/***
 * Java TelnetD library (embeddable telnet daemon)
 * Copyright (c) Dieter Wimberger * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 ***/
package net.wimpi.telnetd.io.toolkit;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;import java.util.ArrayList;import java.util.Stack;

import net.wimpi.telnetd.io.BasicTerminalIO;import net.wimpi.telnetd.io.TerminalIO;import net.wimpi.telnetd.io.terminal.ColorHelper;/** * Provides a <tt>Pager</tt> for output with * paging. * <p/> * If the content fits on a single page no prompt * will occur. Terminal resizing is possible, * but will cause the pages to be rendered and * the pager to start over from the new first page. * </p> * * @author Dieter Wimberger * @version @version@ (@date@); */public class Pager    extends ActiveComponent {  //Members  private BufferedReader m_Source;  private ArrayList m_Pages;  private int m_PageCursor;  private String m_Prompt;  private int m_StopKey;  private boolean m_ShowPos;  private String m_StatusPrompt;  private int m_TermRows = -1;  private int m_TermCols = -1;  private boolean m_PreFormatted = false;  private String m_DefaultFGColor = ColorHelper.GREEN;  private String m_DefaultBGColor;  private StringBuilder m_CurrentPage;  private int m_CurrentPageRows;  /**   * Constructor method for a standard pager.   *   * @param io the {@link BasicTerminalIO} this pager should use.   */  public Pager(BasicTerminalIO io) {    super(io, "Pager", false);    setPrompt(DEFAULT_PROMPT);    setStopKey(DEFAULT_STOPKEY);    terminalGeometryChanged();  }//constructor  /**   * Constructor method for a pager with a prompt set and a default   * stop key.   *   * @param io      the {@link BasicTerminalIO} this pager should use.   * @param prompt  String that represents the paging prompt.   * @param stopKey String that represents the stop key.   */  public Pager(BasicTerminalIO io, String prompt, char stopKey) {    super(io, "Pager");    setPrompt(prompt);    m_StopKey = stopKey;    terminalGeometryChanged();  }//constructor  /**   * Mutator method for the pagers stop key.   *   * @param key char that represents the new stop key.   */  public void setStopKey(char key) {    m_StopKey = (int) key;  }//setStopKey  /**   * Mutator method for the pagers prompt.   *   * @param prompt String that represents the new promptkey.   */  public void setPrompt(String prompt) {    m_Prompt = prompt;  }//setPrompt  /**   * Method to make the pager add pager postion to the prompt.   *   * @param b true if position should be indicated, false otherwise.   */  public void setShowPosition(boolean b) {    m_ShowPos = b;  }//setShowPosition  /**   * Sets the default foreground color.   *   * @param color as String as defined in {@link ColorHelper}.   */  public void setDefaultFGColor(String color) {    m_DefaultFGColor = color;  }//setDefaultFGColor  /**   * Sets the default background color.   *   * @param color as String as defined in {@link ColorHelper}.   */  public void setDefaultBGColor(String color) {    m_DefaultBGColor = color.toLowerCase();  }//setDefaultBGColor  /**   * Tests the flag that indicates if the content is preformatted   * to the terminal width (columns).   *   * @return true if preformatted, false otherwise.   */  public boolean isPreFormatted() {    return m_PreFormatted;  }//isPreFormatted  /**   * Sets the flag that indicates that the content is preformatted   * to the terminal width.   *   * @param preFormatted if preformatted to width, false otherwise.   */  public void setPreFormatted(boolean preFormatted) {    m_PreFormatted = preFormatted;  }//setPreFormatted  /**   * Page the given <tt>String</tt> to the   * associated {@link TerminalIO}.   * <p/>   * If the <tt>String</tt> fits on a single page,   * the method will return immediately.   * </p>   *   * @param str a <tt>String</tt>.   * @throws IOException if an I/O error occurs.   */  public void page(String str) throws IOException {    m_Source = new BufferedReader(new StringReader(str));    run();  }//page  /**   * Page the given <tt>String</tt> to the   * associated {@link TerminalIO}.   * <p/>   * If the <tt>String</tt> fits on a single page,   * the method will return immediately.   * </p>   *   * @param str a <tt>String</tt>.   * @throws IOException if an I/O error occurs.   */  public void pagePreFormatted(String str) throws IOException {    m_Source = new BufferedReader(new StringReader(str));    m_PreFormatted = true;    try {      run();    } finally {      m_PreFormatted = false;    }  }//page  /**   * Page through the given <tt>InputStream</tt> to the   * associated {@link TerminalIO}.   * <p/>   * If the content fits on a single page,   * the method will return immediately.   * Note that a resetable stream is required.   * </p>   *   * @param in an <tt>Inputstream</tt>.   * @throws IOException if an I/O error occurs.   */  public void page(InputStream in)      throws IOException {    m_Source = new BufferedReader(new InputStreamReader(in, "UTF-8"));    run();  }//page(InputStream)  /**   * Runs the pagination mechanism and allows to page the content.   *   * @throws IOException if an I/O error occurs.   */  public void run() throws IOException {    terminalGeometryChanged();    storeAutoflush();    storeLineWrapping();    m_IO.setAutoflushing(false);    m_IO.setLineWrapping(false);    //1. render pages    if (m_PreFormatted) {      simpleRenderPages();    } else {      renderPages();    }    //2. draw single page and return without prompt    if (m_Pages.size() == 1) {      m_IO.write(getPage());      m_IO.flush();      return;    } else {      //draw first page      draw();      m_IO.flush();    }    try {      //storage for read byte      int in = 0;      boolean stopped = false;      do {        //get next key        prompt();        in = m_IO.read();        if (in == BasicTerminalIO.IO_ERROR) {          throw new IOException();        }        //remove prompt        m_IO.eraseToBeginOfLine();        m_IO.moveCursor(            BasicTerminalIO.LEFT,            (int) ColorHelper.getVisibleLength(m_StatusPrompt)        );        switch (in) {          case BasicTerminalIO.UP:            doPreviousPage();            break;          case SPACE:          case BasicTerminalIO.DOWN:            if (!doNextPage()) {              in = -1;            }            break;          default:            //test for stopkey, cant be switched because not constant            if (in == m_StopKey) {              //flag loop over              m_IO.write(BasicTerminalIO.CRLF);              in = -1;              stopped = true;            } else {              m_IO.bell();        }        }//switch        if (!stopped) {          //draw page with geometry check          checkTerminalGeometry();          draw();        }      } while (in != -1);      //flush the last page      m_IO.flush();    } finally {      //close source    m_Source.close();      m_IO.flush();      //restore I/O state      restoreAutoflush();      restoreLineWrapping();      }  }//page(String)  public void draw() throws IOException {    m_IO.write(getPage());    m_IO.write("\001a");    m_IO.flush();  }//draw  private boolean doNextPage() {    if (m_PageCursor < m_Pages.size()) {      m_PageCursor++;    }    return (m_PageCursor < m_Pages.size() - 1);  }//drawNextPage  private void doPreviousPage() throws IOException {    if (m_PageCursor > 0) {      m_PageCursor--;    } else {      m_IO.bell();    }  }//doPreviousPage  private String getPage() {    return (String) m_Pages.get(m_PageCursor);  }//getPage  private void prompt() throws IOException {    //1. update status    updateStatus();    //2. Prompt    //m_IO.write(BasicTerminalIO.CRLF);    m_IO.write(m_StatusPrompt);    m_IO.flush();  }//prompt  private void renderPages() {    //1. Reset cursor    m_PageCursor = 0;    m_Pages = new ArrayList(20);    //2. Prepare empty page    newPage();    String line = "";    while (line != null) {      try {        line = m_Source.readLine();      } catch (IOException ex) {        line = null;      }      if (line != null) {        if (ColorHelper.getVisibleLength(line) <= m_TermCols) {          addLineToPage(line);    } else {          splitAndAddLine(line);        }      } else {        if (m_CurrentPage.length() > 0) {          m_Pages.add(m_CurrentPage.toString());        }      }      }  }//renderPages  private void splitAndAddLine(String line) {      try {      char[] chars = line.toCharArray();      int len = 0;      int lastsplit = 0;      for (int i = 0; i < chars.length; i++) {        char c = chars[i];        if (c == ColorHelper.MARKER_CODE) {          i++; //skip color code        } else {          if (++len >= m_TermCols) {            //1. Search backwards to word boundary            int split = findPreceedingBoundary(chars, i);            addLineToPage(line.substring(lastsplit, split));            //2. Search forward to word boundary if a preceeding boundary was found            if (split < i) {              split = findPosteriorBoundary(chars, split);            }            lastsplit = split;            len = 0;            i = split;        }        }      }      if (lastsplit < line.length()) {        addLineToPage(line.substring(lastsplit));      }    } catch (Exception ex) {      ex.printStackTrace();    }  }//splitLine  private int findPreceedingBoundary(char[] chars, int from) {    for (int i = from; i > 1; i--) {      if (chars[i] == ' '          && Character.isLetterOrDigit(chars[i - 1])          && chars[i - 2] != ColorHelper.MARKER_CODE) {        return i;      }    }    return from;  }//findPreceedingWordBoundary  private int findPosteriorBoundary(char[] chars, int from) {    Stack trimmedMarkup = new Stack();    int to = chars.length - 1;    for (int i = from; i < (to - 1); i++) {      if (chars[i] == ColorHelper.MARKER_CODE && Character.isLetterOrDigit(chars[i + 1])) {        trimmedMarkup.push(new String(chars, i, 2));        if (!Character.isWhitespace(chars[i + 2]) && chars[i + 2] != ColorHelper.MARKER_CODE) {          return i + 2;        }      }      if (chars[i] == ' '          && !Character.isWhitespace(chars[i + 1])          && chars[i + 1] != ColorHelper.MARKER_CODE) {        return i + 1;      }    }    //append trimmed markups    while (!trimmedMarkup.empty()) {      m_CurrentPage.append(trimmedMarkup.pop());    }    return to;  }//findPosterior  private void addLineToPage(String line) {    m_CurrentPage.append(line);    m_CurrentPage.append(BasicTerminalIO.CRLF);    if (++m_CurrentPageRows >= m_TermRows - 1) {      m_Pages.add(m_CurrentPage.toString());      newPage();    }  }//addLineToPage  private void newPage() {    m_CurrentPage = new StringBuilder(m_TermCols * m_TermRows);    appendColors(m_CurrentPage);    m_CurrentPageRows = 0;  }//newPage  private void simpleRenderPages() {    //1. Reset cursor    m_PageCursor = 0;    m_Pages = new ArrayList(20);    //2. Prepare page    newPage();    //3. Lines to pages    String line = "";    while (line != null) {        try {        line = m_Source.readLine();        } catch (IOException ex) {        line = null;        }      if (line != null) {        addLineToPage(line);      } else {        if (m_CurrentPage.length() > 0) {          m_Pages.add(m_CurrentPage.toString());        }        }      }  }//simpleRenderPages  private void appendColors(StringBuilder sbuf) {    if (m_DefaultFGColor != null) {      sbuf.append(ColorHelper.INTERNAL_MARKER).append(m_DefaultFGColor.charAt(0));    }    if (m_DefaultBGColor != null) {      sbuf.append(ColorHelper.INTERNAL_MARKER).append(m_DefaultBGColor.charAt(0));    }  }//appendColors  private void checkTerminalGeometry() {    if (terminalGeometryChanged()) {      try {        m_Source.reset();        renderPages();        m_PageCursor = 0;      } catch (Exception ex) {      }    }  }//checkTerminalGeometry  private boolean terminalGeometryChanged() {    if (m_TermRows != m_IO.getRows() || m_TermCols != m_IO.getColumns()) {      m_TermRows = m_IO.getRows();      m_TermCols = m_IO.getColumns();      return true;    } else {      return false;    }  }//terminalGeometryChanged  private void updateStatus() {    if (m_ShowPos) {      m_StatusPrompt = m_Prompt + " [" + (m_PageCursor + 1) + "/" + m_Pages.size() + "]";    } else {      m_StatusPrompt = m_Prompt;    }  }//updateStatus  /**   * Constant definitions   */  private static final char DEFAULT_STOPKEY = 's';  private static final String DEFAULT_PROMPT = "[Cursor Up,Cursor Down,Space,s (stop)] ";  private static final int SPACE = 32;}//class Pager