/***
 * Java TelnetD library (embeddable telnet daemon)
 * Copyright (c) Dieter Wimberger * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 ***/
package net.wimpi.telnetd.io.toolkit;import java.io.IOException;import java.util.ArrayList;import java.util.Iterator;import java.util.List;

import net.wimpi.telnetd.io.BasicTerminalIO;/** * Class that implements an Editarea. * * @author Dieter Wimberger * @version @version@ (@date@) */public class Editarea    extends ActiveComponent {  private int m_RowCursor = 0;  private int m_Rows = 0;  private boolean m_Firstrun = true;  private int m_FirstVisibleRow = 0;  private boolean m_Softwrapping = true;  private int m_SoftwrapLength;  private String m_HardwrapSequence = "\n";  private List m_Lines;  private OldEditline m_ActiveLine;  public Editarea(BasicTerminalIO io, String name, int rowheight, int maxrows) {    super(io, name);    m_Lines = new ArrayList(200);    m_Rows = maxrows;    m_Firstrun = true;    m_FirstVisibleRow = 0;    m_SoftwrapLength = io.getColumns();    setDimension(new Dimension(m_IO.getColumns(), rowheight));  }//constructor  /**   * Tests if this <tt>Editarea</tt> is does softwrap.   *   * @return true if softwrapping, false otherwise.   */  public boolean isSoftwrapping() {    return m_Softwrapping;  }//isSoftwrapping  /**   * Sets the flag that decides whether this   * <tt>Editarea</tt> does softwrap the input.   *   * @param b true if to do softwrapping, false otherwise.   * @see #getSoftwrapLength()   */  public void setSoftwrapping(boolean b) {    m_Softwrapping = b;  }//setSoftwrapping  /**   * Returns the length in columns the text will be   * softwrapped to.   *   * @return the length at which the text is wrapped as <tt>int</tt>.   */  public int getSoftwrapLength() {    return m_SoftwrapLength;  }//getSoftwrapLength  /**   * Sets the length in columns the text will be   * softwrapped to.   *   * @param wl the length at which the text is softwrapped as <tt>int</tt>   */  public void setSoftwrapLength(int wl) {    m_SoftwrapLength = wl;    //TODO: probably requires rewrapping the text.  }//setSoftwrapLength  /**   * Returns the number of lines in the buffer.   *   * @return the number of lines as <tt>int</tt>.   */  public int getLineCount() {    return m_Lines.size();  }//getLineCount  /**   * Returns the number of characters in the buffer.   *   * @return the number of characters as <tt>int</tt>.   */  public int getCharacterCount() {    int size = 0;    //iterate over buffers and accumulate size    for (Iterator iterator = m_Lines.iterator(); iterator.hasNext();) {      OldEditline editline = (OldEditline) iterator.next();      size += editline.size();    }    return size;  }//getCharacterCount  /**   * Sets the character sequence that will be appended   * in the buffer for a hardwrap.   *   * @param str the character sequence to be appended to the   *            buffer for a hardwrap.   */  public void setHardwrapSequence(String str) {    m_HardwrapSequence = str;  }//setHardwrapSequence  /**   * Returns the character sequence that will be appended   * to the buffer for a hardwrap.   *   * @return the character sequence to be appended to the   *         buffer for a hardwrap.   */  public String getHardwrapSequence() {    return m_HardwrapSequence;  }//getHardwrapSequence  /**   * Returns the content of the buffer of this   * <tt>Editarea</tt>.   *   * @return the buffer content as <tt>String</tt>.   */  public String getValue() {    StringBuffer sbuf = new StringBuffer();    //iterate over buffers and accumulate size    OldEditline el = null;    for (int i = 0; i < m_Lines.size(); i++) {      el = getLine(i);      sbuf.append(el.getValue());      if (el.isHardwrapped()) {        sbuf.append(m_HardwrapSequence);      }    }    return sbuf.toString();  }//getValue  /**   * Sets the content of the buffer of this   * <tt>Editarea</tt>.   * <p/>   * This will clear all former buffer content, and   * require the component to be drawn again.   * </p>   *   * @param str   * @throws BufferOverflowException   */  public void setValue(String str)      throws BufferOverflowException {    clearBuffer();    //split into hardwrapped lines    String[] lines = str.split(getHardwrapSequence());    for (int i = 0; i < lines.length; i++) {      OldEditline el = createLine();      if (isSoftwrapping()) {        str.substring(i, i + getSoftwrapLength());      }    }  }//setValue  public void clear() throws IOException {    clearBuffer();    //Screen    draw();  }//clear  public void run() throws IOException {    //int oldcursor = 0;    boolean done = false;    m_IO.setAutoflushing(false);    //check flag    if (m_Firstrun) {      //reset flag      m_Firstrun = false;      //make a new editline      m_ActiveLine = createLine();      appendLine(m_ActiveLine);    }    do {      //switch return of a m_ActiveLine      switch (m_ActiveLine.run()) {        case BasicTerminalIO.UP:          if (m_RowCursor > 0) {            if (m_FirstVisibleRow == m_RowCursor) {              scrollUp();            } else {              cursorUp();            }          } else {            m_IO.bell();          }          break;        case BasicTerminalIO.DOWN:          if (m_RowCursor < (m_Lines.size() - 1)) {            if (m_RowCursor == m_FirstVisibleRow + (m_Dim.getHeight() - 1)) {              scrollDown();            } else {              cursorDown();            }          } else {            m_IO.bell();          }          break;        case BasicTerminalIO.ENTER:          /*          System.out.println("DEBUG:firstVisibleRow:"+firstVisibleRow);          System.out.println("DEBUG:rowCursor:"+rowCursor);          System.out.println("DEBUG:m_Lines:"+m_Lines.size());          System.out.println("DEBUG:maxRows:"+myRows);          System.out.println("DEBUG:height:"+myDim.getHeight());          */          //ensure exit on maxrows m_ActiveLine          if (m_RowCursor == (m_Rows - 1)) {            done = true;          } else {            if (!hasLineSpace()) {              m_IO.bell();            } else {              String wrap = m_ActiveLine.getHardwrap();              m_ActiveLine.setHardwrapped(true);              if (m_RowCursor == (m_Lines.size() - 1)) {                appendNewLine();              } else {                insertNewLine();              }              //cursor              m_RowCursor++;              //activate new row              activateLine(m_RowCursor);              //set value of new row              try {                m_ActiveLine.setValue(wrap);                m_ActiveLine.setCursorPosition(0);                m_IO.moveLeft(m_ActiveLine.size());              } catch (Exception ex) {              }            }          }          break;        case BasicTerminalIO.TABULATOR:          //set cursor to end of field?          done = true;          break;        case BasicTerminalIO.LEFT:          if (m_RowCursor > 0) {            if (m_FirstVisibleRow == m_RowCursor) {              scrollUp();              m_ActiveLine.setCursorPosition(m_ActiveLine.size());              m_IO.moveRight(m_ActiveLine.size());            } else {              //Cursor              m_RowCursor--;              //buffer              activateLine(m_RowCursor);              m_ActiveLine.setCursorPosition(m_ActiveLine.size());              //screen              m_IO.moveUp(1);              m_IO.moveRight(m_ActiveLine.size());            }          } else {            m_IO.bell();          }          break;        case BasicTerminalIO.RIGHT:          if (m_RowCursor < (m_Lines.size() - 1)) {            if (m_RowCursor == m_FirstVisibleRow + (m_Dim.getHeight() - 1)) {              m_ActiveLine.setCursorPosition(0);              m_IO.moveLeft(m_ActiveLine.size());              scrollDown();            } else {              //Cursor              m_RowCursor++;              //screen horizontal              m_IO.moveLeft(m_ActiveLine.size());              //buffer              activateLine(m_RowCursor);              m_ActiveLine.setCursorPosition(0);              //screen              m_IO.moveDown(1);            }          } else {            m_IO.bell();          }          break;        case BasicTerminalIO.BACKSPACE:          if (m_RowCursor == 0 || m_ActiveLine.size() != 0 || m_RowCursor == m_FirstVisibleRow) {            m_IO.bell();          } else {            //take m_ActiveLine from buffer            //and draw update all below            removeLine();          }          break;        default:          if (!hasLineSpace()) {            m_IO.bell();          } else {//            String wrap = m_ActiveLine.getSoftwrap();            //System.out.println("softwrap:"+wrap);            m_ActiveLine.setHardwrapped(false);            if (m_RowCursor == (m_Lines.size() - 1)) {              appendNewLine();            } else {              insertNewLine();            }            //cursor            m_RowCursor++;            //activate new row            activateLine(m_RowCursor);            //set value of new row            try {              //m_ActiveLine.setValue(wrap);              //getLine(rowCursor-1).getLastRelPos();              //m_ActiveLine.setCursorPosition(0);              //myIO.moveLeft(m_ActiveLine.size());            } catch (Exception ex) {            }          }      }      m_IO.flush();    } while (!done);  }//run  private void scrollUp() throws IOException {    int horizontalpos = m_ActiveLine.getCursorPosition();    //System.out.println("Debug:scrolling:up:horpos:"+horizontalpos);    //System.out.println("Debug:scrolling:up");    //Cursors    m_FirstVisibleRow--;    m_RowCursor--;    //buffer    activateLine(m_RowCursor);    m_ActiveLine.setCursorPosition(horizontalpos);    //screen    //horizontal    //content:    int lasthorizontal = horizontalpos;    int count = 0;    for (int i = m_FirstVisibleRow; i < (m_FirstVisibleRow + m_Dim.getHeight()) && i < m_Lines.size(); i++) {      //System.out.println("Debug:scrolling:up:drawing m_ActiveLine "+i);      m_IO.moveLeft(lasthorizontal);      OldEditline lin = (OldEditline) m_Lines.get(i);      lasthorizontal = lin.size();      m_IO.eraseToEndOfLine();      m_IO.write(lin.getValue());      m_IO.moveDown(1);      count++;    }    //vertical:    m_IO.moveUp(count);    //horizontal:    if (lasthorizontal > horizontalpos) {      m_IO.moveLeft(lasthorizontal - horizontalpos);    } else if (lasthorizontal < horizontalpos) {      m_IO.moveRight(horizontalpos - lasthorizontal);    }    if (horizontalpos > m_ActiveLine.getCursorPosition()) {      m_IO.moveLeft(horizontalpos - m_ActiveLine.getCursorPosition());    }  }//scrollUp  private void cursorUp() throws IOException {    //System.out.println("Debug:cursor:up");    int horizontalpos = m_ActiveLine.getCursorPosition();    //Cursor    m_RowCursor--;    //buffer    activateLine(m_RowCursor);    m_ActiveLine.setCursorPosition(horizontalpos);    //screen    //vertical    m_IO.moveUp(1);    //horizontal    if (horizontalpos > m_ActiveLine.getCursorPosition()) {      m_IO.moveLeft(horizontalpos - m_ActiveLine.getCursorPosition());    }  }//cursorUp  private void scrollDown() throws IOException {    //System.out.println("Debug:scrolling:down");    int horizontalpos = m_ActiveLine.getCursorPosition();    //Cursors    m_FirstVisibleRow++;    m_RowCursor++;    //buffer    activateLine(m_RowCursor);    m_ActiveLine.setCursorPosition(horizontalpos);    //screen    //vertical:    m_IO.moveUp(m_Dim.getHeight() - 1);    //content:    int lasthorizontal = horizontalpos;    for (int i = m_FirstVisibleRow; i < (m_FirstVisibleRow + m_Dim.getHeight()); i++) {      //System.out.println("Debug:scrolling:up:drawing m_ActiveLine "+i);      m_IO.moveLeft(lasthorizontal);      OldEditline lin = (OldEditline) m_Lines.get(i);      lasthorizontal = lin.size();      m_IO.eraseToEndOfLine();      m_IO.write(lin.getValue());      m_IO.moveDown(1);    }    //correct move down and last write    m_IO.moveUp(1);    //horizontal:    if (lasthorizontal > horizontalpos) {      m_IO.moveLeft(lasthorizontal - horizontalpos);    } else if (lasthorizontal < horizontalpos) {      m_IO.moveRight(horizontalpos - lasthorizontal);    }    if (horizontalpos > m_ActiveLine.getCursorPosition()) {      m_IO.moveLeft(horizontalpos - m_ActiveLine.getCursorPosition());    }  }//scrollDown  private void cursorDown() throws IOException {    //System.out.println("Debug:cursor:down");    int horizontalpos = m_ActiveLine.getCursorPosition();    //Cursor    m_RowCursor++;    //buffer    activateLine(m_RowCursor);    m_ActiveLine.setCursorPosition(horizontalpos);    //screen    m_IO.moveDown(1);    if (horizontalpos > m_ActiveLine.getCursorPosition()) {      m_IO.moveLeft(horizontalpos - m_ActiveLine.getCursorPosition());    }  }//cursorDown  private void appendNewLine() throws IOException {    //System.out.println("Debug:appendline");    //buffer    appendLine(createLine());    if (m_RowCursor == m_FirstVisibleRow + (m_Dim.getHeight() - 1)) {      //System.out.println("Debug:appendline:scroll");      //this will "scroll"      m_FirstVisibleRow++;      //System.out.println("Debug:appendline:scroll:firstvis:"+firstVisibleRow);      //System.out.println("Debug:appendline:scroll:rowCursor:"+rowCursor);      //System.out.println("Debug:appendline:scroll:movevert:"+(myDim.getHeight()-1));      //vertical      m_IO.moveUp(m_Dim.getHeight() - 1);      m_IO.moveLeft(m_ActiveLine.getCursorPosition());      //content      //int lasthorizontal = m_ActiveLine.getCursorPosition();      for (int i = m_FirstVisibleRow; i < (m_FirstVisibleRow + m_Dim.getHeight()); i++) {        //System.out.println("Debug:appendline:scroll:m_ActiveLine:"+i);        OldEditline lin = (OldEditline) m_Lines.get(i);        m_IO.eraseToEndOfLine();        m_IO.write(lin.getValue());        m_IO.moveLeft(lin.size());        m_IO.moveDown(1);      }      //correct the move to down in last place      m_IO.moveUp(1);    } else {      //System.out.println("Debug:appendline:NOscroll");      //this wont need a scroll redraw      m_IO.moveLeft(m_ActiveLine.getCursorPosition());      m_IO.moveDown(1);    }  }//appendNewLine  private void insertNewLine() throws IOException {    //System.out.println("Debug:insertline:");    //buffer    insertLine(m_RowCursor + 1, createLine());    if (m_RowCursor == m_FirstVisibleRow + (m_Dim.getHeight() - 1)) {      //System.out.println("Debug:insertline:scroll");      //this will "scroll"      m_FirstVisibleRow++;      //System.out.println("Debug:insertline:scroll:firstvis:"+firstVisibleRow);      //System.out.println("Debug:appendline:scroll:rowCursor:"+rowCursor);      //System.out.println("Debug:appendline:scroll:movevert:"+(myDim.getHeight()-1));      //vertical      m_IO.moveUp(m_Dim.getHeight() - 1);      //content      int lasthorizontal = m_ActiveLine.getCursorPosition();      for (int i = m_FirstVisibleRow; i < (m_FirstVisibleRow + m_Dim.getHeight()); i++) {        //System.out.println("Debug:appendline:scroll:m_ActiveLine:"+i);        m_IO.moveLeft(lasthorizontal);        OldEditline lin = (OldEditline) m_Lines.get(i);        lasthorizontal = lin.size();        m_IO.eraseToEndOfLine();        m_IO.write(lin.getValue());        m_IO.moveDown(1);      }      //correct the move to down in last place      m_IO.moveUp(1);    } else {      //System.out.println("Debug:insertline:NOscroll");      //we have to redraw any m_ActiveLine below rowCursor+1 anyway      m_IO.moveDown(1);      m_IO.moveLeft(m_ActiveLine.getCursorPosition());      int count = 0;      for (int i = m_RowCursor + 1; i < (m_FirstVisibleRow + m_Dim.getHeight()) && i < m_Lines.size(); i++) {        //System.out.println("Debug:insertline:redrawing m_ActiveLine:"+i);        m_IO.eraseToEndOfLine();        OldEditline lin = (OldEditline) m_Lines.get(i);        m_IO.write(lin.getValue());        m_IO.moveLeft(lin.size());        m_IO.moveDown(1);        count++;      }      m_IO.moveUp(count);    }  }//insertNewLine  private void removeLine() throws IOException {    //buffer    deleteLine(m_RowCursor);    activateLine(m_RowCursor - 1);    //Cursor    m_RowCursor--;    //Screen    //content redraw    //int lasthorizontal = 0;    int count = 0;    for (int i = m_RowCursor + 1; i < (m_FirstVisibleRow + m_Dim.getHeight()); i++) {      if (i < m_Lines.size()) {        //System.out.println("Debug:removeline:redrawing m_ActiveLine:"+i);        m_IO.eraseToEndOfLine();        OldEditline lin = (OldEditline) m_Lines.get(i);        m_IO.write(lin.getValue());        m_IO.moveLeft(lin.size());        m_IO.moveDown(1);        count++;      } else {        m_IO.eraseToEndOfLine();        m_IO.moveDown(1);        count++;      }    }    //cursor readjustment    //vertical    m_IO.moveUp(count + 1);    //horizontal    m_ActiveLine.setCursorPosition(m_ActiveLine.size());    m_IO.moveRight(m_ActiveLine.size());  }//removeLine  public void draw() throws IOException {    if (m_Location != null) {      m_IO.setCursor(m_Location.getRow(), m_Location.getColumn());      int count = 0;      for (int i = m_FirstVisibleRow; i < (m_FirstVisibleRow + m_Dim.getHeight()) && i < m_Lines.size(); i++) {        m_IO.eraseToEndOfLine();        OldEditline lin = (OldEditline) m_Lines.get(i);        m_IO.write(lin.getValue());        m_IO.moveLeft(lin.size());        m_IO.moveDown(1);        count++;      }      int corr = (m_FirstVisibleRow + count) - m_RowCursor;      if (corr > 0) {        m_IO.moveUp(corr);      }    }    m_IO.flush();  }//draw  private void activateLine(int pos) {    m_ActiveLine = getLine(pos);  }//activateLine  private boolean hasLineSpace() {    return (m_Lines.size() < m_Rows);  }//hasLineSpace  private OldEditline createLine() {    return new OldEditline(m_IO, m_Softwrapping);  }//newLine  private void deleteLine(int pos) {    m_Lines.remove(pos);  }//deleteLine  private void insertLine(int pos, OldEditline el) {    m_Lines.add(pos, el);  }//insertLine  private void appendLine(OldEditline el) {    m_Lines.add(el);  }//appendLine  private OldEditline getLine(int pos) {    return (OldEditline) m_Lines.get(pos);  }//getLine  private void clearBuffer() {    m_Lines.clear();    m_RowCursor = 0;  }//clearBuffer}//class Editarea