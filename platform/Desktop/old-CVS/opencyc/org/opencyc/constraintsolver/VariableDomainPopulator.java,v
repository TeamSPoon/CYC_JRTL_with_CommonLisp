head	1.9;
access;
symbols
	PRE_1_0:1.8;
locks; strict;
comment	@# @;


1.9
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.23.02.59.02;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.17.23.44.19;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.13.56.34;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.06.14.49.47;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.05.22.59.00;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.04.23.57.47;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.constraintsolver;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.inferencesupport.Binding;
import org.opencyc.inferencesupport.ConstraintRule;
import org.opencyc.inferencesupport.UnitTest;

/**
 * <tt>VariableDomainPopulator</tt> object to contain information about variables
 * and applicable rules, and which determines the best rule to populate each
 * variable.  For high cardinality variables, which are those variables having
 * a domain size exceeding a high cardinality threshold, the domain population is
 * typically postponed until the forward checking search has instantiated enough
 * other variables so that the high cardinality variable's domain is more efficiently
 * obtained from the KB.<p>
 *
 * @@version $Id: VariableDomainPopulator.java,v 1.8 2002/04/23 02:59:02 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class VariableDomainPopulator {
    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Reference to the parent <tt>ValueDomains</tt> object.
     */
    protected ValueDomains valueDomains;

    /**
     * Reference to the parent list of domain populating constraint rules.
     */
    protected ArrayList domainPopulationRules;

    /**
     * Reference to the parent list of constraint rules.
     */
    protected ArrayList constraintRules;

    /**
     * List of <tt>VariablePopulation</tt> objects used to determine the best domain population rule
     * for each variable.
     */
    protected ArrayList candidateVariablePopulators = new ArrayList();

    /**
     * The default value of the variable value domain size beyond which the initial values are not
     * all fetched from the KB.
     */
    public static final int DEFAULT_DOMAIN_SIZE_THRESHOLD = 50;

    /**
     * The value of the variable value domain size beyond which the initial values are not
     * all fetched from the KB.
     */
    protected int domainSizeThreshold = DEFAULT_DOMAIN_SIZE_THRESHOLD;

    /**
     * variable --> VariableDomainPopulator<br>
     */
    protected HashMap variableDomainPopulators = new HashMap();

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Constructs a new <tt>VariableDomainPopulator</tt> object.
     */
    public VariableDomainPopulator(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
        this.domainPopulationRules = new ArrayList();
        constraintProblem.domainPopulationRules = this.domainPopulationRules;
        this.constraintRules = new ArrayList();
        constraintProblem.constraintRules = this.constraintRules;
        this.valueDomains = constraintProblem.valueDomains;
    }

    /**
     * Adds the given <tt>VariablePopulationItem</tt> object to the list
     * of variable populator items.  Each item contains a variable, an applicable
     * rule, and the number of values that rule would yield if asked in the KB.
     */
    public void add(VariablePopulationItem variablePopulationItem) {
        this.candidateVariablePopulators.add(variablePopulationItem);
    }

    /**
     * Determines the best domain population rule to populate each constraint problem variable, and populates
     * those which do not exceed the domain size threshold.
     */
    public void populateDomains() throws IOException, CycApiException {
        Collections.sort(candidateVariablePopulators);
        for (int i = 0; i < candidateVariablePopulators.size(); i++) {
            VariablePopulationItem variablePopulationItem =
                (VariablePopulationItem) candidateVariablePopulators.get(i);
            if (verbosity > 3)
                System.out.println("Considering candidate domain population for " +
                                   variablePopulationItem.cycVariable.cyclify() +
                                   "\n  " + variablePopulationItem.rule +
                                   "\n  which has " + variablePopulationItem.getNbrFormulaInstances() + " instances");

            if ((variablePopulationItem.rule.getArity() > 1) &&
                (! constraintRules.contains(variablePopulationItem.rule)))
                constraintRules.add(variablePopulationItem.rule);

            if (i == 0) {
                if (verbosity > 3)
                    System.out.println("  First variable must always be populated");
                variableDomainPopulators.put(variablePopulationItem.cycVariable, variablePopulationItem);
                domainPopulationRules.add(variablePopulationItem.rule);
                valueDomains.varsDictionary.put(variablePopulationItem.cycVariable, new ArrayList());
                initializeDomain(variablePopulationItem);
                continue;
            }
            if (variableDomainPopulators.containsKey(variablePopulationItem.cycVariable)) {
                if (verbosity > 3)
                    System.out.println("  Variable already has the best domain populating rule");
                if (! constraintRules.contains(variablePopulationItem.rule))
                    constraintRules.add(variablePopulationItem.rule);
                continue;
            }
            if (variablePopulationItem.getNbrFormulaInstances() > domainSizeThreshold) {
                if (verbosity > 3)
                    System.out.println("  ConstraintRule's domain size exceeds the threshold of " + domainSizeThreshold +
                                       ", domain population postponed");
                variableDomainPopulators.put(variablePopulationItem.cycVariable, variablePopulationItem);
                valueDomains.varsDictionary.put(variablePopulationItem.cycVariable, new ArrayList());
                continue;
            }
            if (verbosity > 3)
                System.out.println("  Will populate using this rule");
            domainPopulationRules.add(variablePopulationItem.rule);
            variableDomainPopulators.put(variablePopulationItem.cycVariable, variablePopulationItem);
            valueDomains.varsDictionary.put(variablePopulationItem.cycVariable, new ArrayList());
            initializeDomain(variablePopulationItem);
        }
        if (verbosity > 1)
            valueDomains.displayVariablesAndDomains();
    }

    /**
     * Returns <tt>true</tt> iff this variable's domain is too large for efficient
     * processing.  The constraint solver will employ other rules to populate
     * domain values via OpenCyc KB queries.
     *
     * @@param cycVariable the variable under consideration
     * @@return <tt>true</tt> iff this variable's domain is too large for efficient
     * processing
     */
    public boolean isPostponedHighCardinalityDomain(CycVariable cycVariable) {
        VariablePopulationItem variablePopulationItem =
            (VariablePopulationItem) variableDomainPopulators.get(cycVariable);
        boolean answer = variablePopulationItem.getNbrFormulaInstances() > domainSizeThreshold;
        if (verbosity > 8)
            System.out.println("\nhigh cardinality domain for " + cycVariable + " --> " + answer);
        return answer;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Returns <tt>true</tt> iff the given <tt>ConstraintRule</tt> was used to populate the domain
     * of the given high cardinality variable.
     *
     * @@param rule the rule under consideration
     * @@param cycVariable the variable under consideration
     * @@return <tt>true</tt> iff the given <tt>ConstraintRule</tt> was used to populate the domain
     * of the given high cardinality variable
     */
    public boolean isPopulatingRule(ConstraintRule rule, CycVariable cycVariable) {
        return rule.equals(getPopulatingRule(cycVariable));
    }

    /**
     * Sets the domain size threshold, beyond which the population of a
     * variable's domain is typically postponed until the forward checking
     * search.
     *
     * @@param domainSizeThreshold domain size threshold
     */
    public void setDomainSizeThreshold(int domainSizeThreshold) {
        this.domainSizeThreshold = domainSizeThreshold;
    }

    /**
     * Gets the domain size of the high cardinality variable.
     *
     * @@param cycVariable the variable under consideration
     * @@return <tt>int</tt> the domain size of the high cardinality variable
     */
    public int getDomainSize(CycVariable cycVariable) {
        VariablePopulationItem variablePopulationItem =
            (VariablePopulationItem) variableDomainPopulators.get(cycVariable);
        return variablePopulationItem.getNbrFormulaInstances();
    }

    /**
     * Sets the domain-populating <tt>ConstraintRule</tt> of the high cardinality variable.
     *
     * @@param cycVariable the high-cardinality variable under consideration
     * @@parma rule the domain-populating rule
     */
    public void setPopulatingRule(CycVariable cycVariable, ConstraintRule rule) {
        VariablePopulationItem variablePopulationItem =
            (VariablePopulationItem) variableDomainPopulators.get(cycVariable);
        variablePopulationItem.rule = rule;
        if (verbosity > 8)
            System.out.println("\nset high cardinality populating rule for " +
                               cycVariable.cyclify() + " to " + rule.cyclify());
    }

    /**
     * Gets the domain-populating <tt>ConstraintRule</tt> of the high cardinality variable.
     *
     * @@param cycVariable the variable under consideration
     * @@return the domain-populating <tt>ConstraintRule</tt> of the high cardinality variable
     */
    public ConstraintRule getPopulatingRule(CycVariable cycVariable) {
        VariablePopulationItem variablePopulationItem =
            (VariablePopulationItem) variableDomainPopulators.get(cycVariable);
        return variablePopulationItem.rule;
    }

    /**
     * Populates the domain by asking a query.
     *
     * @@param rule the query to asked in the KB
     * @@param cycVariable the variable whose value domain is to be populated by the results of the query
     *
     */
    protected void populateDomainViaQuery(ConstraintRule rule, CycVariable cycVariable)
        throws IOException, CycApiException {
        CycList domainValuesCycList =
            CycAccess.current().askWithVariable (rule.getFormula(),
                                                 cycVariable,
                                                 constraintProblem.mt);
        ArrayList domainValues = new ArrayList();
        domainValues.addAll(domainValuesCycList);
        constraintProblem.valueDomains.varsDictionary.put(cycVariable, domainValues);
    }

    /**
     * Initializes the value domain for each variable.
     *
     * @@param variablePopulationItem the <tt>VariablePopulationItem</tt> object which contains the variable
     * and its domain populating rule
     */
    public void initializeDomain(VariablePopulationItem variablePopulationItem)
        throws IOException, CycApiException {
        CycVariable cycVariable = variablePopulationItem.cycVariable;
        ConstraintRule rule = variablePopulationItem.rule;
        if (valueDomains.domains.containsKey(cycVariable))
            throw new RuntimeException("Duplicate domain specifying rule for " +
                                       cycVariable);
        if (rule.isExtensionalVariableDomainPopulatingConstraintRule()) {
            valueDomains.domains.put(cycVariable, null);
            CycList theSet =  (CycList) rule.getFormula().third();
            if (! (theSet.first().toString().equals("TheSet")))
                throw new RuntimeException("Invalid TheSet entry for " + cycVariable);
            ArrayList domainValues = new ArrayList((CycList) theSet.rest());
            valueDomains.varsDictionary.put(cycVariable, domainValues);
        }
        else if (rule.getArity() == 1) {
            populateDomainViaQuery(rule, cycVariable);
        }
        else {
            CycList resultSet =
                CycAccess.current().askWithVariables(rule.getFormula(),
                                                     rule.getVariables(),
                                                     constraintProblem.mt);
            for (int i = 0; i < rule.getVariables().size(); i++) {
                if (rule.getVariables().get(i).equals(cycVariable)) {
                    ArrayList domainValues = new ArrayList();
                    for (int k = 0; k < resultSet.size(); k++) {
                        CycList resultItem = (CycList) resultSet.get(k);
                        domainValues.add(resultItem.get(i));
                    }
                    valueDomains.varsDictionary.put(cycVariable, domainValues);
                    break;
                }
            }
        }
    }

    /**
     * Populates the domain of an postponed high cardinality variable, using the previously
     * determined best value domain population rule.
     *
     * @@param variable the variable whose value domain is to be populated
     */
    protected void populatePostponedDomain (CycVariable variable)
        throws IOException, CycApiException {
        VariablePopulationItem variablePopulationItem =
            (VariablePopulationItem) variableDomainPopulators.get(variable);
        ConstraintRule rule = variablePopulationItem.rule;
        if (verbosity > 2)
            System.out.println("Populating high cardinality variable " + variable +
                               "\n  with rule\n" + rule.cyclify());
        ArrayList permittedValues = null;
        if (rule.getArity() == 1)
            permittedValues =
                CycAccess.current().askWithVariable(rule.getFormula(), variable, constraintProblem.mt);
        else {
            CycList resultSet =
                CycAccess.current().askWithVariables(rule.getFormula(), rule.getVariables(), constraintProblem.mt);
            for (int i = 0; i < rule.getVariables().size(); i++) {
                if (rule.getVariables().get(i).equals(variable)) {
                    permittedValues = new ArrayList();
                    for (int k = 0; k < resultSet.size(); k++) {
                        CycList resultItem = (CycList) resultSet.get(k);
                        permittedValues.add(resultItem.get(i));
                    }
                    break;
                }
            }
        }
        for (int i = 0; i < permittedValues.size(); i++) {
            Object value = permittedValues.get(i);
            Binding binding = new Binding(variable, value);
            if (verbosity > 2)
                System.out.println("  " + binding.cyclify() +
                                   " is new");
            valueDomains.addDomainValue(variable, value);
            valueDomains.markDomain(variable, value, Boolean.TRUE);
        }
    }

}@


1.8
log
@Fixed bug in CycList.rest() method where it did not return the
dotted element in a dotted pair list.  Wide impact because the
function signature changed from CycList to Object.
@
text
@d3 12
a14 5
import java.util.*;
import java.io.*;
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.api.*;
d25 1
a25 1
 * @@version $Id: VariableDomainPopulator.java,v 1.7 2001/10/17 23:44:19 stephenreed Exp $
@


1.7
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@d18 1
a18 1
 * @@version $Id: VariableDomainPopulator.java,v 1.6 2001/09/11 13:56:34 stephenreed Exp $
d293 1
a293 1
            ArrayList domainValues = new ArrayList(theSet.rest());
@


1.6
log
@Removing domain population logic from the constraint solver, having moved that behavior to the query processor.
@
text
@d18 1
a18 1
 * @@version $Id: VariableDomainPopulator.java,v 1.5 2001/09/06 21:43:25 stephenreed Exp $
d116 1
a116 1
    public void populateDomains() throws IOException {
d264 2
a265 1
    protected void populateDomainViaQuery(ConstraintRule rule, CycVariable cycVariable) throws IOException {
d281 2
a282 1
    public void initializeDomain(VariablePopulationItem variablePopulationItem) throws IOException {
d324 2
a325 1
    protected void populatePostponedDomain (CycVariable variable) throws IOException {
@


1.5
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d18 1
a18 1
 * @@version $Id: VariableDomainPopulator.java,v 1.4 2001/09/06 14:49:47 stephenreed Exp $
a270 16

        if (constraintProblem.backchainer.maxBackchainDepth >
            constraintProblem.backchainer.backchainDepth) {
            if (verbosity > 3)
                System.out.println("maxBackchainDepth " +
                                   constraintProblem.backchainer.maxBackchainDepth +
                                   " > " + constraintProblem.backchainer.backchainDepth +
                                   "\n  for rule\n" + rule);
            ArrayList backchainDomainValues =
                constraintProblem.backchainer.backchain(rule,
                                                        constraintProblem.variables,
                                                        constraintProblem.mt);
            if (verbosity > 3)
                System.out.println("Adding backchain domain values " + backchainDomainValues +
                                   "\n  for " + cycVariable);
        }
@


1.4
log
@Renamed Rule to ConstraintRule, moved QueryLiteral class to inferencesupport.
@
text
@d6 1
d18 1
a18 1
 * @@version $Id: VariableDomainPopulator.java,v 1.3 2001/09/05 22:59:00 stephenreed Exp $
d279 4
a282 1
            ArrayList backchainDomainValues = constraintProblem.backchainer.backchain(rule);
d302 1
a302 1
        if (rule.isExtensionalVariableDomainPopulatingRule()) {
d315 4
a318 2
                CycAccess.current().askWithVariables(rule.formula, rule.variables, constraintProblem.mt);
            for (int i = 0; i < rule.variables.size(); i++) {
d348 1
a348 1
                CycAccess.current().askWithVariable(rule.formula, variable, constraintProblem.mt);
d351 2
a352 2
                CycAccess.current().askWithVariables(rule.formula, rule.variables, constraintProblem.mt);
            for (int i = 0; i < rule.variables.size(); i++) {
@


1.3
log
@Reworking population of high cardinality domains
@
text
@d17 1
a17 1
 * @@version $Id: VariableDomainPopulator.java,v 1.2 2001/09/04 23:57:47 stephenreed Exp $
d148 1
a148 1
                    System.out.println("  Rule's domain size exceeds the threshold of " + domainSizeThreshold +
d194 1
a194 1
     * Returns <tt>true</tt> iff the given <tt>Rule</tt> was used to populate the domain
d199 1
a199 1
     * @@return <tt>true</tt> iff the given <tt>Rule</tt> was used to populate the domain
d202 1
a202 1
    public boolean isPopulatingRule(Rule rule, CycVariable cycVariable) {
d230 1
a230 1
     * Sets the domain-populating <tt>Rule</tt> of the high cardinality variable.
d235 1
a235 1
    public void setPopulatingRule(CycVariable cycVariable, Rule rule) {
d245 1
a245 1
     * Gets the domain-populating <tt>Rule</tt> of the high cardinality variable.
d248 1
a248 1
     * @@return the domain-populating <tt>Rule</tt> of the high cardinality variable
d250 1
a250 1
    public Rule getPopulatingRule(CycVariable cycVariable) {
d263 1
a263 1
    protected void populateDomainViaQuery(Rule rule, CycVariable cycVariable) throws IOException {
d294 1
a294 1
        Rule rule = variablePopulationItem.rule;
d335 1
a335 1
        Rule rule = variablePopulationItem.rule;
@


1.2
log
@Continued refactoring domain population methods.
@
text
@d17 1
a17 1
 * @@version $Id: VariableDomainPopulator.java,v 1.1 2001/09/04 14:30:23 stephenreed Exp $
d95 4
a98 2
        this.domainPopulationRules = constraintProblem.domainPopulationRules;
        this.constraintRules = constraintProblem.constraintRules;
d125 5
d136 1
d142 2
a143 1
                constraintRules.add(variablePopulationItem.rule);
a149 1
                variablePopulationItem.rule = null;
d156 4
a159 2
                domainPopulationRules.add(variablePopulationItem.rule);
                valueDomains.varsDictionary.put(variablePopulationItem.cycVariable, new ArrayList());
d161 2
d287 4
a290 1
     * Initializes the value domains for each variable.
d292 30
a321 16
    public void initializeDomains() throws IOException {
        for (int i = 0; i < domainPopulationRules.size(); i++) {
            Rule rule = (Rule) domainPopulationRules.get(i);
            if (rule.isExtensionalVariableDomainPopulatingRule()) {
                CycVariable cycVariable = (CycVariable) rule.getVariables().get(0);
                if (valueDomains.domains.containsKey(cycVariable))
                    throw new RuntimeException("Duplicate domain specifying rule for " +
                                               cycVariable);
                valueDomains.domains.put(cycVariable, null);
                if (valueDomains.varsDictionary.containsKey(cycVariable))
                    throw new RuntimeException("Duplicate varsDictionary entry for " + cycVariable);
                CycList theSet =  (CycList) rule.getFormula().third();
                if (! (theSet.first().toString().equals("TheSet")))
                    throw new RuntimeException("Invalid TheSet entry for " + cycVariable);
                ArrayList domainValues = new ArrayList(theSet.rest());
                valueDomains.varsDictionary.put(cycVariable, domainValues);
d323 2
a324 7
            else if (rule.getArity() == 1) {
                CycVariable cycVariable = (CycVariable) rule.getVariables().get(0);
                populateDomainViaQuery(rule, cycVariable);
            }
            else {

                //TODO handle domain population for arity > 1
d326 29
d357 9
a365 2
        if (verbosity > 1)
            valueDomains.displayVariablesAndDomains();
@


1.1
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d3 2
d6 1
a6 1
import java.util.*;
d17 1
a17 1
 * @@version $Id: VariableDomainPopulator.java,v 1.4 2001/08/16 14:25:27 stephenreed Exp $
d41 19
d65 1
a65 1
    protected ArrayList variablePopulations = new ArrayList();
d80 1
a80 9
     * variable --> item<br>
     * where item is the object array
     * {<tt>Integer</tt> domain size, domain populating <tt>Rule</tt>}<p>
     *
     * Dictionary of items describing whether the domain of the key
     * variable is too large to handle efficiently.  For high cardinality
     * domains, the domain size is determined from the KB without asking
     * for all of the values.  For variables not exceeding the <tt>domainSizeThreshold</tt>,
     * the dictionary contains a value of <tt>null</tt>.
d82 1
a82 1
    protected HashMap highCardinalityDomains = new HashMap();
d93 5
a97 1
    public VariableDomainPopulator() {
d102 1
a102 1
     * of variable population items.  Each item contains a variable, an applicable
d106 1
a106 1
        this.variablePopulations.add(variablePopulationItem);
a108 1

d110 2
a111 5
     * Initializes the high cardinality domain item for the given constraint variable.
     * where item is the object array
     * {<tt>Integer</tt> domain size, domain populating <tt>Rule</tt>}
     *
     * @@param cycVariable the variable under consideration
d113 38
a150 3
    public void initialize(CycVariable cycVariable) {
        Object[] item = {null, null};
        highCardinalityDomains.put(cycVariable, item);
d154 1
a154 2
     * Returns <tt>true</tt> iff this variable's domain was specified via an #$isa
     * domain population rule, and this variables domain is too large for efficient
d159 1
a159 2
     * @@return <tt>true</tt> iff this variable's domain was specified via an #$isa
     * domain population rule, and this variables domain is too large for efficient
d162 4
a165 2
    public boolean contains(CycVariable cycVariable) {
        boolean answer = highCardinalityDomains.containsKey(cycVariable);
a194 16
     * Sets the domain size of the high cardinality variable.
     *
     * @@param cycVariable the high cardinality variable under consideration
     * @@param size the new domain size of the high cardinality variable
     */
    public void setDomainSize(CycVariable cycVariable, Integer size) {
        if (! contains(cycVariable))
            this.initialize(cycVariable);
        Object[] item = (Object[]) highCardinalityDomains.get(cycVariable);
        item[0] = size;
        if (verbosity > 8)
            System.out.println("\nset high cardinality domain for " +
                               cycVariable + " to " + size);
    }

    /**
d212 3
a214 2
        Object[] item = (Object[]) highCardinalityDomains.get(cycVariable);
        return ((Integer) item[0]).intValue();
d224 3
a226 4
        if (! contains(cycVariable))
            this.initialize(cycVariable);
        Object[] item = (Object[]) highCardinalityDomains.get(cycVariable);
        item[1] = rule;
d239 33
a271 2
        Object[] item = (Object[]) highCardinalityDomains.get(cycVariable);
        return (Rule) item[1];
d273 35
@

