head	1.7;
access;
symbols
	PRE_1_0:1.7;
locks; strict;
comment	@# @;


1.7
date	2001.09.06.13.55.07;	author stephenreed;	state dead;
branches;
next	1.6;

1.6
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.16.14.25.27;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.10.22.22.00;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.31.20.37.40;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.31.13.19.02;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Added inferencesupport and queryprocessor packages, refactored support classes among them.
@
text
@package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import java.util.*;

/**
 * <tt>Solution</tt> object to model the attributes and behavior of
 * solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: Solution.java,v 1.6 2001/09/04 14:30:23 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class Solution {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Number of solutions found by the search.  Will not be more than the
     * number requested if <tt>nbrSolutionsRequested</tt> is not <tt>null</tt>.
     */
    protected int nbrSolutionsFound = 0;

    /**
     * List of solutions where each solution is a list of constraint variable -
     * domain value bindings which satisfy all the constraint rules.  Newest
     * solution is at the end of the list.
     */
    protected ArrayList solutions = new ArrayList();

    /**
     * Constructs a new <tt>Solution</tt> object given the parent <tt>ConstraintProblem</tt>
     * object.  Initializes the solutions to a single empty solution.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public Solution(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
        solutions = new ArrayList();
        addSolution(new ArrayList());
    }

    /**
     * Adds the variable / value binding to the current solution.
     *
     * @@param binding the variable / value binding to be added
     */
    public void addBindingToCurrentSolution(Binding binding) {
        getCurrentSolution().add(binding);
    }

    /**
     * Removes the variable / value binding from the current solution.
     *
     * @@param binding the variable / value binding to be removed
     */
    public void removeBindingFromCurrentSolution(Binding binding) {
        getCurrentSolution().remove(binding);
    }

    /**
     * Adds a new solution to the solution set.  The added
     * solution becomes the current solution.
     *
     * @@param the new solution <tt>ArrayList</tt> of <tt>Binding</tt> objects
     * to be added to the solution set
     */
    public void addSolution(ArrayList solution) {
        solutions.add(solution);
    }

    /**
     * Returns the current solution.
     *
     * @@return the current solution
     */
    public ArrayList getCurrentSolution() {
        return (ArrayList) solutions.get(solutions.size() - 1);
    }

    /**
     * Returns all solutions.
     *
     * @@return the <tt>ArrayList</tt> of solutions, each solution is an <tt>ArrayList</tt>
     * of <tt>Binding</tt> objects
     */
    public ArrayList getSolutions() {
        return solutions;
    }

    /**
     * Records the current solution state by copying the current solution into a new
     * partial solution without including the given binding, which is already part of
     * a prior solution.
     *
     * @@param binding the variable / value binding, which is not to be included in the
     * new partial solution
     */
    public void recordNewSolution(Binding binding) {
        ArrayList currentSolution = getCurrentSolution();
        ArrayList partialSolution = new ArrayList();
        for (int i = 0; i < currentSolution.size(); i++) {
            Binding solutionBinding = (Binding) currentSolution.get(i);
            partialSolution.add(solutionBinding.clone());
        }
        partialSolution.remove(binding);
        addSolution(partialSolution);
    }

    /**
     * Displays the bindings in a given solution to the constraint problem.
     */
    public void displaySolution(ArrayList solution) {
        System.out.println("Variables and solution value:");
        ArrayList orderedSolution = (ArrayList) solution.clone();
        Collections.sort(orderedSolution);
        for (int i = 0; i < orderedSolution.size(); i++)
            System.out.println(orderedSolution.get(i));
    }

    /**
     * Displays the bindings in all solutions to the constraint problem.
     */
    public void displaySolutions() {
        for (int i = 0; i < solutions.size(); i++) {
            displaySolution((ArrayList) solutions.get(i));
            System.out.println();
        }
    }

    /**
     * Removes the current empty solution in the special case where all solutions
     * were requested and where all solutions were found.
     */
    public void finalizeAllSolutions() {
        if (this.constraintProblem.nbrSolutionsRequested == null &&
            this.nbrSolutionsFound > 0)
            solutions.remove(solutions.size() - 1);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}@


1.6
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d10 1
a10 1
 * @@version $Id: Solution.java,v 1.5 2001/08/16 14:25:27 stephenreed Exp $
@


1.5
log
@Changed toString method of CycVariable to include "?" prefix.
Continued with unit test of the European Cathedrals constraint use case with OpenCyc connection.
@
text
@d10 1
a10 1
 * @@version $Id: Solution.java,v 1.4 2001/08/13 16:14:44 stephenreed Exp $
d39 1
a39 1
    protected int verbosity = 9;
@


1.4
log
@Revised copyright notice to Cycorp Inc.
@
text
@d1 177
a177 178
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import java.util.*;

/**
 * <tt>Solution</tt> object to model the attributes and behavior of
 * solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: Solution.java,v 1.2 2001/07/31 20:37:40 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class Solution {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 9;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Number of solutions found by the search.  Will not be more than the
     * number requested if <tt>nbrSolutionsRequested</tt> is not <tt>null</tt>.
     */
    protected int nbrSolutionsFound = 0;

    /**
     * List of solutions where each solution is a list of constraint variable -
     * domain value bindings which satisfy all the constraint rules.  Newest
     * solution is at the end of the list.
     */
    protected ArrayList solutions = new ArrayList();

    /**
     * Constructs a new <tt>Solution</tt> object given the parent <tt>ConstraintProblem</tt>
     * object.  Initializes the solutions to a single empty solution.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public Solution(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
        solutions = new ArrayList();
        addSolution(new ArrayList());
    }

    /**
     * Adds the variable / value binding to the current solution.
     *
     * @@param binding the variable / value binding to be added
     */
    public void addBindingToCurrentSolution(Binding binding) {
        getCurrentSolution().add(binding);
    }

    /**
     * Removes the variable / value binding from the current solution.
     *
     * @@param binding the variable / value binding to be removed
     */
    public void removeBindingFromCurrentSolution(Binding binding) {
        getCurrentSolution().remove(binding);
    }

    /**
     * Adds a new solution to the solution set.  The added
     * solution becomes the current solution.
     *
     * @@param the new solution <tt>ArrayList</tt> of <tt>Binding</tt> objects
     * to be added to the solution set
     */
    public void addSolution(ArrayList solution) {
        solutions.add(solution);
    }

    /**
     * Returns the current solution.
     *
     * @@return the current solution
     */
    public ArrayList getCurrentSolution() {
        return (ArrayList) solutions.get(solutions.size() - 1);
    }

    /**
     * Returns all solutions.
     *
     * @@return the <tt>ArrayList</tt> of solutions, each solution is an <tt>ArrayList</tt>
     * of <tt>Binding</tt> objects
     */
    public ArrayList getSolutions() {
        return solutions;
    }

    /**
     * Records the current solution state by copying the current solution into a new
     * partial solution without including the given binding, which is already part of
     * a prior solution.
     *
     * @@param binding the variable / value binding, which is not to be included in the
     * new partial solution
     */
    public void recordNewSolution(Binding binding) {
        ArrayList currentSolution = getCurrentSolution();
        ArrayList partialSolution = new ArrayList();
        for (int i = 0; i < currentSolution.size(); i++) {
            Binding solutionBinding = (Binding) currentSolution.get(i);
            partialSolution.add(solutionBinding.clone());
        }
        partialSolution.remove(binding);
        addSolution(partialSolution);
    }

    /**
     * Displays the bindings in a given solution to the constraint problem.
     */
    public void displaySolution(ArrayList solution) {
        System.out.println("Variables and solution value:");
        ArrayList orderedSolution = (ArrayList) solution.clone();
        Collections.sort(orderedSolution);
        for (int i = 0; i < orderedSolution.size(); i++)
            System.out.println(orderedSolution.get(i));
    }

    /**
     * Displays the bindings in all solutions to the constraint problem.
     */
    public void displaySolutions() {
        for (int i = 0; i < solutions.size(); i++) {
            displaySolution((ArrayList) solutions.get(i));
            System.out.println();
        }
    }

    /**
     * Removes the current empty solution in the special case where all solutions
     * were requested and where all solutions were found.
     */
    public void finalizeAllSolutions() {
        if (this.constraintProblem.nbrSolutionsRequested == null &&
            this.nbrSolutionsFound > 0)
            solutions.remove(solutions.size() - 1);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

@


1.3
log
@Completed coding and unit test of standalone constraint solver.
Calls to OpenCyc are yet to be included.
Unit test demonstrates solution of the Zebra puzzle in CycL form.
@
text
@d13 1
a13 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
d76 1
a76 1
    protected void addBindingToCurrentSolution(Binding binding) {
d85 1
a85 1
    protected void removeBindingFromCurrentSolution(Binding binding) {
d96 1
a96 1
    protected void addSolution(ArrayList solution) {
d105 1
a105 1
    protected ArrayList getCurrentSolution() {
d115 1
a115 1
    protected ArrayList getSolutions() {
d127 1
a127 1
    protected void recordNewSolution(Binding binding) {
d141 1
a141 1
    protected void displaySolution(ArrayList solution) {
d152 1
a152 1
    protected void displaySolutions() {
d163 1
a163 1
    protected void finalizeAllSolutions() {
d175 1
a175 1
    protected void setVerbosity(int verbosity) {
@


1.2
log
@Added test cases for Solution class
@
text
@d1 178
a178 178
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import java.util.*;

/**
 * <tt>Solution</tt> object to model the attributes and behavior of
 * solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: Solution.java,v 1.1 2001/07/31 13:19:02 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class Solution {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 9;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Number of solutions found by the search.  Will not be more than the
     * number requested if <tt>nbrSolutionsRequested</tt> is not <tt>null</tt>.
     */
    protected int nbrSolutionsFound = 0;

    /**
     * List of solutions where each solution is a list of constraint variable -
     * domain value bindings which satisfy all the constraint rules.  Newest
     * solution is at the end of the list.
     */
    protected ArrayList solutions = new ArrayList();

    /**
     * Constructs a new <tt>Solution</tt> object given the parent <tt>ConstraintProblem</tt>
     * object.  Initializes the solutions to a single empty solution.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public Solution(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
        solutions = new ArrayList();
        addSolution(new ArrayList());
    }

    /**
     * Adds the variable / value binding to the current solution.
     *
     * @@param binding the variable / value binding to be added
     */
    protected void addBindingToCurrentSolution(Binding binding) {
        getCurrentSolution().add(binding);
    }

    /**
     * Removes the variable / value binding from the current solution.
     *
     * @@param binding the variable / value binding to be removed
     */
    protected void removeBindingFromCurrentSolution(Binding binding) {
        getCurrentSolution().remove(binding);
    }

    /**
     * Adds a new solution to the solution set.  The added
     * solution becomes the current solution.
     *
     * @@param the new solution <tt>ArrayList</tt> of <tt>Binding</tt> objects
     * to be added to the solution set
     */
    protected void addSolution(ArrayList solution) {
        solutions.add(solution);
    }

    /**
     * Returns the current solution.
     *
     * @@return the current solution
     */
    protected ArrayList getCurrentSolution() {
        return (ArrayList) solutions.get(solutions.size() - 1);
    }

    /**
     * Returns all solutions.
     *
     * @@return the <tt>ArrayList</tt> of solutions, each solution is an <tt>ArrayList</tt>
     * of <tt>Binding</tt> objects
     */
    protected ArrayList getSolutions() {
        return solutions;
    }

    /**
     * Records the current solution state by copying the current solution into a new
     * partial solution without including the given binding, which is already part of
     * a prior solution.
     *
     * @@param binding the variable / value binding, which is not to be included in the
     * new partial solution
     */
    protected void recordNewSolution(Binding binding) {
        ArrayList currentSolution = getCurrentSolution();
        ArrayList partialSolution = new ArrayList();
        for (int i = 0; i < currentSolution.size(); i++) {
            Binding solutionBinding = (Binding) currentSolution.get(i);
            partialSolution.add(solutionBinding.clone());
        }
        partialSolution.remove(binding);
        addSolution(partialSolution);
    }

    /**
     * Displays the bindings in a given solution to the constraint problem.
     */
    protected void displaySolution(ArrayList solution) {
        System.out.println("Variables and solution value:");
        ArrayList orderedSolution = (ArrayList) solution.clone();
        Collections.sort(orderedSolution);
        for (int i = 0; i < orderedSolution.size(); i++)
            System.out.println(orderedSolution.get(i));
    }

    /**
     * Displays the bindings in all solutions to the constraint problem.
     */
    protected void displaySolutions() {
        for (int i = 0; i < solutions.size(); i++) {
            displaySolution((ArrayList) solutions.get(i));
            System.out.println();
        }
    }

    /**
     * Removes the current empty solution in the special case where all solutions
     * were requested and where all solutions were found.
     */
    protected void finalizeAllSolutions() {
        if (this.constraintProblem.nbrSolutionsRequested == null &&
            this.nbrSolutionsFound > 0)
            solutions.remove(solutions.size() - 1);
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    protected void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

@


1.1
log
@Added VariableSelectionAttributes class and unit test cases
@
text
@d10 1
a10 1
 * @@version $Id$
d85 1
a85 1
    protected void removeBinding(Binding binding) {
d139 1
a139 1
     * Display the bindings in a given solution to the constraint problem.
d150 1
a150 1
     * Display the bindings in all solutions to the constraint problem.
d157 10
@

