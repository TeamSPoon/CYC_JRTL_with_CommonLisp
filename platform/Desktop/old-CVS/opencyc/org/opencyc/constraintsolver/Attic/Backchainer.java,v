head	1.11;
access;
symbols
	PRE_1_0:1.11;
locks; strict;
comment	@# @;


1.11
date	2001.09.06.13.55.07;	author stephenreed;	state dead;
branches;
next	1.10;

1.10
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.31.15.45.42;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.30.23.35.11;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.30.14.52.08;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.30.00.06.55;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.29.15.25.19;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.28.23.52.16;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.21.14.34.31;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.10.22.42.41;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Added inferencesupport and queryprocessor packages, refactored support classes among them.
@
text
@package org.opencyc.constraintsolver;

import java.util.*;
import java.io.*;
import org.apache.oro.util.*;
import org.opencyc.cycobject.*;
import org.opencyc.api.*;

/**
 * Provides additional constraint rules through backwards KB inference using the input constraint
 * rules as a starting point.  Domain populating rules can be supplemented via backchaining,
 * because the answer to the query involves a search for bindings in the KB which are provided by
 * the domain populating rules.  Ordinary (non domain populating) rules on the other hand are not
 * supplemented by backchaining because they serve to restrict the domain values, as opposed to
 * populating them.<p>
 *
 * The <tt>Backchainer</tt> provides the additional constraint rules as a preparation step
 * before beginning the forward checking search for permitted bindings.
 *
 * @@version $Id: Backchainer.java,v 1.10 2001/09/04 14:30:23 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class Backchainer {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * <tt>Unifier</tt> for this <tt>Backchainer</tt>.
     */
    protected Unifier unifier = new Unifier(this);

    /**
     * current depth of backchaining from an input constraint rule.
     */
    protected int backchainDepth = 0;

    /**
     * Maximum depth of backchaining from an input constraint rule.
     */
    protected int maxBackchainDepth = 0;

    /**
     * Indicates whether to backchain on predicates #$isa and #$genl
     */
    protected boolean sbhlBackchain = false;

    /**
     * Least Recently Used Cache of implication rule sets concluding a predicate, so that a reference to an
     * existing implication rule set concluding a predicate is returned instead of gathering a duplicate.
     */
    protected static Cache implicationRuleSetCache = new CacheLRU(100);

    /**
     * Constructs a new <tt>Backchainer</tt> object given the parent <tt>ConstraintProblem</tt>
     * object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public Backchainer(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
    }

    /**
     * Solves a recursive constraint problem to obtain additional bindings for the variable in the given
     * unary rule, via backchaining on the unary rule (which might be a partially instantiated form of
     * a higher arity rule).
     *
     * @@param rule the unary rule for which additional bindings are sought via backchaining
     * @@return the <tt>ArrayList</tt> of values found
     */
    public ArrayList backchain(Rule rule) throws IOException {
        ArrayList values = new ArrayList();
        if (rule.getVariables().size() != 1)
            throw new RuntimeException("Attempt to backchain on non-unary rule " + rule);
        CycVariable variable = (CycVariable) rule.getVariables().get(0);
        if (verbosity > 1)
            System.out.println("Backchaining at depth " + backchainDepth + " on\n  " + rule +
                               "\n  to get bindings for " + variable);

        ArrayList backchainRules = getBackchainRules(rule);
        for (int i = 0; i < backchainRules.size(); i++) {
            Rule backchainRule = (Rule) backchainRules.get(i);
            if (verbosity > 1)
                System.out.println("\nRecursive constraint problem to solve\n  " + backchainRule);
            // Reuse the existing <tt>CycAccess</tt> object for the new constraint problem.
            ConstraintProblem backchainProblem =
                new ConstraintProblem(constraintProblem.cycAccess);
            backchainProblem.setVerbosity(verbosity);
            //backchainProblem.setVerbosity(9);
            // Request all solutions.
            backchainProblem.nbrSolutionsRequested = null;
            backchainProblem.mt = constraintProblem.mt;
            // Keep the same limit on maximum backchain depth
            backchainProblem.setMaxBackchainDepth(this.maxBackchainDepth);
            // Increment the depth of backchaining.
            backchainProblem.backchainer.backchainDepth = this.backchainDepth + 1;
            ArrayList solutions = backchainProblem.solve(backchainRule.formula);
            boolean solutionFound = false;
            for (int j = 0; j < solutions.size(); j++) {
                ArrayList solutionBindings = (ArrayList) solutions.get(j);
                if (verbosity > 3)
                    System.out.println("  Found bindings " + solutionBindings +
                                       "\n  for " + variable);
                for (int k = 0; k < solutionBindings.size(); k++) {
                    Binding binding = (Binding) solutionBindings.get(k);
                    if (binding.getCycVariable().equals(variable)) {
                        Object value = binding.getValue();
                        if (verbosity > 1)
                            System.out.println("  adding value " + value + " for " + variable);
                        values.add(value);
                        solutionFound = true;
                    }
                }
            }
            if (verbosity > 1) {
                if (! solutionFound)
                    System.out.println("  No bindings found for " + variable);
            }
        }
        return values;
    }

    /**
     * Performs backchaining inference to augment the input constraint domain-populating
     * constraint rule set.
     *
     * @@param domainPopulationRules collection of the rules which populate variable domains
     * @@return the augmented input constraint domain-populating constraint rule set
     */
    public ArrayList getBackchainRules(ArrayList domainPopulationRules) throws IOException {
        ArrayList result = new ArrayList();
        for (int i = 0; i < domainPopulationRules.size(); i++) {
            Rule domainPopulationRule = (Rule) domainPopulationRules.get(i);
            result.addAll(getBackchainRules(domainPopulationRule));
        }
        return result;
    }

    /**
     * Returns the sets of conjunctive antecentant rules which can prove the given rule.
     *
     * @@param rule a rule is to be proven via backchaining
     * @@return the sets of conjunctive antecentant rules which can prove the given rule
     */
    public ArrayList getBackchainRules(Rule rule) throws IOException {
        ArrayList result = new ArrayList();
        if (verbosity > 3)
            System.out.println("getting rules to conclude\n" + rule);
        ArrayList candidateImplicationRules = gatherRulesConcluding(rule);
        int nbrAcceptedRules = 0;
        int nbrCandidateRules = candidateImplicationRules.size();
        for (int i = 0; i < nbrCandidateRules; i++) {
            Rule candidateImplicationRule = (Rule) candidateImplicationRules.get(i);
            if (verbosity > 4)
                System.out.println("\nConsidering implication rule\n" + candidateImplicationRule.cyclify());
            HornClause hornClause = new HornClause(candidateImplicationRule);
            ArrayList antecedants = unifier.semanticallyUnify(rule, hornClause);
            if (antecedants != null) {
                if (verbosity > 4)
                    System.out.println("Unified antecedants\n" + antecedants);
                nbrAcceptedRules++;
                CycList conjunctiveAntecedantRule = new CycList();
                conjunctiveAntecedantRule.add(CycAccess.and);
                for (int j = 0; j < antecedants.size(); j++) {
                    Rule antecedant = (Rule) antecedants.get(j);
                    conjunctiveAntecedantRule.add(antecedant.getFormula());
                }
                result.add(new Rule(conjunctiveAntecedantRule));
            }
        }
        if (verbosity > 1) {
            System.out.println("\nSummary of accepted backchain rules");
            for (int i = 0; i < result.size(); i++)
                System.out.println("  " + ((Rule) result.get(i)).cyclify());
            System.out.println("Accepted " + nbrAcceptedRules + " backchain rules from " +
                               nbrCandidateRules + " candidates");
        }
        return result;
    }

    /**
     * Gathers the implication rules which conclude the given rule.
     *
     * @@param rule the rule to be proven via backchaining
     * @@return the implication rules which conclude the given rule
     */
    public ArrayList gatherRulesConcluding(Rule rule) throws IOException {
        ArrayList result = new ArrayList();
        CycConstant predicate = rule.getPredicate();
        if (! this.sbhlBackchain &&
            (predicate.equals(CycAccess.isa) || predicate.equals(CycAccess.genls))) {
            if (verbosity > 3)
                System.out.println("backchain inference bypassed for predicate " + predicate);
            return result;
        }
        if (CycAccess.current().isBackchainForbidden(predicate,
                                                     constraintProblem.mt)) {
            if (verbosity > 3)
                System.out.println("backchain inference forbidden for predicate " + predicate);
            return result;
        }
        if (CycAccess.current().isBackchainDiscouraged(predicate,
                                                       constraintProblem.mt)) {
            if (verbosity > 3)
                System.out.println("backchain inference discouraged for predicate " + predicate);
            return result;
        }
        if (CycAccess.current().isEvaluatablePredicate(predicate)) {
            if (verbosity > 3)
                System.out.println("backchain inference bypassed for evaluatable predicate " + predicate);
            return result;
        }
        /*
        ArrayList cachedResult = getCache(predicate);
        if (cachedResult != null) {
            if (verbosity > 1)
                System.out.println("Using cached implication rule set concluding " + predicate);
            return cachedResult;
        }
        */

        CycList backchainRules = CycAccess.current().getBackchainRules(rule,
                                                                       constraintProblem.mt);
        for (int i = 0; i < backchainRules.size(); i++) {
            CycList cycListRule = (CycList) backchainRules.get(i);
            if (HornClause.isValidHornExpression(cycListRule)) {
                Rule backchainRule = new Rule(cycListRule);
                result.add(backchainRule);
            }
            else {
                if (verbosity > 3)
                    System.out.println("dropped ill-formed (backward) rule " + cycListRule.cyclify());
            }
        }
        CycList forwardChainRules = CycAccess.current().getForwardChainRules(rule,
                                                                             constraintProblem.mt);
        for (int i = 0; i < forwardChainRules.size(); i++) {
            CycList cycListRule = (CycList) forwardChainRules.get(i);
            if (HornClause.isValidHornExpression(cycListRule)) {
                Rule forwardChainRule = new Rule(cycListRule);
                result.add(forwardChainRule);
            }
            else {
                if (verbosity > 3)
                    System.out.println("dropped ill-formed (forward) rule " + cycListRule.cyclify());
            }
        }
        /*
        addCache(predicate, result);
        */
        return result;
    }

    /**
     * Sets whether backchaining is performed on rules with the predicate of #$isa or #$genls.  Large
     * numbers of rules conclude #$isa or #$genls, which are not usually relevant - so the default is
     * false.
     *
     * @@param sbhlBackchain whether backchaining is performed on rules with the predicate of #$isa or #$genls
     */
    public void setSbhlBackchain(boolean sbhlBackchain) {
        this.sbhlBackchain = sbhlBackchain;
    }

    /**
     * Sets the maximum depth of backchaining from an input constraint rule. A value of zero indicates
     * no backchaining.
     *
     * @@param maxBackchainDepth the maximum depth of backchaining, or zero if no backchaing on the input
     * constraint rules
     */
    public void setMaxBackchainDepth(int maxBackchainDepth) {
        this.maxBackchainDepth = maxBackchainDepth;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
        unifier.setVerbosity(verbosity);
    }

    /**
     * Resets the implication rule set cache.
     */
    public static void resetImplicationRuleSetCache() {
        implicationRuleSetCache = new CacheLRU(500);
    }

    /**
     * Adds the implication rule set to the cache for the given predicate
     *
     * @@param predicate the predicate concluded by the implication rule set
     * @@param ruleSet the set of implication rules concluding the given predicate
     */
    public static void addCache(CycConstant predicate, ArrayList ruleSet) {
        implicationRuleSetCache.addElement(predicate, ruleSet);
    }

    /**
     * Retrieves the implication rule set from the cache for the given predicate, returning <tt>null</tt>
     * if not found in the cache.
     *
     * @@param predicate the predicate concluded by the implication rule set
     * @@return the implication rule set from the cache for the given predicate, returning <tt>null</tt>
     * if not found in the cache
     */
    public static ArrayList getCache(CycConstant predicate) {
        return (ArrayList) implicationRuleSetCache.getElement(predicate);
    }

    /**
     * Removes the implication rule set from the cache for the given predicate if it is contained within.
     */
    public static void removeCache(CycConstant predicate) {
        Object element = implicationRuleSetCache.getElement(predicate);
        if (element != null)
            implicationRuleSetCache.addElement(predicate, null);
    }

    /**
     * Returns the size of the implication rule set cache.
     *
     * @@return an <tt>int</tt> indicating the number of implication rule sets in the cache
     */
    public static int getCacheSize() {
        return implicationRuleSetCache.size();
    }

}@


1.10
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d20 1
a20 1
 * @@version $Id: Backchainer.java,v 1.9 2001/08/31 15:45:42 stephenreed Exp $
@


1.9
log
@Renamed rule instance variable to formula, continued backchain test cases
@
text
@d20 1
a20 1
 * @@version $Id: Backchainer.java,v 1.8 2001/08/30 23:35:11 stephenreed Exp $
d47 1
a47 1
    protected int verbosity = 9;
@


1.8
log
@Improved backchain rule filtering
@
text
@d20 1
a20 1
 * @@version $Id: Backchainer.java,v 1.7 2001/08/30 14:52:08 stephenreed Exp $
d124 1
a124 1
            ArrayList solutions = backchainProblem.solve(backchainRule.rule);
d193 1
a193 1
                    conjunctiveAntecedantRule.add(antecedant.getRule());
@


1.7
log
@Abbreviated diagnostic output for deep backchain examination.
@
text
@d5 1
d20 1
a20 1
 * @@version $Id: Backchainer.java,v 1.6 2001/08/30 00:06:55 stephenreed Exp $
d75 6
d235 15
a249 1
        CycList backchainRules = CycAccess.current().getBackchainRules(predicate,
d262 1
a262 1
        CycList forwardChainRules = CycAccess.current().getForwardChainRules(rule.getPredicate(),
d275 3
d313 48
@


1.6
log
@Changed CycAccess parameters from CycConstants to CycForts, more backchaining tests
@
text
@d19 1
a19 1
 * @@version $Id: Backchainer.java,v 1.5 2001/08/29 15:25:19 stephenreed Exp $
d96 2
a97 2
        if (verbosity > 3)
            System.out.println("Backchaining on " + rule +
d103 5
a107 3
            if (verbosity > 3)
                System.out.println("\n\nRecursive constraint problem to solve " + backchainRule);
            ConstraintProblem backchainProblem = new ConstraintProblem();
d118 1
d122 1
a122 1
                    System.out.println("Found bindings " + solutionBindings +
d128 1
a128 1
                        if (verbosity > 2)
d131 1
d135 4
d174 1
a174 1
            if (verbosity > 3)
d179 1
a179 1
                if (verbosity > 3)
d191 2
a192 2
        if (verbosity > 3) {
            System.out.println("\nSummary of accepted backchain rules\n");
d194 2
a195 2
                System.out.println(((Rule) result.get(i)).cyclify());
            System.out.println("\nAccepted " + nbrAcceptedRules + " backchain rules from " +
@


1.5
log
@More backchain test cases
@
text
@d19 1
a19 1
 * @@version $Id: Backchainer.java,v 1.4 2001/08/28 23:52:16 stephenreed Exp $
d69 5
d183 4
a186 1
        if (verbosity > 3)
d189 1
d201 20
a220 1
        CycList backchainRules = CycAccess.current().getBackchainRules(rule.getPredicate(),
d223 9
a231 2
            Rule backchainRule = new Rule((CycList) backchainRules.get(i));
            result.add(backchainRule);
d236 9
a244 2
            Rule forwardChainRule = new Rule((CycList) forwardChainRules.get(i));
            result.add(forwardChainRule);
d247 11
@


1.4
log
@Added more backchain support - testing with one level of backchaining
@
text
@d19 1
a19 1
 * @@version $Id: Backchainer.java,v 1.3 2001/08/21 14:34:31 stephenreed Exp $
d66 1
a66 1
    protected int maxBackchainDepth = 1;
d102 1
d120 1
a120 1
                        if (verbosity > 3)
d164 1
a164 1
            ArrayList antecedants = unifier.unify(rule, hornClause);
@


1.3
log
@Implemented gathering of candidate backchain rules from the KB
@
text
@d10 1
a10 1
 * rules as a starting point.  Only domain populating rules can be supplemented via backchaining,
d19 1
a19 1
 * @@version $Id: Backchainer.java,v 1.2 2001/08/13 16:14:44 stephenreed Exp $
d59 5
d66 1
a66 1
    protected int maxBackchainDepth = 6;
d79 51
d136 1
a136 1
    public ArrayList backchain(ArrayList domainPopulationRules) throws IOException {
d140 1
a140 1
            result.addAll(backchain(domainPopulationRule));
d146 1
a146 1
     * Returns the implication rules which can prove the given rule.
d149 1
a149 1
     * @@return the implication rules which can prove the given rule
d151 1
a151 1
    public ArrayList backchain(Rule rule) throws IOException {
a152 7
        int backchainDepth = rule.getBackchainDepth();
        if (backchainDepth >= this.maxBackchainDepth) {
            if (verbosity > 3)
                System.out.println("backchaining limit reached for\n" + rule);
            return result;
        }
        int newBackchainDepth = backchainDepth + 1;
d154 1
a154 2
            System.out.println("backchaining on\n" + rule);

d156 3
a158 2
        for (int i = 0; i < candidateImplicationRules.size(); i++) {
            // TODO implement rule filtering
d161 15
a175 1
                System.out.println("Considering implication rule\n" + candidateImplicationRule.cyclify());
d177 3
d206 10
a215 5





@


1.2
log
@Revised copyright notice to Cycorp Inc.
@
text
@d4 1
d6 1
d19 1
a19 1
 * @@version $Id: ConstraintProblem.java,v 1.4 2001/08/02 11:14:59 stephenreed Exp $
d80 1
a80 1
    public ArrayList backchain(ArrayList domainPopulationRules) {
d95 1
a95 1
    public ArrayList backchain(Rule rule) {
d108 6
a113 4

        // TODO implement rule filtering


d121 1
a121 1
     * @@return the implication rules which coonclde the given rule
d123 1
a123 1
    public ArrayList gatherRulesConcluding(Rule rule) {
d125 12
a136 3

        //TODO implement

@


1.1
log
@Added three modules to support backchaining inference.
@
text
@d20 1
a20 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
d52 5
d59 1
a59 1
    int maxBackchainDepth = 6;
d72 2
d75 2
d78 28
d107 1
d110 16
d139 1
a139 1
    protected void setVerbosity(int verbosity) {
d141 1
@

