head	1.7;
access;
symbols
	PRE_1_0:1.7;
locks; strict;
comment	@# @;


1.7
date	2001.09.06.13.55.07;	author stephenreed;	state dead;
branches;
next	1.6;

1.6
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.31.15.45.42;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.30.23.35.11;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.29.15.25.19;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.28.23.52.16;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Added inferencesupport and queryprocessor packages, refactored support classes among them.
@
text
@package org.opencyc.constraintsolver;

import java.util.*;
import java.io.*;
import org.opencyc.cycobject.*;
import org.opencyc.api.*;
import org.opencyc.util.*;

/**
 * Provides attribute and behavior for a formula unifier, used by the constraint solver
 * during backchaining.<p>
 *
 * @@version $Id: Unifier.java,v 1.6 2001/09/04 14:30:23 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class Unifier {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Reference to the collection of additional argument type constraint rules.
     */
    ArrayList argumentTypeConstraintRules;

    /**
     * Reference to the parent <tt>Backchainer</tt> object.
     */
    protected Backchainer backchainer;

    /**
     * Constructs a new <tt>Unifier</tt> object given the parent
     * <tt>Backchainer</tt> object.
     *
     * @@param backchainer the parent <tt>Backchainer</tt> ojbect
     */
    public Unifier(Backchainer backchainer) {
        this.backchainer = backchainer;
    }

    /**
     * Unifies a constraint rule with the consequent of a horn clause and returns a list of
     * the antecedants with the required variable renamings and substitutions, or returns
     * <tt>null</tt> if no unification is possible.
     *
     * @@param rule the constraint rule which is the subject of the backchaining operation
     * @@param hornClause the horn clause whose consequent is to be unified with the constraint
     * rule
     * @@return an <tt>ArrayList</tt> of the antecedants with the required variable renamings and
     * substitutions if unification succeeds otherwise return <tt>null</tt>
     */
    public ArrayList semanticallyUnify(Rule rule, HornClause hornClause) throws IOException {
        if (verbosity > 3)
            System.out.println("Attempting to unify \n" + rule + "\n" + hornClause);
        if (! (rule.getPredicate().equals(hornClause.getConsequent().getPredicate()))) {
            if (verbosity > 3)
                System.out.println("predicates not equal \n" + rule.getPredicate() +
                " " + hornClause.getConsequent().getPredicate());
            return null;
        }
        // Clone a new horn clause having no variables in common with those variable which
        // are already included in the constraint problem.
        HornClause unifiedHornClause = (HornClause) hornClause.clone();
        unifiedHornClause.renameVariables(backchainer.constraintProblem.variables, verbosity);

        // Visit each corresponding argument position in the rule and in the horn clause
        // consequent.
        CycList consequentArguments = unifiedHornClause.getConsequent().getArguments();
        CycList ruleArguments = rule.getArguments();

        for (int i = 0; i < ruleArguments.size(); i++) {
            Object ruleArgument = ruleArguments.get(i);
            Object consequentArgument = consequentArguments.get(i);
            if (ruleArgument instanceof CycVariable) {
                if (consequentArgument instanceof CycVariable) {
                    // Unify a rule variable.
                    unifiedHornClause.substituteVariable((CycVariable) consequentArgument,
                                                         ruleArgument,
                                                         verbosity);
                if (verbosity > 3)
                    System.out.println("at argument position " + (i + 1) +
                                       ". " + ((CycVariable) ruleArgument).cyclify() +
                                       " substituted for " +
                                       ((CycVariable) consequentArgument).cyclify());
                }
                else {
                    if (verbosity > 3)
                        System.out.println("at argument position " + (i + 1) +
                                           ", " + ruleArgument + " is a variable " +
                                           " but " + consequentArgument + " is not a variable");
                    return null;
                }

            }
            else if (consequentArgument instanceof CycVariable) {
                // Unify a horn clause consequent variable with a rule term.
                if (unifiedHornClause.substituteVariable((CycVariable) consequentArgument,
                                                         ruleArgument,
                                                         verbosity)) {
                    if (verbosity > 3)
                        System.out.println("at argument position " + (i + 1) +
                                           ". " + ruleArgument + " substituted for " +
                                           ((CycVariable) consequentArgument).cyclify());
                }
                else {
                    if (verbosity > 3)
                        System.out.println("  unification abandoned because formula not wff");
                    return null;
                }
            }
            else if (! (ruleArgument.equals(consequentArgument))) {
                // Otherwise respective terms in the rule and horn clause consequent must be
                // equal for unification to succeed.
                if (verbosity > 3)
                    System.out.println("at argument position " + (i + 1) +
                                       ", " + ruleArgument + " does not equal " +
                                       consequentArgument);
                return null;
            }
        }
        if (anyFalseViaKbLookup(unifiedHornClause.getAntecedantConjuncts()))
            return null;
        else if (anyFalseViaIrreflexsivity(unifiedHornClause.getAntecedantConjuncts()))
            return null;
        else
            return unifiedHornClause.getAntecedantConjuncts();
    }

    /**
     * Checks any ground antecedant conjuncts (having no variables) for truthfullness via KB
     * lookup, returning <tt>false</tt> iff any ground conjunct is false.  This check is not
     * performed if subsequent backchaining could prove the ground fact true.
     *
     * @@param antecedantConjuncts
     * @@return <tt>false</tt> iff any ground conjunct is false
     */
    protected boolean anyFalseViaKbLookup(ArrayList antecedantConjuncts) throws IOException {
        if (backchainer.backchainDepth < backchainer.maxBackchainDepth)
            return false;
        for (int i = 0; i < antecedantConjuncts.size(); i++) {
            Rule antecedantConjunct = (Rule) antecedantConjuncts.get(i);
            if (antecedantConjunct.isGround()) {
                boolean isAntecedantConjunctTrue =
                    CycAccess.current().isQueryTrue(antecedantConjunct.getFormula(),
                                                    backchainer.constraintProblem.mt);
                    if (verbosity > 8)
                        System.out.println("asking KB about antecedant conjunct\n" +
                                           antecedantConjunct + "\n  --> " + isAntecedantConjunctTrue);
                if (! isAntecedantConjunctTrue) {
                    if (verbosity > 3)
                        System.out.println("  unification abandoned because antecedant conjunct is not true\n" +
                                           antecedantConjunct);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks antecedant conjuncts for use of binary irreflexive predicates in a reflexsive situation, such as
     * (#$father ?X ?X) or other irreflexive predicates such as (#$different ?X ?X), returning <tt>false</tt> iff
     * any conjunct contains an invalid reflexsive usage.
     *
     * @@param antecedantConjuncts
     * @@return <tt>false</tt> iff any conjunct contains an invalid reflexsive usage
     */
    protected boolean anyFalseViaIrreflexsivity(ArrayList antecedantConjuncts) throws IOException {
        for (int i = 0; i < antecedantConjuncts.size(); i++) {
            Rule antecedantConjunct = (Rule) antecedantConjuncts.get(i);
            if (verbosity > 8) {
                System.out.println("  Screening irreflexivity usage\n  " +
                                   antecedantConjunct);
                System.out.println("    isIrreflexive " +
                                   antecedantConjunct.isIrreflexive(backchainer.constraintProblem.mt));
                System.out.println("    isAllDifferent " +
                                   antecedantConjunct.isAllDifferent());
                System.out.println("    arguments size " +
                                   antecedantConjunct.getArguments().size());
                System.out.println("    arity " +
                                   antecedantConjunct.getArity());
            }
            if (antecedantConjunct.isIrreflexive(backchainer.constraintProblem.mt) &&
                antecedantConjunct.getArguments().get(0).equals(antecedantConjunct.getArguments().get(1))) {
                if (verbosity > 1)
                    System.out.println("  unification abandoned because antecedant conjunct " +
                                       "contains invalid reflexive usage\n  " +
                                       antecedantConjunct);
                return true;
            }
            if (antecedantConjunct.isAllDifferent() &&
                antecedantConjunct.getArguments().containsDuplicates()) {
                if (verbosity > 1)
                    System.out.println("  unification abandoned because antecedant conjunct " +
                                       "contains invalid #$different usage\n  " +
                                       antecedantConjunct);
                return true;
            }
        }
        return false;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}@


1.6
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d13 1
a13 1
 * @@version $Id: Unifier.java,v 1.5 2001/08/31 15:45:42 stephenreed Exp $
@


1.5
log
@Renamed rule instance variable to formula, continued backchain test cases
@
text
@d13 1
a13 1
 * @@version $Id: Unifier.java,v 1.4 2001/08/30 23:35:11 stephenreed Exp $
d40 1
a40 1
    protected int verbosity = 9;
@


1.4
log
@Improved backchain rule filtering
@
text
@d13 1
a13 1
 * @@version $Id: Unifier.java,v 1.3 2001/08/29 15:25:19 stephenreed Exp $
d152 2
a153 1
     * lookup, returning <tt>false</tt> iff any ground conjunct is false;
d159 2
d165 1
a165 1
                    CycAccess.current().isQueryTrue(antecedantConjunct.getRule(),
@


1.3
log
@More backchain test cases
@
text
@d7 1
d13 1
a13 1
 * @@version $Id: Unifier.java,v 1.2 2001/08/28 23:52:16 stephenreed Exp $
d85 1
a85 1
        hornClause.renameVariables(backchainer.constraintProblem.variables, verbosity);
d144 2
d173 43
@


1.2
log
@Added more backchain support - testing with one level of backchaining
@
text
@d6 1
d12 1
a12 1
 * @@version $Id: Unifier.java,v 1.1 2001/08/13 16:14:44 stephenreed Exp $
d72 1
a72 1
    public ArrayList unify(Rule rule, HornClause hornClause) throws IOException {
d141 4
a144 1
        return unifiedHornClause.getAntecedantConjuncts();
d147 27
@


1.1
log
@Revised copyright notice to Cycorp Inc.
@
text
@d4 1
d11 1
a11 1
 * @@version $Id: Rule.java,v 1.3 2001/07/30 22:59:00 stephenreed Exp $
d71 1
a71 1
    public ArrayList unify(Rule rule, HornClause hornClause) {
a79 1

d89 1
d97 2
a98 1
                                                         ruleArgument);
d116 13
a128 6
                unifiedHornClause.substituteVariable((CycVariable) consequentArgument,
                                                     ruleArgument);
                if (verbosity > 3)
                    System.out.println("at argument position " + (i + 1) +
                                       ". " + ruleArgument + " substituted for " +
                                       ((CycVariable) consequentArgument).cyclify());
@

