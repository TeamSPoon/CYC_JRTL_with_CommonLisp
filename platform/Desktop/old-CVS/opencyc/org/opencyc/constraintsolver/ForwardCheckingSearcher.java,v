head	1.24;
access;
symbols
	PRE_1_0:1.23;
locks; strict;
comment	@# @;


1.24
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.17.23.44.19;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.11.21.46.17;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.06.14.49.47;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.05.22.58.59;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.04.23.57.47;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.03.22.30.50;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.31.15.45.42;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.29.15.25.19;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.21.14.34.31;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.20.14.00.07;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.16.17.31.46;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.16.14.25.27;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.15.23.49.56;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.14.01.06.43;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.10.22.22.00;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.03.10.31.26;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.02.11.14.59;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.31.13.19.02;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.31.13.08.37;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.30.22.59.00;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.constraintsolver;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;

import org.apache.commons.collections.CollectionUtils;
import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.inferencesupport.Binding;
import org.opencyc.inferencesupport.ConstraintRule;
import org.opencyc.inferencesupport.Solution;
import org.opencyc.inferencesupport.UnitTest;

/**
 * The <tt>ForwardCheckingSearcher</tt> object to perform forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ForwardCheckingSearcher.java,v 1.23 2001/10/17 23:44:19 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ForwardCheckingSearcher {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Reference to the collection of the constraint rules used in the search for
     * solution(s).
     */
    protected ArrayList constraintRules;

    /**
     * Reference to the <tt>Solution</tt> for the parent <tt>ConstraintProblem</tt> object.
     */
    protected Solution solution;

    /**
     * Reference to the <tt>ValueDomains</tt> object for the parent <tt>ConstraintProblem</tt>
     * object.
     */
    protected ValueDomains valueDomains;

    /**
     * When instantiating a rule having one variable left to instantiate for subsequent
     * asking the KB, this parameter sets the threshold beyond which a variable is used in the ask
     *  -- returning what bindings are known (or proven) in the KB.
     * Under this threshold, the rule is fully instantiated for the of each variable binding in
     * the unmarked value domain and the KB ask is performed on each of these.
     */
    protected static final int ASK_ALL_OR_INDIV_THRESHOLD = 10;

    /**
     * Number of search steps performed during the search for solution(s).
     */
    protected int nbrSteps = 0;

    /**
     * Constructs a new <tt>FowardCheckingSearcher</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ForwardCheckingSearcher(ConstraintProblem constraintProblem) {
        // Set direct references to collaborating objects.
        this.constraintProblem = constraintProblem;
        constraintRules = constraintProblem.constraintRules;
        solution = constraintProblem.solution;
        valueDomains = constraintProblem.valueDomains;
        verbosity = constraintProblem.verbosity;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Performs a depth-first search of the solution space, using forward checking
     * to prune alternatives.  Employs recursion to search subtrees.
     *
     * @@param variables is the <tt>ArrayList</tt> of remaining variables to solve
     * @@param level is the current depth of the search
     * @@return <tt>true</tt> when done with the search
     */
    public boolean search(ArrayList variables, int level)
        throws IOException, CycApiException {
        CycVariable selectedVariable = selectVariable(variables);
        ArrayList remainingDomain = valueDomains.getUnmarkedDomainValues(selectedVariable);
        ArrayList remainingVariables = (ArrayList) variables.clone();
        remainingVariables.remove(selectedVariable);
        if (verbosity > 2) {
            System.out.println("\nSearching level   " + level);
            System.out.println("  variable         " + selectedVariable.cyclify());
            System.out.println("  remaining domain " + remainingDomain);
            System.out.println("  remaining vars   " + remainingVariables);
        }
        // Iterate through the unmarked domain values, solving the subtree recursively,
        // backtracking when required.
        for (int i = 0; i < remainingDomain.size(); i++) {
            Object selectedValue = remainingDomain.get(i);
            Binding currentBinding = new Binding(selectedVariable,
                                                 selectedValue);
            solution.addBindingToCurrentSolution(currentBinding);
            nbrSteps++;
            if (verbosity > 2)
                System.out.println("  trial solution " +
                                   solution.getCurrentSolution());
            if (variables.size() == 1) {
                // Trivial case where the last variable is under consideration.
                solution.setNbrSolutionsFound(solution. getNbrSolutionsFound() + 1);
                if (verbosity > 0) {
                    if (solution.getNbrSolutionsFound() == 1)
                        System.out.println("\nFound a solution\n");
                    else
                        System.out.println("\nFound solution " +
                                           solution.getNbrSolutionsFound() + "\n");
                    solution.displaySolution(solution.getCurrentSolution());
                    System.out.println();
                }
                // The last variable is solved, have all the solutions requested been found?
                if (constraintProblem.nbrSolutionsRequested != null)
                    if (constraintProblem.nbrSolutionsRequested.intValue() == solution.getNbrSolutionsFound())
                        // Done and stop the search.
                        return true;
                // More solutions are needed, record this solution.
                solution.recordNewSolution(currentBinding);
            }
            else {
                // Try to achieve partial arc-consistency in the subtree.
                if (checkForwardRules(remainingVariables,
                                      level,
                                      currentBinding) &&
                    search(remainingVariables, level + 1))
                    // Requested solution(s) found in the subtree.
                    return true;
                // Otherwise backtrack, selecting next unmarked domain value.
                solution.removeBindingFromCurrentSolution(currentBinding);
                if (verbosity > 2) {
                    System.out.println("  backtracking from " + currentBinding);
                    System.out.println("  trial solution " +
                                       solution.getCurrentSolution());
                }
                restore(remainingVariables, level);
            }
        }
        // Done with this branch of the search tree, and keep searching.
        return false;
    }

    /**
     * From the list of variables, heuristically chooses the one most likely to
     * narrow the remaining search space.
     *
     * @@param variables the <tt>ArrayList</tt> of variables from which the choice is made
     * @@return the variable most likely to narrow the remaining search space
     */
    protected CycVariable selectVariable (ArrayList variables) {
        if (variables.size() == 1)
            return (CycVariable) variables.get(0);
        ArrayList annotatedVariables = new ArrayList();
        Integer remainingDomainSize = null;
        Integer degree = null;
        for (int i = 0; i < variables.size(); i++) {
            CycVariable variable = (CycVariable) variables.get(i);
            remainingDomainSize = new Integer(valueDomains.getUnmarkedDomainSize(variable));
            degree = new Integer(constraintDegree(variable, variables));
            annotatedVariables.add(new VariableSelectionAttributes(variable,
                                                                   remainingDomainSize,
                                                                   degree));
        }
        Collections.sort(annotatedVariables);
        if (verbosity > 7) {
            System.out.println("\nHeuristic selection order");
            for (int i = 0; i < annotatedVariables.size(); i++) {
                System.out.println("  " + (VariableSelectionAttributes) annotatedVariables.get(i));
            }
        }
        return ((VariableSelectionAttributes) annotatedVariables.get(0)).cycVariable;
    }

    /**
     * Performs forward checking of applicable rules to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     *
     * @@param remainingVariables the <tt>ArrayList</tt> of variables for which no domain
     * values have yet been bound
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRules(ArrayList remainingVariables,
                                        int level,
                                        Binding currentBinding)
        throws IOException, CycApiException {
        if (verbosity > 8)
            System.out.println("check forward rules applicable to binding " + currentBinding);
        for (int i = 0; i < constraintRules.size(); i++) {
            ConstraintRule rule = (ConstraintRule) constraintRules.get(i);
            ArrayList ruleVariables = rule.getVariables();
            if (verbosity > 8)
                System.out.println("check forward rule \n  " + rule.cyclify() +
                                   "  with variables " + ruleVariables);
            if ((rule.getArity() > 1) &&
                ruleVariables.contains(currentBinding.getCycVariable())) {
                // ConstraintRule applies to the selected variable.
                ArrayList remainingRuleVariables =
                    (ArrayList) CollectionUtils.intersection(remainingVariables,
                                                             ruleVariables);
                if (remainingRuleVariables.size() > 0) {
                    // It can rule out remaining variable values.

                    if (verbosity > 4)
                        System.out.println("Applicable rule \n  " + rule.cyclify() +
                                           "  for " + currentBinding.getCycVariable().cyclify());
                    if (! checkForwardRule(rule,
                                           remainingRuleVariables,
                                           level,
                                           currentBinding))
                        // found a forward rule which wipes out a domain
                        return false;
                }
            }
        }
    return true;
    }

    /**
     * Performs forward checking of the given rule to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     * Delegates forward checking to specific methods for all-different constraint,
     * evaluatable constraint, non-evaluatable constraint.  Non-evaluatable constraints
     * are asked in the knowledge base rather than evaluated in the constraint solver
     * object.
     *
     * @@param rule the constraint rule
     * @@param remainingRuleVariables the <tt>ArrayList</tt> of rule variables for which no domain
     * values have yet been bound
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRule(ConstraintRule rule,
                                       ArrayList remainingRuleVariables,
                                       int level,
                                       Binding currentBinding)
        throws IOException, CycApiException {
        CycList instantiatedRule = rule.getFormula().subst(currentBinding.getValue(),
                                                        currentBinding.getCycVariable());
        if (verbosity > 2) {
            System.out.println("Forward checking constraint\n  " + instantiatedRule.cyclify());
        }
        if (rule.isAllDifferent()) {
            if (verbosity > 2)
                System.out.println("all-different rule\n  " + rule.getFormula().cyclify() +
                                   "  for binding " + currentBinding.cyclify());
            return checkForwardDifferentRule(rule,
                                             remainingRuleVariables,
                                             level,
                                             currentBinding);
        }
        else if (rule.isEvaluatable()) {
            if (verbosity > 2)
                System.out.println("Evaluatable rule\n  " + rule.getFormula() +
                                   "  for binding " + currentBinding.cyclify());
            ArrayList bindings = new ArrayList();
            bindings.add(currentBinding);
            return checkForwardInstantiatedRule(instantiatedRule,
                                                remainingRuleVariables,
                                                bindings,
                                                level,
                                                currentBinding);
        }
        else {
            if (verbosity > 2)
                System.out.println("Non-evaluatable rule " + rule.getFormula().cyclify() +
                                   "\n  for binding " + currentBinding.cyclify());
            return checkForwardNonEvaluatableRule(rule,
                                                  level,
                                                  currentBinding);
        }
    }

    /**
     * Performs forward checking of the given non-evaluatable rule to restrict the
     * domains of remaining variables.  Returns <tt>true</tt> iff no remaining variable
     * domains are wiped out. Non-evaluatable constraints are asked in the knowledge base
     * rather than evaluated in the constraint solver object.
     *
     * @@param rule the constraint rule
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardNonEvaluatableRule(ConstraintRule rule,
                                                     int level,
                                                     Binding currentBinding)
        throws IOException, CycApiException {
        // Order the remaining variables by ascending domain size.
        ArrayList remainingRuleVariables = (ArrayList) rule.getVariables().clone();
        remainingRuleVariables.remove(currentBinding.getCycVariable());
        Collections.sort(remainingRuleVariables,
                         new VariablesByAscendingDomainSizeComparator(valueDomains));
        CycList instantiatedRule = rule.getFormula().subst(currentBinding.getValue(),
                                                        currentBinding.getCycVariable());
        ArrayList bindingList = new ArrayList();
        bindingList.add(currentBinding);
        markPermittedRemainingBindings(instantiatedRule,
                                       remainingRuleVariables,
                                       bindingList,
                                       currentBinding,
                                       rule);
        for (int i = 0; i < remainingRuleVariables.size(); i++) {
            CycVariable remainingRuleVariable = (CycVariable) remainingRuleVariables.get(i);
            valueDomains.complementDomainValues(remainingRuleVariable,
                                                new Integer(level),
                                                currentBinding);
            if (valueDomains.isDomainWipedOut(remainingRuleVariable))
                return false;
        }
        return true;
    }

    /**
     * Recurses to instantiate the constraint rule in the constraint problem KB microtheory with
     * all remaining variables as bindings, marking the domain values as permitted with
     * <tt>Boolean</tt> <tt>true</tt>.
     *
     * @@param instantiatedRule the constraint rule
     * @@param remainingVariables the variables left to instantiate in the constraint rule
     * @@param bindings the instantiated values for variables already instantiated in the
     * constraint rule
     */
    protected void markPermittedRemainingBindings(CycList instantiatedRule,
                                                  ArrayList remainingVariables,
                                                  ArrayList bindings,
                                                  Binding currentBinding,
                                                  ConstraintRule currentRule)
        throws IOException, CycApiException {
        CycVariable selectedVariable = currentBinding.getCycVariable();
        if (remainingVariables.size() == 0) {
            // This is the terminating recursion case, with no more variables left to instantiate.
            boolean instantiatedRuleResult =
                CycAccess.current().isQueryTrue_Cached(instantiatedRule,
                                                       constraintProblem.mt);
            if (verbosity > 2) {
                System.out.println("Bindings " + bindings);
                System.out.println(instantiatedRule.cyclify() + " --> " + instantiatedRuleResult);
            }
            if (instantiatedRuleResult) {
                CycVariable variable;
                Object value;
                for (int i = 0; i < bindings.size(); i++) {
                    Binding binding = (Binding) bindings.get(i);
                    variable = binding.getCycVariable();
                    if (! variable.equals(selectedVariable)) {
                        value = binding.getValue();
                        if (valueDomains.domainHasValue(variable, value)) {
                            if (verbosity > 2)
                                System.out.println("  " + binding.cyclify() + " is permitted by " +
                                                   currentBinding.cyclify());
                            valueDomains.markDomain(variable, value, Boolean.TRUE);
                        }
                    }
                }
            }
            return;
        }
        else if (remainingVariables.size() == 1) {
            // One variable left, handle the special cases where individual value
            // instantiation is not efficient.
            CycVariable variable = (CycVariable) remainingVariables.get(0);
            if (valueDomains.getUnmarkedDomainSize(variable) > ASK_ALL_OR_INDIV_THRESHOLD) {
                // Special case it is more efficient to ask for all the bindings and mark
                // them rather than to ask for them individually.
                if (verbosity > 2)
                    System.out.println("Variable exceeds ask-all threshold " + variable);
                ArrayList domainValues = this.askWithVariable(instantiatedRule, variable);
                for (int i = 0; i < domainValues.size(); i++) {
                    Object value = domainValues.get(i);
                    if (valueDomains.domainHasValue(variable, value)) {
                        if (verbosity > 2)
                            System.out.println("  " + (new Binding(variable, value)).cyclify() +
                                               " is permitted by " + currentBinding.cyclify());
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }

                }
            }
            return;
        }
        else {
            // Recurse to instantiate the remaining variables.
            CycVariable variable = (CycVariable) remainingVariables.get(0);
            ArrayList domainValues = valueDomains.getUnmarkedDomainValues(variable);
            int limit = valueDomains.getUnmarkedDomainSize(variable);
            if (verbosity > 4) {
                System.out.println("variable " + variable);
                System.out.println("  domain " + domainValues);
                System.out.println("  limit  " + limit);
            }
            Object value;
            CycList newInstantiatedRule;
            ArrayList newBindings = new ArrayList();
            for (int i = 0; i < limit; i++) {
                value = domainValues.get(i);
                Binding newCurrentBinding = new Binding(variable, value);
                newBindings.addAll(bindings);
                newBindings.add(new Binding(variable, value));
                newInstantiatedRule = instantiatedRule.subst(value, variable);
                if (verbosity > 4)
                    System.out.println("  instantiated rule " + newInstantiatedRule.cyclify());
                ArrayList newRemainingVariables = (ArrayList) remainingVariables.clone();
                newRemainingVariables.remove(0);
                this.markPermittedRemainingBindings(newInstantiatedRule,
                                                    newRemainingVariables,
                                                    newBindings,
                                                    newCurrentBinding,
                                                    currentRule);
            }
        }
    }

    /**
     * Returns a list of bindings for single unbound variable left in the rule.
     *
     * @@param instantiatedRule the rule in <tt>CycList</tt> form which has a single
     * unbound variable
     * @@param variable the variable for which bindings are sought
     * @@return a <tt>ArrayList</tt> of bindings for single unbound variable left in the rule
     */
    protected ArrayList askWithVariable(CycList instantiatedRule, CycVariable variable)
        throws IOException, CycApiException {
        ArrayList result = new ArrayList();
        CycList kbValues = constraintProblem.cycAccess.askWithVariable(instantiatedRule,
                                                                       variable,
                                                                       constraintProblem.mt);
        result.addAll(kbValues);
        if (verbosity > 3)
            System.out.println("Bindings for " + variable +
                               "\n" + instantiatedRule.cyclify() +
                               "\n  in mt " + constraintProblem.mt.cyclify() +
                               "\n  --> " + kbValues.cyclify());
        return result;
    }

    /**
     * Applies the all-different constraint rule to the remaining domains and returns <tt>true</tt>
     * iff no domains are wiped out.
     *
     * @@param rule the all-different constraint rule
     * @@param remainingRuleVariables the variables left to instantiate in the constraint rule
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardDifferentRule(ConstraintRule rule,
                                                ArrayList remainingRuleVariables,
                                                int level,
                                                Binding currentBinding) {
        Object value = currentBinding.getValue();
        ArrayList differentVariables = (ArrayList) remainingRuleVariables.clone();
        differentVariables.remove(currentBinding.getCycVariable());
        for (int i = 0; i < differentVariables.size(); i++) {
            CycVariable differentVariable = (CycVariable) differentVariables.get(i);
            if (valueDomains.getUnmarkedDomainValues(differentVariable).contains(value) &&
                ! valueDomains.isDomainMarked(differentVariable, value)) {
                if (verbosity > 6)
                    System.out.println("  " + (new Binding(differentVariable, value)).cyclify() +
                                       " is ruled out by " + currentBinding.cyclify());
                valueDomains.markDomain(differentVariable, value, new Integer(level));
                if (valueDomains.isDomainWipedOut(differentVariable)) {
                    if (verbosity > 6)
                        System.out.println("  domain wiped out for " + differentVariable.cyclify());
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Recurses to instantiate the rule in the constraint problem microtheory with all
     * remaining variables as bindings. Returns <tt>true</tt> iff no domains are wiped out.
     *
     * @@param rule the instantiated constraint rule
     * @@param remainingRuleVariables the variables left to instantiate in the constraint rule
     * @@param bindings the list of bindings instantiated so far
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardInstantiatedRule(CycList instantiatedRule,
                                                   ArrayList remainingRuleVariables,
                                                   ArrayList bindings,
                                                   int level,
                                                   Binding currentBinding) throws IOException {
        CycVariable selectedVariable = currentBinding.getCycVariable();
        if (remainingRuleVariables.size() == 0) {
            // This is the terminating recursion case, with no more variables left to instantiate.
            boolean instantiatedRuleResult = ConstraintRule.evaluateConstraintRule(instantiatedRule);
            if (verbosity > 2) {
                System.out.println("  bindings " + bindings);
                System.out.println("  " + instantiatedRule.cyclify() + " --> " +
                                   instantiatedRuleResult);
            }
            if (! instantiatedRuleResult) {
                CycVariable variable;
                Object value;
                for (int i = 0; i < bindings.size(); i++) {
                    Binding binding = (Binding) bindings.get(i);
                    variable = binding.getCycVariable();
                    if (! variable.equals(selectedVariable)) {
                        value = binding.getValue();
                        if (verbosity > 6)
                            System.out.println("  " + binding.cyclify() + " is ruled out by " +
                                               currentBinding.cyclify());
                        valueDomains.markDomain(variable, value, new Integer(level));
                        if (valueDomains.isDomainWipedOut(variable)) {
                            if (verbosity > 6)
                                System.out.println("  domain wiped out for " + variable);
                            return false;
                            }
                        }
                }
            }
            return true;
        }
        else {
            // Recurse to instantiate the remaining variables.
            CycVariable variable = (CycVariable) remainingRuleVariables.get(0);
            ArrayList domainValues = valueDomains.getUnmarkedDomainValues(variable);
            int limit = valueDomains.getUnmarkedDomainSize(variable);
            if (verbosity > 4) {
                System.out.println("variable " + variable);
                System.out.println("  domain " + domainValues);
                System.out.println("  limit  " + limit);
            }
            Object value;
            CycList newInstantiatedRule;
            for (int i = 0; i < limit; i++) {
                value = domainValues.get(i);
                Binding newCurrentBinding = new Binding(variable, value);
                ArrayList newBindings = new ArrayList();
                newBindings.addAll(bindings);
                newBindings.add(new Binding(variable, value));
                newInstantiatedRule = instantiatedRule.subst(value, variable);
                if (verbosity > 4)
                    System.out.println("  instantiated rule\n  " + newInstantiatedRule.cyclify());
                ArrayList newRemainingRuleVariables = (ArrayList) remainingRuleVariables.clone();
                newRemainingRuleVariables.remove(0);
                if (! checkForwardInstantiatedRule(newInstantiatedRule,
                                                   newRemainingRuleVariables,
                                                   newBindings,
                                                   level,
                                                   currentBinding)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Restores the eliminated value choices for constraint variables due to a backtrack in
     * the search.
     */
    protected void restore(ArrayList remainingVariables, int level) {
        Integer intLevel = new Integer(level);
        for (int i = 0; i < remainingVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) remainingVariables.get(i);
            ArrayList domainValues = valueDomains.getDomainValues(cycVariable);
            for (int j = 0; j < domainValues.size(); j++) {
                Object value = domainValues.get(j);
                if (valueDomains.isDomainMarkedAtLevel(cycVariable, value, intLevel)) {
                    if (verbosity > 2)
                        System.out.println("  restoring " +
                                           (new Binding(cycVariable, value)).cyclify());
                    valueDomains.unmarkDomain(cycVariable, value);
                }
            }
        }
    }

    /**
     * Returns the number of constraint rules applicable to variable and one or more
     * of the other variables.
     *
     * @@param variable the variable which must be used in the counted constraint rules
     * @@param variables the counted constraint rules must use only these variables and no others.
     * @@return the number of constraint rules applicable to variable and one or more
     * of the other variables
     */
    protected int constraintDegree(CycVariable variable, ArrayList variables) {
        int degree = 0;
        ArrayList ruleVariables = null;
        for (int i = 0; i < constraintProblem.constraintRules.size(); i++) {
            ConstraintRule rule = (ConstraintRule) constraintProblem.constraintRules.get(i);
            ruleVariables = rule.getVariables();
            if (ruleVariables.contains(variable) &&
                variables.containsAll(ruleVariables)) {
                degree++;
                if (verbosity > 8) {
                    ArrayList candidateVariables = (ArrayList) variables.clone();
                    candidateVariables.remove(variable);
                    System.out.println("ConstraintRule " + rule.cyclify() + "\n  between " +
                                       variable + " and candidate variables " +
                                       candidateVariables);
                }
            }
        }
        if (verbosity > 8)
            System.out.println("Constraint degree for " + variable + " is " + degree);
        return degree;
    }
}@


1.23
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@a2 2
import org.apache.commons.collections.*;
import java.util.*;
d4 12
a15 4
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.util.*;
import org.opencyc.api.*;
d21 1
a21 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.22 2001/09/11 21:46:17 stephenreed Exp $
d145 1
a145 1
                solution.setNbrSolutionsFound(solution.getNbrSolutionsFound() + 1);
@


1.22
log
@Constraint problems now enter the cyc api initially as queries.
@
text
@d15 1
a15 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.21 2001/09/06 21:43:25 stephenreed Exp $
d114 2
a115 1
    public boolean search(ArrayList variables, int level) throws IOException {
d221 2
a222 1
                                        Binding currentBinding) throws IOException {
d273 2
a274 1
                                       Binding currentBinding) throws IOException {
d325 1
a325 1
        throws IOException {
d365 2
a366 1
                                                  ConstraintRule currentRule) throws IOException {
d460 1
a460 1
        throws IOException {
@


1.21
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d15 1
a15 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.20 2001/09/06 14:49:47 stephenreed Exp $
a68 6
     * Reference to the <tt>VariableDomainPopulator</tt> object for the parent <tt>ConstraintProblem</tt>
     * object.
     */
    protected VariableDomainPopulator variableDomainPopulator;

    /**
a92 1
        variableDomainPopulator = constraintProblem.variableDomainPopulator;
a115 6

        // Handle the atypical case where a high cardinality variable is selected first.
        if (this.variableDomainPopulator.isPostponedHighCardinalityDomain(selectedVariable) &&
            this.variableDomainPopulator.getPopulatingRule(selectedVariable) == null)
            constraintProblem.variableDomainPopulator.populatePostponedDomain(selectedVariable);

a329 16
        // For variables with high domain cardinality, use the first applicable
        // rule to obtain the initial domain.
        if (remainingRuleVariables.size() == 1) {
            CycVariable variable = (CycVariable) remainingRuleVariables.get(0);
            // one variable left to instantiate
            if (variableDomainPopulator.isPostponedHighCardinalityDomain(variable))

                // The one variable left has a high cardinality domain.
                if (variableDomainPopulator.getPopulatingRule(variable) == null) {
                    // A rule has not yet populated the high cardinality domain.
                    if (verbosity > 2)
                        System.out.println("Using " + instantiatedRule.cyclify() +
                                           "\nto populate the domain of " + variable);
                    variableDomainPopulator.setPopulatingRule(variable, rule);
                }
        }
d381 6
a386 9
                    if ((! variableDomainPopulator.isPostponedHighCardinalityDomain(variable)) ||
                        // initial population of high cardinality domain
                        variableDomainPopulator.isPopulatingRule(currentRule, variable) ||
                        // Other rules cannot extend a high cardinality domain.
                        valueDomains.domainHasValue(variable, value))
                        if (verbosity > 2)
                            System.out.println("  " + binding.cyclify() + " is permitted by " +
                                               currentBinding.cyclify());
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
d396 1
a396 36
            boolean isHighCardinalityDomain =
                variableDomainPopulator.isPostponedHighCardinalityDomain(variable);
            if (verbosity > 2) {
                System.out.println("ConstraintRule instantiation reached singleton " + variable);
                System.out.println("  high cardinality? --> " + isHighCardinalityDomain);
            }
            if (isHighCardinalityDomain &&
                variableDomainPopulator.isPopulatingRule(currentRule, variable)) {
                // Special case where the rule is used to populate the values of an
                // otherwise high cardinality domain.  Thus the constraint reasoner
                // searches some subset of the potential domain values, where the
                // subset is expected to have much smaller cardinality.
                if (verbosity > 2)
                    System.out.println("  high cardinality variable " + variable +
                                       "\n  in " + instantiatedRule);
                ArrayList permittedValues = askWithVariable(instantiatedRule, variable);
                for (int i = 0; i < permittedValues.size(); i++) {
                    Object value = permittedValues.get(i);
                    Binding binding = new Binding(variable, value);
                    if (valueDomains.domainHasValue(variable, value)) {
                        if (verbosity > 2)
                            System.out.println("  " + binding.cyclify() + " is permitted by " +
                                               currentBinding.cyclify());
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }
                    else {
                        // initial population of high cardinality domain
                        if (verbosity > 2)
                            System.out.println("  " + binding.cyclify() + " is new and permitted by " +
                                               currentBinding.cyclify());
                        valueDomains.addDomainValue(variable, value);
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }
                }
            }
            else if (valueDomains.getUnmarkedDomainSize(variable) > ASK_ALL_OR_INDIV_THRESHOLD) {
@


1.20
log
@Renamed Rule to ConstraintRule, moved QueryLiteral class to inferencesupport.
@
text
@d7 1
d15 1
a15 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.19 2001/09/05 22:58:59 stephenreed Exp $
d151 1
a151 1
                solution.nbrSolutionsFound++;
d153 1
a153 1
                    if (solution.nbrSolutionsFound == 1)
d157 1
a157 1
                                           solution.nbrSolutionsFound + "\n");
d163 1
a163 1
                    if (constraintProblem.nbrSolutionsRequested.intValue() == solution.nbrSolutionsFound)
@


1.19
log
@Reworking population of high cardinality domains
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.18 2001/09/04 23:57:47 stephenreed Exp $
d236 1
a236 1
            Rule rule = (Rule) constraintRules.get(i);
d243 1
a243 1
                // Rule applies to the selected variable.
d280 1
a280 1
    protected boolean checkForwardRule(Rule rule,
d331 1
a331 1
    protected boolean checkForwardNonEvaluatableRule(Rule rule,
d390 1
a390 1
                                                  Rule currentRule) throws IOException {
d430 1
a430 1
                System.out.println("Rule instantiation reached singleton " + variable);
d546 1
a546 1
    protected boolean checkForwardDifferentRule(Rule rule,
d590 1
a590 1
            boolean instantiatedRuleResult = Rule.evaluateConstraintRule(instantiatedRule);
d687 1
a687 1
            Rule rule = (Rule) constraintProblem.constraintRules.get(i);
d695 1
a695 1
                    System.out.println("Rule " + rule.cyclify() + "\n  between " +
@


1.18
log
@Continued refactoring domain population methods.
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.17 2001/09/04 14:30:23 stephenreed Exp $
d126 1
a126 1
            populatePostponedDomain(selectedVariable);
a190 29
     * Populates the domain of an unpopulated high cardinality variable, choosing from
     * among applicable rules.
     */
    protected void populatePostponedDomain (CycVariable variable) throws IOException {
        for (int i = 0; i < constraintProblem.domainPopulationRules.size(); i++) {
            Rule rule = (Rule) constraintProblem.domainPopulationRules.get(i);
            if (rule.getArity() == 1 &&
                rule.getVariables().get(0).equals(variable)) {
                if (verbosity > 2)
                    System.out.println("Populating high cardinality variable " + variable +
                                       "\n  with rule\n" + rule.cyclify());
                ArrayList permittedValues = askWithVariable(rule.getFormula(), variable);
                for (int j = 0; j < permittedValues.size(); j++) {
                    Object value = permittedValues.get(j);
                    Binding binding = new Binding(variable, value);
                    if (verbosity > 2)
                        System.out.println("  " + binding.cyclify() +
                                           " is new");
                    valueDomains.addDomainValue(variable, value);
                    valueDomains.markDomain(variable, value, Boolean.TRUE);
                }
                return;
            }
        }
        throw new RuntimeException("Expected domain population rule not found for " +
                                   variable);
    }

    /**
d440 2
a441 1
                    System.out.println("  high cardinality variable " + variable);
@


1.17
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.16 2001/09/03 22:30:50 stephenreed Exp $
d124 1
a124 1
        if (this.variableDomainPopulator.contains(selectedVariable) &&
d376 1
a376 1
            if (variableDomainPopulator.contains(variable))
d438 1
a438 1
                    if ((! variableDomainPopulator.contains(variable)) ||
d457 1
a457 1
                variableDomainPopulator.contains(variable);
@


1.16
log
@Reworking ProblemParser to handle high cardinality domains better
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.15 2001/08/31 15:45:42 stephenreed Exp $
d43 1
a43 1
    protected int verbosity = 0;
d68 1
a68 1
     * Reference to the <tt>HighCardinalityDomains</tt> object for the parent <tt>ConstraintProblem</tt>
d71 1
a71 1
    protected HighCardinalityDomains highCardinalityDomains;
d98 1
a98 1
        highCardinalityDomains = constraintProblem.highCardinalityDomains;
d124 2
a125 2
        if (this.highCardinalityDomains.contains(selectedVariable) &&
            this.highCardinalityDomains.getPopulatingRule(selectedVariable) == null)
d376 1
a376 1
            if (highCardinalityDomains.contains(variable))
d379 1
a379 1
                if (highCardinalityDomains.getPopulatingRule(variable) == null) {
d384 1
a384 1
                    highCardinalityDomains.setPopulatingRule(variable, rule);
d438 1
a438 1
                    if ((! highCardinalityDomains.contains(variable)) ||
d440 1
a440 1
                        highCardinalityDomains.isPopulatingRule(currentRule, variable) ||
d457 1
a457 1
                highCardinalityDomains.contains(variable);
d463 1
a463 1
                highCardinalityDomains.isPopulatingRule(currentRule, variable)) {
@


1.15
log
@Renamed rule instance variable to formula, continued backchain test cases
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.14 2001/08/29 15:25:19 stephenreed Exp $
d203 1
a203 1
                for (int j = 0; i < permittedValues.size(); j++) {
@


1.14
log
@More backchain test cases
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.13 2001/08/21 14:34:31 stephenreed Exp $
d202 1
a202 1
                ArrayList permittedValues = askWithVariable(rule.getRule(), variable);
d313 1
a313 1
        CycList instantiatedRule = rule.getRule().subst(currentBinding.getValue(),
d320 1
a320 1
                System.out.println("all-different rule\n  " + rule.getRule().cyclify() +
d329 1
a329 1
                System.out.println("Evaluatable rule\n  " + rule.getRule() +
d341 1
a341 1
                System.out.println("Non-evaluatable rule " + rule.getRule().cyclify() +
d369 1
a369 1
        CycList instantiatedRule = rule.getRule().subst(currentBinding.getValue(),
@


1.13
log
@Implemented gathering of candidate backchain rules from the KB
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.12 2001/08/20 14:00:07 stephenreed Exp $
d262 2
d267 3
@


1.12
log
@Geting unit tests working for ProblemParser and arg constraints gathering.
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.11 2001/08/16 17:31:46 stephenreed Exp $
d122 6
d191 29
d357 2
a358 1
                                                     Binding currentBinding) throws IOException {
@


1.11
log
@Completed European Cathedrals use case accessing OpenCyc.
@
text
@a2 2
import org.opencyc.cycobject.*;
import org.opencyc.util.*;
a3 1
import org.apache.oro.util.*;
d6 3
d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.10 2001/08/16 14:25:27 stephenreed Exp $
a87 4
     * Least Recently Used Cache of ask results.
     */
    protected Cache askCache = new CacheLRU(500);
    /**
d382 3
a384 1
            boolean instantiatedRuleResult = constraintRuleAsk(instantiatedRule);
a520 25
    }

    /**
     * Returns <tt>true</tt> iff the instantiated (fully bound) rule is proven true in
     * the constraint problem KB microtheory.
     *
     * @@param instantiatedRule the fully bound constraint rule
     * @@return <tt>true</tt> iff the instantiated (fully bound) rule is proven true in
     * the constraint problem KB microtheory
     */
    protected boolean constraintRuleAsk(CycList instantiatedRule) throws IOException {
        boolean answer;
        Boolean isQueryTrue = (Boolean) askCache.getElement(instantiatedRule);
        if (isQueryTrue != null) {
            answer = isQueryTrue.booleanValue();
            if (verbosity > 3)
                System.out.println("Cached answer to \n" + instantiatedRule.cyclify() + " --> " + answer);
            return answer;
        }
        constraintProblem.nbrAsks++;
        answer = constraintProblem.cycAccess.isQueryTrue(instantiatedRule, constraintProblem.mt);
        askCache.addElement(instantiatedRule, new Boolean(answer));
        if (verbosity > 3)
            System.out.println("Answer to \n" + instantiatedRule.cyclify() + " --> " + answer);
        return answer;
@


1.10
log
@Changed toString method of CycVariable to include "?" prefix.
Continued with unit test of the European Cathedrals constraint use case with OpenCyc connection.
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.9 2001/08/15 23:49:56 stephenreed Exp $
d328 1
a328 1
        ArrayList remainingRuleVariables = rule.getVariables();
@


1.9
log
@Cached CycAccess instances by thread and introduced European Cathedrals
constraint problem that evaluates its rules in OpenCyc.
@
text
@d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.8 2001/08/14 01:06:43 stephenreed Exp $
d131 1
a131 1
            System.out.println("  variable         " + selectedVariable);
d244 2
a245 2
                        System.out.println("Applicable rule \n  " + rule +
                                           "  for " + currentBinding.getCycVariable());
d280 1
a280 1
            System.out.println("Forward checking constraint\n  " + instantiatedRule);
d284 2
a285 2
                System.out.println("all-different rule\n  " + rule.getRule() +
                                   "  for binding " + currentBinding);
d294 1
a294 1
                                   "  for binding " + currentBinding);
d305 2
a306 2
                System.out.println("Non-evaluatable rule " + rule.getRule() +
                                   "\n  for binding " + currentBinding);
d345 1
a345 1
                        System.out.println("Using " + instantiatedRule +
d389 1
a389 1
                System.out.println(instantiatedRule + " --> " + instantiatedRuleResult);
d405 2
a406 2
                            System.out.println("  " + binding + " is permitted by " +
                                               currentBinding);
d437 2
a438 2
                            System.out.println("  " + binding + " is permitted by " +
                                               currentBinding);
d444 2
a445 2
                            System.out.println("  " + binding + " is new and permitted by " +
                                               currentBinding);
d461 2
a462 2
                            System.out.println("  " + (new Binding(variable, value)) +
                                               " is permitted by " + currentBinding);
d490 1
a490 1
                    System.out.println("  instantiated rule " + newInstantiatedRule);
d513 9
a521 3
        result.addAll(constraintProblem.cycAccess.askWithVariable(instantiatedRule,
                                                                  variable,
                                                                  constraintProblem.mt));
d539 1
a539 1
                System.out.println("Cached answer to \n" + instantiatedRule + " --> " + answer);
d546 1
a546 1
            System.out.println("Answer to \n" + instantiatedRule + " --> " + answer);
d572 2
a573 2
                    System.out.println("  " + (new Binding(differentVariable, value)) +
                                       " is ruled out by " + currentBinding);
d577 1
a577 1
                        System.out.println("  domain wiped out for " + differentVariable);
d607 2
a608 1
                System.out.println("  " + instantiatedRule + " --> " + instantiatedRuleResult);
d619 2
a620 2
                            System.out.println("  " + binding + " is ruled out by " +
                                               currentBinding);
d652 1
a652 1
                    System.out.println("  instantiated rule\n  " + newInstantiatedRule);
d680 2
a681 1
                        System.out.println("  restoring " + (new Binding(cycVariable, value)));
d706 7
a712 3
                if (verbosity > 8)
                    System.out.println("Rule " + rule + "\n  between " +
                                       variable + " and " + variables);
@


1.8
log
@Fixed double newlines.
@
text
@d6 1
d8 1
d14 1
a14 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.7 2001/08/13 16:14:44 stephenreed Exp $
d88 4
d124 1
a124 1
    public boolean search(ArrayList variables, int level) {
d230 1
a230 1
                                        Binding currentBinding) {
d276 1
a276 1
                                       Binding currentBinding) {
d326 1
a326 1
                                                     Binding currentBinding) {
d382 1
a382 1
                                                  Rule currentRule) {
d510 2
a511 1
    protected ArrayList askWithVariable(CycList instantiatedRule, CycVariable variable) {
d513 3
a515 5

        System.out.println("******** askWithVariable Not implemented**********");

        //TODO use CycAccess

d527 9
a535 1
    protected boolean constraintRuleAsk(CycList instantiatedRule) {
d537 5
a541 4
        //TODO add cache of results
        //TODO call removal ask
        System.out.println("******** constraintRuleAsk Not implemented**********");
        return true;
a543 1

d594 1
a594 1
                                                   Binding currentBinding) {
@


1.7
log
@Revised copyright notice to Cycorp Inc.
@
text
@d1 693
a693 703
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import org.opencyc.util.*;
import org.apache.commons.collections.*;
import java.util.*;

/**
 * The <tt>ForwardCheckingSearcher</tt> object to perform forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ForwardCheckingSearcher.java,v 1.5 2001/08/03 10:31:26 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ForwardCheckingSearcher {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 0;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Reference to the collection of the constraint rules used in the search for
     * solution(s).
     */
    protected ArrayList constraintRules;

    /**
     * Reference to the <tt>Solution</tt> for the parent <tt>ConstraintProblem</tt> object.
     */
    protected Solution solution;

    /**
     * Reference to the <tt>ValueDomains</tt> object for the parent <tt>ConstraintProblem</tt>
     * object.
     */
    protected ValueDomains valueDomains;

    /**
     * Reference to the <tt>HighCardinalityDomains</tt> object for the parent <tt>ConstraintProblem</tt>
     * object.
     */
    protected HighCardinalityDomains highCardinalityDomains;

    /**
     * When instantiating a rule having one variable left to instantiate for subsequent
     * asking the KB, this parameter sets the threshold beyond which a variable is used in the ask
     *  -- returning what bindings are known (or proven) in the KB.
     * Under this threshold, the rule is fully instantiated for the of each variable binding in
     * the unmarked value domain and the KB ask is performed on each of these.
     */
    protected static final int ASK_ALL_OR_INDIV_THRESHOLD = 10;

    /**
     * Number of search steps performed during the search for solution(s).
     */
    protected int nbrSteps = 0;

    /**
     * Constructs a new <tt>FowardCheckingSearcher</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ForwardCheckingSearcher(ConstraintProblem constraintProblem) {
        // Set direct references to collaborating objects.
        this.constraintProblem = constraintProblem;
        constraintRules = constraintProblem.constraintRules;
        solution = constraintProblem.solution;
        valueDomains = constraintProblem.valueDomains;
        highCardinalityDomains = constraintProblem.highCardinalityDomains;
        verbosity = constraintProblem.verbosity;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Performs a depth-first search of the solution space, using forward checking
     * to prune alternatives.  Employs recursion to search subtrees.
     *
     * @@param variables is the <tt>ArrayList</tt> of remaining variables to solve
     * @@param level is the current depth of the search
     * @@return <tt>true</tt> when done with the search
     */
    public boolean search(ArrayList variables, int level) {
        CycVariable selectedVariable = selectVariable(variables);
        ArrayList remainingDomain = valueDomains.getUnmarkedDomainValues(selectedVariable);
        ArrayList remainingVariables = (ArrayList) variables.clone();
        remainingVariables.remove(selectedVariable);
        if (verbosity > 2) {
            System.out.println("\nSearching level   " + level);
            System.out.println("  variable         " + selectedVariable);
            System.out.println("  remaining domain " + remainingDomain);
            System.out.println("  remaining vars   " + remainingVariables);
        }
        // Iterate through the unmarked domain values, solving the subtree recursively,
        // backtracking when required.
        for (int i = 0; i < remainingDomain.size(); i++) {
            Object selectedValue = remainingDomain.get(i);
            Binding currentBinding = new Binding(selectedVariable,
                                                 selectedValue);
            solution.addBindingToCurrentSolution(currentBinding);
            nbrSteps++;
            if (verbosity > 2)
                System.out.println("  trial solution " +
                                   solution.getCurrentSolution());
            if (variables.size() == 1) {
                // Trivial case where the last variable is under consideration.
                solution.nbrSolutionsFound++;
                if (verbosity > 0) {
                    if (solution.nbrSolutionsFound == 1)
                        System.out.println("\nFound a solution\n");
                    else
                        System.out.println("\nFound solution " +
                                           solution.nbrSolutionsFound + "\n");
                    solution.displaySolution(solution.getCurrentSolution());
                    System.out.println();
                }
                // The last variable is solved, have all the solutions requested been found?
                if (constraintProblem.nbrSolutionsRequested != null)
                    if (constraintProblem.nbrSolutionsRequested.intValue() == solution.nbrSolutionsFound)
                        // Done and stop the search.
                        return true;
                // More solutions are needed, record this solution.
                solution.recordNewSolution(currentBinding);
            }
            else {
                // Try to achieve partial arc-consistency in the subtree.
                if (checkForwardRules(remainingVariables,
                                      level,
                                      currentBinding) &&
                    search(remainingVariables, level + 1))
                    // Requested solution(s) found in the subtree.
                    return true;
                // Otherwise backtrack, selecting next unmarked domain value.
                solution.removeBindingFromCurrentSolution(currentBinding);
                if (verbosity > 2) {
                    System.out.println("  backtracking from " + currentBinding);
                    System.out.println("  trial solution " +
                                       solution.getCurrentSolution());
                }
                restore(remainingVariables, level);
            }
        }
        // Done with this branch of the search tree, and keep searching.
        return false;
    }

    /**
     * From the list of variables, heuristically chooses the one most likely to
     * narrow the remaining search space.
     *
     * @@param variables the <tt>ArrayList</tt> of variables from which the choice is made
     * @@return the variable most likely to narrow the remaining search space
     */
    protected CycVariable selectVariable (ArrayList variables) {
        if (variables.size() == 1)
            return (CycVariable) variables.get(0);
        ArrayList annotatedVariables = new ArrayList();
        Integer remainingDomainSize = null;
        Integer degree = null;
        for (int i = 0; i < variables.size(); i++) {
            CycVariable variable = (CycVariable) variables.get(i);
            remainingDomainSize = new Integer(valueDomains.getUnmarkedDomainSize(variable));
            degree = new Integer(constraintDegree(variable, variables));
            annotatedVariables.add(new VariableSelectionAttributes(variable,
                                                                   remainingDomainSize,
                                                                   degree));
        }
        Collections.sort(annotatedVariables);
        if (verbosity > 7) {
            System.out.println("\nHeuristic selection order");
            for (int i = 0; i < annotatedVariables.size(); i++) {
                System.out.println("  " + (VariableSelectionAttributes) annotatedVariables.get(i));
            }
        }
        return ((VariableSelectionAttributes) annotatedVariables.get(0)).cycVariable;
    }

    /**
     * Performs forward checking of applicable rules to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     *
     * @@param remainingVariables the <tt>ArrayList</tt> of variables for which no domain
     * values have yet been bound
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRules(ArrayList remainingVariables,
                                        int level,
                                        Binding currentBinding) {
        for (int i = 0; i < constraintRules.size(); i++) {
            Rule rule = (Rule) constraintRules.get(i);
            ArrayList ruleVariables = rule.getVariables();
            if ((rule.getArity() > 1) &&
                ruleVariables.contains(currentBinding.getCycVariable())) {
                // Rule applies to the selected variable.
                ArrayList remainingRuleVariables =
                    (ArrayList) CollectionUtils.intersection(remainingVariables,
                                                             ruleVariables);
                if (remainingRuleVariables.size() > 0) {
                    // It can rule out remaining variable values.

                    if (verbosity > 4)
                        System.out.println("Applicable rule \n  " + rule +
                                           "  for " + currentBinding.getCycVariable());
                    if (! checkForwardRule(rule,
                                           remainingRuleVariables,
                                           level,
                                           currentBinding))
                        // found a forward rule which wipes out a domain
                        return false;
                }
            }
        }
    return true;
    }

    /**
     * Performs forward checking of the given rule to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     * Delegates forward checking to specific methods for all-different constraint,
     * evaluatable constraint, non-evaluatable constraint.  Non-evaluatable constraints
     * are asked in the knowledge base rather than evaluated in the constraint solver
     * object.
     *
     * @@param rule the constraint rule
     * @@param remainingRuleVariables the <tt>ArrayList</tt> of rule variables for which no domain
     * values have yet been bound
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRule(Rule rule,
                                       ArrayList remainingRuleVariables,
                                       int level,
                                       Binding currentBinding) {
        CycList instantiatedRule = rule.getRule().subst(currentBinding.getValue(),
                                                        currentBinding.getCycVariable());
        if (verbosity > 2) {
            System.out.println("Forward checking constraint\n  " + instantiatedRule);
        }
        if (rule.isAllDifferent()) {
            if (verbosity > 2)
                System.out.println("all-different rule\n  " + rule.getRule() +
                                   "  for binding " + currentBinding);
            return checkForwardDifferentRule(rule,
                                             remainingRuleVariables,
                                             level,
                                             currentBinding);
        }
        else if (rule.isEvaluatable()) {
            if (verbosity > 2)
                System.out.println("Evaluatable rule\n  " + rule.getRule() +
                                   "  for binding " + currentBinding);
            ArrayList bindings = new ArrayList();
            bindings.add(currentBinding);
            return checkForwardInstantiatedRule(instantiatedRule,
                                                remainingRuleVariables,
                                                bindings,
                                                level,
                                                currentBinding);
        }
        else {
            if (verbosity > 2)
                System.out.println("Non-evaluatable rule " + rule.getRule() +
                                   "\n  for binding " + currentBinding);
            return checkForwardNonEvaluatableRule(rule,
                                                  level,
                                                  currentBinding);
        }
    }

    /**
     * Performs forward checking of the given non-evaluatable rule to restrict the
     * domains of remaining variables.  Returns <tt>true</tt> iff no remaining variable
     * domains are wiped out. Non-evaluatable constraints are asked in the knowledge base
     * rather than evaluated in the constraint solver object.
     *
     * @@param rule the constraint rule
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardNonEvaluatableRule(Rule rule,
                                                     int level,
                                                     Binding currentBinding) {
        // Order the remaining variables by ascending domain size.
        ArrayList remainingRuleVariables = rule.getVariables();
        remainingRuleVariables.remove(currentBinding.getCycVariable());
        Collections.sort(remainingRuleVariables,
                         new VariablesByAscendingDomainSizeComparator(valueDomains));
        CycList instantiatedRule = rule.getRule().subst(currentBinding.getValue(),
                                                        currentBinding.getCycVariable());
        // For variables with high domain cardinality, use the first applicable
        // rule to obtain the initial domain.
        if (remainingRuleVariables.size() == 1) {
            CycVariable variable = (CycVariable) remainingRuleVariables.get(0);
            // one variable left to instantiate
            if (highCardinalityDomains.contains(variable))
                // The one variable left has a high cardinality domain.
                if (highCardinalityDomains.getPopulatingRule(variable) == null) {
                    // A rule has not yet populated the high cardinality domain.
                    if (verbosity > 2)
                        System.out.println("Using " + instantiatedRule +
                                           "\nto populate the domain of " + variable);
                    highCardinalityDomains.setPopulatingRule(variable, rule);
                }
        }
        ArrayList bindingList = new ArrayList();
        bindingList.add(currentBinding);
        markPermittedRemainingBindings(instantiatedRule,
                                       remainingRuleVariables,
                                       bindingList,
                                       currentBinding,
                                       rule);
        for (int i = 0; i < remainingRuleVariables.size(); i++) {
            CycVariable remainingRuleVariable = (CycVariable) remainingRuleVariables.get(i);
            valueDomains.complementDomainValues(remainingRuleVariable,
                                                new Integer(level),
                                                currentBinding);
            if (valueDomains.isDomainWipedOut(remainingRuleVariable))
                return false;
        }
        return true;
    }

    /**
     * Recurses to instantiate the constraint rule in the constraint problem KB microtheory with
     * all remaining variables as bindings, marking the domain values as permitted with
     * <tt>Boolean</tt> <tt>true</tt>.
     *
     * @@param instantiatedRule the constraint rule
     * @@param remainingVariables the variables left to instantiate in the constraint rule
     * @@param bindings the instantiated values for variables already instantiated in the
     * constraint rule
     */
    protected void markPermittedRemainingBindings(CycList instantiatedRule,
                                                  ArrayList remainingVariables,
                                                  ArrayList bindings,
                                                  Binding currentBinding,
                                                  Rule currentRule) {
        CycVariable selectedVariable = currentBinding.getCycVariable();
        if (remainingVariables.size() == 0) {
            // This is the terminating recursion case, with no more variables left to instantiate.
            boolean instantiatedRuleResult = constraintRuleAsk(instantiatedRule);
            if (verbosity > 2) {
                System.out.println("Bindings " + bindings);
                System.out.println(instantiatedRule + " --> " + instantiatedRuleResult);
            }
            if (instantiatedRuleResult) {
                CycVariable variable;
                Object value;
                for (int i = 0; i < bindings.size(); i++) {
                    Binding binding = (Binding) bindings.get(i);
                    variable = binding.getCycVariable();
                    if (! variable.equals(selectedVariable)) {
                        value = binding.getValue();
                    if ((! highCardinalityDomains.contains(variable)) ||
                        // initial population of high cardinality domain
                        highCardinalityDomains.isPopulatingRule(currentRule, variable) ||
                        // Other rules cannot extend a high cardinality domain.
                        valueDomains.domainHasValue(variable, value))
                        if (verbosity > 2)
                            System.out.println("  " + binding + " is permitted by " +
                                               currentBinding);
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }
                }
            }
            return;
        }
        else if (remainingVariables.size() == 1) {
            // One variable left, handle the special cases where individual value
            // instantiation is not efficient.
            CycVariable variable = (CycVariable) remainingVariables.get(0);
            boolean isHighCardinalityDomain =
                highCardinalityDomains.contains(variable);
            if (verbosity > 2) {
                System.out.println("Rule instantiation reached singleton " + variable);
                System.out.println("  high cardinality? --> " + isHighCardinalityDomain);
            }
            if (isHighCardinalityDomain &&
                highCardinalityDomains.isPopulatingRule(currentRule, variable)) {
                // Special case where the rule is used to populate the values of an
                // otherwise high cardinality domain.  Thus the constraint reasoner
                // searches some subset of the potential domain values, where the
                // subset is expected to have much smaller cardinality.
                if (verbosity > 2)
                    System.out.println("  high cardinality variable " + variable);
                ArrayList permittedValues = askWithVariable(instantiatedRule, variable);
                for (int i = 0; i < permittedValues.size(); i++) {
                    Object value = permittedValues.get(i);
                    Binding binding = new Binding(variable, value);
                    if (valueDomains.domainHasValue(variable, value)) {
                        if (verbosity > 2)
                            System.out.println("  " + binding + " is permitted by " +
                                               currentBinding);
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }
                    else {
                        // initial population of high cardinality domain
                        if (verbosity > 2)
                            System.out.println("  " + binding + " is new and permitted by " +
                                               currentBinding);
                        valueDomains.addDomainValue(variable, value);
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }
                }
            }
            else if (valueDomains.getUnmarkedDomainSize(variable) > ASK_ALL_OR_INDIV_THRESHOLD) {
                // Special case it is more efficient to ask for all the bindings and mark
                // them rather than to ask for them individually.
                if (verbosity > 2)
                    System.out.println("Variable exceeds ask-all threshold " + variable);
                ArrayList domainValues = this.askWithVariable(instantiatedRule, variable);
                for (int i = 0; i < domainValues.size(); i++) {
                    Object value = domainValues.get(i);
                    if (valueDomains.domainHasValue(variable, value)) {
                        if (verbosity > 2)
                            System.out.println("  " + (new Binding(variable, value)) +
                                               " is permitted by " + currentBinding);
                        valueDomains.markDomain(variable, value, Boolean.TRUE);
                    }

                }
            }
            return;
        }
        else {
            // Recurse to instantiate the remaining variables.
            CycVariable variable = (CycVariable) remainingVariables.get(0);
            ArrayList domainValues = valueDomains.getUnmarkedDomainValues(variable);
            int limit = valueDomains.getUnmarkedDomainSize(variable);
            if (verbosity > 4) {
                System.out.println("variable " + variable);
                System.out.println("  domain " + domainValues);
                System.out.println("  limit  " + limit);
            }
            Object value;
            CycList newInstantiatedRule;
            ArrayList newBindings = new ArrayList();
            for (int i = 0; i < limit; i++) {
                value = domainValues.get(i);
                Binding newCurrentBinding = new Binding(variable, value);
                newBindings.addAll(bindings);
                newBindings.add(new Binding(variable, value));
                newInstantiatedRule = instantiatedRule.subst(value, variable);
                if (verbosity > 4)
                    System.out.println("  instantiated rule " + newInstantiatedRule);
                ArrayList newRemainingVariables = (ArrayList) remainingVariables.clone();
                newRemainingVariables.remove(0);
                this.markPermittedRemainingBindings(newInstantiatedRule,
                                                    newRemainingVariables,
                                                    newBindings,
                                                    newCurrentBinding,
                                                    currentRule);
            }
        }
    }

    /**
     * Returns a list of bindings for single unbound variable left in the rule.
     *
     * @@param instantiatedRule the rule in <tt>CycList</tt> form which has a single
     * unbound variable
     * @@param variable the variable for which bindings are sought
     * @@return a <tt>ArrayList</tt> of bindings for single unbound variable left in the rule
     */
    protected ArrayList askWithVariable(CycList instantiatedRule, CycVariable variable) {
        ArrayList result = new ArrayList();

        System.out.println("******** askWithVariable Not implemented**********");

        //TODO use CycAccess

        return result;
    }

    /**
     * Returns <tt>true</tt> iff the instantiated (fully bound) rule is proven true in
     * the constraint problem KB microtheory.
     *
     * @@param instantiatedRule the fully bound constraint rule
     * @@return <tt>true</tt> iff the instantiated (fully bound) rule is proven true in
     * the constraint problem KB microtheory
     */
    protected boolean constraintRuleAsk(CycList instantiatedRule) {
        constraintProblem.nbrAsks++;
        //TODO add cache of results
        //TODO call removal ask
        System.out.println("******** constraintRuleAsk Not implemented**********");
        return true;
    }


    /**
     * Applies the all-different constraint rule to the remaining domains and returns <tt>true</tt>
     * iff no domains are wiped out.
     *
     * @@param rule the all-different constraint rule
     * @@param remainingRuleVariables the variables left to instantiate in the constraint rule
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardDifferentRule(Rule rule,
                                                ArrayList remainingRuleVariables,
                                                int level,
                                                Binding currentBinding) {
        Object value = currentBinding.getValue();
        ArrayList differentVariables = (ArrayList) remainingRuleVariables.clone();
        differentVariables.remove(currentBinding.getCycVariable());
        for (int i = 0; i < differentVariables.size(); i++) {
            CycVariable differentVariable = (CycVariable) differentVariables.get(i);
            if (valueDomains.getUnmarkedDomainValues(differentVariable).contains(value) &&
                ! valueDomains.isDomainMarked(differentVariable, value)) {
                if (verbosity > 6)
                    System.out.println("  " + (new Binding(differentVariable, value)) +
                                       " is ruled out by " + currentBinding);
                valueDomains.markDomain(differentVariable, value, new Integer(level));
                if (valueDomains.isDomainWipedOut(differentVariable)) {
                    if (verbosity > 6)
                        System.out.println("  domain wiped out for " + differentVariable);
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Recurses to instantiate the rule in the constraint problem microtheory with all
     * remaining variables as bindings. Returns <tt>true</tt> iff no domains are wiped out.
     *
     * @@param rule the instantiated constraint rule
     * @@param remainingRuleVariables the variables left to instantiate in the constraint rule
     * @@param bindings the list of bindings instantiated so far
     * @@param level the current level of solution search depth
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardInstantiatedRule(CycList instantiatedRule,
                                                   ArrayList remainingRuleVariables,
                                                   ArrayList bindings,
                                                   int level,
                                                   Binding currentBinding) {
        CycVariable selectedVariable = currentBinding.getCycVariable();
        if (remainingRuleVariables.size() == 0) {
            // This is the terminating recursion case, with no more variables left to instantiate.
            boolean instantiatedRuleResult = Rule.evaluateConstraintRule(instantiatedRule);
            if (verbosity > 2) {
                System.out.println("  bindings " + bindings);
                System.out.println("  " + instantiatedRule + " --> " + instantiatedRuleResult);
            }
            if (! instantiatedRuleResult) {
                CycVariable variable;
                Object value;
                for (int i = 0; i < bindings.size(); i++) {
                    Binding binding = (Binding) bindings.get(i);
                    variable = binding.getCycVariable();
                    if (! variable.equals(selectedVariable)) {
                        value = binding.getValue();
                        if (verbosity > 6)
                            System.out.println("  " + binding + " is ruled out by " +
                                               currentBinding);
                        valueDomains.markDomain(variable, value, new Integer(level));
                        if (valueDomains.isDomainWipedOut(variable)) {
                            if (verbosity > 6)
                                System.out.println("  domain wiped out for " + variable);
                            return false;
                            }
                        }
                }
            }
            return true;
        }
        else {
            // Recurse to instantiate the remaining variables.
            CycVariable variable = (CycVariable) remainingRuleVariables.get(0);
            ArrayList domainValues = valueDomains.getUnmarkedDomainValues(variable);
            int limit = valueDomains.getUnmarkedDomainSize(variable);
            if (verbosity > 4) {
                System.out.println("variable " + variable);
                System.out.println("  domain " + domainValues);
                System.out.println("  limit  " + limit);
            }
            Object value;
            CycList newInstantiatedRule;
            for (int i = 0; i < limit; i++) {
                value = domainValues.get(i);
                Binding newCurrentBinding = new Binding(variable, value);
                ArrayList newBindings = new ArrayList();
                newBindings.addAll(bindings);
                newBindings.add(new Binding(variable, value));
                newInstantiatedRule = instantiatedRule.subst(value, variable);
                if (verbosity > 4)
                    System.out.println("  instantiated rule\n  " + newInstantiatedRule);
                ArrayList newRemainingRuleVariables = (ArrayList) remainingRuleVariables.clone();
                newRemainingRuleVariables.remove(0);
                if (! checkForwardInstantiatedRule(newInstantiatedRule,
                                                   newRemainingRuleVariables,
                                                   newBindings,
                                                   level,
                                                   currentBinding)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Restores the eliminated value choices for constraint variables due to a backtrack in
     * the search.
     */
    protected void restore(ArrayList remainingVariables, int level) {
        Integer intLevel = new Integer(level);
        for (int i = 0; i < remainingVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) remainingVariables.get(i);
            ArrayList domainValues = valueDomains.getDomainValues(cycVariable);
            for (int j = 0; j < domainValues.size(); j++) {
                Object value = domainValues.get(j);
                if (valueDomains.isDomainMarkedAtLevel(cycVariable, value, intLevel)) {
                    if (verbosity > 2)
                        System.out.println("  restoring " + (new Binding(cycVariable, value)));
                    valueDomains.unmarkDomain(cycVariable, value);
                }
            }
        }
    }

    /**
     * Returns the number of constraint rules applicable to variable and one or more
     * of the other variables.
     *
     * @@param variable the variable which must be used in the counted constraint rules
     * @@param variables the counted constraint rules must use only these variables and no others.
     * @@return the number of constraint rules applicable to variable and one or more
     * of the other variables
     */
    protected int constraintDegree(CycVariable variable, ArrayList variables) {
        int degree = 0;
        ArrayList ruleVariables = null;
        for (int i = 0; i < constraintProblem.constraintRules.size(); i++) {
            Rule rule = (Rule) constraintProblem.constraintRules.get(i);
            ruleVariables = rule.getVariables();
            if (ruleVariables.contains(variable) &&
                variables.containsAll(ruleVariables)) {
                degree++;
                if (verbosity > 8)
                    System.out.println("Rule " + rule + "\n  between " +
                                       variable + " and " + variables);
            }
        }
        if (verbosity > 8)
            System.out.println("Constraint degree for " + variable + " is " + degree);
        return degree;
    }











@


1.6
log
@Completed coding and unit test of standalone constraint solver.
Calls to OpenCyc are yet to be included.
Unit test demonstrates solution of the Zebra puzzle in CycL form.
@
text
@d15 1
a15 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
d81 5
a100 6
     * Number of search steps performed during the search for solution(s).
     */
    protected int nbrSteps = 0;


    /**
d106 1
a106 1
    protected void setVerbosity(int verbosity) {
d118 1
a118 1
    protected boolean search(ArrayList variables, int level) {
@


1.5
log
@Fleshed out checkForwardRules method
@
text
@d1 704
a704 302
package org.opencyc.constraintsolver;

import org.opencyc.cycobject.*;
import org.opencyc.util.*;
import org.apache.commons.collections.*;
import java.util.*;

/**
 * The <tt>ForwardCheckingSearcher</tt> object to perform forward checking search for one or
 * more solutions to the <tt>ConstraintProblem</tt>.<p>
 *
 * @@version $Id: ForwardCheckingSearcher.java,v 1.4 2001/08/02 11:14:59 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@see UnitTest#testConstraintProblem
 */
public class ForwardCheckingSearcher {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = 8;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Reference to the collection of the constraint rules used in the search for
     * solution(s).
     */
    protected ArrayList constraintRules;

    /**
     * Reference to the <tt>Solution</tt> for the parent <tt>ConstraintProblem</tt> object.
     */
    protected Solution solution;

    /**
     * Reference to the <tt>ValueDomains</tt> object for the parent <tt>ConstraintProblem</tt>
     * object.
     */
    protected ValueDomains valueDomains;

    /**
     * Constructs a new <tt>FowardCheckingSearcher</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ForwardCheckingSearcher(ConstraintProblem constraintProblem) {
        // Set direct references to collaborating objects.
        this.constraintProblem = constraintProblem;
        constraintRules = constraintProblem.constraintRules;
        solution = constraintProblem.solution;
        valueDomains = constraintProblem.valueDomains;
    }

    /**
     * Number of search steps performed during the search for solution(s).
     */
    protected int nbrSteps = 0;


    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    protected void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Performs a depth-first search of the solution space, using forward checking
     * to prune alternatives.  Employs recursion to search subtrees.
     *
     * @@param variables is the <tt>ArrayList</tt> of remaining variables to solve
     * @@param level is the current depth of the search
     * @@return <tt>true</tt> when done with the search
     */
    protected boolean search(ArrayList variables, int level) {
        CycVariable selectedVariable = selectVariable(variables);
        ArrayList remainingDomain = valueDomains.getUnmarkedDomainValues(selectedVariable);
        ArrayList remainingVariables = (ArrayList) variables.clone();
        remainingVariables.remove(selectedVariable);
        if (verbosity > 2) {
            System.out.println("\nSearching level   " + level);
            System.out.println("  variable         " + selectedVariable);
            System.out.println("  remaining domain " + remainingDomain);
            System.out.println("  remaining vars   " + remainingVariables);
        }
        // Iterate through the unmarked domain values, solving the subtree recursively,
        // backtracking when required.
        for (int i = 0; i < remainingDomain.size(); i++) {
            Object selectedValue = remainingDomain.get(i);
            Binding currentBinding = new Binding(selectedVariable,
                                                 selectedValue);
            solution.addBindingToCurrentSolution(currentBinding);
            nbrSteps++;
            if (verbosity > 2)
                System.out.println("  trial solution " +
                                   solution.getCurrentSolution());
            if (variables.size() == 1) {
                // Trivial case where the last variable is under consideration.
                solution.nbrSolutionsFound++;
                if (verbosity > 0) {
                    if (solution.nbrSolutionsFound == 1)
                        System.out.println("\nFound a solution\n");
                    else
                        System.out.println("\nFound solution " +
                                           solution.nbrSolutionsFound + "\n");
                    solution.displaySolution(solution.getCurrentSolution());
                    System.out.println();
                }
                // The last variable is solved, have all the solutions requested been found?
                if (constraintProblem.nbrSolutionsRequested != null)
                    if (constraintProblem.nbrSolutionsRequested.intValue() == solution.nbrSolutionsFound)
                        // Done and stop the search.
                        return true;
                // More solutions are needed, record this solution.
                solution.recordNewSolution(currentBinding);
            }
            else {
                // Try to achieve partial arc-consistency in the subtree.
                if (checkForwardRules(remainingVariables,
                                      level,
                                      currentBinding) &&
                    search(remainingVariables, level + 1))
                    // Requested solution(s) found in the subtree.
                    return true;
                // Otherwise backtrack, selecting next unmarked domain value.
                if (verbosity > 2)
                    System.out.println("  backtracking from " + currentBinding);
                solution.removeBindingFromCurrentSolution(currentBinding);
                restore(remainingVariables, level);
            }
        }
        // Done with this branch of the search tree, and keep searching.
        return false;
    }

    /**
     * From the list of variables, heuristically chooses the one most likely to
     * narrow the remaining search space.
     *
     * @@param variables the <tt>ArrayList</tt> of variables from which the choice is made
     * @@return the variable most likely to narrow the remaining search space
     */
    protected CycVariable selectVariable (ArrayList variables) {
        if (variables.size() == 1)
            return (CycVariable) variables.get(0);
        ArrayList annotatedVariables = new ArrayList();
        Integer remainingDomainSize = null;
        Integer degree = null;
        for (int i = 0; i < variables.size(); i++) {
            CycVariable variable = (CycVariable) variables.get(i);
            remainingDomainSize = new Integer(valueDomains.getUnmarkedDomainSize(variable));
            degree = new Integer(constraintDegree(variable, variables));
            annotatedVariables.add(new VariableSelectionAttributes(variable,
                                                                   remainingDomainSize,
                                                                   degree));
        }
        Collections.sort(annotatedVariables);
        if (verbosity > 7) {
            System.out.println("\nHeuristic selection order");
            for (int i = 0; i < annotatedVariables.size(); i++) {
                System.out.println("  " + (VariableSelectionAttributes) annotatedVariables.get(i));
            }
        }
        return ((VariableSelectionAttributes) annotatedVariables.get(0)).cycVariable;
    }

    /**
     * Performs forward checking of applicable rules to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     *
     * @@param remainingVariables the <tt>ArrayList</tt> of variables for which no domain
     * values have yet been bound
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRules(ArrayList remainingVariables,
                                        int level,
                                        Binding currentBinding) {
        for (int i = 0; i < constraintRules.size(); i++) {
            Rule rule = (Rule) constraintRules.get(i);
            ArrayList ruleVariables = rule.getVariables();
            if ((rule.getArity() > 1) &&
                // Does rule apply?
                ruleVariables.contains(currentBinding.getCycVariable()) &&
                // Can it rule out any remaining variable values?
                OcCollectionUtils.hasIntersection(remainingVariables, ruleVariables)) {

                if (verbosity > 4)
                    System.out.println("Applicable rule \n" + rule +
                                       "  for " + currentBinding.getCycVariable());
                if (! checkForwardRule(rule,
                                       remainingVariables,
                                       level,
                                       currentBinding))
                    // found a forward rule which wipes out a domain
                    return false;
            }
        }
    return true;
    }

    /**
     * Performs forward checking of the given rule to restrict the domains of remaining
     * variables.  Returns <tt>true</tt> iff no remaining variable domains are wiped out.
     *
     * @@param remainingVariables the <tt>ArrayList</tt> of variables for which no domain
     * values have yet been bound
     * @@param currentBinding the current variable and bound value
     * @@return <tt>true</tt> iff no remaining variable domains are wiped out
     */
    protected boolean checkForwardRule(Rule rule,
                                       ArrayList remainingVariables,
                                       int level,
                                       Binding currentBinding) {
        return true;
    }

    /**
     * Restores the eliminated value choices for constraint variables due to a backtrack in
     * the search.
     */
    protected void restore(ArrayList remainingVariables, int level) {
        Integer intLevel = new Integer(level);
        for (int i = 0; i < remainingVariables.size(); i++) {
            CycVariable cycVariable = (CycVariable) remainingVariables.get(i);
            ArrayList domainValues = valueDomains.getDomainValues(cycVariable);
            for (int j = 0; j < domainValues.size(); j++) {
                Object value = domainValues.get(j);
                if (valueDomains.isDomainMarkedAtLevel(cycVariable, value, intLevel)) {
                    if (verbosity > 2)
                        System.out.println("  restoring " + (new Binding(cycVariable, value)));
                    valueDomains.unmarkDomain(cycVariable, value);
                }
            }
        }
    }

    /**
     * Returns the number of constraint rules applicable to variable and one or more
     * of the other variables.
     *
     * @@param variable the variable which must be used in the counted constraint rules
     * @@param variables the counted constraint rules must use only these variables and no others.
     * @@return the number of constraint rules applicable to variable and one or more
     * of the other variables
     */
    protected int constraintDegree(CycVariable variable, ArrayList variables) {
        int degree = 0;
        ArrayList ruleVariables = null;
        for (int i = 0; i < constraintProblem.constraintRules.size(); i++) {
            Rule rule = (Rule) constraintProblem.constraintRules.get(i);
            ruleVariables = rule.getVariables();
            if (ruleVariables.contains(variable) &&
                variables.containsAll(ruleVariables)) {
                degree++;
                if (verbosity > 8)
                    System.out.println("Rule " + rule + "\n  between " +
                                       variable + " and " + variables);
            }
        }
        if (verbosity > 8)
            System.out.println("Constraint degree for " + variable + " is " + degree);
        return degree;
    }











@


1.4
log
@Continued coding methods in ForwardCheckingSearcher.  Removed search from unit tests until done.
@
text
@d4 2
d12 1
a12 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.3 2001/07/31 13:19:02 stephenreed Exp $
d49 6
d73 1
d206 22
d229 14
a242 2

    return true;
@


1.3
log
@Added VariableSelectionAttributes class and unit test cases
@
text
@d10 1
a10 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.2 2001/07/31 13:08:37 stephenreed Exp $
d47 11
d63 1
d65 2
d70 6
d91 1
a91 1
     * @@return <tt>true</tt> if a solution is found in this subtree.
d95 1
a95 1
        ArrayList remainingDomain = constraintProblem.valueDomains.getUnmarkedDomainValues(selectedVariable);
d108 41
a148 2
            //Solution object

d150 1
a150 1
        // No solution down this branch.
d169 1
a169 1
            remainingDomainSize = new Integer(constraintProblem.valueDomains.getUnmarkedDomainSize(variable));
d183 37
@


1.2
log
@Add compareTo methods and unit test cases
@
text
@d10 1
a10 1
 * @@version $Id: ForwardCheckingSearcher.java,v 1.1 2001/07/30 22:59:00 stephenreed Exp $
d112 3
a114 3
            annotatedVariables.add(new VariableSelectionAttibutes(variable,
                                                                  remainingDomainSize,
                                                                  degree));
d120 1
a120 1
                System.out.println("  " + (VariableSelectionAttibutes) annotatedVariables.get(i));
d123 1
a123 1
        return ((VariableSelectionAttibutes) annotatedVariables.get(0)).cycVariable;
@


1.1
log
@Refactored ConstraintProblem class and added several other supporting classes
@
text
@d10 1
a10 1
 * @@version $Id$
a107 1
        Object[] annotation = {null, null, null};
d112 3
a114 4
            annotation[0] = variable;
            annotation[1] = remainingDomainSize;
            annotation[2] = degree;
            annotatedVariables.add(annotation.clone());
d116 3
a118 3
        Collections.sort(annotatedVariables, new VariableSelectionComparator());
        if (verbosity > 8) {
            System.out.println("\nHeuristic selection order (variable remainingDomainSize degree)");
d120 1
a120 2
                annotation = (Object[]) annotatedVariables.get(i);
                System.out.println(annotation[0] + "  " +  annotation[1] + "  " +  annotation[2]);
d123 1
a123 2
        annotation = (Object[]) annotatedVariables.get(0);
        return (CycVariable) annotation[0];
@

