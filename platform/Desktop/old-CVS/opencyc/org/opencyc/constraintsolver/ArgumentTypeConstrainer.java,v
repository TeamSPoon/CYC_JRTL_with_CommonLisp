head	1.14;
access;
symbols
	PRE_1_0:1.13;
locks; strict;
comment	@# @;


1.14
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.17.23.44.19;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.06.14.49.47;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.06.13.55.07;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.04.14.30.23;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.31.15.45.42;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.30.23.35.11;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.21.14.34.31;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.20.14.00.07;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.17.13.57.21;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.16.23.04.57;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.10.22.42.41;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.constraintsolver;

import java.io.IOException;
import java.net.UnknownHostException;
import java.util.ArrayList;

import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.inferencesupport.ConstraintRule;

/**
 * Provides argument type consistency checking for candidate backchaining rules, and also
 * provides additional constraint rules derived from argument type constraints on the
 * restricting constraint rules using the input constraint
 * rules as a starting point.  No additional rules are derived for domain populating rules
 * because their purpose is not to restrict permitted variable bindings, but to populate
 * the domains with values.<p>
 *
 * Argument type constraints are retrieved for candidate rules during backchaining.  For
 * variables mentioned in both the antecedant and consequent portions of the candidate
 * backchain rule, the argument type constraints on these variables can rule out
 * candidates for backchaining if associated collections are proven disjoint.
 *
 * The <tt>ArgumentTypeConstrainer</tt> provides the additional constraint rules as a preparation
 * step before beginning the forward checking search for permitted bindings.
 *
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.13 2001/10/17 23:44:19 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class ArgumentTypeConstrainer {

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = ConstraintProblem.DEFAULT_VERBOSITY;

    /**
     * Reference to the collection of additional argument type constraint rules.
     */
    ArrayList argumentTypeConstraintRules;

    /**
     * Reference to the parent <tt>ConstraintProblem</tt> object.
     */
    protected ConstraintProblem constraintProblem;

    /**
     * Constructs a new <tt>ArgumentTypeConstrainer</tt> object given the parent
     * <tt>ConstraintProblem</tt> object.
     *
     * @@param constraintProblem the parent constraint problem
     */
    public ArgumentTypeConstrainer(ConstraintProblem constraintProblem) {
        this.constraintProblem = constraintProblem;
        argumentTypeConstraintRules = constraintProblem.argumentTypeConstraintRules;
    }

    /**
     * Retrieves the argument type constraint rules for the given rule.
     *
     * @@param predicate the <tt>CycConstant</tt> which is the predicate of a simple rule
     * @@param argPosition the argument position, indexed base 1, for which the argument
     * type constraint rules are sought
     * @@param cycVariable the variable used to construct the returned rules
     * @@return the argument type constraint rules for the given rule
     */
    public ArrayList retrieveArgumentTypeConstraintRules(ConstraintRule rule)
        throws IOException, CycApiException {
        if (verbosity > 3)
            System.out.println("Gathering type constraints for\n" + rule.cyclify());
        return gatherPredicateVariableArgConstaints(rule.getFormula());
    }

    /**
     * Returns the argument type constraint rules for the variables within the given expression.
     *
     * @@param expression the expression which possibly contains variables
     * @@return the argument type constraint rules for the variables within the given expression
     */
    protected ArrayList gatherPredicateVariableArgConstaints(CycList expression)
        throws IOException, CycApiException {
        ArrayList result = new ArrayList();
        Object arg0 = expression.get(0);
        if (! (arg0 instanceof CycConstant))
            return result;
        CycConstant predicateOrFunction = (CycConstant) arg0;
        for (int i = 1; i < expression.size(); i++) {
            Object argument = expression.get(i);
            if (argument instanceof CycVariable) {
                CycVariable cycVariable = (CycVariable) argument;
                int argPosition = i;
                result.addAll(retrieveArgumentTypeConstraintRules(predicateOrFunction,
                                                                  argPosition,
                                                                  cycVariable));
            }
            else if (argument instanceof CycList)
                // Handle variables embedded within expressions.
                result.addAll(gatherPredicateVariableArgConstaints((CycList) argument));
        }
        return result;
    }


    /**
     * Retrieves the argument type constraint rules for the given predicate at the given
     * argument position, indexed base 1.
     *
     * @@param predicate the <tt>CycConstant</tt> which is the predicate of a simple rule
     * @@param argPosition the argument position, indexed base 1, for which the argument
     * type constraint rules are sought
     * @@param cycVariable the variable used to construct the returned rules
     * @@return the argument type constraint rules for the predicate
     */
    public ArrayList retrieveArgumentTypeConstraintRules(CycConstant predicate,
                                                            int argPosition,
                                                            CycVariable cycVariable)
        throws IOException, CycApiException {
        ArrayList result = new ArrayList();
        result.addAll(retrieveArgNIsas(predicate, argPosition, cycVariable));
        result.addAll(retrieveArgGenls(predicate, argPosition, cycVariable));
        return result;
    }

    /**
     * Retrieves the #$argNIsa constraint rules for the given predicate at the given
     * argument position, indexed base 1.
     *
     * @@param predicate the <tt>CycConstant</tt> which is the predicate of a simple rule
     * @@param argPosition the argument position, indexed base 1, for which the argument
     * type constraint rules are sought
     * @@param cycVariable the variable used to construct the returned rules
     * @@return the #$argNIsa constraint rules for the given predicate at the given
     * argument position, indexed base 1
     */
    public ArrayList retrieveArgNIsas(CycConstant predicate,
                                         int argPosition,
                                         CycVariable cycVariable)
        throws IOException, CycApiException {
        ArrayList result = new ArrayList();
        CycList isas = CycAccess.current().getArgNIsas(predicate, argPosition);
        for (int i = 0; i < isas.size(); i++) {
            CycFort collection = (CycFort) isas.get(i);
            String ruleString = "(#$isa " + cycVariable + " " + collection.cyclify() + ")";
            ConstraintRule rule = new ConstraintRule(ruleString);
            result.add(rule);
            if (verbosity > 3)
                System.out.println("  " + predicate.cyclify() +
                                   " has #$argNIsa constraint at arg position " + argPosition +
                                   "  \n" + rule.cyclify());
        }
        return result;
    }

    /**
     * Retrieves the #$argGenl constraint rules for the given predicate at the given
     * argument position, indexed base 1.
     *
     * @@param predicate the <tt>CycConstant</tt> which is the predicate of a simple rule
     * @@param argPosition the argument position, indexed base 1, for which the argument
     * type constraint rules are sought
     * @@param cycVariable the variable used to construct the returned rules
     * @@return the #$argNGenls constraint rules for the given predicate at the given
     * argument position, indexed base 1
     */
    public ArrayList retrieveArgGenls(CycConstant predicate,
                                      int argPosition,
                                      CycVariable cycVariable)
        throws IOException, UnknownHostException, CycApiException {
        ArrayList result = new ArrayList();
        CycList genls = CycAccess.current().getArgNGenls(predicate, argPosition);
        for (int i = 0; i < genls.size(); i++) {
            CycFort collection = (CycFort) genls.get(i);
            String ruleString = "(#$isa " + cycVariable + " " + collection.cyclify() + ")";
            ConstraintRule rule = new ConstraintRule(ruleString);
            result.add(rule);
            if (verbosity > 3)
                System.out.println("  " + predicate.cyclify() +
                                   " has #$argNGenl constraint at arg position " + argPosition +
                                   "  \n" + rule.cyclify());
        }
        return result;
    }

    /**
     * Returns <tt>true</tt> iff the given unary constraint rule is consistent with
     * the previously accepted unary constraints on the given variable.  Consistency is
     * determined by cases.  If the unary constraint is of the form<br>
     * <code>(#$isa variable collection)</code><br>
     * then the collection must not be disjoint from any other collections having the
     * variable as an element.  And in the case where the unary constraint is of the
     * form<br>
     * <code>(#$genls variable collection)</code><br>
     * then the collection must not be disjoint from any other collections have the
     * variable as a spec.
     *
     * @@param unaryRule the unary constraint rule whose consistency is in question
     * @@param cycVariable the variable to which the unary constraint is checked for consistency
     * @@return <tt>true</tt> iff the given unary constraint rule is consistent with
     * the previously accepted unary constraints on the given variable
     */
    public boolean isUnaryRuleConsistent(ConstraintRule unaryRule, CycVariable cycVariable)
        throws IOException, CycApiException {
        // Find the associated collections for the unary constraint rule under consideration.
        CycFort consideringIsaCollection = null;
        CycFort consideringGenlsCollection = null;
        CycConstant consideringPredicate = unaryRule.getPredicate();
        if (consideringPredicate.toString().equals("isa")) {
            consideringIsaCollection = (CycConstant) unaryRule.getArguments().third();
            if (verbosity > 3)
                System.out.println("considering isa collection " + consideringIsaCollection);
        }
        else if (consideringPredicate.toString().equals("genls")) {
            consideringGenlsCollection = (CycConstant) unaryRule.getArguments().third();
            if (verbosity > 3)
                System.out.println("considering genls collection " + consideringIsaCollection);
        }
        else {
            System.out.println("Unexpected predicate for argument constraint " + unaryRule);
            System.exit(1);
        }
        // Compare the considered collection(s) with those previously accepted for the
        // given variable.  Return false if any are disjoint.

        for (int i = 0; i < constraintProblem.constraintRules.size(); i++) {
            ConstraintRule rule = (ConstraintRule) constraintProblem.constraintRules.get(i);
            if ((rule.getArity() == 1) &&
                (rule.getVariables().contains(cycVariable)))
            if (verbosity > 3)
                System.out.println(cycVariable + " has applicable unary rule \n" + rule);
            CycConstant predicate = rule.getPredicate();
            if (predicate.toString().equals("isa")) {
                CycFort isaCollection = (CycFort) rule.getArguments().third();
                if (CycAccess.current().areDisjoint(consideringIsaCollection, isaCollection)) {
                    if (verbosity > 1)
                        System.out.println(consideringIsaCollection +
                                           " is disjoint from " + isaCollection);
                    return false;
                }
            }
            else if (predicate.toString().equals("genls")) {
                CycFort genlsCollection = (CycFort) rule.getArguments().third();
                if (CycAccess.current().areDisjoint(consideringGenlsCollection, genlsCollection)) {
                    if (verbosity > 1)
                        System.out.println(consideringGenlsCollection +
                                           " is disjoint from " + genlsCollection);
                    return false;
                }
            }
            else {
                System.out.println("Unexpected rule " + rule);
                System.exit(1);
            }
        }
        return true;
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

}@


1.13
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@d3 11
a13 6
import java.util.*;
import java.io.*;
import java.net.*;
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.api.*;
d31 1
a31 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.12 2001/09/06 21:43:25 stephenreed Exp $
@


1.12
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d26 1
a26 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.11 2001/09/06 14:49:47 stephenreed Exp $
d85 2
a86 1
    public ArrayList retrieveArgumentTypeConstraintRules(ConstraintRule rule) throws IOException {
d99 1
a99 1
        throws IOException {
d134 2
a135 1
                                                            CycVariable cycVariable) throws IOException {
d155 2
a156 1
                                         CycVariable cycVariable) throws IOException {
d186 1
a186 1
        throws IOException, UnknownHostException{
d219 2
a220 1
    public boolean isUnaryRuleConsistent(ConstraintRule unaryRule, CycVariable cycVariable) throws IOException {
@


1.11
log
@Renamed Rule to ConstraintRule, moved QueryLiteral class to inferencesupport.
@
text
@d7 1
d26 1
a26 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.10 2001/09/06 13:55:07 stephenreed Exp $
d88 1
a88 1
        return gatherPredicateVariableArgConstaints(rule.formula);
@


1.10
log
@Added inferencesupport and queryprocessor packages, refactored support classes among them.
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.9 2001/09/04 14:30:23 stephenreed Exp $
d84 1
a84 1
    public ArrayList retrieveArgumentTypeConstraintRules(Rule rule) throws IOException {
d158 1
a158 1
            Rule rule = new Rule(ruleString);
d188 1
a188 1
            Rule rule = new Rule(ruleString);
d215 1
a215 1
    public boolean isUnaryRuleConsistent(Rule unaryRule, CycVariable cycVariable) throws IOException {
d238 1
a238 1
            Rule rule = (Rule) constraintProblem.constraintRules.get(i);
@


1.9
log
@Renamed HighCardinalityDomains to VariableDomainPopulator, in preparation
for a reworking of the variable domain population technique.  The previous
idea of augmenting the constraint problem with the constraint problem argument
constraints is not efficient in a few cases where most of the rules involve
high cardinality situations.

The new technique will determine the best rule to instantiate domains for each
variable, and whether to perform the instantiation immediately, or to postpone it
for the forward checking search.  A new api call was added to get the instantiation
counts from the OpenCyc indexing mechanism.
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.8 2001/08/31 15:45:42 stephenreed Exp $
a268 5





@


1.8
log
@Renamed rule instance variable to formula, continued backchain test cases
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.7 2001/08/30 23:35:11 stephenreed Exp $
d52 1
a52 1
    protected int verbosity = 9;
@


1.7
log
@Improved backchain rule filtering
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.6 2001/08/21 14:34:31 stephenreed Exp $
a84 2
        ArrayList result = new ArrayList();
        CycConstant predicate = rule.getPredicate();
d87 19
a105 3
        for (int i = 0; i < rule.getArguments().size(); i++) {
            Object argument = rule.getArguments().get(i);
            if (rule.getVariables().contains(argument)) {
d107 2
a108 2
                int argPosition = i + 1;
                result.addAll(retrieveArgumentTypeConstraintRules(predicate,
d112 3
d118 1
@


1.6
log
@Implemented gathering of candidate backchain rules from the KB
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.5 2001/08/20 14:00:07 stephenreed Exp $
d138 1
a138 1
            CycConstant collection = (CycConstant) isas.get(i);
d168 1
a168 1
            CycConstant collection = (CycConstant) genls.get(i);
d197 1
a197 1
    public boolean isUnaryRuleConsistent(Rule unaryRule, CycVariable cycVariable) {
d199 2
a200 2
        CycConstant consideringIsaCollection = null;
        CycConstant consideringGenlsCollection = null;
d227 3
a229 3
                CycConstant isaCollection = (CycConstant) rule.getArguments().third();
                if (areDisjointCollections(consideringIsaCollection, isaCollection)) {
                    if (verbosity > 3)
d236 3
a238 3
                CycConstant genlsCollection = (CycConstant) rule.getArguments().third();
                if (areDisjointCollections(consideringGenlsCollection, genlsCollection)) {
                    if (verbosity > 3)
a251 4
    //TODO replace with CycAccess method
    protected boolean areDisjointCollections(CycConstant collection1, CycConstant collection2) {
        return false;
    }
@


1.5
log
@Geting unit tests working for ProblemParser and arg constraints gathering.
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.4 2001/08/17 13:57:21 stephenreed Exp $
d143 1
a143 1
                System.out.println(predicate.cyclify() +
d173 1
a173 1
                System.out.println(predicate.cyclify() +
@


1.4
log
@Added more methods to argument type constraints class
@
text
@d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.3 2001/08/16 23:04:57 stephenreed Exp $
d87 2
@


1.3
log
@Added argument type constraint rule augmentation.
@
text
@d5 1
d25 1
a25 1
 * @@version $Id: ArgumentTypeConstrainer.java,v 1.2 2001/08/13 16:14:44 stephenreed Exp $
a91 1
                System.out.println("rule=" + rule.cyclify() + " variable=" + cycVariable + " argPosition=" + argPosition);
d115 1
a115 1
        //result.addAll(retrieveArgNGenls(predicate, argPosition, cycVariable));
d137 7
a143 13
            if (collection.equals(CycAccess.current().getConstantByName("Thing"))) {
                if (verbosity > 3)
                    System.out.println("ignoring " + predicate.cyclify() + " arg type #$isa #$Thing at arg position " + argPosition);
            }
            else {
                String ruleString = "(#$isa " + cycVariable + " " + collection.cyclify() + ")";
                Rule rule = new Rule(ruleString);
                result.add(rule);
                if (verbosity > 3)
                    System.out.println(predicate.cyclify() +
                                       " has #$argNIsa constraint at arg position " + argPosition +
                                       "  \n" + rule.cyclify());
            }
d149 1
a149 1
     * Retrieves the #$argNGenls constraint rules for the given predicate at the given
d159 4
a162 3
    public ArrayList retrieveArgNGenls(CycConstant predicate,
                                          int argPosition,
                                          CycVariable cycVariable) {
d164 11
a174 8

        //TODO retrieve argNGenls constraints
        Rule rule = null;
        if (verbosity > 3)
            System.out.println(predicate +
                               " has #$argNGenls constraint at arg position " + argPosition +
                               "  \n" + rule);

@


1.2
log
@Revised copyright notice to Cycorp Inc.
@
text
@d4 1
d6 1
d24 1
a24 1
 * @@version $Id: ConstraintProblem.java,v 1.4 2001/08/02 11:14:59 stephenreed Exp $
d83 1
a83 1
    public ArrayList retrieveArgumentTypeConstraintRules(Rule rule) {
d91 1
d112 1
a112 1
                                                            CycVariable cycVariable) {
d115 1
a115 1
        result.addAll(retrieveArgNGenls(predicate, argPosition, cycVariable));
d132 1
a132 1
                                         CycVariable cycVariable) {
d134 17
a150 8

        //TODO retrieve argNIsa constraints
        Rule rule = null;
        if (verbosity > 3)
            System.out.println(predicate +
                               " has #$argNIsa constraint at arg position " + argPosition +
                               "  \n" + rule);

@


1.1
log
@Added three modules to support backchaining inference.
@
text
@d25 1
a25 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
d81 1
a81 1
    protected ArrayList retrieveArgumentTypeConstraintRules(Rule rule) {
d107 1
a107 1
    protected ArrayList retrieveArgumentTypeConstraintRules(CycConstant predicate,
d127 1
a127 1
    protected ArrayList retrieveArgNIsas(CycConstant predicate,
d153 1
a153 1
    protected ArrayList retrieveArgNGenls(CycConstant predicate,
d185 1
a185 1
    protected boolean isUnaryRuleConsistent(Rule unaryRule, CycVariable cycVariable) {
d255 1
a255 1
    protected void setVerbosity(int verbosity) {
@

