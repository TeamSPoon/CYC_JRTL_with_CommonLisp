head	1.15;
access;
symbols
	PRE_1_0:1.15;
locks; strict;
comment	@# @;


1.15
date	2003.02.24.22.41.33;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.02.14.19;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.06.02.57.03;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.20.16.39.19;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.04.21.38.26;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.04.02.21.04;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.01.23.24.06;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.01.16.18.53;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.01.03.06.00;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.31.15.07.56;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.31.00.14.41;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.29.23.30.15;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.29.00.54.59;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.27.04.49.35;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.25.23.54.58;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Passing unit tests for State Machine Interpretation
@
text
@package org.opencyc.uml.statemachine;

import java.util.*;
import org.opencyc.uml.action.*;
import org.opencyc.uml.core.*;
import org.opencyc.uml.commonbehavior.*;
import org.opencyc.uml.interpreter.*;

/**
 * State from the UML State_Machines package.
 *
 * @@version $Id: State.java,v 1.14 2003/02/09 02:14:19 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public abstract class State extends StateVertex {

    /**
     * the entry procedure for this state
     */
    protected Procedure entry;

    /**
     * the input pin bindings for the state entry procedure
     */
    protected ArrayList entryInputBindings = new ArrayList();

    /**
     * the output pin bindings for the state entry procedure
     */
    protected ArrayList entryOutputBindings = new ArrayList();

    /**
     * the exit procedure for this state
     */
    protected Procedure exit;

    /**
     * the input pin bindings for the state exit procedure
     */
    protected ArrayList exitInputBindings = new ArrayList();

    /**
     * the output pin bindings for the state exit procedure
     */
    protected ArrayList exitOutputBindings = new ArrayList();

    /**
     * the do activity for this state
     */
    protected Procedure doActivity;

    /**
     * the input pin bindings for the state do activity procedure
     */
    protected ArrayList doActivityInputBindings = new ArrayList();

    /**
     * the output pin bindings for the state do activity procedure
     */
    protected ArrayList doActivityOutputBindings = new ArrayList();

    /**
     * the deferrable events for this state
     */
    protected ArrayList deferrableEvent = new ArrayList();

    /**
     * the internal transitions for this state
     */
    protected ArrayList internalTransition = new ArrayList();

    /**
     * the state machine for this state (if top)
     */
    protected StateMachine stateMachine;

    /**
     * the state interpreter for this state
     */
    protected StateInterpreter stateInterpreter;

    /**
     * Indicates whether this state is currently active during execution of
     * the state machine.  A state becomes active when it is entered as a
     * result of some transition, and becomes inactive if it is exited as a
     * result of a transition.
     */
    protected boolean isActive;

    /**
     * the do activity thread for this state
     */
    protected DoActivity doActivityThread;

    /**
     * Constructs a new State object.
     */
    public State() {
    }

    /**
     * Gets the entry procedure for this state.
     *
     * @@return the entry procedure for this state
     */
    public Procedure getEntry () {
        return entry;
    }

    /**
     * Sets the entry procedure for this state.
     *
     * @@param entry the entry procedure for this state
     */
    public void setEntry (Procedure entry) {
        this.entry = entry;
    }

    /**
     * Gets the input pin bindings for the state entry procedure
     *
     * @@return the input pin bindings for the state entry procedure
     */
    public ArrayList getEntryInputBindings () {
        return entryInputBindings;
    }

    /**
     * Adds an input pin binding for the state entry procedure
     *
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state entry procedure
     */
    public void addEntryInputBinding (InputPin inputPin, Object boundObject) {
        InputBinding inputBinding =
            new InputBinding(inputPin, boundObject);
        entryInputBindings.add(inputBinding);
    }

    /**
     * Sets the input pin bindings for the state entry procedure
     *
     * @@param effectInputBindings the input pin bindings for the state entry procedure
     */
    public void setEntryInputBindings (ArrayList effectInputBindings) {
        this.entryInputBindings = entryInputBindings;
    }

    /**
     * Gets the output pin bindings for the state entry procedure
     *
     * @@return the output pin bindings for the state entry procedure
     */
    public ArrayList getEntryOutputBindings () {
        return entryOutputBindings;
    }

    /**
     * Adds an output pin binding for the state entry procedure
     *
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state entry procedure
     */
    public void addEntryOutputBinding (OutputPin outputPin, StateVariable stateVariable) {
        OutputBinding outputBinding =
            new OutputBinding(outputPin, stateVariable);
        entryOutputBindings.add(outputBinding);
    }

    /**
     * Sets the output pin bindings for the state entry procedure
     *
     * @@param effectOutputBindings the output pin bindings for the state entry procedure
     */
    public void setEntryOutputBindings (ArrayList effectOutputBindings) {
        this.entryOutputBindings = entryOutputBindings;
    }

    /**
     * Gets the exit procedure for this state.
     *
     * @@return the exit procedure for this state
     */
    public Procedure getExit () {
        return exit;
    }

    /**
     * Sets the exit procedure for this state.
     *
     * @@param exit the exit procedure for this state
     */
    public void setExit (Procedure exit) {
        this.exit = exit;
    }

    /**
     * Gets the input pin bindings for the state exit procedure
     *
     * @@return the input pin bindings for the state exit procedure
     */
    public ArrayList getExitInputBindings () {
        return exitInputBindings;
    }

    /**
     * Adds an input pin binding for the state exit procedure
     *
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state exit procedure
     */
    public void addExitInputBinding (InputPin inputPin, Object boundObject) {
        InputBinding inputBinding =
            new InputBinding(inputPin, boundObject);
        exitInputBindings.add(inputBinding);
    }

    /**
     * Sets the input pin bindings for the state exit procedure
     *
     * @@param effectInputBindings the input pin bindings for the state exit procedure
     */
    public void setExitInputBindings (ArrayList effectInputBindings) {
        this.exitInputBindings = exitInputBindings;
    }

    /**
     * Gets the output pin bindings for the state exit procedure
     *
     * @@return the output pin bindings for the state exit procedure
     */
    public ArrayList getExitOutputBindings () {
        return exitOutputBindings;
    }

    /**
     * Adds an output pin binding for the state exit procedure
     *
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state exit procedure
     */
    public void addExitOutputBinding (OutputPin outputPin, StateVariable stateVariable) {
        OutputBinding outputBinding =
            new OutputBinding(outputPin, stateVariable);
        exitOutputBindings.add(outputBinding);
    }

    /**
     * Sets the output pin bindings for the state exit procedure
     *
     * @@param effectOutputBindings the output pin bindings for the state exit procedure
     */
    public void setExitOutputBindings (ArrayList effectOutputBindings) {
        this.exitOutputBindings = exitOutputBindings;
    }

    /**
     * Gets the deferrable events for this state.
     *
     * @@return the deferrable events for this state
     */
    public ArrayList getDeferrableEvent () {
        return deferrableEvent;
    }

    /**
     * Sets the deferrable events for this state.
     *
     * @@param deferrableEvent the deferrable events for this state
     */
    public void setDeferrableEvent (ArrayList deferrableEvent) {
        this.deferrableEvent = deferrableEvent;
    }

    /**
     * Gets the do activity for this state.
     *
     * @@return the do activity for this state
     */
    public Procedure getDoActivity () {
        return doActivity;
    }

    /**
     * Sets the do activity for this state.
     *
     * @@param doActivity the do activity for this state
     */
    public void setDoActivity (Procedure doActivity) {
        this.doActivity = doActivity;
    }

    /**
     * Gets the state machine for this state (if top).
     *
     * @@return the state machine for this state
     */
    public StateMachine getStateMachine () {
        return stateMachine;
    }

    /**
     * Sets the state machine for this state (if top).
     *
     * @@param stateMachine the state machine for this state
     */
    public void setStateMachine (StateMachine stateMachine) {
        this.stateMachine = stateMachine;
    }


    /**
     * Gets whether this state is currently active during execution of
     * the state machine.
     *
     * @@return whether this state is currently active during execution of
     * the state machine
     */
    public boolean isActive () {
        return isActive;
    }

    /**
     * Sets whether this state is currently active during execution of
     * the state machine.
     *
     * @@param isActive whether this state is currently active during execution of
     * the state machine
     */
    public void setIsActive (boolean isActive) {
        this.isActive = isActive;
    }

    /**
     * Gets the do activity thread for this state.
     *
     * @@return the do activity thread for this state
     */
    public DoActivity getDoActivityThread () {
        return doActivityThread;
    }

    /**
     * Sets the do activity thread for this state.
     *
     * @@param doActivityThread the do activity thread for this state
     */
    public void setDoActivityThread (DoActivity doActivityThread) {
        this.doActivityThread = doActivityThread;
    }

    /**
     * Gets the input pin bindings for the state doActivity procedure
     *
     * @@return the input pin bindings for the state doActivity procedure
     */
    public ArrayList getDoActivityInputBindings () {
        return doActivityInputBindings;
    }

    /**
     * Adds an input pin binding for the state doActivity procedure
     *
     * @@param inputPin the given input pin
     * @@param boundObject the object bound to the given input pin
     * @@return the input pin bindings for the state doActivity procedure
     */
    public void addDoActivityInputBinding (InputPin inputPin, Object boundObject) {
        InputBinding inputBinding =
            new InputBinding(inputPin, boundObject);
        doActivityInputBindings.add(inputBinding);
    }

    /**
     * Sets the input pin bindings for the state doActivity procedure
     *
     * @@param effectInputBindings the input pin bindings for the state doActivity procedure
     */
    public void setDoActivityInputBindings (ArrayList effectInputBindings) {
        this.doActivityInputBindings = doActivityInputBindings;
    }

    /**
     * Gets the output pin bindings for the state doActivity procedure
     *
     * @@return the output pin bindings for the state doActivity procedure
     */
    public ArrayList getDoActivityOutputBindings () {
        return doActivityOutputBindings;
    }

    /**
     * Adds an output pin binding for the state doActivity procedure
     *
     * @@param outputPin the given output pin
     * @@param stateVariable the state variable bound to the given output pin
     * @@return the output pin bindings for the state doActivity procedure
     */
    public void addDoActivityOutputBinding (OutputPin outputPin, StateVariable stateVariable) {
        OutputBinding outputBinding =
            new OutputBinding(outputPin, stateVariable);
        doActivityOutputBindings.add(outputBinding);
    }

    /**
     * Sets the output pin bindings for the state doActivity procedure
     *
     * @@param effectOutputBindings the output pin bindings for the state doActivity procedure
     */
    public void setDoActivityOutputBindings (ArrayList effectOutputBindings) {
        this.doActivityOutputBindings = doActivityOutputBindings;
    }

    /**
     * Gets the internal transitions for this state.
     *
     * @@return the internal transitions for this state
     */
    public ArrayList getInternalTransition () {
        return internalTransition;
    }

    /**
     * Sets the internal transitions for this state.
     *
     * @@param internalTransition the internal transitions for this state
     */
    public void setInternalTransition (ArrayList internalTransition) {
        this.internalTransition = internalTransition;
    }
    /**
     * Gets the state interpreter for this state.
     *
     * @@return the state interpreter for this state
     */
    public StateInterpreter getStateInterpreter () {
        return stateInterpreter;
    }

    /**
     * Sets the state interpreter for this state.
     *
     * @@param stateInterpreter the state interpreter for this state
     */
    public void setStateInterpreter (StateInterpreter stateInterpreter) {
        this.stateInterpreter = stateInterpreter;
    }


}@


1.14
log
@Completed coding of procedure bindings - ready to test them
@
text
@d12 1
a12 1
 * @@version $Id: State.java,v 1.13 2003/02/06 02:57:03 stephenreed Exp $
d44 1
a44 1
    protected ArrayList entryInputBindings;
d49 1
a49 1
    protected ArrayList entryOutputBindings;
d59 1
a59 1
    protected ArrayList exitInputBindings;
d64 1
a64 1
    protected ArrayList exitOutputBindings;
d74 1
a74 1
    protected ArrayList doActivityInputBindings;
d79 1
a79 1
    protected ArrayList doActivityOutputBindings;
a156 2
        if (entryInputBindings == null)
            entryInputBindings = new ArrayList();
a187 2
        if (entryOutputBindings == null)
            entryOutputBindings = new ArrayList();
a236 2
        if (exitInputBindings == null)
            exitInputBindings = new ArrayList();
a267 2
        if (exitOutputBindings == null)
            exitOutputBindings = new ArrayList();
a393 2
        if (doActivityInputBindings == null)
            doActivityInputBindings = new ArrayList();
a424 2
        if (doActivityOutputBindings == null)
            doActivityOutputBindings = new ArrayList();
@


1.13
log
@Refactoring of the UML state machine extractor.
Work in progress  and will not all compile.
@
text
@d12 1
a12 1
 * @@version $Id: State.java,v 1.12 2002/11/20 16:39:19 stephenreed Exp $
d155 2
a156 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(inputPin, boundObject);
d159 1
a159 1
        entryInputBindings.add(procedureArgumentBinding);
d188 2
a189 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(outputPin, stateVariable);
d192 1
a192 1
        entryOutputBindings.add(procedureArgumentBinding);
d239 2
a240 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(inputPin, boundObject);
d243 1
a243 1
        exitInputBindings.add(procedureArgumentBinding);
d272 2
a273 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(outputPin, stateVariable);
d276 1
a276 1
        exitOutputBindings.add(procedureArgumentBinding);
d400 2
a401 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(inputPin, boundObject);
d404 1
a404 1
        doActivityInputBindings.add(procedureArgumentBinding);
d433 2
a434 2
        ProcedureArgumentBinding procedureArgumentBinding =
            new ProcedureArgumentBinding(outputPin, stateVariable);
d437 1
a437 1
        doActivityOutputBindings.add(procedureArgumentBinding);
@


1.12
log
@Removing previous state machine implementation which is
replaced by org.opencyc.uml.statemachine package
@
text
@d4 1
d12 1
a12 1
 * @@version $Id: State.java,v 1.11 2002/11/04 21:38:26 stephenreed Exp $
d42 10
d57 6
a62 1
     * the deferrable events for this state
d64 1
a64 1
    protected ArrayList deferrableEvent = new ArrayList();
d72 15
d139 66
d223 66
a364 1

d384 66
d483 1
@


1.11
log
@Added primitive types for state machine interpretation.
@
text
@d11 1
a11 1
 * @@version $Id: State.java,v 1.10 2002/11/04 02:21:04 stephenreed Exp $
a76 1

@


1.10
log
@Added more support for UML state machine interpretation.
@
text
@d11 1
a11 1
 * @@version $Id: State.java,v 1.9 2002/11/01 23:24:06 stephenreed Exp $
d33 1
a33 1
public class State extends StateVertex {
@


1.9
log
@Removed references to Action per UML Action Semantics revision.
@
text
@d4 1
d11 1
a11 1
 * @@version $Id: State.java,v 1.8 2002/11/01 16:18:53 stephenreed Exp $
d56 5
d222 17
@


1.8
log
@More support for UML StateMachines.
@
text
@d10 1
a10 1
 * @@version $Id: State.java,v 1.7 2002/11/01 03:06:00 stephenreed Exp $
d35 1
a35 1
     * the entry action for this state
d37 1
a37 1
    protected Action entry;
d40 1
a40 1
     * the exit action for this state
d42 1
a42 1
    protected Action exit;
d52 1
a52 1
    protected Action doActivity;
d85 1
a85 1
     * Gets the entry action for this state.
d87 1
a87 1
     * @@return the entry action for this state
d89 1
a89 1
    public Action getEntry () {
d94 1
a94 1
     * Sets the entry action for this state.
d96 1
a96 1
     * @@param entry the entry action for this state
d98 1
a98 1
    public void setEntry (Action entry) {
d103 1
a103 1
     * Gets the exit action for this state.
d105 1
a105 1
     * @@return the exit action for this state
d107 1
a107 1
    public Action getExit () {
d112 1
a112 1
     * Sets the exit action for this state.
d114 1
a114 1
     * @@param exit the exit action for this state
d116 1
a116 1
    public void setExit (Action exit) {
d143 1
a143 1
    public Action getDoActivity () {
d152 1
a152 1
    public void setDoActivity (Action doActivity) {
@


1.7
log
@Adding more UML state machine support.
@
text
@d10 1
a10 1
 * @@version $Id: State.java,v 1.6 2002/10/31 15:07:56 stephenreed Exp $
a57 1

@


1.6
log
@Added more support for UML state machine interpretation.
@
text
@d10 1
a10 1
 * @@version $Id: State.java,v 1.5 2002/10/31 00:14:41 stephenreed Exp $
d77 1
a77 1
    protected Thread doActivityThread;
d204 1
a204 1
    public Thread getDoActivityThread () {
d213 1
a213 1
    public void setDoActivityThread (Thread doActivityThread) {
@


1.5
log
@Slight code fixes for UML state machine support.
@
text
@d5 1
d10 1
a10 1
 * @@version $Id: State.java,v 1.4 2002/10/29 23:30:15 stephenreed Exp $
d59 6
a84 1

d215 18
@


1.4
log
@Added getter and setter methods.
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.3 2002/10/29 00:54:59 stephenreed Exp $
d58 13
d167 42
@


1.3
log
@Aligning UML support with v 1.4
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.2 2002/10/27 04:49:35 stephenreed Exp $
d34 1
a34 1
     * entry action for this state
d36 1
a36 1
    public Action entry;
d39 1
a39 1
     * exit action for this state
d41 1
a41 1
    public Action exit;
d44 1
a44 1
     * deferrable events for this state
d46 1
a46 1
    public ArrayList deferrableEvent = new ArrayList();
d49 1
a49 1
     * do activity for this state
d51 1
a51 1
    public Action doActivity;
d54 1
a54 1
     * state machine for this state (if top)
d56 1
a56 1
    public StateMachine stateMachine;
d64 92
@


1.2
log
@Adding more uml statemachine support
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.1 2002/10/25 23:54:58 stephenreed Exp $
d31 1
a31 1
public class State {
@


1.1
log
@Adding classes for UML state machines
@
text
@d4 1
d9 1
a9 1
 * @@version $Id: ModelElement.java,v 1.1 2002/10/25 23:23:57 stephenreed Exp $
d36 1
a36 1
    Action entry;
d41 1
a41 1
    Action exit;
d46 1
a46 1
    ArrayList deferrableEvent = new ArrayList();
d51 1
a51 1
    Action doActivity;
d56 1
a56 1
    StateMachine stateMachine;
@

