head	1.27;
access;
symbols
	PRE_1_0:1.27;
locks; strict;
comment	@# @;


1.27
date	2003.02.09.19.45.21;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.06.02.57.03;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.29.00.18.09;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.27.22.49.40;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.10.22.31.40;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.09.21.52.13;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.09.00.00.20;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.27.14.08.35;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.26.00.15.21;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.14.22.06.05;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.14.00.35.40;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.09.15.18.55;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.06.16.35.14;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.06.04.51.02;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.06.00.24.31;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.05.15.44.15;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.05.00.35.25;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.01.16.18.50;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.01.03.05.58;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.31.20.58.41;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.31.15.07.55;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.31.03.16.53;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.31.02.50.54;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.31.00.12.56;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.30.15.52.01;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.28.05.05.01;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.28.03.26.20;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.27
log
@removed file
@
text
@package org.opencyc.uml.interpreter;

import java.io.*;
import java.util.*;
import javax.swing.tree.*;
import org.apache.commons.collections.*;
import org.opencyc.api.*;
import org.opencyc.cycobject.*;
import org.opencyc.uml.commonbehavior.*;
import org.opencyc.uml.statemachine.*;
import org.opencyc.util.*;

/**
 * Interprets a UML StateMachine.
 *
 * @@version $Id: Interpreter.java,v 1.26 2003/02/06 02:57:03 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Interpreter {

    /**
     * The quiet verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public static final int QUIET_VERBOSITY = 0;

    /**
     * The default verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public static final int DEFAULT_VERBOSITY = 3;

    /**
     * Sets verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * the event queue
     */
    protected UnboundedFifoBuffer eventQueue = new UnboundedFifoBuffer();

    /**
     * the current event
     */
    protected Event currentEvent;

    /**
     * the state machine
     */
    protected StateMachine stateMachine;

    /**
     * The state configuration of all states, which is a tree consisting of a top state
     * at the root down to individual simple states at the leaves.  States
     * other than the leaf states are composite states, and branches in
     * the state configuration are concurrent composite states.
     */
    protected DefaultTreeModel allStatesConfiguration;

    /**
     * a dictionary associating states with tree nodes in the all
     * states configuration
     */
    protected HashMap allStates = new HashMap();

    /**
     * The (active) state configuration, which is a tree consisting of a top state
     * at the root down to individual active simple states at the leaves.  States
     * other than the leaf states are composite states, and branches in
     * the state configuration are concurrent composite states.
     */
    protected DefaultTreeModel stateConfiguration;

    /**
     * a dictionary associating active states with tree nodes in the active
     * state configuration
     */
    protected HashMap activeStates;

    /**
     * The list of selected transitions for firing.  Each of these has an
     * active source state, a matching trigger event and a guard expression
     * which evaluates true.
     */
    protected ArrayList selectedTransitions;

    /**
     * an expression evaluator
     */
    protected ExpressionEvaluator expressionEvaluator;

    /**
     * the cyc access instance
     */
    protected CycAccess cycAccess;

    /**
     * the state machine definition microtheory
     */
    protected CycFort stateMachineDefinitionMt;

    /**
     * the expression evaluation state context
     */
    protected CycConstant stateMt;

    /**
     * the global temporary interpreter workspace
     */
    protected CycFort temporaryWorkspaceMt;

    /**
     * the state machine factory used to create and destroy events
     */
    protected StateMachineFactory stateMachineFactory;

    /**
     * indicates that the state machine has terminated
     */
    protected boolean isTerminated = false;

    /**
     * the context stack pool
     */
    protected ContextStackPool contextStackPool;

    /**
     * Constructs a new Interpreter object.
     */
    public Interpreter() {
    }

    /**
     * Constructs a new Interpreter object given a state machine
     * to interpret given the state machine to interpret
     *
     * @@param stateMachine the state machine to interpret
     * @@param cycAccess the Cyc access instance
     * @@param contextStatePool the context state pool
     */
    public Interpreter(StateMachine stateMachine,
                       CycAccess cycAccess,
                       ContextStackPool contextStackPool)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this(stateMachine,
             cycAccess,
             contextStackPool,
             Interpreter.DEFAULT_VERBOSITY);
    }

    /**
     * Constructs a new Interpreter object given the state machine
     * to interpret.
     *
     * @@param stateMachine the state machine to interpret
     * @@param cycAccess the Cyc access instance
     * @@param contextStatePool the context state pool
     * @@param verbosity indicates the verbosity of the interpreter's
     * diagnostic output - 9 = maximum, 0 = quiet
     */
    public Interpreter(StateMachine stateMachine,
                       CycAccess cycAccess,
                       ContextStackPool contextStackPool,
                       int verbosity)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this.stateMachine = stateMachine;
        this.cycAccess = cycAccess;
        this.contextStackPool = contextStackPool;
        this.verbosity = verbosity;
        if (verbosity > 2)
            Log.current.println("Interpreting " + stateMachine.toString());
        initialize();
    }

    /**
     * Initializes this object.
     */
    protected void initialize ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        Log.makeLog("state-machine-interpreter.log");
        expressionEvaluator = new ExpressionEvaluator(cycAccess,
                                                      verbosity);
        stateMachineFactory = new StateMachineFactory();
        stateMachineFactory.setStateMachine(stateMachine);
        stateMachineFactory.setNamespace(stateMachine.getNamespace());
        CycFort stateMachineTerm = cycAccess.getKnownConstantByName(stateMachine.getName());
        stateMachineDefinitionMt =
            (CycFort) cycAccess.getArg2("umlStateMachineDefinition",
                                       stateMachineTerm,
                                       cycAccess.getKnownConstantByName("UMLStateMachineSpindleHeadMt"));
        if (verbosity > 2)
            Log.current.println("  defined in " + stateMachineDefinitionMt.cyclify());
        stateMt = contextStackPool.allocateStateMachineContextFrame(null,
                                                                    stateMachineDefinitionMt,
                                                                    stateMachineTerm);
        cycAccess.unassertMtContentsWithoutTranscript(stateMt);
    }

    /**
     * Executes the Interpreter application.
     *
     * @@param args ignored
     */
    public static void main(String[] args) {
        try {
        Interpreter interpreter = new Interpreter();
        interpreter.interpret();
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Terminates the interpretation of the state machine.
     */
    public void terminate ()
        throws IOException, CycApiException, ExpressionEvaluationException  {
        if (verbosity > 2)
            Log.current.println("Terminating " + stateMachine.toString());
        isTerminated = true;
        contextStackPool.deallocateContextFrame(stateMt);
    }

    /**
     * Interprets the state machine.
     */
    public void interpret ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        if (verbosity > 2)
            Log.current.println("Interpreting UML state machine " + stateMachine.getName() +
                                "\n  with evaluation context " + stateMt);
        formAllStatesConfiguration();
        formInitialStateConfiguration();
        while (! isTerminated) {
            eventDispatcher();
            eventProcessor();
            fireSelectedTransitions();
            if (currentEvent != null) {
                if (verbosity > 2)
                    Log.current.println("Destroying " + currentEvent.toString());
                stateMachineFactory.destroyEvent(currentEvent);
                currentEvent = null;
            }
        }
    }

    /**
     * Forms the all states configuration for this
     * state machine.
     */
    protected void formAllStatesConfiguration () {
        State topState = stateMachine.getTop();
        if (verbosity > 2)
            Log.current.println("Forming all states configuration from " + topState.toString());
        DefaultMutableTreeNode root = new DefaultMutableTreeNode(topState);
        allStates.put(topState, root);
        allStatesConfiguration = new DefaultTreeModel(root);
        formAllStatesConfigurationFrom(topState, root);
    }

    /**
     * Recursively forms the all states configuration from the given
     * state and tree node.
     *
     * @@param state the given state to be placed into the all states configuration
     * @@param parentNode the parent tree node in the all states configuration tree
     */
    protected void formAllStatesConfigurationFrom(State state, DefaultMutableTreeNode parentNode) {
        if (state instanceof CompositeState) {
            CompositeState compositeState = (CompositeState) state;
            Iterator subVertices = compositeState.getSubVertex().iterator();
            while (subVertices.hasNext()) {
                StateVertex subVertex = (StateVertex) subVertices.next();
                if (subVertex instanceof State) {
                    DefaultMutableTreeNode stateNode = new DefaultMutableTreeNode(subVertex);
                    parentNode.add(stateNode);
                    allStates.put(subVertex, stateNode);
                    formAllStatesConfigurationFrom((State) subVertex, stateNode);
                }
            }
        }
    }

    /**
     * Forms the initial (active) state configuration for this
     * state machine.
     */
    protected void formInitialStateConfiguration ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        State topState = stateMachine.getTop();
        if (verbosity > 2)
            Log.current.println("Forming initial state configuration from " + topState.toString());
        DefaultMutableTreeNode root = new DefaultMutableTreeNode(topState);
        activeStates = new HashMap();
        activeStates.put(topState, root);
        stateConfiguration = new DefaultTreeModel(root);
        if (topState instanceof CompositeState) {
            CompositeState compositeTopState = (CompositeState) topState;
            if (compositeTopState.isConcurrent()) {
                //TODO
                throw new RuntimeException("Concurrent initial states are not implemented.");
            }
            Iterator subVertices = compositeTopState.getSubVertex().iterator();
            while (subVertices.hasNext()) {
                StateVertex subVertex = (StateVertex) subVertices.next();
                if (subVertex instanceof PseudoState &&
                    ((PseudoState) subVertex).getKind() == PseudoState.PK_INITIAL) {
                    if (verbosity > 2)
                        Log.current.println("Starting from " + subVertex.toString());
                    PseudoState initialState = (PseudoState) subVertex;
                    Transition transition = (Transition) initialState.getOutgoing().get(0);
                    transitionEnter(transition);
                }
            }
        }
        else {
            topState.isActive();
            topState.setStateInterpreter(new StateInterpreter(this, topState));
            topState.getStateInterpreter().enter();
        }
        if (verbosity > 2)
            System.out.print(displayStateConfigurationTree());
    }

    /**
     * Processes dispatched event instances according to the general semantics
     * of UML state machines and the specific form of this state machine.
     * Selects the transitions from active source states which are triggered
     * by the current event.
     */
    protected void eventProcessor ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        selectedTransitions = new ArrayList();
        Iterator activeStatesIter = activeStates.keySet().iterator();
        while (activeStatesIter.hasNext()) {
            State state = (State) activeStatesIter.next();
            if (verbosity > 2)
                Log.current.println("Considering transitions from " + state.toString());
            Iterator transitions = state.getInternalTransition().iterator();
            selectTransitions(transitions);
            transitions = state.getOutgoing().iterator();
            selectTransitions(transitions);
        }
    }

    /**
     * Selects transitions from the given state transition iterator.
     *
     * @@param transitions the given state transition iterator
     */
    protected void selectTransitions (Iterator transitions)
        throws IOException, CycApiException, ExpressionEvaluationException {
        while (transitions.hasNext()) {
            Transition transition = (Transition) transitions.next();
            if (currentEventEnables(transition)) {
                if (verbosity > 2)
                    Log.current.println("  " + transition.toString() +
                                        " enabled by " + currentEvent.toString());
                BooleanExpression guardExpression = transition.getGuard().getexpression();
                if ((guardExpression == null) ||
                    expressionEvaluator.evaluateBoolean(guardExpression, stateMt)) {
                    if (verbosity > 2)
                        Log.current.println("    selected " + transition.toString());
                    selectedTransitions.add(transition);
                }
            }
        }
    }


    /**
     * Determines whether the given transition can be triggered by the current event.
     *
     * @@param transition the given transition
     * @@return whether the given transition can be triggered by the current event
     */
    protected boolean currentEventEnables (Transition transition) {
        Event trigger = transition.getTrigger();
        if (trigger == null)
            return true;
        return trigger.getClass().equals(currentEvent.getClass());
    }


    /**
     * Selects and dequeues event instances from the event queue for
     * processing.
     */
    protected void eventDispatcher () {
        if (eventQueue.isEmpty()) {
            currentEvent = null;
            if (verbosity > 2)
                Log.current.println("No events to dispatch");
        }
        else {
            currentEvent = (Event) eventQueue.get();
            if (verbosity > 2)
                Log.current.println("Dispatching " + currentEvent.toString());
        }
    }

    /**
     * Fires the selected transitions and runs the associated
     * actions to completion.
     */
    protected void fireSelectedTransitions ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        Iterator iter = selectedTransitions.iterator();
        while (iter.hasNext()) {
            Transition transition = (Transition) iter.next();
            if (transition.isSelfTransition())
                 internalTransition(transition);
            else {
                transitionExit(transition);
                transitionEnter(transition);
            }
        }
    }

    /**
     * Interprets the given internal transition.
     *
     * @@param transition the given internal transition
     */
    protected void internalTransition (Transition transition)
        throws IOException, CycApiException, ExpressionEvaluationException {
        State targetState = (State) transition.getTarget();
        if (verbosity > 2)
            Log.current.println("Internal transition " + transition.toString() +
                                " in " + targetState.toString());
        targetState.getStateInterpreter().performTransitionEffect(transition);
    }

    /**
     * Transitions from a state with the given transition.
     *
     * @@param transition the given transition
     */
    protected void transitionExit (Transition transition)
        throws IOException, CycApiException, ExpressionEvaluationException {
        StateVertex source = transition.getSource();
        if (source instanceof State) {
            State sourceState = (State) source;
            if (sourceState.getStateInterpreter() == null)
                sourceState.setStateInterpreter(new StateInterpreter(this, sourceState));
            sourceState.getStateInterpreter().interpretTransitionExit(transition);
        }
        else {
            //TODO handle vertices
            throw new RuntimeException("Transitions from vertices not yet implemented.");
        }
    }

    /**
     * Transitions into a state with the given transition.
     *
     * @@param transition the given transition
     */
    protected void transitionEnter (Transition transition)
        throws IOException, CycApiException, ExpressionEvaluationException {
        StateVertex target = transition.getTarget();
        if (target instanceof State) {
            State targetState = (State) target;
            if (targetState.getStateInterpreter() == null)
                targetState.setStateInterpreter(new StateInterpreter(this, targetState));
            targetState.getStateInterpreter().interpretTransitionEntry(transition);
        }
        else {
            //TODO handle vertices
            throw new RuntimeException("Transitions into vertices not yet implemented.");
        }
    }

    /**
     * Adds an event to this state machine's event queue.
     *
     * @@param event the event to add  to this state machine's event queue
     */
    public void enqueueEvent (Event event) {
        eventQueue.add(event);
    }

    /**
     * Gets the current value of the given state variable.
     *
     * @@param stateVariable the given state variable
     * @@return the current value of the given state variable
     */
    public Object getStateVariableValue (String stateVariable)
        throws IOException, CycApiException, ExpressionEvaluationException {
        return getStateVariableValue(cycAccess.getKnownConstantByName(stateVariable));
    }

    /**
     * Gets the current value of the given state variable.
     *
     * @@param stateVariable the given state variable
     * @@return the current value of the given state variable
     */
    public Object getStateVariableValue (CycFort stateVariable)
        throws IOException, CycApiException, ExpressionEvaluationException {
        return cycAccess.getArg2(cycAccess.getKnownConstantByName("softwareParameterValue"),
                                 stateVariable,
                                 stateMt);
    }

    /**
     * Gets the state machine
     *
     * @@return the state machine
     */
    public StateMachine getStateMachine () {
        return stateMachine;
    }

    /**
     * Sets the state machine
     *
     * @@param stateMachine the state machine
     */
    public void setStateMachine (StateMachine stateMachine) {
        this.stateMachine = stateMachine;
    }


    /**
     * Gets the cyc access instance
     *
     * @@return the cyc access instance
     */
    public CycAccess getCycAccess () {
        return cycAccess;
    }

    /**
     * Sets the cyc access instance
     *
     * @@param cycAccess the cyc access instance
     */
    public void setCycAccess (CycAccess cycAccess) {
        this.cycAccess = cycAccess;
    }

    /**
     * Gets the state machine definition microtheory
     *
     * @@return the state machine definition microtheory
     */
    public CycFort getStateMachineDefinitionMt () {
        return stateMachineDefinitionMt;
    }

    /**
     * Sets the state machine definition microtheory
     *
     * @@param stateMachineDefinitionMt the state machine definition microtheory
     */
    public void setStateMachineDefinitionMt (CycFort stateMachineDefinitionMt) {
        this.stateMachineDefinitionMt = stateMachineDefinitionMt;
    }

    /**
     * Gets the expression evaluation state context
     *
     * @@return the expression evaluation state context
     */
    public CycConstant getStateMt () {
        return stateMt;
    }

    /**
     * Gets the  verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.  0 --> quiet ... 9 -> maximum diagnostic input.
     *
     * @@return  the  verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input
     */
    public int getVerbosity () {
        return verbosity;
    }

    /**
     * Sets verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Gets the current event.
     *
     * @@return the current event
     */
    public Event getCurrentEvent () {
        return currentEvent;
    }

    /**
     * Returns the Tree at the given active state.
     *
     * @@param state the given active state
     * @@return the sub tree of active states rooted at the given active state
     */
    public DefaultMutableTreeNode getActiveStatesRootedAt (State state) {
        Iterator activeStatesIter = activeStates.keySet().iterator();
        while (activeStatesIter.hasNext()) {
            State activeState = (State) activeStatesIter.next();
            if (state.equals(activeState)) {
                return (DefaultMutableTreeNode) activeStates.get(activeState);
            }
        }
        return null;
    }

    /**
     * Returns the list of states from the root down to the given state
     * in the all states configuration tree.
     *
     * @@param state the given state
     * @@return the list of states from the root down to the given state
     * in the all states configuration tree
     */
    protected Object[] getStatesFromRootTo (State state) {
        DefaultMutableTreeNode stateTreeNode = (DefaultMutableTreeNode) allStates.get(state);
        return (Object[]) stateTreeNode.getUserObjectPath();
    }

    /**
     * Returns the tree node associated with the given state in the
     * active configuration state tree.
     *
     * @@param state the given state
     * @@return  the tree node associated with the given state in the
     * active configuration state tree
     */
    public DefaultMutableTreeNode getActiveStateConfigurationTreeNode (State state) {
        return (DefaultMutableTreeNode) activeStates.get(state);
    }

    /**
     * Returns an indented string representation of the all states configuration
     * tree.
     */
    public String displayAllStatesConfigurationTree() {
        StringBuffer stringBuffer = new StringBuffer();
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) allStatesConfiguration.getRoot();
        formStringTree(root,
                       0,
                       stringBuffer);
        return stringBuffer.toString();
    }

    /**
     * Returns an indented string representation of the active state configuration
     * tree.
     */
    public String displayStateConfigurationTree() {
        StringBuffer stringBuffer = new StringBuffer();
        if (stateConfiguration != null) {
            DefaultMutableTreeNode root = (DefaultMutableTreeNode) stateConfiguration.getRoot();
            formStringTree(root,
                           0,
                           stringBuffer);
        }
        return stringBuffer.toString();
    }

    /**
     * Recursively builds the indented string representation of the given
     * state configuration tree.
     *
     * @@param stateTreeNode the current tree node
     * @@param nestingDepth the nesting depth
     * @@param stringBuffer the buffer containing the partially completed string
     * representation of the state configuration tree
     */
    protected void formStringTree(DefaultMutableTreeNode stateTreeNode,
                                  int nestingDepth,
                                  StringBuffer stringBuffer) {
        for (int i = 0; i < nestingDepth; i++)
            stringBuffer.append("  ");
        stringBuffer.append(stateTreeNode.getUserObject().toString());
        stringBuffer.append("\n");
        Enumeration children = stateTreeNode.children();
        while (children.hasMoreElements())
            formStringTree((DefaultMutableTreeNode) children.nextElement(),
                           nestingDepth + 1,
                           stringBuffer);
    }

    /**
     * Returns the parent state of the given state, or null if
     * given the top state.
     *
     * @@param state the given state
     * @@return the parent state of this state, or null if
     * given the top state
     */
    public State getParentState(State state) {
        if (state.equals(stateMachine.getTop()))
            return null;
        DefaultMutableTreeNode stateTreeNode = (DefaultMutableTreeNode) allStates.get(state);
        DefaultMutableTreeNode parentTreeNode = (DefaultMutableTreeNode) stateTreeNode.getParent();
        return (State) parentTreeNode.getUserObject();
    }

    /**
     * Gets the state machine factory used by this interpreter for event
     * creation and destruction.
     *
     * @@return  the state machine factory used by this interpreter for event
     * creation and destruction
     */
    public StateMachineFactory getStateMachineFactory () {
        return stateMachineFactory;
    }

    /**
     * Gets the dictionary of active states.
     *
     * @@return the dictionary of active states
     */
    public HashMap getActiveStates () {
        return this.activeStates;
    }

    /**
     * Sets the active state configuration to the given
     * configuration tree
     *
     * @@param stateConfiguration the given configuration tree, or null if
     * terminating the state machine
     */
    public void setStateConfiguration (DefaultTreeModel stateConfiguration) {
        this.stateConfiguration = stateConfiguration;
    }
    /**
     * Gets the global temporary interpreter workspace
     *
     * @@return the global temporary interpreter workspace
     */
    public CycFort getTemporaryWorkspaceMt () {
        return temporaryWorkspaceMt;
    }

    /**
     * Sets the global temporary interpreter workspace
     *
     * @@param temporaryWorkspaceMt
     */
    public void setTemporaryWorkspaceMt (CycFort temporaryWorkspaceMt) {
        this.temporaryWorkspaceMt = temporaryWorkspaceMt;
    }

    /**
     * Gets the context stack pool
     *
     * @@return the context stack pool
     */
    public ContextStackPool getContextStackPool () {
        return contextStackPool;
    }

    /**
     * Sets the context stack pool
     *
     * @@param ContextStackPool
     */
    public void setContextStackPool (ContextStackPool contextStackPool) {
        this.contextStackPool = contextStackPool;
    }

}@


1.26
log
@Refactoring of the UML state machine extractor.
Work in progress  and will not all compile.
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.25 2003/01/29 00:18:09 stephenreed Exp $
a190 1
        initialize();
d193 1
d208 6
@


1.25
log
@Mostly completed the code for UML state machine interpretation.
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.24 2003/01/27 22:49:40 stephenreed Exp $
d121 1
a121 1
    protected CycFort definitionMt;
a159 1
     * @@param definitionMt the state machine definition microtheory
a163 1
                       CycFort definitionMt,
a167 1
             definitionMt,
a177 1
     * @@param definitionMt the state machine definition microtheory
a183 1
                       CycFort definitionMt,
a188 1
        this.definitionMt = definitionMt;
d209 1
a209 1
                                                                    definitionMt,
d563 1
a563 1
     * Gets the expression evaluation state context
d565 1
a565 1
     * @@return the expression evaluation state context
d567 2
a568 2
    public CycFort getDefinitionMt () {
        return definitionMt;
d572 1
a572 1
     * Sets the expression evaluation state context
d574 1
a574 1
     * @@param definitionMt the expression evaluation state context
d576 2
a577 2
    public void setDefinitionMt (CycFort definitionMt) {
        this.definitionMt = definitionMt;
@


1.24
log
@Adding code to the state machine interpreter.
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.23 2003/01/10 22:31:40 stephenreed Exp $
d126 1
a126 1
    protected CycFort stateMt;
d144 5
d161 1
a161 1
     * @@param stateMt the expression evaluation state context
d166 2
a167 2
                       CycFort stateMt)
        throws IOException, CycApiException {
a169 1
             stateMt,
d171 1
d182 1
a182 1
     * @@param stateMt the expression evaluation state context
d189 1
a189 1
                       CycFort stateMt,
d191 1
a191 1
        throws IOException, CycApiException {
d195 1
a195 1
        this.stateMt = stateMt;
d205 2
a206 1
    protected void initialize () throws IOException, CycApiException {
d213 4
d240 2
a241 1
    public void terminate () {
d245 1
d253 3
d591 1
a591 1
    public CycFort getStateMt () {
a595 9
     * Sets the expression evaluation state context
     *
     * @@param stateMt the expression evaluation state context
     */
    public void setStateMt (CycFort stateMt) {
        this.stateMt = stateMt;
    }

    /**
d780 18
@


1.23
log
@Added more code to the state machine interpreter
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.22 2003/01/09 21:52:13 stephenreed Exp $
d41 6
d50 1
a50 1
    public static final int DEFAULT_VERBOSITY = 0;
d119 5
d129 5
a146 1
        initialize();
d155 1
d160 1
d166 1
d176 1
d183 1
d189 1
a202 1
                                                      stateMt,
d207 1
a207 1

d370 1
a370 1
                    expressionEvaluator.evaluateBoolean(guardExpression)) {
d493 24
d558 18
d583 1
a583 1
     * @@param xxxx the expression evaluation state context
d758 18
@


1.22
log
@Added code to state machine expression evaluator
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.21 2003/01/09 00:00:20 stephenreed Exp $
d220 1
a220 1
        throws IOException, CycApiException {
d278 1
a278 1
        throws IOException, CycApiException {
d321 1
a321 1
        throws IOException, CycApiException {
d341 1
a341 1
        throws IOException, CycApiException {
d396 1
a396 1
        throws IOException, CycApiException {
d415 1
a415 1
        throws IOException, CycApiException {
d429 1
a429 1
        throws IOException, CycApiException {
d449 1
a449 1
        throws IOException, CycApiException {
@


1.21
log
@Changing the state machine interpreter to keep state in the Cyc server.
@
text
@d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.20 2002/11/27 14:08:35 stephenreed Exp $
d145 1
a145 1
        throws IOException {
d166 1
a166 1
        throws IOException {
d179 1
a179 1
    protected void initialize () throws IOException {
d181 3
a183 1
        expressionEvaluator = new ExpressionEvaluator(cycAccess, stateMt);
d196 1
d199 6
d219 2
a220 1
    public void interpret () {
d277 2
a278 1
    protected void formInitialStateConfiguration () {
d320 2
a321 1
    protected void eventProcessor () {
d340 2
a341 1
    protected void selectTransitions (Iterator transitions) {
d395 2
a396 1
    protected void fireSelectedTransitions () {
d414 2
a415 1
    protected void internalTransition (Transition transition) {
d428 2
a429 1
    protected void transitionExit (Transition transition) {
d448 2
a449 1
    protected void transitionEnter (Transition transition) {
d488 37
@


1.20
log
@ChatterBot unit tests
@
text
@a5 2
import koala.dynamicjava.interpreter.*;
import koala.dynamicjava.parser.wrapper.*;
d8 1
d16 1
a16 1
 * @@version $Id: Interpreter.java,v 1.19 2002/11/26 00:15:21 stephenreed Exp $
a102 5
     * TreeInterpreter that interprets java source code statements.
     */
    protected TreeInterpreter treeInterpreter;

    /**
d113 5
d140 1
d142 3
a144 1
    public Interpreter(StateMachine stateMachine, CycAccess cycAccess)
d146 4
a149 1
        this(stateMachine, cycAccess, Interpreter.DEFAULT_VERBOSITY);
d158 1
d162 4
a165 1
    public Interpreter(StateMachine stateMachine, CycAccess cycAccess, int verbosity)
d169 1
d181 1
a181 21
        treeInterpreter = new TreeInterpreter(new JavaCCParserFactory());
        StringReader stringReader = new StringReader("import org.opencyc.api.*;");
        treeInterpreter.interpret(stringReader, "");
        stringReader = new StringReader("import org.opencyc.util.*;");
        treeInterpreter.interpret(stringReader, "");
        stringReader = new StringReader("import org.opencyc.cycobject.*;");
        treeInterpreter.interpret(stringReader, "");
        stringReader = new StringReader("import java.io.*;");
        treeInterpreter.interpret(stringReader, "");
        treeInterpreter.defineVariable("cycAccess", cycAccess);
        String javaStatements =
                "BufferedReader consoleReader = null; " +
                "try { " +
                "    consoleReader = new BufferedReader(new InputStreamReader(System.in)); " +
                "} " +
                "catch (IOException e) { " +
                "    Log.current.println(e.getMessage()); " +
                "} ";
        stringReader = new StringReader(javaStatements);
        treeInterpreter.interpret(stringReader, "");
        expressionEvaluator = new ExpressionEvaluator(treeInterpreter);
a542 9
    }

    /**
     * Gets the tree interpreter which interprets java statements
     *
     * @@return the tree interpreter which interprets java statements
     */
    public TreeInterpreter getTreeInterpreter () {
        return treeInterpreter;
@


1.19
log
@Begin unit test of ChatterBot state machine
@
text
@d17 1
a17 1
 * @@version $Id: Interpreter.java,v 1.18 2002/11/14 22:06:05 stephenreed Exp $
d175 2
@


1.18
log
@Completed first set of unit tests for UML State Machine extraction from Cyc.
@
text
@d3 1
d9 1
d17 1
a17 1
 * @@version $Id: Interpreter.java,v 1.17 2002/11/14 00:35:40 stephenreed Exp $
d114 5
d140 1
d142 3
a144 2
    public Interpreter(StateMachine stateMachine) {
        this(stateMachine, Interpreter.DEFAULT_VERBOSITY);
d152 1
d156 2
a157 1
    public Interpreter(StateMachine stateMachine, int verbosity) {
d159 1
d169 1
a169 1
    protected void initialize () {
d172 17
d193 1
d307 2
@


1.17
log
@Adding code to CycExtractor to extract the test state machine from Cyc
@
text
@d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.16 2002/11/09 15:18:55 stephenreed Exp $
d292 22
a313 4
            Iterator transitions = state.getOutgoing().listIterator();
            while (transitions.hasNext()) {
                Transition transition = (Transition) transitions.next();
                if (currentEventEnables(transition)) {
d315 2
a316 9
                        Log.current.println("  " + transition.toString() +
                                            " enabled by " + currentEvent.toString());
                    BooleanExpression guardExpression = transition.getGuard().getexpression();
                    if ((guardExpression == null) ||
                        expressionEvaluator.evaluateBoolean(guardExpression)) {
                        if (verbosity > 2)
                            Log.current.println("    selected " + transition.toString());
                        selectedTransitions.add(transition);
                    }
d321 1
@


1.16
log
@Small mods to update UML association names per the UML doc.
@
text
@d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.15 2002/11/06 16:35:14 stephenreed Exp $
d43 1
a43 1
    public static final int DEFAULT_VERBOSITY = 3;
@


1.15
log
@Completed first (simple) unit test of UML state machine support.
@
text
@d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.14 2002/11/06 04:51:02 stephenreed Exp $
d117 5
d130 10
d141 4
d146 1
a146 1
    public Interpreter(StateMachine stateMachine) {
d148 1
d182 1
a182 1
        System.exit(0);
d191 1
a191 1
        while (true) {
d438 11
d537 6
a542 4
        DefaultMutableTreeNode root = (DefaultMutableTreeNode) stateConfiguration.getRoot();
        formStringTree(root,
                       0,
                       stringBuffer);
d603 11
@


1.14
log
@Adding more code to UML state machine support.
@
text
@d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.13 2002/11/06 00:24:31 stephenreed Exp $
d157 9
d330 6
a335 2
            transitionExit(transition);
            transitionEnter(transition);
d337 13
@


1.13
log
@Added more code for UML state machine interpretation.
@
text
@d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.12 2002/11/05 15:44:15 stephenreed Exp $
d166 6
d261 2
d266 4
a269 1
                if (transition.getTrigger().equals(currentEvent)) {
d273 2
d283 4
a286 1
     * Determines whether the given transition can be triggered by the given event.
d288 6
a322 7
            Event event = transition.getTrigger();
            if (event != null) {
                if (verbosity > 2)
                    Log.current.println("Destroying " + event.toString());
                stateMachineFactory.destroyEvent(event);
                transition.setTrigger(null);
            }
d535 9
@


1.12
log
@Added more support for UML State Machine state interpretation
@
text
@d5 2
d15 1
a15 1
 * @@version $Id: Interpreter.java,v 1.11 2002/11/05 00:35:25 stephenreed Exp $
d67 14
d102 6
a107 1
     * the java expression evaluator
d112 5
d139 5
a143 1
        expressionEvaluator = new ExpressionEvaluator();
d160 1
d170 37
d270 5
d279 1
a279 1
        if (eventQueue.isEmpty())
d281 4
a284 1
        else
d286 3
d301 7
d414 1
a414 1
     * in the active state configuration tree.
d418 31
a448 1
     * in the active state configuration tree
d450 7
a456 3
    protected State[] getStatesFromRootTo (State state) {
        DefaultMutableTreeNode stateTreeNode = (DefaultMutableTreeNode) activeStates.get(state);
        return (State[]) stateTreeNode.getUserObjectPath();
d459 62
@


1.11
log
@Adding more code to the UML State Machine interpreter
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.10 2002/11/01 16:18:50 stephenreed Exp $
d104 2
d144 2
d151 17
a167 1
            formCompositeStateConfigurationFrom((CompositeState) topState, root);
d171 2
a172 21
            topState.setStateInterpreter(new StateInterpreter(this));
            topState.getStateInterpreter().enterState(topState);
        }
    }

    /**
     * Forms the portion of the (active) state configuration downward from
     * the given composite state and corresponding state configuration tree
     * node.
     *
     * @@param compositeState the given composite state
     * @@param stateConfigurationNode the given state configuration tree node
     */
    protected void formCompositeStateConfigurationFrom (CompositeState compositeState,
                                                        DefaultMutableTreeNode stateConfigurationNode) {
        Iterator subVertices = compositeState.getSubVertex().iterator();
        while (subVertices.hasNext()) {
            StateVertex subVertex = (StateVertex) subVertices.next();

            //TODO

a175 1

d220 40
a259 12
            StateVertex source = transition.getSource();
            if (source instanceof State)
                ((State) source).getStateInterpreter().interpretTransitionExit(transition);
            else {
                //TODO handle vertices
            }
            StateVertex target = transition.getTarget();
            if (target instanceof State)
                ((State) target).getStateInterpreter().interpretTransitionEntry(transition);
            else {
                //TODO handle vertices
            }
a337 1

@


1.10
log
@More support for UML StateMachines.
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.9 2002/11/01 03:05:58 stephenreed Exp $
d65 2
a66 2
     * The state configuration, which is a tree consisting of a top state
     * at the root down to individual simple states at the leaves.  States
d94 1
a94 1
        initialization();
d103 1
a103 1
        initialization();
d107 1
a107 1
     * Performs initialization of this object.
d109 1
a109 1
    protected void initialization () {
d128 1
d135 40
@


1.9
log
@Adding more UML state machine support.
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.8 2002/10/31 20:58:41 stephenreed Exp $
d246 1
a246 1
    public DefaultMutableTreeNode getActiveSubstates (State state) {
d257 12
a268 1

@


1.8
log
@Some more UML state machine interpreter code.
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.7 2002/10/31 15:07:55 stephenreed Exp $
d73 6
d143 11
a153 19
        Stack stateNodeStack = new Stack();
        stateNodeStack.push(stateConfiguration.getRoot());
        while (! stateNodeStack.empty()) {
            DefaultMutableTreeNode stateNode = (DefaultMutableTreeNode) stateNodeStack.pop();
            Enumeration containedStates = stateNode.children();
            while (containedStates.hasMoreElements()) {
                DefaultMutableTreeNode containedState =
                        (DefaultMutableTreeNode) containedStates.nextElement();
                stateNodeStack.push(containedState);
                State state = (State) containedState.getUserObject();
                Iterator transitions = state.getOutgoing().listIterator();
                while (transitions.hasNext()) {
                    Transition transition = (Transition) transitions.next();
                    if (transition.getTrigger().equals(currentEvent)) {
                        BooleanExpression guardExpression = transition.getGuard().getexpression();
                        if ((guardExpression == null) ||
                            expressionEvaluator.evaluateBoolean(guardExpression)) {
                            selectedTransitions.add(transition);
                        }
d247 8
a254 1
        //DefaultMutableTreeNode substateTreeNode
@


1.7
log
@Added more support for UML state machine interpretation.
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.6 2002/10/31 03:16:53 stephenreed Exp $
d242 9
@


1.6
log
@Added more code for UML state machine interpretation
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.5 2002/10/31 02:50:54 stephenreed Exp $
a157 1

a158 1

d178 16
a193 1

@


1.5
log
@Initial check in
@
text
@d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.4 2002/10/31 00:12:56 stephenreed Exp $
a58 1

d80 5
d88 1
a88 1
        Log.makeLog("state-machine-interpreter.log");
d97 9
d123 1
a129 28
     * Fires the selected transitions and runs the associated
     * actions to completion.
     */
    protected void fireSelectedTransitions () {

    }

    /**
     * Adds an event to this state machine's event queue.
     *
     * @@param event the event to add  to this state machine's event queue
     */
    public void enqueueEvent (Event event) {
        eventQueue.add(event);
    }

    /**
     * Selects and dequeues event instances from the event queue for
     * processing.
     */
    protected void eventDispatcher () {
        if (eventQueue.isEmpty())
            currentEvent = null;
        else
            currentEvent = (Event) eventQueue.get();
    }

    /**
a131 10
     */
    protected void eventProcessor () {
        eventDispatcher();
        while (currentEvent != null) {
            selectTransitions();
            eventDispatcher();
        }
    }

    /**
d135 1
a135 1
    protected void selectTransitions() {
d152 3
a154 2
                        /*
                        if (evaluateBoolean(guardExpression.getBody()) {
a155 1
                        */
d162 1
d164 26
@


1.4
log
@Initial check in.
@
text
@d6 1
a9 1

d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.3 2002/10/30 15:52:01 stephenreed Exp $
d174 7
a180 1

@


1.3
log
@Beginning to add code to the state machine interpeter.
Added usage of most recent jakarta common collections package.
@
text
@d3 2
d7 2
d13 1
a13 1
 * @@version $Id: Interpreter.java,v 1.2 2002/10/28 05:05:01 stephenreed Exp $
d38 12
d55 6
d66 15
d84 1
d102 28
d137 4
d148 70
d219 4
@


1.2
log
@No changes.
@
text
@d3 3
d9 1
a9 1
 * @@version $Id: Interpreter.java,v 1.1 2002/10/28 03:26:20 stephenreed Exp $
d34 10
d50 8
d65 15
@


1.1
log
@Check in.
@
text
@d6 1
a6 1
 * @@version $Id: BehavioralFeature.java,v 1.1 2002/10/27 04:53:47 stephenreed Exp $
d42 1
a42 1
        Interpreter interpreter1 = new Interpreter();
@

