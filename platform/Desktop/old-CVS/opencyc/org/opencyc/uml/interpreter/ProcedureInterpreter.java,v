head	1.17;
access;
symbols
	PRE_1_0:1.17;
locks; strict;
comment	@# @;


1.17
date	2003.02.09.19.45.22;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.09.02.14.19;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.06.02.57.03;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.29.02.03.19;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.29.00.18.09;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.27.22.49.40;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.24.00.20.50;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.23.23.55.30;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.23.23.15.43;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.10.22.31.41;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.09.21.52.14;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.09.00.00.22;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.09.15.18.57;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.06.00.24.31;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.05.15.44.15;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.04.02.21.04;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.01.03.43.33;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.17
log
@removed file
@
text
@package org.opencyc.uml.interpreter;

import java.util.*;
import java.io.*;
import org.opencyc.api.*;
import org.opencyc.cycobject.*;
import org.opencyc.util.*;
import org.opencyc.uml.action.*;
import org.opencyc.uml.core.*;
import org.opencyc.uml.commonbehavior.*;
import org.opencyc.uml.statemachine.*;

/**
 * Interprets a procedure of a UML StateMachine.
 *
 * @@version $Id: ProcedureInterpreter.java,v 1.15 2003/02/06 02:57:03 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class ProcedureInterpreter {

    /**
     * The default verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public static final int DEFAULT_VERBOSITY = 3;

    /**
     * Sets verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * the procedure to interpret
     */
    protected Procedure procedure;

    /**
     * the expression evaluator
     */
    protected ExpressionEvaluator expressionEvaluator;

    /**
     * the reference to the parent CycAccess object which provides Cyc api
     * services
     */
    protected CycAccess cycAccess;

    /**
     * the state machine definition microtheory
     */
    protected CycFort stateMachineDefinitionMt;

    /**
     * the procedure definition microtheory
     */
    protected CycFort procedureDefinitionMt;

    /**
     * the context stack pool
     */
    protected ContextStackPool contextStackPool;

    /**
     * the expression evaluation state context
     */
    protected CycConstant contextFrame;

    /**
     * the procedure CycFort
     */
    protected CycFort procedureTerm;

    /**
     * #$umlProcedureInputBinding
     */
    protected CycConstant umlProcedureInputBinding;

    /**
     * #$umlProcedureOutputBinding
     */
    protected CycConstant umlProcedureOutputBinding;

    /**
     * #$softwareParameterValue
     */
    protected CycConstant softwareParameterValue;

    /**
     * #$SoftwareParameterFromSyntaxFn
     */
    protected CycConstant softwareParameterFromSyntaxFn;

    /**
     * Constructs a new ProcedureInterpreter object.
     *
     * @@param cycAccess the reference to the parent CycAccess object which provides Cyc api
     * services
     * @@param stateMachineDefinitionMt the state machine definition microtheory
     * @@param contextStackPool the context frame pool
     * @@param verbosity the output verbosity for this object
     */
    public ProcedureInterpreter(CycAccess cycAccess,
                                CycFort stateMachineDefinitionMt,
                                ContextStackPool contextStackPool,
                                int verbosity)
        throws IOException, CycApiException {
        this.cycAccess = cycAccess;
        this.stateMachineDefinitionMt = stateMachineDefinitionMt;
        this.contextStackPool = contextStackPool;
        this.verbosity = verbosity;
        initialize();
    }

    /**
     * Initializes this procedure interpreter.
     */
    protected void initialize ()
        throws IOException, CycApiException {
        expressionEvaluator = new ExpressionEvaluator(cycAccess, verbosity);
        softwareParameterValue = cycAccess.getKnownConstantByName("softwareParameterValue");
        softwareParameterFromSyntaxFn = cycAccess.getKnownConstantByName("SoftwareParameterFromSyntaxFn");
        if (verbosity > 2)
            Log.current.println("Creating ProcedureInterpreter for " +
                                "\n  stateMachineDefinitionMt: " + stateMachineDefinitionMt.cyclify());
    }


    /**
     * Interprets the procedure using the procedure binding term.
     *
     * @@param procedure the procedure to evaluate
     * @@param inputBindings the list of input pin bindings
     * @@param outputBindings the list of output pin bindings
     * @@param parentContextFrame the caller's context frame which becomes the parent
     * of the context frame allocated for this procedure's evaluation
     */
    protected void interpretProcedure (Procedure procedure,
                                       ArrayList inputBindings,
                                       ArrayList outputBindings,
                                       CycConstant parentContextFrame)
        throws IOException, CycApiException, ExpressionEvaluationException {
        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                "\n  body: " + procedure.getBody());
        procedureTerm = cycAccess.getKnownConstantByName(procedure.toString());
        contextFrame =
            contextStackPool.allocateProcedureContextFrame(parentContextFrame,
                                                           stateMachineDefinitionMt,
                                                           procedureTerm);
        if (verbosity > 2)
            Log.current.println("Input bindings: " + inputBindings.toString());
        Iterator iter = inputBindings.iterator();
        while (iter.hasNext()) {
            InputBinding inputBinding = (InputBinding) iter.next();
            InputPin inputPin = inputBinding.getBoundInputPin();
            CycFort inputPinTerm = cycAccess.getKnownConstantByName(inputPin.toString());
            CycNart inputPinParameter = new CycNart(softwareParameterFromSyntaxFn, inputPinTerm);
            Object valueExpression = inputBinding.getBoundInputValueExpression();
            Object value = null;
            if (valueExpression instanceof StateVariable) {
                // lookup the value of the state variable
                value = cycAccess.getArg2(softwareParameterValue,
                                          cycAccess.getKnownConstantByName(valueExpression.toString()),
                                          parentContextFrame);
            }
            else
                // a literal
                value = valueExpression;
            if (verbosity > 2)
                Log.current.println(value.toString() + " --> " + inputPinParameter.cyclify());
            //TODO interpret evaluatable expressions as inpput arguments

            CycList softwareParameterValueSentence = new CycList();
            softwareParameterValueSentence.add(softwareParameterValue);
            softwareParameterValueSentence.add(inputPinParameter);
            softwareParameterValueSentence.add(value);
            cycAccess.assertWithBookkeepingAndWithoutTranscript(softwareParameterValueSentence,
                                                                contextFrame);
        }

        // evaluate the procedure body
        expressionEvaluator.evaluateCycLExpression(procedure.getBody(),
                                                   contextFrame);

        // bind output values
        if (verbosity > 2)
            Log.current.println("Output bindings: " + outputBindings.toString());
        iter = outputBindings.iterator();
        while (iter.hasNext()) {
            OutputBinding outputBinding = (OutputBinding)  iter.next();
            OutputPin outputPin = outputBinding.getBoundOutputPin();
            CycFort outputPinTerm = cycAccess.getKnownConstantByName(outputPin.toString());
            StateVariable stateVariable = outputBinding.getBoundOutputStateVariable();
            CycFort stateVariableTerm = cycAccess.getKnownConstantByName(stateVariable.toString());
            CycNart outputPinParameter = new CycNart(softwareParameterFromSyntaxFn, outputPinTerm);
            Object value =
                cycAccess.getArg2(softwareParameterValue,
                                  outputPinParameter,
                                  contextFrame);
            CycList softwareParameterValueSentence = new CycList();
            softwareParameterValueSentence.add(softwareParameterValue);
            softwareParameterValueSentence.add(stateVariableTerm);
            softwareParameterValueSentence.add(value);
            cycAccess.unassertMatchingAssertionsWithoutTranscript(softwareParameterValue,
                                                                  stateVariableTerm,
                                                                  parentContextFrame);
            if (verbosity > 2)
                Log.current.println("asserting " + softwareParameterValueSentence +
                                    " in " + parentContextFrame);
            cycAccess.assertWithBookkeepingAndWithoutTranscript(softwareParameterValueSentence,
                                                                parentContextFrame);
        }
        contextStackPool.deallocateContextFrame(contextFrame);
    }

    /**
     * Gets the procedure to interpret.
     *
     * @@return the procedure to interpret
     */
    public Procedure getProcedure () {
        return procedure;
    }

    /**
     * Sets verbosity of this object's output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

}@


1.16
log
@Completed coding of procedure bindings - ready to test them
@
text
@a88 5
     * the parent expression evaluation state context
     */
    protected CycConstant parentContextFrame;

    /**
d150 6
d159 2
a160 1
                                       ArrayList outputBindings)
d165 1
d180 1
a180 1
            if (valueExpression instanceof CycConstant) {
d183 1
a183 1
                                          (CycFort) valueExpression,
d189 2
d227 1
a227 1
            if (verbosity > 0)
@


1.15
log
@Refactoring of the UML state machine extractor.
Work in progress  and will not all compile.
@
text
@d8 1
d16 1
a16 1
 * @@version $Id: ProcedureInterpreter.java,v 1.14 2003/01/29 02:03:19 stephenreed Exp $
a57 6
     * the procedure binding term which is the association
     * between the procedure and a particular calling transition or state
     */
    protected CycFort procedureBinding;

    /**
a98 25
     * #$umlProcedureBinding-CalledByStateEntry
     */
    protected CycConstant umlProcedureBinding_CalledByStateEntry;

    /**
     * #$umlProcedureBinding-CalledByStateDoActivity
     */
    protected CycConstant umlProcedureBinding_CalledByStateDoActivity;

    /**
     * #$umlProcedureBinding-CalledByStateExit
     */
    protected CycConstant umlProcedureBinding_CalledByStateExit;

    /**
     * #$umlProcedureBinding-CalledByTransition
     */
    protected CycConstant umlProcedureBinding_CalledByTransition;

    /**
     * #$umlProcedureBinding-Procedure
     */
    protected CycConstant umlProcedureBinding_Procedure;

    /**
d143 1
a143 1
    throws IOException, CycApiException {
a144 7
        umlProcedureBinding_CalledByStateEntry = cycAccess.getKnownConstantByName("umlProcedureBinding-CalledByStateEntry");
        umlProcedureBinding_CalledByStateDoActivity = cycAccess.getKnownConstantByName("umlProcedureBinding-CalledByStateDoActivity");
        umlProcedureBinding_CalledByStateExit = cycAccess.getKnownConstantByName("umlProcedureBinding-CalledByStateExit");
        umlProcedureBinding_CalledByTransition = cycAccess.getKnownConstantByName("umlProcedureBinding-CalledByTransition");
        umlProcedureBinding_Procedure = cycAccess.getKnownConstantByName("umlProcedureBinding-Procedure");
        umlProcedureInputBinding = cycAccess.getKnownConstantByName("umlProcedureInputBinding");
        umlProcedureOutputBinding = cycAccess.getKnownConstantByName("umlProcedureOutputBinding");
d154 1
a154 4
     * Interprets the procedure which is called from the calling transition.
     *
     * @@param transition the transition which called the procedure to be interpreted
     * @@param parentContextFrame the parent context frame
d156 3
a158 2
    public void interpretTransitionProcedure (Transition transition,
                                              CycConstant parentContextFrame)
a159 2
        this.parentContextFrame = parentContextFrame;
        procedure = transition.getEffect();
a161 1
                                " at " + transition.toString() +
a162 24
        // get procedure binding term
        procedureTerm = cycAccess.getKnownConstantByName(procedure.getName());
        CycList query = new CycList();
        query.add(CycAccess.and);
        CycList query1 = new CycList();
        query1.add(umlProcedureBinding_CalledByTransition);
        CycVariable cycVariable = CycObjectFactory.makeCycVariable("?PROCEDURE-BINDING");
        query1.add(cycVariable);
        query1.add(cycAccess.getKnownConstantByName(transition.toString()));
        query.add(query1);
        CycList query2 = new CycList();
        query2.add(umlProcedureBinding_Procedure);
        query2.add(cycVariable);
        query2.add(cycAccess.getKnownConstantByName(procedure.toString()));
        query.add(query2);
        CycList queryResult =
            cycAccess.askWithVariable(query, cycVariable, stateMachineDefinitionMt);
        if (queryResult.isEmpty())
            throw new CycApiException("umlProcedureBinding-Procedure " + procedure.toString() +
                                      " or \numlProcedureBinding-CalledByTransition not found for " +
                                      transition.toString() +
                                      " with mt " + stateMachineDefinitionMt.cyclify() +
                                      "\n in query \n" + query.toPrettyString(""));
        procedureBinding = (CycFort) queryResult.first();
a166 16
        interpretProcedure();
        contextStackPool.deallocateContextFrame(contextFrame);
    }

    /**
     * Interprets the procedure which is called from the given state as its
     * entry action.
     *
     * @@param state the state whose entry action called the procedure
     * @@param parentContextFrame the parent context frame
     */
    public void interpretStateEntryProcedure (State state,
                                              CycConstant parentContextFrame)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this.parentContextFrame = parentContextFrame;
        procedure = state.getEntry();
d168 19
a186 51
            Log.current.println("Interpreting " + procedure.toString() +
                                " at entry action for " + state.toString() +
                                "\n  " + procedure.getBody());
        // get procedure binding term
        CycFort procedureTerm = cycAccess.getKnownConstantByName(procedure.getName());
        contextFrame =
            contextStackPool.allocateProcedureContextFrame(parentContextFrame,
                                                           stateMachineDefinitionMt,
                                                           procedureTerm);
        procedureBinding =
            (CycFort) cycAccess.getArg1(umlProcedureBinding_Procedure,
                                        procedureTerm,
                                        contextFrame);
        interpretProcedure();
        contextStackPool.deallocateContextFrame(contextFrame);
    }

    /**
     * Interprets theprocedure which is called from the given state as its
     * entry action.
     *
     * @@param state the state whose doActivity called the procedure
     * @@param parentContextFrame the parent context frame
     */
    public void interpretStateDoActivityProcedure (State state,
                                                   CycConstant parentContextFrame)
        throws IOException, CycApiException, ExpressionEvaluationException {
        procedure = state.getDoActivity();
        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                " at doActivity for " + state.toString() +
                                "\n  " + procedure.getBody());
        //TODO
    }

    /**
     * Interprets the given procedure which is called from the given state as its
     * entry action.
     *
     * @@param procedure the procedure to interpret
     * @@param state the state whose exit action called the procedure
     */
    public void interpretStateExitProcedure (State state)
        throws IOException, CycApiException, ExpressionEvaluationException {
        procedure = state.getExit();
        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                " at exit action for " + state.toString() +
                                "\n  " + procedure.getBody());
        //TODO
    }
a187 33
    /**
     * Interprets the procedure using the procedure binding term.
     */
    protected void interpretProcedure ()
        throws IOException, CycApiException, ExpressionEvaluationException {
        if (verbosity > 2)
            Log.current.println("procedureBinding: " + procedureBinding.cyclify());
        // clear interpretation context
        cycAccess.unassertMtContentsWithoutTranscript(contextFrame);
        if (verbosity > 2)
            Log.current.println("contextFrame: " + contextFrame.cyclify());
        // bind input values
        CycList gatherArgs = new CycList();
        gatherArgs.add(new Integer(2));
        gatherArgs.add(new Integer(3));
        CycList inputBindingTuples =
            cycAccess.getPredicateValueTuplesInMt(procedureBinding,
                                                  umlProcedureInputBinding,
                                                  1,
                                                  gatherArgs,
                                                  stateMachineDefinitionMt);
        if (verbosity > 2)
            Log.current.println("Input binding tuples: " + inputBindingTuples.cyclify());
        Iterator iter = inputBindingTuples.iterator();
        while (iter.hasNext()) {
            CycList inputBindingTuple = (CycList) iter.next();
            CycFort inputPin = (CycFort) inputBindingTuple.first();
            CycNart inputPinParameter = new CycNart(softwareParameterFromSyntaxFn, inputPin);
            CycFort stateVariable = (CycFort) inputBindingTuple.second();
            Object value =
                cycAccess.getArg2(softwareParameterValue,
                                  stateVariable,
                                  parentContextFrame);
a200 6
        CycList outputBindingTuples =
            cycAccess.getPredicateValueTuplesInMt(procedureBinding,
                                                  umlProcedureOutputBinding,
                                                  1,
                                                  gatherArgs,
                                                  stateMachineDefinitionMt);
d202 2
a203 2
            Log.current.println("Output binding tuples: " + outputBindingTuples.cyclify());
        iter = outputBindingTuples.iterator();
d205 6
a210 4
            CycList outputBindingTuple = (CycList) iter.next();
            CycFort outputPin = (CycFort) outputBindingTuple.first();
            CycFort stateVariable = (CycFort) outputBindingTuple.second();
            CycNart outputPinParameter = new CycNart(softwareParameterFromSyntaxFn, outputPin);
d217 1
a217 1
            softwareParameterValueSentence.add(stateVariable);
d220 1
a220 1
                                                                  stateVariable,
d228 1
a237 10
    }

    /**
     * Gets the procedure binding term which is the association
     * between the procedure and a particular calling transition or state.
     *
     * @@return procedure binding term
     */
    public CycFort getProcedureBinding () {
        return procedureBinding;
@


1.14
log
@Refactored UML procedure definitions into individual microtheories.
@
text
@d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.13 2003/01/29 00:18:09 stephenreed Exp $
d222 6
@


1.13
log
@Mostly completed the code for UML state machine interpretation.
@
text
@d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.12 2003/01/27 22:49:40 stephenreed Exp $
d76 6
a81 1
    protected CycFort definitionMt;
d153 1
a153 1
     * @@param definitionMt the state machine definition microtheory
d158 1
a158 1
                                CycFort definitionMt,
d163 1
a163 1
        this.definitionMt = definitionMt;
d186 1
a186 1
                                "\n  definitionMt: " + definitionMt.cyclify());
d221 1
a221 1
            cycAccess.askWithVariable(query, cycVariable, definitionMt);
d225 1
a225 1
                                                           definitionMt,
d251 1
a251 1
                                                           definitionMt,
d304 1
a306 1
        cycAccess.unassertMtContentsWithoutTranscript(contextFrame);
d316 1
a316 1
                                                  definitionMt);
d347 1
a347 1
                                                  definitionMt);
@


1.12
log
@Adding code to the state machine interpreter.
@
text
@d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.11 2003/01/24 00:20:50 stephenreed Exp $
d79 5
d86 1
a86 1
    protected CycFort stateMt;
d89 1
a89 1
     * the procedure CycFort
d91 1
a91 1
    protected CycFort procedureTerm;
d94 1
a94 1
     * #$umlProcedureEvaluationContext
d96 1
a96 1
    protected CycConstant umlProcedureEvaluationContext;
d149 1
a149 1
     * @@param stateMt the expression evaluation state context
d154 1
a154 1
                                CycFort stateMt,
d159 1
a159 1
        this.stateMt = stateMt;
d161 8
a169 1
        umlProcedureEvaluationContext = cycAccess.getKnownConstantByName("umlProcedureEvaluationContext");
d181 1
a181 2
                                "\n  definitionMt: " + definitionMt.cyclify() +
                                "\n  stateMt: " + stateMt.cyclify());
d184 1
d189 1
d191 2
a192 1
    public void interpretTransitionProcedure (Transition transition)
d194 1
d199 1
a199 1
                                "\n  " + procedure.getBody());
d216 1
a216 1
            cycAccess.askWithVariable(query, cycVariable, stateMt);
d218 4
d223 1
d231 1
d233 2
a234 1
    public void interpretStateEntryProcedure (State state)
d236 1
d244 4
d251 1
a251 1
                                        stateMt);
d253 1
d261 1
d263 2
a264 1
    public void interpretStateDoActivityProcedure (State state)
a298 4
        CycFort evaluationContext =
            (CycFort) cycAccess.getArg2(umlProcedureEvaluationContext,
                                        procedureTerm,
                                        definitionMt);
d300 2
a301 2
            Log.current.println("evaluationContext: " + evaluationContext.cyclify());
        cycAccess.unassertMtContentsWithoutTranscript(evaluationContext);
d323 1
a323 1
                                  stateMt);
d329 1
a329 1
                                                                evaluationContext);
d334 1
a334 1
                                                   evaluationContext);
d354 1
a354 1
                                  evaluationContext);
d361 1
a361 1
                                                                  stateMt);
d364 1
a364 1
                                    " in " + stateMt);
d366 1
a366 1
                                                                stateMt);
@


1.11
log
@continuing unit tests of procedure interpreter
@
text
@d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.9 2003/01/23 23:15:43 stephenreed Exp $
d74 5
d143 1
d148 1
d153 1
d156 1
a156 1
        expressionEvaluator = new ExpressionEvaluator(cycAccess, stateMt, verbosity);
d167 4
d186 1
a186 1
        CycFort procedureTerm = cycAccess.getKnownConstantByName(procedure.getName());
d266 2
d272 3
a274 1
                                        stateMt);
d277 12
a288 3
        CycList inputBindingGafs =
            cycAccess.getGafs(umlProcedureInputBinding, stateMt);
        Iterator iter = inputBindingGafs.iterator();
d290 2
a291 5
            CycList inputBindingGaf = (CycList) iter.next();
            CycFort thisProcedureBinding = (CycFort) inputBindingGaf.second();
            if (! procedureBinding.equals(thisProcedureBinding))
                continue;
            CycFort inputPin = (CycFort) inputBindingGaf.third();
d293 1
a293 1
            CycFort stateVariable = (CycFort) inputBindingGaf.fourth();
d296 1
a296 1
                                  inputPinParameter,
d300 1
a300 1
            softwareParameterValueSentence.add(stateVariable);
d307 2
a308 1
        expressionEvaluator.evaluateCycLExpression((CycList) procedure.getBody());
d311 9
a319 3
        CycList outputBindingGafs =
            cycAccess.getGafs(umlProcedureOutputBinding, stateMt);
        iter = outputBindingGafs.iterator();
d321 4
a324 6
            CycList outputBindingGaf = (CycList) iter.next();
            CycFort thisProcedureBinding = (CycFort) outputBindingGaf.second();
            if (! procedureBinding.equals(thisProcedureBinding))
                continue;
            CycFort outputPin = (CycFort) outputBindingGaf.third();
            CycFort stateVariable = (CycFort) outputBindingGaf.fourth();
d327 1
a327 1
                                  stateVariable,
d331 1
a331 2
            CycNart outputPinParameter = new CycNart(softwareParameterFromSyntaxFn, outputPin);
            softwareParameterValueSentence.add(outputPinParameter);
d333 6
@


1.10
log
@added more code to the procedure interpreter
@
text
@d84 1
a84 1
     * #$procedureEvaluationContext
d86 1
a86 1
    protected CycConstant procedureEvaluationContext;
d149 1
a149 1
        procedureEvaluationContext = cycAccess.getKnownConstantByName("procedureEvaluationContext");
a187 1

d256 1
a256 1
            (CycFort) cycAccess.getArg2(procedureEvaluationContext,
@


1.9
log
@added code to the procedure interpreter
@
text
@d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.8 2003/01/10 22:31:41 stephenreed Exp $
d79 5
d89 20
d147 1
a148 1
        this.verbosity = verbosity;
d150 4
d168 26
a193 1
        this.procedure = transition.getEffect();
d195 9
d206 1
a206 1
                                " at " + transition.toString() +
d208 1
d210 45
a260 5
        // get procedure binding term
        CycFort procedureBinding =
            (CycFort) cycAccess.getArg1(umlProcedureBinding_Procedure,
                                        procedureTerm,
                                        stateMt);
d267 4
a270 1
            CycFort inputPin = (CycFort) inputBindingGaf.second();
d272 1
a272 1
            CycFort stateVariable = (CycFort) inputBindingGaf.third();
d294 5
a298 2
            CycFort outputPin = (CycFort) outputBindingGaf.second();
            CycFort stateVariable = (CycFort) outputBindingGaf.third();
a310 52
    }

    /**
     * Interprets the procedure which is called from the given state as its
     * entry action.
     *
     * @@param state the state whose entry action called the procedure
     */
    public void interpretStateEntryProcedure (State state)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this.procedure = state.getEntry();

        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                " at entry action for " + state.toString() +
                                "\n  " + procedure.getBody());
        //TODO
    }

    /**
     * Interprets theprocedure which is called from the given state as its
     * entry action.
     *
     * @@param state the state whose doActivity called the procedure
     */
    public void interpretStateDoActivityProcedure (State state)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this.procedure = state.getDoActivity();

        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                " at doActivity for " + state.toString() +
                                "\n  " + procedure.getBody());
        //TODO
    }

    /**
     * Interprets the given procedure which is called from the given state as its
     * entry action.
     *
     * @@param procedure the procedure to interpret
     * @@param state the state whose exit action called the procedure
     */
    public void interpretStateExitProcedure (State state)
        throws IOException, CycApiException, ExpressionEvaluationException {
        this.procedure = procedure;

        if (verbosity > 2)
            Log.current.println("Interpreting " + procedure.toString() +
                                " at exit action for " + state.toString() +
                                "\n  " + procedure.getBody());
        //TODO
@


1.8
log
@Added more code to the state machine interpreter
@
text
@d10 1
d15 1
a15 1
 * @@version $Id: ProcedureInterpreter.java,v 1.7 2003/01/09 21:52:14 stephenreed Exp $
d57 6
d68 41
d120 2
d124 94
d221 19
a239 1
     * Interprets the given procedure.
d242 1
d244 1
a244 1
    public void interpret (Procedure procedure)
d247 1
d250 1
d252 1
a252 1
        expressionEvaluator.evaluateCycLExpression((CycList) procedure.getBody());
d262 10
@


1.7
log
@Added code to state machine expression evaluator
@
text
@d14 1
a14 1
 * @@version $Id: ProcedureInterpreter.java,v 1.6 2003/01/09 00:00:22 stephenreed Exp $
d82 1
a82 1
        throws IOException, CycApiException {
@


1.6
log
@Changing the state machine interpreter to keep state in the Cyc server.
@
text
@d5 2
d14 1
a14 1
 * @@version $Id: ProcedureInterpreter.java,v 1.5 2002/11/09 15:18:57 stephenreed Exp $
d53 6
a58 1
    Procedure procedure;
d63 4
a66 2
     * @@param verbosity the desired verbosity for interpreting procedures
     *
d68 5
a72 1
    public ProcedureInterpreter(int verbosity) {
d81 2
a82 1
    public void interpret (Procedure procedure) {
d87 1
a87 1
        // TODO
@


1.5
log
@Small mods to update UML association names per the UML doc.
@
text
@a4 2
import koala.dynamicjava.interpreter.*;
import koala.dynamicjava.parser.wrapper.*;
d12 1
a12 1
 * @@version $Id: ProcedureInterpreter.java,v 1.4 2002/11/06 00:24:31 stephenreed Exp $
a48 5
     * the tree interpreter which interprets java statements
     */
    TreeInterpreter treeInterpreter;

    /**
d54 3
a56 2
     * Constructs a new ProcedureInterpreter object given the tree
     * interpreter which interprets java statements
a57 1
     * @@param treeInterpreter the given tree interpreter
d59 1
a59 2
    public ProcedureInterpreter(TreeInterpreter treeInterpreter, int verbosity) {
        this.treeInterpreter = treeInterpreter;
d73 1
a73 3
        //TODO handle arguments
        StringReader stringReader = new StringReader(procedure.getBody());
        treeInterpreter.interpret(stringReader, "procedure");
@


1.4
log
@Added more code for UML state machine interpretation.
@
text
@d14 1
a14 1
 * @@version $Id: ProcedureInterpreter.java,v 1.3 2002/11/05 15:44:15 stephenreed Exp $
d66 1
a66 1
    public ProcedureInterpreter(TreeInterpreter treeInterpreter) {
d68 1
@


1.3
log
@Added more support for UML State Machine state interpretation
@
text
@d3 4
d14 1
a14 1
 * @@version $Id: ProcedureInterpreter.java,v 1.2 2002/11/04 02:21:04 stephenreed Exp $
d51 5
d61 11
a71 2
     * Constructs a new ProcedureInterpreter object given the procedure
     * to interpret.
d75 1
a75 1
    public ProcedureInterpreter(Procedure procedure) {
d78 5
a82 1
            Log.current.println("Interpreting " + procedure.toString());
@


1.2
log
@Added more support for UML state machine interpretation.
@
text
@d3 1
d10 1
a10 1
 * @@version $Id: ProcedureInterpreter.java,v 1.1 2002/11/01 03:43:33 stephenreed Exp $
d35 12
d59 2
d70 10
@


1.1
log
@Added more UML state machine support.
@
text
@d3 1
d9 1
a9 1
 * @@version $Id: StateInterpreter.java,v 1.5 2002/11/01 03:28:32 stephenreed Exp $
@

