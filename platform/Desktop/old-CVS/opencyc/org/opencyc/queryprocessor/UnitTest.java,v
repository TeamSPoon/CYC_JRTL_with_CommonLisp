head	1.13;
access;
symbols
	PRE_1_0:1.12;
locks; strict;
comment	@# @;


1.13
date	2006.10.21.17.01.59;	author dmiles;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.06.02.37.21;	author stephenreed;	state dead;
branches;
next	1.11;

1.11
date	2001.10.01.23.30.45;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.14.19.58.54;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.12.21.28.27;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.11.21.46.17;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.11.13.56.34;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.10.16.00.28;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.09.20.55.41;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.08.03.30.41;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.07.23.43.03;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.07.03.28.15;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.06.22.13.23;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental classes.
@
text
@package org.opencyc.queryprocessor;

import java.util.*;
import java.io.*;
import junit.framework.*;

import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.api.*;

/**
 * Provides a suite of JUnit test cases for the <tt>org.opencyc.queryprocessor</tt> package.<p>
 *
 * @@version $Id: UnitTest.java,v 1.11 2001/10/01 23:30:45 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class UnitTest extends TestCase {

    /**
     * Constructs a new UnitTest object.
     * @@param name the test case name.
     */
    public UnitTest(String name) {
        super(name);
    }

    /**
     * Main method in case tracing is prefered over running JUnit GUI.
     */
    public static void main(String[] args) {
        boolean allTests = false;
        //boolean allTests = true;
        runTests(allTests);
    }

    /**
     * Runs the unit tests
     */
    public static void runTests(boolean allTests) {
        TestSuite testSuite;
        if (allTests)
            testSuite = new TestSuite(UnitTest.class);
        else {
            testSuite = new TestSuite();
            testSuite.addTest(new UnitTest("testQueryParser"));
            testSuite.addTest(new UnitTest("testLiteralAsker1"));
            testSuite.addTest(new UnitTest("testHashJoiner"));
            testSuite.addTest(new UnitTest("testQueryProcessor1"));
            testSuite.addTest(new UnitTest("testQueryProcessor4"));
            testSuite.addTest(new UnitTest("testQueryProcessor5"));
            testSuite.addTest(new UnitTest("testQueryProcessor6"));
            testSuite.addTest(new UnitTest("testQueryProcessor7"));
            testSuite.addTest(new UnitTest("testQueryProcessor8"));
            testSuite.addTest(new UnitTest("testQueryProcessor9"));
            testSuite.addTest(new UnitTest("testQueryProcessor11"));
            testSuite.addTest(new UnitTest("testBackchainer1"));
            testSuite.addTest(new UnitTest("testBackchainer2"));
            testSuite.addTest(new UnitTest("testBackchainer3"));
            testSuite.addTest(new UnitTest("testBackchainer4"));
            testSuite.addTest(new UnitTest("testBackchainer5"));
            testSuite.addTest(new UnitTest("testBackchainer6"));
        }
        TestResult testResult = new TestResult();
        testSuite.run(testResult);
    }

    /**
     * Tests the <tt>QueryParser</tt> class.
     */
    public void testQueryParser() {
        System.out.println("** testQueryParser **");

        QueryProcessor queryProcessor = new QueryProcessor();
        int verbosity = 3;
        queryProcessor.solution = new Solution(null, verbosity);
        String queryString1 =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        try {
            CycList query1 = CycAccess.current().makeCycList(queryString1);
            queryProcessor.query = query1;
            queryProcessor.queryLiterals = QueryLiteral.simplifyQueryLiteralExpression(query1);
            QueryParser queryParser = queryProcessor.queryParser;
            queryParser.extractQueryLiterals();
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(queryProcessor.queryLiterals);
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        System.out.println("queryLiterals\n" + queryProcessor.queryLiterals);
        Assert.assertEquals(4, queryProcessor.queryLiterals.size());
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral1));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral2));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral3));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral4));

        System.out.println("** testProblemParser OK **");
    }

    /**
     * Tests the <tt>LiteralAsker</tt> class.
     */
    public void testLiteralAsker1() {
        System.out.println("** testLiteralAsker1 **");
        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        CycFort mt = null;
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
            CycConstant tourAndVacationPackageItinerariesMt =
                cycAccess.getKnownConstantByGuid("bfc7800e-9c29-11b1-9dad-c379636f7270");
            mt = tourAndVacationPackageItinerariesMt;
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        ArrayList queryLiterals = new ArrayList();
        queryLiterals.add(queryLiteral1);
        queryLiterals.add(queryLiteral2);
        queryLiterals.add(queryLiteral3);
        queryLiterals.add(queryLiteral4);
        LiteralAsker literalAsker = new LiteralAsker();
        literalAsker.setVerbosity(0);
        ArrayList bindingSets = null;
        try {
            bindingSets = literalAsker.ask(queryLiterals, mt);
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        for (int i = 0; i < bindingSets.size(); i++) {
            BindingSet bindingSet = (BindingSet) bindingSets.get(i);
            //bindingSet.displayBindingSet();
        }
        try {
            cycAccess.close();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        System.out.println("** testLiteralAsker1 OK **");
    }

    /**
     * Tests the <tt>HashJoinerr</tt> class.
     */
    public void testHashJoiner() {
        System.out.println("** testHashJoiner **");

        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        CycFort mt = null;
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
            CycConstant tourAndVacationPackageItinerariesMt =
                cycAccess.getKnownConstantByGuid("bfc7800e-9c29-11b1-9dad-c379636f7270");
            mt = tourAndVacationPackageItinerariesMt;
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        ArrayList queryLiterals = new ArrayList();
        queryLiterals.add(queryLiteral1);
        queryLiterals.add(queryLiteral2);
        queryLiterals.add(queryLiteral3);
        queryLiterals.add(queryLiteral4);
        LiteralAsker literalAsker = new LiteralAsker();
        literalAsker.setVerbosity(3);
        ArrayList bindingSets = null;
        try {
            bindingSets = literalAsker.ask(queryLiterals, mt);
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }

        HashJoiner hashJoiner = new HashJoiner();
        hashJoiner.literalAsker = literalAsker;
        hashJoiner.setVerbosity(3);
        BindingSet joinedBindingSets = null;
        try {
            joinedBindingSets = hashJoiner.join(bindingSets);
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(joinedBindingSets);

        try {
            cycAccess.close();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }

        System.out.println("** testHashJoiner OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor1() {
        System.out.println("** testQueryProcessor1 **");

        // European Cathedrals
        String europeanCathedralsString =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?city #$City) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        QueryProcessor europeanCathedralsQuery = new QueryProcessor();
        europeanCathedralsQuery.setVerbosity(5);
        // Request two solutions.
        // europeanCathedralsQuery.nbrSolutionsRequested = new Integer(2);
        // Request all solutions.
        europeanCathedralsQuery.nbrSolutionsRequested = null;
        ArrayList solutions = null;
        try {
            CycConstant tourAndVacationPackageItinerariesMt =
                CycAccess.current().getKnownConstantByGuid("bfc7800e-9c29-11b1-9dad-c379636f7270");
            europeanCathedralsQuery.mt = tourAndVacationPackageItinerariesMt;
            solutions = europeanCathedralsQuery.ask(CycAccess.current().makeCycList(europeanCathedralsString));
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(solutions);

        System.out.println("** testQueryProcessor1 OK **");
    }


    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor4() {
        System.out.println("** testQueryProcessor4 **");

        // One variable query.
        String oneVariableQueryString =
            "(#$and (#$isa ?WHAT #$CarvedArtwork) (#$provenanceOfArtObject #$CityOfAustinTX ?WHAT))";
        System.out.println(oneVariableQueryString);
        QueryProcessor oneVariableQueryProblem = new QueryProcessor();
        oneVariableQueryProblem.setVerbosity(3);
        // Request all solutions.
        oneVariableQueryProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            oneVariableQueryProblem.mt = inferencePSC;
            ArrayList solutions = oneVariableQueryProblem.ask(oneVariableQueryString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor4 OK **");
    }


    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor5() {
        System.out.println("** testQueryProcessor5 **");

        // One variable query.
        String oneVariableQueryString =
            "(#$and (#$groupMembers ?C ?C) (#$objectFoundInLocation ?C #$CityOfAustinTX))";
        System.out.println(oneVariableQueryString);
        QueryProcessor oneVariableQueryProblem = new QueryProcessor();
        oneVariableQueryProblem.setVerbosity(3);
        // Request all solutions.
        oneVariableQueryProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            oneVariableQueryProblem.mt = inferencePSC;
            ArrayList solutions = oneVariableQueryProblem.ask(oneVariableQueryString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor5 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor6() {
        System.out.println("** testQueryProcessor6 **");

        // query with nart.
        String nartQueryString =
            "(#$isa ?STORAGE (#$StoreFn #$CarvedArtwork))";
        System.out.println(nartQueryString);
        QueryProcessor nartProblem = new QueryProcessor();
        nartProblem.setVerbosity(3);
        // Request all solutions.
        nartProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            nartProblem.mt = inferencePSC;
            ArrayList solutions = nartProblem.ask(nartQueryString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor6 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor7() {
        System.out.println("** testQueryProcessor7 **");

        // NFn.
        String nFnString =
            "(#$and (#$physicalParts #$CityOfAustinTX (#$NFn ?COL ?N ?INDEX)) " +
            "       (#$groupMembers (#$NFn ?COL ?N ?INDEX) ?MEMBER))";
        System.out.println(nFnString);
        QueryProcessor nFnProblem = new QueryProcessor();
        nFnProblem.setVerbosity(3);
        // Request all solutions.
        nFnProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            nFnProblem.mt = inferencePSC;
            ArrayList solutions = nFnProblem.ask(nFnString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor7 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor8() {
        System.out.println("** testQueryProcessor8 **");

        // domain population rules are mostly high cardinality isa rules.
        String isaDomainString =
            "(#$and " +
            "  (#$isa (#$GovernmentFn ?STATE) #$Organization) " +
            "  (#$physicalExtent (#$GovernmentFn ?STATE) ?PLACE) " +
            "  (#$physicalParts ?PLACE ?CAP) " +
            "  (#$isa ?CAP #$ConstructionArtifact))";
        System.out.println(isaDomainString);
        QueryProcessor isaDomainProblem = new QueryProcessor();
        isaDomainProblem.setVerbosity(3);
        // Request all solutions.
        isaDomainProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            isaDomainProblem.mt = inferencePSC;
            ArrayList solutions = isaDomainProblem.ask(isaDomainString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor8 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor9() {
        System.out.println("** testQueryProcessor9 **");

        // domain population rules are all high cardinality isa rules.
        String problemString =
            "(#$and " +
            "  (#$temporallySubsumes ?TIME ?MT-TIME) " +
            "  (#$mtTime ?MT ?MT-TIME) " +
            "  (#$holdsIn ?TIME (#$on-Physical ?WHAT #$CityOfAustinTX)))";
        System.out.println(problemString);
        QueryProcessor problem = new QueryProcessor();
        problem.setVerbosity(3);
        // Request all solutions.
        problem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            problem.mt = inferencePSC;
            ArrayList solutions = problem.ask(problemString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor9 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor11() {
        System.out.println("** testQueryProcessor11 **");

        String problemString =
            "(#$and " +
            "  (#$assertedSentence " +
            "    (#$isa ?COUNTRY #$WesternEuropeanCountry)) " +
            "  (#$assertedSentence " +
            "    (#$isa ?CATHEDRAL #$Cathedral)) " +
            "  (#$assertedSentence " +
            "    (#$countryOfCity ?COUNTRY ?CITY)) " +
            "  (#$assertedSentence  " +
            "    (#$objectFoundInLocation ?CATHEDRAL ?CITY)))";
            //"  (#$genlPreds ?OBJECT-SPEC #$objectFoundInLocation) " +
            //"  (#$assertedSentence  " +
            //"    (?OBJECT-SPEC ?CATHEDRAL ?CITY)))";
        System.out.println(problemString);
        QueryProcessor problem = new QueryProcessor();
        problem.setVerbosity(1);
        // Request all solutions.
        problem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            problem.mt = inferencePSC;
            ArrayList solutions = problem.ask(problemString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor11 OK **");
    }


    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer1() {
        System.out.println("** testBackchainer1 **");

        // what is in Austin?
        String whatIsInAustinString =
            "(#$objectFoundInLocation ?WHAT #$CityOfAustinTX)";
        System.out.println(whatIsInAustinString);
        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess(CycConnection.DEFAULT_HOSTNAME,
                                      CycConnection.DEFAULT_BASE_PORT,
                                      CycConnection.ASCII_MODE,
                                      CycAccess.PERSISTENT_CONNECTION);
        }
        catch (Exception e) {
            Assert.fail(e.toString());
        }
        QueryProcessor whatIsInAustinProblem = new QueryProcessor(cycAccess);
        whatIsInAustinProblem.setVerbosity(9);
        // Request one solution.
        //whatIsInAustinProblem.nbrSolutionsRequested = new Integer(1);
        // Request all solutions.
        whatIsInAustinProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsInAustinProblem.mt = inferencePSC;
            whatIsInAustinProblem.query = CycAccess.current().makeCycList(whatIsInAustinString);
            whatIsInAustinProblem.queryParser.extractQueryLiterals();
            whatIsInAustinProblem.backchainer.mt = whatIsInAustinProblem.mt;
            whatIsInAustinProblem.backchainer.setVariables(whatIsInAustinProblem.getVariables());
            ArrayList backchainRules =
                whatIsInAustinProblem.backchainer.getBackchainRules(whatIsInAustinProblem.queryLiterals);
            Assert.assertNotNull(backchainRules);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testBackchainer1 OK **");
    }

    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer2() {
        System.out.println("** testBackchainer2 **");
        // what is in Austin?
        String whatIsInAustinString =
            "(#$objectFoundInLocation ?WHAT #$CityOfAustinTX)";
        System.out.println(whatIsInAustinString);
        QueryProcessor whatIsInAustinProblem = new QueryProcessor();
        whatIsInAustinProblem.setVerbosity(3);
        whatIsInAustinProblem.setMaxBackchainDepth(1);
        // Request all solutions.
        whatIsInAustinProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsInAustinProblem.mt = inferencePSC;
            ArrayList solutions = whatIsInAustinProblem.ask(whatIsInAustinString);
            for (int i = 0; i < solutions.size(); i++)
                System.out.println(solutions.get(i));
            //Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }
        System.out.println("** testBackchainer2 OK **");
    }

    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer3() {
        System.out.println("** testBackchainer3 **");
        // what is in Austin? to depth 2
        String whatIsInAustinString =
            "(#$objectFoundInLocation ?WHAT #$CityOfAustinTX)";
        System.out.println(whatIsInAustinString);
        QueryProcessor whatIsInAustinProblem = new QueryProcessor();
        //whatIsInAustinProblem.setVerbosity(9);
        whatIsInAustinProblem.setVerbosity(2);
        whatIsInAustinProblem.setMaxBackchainDepth(2);
        // Request all solutions.
        whatIsInAustinProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsInAustinProblem.mt = inferencePSC;
            ArrayList solutions = whatIsInAustinProblem.ask(whatIsInAustinString);
            for (int i = 0; i < solutions.size(); i++)
                System.out.println(solutions.get(i));
            //Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }
        System.out.println("** testBackchainer3 OK **");
    }

    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer4() {
        System.out.println("** testBackchainer4 **");
        // what is a CarvedArtwork? to depth 1
        String whatIsACarvedArtworkString =
            "(#$isa ?WHAT #$CarvedArtwork)";
        System.out.println(whatIsACarvedArtworkString);
        QueryProcessor whatIsACarvedArtworkProblem = new QueryProcessor();
        whatIsACarvedArtworkProblem.setVerbosity(3);
        whatIsACarvedArtworkProblem.setSbhlBackchain(true);
        whatIsACarvedArtworkProblem.setMaxBackchainDepth(1);
        // Request all solutions.
        whatIsACarvedArtworkProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsACarvedArtworkProblem.mt = inferencePSC;
            ArrayList solutions = whatIsACarvedArtworkProblem.ask(whatIsACarvedArtworkString);
            for (int i = 0; i < solutions.size(); i++)
                System.out.println(solutions.get(i));
            //Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }
        System.out.println("** testBackchainer4 OK **");
    }

    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer5() {
        System.out.println("** testBackchainer5 **");
        String whatIsACarvedArtworkString =
            "(#$holdsIn ?SIT (#$pathState #$CityOfAustinTX #$PathBlocked))";
        System.out.println(whatIsACarvedArtworkString);
        QueryProcessor whatIsACarvedArtworkProblem = new QueryProcessor();
        whatIsACarvedArtworkProblem.setVerbosity(3);
        whatIsACarvedArtworkProblem.setSbhlBackchain(true);
        whatIsACarvedArtworkProblem.setMaxBackchainDepth(1);
        // Request all solutions.
        whatIsACarvedArtworkProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsACarvedArtworkProblem.mt = inferencePSC;
            ArrayList solutions = whatIsACarvedArtworkProblem.ask(whatIsACarvedArtworkString);
            for (int i = 0; i < solutions.size(); i++)
                System.out.println(solutions.get(i));
            //Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }
        System.out.println("** testBackchainer5 OK **");
    }

    /**
     * Tests the <tt>Backchainer</tt> class.
     */
    public void testBackchainer6() {
        System.out.println("** testBackchainer6 **");

        // austinIsaHarbor.
        String austinIsaHarborString =
            "(#$and (#$isa ?WHAT #$Ship) " +
            "       (#$objectFoundInLocation ?WHAT ?L) " +
            "       (#$isa ?L #$PortCity) " +
            "       (#$isa #$CityOfAustinTX #$Harbor) " +
            "       (#$geographicalSubRegions ?L #$CityOfAustinTX))";
        System.out.println(austinIsaHarborString);
        QueryProcessor austinIsaHarborProblem = new QueryProcessor();
        austinIsaHarborProblem.setVerbosity(3);
        // Request all solutions.
        austinIsaHarborProblem.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            austinIsaHarborProblem.mt = inferencePSC;
            ArrayList solutions = austinIsaHarborProblem.ask(austinIsaHarborString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testBackchainer6 OK **");
    }

}
@


1.12
log
@Removed experimental classes
@
text
@d6 1
@


1.11
log
@Added more test cases for SubL server scripting
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.10 2001/09/14 19:58:54 stephenreed Exp $
@


1.10
log
@Replaced getConstantByName with getConstantByGuid
Replaced getKnownConstantByName with getKnownConstantByGuid
to reflect the stability of guids and the lesser stability of constant names.
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.9 2001/09/12 21:28:27 stephenreed Exp $
d62 10
a71 11
            //testSuite.addTest(new UnitTest("testQueryParser"));
            //testSuite.addTest(new UnitTest("testLiteralAsker1"));
            //testSuite.addTest(new UnitTest("testHashJoiner"));
            //testSuite.addTest(new UnitTest("testQueryProcessor1"));
            //testSuite.addTest(new UnitTest("testQueryProcessor3"));
            //testSuite.addTest(new UnitTest("testQueryProcessor4"));
            //testSuite.addTest(new UnitTest("testQueryProcessor5"));
            //testSuite.addTest(new UnitTest("testQueryProcessor6"));
            //testSuite.addTest(new UnitTest("testQueryProcessor7"));
            //testSuite.addTest(new UnitTest("testQueryProcessor8"));
            //testSuite.addTest(new UnitTest("testQueryProcessor9"));
d73 6
a78 6
            //testSuite.addTest(new UnitTest("testBackchainer1"));
            //testSuite.addTest(new UnitTest("testBackchainer2"));
            //testSuite.addTest(new UnitTest("testBackchainer3"));
            //testSuite.addTest(new UnitTest("testBackchainer4"));
            //testSuite.addTest(new UnitTest("testBackchainer5"));
            //testSuite.addTest(new UnitTest("testBackchainer6"));
a295 32

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor3() {
        System.out.println("** testQueryProcessor3 **");

        // European Cathedrals with arg type discovery
        String whatIsInAustinString =
            "(#$objectFoundInLocation ?WHAT #$CityOfAustinTX)";
        System.out.println(whatIsInAustinString);
        QueryProcessor whatIsInAustinProblem2 = new QueryProcessor();
        whatIsInAustinProblem2.setVerbosity(3);
        // Request one solution.
        //whatIsInAustinProblem2.nbrSolutionsRequested = new Integer(1);
        // Request all solutions.
        whatIsInAustinProblem2.nbrSolutionsRequested = null;
        try {
            CycConstant inferencePSC =
                CycAccess.current().getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
            whatIsInAustinProblem2.mt = inferencePSC;
            ArrayList solutions = whatIsInAustinProblem2.ask(whatIsInAustinString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor3 OK **");
    }
@


1.9
log
@Added another test case
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.8 2001/09/11 21:46:17 stephenreed Exp $
d63 1
a63 1
            //testSuite.addTest(new UnitTest("testLiteralAsker"));
a72 1
            //testSuite.addTest(new UnitTest("testQueryProcessor10"));
d138 2
a139 2
    public void testLiteralAsker() {
        System.out.println("** testLiteralAsker **");
d157 3
a159 1
            mt = CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
d188 1
a188 1
        System.out.println("** testLiteralAsker OK **");
d214 3
a216 1
            mt = CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
d276 1
a276 1
        europeanCathedralsQuery.setVerbosity(3);
d283 3
a285 2
            europeanCathedralsQuery.mt =
                CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
d315 3
a317 2
            whatIsInAustinProblem2.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d345 3
a347 2
            oneVariableQueryProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d376 3
a378 2
            oneVariableQueryProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d406 3
a408 2
            nartProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d437 3
a439 2
            nFnProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d471 3
a473 2
            isaDomainProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d504 3
a506 2
            problem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
a521 79
    public void testQueryProcessor10() {
        System.out.println("** testQueryProcessor10 **");

        // zebra constraint problem.
        String problemString =
            "(#$and " +
            "  (#$or " +
            "    (#$numericallyEqual ?norwegian (#$PlusFn ?blue 1)) " +
            "    (#$numericallyEqual ?blue (#$PlusFn ?norwegian 1))) " +
            "  (#$numericallyEqual ?japanese ?volkswagen) " +
            "  (#$numericallyEqual ?mercedes-benz ?orange-juice) " +
            "  (#$or " +
            "    (#$numericallyEqual ?ford (#$PlusFn ?horse 1)) " +
            "    (#$numericallyEqual ?horse (#$PlusFn ?ford 1))) " +
            "  (#$or " +
            "    (#$numericallyEqual ?chevrolet (#$PlusFn ?fox 1)) " +
            "    (#$numericallyEqual ?fox (#$PlusFn ?chevrolet 1))) " +
            "  (#$numericallyEqual ?norwegian 1) " +
            "  (#$numericallyEqual ?milk 3) " +
            "  (#$numericallyEqual ?ford ?yellow) " +
            "  (#$numericallyEqual ?oldsmobile ?snails) " +
            "  (#$numericallyEqual ?green (#$PlusFn ?ivory 1)) " +
            "  (#$numericallyEqual ?ukranian ?eggnog) " +
            "  (#$numericallyEqual ?cocoa ?green) " +
            "  (#$numericallyEqual ?spaniard ?dog) " +
            "  (#$numericallyEqual ?english ?red) " +
            "  (#$different ?ford ?chevrolet ?oldsmobile ?mercedes-benz ?volkswagen) " +
            "  (#$different ?orange-juice ?cocoa ?eggnog ?milk ?water) " +
            "  (#$different ?dog ?snails ?horse ?fox ?zebra) " +
            "  (#$different ?english ?spaniard ?norwegian ?japanese ?ukranian) " +
            "  (#$different ?blue ?red ?green ?yellow ?ivory) " +
            "  (#$elementOf ?blue (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?chevrolet (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?cocoa (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?dog (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?eggnog (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?english (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?ford (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?fox (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?green (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?horse (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?ivory (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?japanese (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?mercedes-benz (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?milk (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?norwegian (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?oldsmobile (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?orange-juice (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?red (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?snails (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?spaniard (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?ukranian (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?volkswagen (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?water (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?yellow (#$TheSet 1 2 3 4 5)) " +
            "  (#$elementOf ?zebra (#$TheSet 1 2 3 4 5))) ";
        System.out.println(problemString);
        QueryProcessor problem = new QueryProcessor();
        problem.setVerbosity(9);
        // Request all solutions.
        problem.nbrSolutionsRequested = null;
        try {
            problem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
            ArrayList solutions = problem.ask(problemString);
        Assert.assertNotNull(solutions);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            Assert.fail(e.getMessage());
        }

        System.out.println("** testQueryProcessor10 OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
d544 3
a546 2
            problem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d587 3
a589 2
            whatIsInAustinProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d622 3
a624 2
            whatIsInAustinProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d654 3
a656 2
            whatIsInAustinProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d686 3
a688 2
            whatIsACarvedArtworkProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d717 3
a719 2
            whatIsACarvedArtworkProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
d752 3
a754 2
            austinIsaHarborProblem.mt =
                CycAccess.current().getConstantByName("InferencePSC");
@


1.8
log
@Constraint problems now enter the cyc api initially as queries.
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.7 2001/09/11 13:56:34 stephenreed Exp $
d73 2
a74 1
            testSuite.addTest(new UnitTest("testQueryProcessor10"));
d586 41
d828 1
a828 1
}@


1.7
log
@Removing domain population logic from the constraint solver, having moved that behavior to the query processor.
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.6 2001/09/10 16:00:28 stephenreed Exp $
d73 2
a74 1
            testSuite.addTest(new UnitTest("testBackchainer1"));
a474 1
//(and (temporallySubsumes ?TIME ?MT-TIME) (mtTime ?MT ?MT-TIME) (holdsIn ?TIME (on-Physical ?WHAT CityOfAustinTX)))
d505 79
@


1.6
log
@Added code to support postponed asks for in the HashJoiner class
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.5 2001/09/09 20:55:41 stephenreed Exp $
d65 14
a78 1
            testSuite.addTest(new UnitTest("testQueryProcessor1"));
d223 1
a223 1
        literalAsker.setVerbosity(5);
d234 2
a235 1
        hashJoiner.setVerbosity(4);
a269 1
        System.out.println(europeanCathedralsString);
d271 1
a271 1
        europeanCathedralsQuery.setVerbosity(9);
d290 417
@


1.5
log
@Completed first set of unit tests for HashJoiner and QueryProcessor.
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.4 2001/09/08 03:30:41 stephenreed Exp $
d258 1
a258 1
        europeanCathedralsQuery.setVerbosity(1);
d263 1
d267 1
d269 2
a270 1
        catch (IOException e) {
a272 1
        ArrayList solutions = europeanCathedralsQuery.ask(CycAccess.current().makeCycList(europeanCathedralsString));
@


1.4
log
@Unit testing HashJoiner
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.3 2001/09/07 23:43:03 stephenreed Exp $
d64 2
a65 2
            testSuite.addTest(new UnitTest("testHashJoiner"));
            //testSuite.addTest(new UnitTest("testQueryProcessor1"));
d201 1
d221 1
a221 1
        hashJoiner.setVerbosity(5);
d227 1
d258 1
a258 1
        europeanCathedralsQuery.setVerbosity(9);
@


1.3
log
@Added defered completion of CycForts in the binary api. Continued with HashJoiner.
@
text
@d1 272
a272 272
package org.opencyc.queryprocessor;

import java.util.*;
import java.io.*;
import junit.framework.*;
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.api.*;

/**
 * Provides a suite of JUnit test cases for the <tt>org.opencyc.queryprocessor</tt> package.<p>
 *
 * @@version $Id: UnitTest.java,v 1.2 2001/09/07 03:28:15 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class UnitTest extends TestCase {

    /**
     * Constructs a new UnitTest object.
     * @@param name the test case name.
     */
    public UnitTest(String name) {
        super(name);
    }

    /**
     * Main method in case tracing is prefered over running JUnit GUI.
     */
    public static void main(String[] args) {
        boolean allTests = false;
        //boolean allTests = true;
        runTests(allTests);
    }

    /**
     * Runs the unit tests
     */
    public static void runTests(boolean allTests) {
        TestSuite testSuite;
        if (allTests)
            testSuite = new TestSuite(UnitTest.class);
        else {
            testSuite = new TestSuite();
            //testSuite.addTest(new UnitTest("testQueryParser"));
            //testSuite.addTest(new UnitTest("testLiteralAsker"));
            testSuite.addTest(new UnitTest("testHashJoiner"));
            //testSuite.addTest(new UnitTest("testQueryProcessor1"));
        }
        TestResult testResult = new TestResult();
        testSuite.run(testResult);
    }

    /**
     * Tests the <tt>QueryParser</tt> class.
     */
    public void testQueryParser() {
        System.out.println("** testQueryParser **");

        QueryProcessor queryProcessor = new QueryProcessor();
        int verbosity = 3;
        queryProcessor.solution = new Solution(null, verbosity);
        String queryString1 =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        try {
            CycList query1 = CycAccess.current().makeCycList(queryString1);
            queryProcessor.query = query1;
            queryProcessor.queryLiterals = QueryLiteral.simplifyQueryLiteralExpression(query1);
            QueryParser queryParser = queryProcessor.queryParser;
            queryParser.extractQueryLiterals();
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(queryProcessor.queryLiterals);
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        System.out.println("queryLiterals\n" + queryProcessor.queryLiterals);
        Assert.assertEquals(4, queryProcessor.queryLiterals.size());
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral1));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral2));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral3));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral4));

        System.out.println("** testProblemParser OK **");
    }

    /**
     * Tests the <tt>LiteralAsker</tt> class.
     */
    public void testLiteralAsker() {
        System.out.println("** testLiteralAsker **");
        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        CycFort mt = null;
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
            mt = CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        ArrayList queryLiterals = new ArrayList();
        queryLiterals.add(queryLiteral1);
        queryLiterals.add(queryLiteral2);
        queryLiterals.add(queryLiteral3);
        queryLiterals.add(queryLiteral4);
        LiteralAsker literalAsker = new LiteralAsker();
        literalAsker.setVerbosity(0);
        ArrayList bindingSets = null;
        try {
            bindingSets = literalAsker.ask(queryLiterals, mt);
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        for (int i = 0; i < bindingSets.size(); i++) {
            BindingSet bindingSet = (BindingSet) bindingSets.get(i);
            //bindingSet.displayBindingSet();
        }
        try {
            cycAccess.close();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        System.out.println("** testLiteralAsker OK **");
    }

    /**
     * Tests the <tt>HashJoinerr</tt> class.
     */
    public void testHashJoiner() {
        System.out.println("** testHashJoiner **");

        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        CycFort mt = null;
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
            mt = CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        ArrayList queryLiterals = new ArrayList();
        queryLiterals.add(queryLiteral1);
        queryLiterals.add(queryLiteral2);
        queryLiterals.add(queryLiteral3);
        queryLiterals.add(queryLiteral4);
        LiteralAsker literalAsker = new LiteralAsker();
        literalAsker.setVerbosity(9);
        ArrayList bindingSets = null;
        try {
            bindingSets = literalAsker.ask(queryLiterals, mt);
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }

        HashJoiner hashJoiner = new HashJoiner();
        hashJoiner.setVerbosity(9);
        BindingSet joinedBindingSets = null;
        try {
            joinedBindingSets = hashJoiner.join(bindingSets);
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(joinedBindingSets);

        try {
            cycAccess.close();
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }

        System.out.println("** testHashJoiner OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor1() {
        System.out.println("** testQueryProcessor1 **");

        // European Cathedrals
        String europeanCathedralsString =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?city #$City) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        System.out.println(europeanCathedralsString);
        QueryProcessor europeanCathedralsQuery = new QueryProcessor();
        europeanCathedralsQuery.setVerbosity(9);
        // Request two solutions.
        // europeanCathedralsQuery.nbrSolutionsRequested = new Integer(2);
        // Request all solutions.
        europeanCathedralsQuery.nbrSolutionsRequested = null;
        try {
            europeanCathedralsQuery.mt =
                CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
        }
        catch (IOException e) {
            Assert.fail(e.getMessage());
        }
        ArrayList solutions = europeanCathedralsQuery.ask(CycAccess.current().makeCycList(europeanCathedralsString));
        Assert.assertNotNull(solutions);

        System.out.println("** testQueryProcessor1 OK **");
    }
@


1.2
log
@Beginning unit test cases for query processor.
@
text
@d1 272
a272 173
package org.opencyc.queryprocessor;

import java.util.*;
import java.io.*;
import junit.framework.*;
import org.opencyc.cycobject.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.api.*;

/**
 * Provides a suite of JUnit test cases for the <tt>org.opencyc.queryprocessor</tt> package.<p>
 *
 * @@version $Id: UnitTest.java,v 1.1 2001/09/06 22:13:23 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class UnitTest extends TestCase {

    /**
     * Constructs a new UnitTest object.
     * @@param name the test case name.
     */
    public UnitTest(String name) {
        super(name);
    }

    /**
     * Main method in case tracing is prefered over running JUnit GUI.
     */
    public static void main(String[] args) {
        boolean allTests = false;
        //boolean allTests = true;
        runTests(allTests);
    }

    /**
     * Runs the unit tests
     */
    public static void runTests(boolean allTests) {
        TestSuite testSuite;
        if (allTests)
            testSuite = new TestSuite(UnitTest.class);
        else {
            testSuite = new TestSuite();
            //testSuite.addTest(new UnitTest("testQueryParser"));
            //testSuite.addTest(new UnitTest("testLiteralAsker"));
            //testSuite.addTest(new UnitTest("testHashJoiner"));
            testSuite.addTest(new UnitTest("testQueryProcessor1"));
        }
        TestResult testResult = new TestResult();
        testSuite.run(testResult);
    }

    /**
     * Tests the <tt>QueryParser</tt> class.
     */
    public void testQueryParser() {
        System.out.println("** testQueryParser **");

        QueryProcessor queryProcessor = new QueryProcessor();
        int verbosity = 3;
        queryProcessor.solution = new Solution(null, verbosity);
        String queryString1 =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        QueryLiteral queryLiteral1 = null;
        QueryLiteral queryLiteral2 = null;
        QueryLiteral queryLiteral3 = null;
        QueryLiteral queryLiteral4 = null;
        try {
            CycList query1 = CycAccess.current().makeCycList(queryString1);
            queryProcessor.query = query1;
            queryProcessor.queryLiterals = QueryLiteral.simplifyQueryLiteralExpression(query1);
            QueryParser queryParser = queryProcessor.queryParser;
            queryParser.extractQueryLiterals();
        }
        catch (Exception e) {
            e.printStackTrace();
            Assert.fail(e.getMessage());
        }
        Assert.assertNotNull(queryProcessor.queryLiterals);
        try {
            queryLiteral1 = new QueryLiteral("(#$isa ?country #$WesternEuropeanCountry)");
            queryLiteral2 = new QueryLiteral("(#$isa ?cathedral #$Cathedral)");
            queryLiteral3 = new QueryLiteral("(#$countryOfCity ?country ?city)");
            queryLiteral4 = new QueryLiteral("(#$objectFoundInLocation ?cathedral ?city)");
        }
        catch (Exception e) {
            Assert.fail(e.getMessage());
        }
        System.out.println("queryLiterals\n" + queryProcessor.queryLiterals);
        Assert.assertEquals(4, queryProcessor.queryLiterals.size());
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral1));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral2));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral3));
        Assert.assertTrue(queryProcessor.queryLiterals.contains(queryLiteral4));

        System.out.println("** testProblemParser OK **");
    }

    /**
     * Tests the <tt>LiteralAsker</tt> class.
     */
    public void testLiteralAsker() {
        System.out.println("** testLiteralAsker **");

        System.out.println("** testLiteralAsker OK **");
    }

    /**
     * Tests the <tt>HashJoinerr</tt> class.
     */
    public void testHashJoiner() {
        System.out.println("** testHashJoiner **");

        System.out.println("** testHashJoiner OK **");
    }

    /**
     * Tests the <tt>QueryProcessor</tt> class.
     */
    public void testQueryProcessor1() {
        System.out.println("** testQueryProcessor1 **");

        // European Cathedrals
        String europeanCathedralsString =
            "(#$and " +
            "  (#$isa ?country #$WesternEuropeanCountry) " +
            "  (#$isa ?city #$City) " +
            "  (#$isa ?cathedral #$Cathedral) " +
            "  (#$countryOfCity ?country ?city) " +
            "  (#$objectFoundInLocation ?cathedral ?city)) ";
        System.out.println(europeanCathedralsString);
        QueryProcessor europeanCathedralsQuery = new QueryProcessor();
        europeanCathedralsQuery.setVerbosity(9);
        // Request two solutions.
        // europeanCathedralsQuery.nbrSolutionsRequested = new Integer(2);
        // Request all solutions.
        europeanCathedralsQuery.nbrSolutionsRequested = null;
        try {
            europeanCathedralsQuery.mt =
                CycAccess.current().getConstantByName("TourAndVacationPackageItinerariesMt");
        }
        catch (IOException e) {
            Assert.fail(e.getMessage());
        }
        ArrayList solutions = europeanCathedralsQuery.ask(CycAccess.current().makeCycList(europeanCathedralsString));
        Assert.assertNotNull(solutions);

        System.out.println("** testQueryProcessor1 OK **");
    }


@


1.1
log
@Added UnitTest class for queryprocessor package
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.31 2001/09/06 21:43:25 stephenreed Exp $
d62 3
a64 3
            testSuite.addTest(new UnitTest("testQueryParser"));
            testSuite.addTest(new UnitTest("testLiteralAsker"));
            testSuite.addTest(new UnitTest("testHashJoiner"));
d78 2
d98 1
d155 1
a155 1
        europeanCathedralsQuery.setVerbosity(1);
@

