head	1.9;
access;
symbols
	PRE_1_0:1.8;
locks; strict;
comment	@# @;


1.9
date	2006.10.21.17.01.59;	author dmiles;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.06.02.37.21;	author stephenreed;	state dead;
branches;
next	1.7;

1.7
date	2001.09.11.21.46.17;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.11.13.56.34;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.10.16.00.28;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.09.20.55.41;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.07.03.28.15;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.06.14.01.08;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental classes.
@
text
@package org.opencyc.queryprocessor;

import java.util.*;
import java.io.IOException;
import org.opencyc.cycobject.*;
import org.opencyc.api.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.constraintsolver.*;
import org.opencyc.constraintsolver.ConstraintProblem;

/**
 * <tt>Rule</tt> object to model the attributes and behavior of a query processor.<p>
 *
 * @@version $Id: QueryProcessor.java,v 1.7 2001/09/11 21:46:17 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class QueryProcessor {

    /**
     * CycAccess object which provides the OpenCyc api.
     */
    CycAccess cycAccess;

    /**
     * <tt>Backchainer</tt> for this <tt>QueryProcessor</tt>.
     */
    protected Backchainer backchainer = new Backchainer();

    /**
     * <tt>LiteralAsker</tt> for this <tt>QueryProcessor</tt>.
     */
    protected LiteralAsker literalAsker;

    /**
     * <tt>Solution</tt> for this <tt>QueryProcessor</tt>.
     */
    protected Solution solution;

    /**
     * The OpenCyc microtheory in which the query should be asked.
     */
    public CycFort mt;

    /**
     * The number of solutions requested.  When <tt>null</tt>, all solutions are sought.
     */
    public Integer nbrSolutionsRequested = new Integer(1);

    /**
     * The default verbosity of the query processor output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public static final int DEFAULT_VERBOSITY = 3;

    /**
     * Sets verbosity of the query processor output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * Collection of the query literals.
     */
    protected ArrayList queryLiterals;

    /**
     * Collection of the constraint rules which are evaluatable query literals that
     * cannot be asked in the KB until their variables have populated domains.
     */
    protected ArrayList constraintRules;

    /**
     * <tt>ProblemParser</tt> object for this <tt>QueryProcessor</tt>.
     */
    protected QueryParser queryParser = new QueryParser(this);

    /**
     * <tt>HashJoiner</tt> object for this <tt>QueryProcessor</tt>.
     */
    protected HashJoiner hashJoiner;

    /**
     * Collection of the query variables as <tt>CycVariable</tt> objects.
     */
    protected ArrayList variables = new ArrayList();

    /**
     * Number of KB asks performed during the search for solution(s).
     */
    protected int nbrAsks = 0;

    /**
     * The input query <tt>CycList</tt>.
     */
    protected CycList query = null;

    /**
     * Constructs a new <tt>QueryProcessor</tt> object, creating a new <tt>CycAccess</tt>
     * object.
     */
    public QueryProcessor() {
        this(initializeCycAccess());
    }

    /**
     * Creates a <tt>CycAccess</tt> object to connect to the OpenCyc server and provide api
     * services.
     *
     * @@return a <tt>CycAccess</tt> object to connect to the OpenCyc server and provide api
     * services
     */
    protected static CycAccess initializeCycAccess() {
        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println("Cannot access OpenCyc server " + e.getMessage());
            System.exit(1);
        }
        return cycAccess;
    }

    /**
     * Constructs a new <tt>QueryProcessor</tt> object given an existing connection to the
     * OpenCyc server.
     *
     * @@param cycAccess the <tt>CycAccess</tt> object to use for this query
     */
    public QueryProcessor(CycAccess cycAccess) {
        this.cycAccess = cycAccess;
        try {
            // Default microtheory
            mt = cycAccess.makeCycConstant("EverythingPSC");
        }
        catch (Exception e) {
            e.printStackTrace();
            System.out.println("Cannot access OpenCyc server " + e.getMessage());
            System.exit(1);
        }
        literalAsker = new LiteralAsker();
        hashJoiner = new HashJoiner();
        hashJoiner.literalAsker = literalAsker;
    }

    /**
     * Asks the input query and returns a list of solutions if one or more
     * was found, otherwise returns <tt>null</tt>.
     *
     * @@param queryString a query in the form of an OpenCyc query string
     * @@return an <tt>ArrayList</tt> of solutions or <tt>null</tt> if no solutions were
     * found.  Each solution is an <tt>ArrayList</tt> of variable binding <tt>ArrayList</tt>
     * objects, each binding having the form of an <tt>ArrayList</tt> where the first
     * element is the <tt>CycVariable</tt> and the second element is the bound value
     * <tt>Object</tt>.
     */
    public ArrayList ask(String queryString) {
        return ask(cycAccess.makeCycList(queryString));
    }

    /**
     * Asks the input query and returns a list of solutions if one or more
     * was found, otherwise returns <tt>null</tt>.
     *
     * @@param query a query in the form of an OpenCyc <tt>CycList</tt> object
     * @@return an <tt>ArrayList</tt> of solutions or <tt>null</tt> if no solutions were
     * found.  Each solution is an <tt>ArrayList</tt> of variable binding <tt>ArrayList</tt>
     * objects, each binding having the form of an <tt>ArrayList</tt> where the first
     * element is the <tt>CycVariable</tt> and the second element is the bound value
     * <tt>Object</tt>.
     */
    public ArrayList ask(CycList query) {
        long startMilliseconds = System.currentTimeMillis();
        this.query = query;
        solution = new Solution(this.nbrSolutionsRequested, verbosity);
        try {
            if (! queryParser.extractQueryLiterals()) {
                long endMilliseconds = System.currentTimeMillis();
                if (verbosity > 0) {
                    System.out.println("No solution because an input literal cannot be satisfied");
                    System.out.println((endMilliseconds - startMilliseconds) + " milliseconds");
                }
                return new ArrayList();
            }
            queryParser.gatherVariables();
            if (verbosity > 0) {
                if (nbrSolutionsRequested == null) {
                    if (backchainer.backchainDepth > 0)
                        System.out.println("Asking for all solutions at backchain depth " +
                                           backchainer.backchainDepth);
                    else
                        System.out.println("Asking for all solutions");
                }
                else if (nbrSolutionsRequested.intValue() == 1)
                    System.out.println("Asking for the first solution");
                else
                    System.out.println("Asking for " + nbrSolutionsRequested + " solutions");
            }
            ArrayList bindingSets = literalAsker.ask(queryLiterals, mt);
            BindingSet joinedBindingSets = hashJoiner.join(bindingSets);
            solution.addBindingSet(joinedBindingSets);
            if (constraintRules.size() > 0) {
                ConstraintProblem constraintProblem = new ConstraintProblem(cycAccess);
                constraintProblem.setVerbosity(verbosity);
                constraintProblem.nbrSolutionsRequested = nbrSolutionsRequested;
                ArrayList constraintSolutions =
                    constraintProblem.solveUsingPartialSolution(solution, variables, constraintRules);
                solution.setSolutions(constraintSolutions);
            }
        }
        catch (IOException e) {
            e.printStackTrace();
            System.out.println("Error accessing OpenCyc " + e.getMessage());
            System.exit(1);
        }
        long duration = System.currentTimeMillis() - startMilliseconds;
        if (verbosity > 0) {
            solution.displaySolutions();
            System.out.println("  " + duration + " milliseconds");
        }

        return solution.getSolutions();
    }

    /**
     * Returns the variables used in the query.
     *
     * @@return the variables used in the query
     */
    public ArrayList getVariables() {
        return variables;
    }

    /**
     * Returns the number of <tt>QueryLiteral</tt> objects derived from
     * the input query.
     *
     * @@return the number of constraint <tt>Rule</tt> objects.
     */
    public int getNbrQueryLiterals() {
        return queryLiterals.size();
    }

    /**
     * Returns the number of <tt>Variable</tt> objects derived from
     * the input problem.
     *
     * @@return the number of <tt>CycVariable</tt> objects.
     */
    public int getNbrVariables() {
        return variables.size();
    }

    /**
     * Displays the input query literals.
     */
    public void displayQueryLiterals() {
        if (queryLiterals.size() > 0) {
            System.out.println("Query literals");
            for (int i = 0; i < queryLiterals.size(); i++) {
                QueryLiteral queryLiteral = (QueryLiteral) queryLiterals.get(i);
                if (queryLiteral.nbrFormulaInstances == -1)
                    System.out.println("  " + queryLiteral.cyclify());
                else
                    System.out.println("  " + queryLiteral.cyclify() + "  " +
                                       queryLiteral.nbrFormulaInstances + " instances");
            }
        }
        else
            System.out.println("No query literals");
        System.out.println();
    }

    /**
     * Displays the constraint rules.
     */
    public void displayConstraintRules() {
        System.out.println("Constraint Rules");
        if (constraintRules.size() > 0) {
            for (int i = 0; i < constraintRules.size(); i++) {
                ConstraintRule constraintRule = (ConstraintRule) constraintRules.get(i);
                System.out.println("  " + constraintRule.cyclify());
            }
        }
        else
            System.out.println("No constraint rules");
    }

    /**
     * Sets verbosity of the query processor output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
        queryParser.setVerbosity(verbosity);
        backchainer.setVerbosity(verbosity);
        hashJoiner.setVerbosity(verbosity);
        literalAsker.setVerbosity(verbosity);
        if (solution != null)
            solution.setVerbosity(verbosity);
    }

    /**
     * Sets the maximum depth of backchaining from an input query. A value of zero indicates
     * no backchaining.
     *
     * @@param maxBackchainDepth the maximum depth of backchaining, or zero if no backchaing on the input
     * queries
     */
    public void setMaxBackchainDepth(int maxBackchainDepth) {
        backchainer.maxBackchainDepth = maxBackchainDepth;
    }

    /**
     * Sets the current depth of backchaining from an input query.
     *
     * @@param backchainDepth the current depth of backchaining from an input query
     */
    public void setBackchainDepth(int backchainDepth) {
        backchainer.backchainDepth = backchainDepth;
    }

    /**
     * Sets whether backchaining is performed on rules with the predicate of #$isa or #$genls.  Large
     * numbers of rules conclude #$isa or #$genls, which are not usually relevant - so the default is
     * false.
     *
     * @@param sbhlBackchain whether backchaining is performed on rules with the predicate of #$isa or #$genls
     */
    public void setSbhlBackchain(boolean sbhlBackchain) {
        backchainer.setSbhlBackchain(sbhlBackchain);
    }



}@


1.8
log
@Removed experimental classes
@
text
@d9 1
@


1.7
log
@Constraint problems now enter the cyc api initially as queries.
@
text
@d13 1
a13 1
 * @@version $Id: QueryProcessor.java,v 1.6 2001/09/11 13:56:34 stephenreed Exp $
@


1.6
log
@Removing domain population logic from the constraint solver, having moved that behavior to the query processor.
@
text
@d13 1
a13 1
 * @@version $Id: QueryProcessor.java,v 1.5 2001/09/10 16:00:28 stephenreed Exp $
d225 1
a225 1
                    constraintProblem.solveUsingPartialSolution(solution, constraintRules);
@


1.5
log
@Added code to support postponed asks for in the HashJoiner class
@
text
@d8 1
d13 1
a13 1
 * @@version $Id: QueryProcessor.java,v 1.4 2001/09/09 20:55:41 stephenreed Exp $
d84 6
d220 8
d234 5
a238 3
        long endMilliseconds = System.currentTimeMillis();
        if (verbosity > 0)
            System.out.println("  " + (endMilliseconds - startMilliseconds) + " milliseconds");
d244 9
d293 1
a293 1
     * Displays the literals and their binding set.
d295 7
a301 4
    public void displayLiteralsAndBindings() {
        System.out.println("Query Literals and Bindings");
        for (int i = 0; i < queryLiterals.size(); i++) {
            System.out.println(queryLiterals.get(i));
d303 2
@


1.4
log
@Completed first set of unit tests for HashJoiner and QueryProcessor.
@
text
@d12 1
a12 1
 * @@version $Id: QueryProcessor.java,v 1.3 2001/09/07 03:28:15 stephenreed Exp $
d154 1
@


1.3
log
@Beginning unit test cases for query processor.
@
text
@d12 1
a12 1
 * @@version $Id: QueryProcessor.java,v 1.2 2001/09/06 21:43:25 stephenreed Exp $
d209 3
a211 2
            literalAsker = new LiteralAsker();
            literalAsker.ask(queryLiterals, mt);
@


1.2
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d12 1
a12 1
 * @@version $Id: QueryProcessor.java,v 1.1 2001/09/06 14:01:08 stephenreed Exp $
d43 1
a43 1
    protected Backchainer backchainer;
d152 1
d185 1
a185 1
        solution = new Solution(this.nbrSolutionsRequested);
d286 2
a287 1
        solution.setVerbosity(verbosity);
@


1.1
log
@Added queryprocessor package classes.
@
text
@d7 1
d12 1
a12 1
 * @@version $Id: QueryProcessor.java,v 1.23 2001/09/05 22:58:59 stephenreed Exp $
d43 6
a48 1
    protected Backchainer backchainer = new Backchainer(this);
d53 1
a53 1
    protected Solution solution = new Solution(this);
d58 1
a58 1
    public CycConstant mt;
d88 5
d152 1
d171 1
a171 1
     * Solves a query and return a list of solutions if one or more
d181 1
a181 1
    public ArrayList solve(CycList query) {
d184 1
d186 1
a186 1
            if (! queryParser.extractLiterals()) {
d208 2
a209 2
            literalAsker = new LiteralAsker(this);
            literalAsker.ask();
d220 1
a220 1
        return solution.solutions;
d267 4
a270 1
        literalBindings.displayLiteralsAndBindings();
a281 1
        literalBindings.setVerbosity(verbosity);
d296 10
a305 1
        backchainer.setMaxBackchainDepth(maxBackchainDepth);
@

