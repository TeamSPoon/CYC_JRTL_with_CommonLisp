head	1.4;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.3.0.2
	OPENCYC_1_0_1:1.3
	PRE_1_0:1.1;
locks; strict;
comment	@# @;


1.4
date	2006.10.21.16.49.19;	author dmiles;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.18.14.21.31;	author dmiles;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.18.13.36.03;	author dmiles;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.01.15.39.12;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package  org.opencyc.xml;

//// Internal Imports
import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycNart;
import org.opencyc.cycobject.CycObject;
import org.opencyc.cycobject.Guid;
import org.opencyc.util.Log;
import org.opencyc.util.StringUtils;

//// External Imports
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.HashSet;
import java.util.Iterator;
import org.apache.xerces.dom.DocumentImpl;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * OWL (Web Ontology Language) export for OpenCyc.
 *
 * @@version $Id: ExportOwl.java,v 1.20 2005/02/16 21:35:10 reed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2003 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class ExportOwl extends OntologyExport {
 
  //// Constructors
  
  /**
   * Constructs a new ExportOwl object given the CycAccess object.
   *
   * @@param cycAccess The CycAccess object which manages the api connection.
   */
  public ExportOwl(CycAccess cycAccess) {
    super(cycAccess);
  }
  
  //// Public Area
  
  /**
   * The OWL export path and file name.
   */
  public String outputPath = "export.owl";
 
  /**
   * The OWL comment that titles the output file.
   */
  public String title = "Ontology";
  
  
  /** restricts OWL export to either collections, predicates or individuals */
  public String exportCategory = ALL_EXPORT_CATEGORIES;
  
  public static String ALL_EXPORT_CATEGORIES = "all";
  public static String EXPORT_COLLECTION_CATEGORY = "collections";
  public static String EXPORT_PREDICATE_CATEGORY = "predicates";
  public static String EXPORT_INDIVIDUAL_CATEGORY = "individuals";
  
  /**
   * Exports the desired KB content into OWL.
   */
  public void export(int exportCommand) throws UnknownHostException, IOException, CycApiException {
    this.exportCommand = exportCommand;
    setup();
    final CycConstant cycKBSubsetCollection = cycAccess.getConstantByName("CycKBSubsetCollection");
    if (cycKBSubsetCollection != null) {
      allKbSubsetCollections = cycAccess.getAllInstances(cycAccess.getKnownConstantByName("CycKBSubsetCollection"));
      Collections.sort(allKbSubsetCollections);
      if (verbosity > 4)
        Log.current.println("allKbSubsetCollections: " + allKbSubsetCollections.toString());
    }
    if (verbosity > 2)
      Log.current.println("Getting terms from Cyc");
    if (exportCommand == OntologyExport.EXPORT_ENTIRE_KB)
      selectedCycForts = cycAccess.getAllInstances(cycAccess.thing);
    else if ((exportCommand == OntologyExport.EXPORT_KB_SUBSET) || 
             (exportCommand == OntologyExport.EXPORT_RESEARCH_CYC) ||
             (exportCommand == OntologyExport.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
      selectedCycForts = cycAccess.getAllQuotedInstances(cycKbSubsetCollection, cycAccess.inferencePSC);
      if (exportCommand == OntologyExport.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)
        includeUpwardClosure = true;
    }
    else if (exportCommand == OntologyExport.EXPORT_SELECTED_ASSERTIONS)
      prepareSelectedAssertions();
    else if (exportCommand != OntologyExport.EXPORT_SELECTED_TERMS) {
      // EXPORT_KB_SUBSET_BELOW_TERM
      selectedCycForts = cycAccess.getAllSpecs(rootTerm);
      selectedCycForts.add(rootTerm);
    }
    if (verbosity > 2)
      Log.current.println("Selected " + selectedCycForts.size() + " terms");
    if (includeUpwardClosure) {
      upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
      if (verbosity > 2)
        Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " terms");
      selectedCycForts.addAll(upwardClosureCycForts);
      if (verbosity > 2)
        Log.current.println("All selected " + selectedCycForts.size() + " terms");
    }
    int selectedCycForts_size = selectedCycForts.size();
    if (! includeNonAtomicTerms) {
      if (verbosity > 2)
        Log.current.println("Removing positive arity narts.");
      final CycList temp = new CycList();
      for (int i = 0; i < selectedCycForts_size; i++) {
        CycFort selectedCycFort = (CycFort)selectedCycForts.get(i);

        //TODO accept certain narts.

        if (selectedCycFort instanceof CycConstant ||
           (selectedCycFort instanceof CycNart && (((CycNart) selectedCycFort).getArguments().isEmpty())))
          temp.add(selectedCycFort);
        else if (verbosity > 1)
          Log.current.println("dropped NART " + selectedCycFort.cyclify());
      }
      selectedCycForts = temp;
    }
    selectedCycForts_size = selectedCycForts.size();
    sortCycObjects(selectedCycForts);
    if (verbosity > 8) {
      Log.current.println("\nselectedCycForts");
      for (int i = 0; i < selectedCycForts.size(); i++) {
        Log.current.println(((CycObject) selectedCycForts.get(i)).cyclify());
      }
      Log.current.println("");
    }
    if (verbosity > 2) {
      if (exportCommand == EXPORT_RESEARCH_CYC)
        Log.current.println("Partitioning by type.");
      else
        Log.current.println("Removing non-binary properties and partitioning by type.");
    }
    for (int i = 0; i < selectedCycForts_size; i++) {
      CycObject cycObject = (CycObject) selectedCycForts.get(i);
      if (verbosity > 2) {
        if ((verbosity > 5) && (i % 100 == 0))
          Log.current.println("... " + cycObject.cyclify());
      }
      if (cycAccess.isCollection(cycObject)) {
        owlSelectedConstants.add(cycObject);
        if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_COLLECTION_CATEGORY))
          owlSelectedClasses.add(cycObject);
      }
      else if (cycAccess.isUnaryPredicate(cycObject))
        if (exportCommand == EXPORT_RESEARCH_CYC) {
          owlSelectedConstants.add(cycObject);
          if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
            owlSelectedProperties.add(cycObject);
        }
        else
          // Do not export (for now) Cyc unary predicates, as they cannot be easily expressed in OWL.
          continue;
      else if (cycAccess.isBinaryPredicate(cycObject)) {
        owlSelectedConstants.add(cycObject);
        if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
          owlSelectedProperties.add(cycObject);
      }
      else if (cycAccess.isPredicate(cycObject))
        if (exportCommand == EXPORT_RESEARCH_CYC) {
          owlSelectedConstants.add(cycObject);
          if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
            owlSelectedProperties.add(cycObject);
        }
        else
          // Do not export Cyc (for now) arity 3+ predicates, as they cannot be easily expressed in OWL.
          continue;
        else if (cycAccess.isIndividual(cycObject)) {
          owlSelectedConstants.add(cycObject);
          if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_INDIVIDUAL_CATEGORY))
            owlSelectedIndividuals.add(cycObject);
      }
    }

    //createTermNode("PhysicalDevice");
    if (verbosity > 2)
      Log.current.println("Building OWL model");
    
    for (int i = 0; i < owlSelectedClasses.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedClasses.get(i);
      if (verbosity > 2)
        Log.current.print(cycObject + "  Collection");
      createTermNode(cycObject);
    }
    for (int i = 0; i < owlSelectedProperties.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedProperties.get(i);
      if (verbosity > 2)
        Log.current.print(cycObject + "  BinaryPredicate");
      createTermNode(cycObject);
    }
    for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedIndividuals.get(i);
      if (verbosity > 2)
        Log.current.println(cycObject + "  Individual");
      createTermNode(cycObject);
    }
    serializeDocument();
    
    for (int i = 0; i < owlSelectedClasses.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedClasses.get(i);
      if (verbosity > 2)
        Log.current.println(cycObject.cyclify());
    }
    for (int i = 0; i < owlSelectedProperties.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedProperties.get(i);
      if (verbosity > 2)
        Log.current.println(cycObject.cyclify());
    }
    for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
      CycObject cycObject = (CycObject) owlSelectedIndividuals.get(i);
      if (verbosity > 2)
        Log.current.println(cycObject.cyclify());
    }
    
    if (verbosity > 2)
      Log.current.println("OWL export completed");
  }
  
  /**  Creates an RDF node. */
  public void createRdfNode() {
    rdf = document.createElementNS(rdfNamespace, "rdf:RDF");
    rdf.setAttribute("xmlns:rdf", rdfNamespace);
    rdf.setAttribute("xmlns:rdfs", rdfsNamespace);
    rdf.setAttribute("xmlns:owl", owlNamespace);
    rdf.setAttribute("xmlns", cycOwlNamespace);
    document.appendChild(rdf);
  }
  
  /** Creates a OWL Ontology node. */
  public void createOwlOntologyNode() {
    owlOntology = document.createElementNS(owlNamespace, "owl:Ontology");
    owlOntology.setAttribute("rdf:about", "");
    rdf.appendChild(owlOntology);
    owlVersionInfo = document.createElementNS(owlNamespace, "owl:versionInfo");
    owlVersionInfo.appendChild(document.createTextNode("$Id: ExportOwl.java,v 1.20 2005/02/16 21:35:10 reed Exp $"));
    owlOntology.appendChild(owlVersionInfo);
    rdfsComment = document.createElementNS(rdfsNamespace, "rdfs:comment");
    final String titleText = (exportCommand == EXPORT_RESEARCH_CYC) ?
      title + "\n\n" +
      "OpenCyc License Information\n" +
      "The contents of this file constitute portions of The OpenCyc Knowledge\n" +
      "Base. The OpenCyc Knowledge Base is protected under the following license\n" +
      "and copyrights. This license and copyright information must be included\n" +
      "with any copies or derivative works.\n" +
      "\n" +
      "Copyright Information\n" +
      "OpenCyc Knowledge Base Copyright 2001- 2004 - 2005 Cycorp, Inc., Austin, TX, USA.\n" +
      "All rights reserved.\n" +
      "OpenCyc Knowledge Server Copyright 2001- 2004 - 2005 Cycorp, Inc., Austin, TX, USA.\n" +
      "All rights reserved.\n" +
      "Other copyrights may be found in various files.\n" +
      "\n" +
      "The OpenCyc Knowledge Base\n" +
      "The OpenCyc Knowledge Base consists of code, written in the declarative\n" +
      "language CycL, that represents or supports the representation of facts and\n" +
      "rules pertaining to consensus reality. OpenCyc is licensed using the GNU\n" +
      "Lesser General Public License, whose text can also be found on this volume.\n" +
      "The OpenCyc CycL code base is the \"library\" referred to in the LGPL\n" +
      "license. The terms of this license equally apply to renamings and other\n" +
      "logically equivalent reformulations of the Knowledge Base (or portions\n" +
      "thereof) in any natural or formal language.\n" +
      "\n" +
      "See http://www.opencyc.org for more information.\n" : title;
    rdfsComment.appendChild(document.createTextNode(titleText));
    owlOntology.appendChild(rdfsComment);
  }
  
  /** Serializes the OWL document to the XML file. */
  public void serializeDocument() throws IOException {
    if (verbosity > 2)
      Log.current.println("Writing OWL output to " + outputPath);
    OutputFormat outputFormat = new OutputFormat(document, "UTF-8", true);
    BufferedWriter owlOut = new BufferedWriter(new FileWriter(outputPath));
    XMLSerializer xmlSerializer = new XMLSerializer(owlOut, outputFormat);
    xmlSerializer.asDOMSerializer();
    xmlSerializer.serialize(document);
    owlOut.close();
  }
  
  /** Sets the selected Cyc Forts.
   *
   * @@param selectedCycFort the selected Cyc forts
   */
  public void setSelectedCycForts(final CycList selectedCycForts) {
    this.selectedCycForts = selectedCycForts;
  }
  
  /** Sets the list of applicable binary predicates
   *
   * @@param applicableBinaryPredicates the the list of applicable predicates
   */
  public void setApplicableBinaryPredicates(final CycList applicableBinaryPredicates) {
    this.applicableBinaryPredicates = applicableBinaryPredicates;
  }
  
  //// Protected Area
  
  /** Sets up the OWL export process. */
  private void setup() throws UnknownHostException, IOException, CycApiException {
    createRdfNode();
    if (! useResearchCycOntology) {
      createOwlOntologyNode();
      createCycGuidNode();
    }
    
    if (exportCommand == OntologyExport.EXPORT_ENTIRE_KB) {
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting Entire KB subset");
    }
    else if (exportCommand == OntologyExport.EXPORT_KB_SUBSET || exportCommand == OntologyExport.EXPORT_RESEARCH_CYC) {
      cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
      cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
      cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      includeUpwardClosure = true;
      if (verbosity > 1)
        Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() +
        "\n  plus upward closure to #$Thing filtered by " + cycKbSubsetFilter.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_KB_SUBSET_BELOW_TERM) {
      rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
      if (cycKbSubsetFilterGuid != null)
        cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      cycKbSubsetCollection = cycKbSubsetFilter;
      includeUpwardClosure = false;
      if (verbosity > 1) {
        if (cycKbSubsetFilter != null)
          Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() +
            "\n  filtered by " + cycKbSubsetFilter.cyclify());
        else
          Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify());
      }
    }
    else if (exportCommand == OntologyExport.EXPORT_SELECTED_TERMS) {
      cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      cycKbSubsetCollection = cycKbSubsetFilter;
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting selected terms " + selectedCycForts.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_SELECTED_ASSERTIONS) {
      cycKbSubsetFilter = cycKbSubsetFilterGuid == null ? null : cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      cycKbSubsetCollection = cycKbSubsetFilter;
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting selected assertions");
    }
    else {
      System.err.println("Invalid export comand " + exportCommand);
      System.exit(1);
    }
  }
  
  //// Private Area
    
  /** Creates a OWL node for a single Cyc term.
   *
   * @@param cycObject the given term
   */
  private void createTermNode(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    if (cycObject instanceof CycConstant)
      guid = ((CycConstant) cycObject).getGuid();
    populateComment(cycObject);
    populateIsas(cycObject);
    populatePropertyAssertions(cycObject);
    if (cycAccess.isCollection(cycObject))
      createClassNode(cycObject);
    else if (cycAccess.isBinaryPredicate(cycObject))
      createPropertyNode(cycObject);
    else if (cycAccess.isIndividual(cycObject))
      createIndividualNode(cycObject);
    else {
      if (verbosity > 0)
        Log.current.println("Unhandled term: " + cycObject.toString());
    }
  }
  
  /** Creates a OWL class node for a single Cyc collection.
   *
   * @@param cycObject The Cyc collection from which the OWL class node is created.
   */
  protected void createClassNode(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    populateGenls(cycObject);
    if (exportCommand == OntologyExport.EXPORT_RESEARCH_CYC) {
      disjointWiths = null;
      coExtensionals = null;
    }
    else {
      populateDisjointWiths(cycObject);
      populateCoExtensionals(cycObject);
    }
    Element classNode = document.createElementNS(owlNamespace, "owl:Class");
    rdf.appendChild(classNode);
    if (cycObject instanceof CycConstant)
      classNode.setAttributeNS(rdfNamespace, "rdf:ID", xmlName((CycConstant) cycObject));
    else
      classNode.setAttributeNS(rdfNamespace, "rdf:ID", xmlNonAtomicTermName(cycObject));
    if (exportCommand == OntologyExport.EXPORT_RESEARCH_CYC) {
      if (verbosity > 2)
        Log.current.println();
    }
    else {
      Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      String label = null;
      label = cycAccess.getPluralGeneratedPhrase(cycObject);
      if (verbosity > 2)
        Log.current.println("  " + label);
      labelNode.appendChild(document.createTextNode(label));
      classNode.appendChild(labelNode);
    }
    if (comment != null && ! comment.equals("")) {
      Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
      commentNode.appendChild(document.createTextNode(comment));
      classNode.appendChild(commentNode);
    }
    if (guid != null) {
      Element guidNode = document.createElement("guid");
      guidNode.appendChild(document.createTextNode(guid.toString()));
      classNode.appendChild(guidNode);
    }
    Element sameClassAsNode;
    if (cycObject.equals(cycAccess.thing)) {
      sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
      sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlThing);
      classNode.appendChild(sameClassAsNode);
    }
    else if (cycObject.equals(cycAccess.collection)) {
      sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
      sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlClass);
      classNode.appendChild(sameClassAsNode);
    }
    if (isas != null)
      for (int i = 0; i < isas.size(); i++) {
        Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
        typeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(isas.get(i)));
        classNode.appendChild(typeNode);
      }
    if (genls != null)
      for (int i = 0; i < genls.size(); i++) {
        Element subClassNode = document.createElementNS(rdfsNamespace, "rdfs:subClassOf");
        subClassNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(genls.get(i)));
        classNode.appendChild(subClassNode);
      }
    if (disjointWiths != null)
      for (int i = 0; i < disjointWiths.size(); i++) {
        Element disjointWithNode = document.createElementNS(owlNamespace, "owl:disjointWith");
        disjointWithNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(disjointWiths.get(i)));
        classNode.appendChild(disjointWithNode);
      }
    if (coExtensionals != null)
      for (int i = 0; i < coExtensionals.size(); i++) {
        sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
        sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(coExtensionals.get(i)));
        classNode.appendChild(sameClassAsNode);
      }
    createPropertyAssertionNodes(classNode);
  }
  
  /** Creates a property assertions node for the given Element.
   *
   * @@param element The given element.
   */
  private void createPropertyAssertionNodes(Element node)
    throws UnknownHostException, IOException, CycApiException {
    Collections.sort(propertyAssertions, new ExportOwl.CycObjectComparator());
    for (int i = 0; i < propertyAssertions.size(); i++) {
      CycList propertyAssertion = (CycList) propertyAssertions.get(i);
      CycObject property = (CycObject) propertyAssertion.first();
      Object value = propertyAssertion.third();
      Element propertyAssertionNode = 
        document.createElement((property instanceof CycList) ? xmlNonAtomicTermName(property) : property.toString());
      if (value instanceof String || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double)
        propertyAssertionNode.appendChild(document.createTextNode(value.toString()));
      else if (value instanceof CycList && 
               cycAccess.isa((CycList) value, 
                             cycAccess.getKnownConstantByName("Date")))
        propertyAssertionNode.appendChild(document.createTextNode(cycAccess.xmlDatetimeString((CycList) value)));
      else
        propertyAssertionNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(value));
      node.appendChild(propertyAssertionNode);
    }
  }
  
  /** Creates a OWL individual node for a single Cyc individual.
   *
   * @@param cycObject The Cyc individual from which the OWL individual node is created.
   */
  private void createIndividualNode(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    if (isas == null || isas.size() == 0)
      return;
    CycFort isa = bestIsaForIndividual();
    Element individualNode = document.createElement(isa.toString());
    rdf.appendChild(individualNode);
    if (cycObject instanceof CycConstant)
      individualNode.setAttributeNS(rdfsNamespace, "rdf:ID", xmlName((CycConstant) cycObject));
    else
      individualNode.setAttributeNS(rdfsNamespace, "rdf:ID", xmlNonAtomicTermName(cycObject));
    if (exportCommand == EXPORT_RESEARCH_CYC) {
      if (verbosity > 2)
        Log.current.println();
    }
    else {
      Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      String label = cycAccess.getSingularGeneratedPhrase(cycObject);
      if (label.startsWith("Thing ") && cycObject instanceof CycNart)
        label = "some " + cycAccess.getSingularGeneratedPhrase(isa);
      if (verbosity > 2)
        Log.current.println("  " + label);
      labelNode.appendChild(document.createTextNode(label));
      individualNode.appendChild(labelNode);
    }
    if (comment != null && ! comment.equals("")) {
      Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
      commentNode.appendChild(document.createTextNode(comment));
      individualNode.appendChild(commentNode);
    }
    if (guid != null) {
      Element guidNode = document.createElement("guid");
      guidNode.appendChild(document.createTextNode(guid.toString()));
      individualNode.appendChild(guidNode);
    }
    createPropertyAssertionNodes(individualNode);
  }
  
  /** Returns the best isa for the current Individual term.
   *
   * @@return The best isa for the current Individual term.
   */
  private CycConstant bestIsaForIndividual() throws UnknownHostException, IOException, CycApiException {
    CycFort bestIsa = (CycFort) isas.get(0);
    if (isas.size() == 1 && bestIsa instanceof CycConstant)
      return (CycConstant) bestIsa;
    CycList candidateIsas = new CycList();
    for (int i = 0; i < isas.size(); i++) {
      CycFort isa = (CycFort) isas.get(i);
      if (! cycAccess.isQuotedCollection(isa) && isa instanceof CycConstant)
        candidateIsas.add(isa);
    }
    if (candidateIsas.size() == 0)
      return (CycConstant) bestIsa;
    else if (candidateIsas.size() == 1)
      return (CycConstant) candidateIsas.get(0);
    else {
      bestIsa = (CycConstant) cycAccess.getMinCol(candidateIsas);
      if (verbosity > 4)
        Log.current.println("    candidateIsas: " + candidateIsas +
        " best-isa: " + bestIsa);
      return (CycConstant) bestIsa;
    }
  }
  
  
  /** Creates the OWL node that defines the guid property.  Note that there is
   * no rdfs:domain statement because Cyc's guid relationship applies to predicates,
   * collections and individuals, but in OWL properties are not instances of Thing.
   * The absence of the rdfs:domain restriction allows the guid property to be applied
   * to Cyc predicates.
   */
  private void createCycGuidNode() {
    Element propertyNode = document.createElementNS(owlNamespace, "owl:FunctionalProperty");
    rdf.appendChild(propertyNode);
    propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", "guid");
    if (exportCommand != EXPORT_RESEARCH_CYC) {
      Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      labelNode.appendChild(document.createTextNode("guid"));
      propertyNode.appendChild(labelNode);
    }
    Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
    commentNode.appendChild(document.createTextNode(guidComment));
    propertyNode.appendChild(commentNode);
    Element rangeNode = document.createElementNS(owlNamespace, "rdfs:range");
    rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", rdfsLiteral);
    propertyNode.appendChild(rangeNode);
  }
  
  /** Creates a OWL property node for a single Cyc binary predicate.
   *
   * @@param cycObject The Cyc binary predicate from which the OWL property node is created.
   */
  private void createPropertyNode(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    if (cycObject instanceof CycFort)
      populateGenlPreds((CycFort) cycObject);
    else
      genlPreds = new CycList();
    if (exportCommand == this.EXPORT_RESEARCH_CYC) {
      arg1Isa = null;
      arg2Isa = null;
    }
    else {
      populateArg1Isa(cycObject);
      populateArg2Isa(cycObject);
    }
    populateArg1Format(cycObject);
    populateArg2Format(cycObject);
    Element propertyNode;
    if ((arg1Format != null) && arg1Format.equals("SingleEntry"))
      propertyNode = document.createElementNS(owlNamespace, "owl:InverseFunctionalProperty");
    else if ((arg2Format != null) && arg2Format.equals("SingleEntry"))
      propertyNode = document.createElementNS(owlNamespace, "owl:FunctionalProperty");
    else
      propertyNode = document.createElementNS(owlNamespace, "owl:ObjectProperty");
    rdf.appendChild(propertyNode);
    if (cycObject instanceof CycConstant)
      propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", xmlName((CycConstant) cycObject));
    else
      propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", xmlNonAtomicTermName(cycObject));
    if (exportCommand == EXPORT_RESEARCH_CYC) {   
      if (verbosity > 2)
        Log.current.println();
    }
    else {
      Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      String label = null;
      label = cycAccess.getGeneratedPhrase(cycObject);
      if (verbosity > 2)
        Log.current.println("  " + label);
      labelNode.appendChild(document.createTextNode(label));
      propertyNode.appendChild(labelNode);
    }
    if (comment != null && ! comment.equals("")) {
      Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
      commentNode.appendChild(document.createTextNode(comment));
      propertyNode.appendChild(commentNode);
    }
    if (guid != null) {
      Element guidNode = document.createElement("guid");
      guidNode.appendChild(document.createTextNode(guid.toString()));
      propertyNode.appendChild(guidNode);
    }
    if (genlPreds != null)
      for (int i = 0; i < genlPreds.size(); i++) {
        Element subPropertyOfNode = document.createElementNS(owlNamespace, "rdfs:subPropertyOf");
        subPropertyOfNode.setAttributeNS(rdfNamespace, "rdf:resource", "#" + genlPreds.get(i).toString());
        propertyNode.appendChild(subPropertyOfNode);
      }
    if (arg1Isa != null) {
      Element domainNode = document.createElementNS(owlNamespace, "rdfs:domain");
      domainNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg1Isa));
      propertyNode.appendChild(domainNode);
    }
    if (arg2Isa != null) {
      Element rangeNode = document.createElementNS(owlNamespace, "rdfs:range");
      rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg2Isa));
      propertyNode.appendChild(rangeNode);
    }
    createPropertyAssertionNodes(propertyNode);
  }
  
  /** Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   *
   * @@param obj The Cyc term which is to be translated into a kind of OWL node.
   * @@return The kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   */
  private String translateTerm(Object obj) throws UnknownHostException, IOException, CycApiException {
    if (obj.equals(cycAccess.thing))
      return  owlThing;
    else if (obj.equals(cycAccess.collection))
      return  owlClass;
    else if (obj instanceof CycNart || obj instanceof CycList) {
      return "#" + this.xmlNonAtomicTermName((CycObject) obj);
    }
    else
      return  "#" + xmlName((CycConstant) obj);
  }
  
  /** Populates the comment for a Cyc term, or with an empty string if no comment.
   *
   * @@param cycObject The Cyc term for which the comment is obtained.
   */
  private void populateComment(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    final String tempComment = cycAccess.getComment(cycObject);
    if (tempComment == null) {
      comment = null;
      return;
    }
    final StringBuffer stringBuffer = new StringBuffer();
    final int tempComment_length = tempComment.length();
    for (int i = 0; i < tempComment_length; i++) {
      char c = tempComment.charAt(i);
      if (c > 31 && c < 128)
        stringBuffer.append(c);
      else
        stringBuffer.append(' ');
    }
    comment = stringBuffer.toString();
  }
  
  /** Removes terms from the given list which are not elements of cycKbSubsetFilter.
   *
   * @@param constants The given list of constants which is to be filtered.
   * @@return The filtered list.
   */
  private ArrayList applyCycKbSubsetFilter(CycList constants) throws UnknownHostException, IOException, CycApiException{
    if (cycKbSubsetFilter == null)
      return constants;
    if (verbosity > 2)
      Log.current.println("Applying " + cycKbSubsetFilter.cyclify() + " filter");
    if (constants.size() == 0)
      return  constants;
    ArrayList result = new ArrayList();
    for (int i = 0; i < constants.size(); i++) {
      Object object = constants.get(i);
      if ((object instanceof CycConstant) &&
      cycAccess.isQuotedIsa((CycConstant) object, cycKbSubsetFilter))
        result.add(object);
      else if (verbosity > 4)
        Log.current.println(" dropping " + object);
    }
    return  result;
  }
    
  /** Populates the isas for a Cyc term, removing the case where a term is a type of itself.
   *
   * @@param cycObject The Cyc term for which the isas are obtained.
   */
  private void populateIsas(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    if (cycObject instanceof CycList && ((CycList) cycObject).first().toString().equals("InstanceNamedFn")) {
      isas = new CycList();
      isas.add(((CycList) cycObject).third());
    }
    else
      isas = cycAccess.getIsas(cycObject);
    if (isas.contains(cycObject))
      isas.remove(cycObject);
    isas = substituteGenlConstantsForNarts(isas);
    isas = findAllowedTermsOrGenls(isas);
  }
  
  /** Populates the genls for a Cyc term.
   *
   * @@param cycObject The Cyc term for which the genls are obtained.
   */
  private void populateGenls(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    genls = cycAccess.getGenls(cycObject);
    if (genls.contains(cycObject))
      genls.remove(cycObject);
    genls = substituteGenlConstantsForNarts(genls);
    genls = findAllowedTermsOrGenls(genls);
  }
  
  /** Populates the genlPreds for a Cyc predicate.
   *
   * @@param cycFort The Cyc predicate for which the genlPreds are obtained.
   */
  private void populateGenlPreds(CycFort cycFort) throws UnknownHostException, IOException, CycApiException {
    genlPreds = cycAccess.getGenlPreds(cycFort);
    genlPreds = this.filterSelectedConstants(genlPreds);
    genlPreds = substituteGenlConstantsForNarts(genlPreds);
    if (genlPreds.contains(cycAccess.different))
      genlPreds.remove(cycAccess.different);
    
  }
  
  /** Populates the argument 1 type constaint for a Cyc predicate.
   *
   * @@param cycObject The Cyc predicate for which the argument 1 type constaint is obtained.
   */
  private void populateArg1Isa(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    CycList arg1Isas = cycAccess.getArg1Isas(cycObject);
    arg1Isas = substituteGenlConstantsForNarts(arg1Isas);
    arg1Isas = findAllowedTermsOrGenls(arg1Isas);
    if (arg1Isas.size() > 0)
      arg1Isa = (CycConstant)arg1Isas.first();
    else
      arg1Isa = null;
  }
  
  /** Populates the argument 2 type constaint for a Cyc predicate.
   *
   * @@param cycObject The Cyc predicate for which the argument 2 type constaint is obtained.
   */
  private void populateArg2Isa(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    CycList arg2Isas = cycAccess.getArg2Isas(cycObject);
    arg2Isas = substituteGenlConstantsForNarts(arg2Isas);
    arg2Isas = findAllowedTermsOrGenls(arg2Isas);
    if (arg2Isas.size() > 0)
      arg2Isa = (CycConstant)arg2Isas.first();
    else
      arg2Isa = null;
  }
  
  /** Populates the argument 1 format for a Cyc predicate.
   *
   * @@param cycObject The Cyc predicate for which the argument 1 format is obtained.
   */
  private void populateArg1Format(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    CycList arg1Formats = cycAccess.getArg1Formats(cycObject);
    if (arg1Formats.size() > 0)
      arg1Format = (CycConstant)arg1Formats.first();
  }
  
  /**
   * Populates the argument 2 format for a Cyc predicate.
   *
   * @@param cycObject The Cyc predicate for which the argument 2 format is obtained.
   */
  private void populateArg2Format(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    CycList arg2Formats = cycAccess.getArg2Formats(cycObject);
    if (arg2Formats.size() > 0)
      arg2Format = (CycConstant)arg2Formats.first();
  }
  
  /** Populates the disjointWiths for a Cyc collection.
   *
   * @@param cycObject The Cyc collection for which the disjointWiths are obtained.
   */
  private void populateDisjointWiths(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    disjointWiths = cycAccess.getDisjointWiths(cycObject);
    disjointWiths = substituteGenlConstantsForNarts(disjointWiths);
    disjointWiths = findAllowedTermsOrGenls(disjointWiths);
  }
  
  /** Populates the coExtensionals for a Cyc collection.
   *
   * @@param cycObject The Cyc collection for which the coExtensionals are obtained.
   */
  private void populateCoExtensionals(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    try {
      coExtensionals = cycAccess.getCoExtensionals(cycObject);
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    coExtensionals = substituteGenlConstantsForNarts(coExtensionals);
    coExtensionals = findAllowedTermsOrGenls(coExtensionals);
  }
  
  /** Populates the non-definitional ground atomic formulas in which the the
   * predicate is an element of the list of applicable binary predicates and in
   * which the given term appears as the first argument.
   *
   * @@param cycObject The term which appears in the first argument position.
   */
  private void populatePropertyAssertions(CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    CycList candidatePropertyAssertions = null;
    propertyAssertions = new CycList();
    if (termsWithNoExtraProperties.contains(cycObject)) {
      if (verbosity > 8)
        Log.current.println("      term with no extra properties: " + cycObject.cyclify());
      return;
    }
    try {
      final CycObject canonicalizedObject = (CycObject) cycAccess.getHLCycTerm(cycObject.cyclify());
      candidatePropertyAssertions = cycAccess.getGafs(canonicalizedObject, applicableBinaryPredicates);
    if (verbosity > 8)
      Log.current.println("      candidatePropertyAssertions: " + candidatePropertyAssertions.cyclify());
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    candidatePropertyAssertions.remove(cycAccess.isa);
    candidatePropertyAssertions.remove(cycAccess.genls);
    for (int i = 0; i < candidatePropertyAssertions.size(); i++) {
      CycList candidatePropertyAssertion = (CycList) candidatePropertyAssertions.get(i);
      if (candidatePropertyAssertion.third() instanceof CycFort) {
        if (cycKbSubsetCollection == null || cycAccess.isQuotedIsa((CycFort) candidatePropertyAssertion.third(), cycKbSubsetCollection)) {
          propertyAssertions.add(candidatePropertyAssertion);
          if (verbosity > 2)
            Log.current.println("      " + candidatePropertyAssertion.cyclify());
        }
        else if (verbosity > 8)
            Log.current.println("      quoted " + ((CycFort) candidatePropertyAssertion.third()).cyclify() + " is not a " + cycKbSubsetCollection.cyclify());
      }
      else if (verbosity > 8)
          Log.current.println("      " + candidatePropertyAssertion.cyclify() + " is not a CycFort");
    }
  }
  
  /** Returns an XML compliant name for the given term.
   *
   * @@param cycConstant the given term
   * @@return an XML compliant name for the given term
   */
  public String xmlName(final CycConstant cycConstant) {
    String xmlName = cycConstant.toString();
    if (Character.isDigit(xmlName.charAt(0)))
      xmlName = "N_" + xmlName;
    return xmlName;
  }
  
  /** Returns an XML compliant name for the given non-atomic term.
   *
   * @@param nonAtomicTerm the given non-atomic term
   * @@return an XML compliant name for the given non-atomic term
   */
  public String xmlNonAtomicTermName(final CycObject nonAtomicTerm)
    throws UnknownHostException, IOException, CycApiException {
    String xmlName = cycAccess.getGeneratedPhrase(nonAtomicTerm);
    xmlName = xmlName.replace(' ', '_');
    xmlName = xmlName.replace('"', '_');
    xmlName = xmlName.replace('\'', '_');
    xmlName = StringUtils.change(xmlName, ",", "");
    xmlName = StringUtils.change(xmlName, "{", "");
    xmlName = StringUtils.change(xmlName, "}", "");
    xmlName = StringUtils.change(xmlName, "#$", "");
    return xmlName;
  }
  
  //// Internal Rep
  
  private static final String xmlNamespace = "http://www.w3.org/XML/1998/namespace";
  private static final String rdfNamespace = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  private static final String rdfsNamespace = "http://www.w3.org/2000/01/rdf-schema#";
  private static final String owlNamespace = "http://www.w3.org/2002/07/owl#";
  private static final String cycOwlNamespace = "http://www.cyc.com/2004/06/04/cyc#";
  private static final String owlThing = "http://www.w3.org/2002/07/owl#Thing";
  private static final String owlProperty = "http://www.w3.org/2002/07/owl#Property";
  private static final String owlTransitiveProperty = "http://www.w3.org/2002/07/owl#TransitiveProperty";
  private static final String owlClass = "http://www.w3.org/2002/07/owl#Class";
  private static final String rdfsType = "http://www.w3.org/2000/01/rdf-schema#type";
  private static final String rdfsLiteral = "http://www.w3.org/2000/01/rdf-schema#Literal";
  private static final String guidComment = "Permanent Global Unique ID for the associated concept.";
  
  private final Document document = new DocumentImpl();
  private String documentUrl = null;
  private Element rdf = null;
  private Element owlOntology = null;
  private Element owlVersionInfo = null;
  private Element rdfsComment = null;
  private Guid guid;
  private final ArrayList owlSelectedConstants = new ArrayList();
  private String comment;
  private CycList isas;
  private CycList genls;
  private CycList genlPreds;
  private CycConstant arg1Isa;
  private CycConstant arg2Isa;
  private CycConstant arg1Format;
  private CycConstant arg2Format;
  private CycList disjointWiths;
  private CycList coExtensionals;
  private CycList propertyAssertions;
  private final ArrayList owlSelectedClasses = new ArrayList();
  private final ArrayList owlSelectedProperties = new ArrayList();
  private final ArrayList owlSelectedIndividuals = new ArrayList();
  private CycList allKbSubsetCollections;
  
}



@


1.3
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@a5 1
import org.opencyc.api.CycObjectFactory;
a10 2
import org.opencyc.cycobject.CycVariable;
import org.opencyc.cycobject.ELMt;
d12 1
a13 1
import org.opencyc.util.UUID;
a16 2
import java.io.CharArrayWriter;
import java.io.File;
a22 3
import java.util.Enumeration;
import java.util.EventListener;
import java.util.EventObject;
a23 1
import java.util.HashMap;
a25 6
import java.util.Set;
import java.util.Vector;
import java.util.logging.Logger;
import com.bbn.semweb.owl.vowlidator.Validator;
import com.bbn.semweb.owl.vowlidator.ValidatorAPI;
import com.bbn.semweb.owl.vowlidator.indications.Indication;
d35 1
a35 1
 * @@version $Id: ExportOwl.java,v 1.74 2006/03/07 21:43:00 reed Exp $
d38 1
a38 1
 * <p>Copyright (c) 2003 - 2006 Cycorp, Inc., license is open source GNU LGPL.
d57 1
a57 1
  
d65 1
a65 11
  public ExportOwl(final CycAccess cycAccess) {
    this(cycAccess, null);
  }
  
  /**
   * Constructs a new ExportOwl object given the CycAccess object.
   *
   * @@param cycAccess The CycAccess object which manages the api connection.
   * @@param uuid the given identifier that is returned with each progress event notification
   */
  public ExportOwl(final CycAccess cycAccess, final UUID uuid) {
a66 1
    this.uuid = uuid;
d75 1
a75 1
  
d81 1
a84 3
  /** the indicator for whether to export qualificed cardinality restrictions */
  public boolean exportQualifiedCardinalityRestrictions = false;
  
a89 41
  /** Returns the exportable content for the given term and list of selectedTerms.
   *
   * @@param term the term for which exportable content is to be presented
   * @@param selectedCycForts the list of all selected terms which may appear in exportable content
   * @@param isExportLimitedToOpenCycContent the indicator that the OWL export should be limited to OpenCyc content
   */
  public String exportableContent(final CycFort term, 
                                  final CycList selectedCycForts, 
                                  final boolean isExportLimitedToOpenCycContent) throws Exception {
    //// Preconditions
    assert selectedCycForts != null : "selectedCycForts must not be null";
    
    this.selectedCycForts = selectedCycForts;
    this.isExportLimitedToOpenCycContent = isExportLimitedToOpenCycContent;
    selectedCycForts.addNew(term);
    exportCommand = OntologyExport.EXPORT_SELECTED_TERMS;
    cycKbSubsetFilter = cycKbSubsetFilterGuid == null ? null : cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
    cycKbSubsetCollection = cycKbSubsetFilter;
    logger.info("Obtaining exportable content for " + term.cyclify());
    initializeMappingDictionary();
    ensureSelectedTermsAreReified();
    partitionSelectedTermsByType();
    createRdfNode();
    createTermNode(term);
    final OutputFormat outputFormat = new OutputFormat(document, "UTF-8", true);
    final CharArrayWriter charArrayWriter = new CharArrayWriter();
    final BufferedWriter owlOut = new BufferedWriter(charArrayWriter);
    final XMLSerializer xmlSerializer = new XMLSerializer(owlOut, outputFormat);
    xmlSerializer.asDOMSerializer();
    xmlSerializer.serialize(document);
    owlOut.close();
    final String exportableContent = charArrayWriter.toString();
    logger.info("exportable content:\n" + exportableContent);
    
    //// Postconditions
    assert exportableContent != null : "exportableContent must not be null";
    assert exportableContent.length() > 0 : "exportableContent must not be an empty string";
    
    return exportableContent;
  }
  
d93 1
a93 1
  public void export(final int exportCommand) throws Exception {
a94 9
    logger.info("inferenceMt: " + inferenceMt.toString());
    if (areRulesExported)
      logger.info("Rules will be exported in SWRL");
    if (isExportLimitedToOpenCycContent)
      logger.info("Export is limited to OpenCyc content");
    //cycAccess.traceOn();
    reportProgress(percentProgress, null, false);
    if (isCancelled)
      return;
d98 1
a98 1
      allKbSubsetCollections = cycAccess.getAllInstances(cycKBSubsetCollection);
d100 2
a101 5
      logger.finer("allKbSubsetCollections: " + allKbSubsetCollections.toString());
    }
    if (isCancelled) {
      cleanUp();
      return;
d103 2
a104 1
    logger.info("Getting terms from Cyc");
d107 1
a107 1
    else if ((exportCommand == OntologyExport.EXPORT_KB_SUBSET) ||
d110 1
a110 1
      selectedCycForts = cycAccess.getAllQuotedInstances(cycKbSubsetCollection, inferenceMt);
d118 1
a118 1
      selectedCycForts = cycAccess.getAllSpecs(rootTerm, inferenceMt);
d121 2
a122 8
    if (isCancelled) {
      cleanUp();
      return;
    }
    logger.info("Selected " + selectedCycForts.size() + " terms");
    percentProgress += 1.0d;
    reportProgress(percentProgress, null, false);
    ensureSelectedTermsAreReified();
d125 2
a126 5
      if (isCancelled) {
        cleanUp();
        return;
      }
      logger.info("Upward closure added " + upwardClosureCycForts.size() + " terms");
d128 2
a129 8
      logger.info("All selected " + selectedCycForts.size() + " terms");
      percentProgress += 5.0d;
      reportProgress(percentProgress, null, false);
    }
    
    if (isCancelled) {
      cleanUp();
      return;
d131 1
d133 2
a134 1
      logger.info("Removing positive arity narts.");
d136 10
a145 6
      for (int i = 0; i < selectedCycForts.size(); i++) {
        final CycObject cycObject = (CycObject) selectedCycForts.get(i);
        if (cycObject instanceof CycConstant ||
           (cycObject instanceof CycNart && (((CycNart) cycObject).getArguments().isEmpty())))
          temp.add(cycObject);
        logger.info("dropped term " + cycObject.cyclify());
d149 1
a149 1
    selectedCycForts = omitTermsWithoutComments(selectedCycForts);
d151 4
a154 10
    logger.info("\nselectedCycForts");
    for (int i = 0; i < selectedCycForts.size(); i++)
      logger.info(((CycObject) selectedCycForts.get(i)).cyclify());
    logger.info("");
    partitionSelectedTermsByType();
    final double PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS = 2.0;
    if (includeDerivedNarts) {
      if (isCancelled) {
        cleanUp();
        return;
d156 13
a168 8
      logger.info("Adding derived narts");
      gatherSubcollectionOfWithRelationFromFns();
      owlSelectedClasses.addAllNew(subcollectionOfWithRelationFromFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
d170 4
a173 7
      gatherSubcollectionOfWithRelationToFns();
      owlSelectedClasses.addAllNew(subcollectionOfWithRelationToFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
d175 13
a187 7
      gatherSubcollectionOfWithRelationFromTypeFns();
      owlSelectedClasses.addAllNew(subcollectionOfWithRelationFromTypeFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
d189 13
a201 7
      gatherSubcollectionOfWithRelationToTypeFns();
      owlSelectedClasses.addAllNew(subcollectionOfWithRelationToTypeFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
d203 6
a208 24
      gatherCollectionIntersection2Fns();
      owlSelectedClasses.addAllNew(collectionIntersection2Fns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
      }
      gatherCollectionIntersectionFns();
      owlSelectedClasses.addAllNew(collectionIntersectionFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
      if (isCancelled) {
        cleanUp();
        return;
      }
      gatherCollectionUnionFns();
      owlSelectedClasses.addAllNew(collectionUnionFns);
      percentProgress += PERCENT_PROGRESS_INCREMENT_FOR_DERIVED_NARTS;
      reportProgress(percentProgress, null, false);
    }
    populatePercentProgressDictionary();
    logger.info("Building OWL model");
    long startTimeMillis = System.currentTimeMillis();
d210 3
a212 6
      if (isCancelled) {
        cleanUp();
        return;
      }
      final CycObject cycObject = (CycObject) owlSelectedClasses.get(i);
      logger.info(cycObject.toString() + "  Collection");
a214 5
    if (! owlSelectedClasses.isEmpty())
      logger.fine("Exported " + owlSelectedClasses.size() + " classes at with an average duration of " +
                  ((System.currentTimeMillis() - startTimeMillis) / owlSelectedClasses.size()) +
                  " milliseconds each");
    startTimeMillis = System.currentTimeMillis();
d216 3
a218 21
      if (isCancelled) {
        cleanUp();
        return;
      }
      final CycObject cycObject = (CycObject) owlSelectedProperties.get(i);
      logger.info(cycObject.toString() + "  BinaryPredicate");
      createTermNode(cycObject);
    }
    if (! owlSelectedProperties.isEmpty())
      logger.fine("Exported " + owlSelectedProperties.size() + " properties at with an average duration of " +
                  ((System.currentTimeMillis() - startTimeMillis) / owlSelectedProperties.size()) +
                  " milliseconds each");
    startTimeMillis = System.currentTimeMillis();
    sortCycObjects(inversePredicates);
    for (int i = 0; i < inversePredicates.size(); i++) {
      if (isCancelled) {
        cleanUp();
        return;
      }
      final CycObject cycObject = (CycObject) inversePredicates.get(i);
      logger.info(cycObject.toString() + "  inverse BinaryPredicate");
d222 3
a224 6
      if (isCancelled) {
        cleanUp();
        return;
      }
      final CycObject cycObject = (CycObject) owlSelectedIndividuals.get(i);
      logger.info(cycObject.toString() + "  Individual");
a226 8
    if (! owlSelectedIndividuals.isEmpty())
      logger.fine("Exported " + owlSelectedIndividuals.size() + " individuals at with an average duration of " +
                  ((System.currentTimeMillis() - startTimeMillis) / owlSelectedIndividuals.size()) +
                  " milliseconds each");
    if (! owlSelectedIndividuals.isEmpty() && (! isExportLimitedToOpenCycContent))
      createAllDifferentNode();
    if (! rules.isEmpty())
      createRuleNodes();
d228 5
a232 4
    displayExportedTerms();
    if (isCancelled) {
      cleanUp();
      return;
d234 4
a237 33
    final String validationReport = validateOWLExport();
    cleanUp();
    reportProgress(100, validationReport, true);
    logger.info("OWL export completed");
  }
  
  /** Executes the Vowlidator application to validate the exported OWL file.
   *
   * @@return the string of validation messages
   */
  public String validateOWLExport() throws Exception {
    //// Preconditions
    assert outputPath != null : "outputPath must not be null";
    assert outputPath.length() > 0 : "outputPath must not be an empty string";
    
    if (areRulesExported)
      return "The Vowlidator feature is not available when rules are contained in the OWL export.";

    String indicationStrings = null;
    if ((new File("preferences.xml")).exists()) {
      logger.fine("Validating OWL file at " + outputPath);
      logger.fine("Working directory " + System.getProperty("user.dir"));

      final String[] args = {outputPath};
      final ValidatorAPI validatorAPI = new ValidatorAPI(args);
      final StringBuffer stringBuffer = new StringBuffer(10000);
      final Vector indications = validatorAPI.run(false);
      for (final Enumeration indications_enum = indications.elements(); indications_enum.hasMoreElements(); ) {
        final Indication indication = (Indication) indications_enum.nextElement();
        stringBuffer.append(indication.toString());
        stringBuffer.append('\n');
      }
      indicationStrings = stringBuffer.toString();
d239 4
a242 2
    else {
      indicationStrings = "The Vowlidator feature is not available with Java Web Start";
a243 1
    logger.fine(indicationStrings);
d245 63
a307 5
    //// Postconditions
    assert indicationStrings != null : "indicationStrings must not be null";
    assert indicationStrings.length() > 0 : "indicationStrings must not be an empty string";
    
    return indicationStrings;
a314 3
    //// Preconditions
    assert selectedCycForts != null : "selectedCycForts must not be null";
    
a322 3
    //// Preconditions
    assert applicableBinaryPredicates != null : "applicableBinaryPredicates must not be null";
    
a325 296
  /** Sets the output path for the OWL export file.
   *
   * @@param outputPath the output path for the OWL export file
   */
  public void setOutputPath(final String outputPath) {
    this.outputPath = outputPath;
  }
  
  /** Sets the inference microtheory.
   *
   * @@param inferenceMt the inference microtheory
   */
  public void setInferenceMt(final ELMt inferenceMt) {
    this.inferenceMt = inferenceMt;
  }
  
  /** Sets the license text.
   *
   * @@param licenseText the license text
   */
  public void setLicenseText(final String licenseText) {
    this.licenseText = licenseText;
  }
  
  /** Sets the indicator that the OWL export should be limited to OpenCyc content.
   *
   * @@param isExportLimitedToOpenCycContent the indicator that the OWL export should be limited to OpenCyc content
   */
  public void setIsExportLimitedToOpenCycContent(final boolean isExportLimitedToOpenCycContent) {
    this.isExportLimitedToOpenCycContent = isExportLimitedToOpenCycContent;
  }
 
  /** Sets the indicator that the OWL export should include rules in SWRL (Semantic Web Rule Language).
   *
   * @@param areRulesExported the indicator that the OWL export should include rules in SWRL (Semantic Web Rule Language)
   */
  public void setAreRulesExported(final boolean areRulesExported) {
    this.areRulesExported = areRulesExported;
  }

  /** Returns an XML compliant name for the given non-atomic term.
   *
   * @@param nonAtomicTerm the given non-atomic term
   * @@return an XML compliant name for the given non-atomic term
   */
  public String xmlNonAtomicTermName(final CycObject nonAtomicTerm)
  throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert nonAtomicTerm != null : "nonAtomicTerm must not be null";
    
    final CycList natFormula = (nonAtomicTerm instanceof CycNart) ? ((CycNart) nonAtomicTerm).toDeepCycList() : (CycList) nonAtomicTerm;
    String xmlName = (String) nartXMLNames.get(natFormula.toString());
    logger.finest("      natFormula: " + ((List) natFormula).toString() + " xmlName: " + xmlName);
    if (xmlName != null)
      return xmlName;
    xmlName = cycAccess.getGeneratedPhrase(nonAtomicTerm);
    if (xmlName.indexOf("</") > -1)
      xmlName = stripHTMLTags(xmlName);
    xmlName = xmlName.replace('-', '_');
    xmlName = xmlName.replace(' ', '_');
    xmlName = xmlName.replace('"', '_');
    xmlName = xmlName.replace('\'', '_');
    xmlName = StringUtils.change(xmlName, "?", "");
    xmlName = StringUtils.change(xmlName, ",", "");
    xmlName = StringUtils.change(xmlName, "{", "");
    xmlName = StringUtils.change(xmlName, "}", "");
    xmlName = StringUtils.change(xmlName, "#$", "");
    xmlName = StringUtils.change(xmlName, "#<(", "_");
    xmlName = StringUtils.change(xmlName, ")>", "_");
    if (xmlName.indexOf('_') == -1)
      xmlName = xmlName + "_";
    if (! cycAccess.isPredicate(nonAtomicTerm, inferenceMt))
      xmlName = xmlName.substring(0, 1).toUpperCase() + xmlName.substring(1);
    if (nartXMLNames.containsValue(xmlName))
      xmlName = xmlName + "_" + xmlNameSequence++;
    assert ! nartXMLNames.containsValue(xmlName) : "duplicate name for " + nonAtomicTerm.toString() + " which is " + xmlName;
    nartXMLNames.put(natFormula.toString(), xmlName);
    
    //// Postconditions
    assert xmlName != null : "xmlName must not be null";
    assert xmlName.length() > 0 : "xmlName must not be an empty string";
    
    return xmlName;
  }
  
  /** Strips HTML format tags from the given string. 
   *
   * @@param string the given string
   * @@return the given string stripped of HTML tags
   */
  private String stripHTMLTags(final String string) {
    if (string == null)
      throw new NullPointerException("string must not be null");
    
    if (string.length() < 3)
      return string;
    final StringBuffer stringBuffer = new StringBuffer(string.length());
    boolean withinHTMLTag = false;
    for (int i = 0; i < string.length(); i++) {
      final char c = string.charAt(i);
      if (c == '<')
        withinHTMLTag = true;
      else if (c == '>')
        withinHTMLTag = false;
      else if (! withinHTMLTag)
        stringBuffer.append(c);
    }
    return stringBuffer.toString();
  }
  
  /** Adds an OWL export progress listener.
   *
   * @@param owlExportProgressEventListener a listener for OWL export progress events
   */
  public synchronized void addListener(final OWLExportProgressEventListener owlExportProgressEventListener) {
    //// Preconditions
    if (owlExportProgressEventListener == null)
      throw new IllegalArgumentException("owlExportProgressEventListener must not be null");
    if (listeners.contains(owlExportProgressEventListener))
      throw new IllegalArgumentException("listener must not be currently registered");
    assert listeners != null : "listeners must not be null";
    
    listeners.add(owlExportProgressEventListener);
    logger.fine("added an OWL export progress listener");
  }
  
  /** Removes an OWL export progress listener.
   *
   * @@param owlExportProgressEventListener a listener for OWL export progress events
   */
  public synchronized void removeListener(final OWLExportProgressEventListener owlExportProgressEventListener) {
    //// Preconditions
    if (owlExportProgressEventListener == null)
      throw new IllegalArgumentException("owlExportProgressEventListener must not be null");
    assert listeners != null : "listeners must not be null";
    
    listeners.remove(owlExportProgressEventListener);
    logger.fine("removed an OWL export progress listener");
  }
  
  /** Class that provides an OWL export progress notification event. */
  public class OWLExportProgressEventObject extends EventObject {
    
    /** Constructs a new OWLExportProgressEventObject instance.
     *
     * @@param source the object on which the Event initially occurred
     * @@param owlExportProgressEventInfo the OWL export progress event information
     */
    public OWLExportProgressEventObject(final Object source, final OWLExportProgressEventInfo owlExportProgressEventInfo) {
      super(source);
      //// Preconditions
      if (owlExportProgressEventInfo == null)
        throw new IllegalArgumentException("owlExportProgressEventInfo must not be null");
      
      this.owlExportProgressEventInfo = owlExportProgressEventInfo;
    }
    
    /** Returns a string representation of this object.
     *
     * @@return a string representation of this object
     */
    public String toString() {
      return "OWLExportProgressEventObject (" + owlExportProgressEventInfo.toString() + ")";
    }
    
    public OWLExportProgressEventInfo getOWLExportProgressEventInfo() {
      return owlExportProgressEventInfo;
    }
    
    final OWLExportProgressEventInfo owlExportProgressEventInfo;
  }
  
  /** This class contains OWL Export progress event information. */
  public class OWLExportProgressEventInfo {
    /** the identifier for this OWL export */
    final UUID uuid;
    
    /** the OWL export percent complete */
    final private double percentComplete;
    
    /** the OWL export output path */
    final private String outputPath;
    
    /** the output from the Vowlidator */
    final private String validationReport;
    
    /** the indicator that the OWL export is done */
    final private boolean isDone;
    
    /** Creates a new OWLExportProgressEventInfo instance.
     *
     * @@param uuid the identifier for this OWL export
     * @@param percentComplete the OWL export percent complete
     * @@param outputPath the OWL export output path
     * @@param validationReport the output from the Vowlidator
     * @@param isDone the indicator that the OWL export is done
     */
    public OWLExportProgressEventInfo(final UUID uuid,
    final double percentComplete,
    final String outputPath,
    final String validationReport,
    final boolean isDone) {
      //// Preconditions
      if (uuid == null)
        throw new NullPointerException("uuid must be not be null");
      if (percentComplete < 0.0d || percentComplete > 100.0d)
        throw new IllegalArgumentException("percentComplete must be in the range [0 ... 100]");
      if (outputPath == null)
        throw new NullPointerException("outputPath must be not be null");
      if (outputPath.length() == 0)
        throw new IllegalArgumentException("outputPath must be not be an empty string");
      if (isDone && validationReport == null)
        throw new NullPointerException("validationReport must be not be null");
      if (isDone && validationReport.length() == 0)
        throw new NullPointerException("validationReport must be not be an empty string");
      
      this.uuid = uuid;
      this.percentComplete = percentComplete;
      this.outputPath = outputPath;
      this.validationReport = validationReport;
      this.isDone = isDone;
    }
    
    /** Gets the identifier for this OWL export.
     *
     * @@return the identifier for this OWL export
     */
    public UUID getUUID() {
      return uuid;
    }
    
    /** Gets the OWL export percent complete.
     *
     * @@return the OWL export percent complete
     */
    public double getPercentComplete() {
      return percentComplete;
    }
    
    /** Gets the OWL export output path.
     *
     * @@return the OWL export output path
     */
    public String getOutputPath() {
      return outputPath;
    }
    
    /** Gets the output from the Vowlidator.
     *
     * @@return the output from the Vowlidator, or null if the export is not done
     */
    public String getValidationReport() {
      return validationReport;
    }
    
    /** Returns the indicator that the OWL export is done.
     *
     * @@return the indicator that the OWL export is done
     */
    public boolean isDone() {
      return isDone;
    }
    
    /** Returns a string representation of this object.
     *
     * @@return a string representation of this object
     */
    public String toString() {
      final StringBuffer stringBuffer = new StringBuffer(1000);
      stringBuffer.append("[OWLExportProgressEventInfo %done=");
      stringBuffer.append(percentComplete);
      stringBuffer.append(", outputPath=");
      stringBuffer.append(outputPath);
      stringBuffer.append(", isDone=");
      stringBuffer.append(isDone);
      if (validationReport != null) {
        final int sampleLength = (validationReport.length() > 100) ? 100 : validationReport.length();
        stringBuffer.append(", validationReport=");
        stringBuffer.append(validationReport.substring(0, sampleLength));
        stringBuffer.append("...");
      }
      stringBuffer.append("]");
      return stringBuffer.toString();
    }
  }
  
  /** Defines the interface for OWL export progress event listeners. */
  public interface OWLExportProgressEventListener extends EventListener {
    
    /** Notifies the listener of the given OWL export progress event.
     *
     * @@param evt the OWL export progress event
     */
    void notifyOWLExportProgressEvent(OWLExportProgressEventObject evt);
  };
  
a327 32
  /** Reports OWL export progress to each of the listeners.
   *
   * @@param percentComplete the OWL export percent complete
   * @@param validationReport the output from the Vowlidator
   * @@param isDone the indicator that the OWL export is done
   */
  protected void reportProgress(final double percentComplete) {
    //// Preconditions
    assert percentComplete >= 0.0d && percentComplete <= 100.0d : "percentComplete must be in the range [0 ... 100]";
    assert percentComplete >= previouslyReportedPercentComplete : "percentComplete " + percentComplete + " must not be less than the previously reported value " + previouslyReportedPercentComplete;
    
    reportProgress(percentComplete, null, false);
  }
  
  //// Private Area
  
  /** Serializes the OWL document to the XML file. */
  private void serializeDocument() throws IOException {
    //// Preconditions
    assert document != null : "document must not be null";
    assert outputPath != null : "outputPath must not be null";
    assert outputPath.length() > 0 : "outputPath must not be an empty string";
    
    logger.fine("Writing OWL output to " + outputPath);
    final OutputFormat outputFormat = new OutputFormat(document, "UTF-8", true);
    final BufferedWriter owlOut = new BufferedWriter(new FileWriter(outputPath));
    final XMLSerializer xmlSerializer = new XMLSerializer(owlOut, outputFormat);
    xmlSerializer.asDOMSerializer();
    xmlSerializer.serialize(document);
    owlOut.close();
  }
  
a329 5
    //// Preconditions
    assert document != null : "document must not be null";
    
    initializeMappingDictionary();
    initializeProblemStores();
a330 1
    createOwlOntologyNode();
d332 2
a333 4
      createDefinitionalFunctionalPropertyNode("guid", "globally unique identifier", guidComment);
      createDefinitionalFunctionalPropertyNode("externalID", "external identifier", externalIDComment);
      createDefinitionalFunctionalPropertyNode("nonAtomicFormula", "non-atomic formula", nonAtomicFormulaComment);
      createDefinitionalFunctionalPropertyNode("literalValue", "literal value", literalValueComment);
d338 2
a339 1
      logger.info("Exporting Entire KB subset");
d344 2
a345 1
      logger.info("Exporting KB subset " + cycKbSubsetCollection.cyclify());
d351 3
a353 2
      logger.info("Exporting KB subset " + cycKbSubsetCollection.cyclify() +
      "\n  plus upward closure to #$Thing filtered by " + cycKbSubsetFilter.cyclify());
d361 7
a367 5
      if (cycKbSubsetFilter != null)
        logger.info("Exporting KB collections below root term " + rootTerm.cyclify() +
        "\n  filtered by " + cycKbSubsetFilter.cyclify());
      else
        logger.info("Exporting KB collections below root term " + rootTerm.cyclify());
d370 1
a370 1
      cycKbSubsetFilter = cycKbSubsetFilterGuid == null ? null : cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
d372 3
a374 1
      logger.info("Exporting selected terms " + selectedCycForts.cyclify());
d380 2
a381 1
      logger.info("Exporting selected assertions");
d389 1
a389 11
  /** Cleans up the OWL export process. */
  private void cleanUp() throws UnknownHostException, IOException, CycApiException {
    destroyProblemStores();    
  }

  /** Partitions the selected terms by type */
  private void partitionSelectedTermsByType() throws Exception {
    //// Preconditions
    assert selectedCycForts != null : "selectedCycForts must not be null";
    assert ! selectedCycForts.isEmpty() : "selectedCycForts must not be empty";
    assert cycAccess != null : "cycAccess must not be null";
d391 19
a409 16
    if (exportCommand != EXPORT_RESEARCH_CYC) {
      // Do not export Cyc (for now) arity 3+ predicates, as they cannot be easily expressed in OWL.
      logger.info("Removing non-binary properties");
      final CycList tempSelectedCycForts = new CycList(selectedCycForts.size());
      for (int i = 0; i < selectedCycForts.size(); i++) {
        final CycObject cycObject = (CycObject) selectedCycForts.get(i);
        if (cycAccess.isPredicate(cycObject, inferenceMt)) {
          if (cycAccess.isBinaryPredicate(cycObject, inferenceMt))
            tempSelectedCycForts.add(cycObject);
          else
            logger.info("  Dropping " + cycObject.toString());
        }
        else
          tempSelectedCycForts.add(cycObject);
      }
      selectedCycForts = tempSelectedCycForts;
a410 94
    logger.info("Partitioning by type.");
    for (int i = 0; i < selectedCycForts.size(); i++) {
      if (isCancelled)
        return;
      final CycObject cycObject = (CycObject) selectedCycForts.get(i);
      if (cycAccess.isCollection(cycObject, inferenceMt)) {
        owlSelectedConstants.add(cycObject);
        if (exportCommand != EXPORT_RESEARCH_CYC ||
        exportCategory.equals(ALL_EXPORT_CATEGORIES) ||
        exportCategory.equals(EXPORT_COLLECTION_CATEGORY))
          owlSelectedClasses.add(cycObject);
      }
      else if (cycAccess.isUnaryPredicate(cycObject, inferenceMt)) {
        if (exportCommand == EXPORT_RESEARCH_CYC) {
          owlSelectedConstants.add(cycObject);
          if (exportCategory.equals(ALL_EXPORT_CATEGORIES) ||
          exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
            owlSelectedProperties.add(cycObject);
        }
        else
          // Do not export (for now) Cyc unary predicates, as they cannot be easily expressed in OWL.
          continue;
      }
      else if (cycAccess.isBinaryPredicate(cycObject, inferenceMt)) {
        owlSelectedConstants.add(cycObject);
        if (exportCommand != EXPORT_RESEARCH_CYC ||
            exportCategory.equals(ALL_EXPORT_CATEGORIES) ||
            exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
          owlSelectedProperties.add(cycObject);
      }
      else if (cycAccess.isPredicate(cycObject, inferenceMt)) {
        if (exportCommand == EXPORT_RESEARCH_CYC) {
          owlSelectedConstants.add(cycObject);
          if (exportCategory.equals(ALL_EXPORT_CATEGORIES) || exportCategory.equals(EXPORT_PREDICATE_CATEGORY))
            owlSelectedProperties.add(cycObject);
        }
        else
          // Do not export Cyc (for now) arity 3+ predicates, as they cannot be easily expressed in OWL.
          continue;
      }
      else if (cycAccess.isIndividual(cycObject, inferenceMt)) {
        owlSelectedConstants.add(cycObject);
        if (exportCommand != EXPORT_RESEARCH_CYC ||
            exportCategory.equals(ALL_EXPORT_CATEGORIES) ||
            exportCategory.equals(EXPORT_INDIVIDUAL_CATEGORY))
          owlSelectedIndividuals.add(cycObject);
      }
    }
    theSetOfOWLSelectedClasses = new CycList(owlSelectedClasses.size() + 1);
    theSetOfOWLSelectedClasses.add(cycAccess.getKnownConstantByName("TheSet"));
    theSetOfOWLSelectedClasses.addAll(owlSelectedClasses);
    theSetOfOWLSelectedIndividuals = new CycList(owlSelectedIndividuals.size() + 1);
    theSetOfOWLSelectedIndividuals.add(cycAccess.getKnownConstantByName("TheSet"));
    theSetOfOWLSelectedIndividuals.addAll(owlSelectedIndividuals);
    applicableBinaryPredicates = owlSelectedProperties;
  }
  
  /** Creates a OWL node for a single Cyc term.
   *
   * @@param cycObject the given term
   */
  private void createTermNode(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    guid = null;
    externalID = null;
    comment = null;
    label = null;
    nonAtomicFormula = null;
    if (cycObject instanceof CycConstant)
      guid = ((CycConstant) cycObject).getGuid();
    else {
      externalID = cycAccess.getExternalIDString(cycObject);
      nonAtomicFormula = cycObject.toString();
    }
    populateComment(cycObject);
    populateIsas(cycObject);
    if (! isExportLimitedToOpenCycContent) {
      if (areRulesExported)
        populateRules(cycObject);
      populatePropertyAssertions(cycObject);
    }
    if (cycAccess.isCollection(cycObject, inferenceMt))
      createClassNode(cycObject);
    else if (cycAccess.isBinaryPredicate(cycObject, inferenceMt))
      createPropertyNode(cycObject);
    else if (cycAccess.isIndividual(cycObject, inferenceMt))
      createIndividualNode(cycObject);
    else
      logger.info("Unhandled term: " + cycObject.toString());
    final Double percentProgressDouble = (Double) percentProgressDictionary.get(cycObject);
    if (percentProgressDouble != null)
      reportProgress(percentProgressDouble.doubleValue(), null, false);
d415 1
a415 137
   * @@param collection The Cyc collection from which the OWL class node is created.
   */
  private void createClassNode(final CycObject collection) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert collection != null : "collection must not be null";
    assert rdfNode != null : "rdfNode must not be null";
    assert document != null : "document must not be null";

    if (PROBLEM_STORE_REUSE) {
      allQueriesProblemStoreName = UUID.randomUUID().toString();
      cycAccess.initializeNamedInferenceProblemStore(allQueriesProblemStoreName, null);
    }
    final Element classNode = document.createElementNS(owlNamespace, "owl:Class");
    rdfNode.appendChild(classNode);
    if (collection instanceof CycConstant) {
      createClassNodeCommon(collection, classNode, true);
      if (PROBLEM_STORE_REUSE)
        cycAccess.destroyInferenceProblemStoreByName(allQueriesProblemStoreName);
      return;
    }
    final CycFort symmetricBinaryPredicate = cycAccess.getKnownConstantByName("SymmetricBinaryPredicate");
    final CycFort function = ((CycNart) collection).getFunctor();
    if (function.equals(cycAccess.getKnownConstantByName("SubcollectionOfWithRelationFromFn"))) {
      createClassNodeCommon(collection, classNode, false);
      final CycNart subcollectionOfWithRelationFromFn = (CycNart) collection;
      final CycObject predicate = (CycObject) subcollectionOfWithRelationFromFn.getArguments().get(1);
      if (! cycAccess.isa(predicate, symmetricBinaryPredicate, inferenceMt)) {
        final CycObject collection1 = (CycObject) subcollectionOfWithRelationFromFn.getArguments().get(0);
        final Object thing = subcollectionOfWithRelationFromFn.getArguments().get(2);
        if (selectedCycForts.contains(predicate) && (! (thing instanceof CycObject) || selectedCycForts.contains(thing))) {
          final Element intersectionOfNode = document.createElementNS(owlNamespace, "owl:intersectionOf");
          intersectionOfNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
          final Element subcollectionClassNode = document.createElementNS(owlNamespace, "owl:Class");
          subcollectionClassNode.setAttributeNS(rdfNamespace, "rdf:about", translateTermWithClassMapping(collection1));
          final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
          final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
          final CycFort inversePredicate = new CycNart(cycAccess.getKnownConstantByName("InverseBinaryPredicateFn"), predicate);
          addInversePredicate(inversePredicate);
          onPropertyNode.setAttributeNS(rdfsNamespace, "rdf:resource", "#" + xmlNonAtomicTermName(inversePredicate));
          final Element hasValueNode = document.createElementNS(owlNamespace, "owl:hasValue");
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(thing));
          restrictionNode.appendChild(onPropertyNode);
          restrictionNode.appendChild(hasValueNode);
          intersectionOfNode.appendChild(subcollectionClassNode);
          intersectionOfNode.appendChild(restrictionNode);
          classNode.appendChild(intersectionOfNode);
        }
      }
    }
    else if (function.equals(cycAccess.getKnownConstantByName("SubcollectionOfWithRelationToFn"))) {
      createClassNodeCommon(collection, classNode, false);
      final CycNart subcollectionOfWithRelationToFn = (CycNart) (CycNart) collection;
      final CycObject predicate = (CycObject) subcollectionOfWithRelationToFn.getArguments().get(1);
      if (! cycAccess.isa(predicate, symmetricBinaryPredicate, inferenceMt)) {
        final CycObject collection1 = (CycObject) subcollectionOfWithRelationToFn.getArguments().get(0);
        final Object thing = subcollectionOfWithRelationToFn.getArguments().get(2);
        if (selectedCycForts.contains(predicate) && (! (thing instanceof CycObject) || selectedCycForts.contains(thing))) {
          final Element intersectionOfNode = document.createElementNS(owlNamespace, "owl:intersectionOf");
          intersectionOfNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
          final Element subcollectionClassNode = document.createElementNS(owlNamespace, "owl:Class");
          subcollectionClassNode.setAttributeNS(rdfNamespace, "rdf:about", translateTermWithClassMapping(collection1));
          final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
          final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
          onPropertyNode.setAttributeNS(rdfsNamespace, "rdf:resource", translateTermWithPropertyMapping(predicate));
          final Element hasValueNode = document.createElementNS(owlNamespace, "owl:hasValue");
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(thing));
          restrictionNode.appendChild(onPropertyNode);
          restrictionNode.appendChild(hasValueNode);
          intersectionOfNode.appendChild(subcollectionClassNode);
          intersectionOfNode.appendChild(restrictionNode);
          classNode.appendChild(intersectionOfNode);
        }
      }
    }
    else if (function.equals(cycAccess.getKnownConstantByName("SubcollectionOfWithRelationFromTypeFn"))) {
      createClassNodeCommon(collection, classNode, false);
      final CycNart subcollectionOfWithRelationFromTypeFn = (CycNart) collection;
      final CycObject predicate = (CycObject) subcollectionOfWithRelationFromTypeFn.getArguments().get(1);
      if (! cycAccess.isa(predicate, symmetricBinaryPredicate, inferenceMt)) {
        final CycObject collection1 = (CycObject) subcollectionOfWithRelationFromTypeFn.getArguments().get(0);
        final CycObject collection2 = (CycObject) subcollectionOfWithRelationFromTypeFn.getArguments().get(2);
        if (selectedCycForts.contains(predicate) && selectedCycForts.contains(collection2)) {
          final Element intersectionOfNode = document.createElementNS(owlNamespace, "owl:intersectionOf");
          intersectionOfNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
          final Element subcollectionClassNode = document.createElementNS(owlNamespace, "owl:Class");
          subcollectionClassNode.setAttributeNS(rdfNamespace, "rdf:about", translateTermWithClassMapping(collection1));
          final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
          final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
          final CycFort inversePredicate = new CycNart(cycAccess.getKnownConstantByName("InverseBinaryPredicateFn"), predicate);
          addInversePredicate(inversePredicate);
          onPropertyNode.setAttributeNS(rdfsNamespace, "rdf:resource", "#" + xmlNonAtomicTermName(inversePredicate));
          final Element hasValueNode = document.createElementNS(owlNamespace, "owl:hasValue");
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(collection2));
          restrictionNode.appendChild(onPropertyNode);
          restrictionNode.appendChild(hasValueNode);
          intersectionOfNode.appendChild(subcollectionClassNode);
          intersectionOfNode.appendChild(restrictionNode);
          classNode.appendChild(intersectionOfNode);
        }
      }
    }
    else if (function.equals(cycAccess.getKnownConstantByName("SubcollectionOfWithRelationToTypeFn"))) {
      createClassNodeCommon(collection, classNode, false);
      final CycNart subcollectionOfWithRelationToTypeFn = (CycNart) collection;
      final CycObject predicate = (CycObject) subcollectionOfWithRelationToTypeFn.getArguments().get(1);
      if (! cycAccess.isa(predicate, symmetricBinaryPredicate, inferenceMt)) {
        final CycObject collection1 = (CycObject) subcollectionOfWithRelationToTypeFn.getArguments().get(0);
        final CycObject collection2 = (CycObject) subcollectionOfWithRelationToTypeFn.getArguments().get(2);
        if (selectedCycForts.contains(predicate) && selectedCycForts.contains(collection2)) {
          final Element intersectionOfNode = document.createElementNS(owlNamespace, "owl:intersectionOf");
          intersectionOfNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
          final Element subcollectionClassNode = document.createElementNS(owlNamespace, "owl:Class");
          subcollectionClassNode.setAttributeNS(rdfNamespace, "rdf:about", translateTermWithClassMapping(collection1));
          final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
          final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
          onPropertyNode.setAttributeNS(rdfsNamespace, "rdf:resource", translateTermWithPropertyMapping(predicate));
          final Element hasValueNode = document.createElementNS(owlNamespace, "owl:hasValue");
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(collection2));
          restrictionNode.appendChild(onPropertyNode);
          restrictionNode.appendChild(hasValueNode);
          intersectionOfNode.appendChild(subcollectionClassNode);
          intersectionOfNode.appendChild(restrictionNode);
          classNode.appendChild(intersectionOfNode);
        }
      }
    }
    else
      createClassNodeCommon(collection, classNode, true);
    if (PROBLEM_STORE_REUSE)
      cycAccess.destroyInferenceProblemStoreByName(allQueriesProblemStoreName);
  }
  
  /** Creates common sub-nodes for a OWL class node and a single Cyc collection.
   *
   * @@param collection The Cyc collection from which the OWL class node is created.
   * @@param classNode the class node
   * @@param createTypeAndSubclass the indicator for whether to create the type and subClass nodes
d417 2
a418 8
  private void createClassNodeCommon(final CycObject collection, final Element classNode, final boolean createTypeAndSubclass)
  throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert collection != null : "collection must not be null";
    assert classNode != null : "classNode must not be null";
    
    if (createTypeAndSubclass)
      populateGenls(collection);
a421 1
      restrictions = null;
d424 2
a425 29
      restrictions = new ArrayList();
      if (! isExportLimitedToOpenCycContent) {
        populateDisjointWiths(collection);
        populateCoExtensionals(collection);
        populateInterArgIsa1_2s(collection);
        populateInterArgIsa2_1s(collection);
        populateRelationAllOnly(collection);
        populateRelationOnlyAll(collection);
        populateRelationAllExists(collection);
        populateRelationExistAlls(collection);
        populateTypeGenls(collection);
        populateRelationAllInstances(collection);
        populateRelationInstanceAlls(collection);
        populateRelationInstanceExists(collection);
        populateRelationExistsInstance(collection);
        populateRelationAllExistsCounts(collection);
        populateRelationAllExistMaxs(collection);
        populateRelationAllExistMins(collection);
        populateRelationExistsCountAlls(collection);
        populateRelationExistsMinAlls(collection);
        populateRelationExistsMaxAlls(collection);
        //populateRelationExistsAllMany(collection);
        populateArg2Cardinalities(collection);
        populateInterArgCardinalities1_2(collection);
        populateInterArgCardinalities2_1(collection);
        populateInterArgFormats1_2(collection);
        populateInterArgFormats2_1(collection);
        populateCompletelyAssertedCollectionInstances(collection);
      }
d427 4
a430 2
    if (collection instanceof CycConstant)
      classNode.setAttributeNS(rdfNamespace, "rdf:ID", xmlName((CycConstant) collection));
d432 1
a432 1
      classNode.setAttributeNS(rdfNamespace, "rdf:ID", xmlNonAtomicTermName(collection));
d434 12
a445 1
      logger.fine("");
d447 9
a455 10
    else
      label = cycAccess.getPluralGeneratedPhrase(collection);
    createCommonNodes(classNode);
    if (owlClassMappingDictionary.containsKey(collection)) {
      final String mappedConcept = (String) owlClassMappingDictionary.get(collection);
      if (mappedConcept.startsWith("owl:")) {
        final Element sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
        sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", mappedConcept);
        classNode.appendChild(sameClassAsNode);
      }
d457 10
a466 13
    if (createTypeAndSubclass) {
      if (isas != null)
        for (int i = 0; i < isas.size(); i++) {
          final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
          typeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(isas.get(i)));
          classNode.appendChild(typeNode);
        }
      if (genls != null)
        for (int i = 0; i < genls.size(); i++) {
          final Element subClassNode = document.createElementNS(rdfsNamespace, "rdfs:subClassOf");
          subClassNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(genls.get(i)));
          classNode.appendChild(subClassNode);
        }
d468 12
d482 2
a483 2
        final Element disjointWithNode = document.createElementNS(owlNamespace, "owl:disjointWith");
        disjointWithNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(disjointWiths.get(i)));
d488 2
a489 2
        final Element sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
        sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(coExtensionals.get(i)));
d492 1
a492 303
    if (restrictions != null)
      createRestrictions(classNode);
    if (completelyAssertedCollectionInstances != null && ! completelyAssertedCollectionInstances.isEmpty()) {
      final Element oneOfNode = document.createElementNS(owlNamespace, "owl:oneOf");
      oneOfNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
      for (int i = 0; i < completelyAssertedCollectionInstances.size(); i++) {
        final CycObject instance = (CycObject) completelyAssertedCollectionInstances.get(i);
        final Element instanceNode = document.createElement(collection.toString());
        instanceNode.setAttributeNS(rdfNamespace, "rdf:about", translateTerm(instance));
        oneOfNode.appendChild(instanceNode);
      }
      classNode.appendChild(oneOfNode);
    }
    if (! isExportLimitedToOpenCycContent)
      createPropertyAssertionNodes(classNode);
  }
  
  /** Creates a OWL individual node for a single Cyc individual.
   *
   * @@param cycObject The Cyc individual from which the OWL individual node is created.
   */
  private void createIndividualNode(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    assert document != null : "document must not be null";
    
    if (isas == null || isas.isEmpty())
      return;
    restrictions = new ArrayList();
    final CycFort isa = bestIsaForIndividual();
    isas.remove(isa);
    String isaString = translateTermWithMapping(isa);
    if (isaString.startsWith("#"))
      isaString = isaString.substring(1);
    Element individualNode;
    try {
      if (isaString.startsWith(owlNamespace)) {
        isaString = "owl:" + isaString.substring(owlNamespace.length());
        individualNode = document.createElementNS(owlNamespace, isaString);
      }
      else
        individualNode = document.createElement(isaString);
    }
    catch (Exception e) {
      logger.warning("Bypassing term " + cycObject.cyclify() + " having bad isa name " + isaString);
      return;
    }
    rdfNode.appendChild(individualNode);
    final String owlNameString = (cycObject instanceof CycConstant) ? xmlName((CycConstant) cycObject) : xmlNonAtomicTermName(cycObject);
    individualNode.setAttributeNS(rdfsNamespace, "rdf:ID", owlNameString);
    final IndividualNodeInfo individualNodeInfo = new IndividualNodeInfo(isaString, owlNameString);
    individualNodeInfoDictionary.put(cycObject, individualNodeInfo);
    if (exportCommand == EXPORT_RESEARCH_CYC)
      logger.fine("");
    else {
      label = cycAccess.getSingularGeneratedPhrase(cycObject);
      if (label.startsWith("Thing ") && cycObject instanceof CycNart)
        label = "some " + cycAccess.getSingularGeneratedPhrase(isa);
      populateEquals(cycObject);
      populateRelationInstanceAlls(cycObject);
      populateRelationInstanceExists(cycObject);
      populateRelationExistsInstance(cycObject);
    }
    createCommonNodes(individualNode);
    for (int i = 0; i < isas.size(); i++) {
      final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
      typeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(isas.get(i)));
      individualNode.appendChild(typeNode);
    }
    if (equals != null)
      for (int i = 0; i < equals.size(); i++) {
        final CycObject equalTerm = (CycObject) equals.get(i);
        final Element sameAsNode = document.createElementNS(owlNamespace, "owl:sameAs");
        sameAsNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(equalTerm));
        individualNode.appendChild(sameAsNode);
      }
    if (createdIndividualValues.containsKey(cycObject)) {
      final Object thing = createdIndividualValues.get(cycObject);
      assert thing != null : "thing must not be null for " + cycObject.toString();
      createLiteralValueNode(individualNode, thing);
    }
    if (restrictions != null)
      createRestrictions(individualNode);
    if (! isExportLimitedToOpenCycContent)
      createPropertyAssertionNodes(individualNode);
  }
  
  /** Creates the subnodes common to class, property and individual nodes.
   *
   * @@param parentNode the parent node
   */
  private void createCommonNodes(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
    createLabelNode(parentNode);
    createCommentNode(parentNode);
    createGuidNode(parentNode);
    createExternalIDNode(parentNode);
    createNonAtomicFormulaNode(parentNode);
  }
  
  /** Creates the restriction nodes for the parent class or individual node.
   *
   * @@param parentNode the parent class or individual node
   */
  private void createRestrictions(final Element parentNode) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    assert restrictions != null : "restrictions must not be null";
    
    Collections.sort(restrictions);
    for (int i = 0; i < restrictions.size(); i++) {
      final Restriction restriction = (Restriction) restrictions.get(i);
      Element typeOrSubClassNode;
      if (restriction.restrictionType == SUBCLASS_RESTRICTION)
        typeOrSubClassNode = document.createElementNS(rdfsNamespace, "rdfs:subClassOf");
      else
        typeOrSubClassNode = document.createElementNS(rdfNamespace, "rdf:type");
      parentNode.appendChild(typeOrSubClassNode);
      final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
      typeOrSubClassNode.appendChild(restrictionNode);
      final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
      if (restriction.isInverseProperty) {
        final CycFort inversePredicate =
          new CycNart(cycAccess.getKnownConstantByName("InverseBinaryPredicateFn"), restriction.property);
        addInversePredicate(inversePredicate);
        onPropertyNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithPropertyMapping(inversePredicate));
      }
      else
        onPropertyNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithPropertyMapping(restriction.property));
      restrictionNode.appendChild(onPropertyNode);
      boolean valueNodeCreated = false;
      if (restriction.hasValue != null) {
        final Element hasValueNode = document.createElementNS(owlNamespace, "owl:hasValue");
        if (restriction.hasValue instanceof CycObject)
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(restriction.hasValue));
        else {
          hasValueNode.setAttributeNS(rdfNamespace, "rdf:datatype", xmlSchemaDatatype(restriction.hasValue));
          hasValueNode.appendChild(document.createTextNode(restriction.hasValue.toString()));
        }
        restrictionNode.appendChild(hasValueNode);
        valueNodeCreated = true;
      }
      else if (restriction.valuesFrom != null) {
        final Element valuesFromNode = document.createElementNS(owlNamespace, "owl:valuesFrom");
        valuesFromNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(restriction.valuesFrom));
        restrictionNode.appendChild(valuesFromNode);
        valueNodeCreated = true;
      }
      else if (restriction.allValuesFrom != null) {
        final Element allValuesFromNode = document.createElementNS(owlNamespace, "owl:allValuesFrom");
        allValuesFromNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(restriction.allValuesFrom));
        restrictionNode.appendChild(allValuesFromNode);
        valueNodeCreated = true;
      }
      else if (restriction.someValuesFrom != null) {
        final Element someValuesFromNode = document.createElementNS(owlNamespace, "owl:someValuesFrom");
        someValuesFromNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(restriction.someValuesFrom));
        restrictionNode.appendChild(someValuesFromNode);
        valueNodeCreated = true;
      }
      if (! valueNodeCreated || exportQualifiedCardinalityRestrictions) {
        if (restriction.cardinality > -1) {
          final Element cardinalityNode = document.createElementNS(owlNamespace, "owl:cardinality");
          cardinalityNode.setAttributeNS(rdfNamespace, "rdf:datatype", xsdInt);
          cardinalityNode.appendChild(document.createTextNode(Integer.toString(restriction.cardinality)));
          restrictionNode.appendChild(cardinalityNode);
        }
        else if (restriction.maxCardinality > -1) {
          final Element cardinalityNode = document.createElementNS(owlNamespace, "owl:maxCardinality");
          cardinalityNode.setAttributeNS(rdfNamespace, "rdf:datatype", xsdInt);
          cardinalityNode.appendChild(document.createTextNode(Integer.toString(restriction.maxCardinality)));
          restrictionNode.appendChild(cardinalityNode);
        }
        else if (restriction.minCardinality > -1) {
          final Element cardinalityNode = document.createElementNS(owlNamespace, "owl:minCardinality");
          cardinalityNode.setAttributeNS(rdfNamespace, "rdf:datatype", xsdInt);
          cardinalityNode.appendChild(document.createTextNode(Integer.toString(restriction.minCardinality)));
          restrictionNode.appendChild(cardinalityNode);
        }
      }
    }
  }
  
  /** Reports OWL export progress to each of the listeners.
   *
   * @@param percentComplete the OWL export percent complete
   * @@param validationReport the output from the Vowlidator
   * @@param isDone the indicator that the OWL export is done
   */
  private void reportProgress(final double percentComplete, final String validationReport, final boolean isDone) {
    //// Preconditions
    assert percentComplete >= 0.0d && percentComplete <= 100.0d : "percentComplete must be in the range [0 ... 100]";
    assert percentComplete >= previouslyReportedPercentComplete : "percentComplete " + percentComplete + " must not be less than the previously reported value " + previouslyReportedPercentComplete;
    assert ! isDone || validationReport != null : "validationReport must be not be null";
    assert ! isDone || validationReport.length() > 0 : "validationReport must be not be an empty string";
    assert listeners != null : "listeners must not be null";
    
    if (listeners.isEmpty())
      return;
    final OWLExportProgressEventInfo owlExportProgressEventInfo =
    new OWLExportProgressEventInfo(uuid, percentComplete, outputPath, validationReport, isDone);
    final OWLExportProgressEventObject owlExportProgressEventObject = new OWLExportProgressEventObject(this, owlExportProgressEventInfo);
    for (int i = 0; i < listeners.size(); i++) {
      final OWLExportProgressEventListener owlExportProgressEventListener = (OWLExportProgressEventListener) listeners.get(i);
      logger.finest("notifying listener");
      owlExportProgressEventListener.notifyOWLExportProgressEvent(owlExportProgressEventObject);
    }
    previouslyReportedPercentComplete = percentComplete;
  }
  
  /**  Creates an RDF node. */
  private void createRdfNode() {
    //// Preconditions
    assert document != null : "document must not be null";
    
    rdfNode = document.createElementNS(rdfNamespace, "rdf:RDF");
    rdfNode.setAttribute("xmlns:xsd", xsdNamespace);
    rdfNode.setAttribute("xmlns:rdf", rdfNamespace);
    rdfNode.setAttribute("xmlns:rdfs", rdfsNamespace);
    rdfNode.setAttribute("xmlns:owl", owlNamespace);
    rdfNode.setAttribute("xmlns", cycOwlNamespace);
    rdfNode.setAttribute("xml:base", cycOwlXMLBase);
    document.appendChild(rdfNode);
  }
  
  /** Creates a OWL Ontology node. */
  private void createOwlOntologyNode() {
    //// Preconditions
    assert document != null : "document must not be null";
    
    owlOntologyNode = document.createElementNS(owlNamespace, "owl:Ontology");
    owlOntologyNode.setAttribute("rdf:about", "");
    rdfNode.appendChild(owlOntologyNode);
    owlVersionInfo = document.createElementNS(owlNamespace, "owl:versionInfo");
    owlVersionInfo.appendChild(document.createTextNode("$Id: ExportOwl.java,v 1.74 2006/03/07 21:43:00 reed Exp $"));
    owlOntologyNode.appendChild(owlVersionInfo);
    rdfsCommentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
    final String titleText = (exportCommand == EXPORT_RESEARCH_CYC) ?
      title + "\n\n" +
      "OpenCyc License Information\n" +
      "The contents of this file constitute portions of The OpenCyc Knowledge\n" +
      "Base. The OpenCyc Knowledge Base is protected under the following license\n" +
      "and copyrights. This license and copyright information must be included\n" +
      "with any copies or derivative works.\n" +
      "\n" +
      "Copyright Information\n" +
      "OpenCyc Knowledge Base Copyright (c) 2001 - 2006 Cycorp, Inc., Austin, TX, USA.\n" +
      "All rights reserved.\n" +
      "OpenCyc Knowledge Server Copyright (c) 2001 - 2006 Cycorp, Inc., Austin, TX, USA.\n" +
      "All rights reserved.\n" +
      "Other copyrights may be found in various files.\n" +
      "\n" +
      "The OpenCyc Knowledge Base\n" +
      "The OpenCyc Knowledge Base consists of code, written in the declarative\n" +
      "language CycL, that represents or supports the representation of facts and\n" +
      "rules pertaining to consensus reality. OpenCyc is licensed using the GNU\n" +
      "Lesser General Public License, whose text can also be found on this volume.\n" +
      "The OpenCyc CycL code base is the \"library\" referred to in the LGPL\n" +
      "license. The terms of this license equally apply to renamings and other\n" +
      "logically equivalent reformulations of the Knowledge Base (or portions\n" +
      "thereof) in any natural or formal language.\n" +
      "\n" +
      "See http://www.opencyc.org for more information.\n" : title;
    rdfsCommentNode.appendChild(document.createTextNode(titleText));
    owlOntologyNode.appendChild(rdfsCommentNode);
    if (licenseText == null)
      return;
    final Element rdfsLicenseNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
    rdfsLicenseNode.appendChild(document.createTextNode(licenseText));
    owlOntologyNode.appendChild(rdfsLicenseNode);
  }
  
  /** Returns the XML Schema datatype for the given thing.
   *
   * @@param thing the value
   */
  protected String xmlSchemaDatatype(final Object thing) {
    //// Preconditions
    assert thing != null : "thing must not be null";
    
    String xsdType = null;
    if (thing instanceof Long || thing instanceof Integer) {
      if (((Number) thing).longValue() >= 0)
        xsdType = xsdNonNegativeInteger;
      else
        xsdType = xsdInteger;
    }
    else if (thing instanceof Float || thing instanceof Double) {
      xsdType = xsdDouble;
    }
    else if (thing instanceof String) {
      xsdType = xsdString;
    }
    else
      throw new RuntimeException("Unhandled XML Schema value " + thing.toString());
    
    //// Postconditions
    assert xsdType != null : "xsdType must not be null";
    assert xsdType.length() > 0 : "xsdType must not be an empty string";
    
    return xsdType;
d499 1
a499 1
  private void createPropertyAssertionNodes(final Element node)
d501 1
a501 6
    //// Preconditions
    assert node != null : "node must not be null";
    assert document != null : "document must not be null";
    assert propertyAssertions != null : "propertyAssertions must not be null";
    
    Collections.sort(propertyAssertions, new CycObjectComparator());
d503 4
a506 4
      final CycList propertyAssertion = (CycList) propertyAssertions.get(i);
      final CycObject property = (CycObject) propertyAssertion.first();
      final Object value = propertyAssertion.third();
      final Element propertyAssertionNode =
d510 3
a512 4
      else if (value instanceof CycList &&
               cycAccess.isa((CycList) value,
               cycAccess.getKnownConstantByName("Date"),
               inferenceMt))
d515 1
a515 1
        propertyAssertionNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(value));
d519 2
a520 2

  /** Creates the label node for the given parent.
d522 1
a522 1
   * @@param parentNode the parent node
d524 16
a539 6
  private void createLabelNode(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
    if (label != null && label.length() > 0) {
      final Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
d541 5
a545 1
      logger.fine("  " + label);
d547 1
a547 1
      parentNode.appendChild(labelNode);
a548 10
  }
  
  /** Creates the comment node for the given parent.
   *
   * @@param parentNode the parent node
   */
  private void createCommentNode(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
d550 1
a550 1
      final Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
d552 1
a552 1
      parentNode.appendChild(commentNode);
a553 10
  }
  
  /** Creates the guid node for the given parent.
   *
   * @@param parentNode the parent node
   */
  private void createGuidNode(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
d555 1
a555 1
      final Element guidNode = document.createElement("guid");
d557 1
a557 31
      parentNode.appendChild(guidNode);
    }
  }
  
  /** Creates the external ID node for the given parent.
   *
   * @@param parentNode the parent node
   */
  private void createExternalIDNode(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
    if (externalID != null) {
      final Element externalIDNode = document.createElement("externalID");
      externalIDNode.appendChild(document.createTextNode(externalID));
      parentNode.appendChild(externalIDNode);
    }
  }
  
  /** Creates the nonAtomicFormula node if the given parent is a not-atomic term.
   *
   * @@param parentNode the parent node
   */
  private void createNonAtomicFormulaNode(final Element parentNode) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
    if (nonAtomicFormula != null) {
      final Element nonAtomicFormulaNode = document.createElement("nonAtomicFormula");
      nonAtomicFormulaNode.appendChild(document.createTextNode(nonAtomicFormula));
      parentNode.appendChild(nonAtomicFormulaNode);
d559 1
a559 14
  }
  
  /** Creates the literalVaule node of the given parent created-individual node.
   *
   * @@param parentNode the parent node
   * @@param thing the literal value
   */
  private void createLiteralValueNode(final Element parentNode, final Object thing) {
    //// Preconditions
    assert parentNode != null : "parentNode must not be null";
    
    final Element literalValueNode = document.createElement("literalValue");
    literalValueNode.appendChild(document.createTextNode(thing.toString()));
    parentNode.appendChild(literalValueNode);
a566 4
    //// Preconditions
    assert isas != null : "isas must not be null";
    assert ! isas.isEmpty() : "isas must not be empty";
    
d570 1
a570 1
    final CycList candidateIsas = new CycList();
d573 1
a573 1
      if (! allKbSubsetCollections.contains(isa) && isa instanceof CycConstant)
d581 4
a584 3
      bestIsa = (CycConstant) cycAccess.getMinCol(candidateIsas, inferenceMt);
      logger.finer("    candidateIsas: " + candidateIsas +
                   " best-isa: " + bestIsa);
a588 35
  /** Creates a OWL AllDifferent node for the exported Cyc individuals. */
  private void createAllDifferentNode() throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert owlSelectedIndividuals != null : "owlSelectedIndividuals must not be null";
    assert ! owlSelectedIndividuals.isEmpty() : "owlSelectedIndividuals must not be empty";
    assert individualNodeInfoDictionary.size() == owlSelectedIndividuals.size() :
      "individualNodeInfoDictionary size (" + individualNodeInfoDictionary.size() +
      ") not equal to owlSelectedIndividuals size (" + owlSelectedIndividuals.size() + ")";
    assert rdfNode != null : "rdfNode must not be null";
      
    if ((owlSelectedIndividuals.size() - nonDifferentIndividuals.size()) < 2)
      // do not create an allDifferent node with one child
      return;
    logger.fine("Creating AllDifferent");
    final Element allDifferentNode = document.createElementNS(owlNamespace, "owl:AllDifferent");
    final Element distinctMembersNode = document.createElementNS(owlNamespace, "owl:distinctMembers");
    distinctMembersNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
    for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
      final CycObject individual = (CycObject) owlSelectedIndividuals.get(i);
      if (nonDifferentIndividuals.contains(individual))
        continue;
      final IndividualNodeInfo individualNodeInfo = (IndividualNodeInfo) individualNodeInfoDictionary.get(individual);
      assert individualNodeInfo != null : "individualNodeInfo must not be null for " + individual.toString();
      logger.info("  " + individualNodeInfo.isaString + " " + individualNodeInfo.owlNameString);
      Element individualNode;
      if (individualNodeInfo.isaString.startsWith("owl:"))
        individualNode = document.createElementNS(owlNamespace, individualNodeInfo.isaString);
      else
        individualNode = document.createElement(individualNodeInfo.isaString);
      individualNode.setAttributeNS(rdfNamespace, "rdf:about", "#" + individualNodeInfo.owlNameString);
      distinctMembersNode.appendChild(individualNode);
    }
    allDifferentNode.appendChild(distinctMembersNode);
    rdfNode.appendChild(allDifferentNode);
  }
d590 15
a604 65
  /** Creates all rule nodes. */
  private void createRuleNodes()
    throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert document != null : "document must not be null";
    
    // first pass over the rules gathers all the variables
    final CycList variables = new CycList();
    Iterator rules_iter = rules.iterator();
    while (rules_iter.hasNext()) {
      final CycList rule = (CycList) rules_iter.next();
      final CycList antecedant = (CycList) rule.second();
      final CycList antecedantLiterals;
      if (CycAccess.and.equals(antecedant.first()))
        antecedantLiterals = (CycList) antecedant.rest();
      else {
        antecedantLiterals = new CycList(1);
        antecedantLiterals.add(antecedant);
      }
      final int antecedantLiterals_size = antecedantLiterals.size();
      for (int i = 0; i < antecedantLiterals_size; i++) {
        final CycList antecedantLiteral = (CycList) antecedantLiterals.get(i);
        gatherVariablesFromLiteral(antecedantLiteral, variables);
      }
      final CycList consequentLiteral = (CycList) rule.third();
      gatherVariablesFromLiteral(consequentLiteral, variables);
    }
    logger.fine("Creating variables");
    Collections.sort(variables);
    final int variables_size = variables.size();
    for (int i = 0; i < variables_size; i++) {
      final Element variableNode = document.createElementNS(swrlNamespace, "swrl:Variable");
      final CycVariable variable = (CycVariable) variables.get(i);
      final String variableName = variableName(variable);
      variableNode.setAttributeNS(rdfNamespace, "rdf:ID", variableName);
      rdfNode.appendChild(variableNode);
    }
    // second pass over the rules creates the rule nodes
    logger.fine("Creating rules");
    rules_iter = rules.iterator();
    while (rules_iter.hasNext()) {
      final Element impNode = document.createElementNS(rulemlNamespace, "ruleml:Imp");
      final CycList rule = (CycList) rules_iter.next();
      final CycList antecedant = (CycList) rule.second();
      final CycList consequentLiteral = (CycList) rule.third();
      final CycList antecedantLiterals;
      if (CycAccess.and.equals(antecedant.first()))
        antecedantLiterals = (CycList) antecedant.rest();
      else {
        antecedantLiterals = new CycList(1);
        antecedantLiterals.add(antecedant);
      }
      final Element bodyNode = document.createElementNS(rulemlNamespace, "ruleml:body");
      bodyNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
      final int antecedantLiterals_size = antecedantLiterals.size();
      for (int i = 0; i < antecedantLiterals_size; i++) {
        final CycList antecedantLiteral = (CycList) antecedantLiterals.get(i);
        createAtomNode(bodyNode, antecedantLiteral);
      }
      impNode.appendChild(bodyNode);
      final Element headNode = document.createElementNS(rulemlNamespace, "ruleml:head");
      headNode.setAttributeNS(rdfNamespace, "rdf:parseType", "Collection");
      createAtomNode(headNode, consequentLiteral);
      impNode.appendChild(headNode);
      rdfNode.appendChild(impNode);
d606 6
d614 1
a614 1
  /** Gathers new variables from the the given literal into the given list of variables. 
d616 1
a616 2
   * @@param literal the given literal
   * @@param variables the given list of variables
d618 12
a629 15
  private void gatherVariablesFromLiteral(final CycList literal, final CycList variables) {
    //// Preconditions
    assert literal != null : "literal must not be null";
    assert variables != null : "variables must not be null";
    
    final int literal_size = literal.size();
    if (literal_size > 1) {
      final Object arg1 = literal.second();
      if (arg1 instanceof CycVariable)
        variables.addNew(arg1);
    }
    if (literal_size > 2) {
      final Object arg2 = literal.third();
      if (arg2 instanceof CycVariable)
        variables.addNew(arg2);
d631 8
a638 153
  }
 
  /** Creates a rule atom node for the given literal.
   *
   * @@param literal the given rule literal
   */
  private void createAtomNode(final Element parent, final CycList literal)
    throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert document != null : "document must not be null";
    assert parent != null : "parent must not be null";
    assert literal != null : "literal must not be null";
    
    final CycFort predicate = (CycFort) literal.first();
    if (predicate.equals(CycAccess.isa)) {
      final Element classAtomNode = document.createElementNS(swrlNamespace, "swrl:ClassAtom");
      final CycVariable variable = (CycVariable) literal.second();
      final CycFort collection = (CycFort) literal.third();
      final Element classPredicateNode = document.createElementNS(swrlNamespace, "swrl:ClassPredicate");
      classPredicateNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(collection));
      classAtomNode.appendChild(classPredicateNode);
      final Element argument1Node = document.createElementNS(swrlNamespace, "swrl:argument1");
      argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName(variable));
      classAtomNode.appendChild(argument1Node);
      parent.appendChild(classAtomNode);
    }
    else if (predicate.toString().equals("relationInstanceExists")) {
      final Element classAtomNode = document.createElementNS(swrlNamespace, "swrl:ClassAtom");
      final Element classPredicateNode = document.createElementNS(swrlNamespace, "swrl:ClassPredicate");
      final Element restrictionNode = document.createElementNS(owlNamespace, "owl:Restriction");
      classPredicateNode.appendChild(restrictionNode);
      final Element onPropertyNode = document.createElementNS(owlNamespace, "owl:onProperty");
      final CycFort binaryPredicate = (CycFort) literal.second();
      onPropertyNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(binaryPredicate));
      restrictionNode.appendChild(onPropertyNode);    
      final Element someValuesFromNode = document.createElementNS(owlNamespace, "owl:someValuesFrom");
      final CycFort collection = (CycFort) literal.fourth();
      someValuesFromNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(collection));
      restrictionNode.appendChild(someValuesFromNode);
      classAtomNode.appendChild(classPredicateNode);
      final Element argument1Node = document.createElementNS(swrlNamespace, "swrl:argument1");
      final CycVariable variable = (CycVariable) literal.third();
      argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName(variable));
      classAtomNode.appendChild(argument1Node);
      parent.appendChild(classAtomNode);
    }
    else if (isObjectProperty(predicate)) {
      final Element individualPropertyAtomNode = document.createElementNS(swrlNamespace, "swrl:individualPropertyAtom");
      final Element propertyPredicateNode = document.createElementNS(swrlNamespace, "swrl:propertyPredicate");
      propertyPredicateNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(predicate));
      individualPropertyAtomNode.appendChild(propertyPredicateNode);
      final Object arg1 = literal.second();
      final Element argument1Node = document.createElementNS(swrlNamespace, "swrl:argument1");
      if (arg1 instanceof CycVariable)
        argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName((CycVariable) arg1));
      else
        argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg1));
      individualPropertyAtomNode.appendChild(argument1Node);
      final Object arg2 = literal.third();
      final Element argument2Node = document.createElementNS(swrlNamespace, "swrl:argument2");
      if (arg2 instanceof CycVariable)
        argument2Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName((CycVariable) arg2));
      else
        argument2Node.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg2));
      individualPropertyAtomNode.appendChild(argument2Node);
      parent.appendChild(individualPropertyAtomNode);
    }
    else {
      final Element datavaluedPropertyAtomNode = document.createElementNS(swrlNamespace, "swrl:datavaluedPropertyAtom");
      final Element propertyPredicateNode = document.createElementNS(swrlNamespace, "swrl:propertyPredicate");
      propertyPredicateNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(predicate));
      datavaluedPropertyAtomNode.appendChild(propertyPredicateNode);
      final Object arg1 = literal.second();
      final Element argument1Node = document.createElementNS(swrlNamespace, "swrl:argument1");
      if (arg1 instanceof CycVariable)
        argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName((CycVariable) arg1));
      else
        argument1Node.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg1));
      datavaluedPropertyAtomNode.appendChild(argument1Node);
      final Object arg2 = literal.third();
      final Element argument2Node = document.createElementNS(swrlNamespace, "swrl:argument2");
      if (arg2 instanceof CycVariable)
        argument2Node.setAttributeNS(rdfNamespace, "rdf:resource", "#" + variableName((CycVariable) arg2));
      else if (arg2 instanceof String || 
               arg2 instanceof Integer || 
               arg2 instanceof Long || 
               arg2 instanceof Float || 
               arg2 instanceof Double)
        argument2Node.appendChild(document.createTextNode(arg2.toString()));
      else if (arg2 instanceof CycList &&
               cycAccess.isa((CycList) arg2, cycAccess.getKnownConstantByName("Date"), inferenceMt))
        argument2Node.appendChild(document.createTextNode(cycAccess.xmlDatetimeString((CycList) arg2)));
      else
        argument2Node.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg2));
      datavaluedPropertyAtomNode.appendChild(argument2Node);
      parent.appendChild(datavaluedPropertyAtomNode);
    }
  }
  
  /** Returns the OWL name for the given CycL variable.
   *
   * @@param cycVariable the given CycL variable
   */
  private String variableName (final CycVariable variable) {
    return variable.toString().substring(1) + "_VAR";
  }
  
  
  /** Creates the OWL node that defines a definitional functional property having an rdfsLiteral as its range.
   *
   * @@param name the definitional property name
   * @@param label the definitional property label
   * @@param comment the definitional property comment
   */
  private void createDefinitionalFunctionalPropertyNode(final String name, final String label, final String comment) {
    //// Preconditions
    assert document != null : "document must not be null";
    
    final Element propertyNode = document.createElementNS(owlNamespace, "owl:DatatypeProperty");
    rdfNode.appendChild(propertyNode);
    propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", name);
    if (exportCommand != EXPORT_RESEARCH_CYC) {
      Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      labelNode.appendChild(document.createTextNode(label));
      propertyNode.appendChild(labelNode);
    }
    final Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
    commentNode.appendChild(document.createTextNode(comment));
    propertyNode.appendChild(commentNode);
    final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
    typeNode.setAttributeNS(rdfNamespace, "rdf:resource", owlFunctionalProperty);
    propertyNode.appendChild(typeNode);
    final Element rangeNode = document.createElementNS(rdfsNamespace, "rdfs:range");
    rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", rdfsLiteral);
    propertyNode.appendChild(rangeNode);
  }
  
  /** Creates a OWL property node for a single Cyc binary predicate.
   *
   * @@param cycObject The Cyc binary predicate from which the OWL property node is created.
   */
  private void createPropertyNode(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    assert cycObject instanceof CycFort : "cycObject must be a CycFort";
    assert document != null : "document must not be null";
    
    final Element propertyNode;
    String datatypePropertyDatatype = null;
    String inverseDatatypePropertyDatatype = null;
    boolean isInverseProperty = false;
    if (isObjectProperty(cycObject))
d640 1
a640 32
    else {
      datatypePropertyDatatype = getDatatypePropertyDataype(cycObject);
      if (datatypePropertyDatatype != null)
        propertyNode = document.createElementNS(owlNamespace, "owl:DatatypeProperty");
      else {
        inverseDatatypePropertyDatatype = getInverseDatatypePropertyDatatype(cycObject);
        if (inverseDatatypePropertyDatatype != null) {
          isInverseProperty = true;
          propertyNode = document.createElementNS(owlNamespace, "owl:DatatypeProperty");
        }
        else {
          logger.info("the Cyc predicate " + cycObject.cyclify() + " undecided OWL property; assuming an ObjectProperty.");
          propertyNode = document.createElementNS(owlNamespace, "owl:ObjectProperty");
        }
      }
    }
    rdfNode.appendChild(propertyNode);
    if (isFunctionalProperty(cycObject)) {
      final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
      typeNode.setAttributeNS(rdfNamespace, "rdf:resource", owlFunctionalProperty);
      propertyNode.appendChild(typeNode);
    }
    if (isInverseFunctionalProperty(cycObject)) {
      final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
      typeNode.setAttributeNS(rdfNamespace, "rdf:resource", owlInverseFunctionalProperty);
      propertyNode.appendChild(typeNode);
    }
    if (isInverseProperty) {
      createInversePropertyNode(cycObject, propertyNode);
      return;
    }
    
d645 3
a647 2
    if (exportCommand == EXPORT_RESEARCH_CYC) {
      logger.fine("");
d649 4
a652 1
    else
d654 4
a657 11
    createCommonNodes(propertyNode);
    if (isas != null) {
      for (int i = 0; i < isas.size(); i++) {
        final CycFort isa = (CycFort) isas.get(i);
        if ((! isa.toString().equals("BinaryPredicate")) && 
            (! isa.toString().equals("Thing"))) {
          final Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
          typeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(isa));
          propertyNode.appendChild(typeNode);
        }
      }
d659 4
a662 7
    if (cycObject instanceof CycFort)
      populateGenlPreds((CycFort) cycObject);
    else
      genlPreds = new CycList();
    if (exportCommand == this.EXPORT_RESEARCH_CYC) {
      arg1Isas = null;
      arg2Isas = null;
d664 4
a667 3
    else {
      populateArg1Isas(cycObject);
      populateArg2Isas(cycObject);
a668 3
    populateArg1Format(cycObject);
    //TODO later remove argNFormat because we query for strictlyFunctionalInArgs.
    populateArg2Format(cycObject);
d671 2
a672 2
        final Element subPropertyOfNode = document.createElementNS(rdfsNamespace, "rdfs:subPropertyOf");
        subPropertyOfNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithPropertyMapping(genlPreds.get(i)));
d675 3
a677 61
    for (int i = 0; i < arg1Isas.size(); i++) {
      final Element domainNode = document.createElementNS(rdfsNamespace, "rdfs:domain");
      domainNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(arg1Isas.get(i)));
      propertyNode.appendChild(domainNode);
    }
    if (datatypePropertyDatatype != null) {
      final Element rangeNode = document.createElementNS(rdfsNamespace, "rdfs:range");
      rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", datatypePropertyDatatype);
      propertyNode.appendChild(rangeNode);
    }
    else if (inverseDatatypePropertyDatatype != null) {
      final Element rangeNode = document.createElementNS(rdfsNamespace, "rdfs:range");
      rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", inverseDatatypePropertyDatatype);
      propertyNode.appendChild(rangeNode);
    }
    else {
      for (int i = 0; i < arg2Isas.size(); i++) {
        final Element rangeNode = document.createElementNS(rdfsNamespace, "rdfs:range");
        rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg2Isas.get(i)));
        propertyNode.appendChild(rangeNode);
      }
    }
    if (! isExportLimitedToOpenCycContent)
      createPropertyAssertionNodes(propertyNode);
  }
  
  /** Creates a OWL property node for a single Cyc binary predicate's inverse.
   *
   * @@param predicate The Cyc binary predicate from whose inverse the OWL property node is created.
   * @@param propertyNode property node to be completed
   */
  private void createInversePropertyNode(final CycObject cycObject, final Element propertyNode)
  throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    assert propertyNode != null : "propertyNode must not be null";
    
    final CycFort inversePredicate = new CycNart(cycAccess.getKnownConstantByName("InverseBinaryPredicateFn"), cycObject);
    propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", xmlNonAtomicTermName(cycObject));
    if (exportCommand == EXPORT_RESEARCH_CYC) {
      logger.fine("");
    }
    else {
      final Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
      labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
      final String label = cycAccess.getGeneratedPhrase(cycObject);
      logger.fine("  " + label);
      labelNode.appendChild(document.createTextNode(label));
      propertyNode.appendChild(labelNode);
    }
    if (exportCommand == this.EXPORT_RESEARCH_CYC) {
      arg1Isas = new CycList(0);
      arg2Isas = new CycList(0);
    }
    else {
      populateArg1Isas(cycObject);
      populateArg2Isas(cycObject);
    }
    for (int i = 0; i < arg1Isas.size(); i++) {
      final Element domainNode = document.createElementNS(rdfsNamespace, "rdfs:domain");
      domainNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithClassMapping(arg1Isas.get(i)));
d680 3
a682 3
    for (int i = 0; i < arg2Isas.size(); i++) {
      final Element rangeNode = document.createElementNS(rdfsNamespace, "rdfs:range");
      rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTermWithMapping(arg2Isas.get(i)));
d685 1
d695 8
a702 104
  private String translateTermWithMapping(final Object obj) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert obj != null : "obj must not be null";
    
    String translatedTerm = (String) owlClassMappingDictionary.get(obj);
    if (translatedTerm == null) {
      translatedTerm = (String) owlPropertyMappingDictionary.get(obj);
    }
    if (translatedTerm == null) {
      translatedTerm = (String) xsdSchemaMappingDictionary.get(obj);
    }
    if (translatedTerm == null) {
      translatedTerm = translateTerm(obj);
    }
    //// Postconditions
    assert translatedTerm != null : "translatedTerm must not be null";
    assert translatedTerm.length() > 0 : "translatedTerm must not be an empty string";
    
    return translatedTerm;
  }
  
  /** Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property, with mapping to native OWL class objects.
   *
   * @@param obj The Cyc term which is to be translated into a kind of OWL node.
   * @@return The kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   */
  private String translateTermWithClassMapping(final Object obj) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert obj != null : "obj must not be null";
    
    String translatedTerm = (String) owlClassMappingDictionary.get(obj);
    if (translatedTerm == null) {
      translatedTerm = translateTerm(obj);
    }
    //// Postconditions
    assert translatedTerm != null : "translatedTerm must not be null";
    assert translatedTerm.length() > 0 : "translatedTerm must not be an empty string";
    
    return translatedTerm;
  }
  
  /** Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property, with mapping to naive XML schema datatypes.
   *
   * @@param obj The Cyc term which is to be translated into a kind of OWL node.
   * @@return The kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   */
  private String translateTermWithPropertyMapping(final Object obj) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert obj != null : "obj must not be null";
    
    String translatedTerm = (String) owlPropertyMappingDictionary.get(obj);
    if (translatedTerm == null) {
      translatedTerm = translateTerm(obj);
    }
    //// Postconditions
    assert translatedTerm != null : "translatedTerm must not be null";
    assert translatedTerm.length() > 0 : "translatedTerm must not be an empty string";
    
    return translatedTerm;
  }
  
  /** Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property, with mapping to naive XML schema datatypes.
   *
   * @@param obj The Cyc term which is to be translated into a kind of OWL node.
   * @@return The kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   */
  private String translateTermWithXSDSchemaMapping(final Object obj) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert obj != null : "obj must not be null";
    
    String translatedTerm = (String) xsdSchemaMappingDictionary.get(obj);
    if (translatedTerm == null) {
      translatedTerm = translateTerm(obj);
    }
    //// Postconditions
    assert translatedTerm != null : "translatedTerm must not be null";
    assert translatedTerm.length() > 0 : "translatedTerm must not be an empty string";
    
    return translatedTerm;
  }
  
  /** Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property, without mapping to native OWL objects.
   *
   * @@param obj The Cyc term which is to be translated into a kind of OWL node.
   * @@return The kind of OWL node: OWL Thing, OWL class, OWL property or
   * OWL transitive property.
   */
  private String translateTerm(final Object obj) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert obj != null : "obj must not be null";
    assert ! (obj instanceof CycVariable) : obj.toString() + " must not be a CycVariable";
    
    String translatedTerm = null;
    if (obj instanceof CycNart || obj instanceof CycList)
      translatedTerm = "#" + xmlNonAtomicTermName((CycObject) obj);
    else if (obj instanceof CycConstant)
      translatedTerm =  "#" + xmlName((CycConstant) obj);
d704 1
a704 7
      translatedTerm = obj.toString();
    
    //// Postconditions
    assert translatedTerm != null : "translatedTerm must not be null";
    assert translatedTerm.length() > 0 : "translatedTerm must not be an empty string";
    
    return translatedTerm;
d711 2
a712 10
  private void populateComment(final CycObject cycObject) throws UnknownHostException, IOException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    String tempComment = null;
    try {
      tempComment = cycAccess.getComment(cycObject);
    }
    catch (CycApiException e) {
    }
d734 1
a734 4
  private ArrayList applyCycKbSubsetFilter(final CycList constants) throws UnknownHostException, IOException, CycApiException{
    //// Preconditions
    assert constants != null : "constants must not be null";
    
d737 2
a738 1
    logger.fine("Applying " + cycKbSubsetFilter.cyclify() + " filter");
d741 1
a741 1
    final ArrayList result = new ArrayList();
d745 1
a745 1
          cycAccess.isQuotedIsa((CycConstant) object, cycKbSubsetFilter, inferenceMt))
d747 2
a748 1
      logger.finer(" dropping " + object);
d752 1
a752 1
  
d757 1
a757 4
  private void populateIsas(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
d763 1
a763 1
      isas = cycAccess.getIsas(cycObject, inferenceMt);
a767 15
    if (cycAccess.isBinaryPredicate(cycObject, inferenceMt)) {
      final CycFort transitiveBinaryPredicate = cycAccess.getKnownConstantByName("TransitiveBinaryPredicate");
      if (cycAccess.isa(cycObject, transitiveBinaryPredicate, inferenceMt))
        isas.addNew(transitiveBinaryPredicate);
      final CycFort symmetricBinaryPredicate = cycAccess.getKnownConstantByName("SymmetricBinaryPredicate");
      if (cycAccess.isa(cycObject, symmetricBinaryPredicate, inferenceMt))
        isas.addNew(symmetricBinaryPredicate);
      isas.remove(cycAccess.getKnownConstantByName("Individual"));
    }
    if (isas.isEmpty() && cycAccess.isIndividual(cycObject, inferenceMt))
      isas.add(cycAccess.thing);
    if (! isas.isEmpty()) {
      sortCycObjects(isas);
      logger.fine("    isas: " + isas.toString());
    }
d774 2
a775 5
  private void populateGenls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    genls = cycAccess.getGenls(cycObject, inferenceMt);
a779 4
    if (! genls.isEmpty()) {
      sortCycObjects(genls);
      logger.fine("    genls: " + genls.toString());
    }
d786 3
a788 6
  private void populateGenlPreds(final CycFort cycFort) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycFort != null : "cycFort must not be null";
    
    genlPreds = cycAccess.getGenlPreds(cycFort, inferenceMt);
    genlPreds = filterSelectedConstants(genlPreds);
a791 3
    sortCycObjects(genlPreds);
    if (! genlPreds.isEmpty())
      logger.fine("    genlPreds: " + genlPreds.toString());
a792 2
    //// Postconditions
    assert genlPreds != null : "genlPreds must not be null";
d795 1
a795 1
  /** Populates the argument 1 type constaints for a Cyc predicate.
d797 1
a797 1
   * @@param cycObject The Cyc predicate for which the argument 1 type constaints are obtained.
d799 8
a806 11
  private void populateArg1Isas(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    arg1Isas = cycAccess.getArg1Isas(cycObject, inferenceMt);
    arg1Isas = filterSelectedConstants(arg1Isas);
    if (arg1Isas.size() > 0) {
      if (arg1Isas.size() > 1)
        Collections.sort(arg1Isas);
      logger.fine("    arg1Isas: " + arg1Isas.toString());
    }
d809 1
a809 1
  /** Populates the argument 2 type constaints for a Cyc predicate.
d811 1
a811 1
   * @@param cycObject The Cyc predicate for which the argument 2 type constaints are obtained.
d813 8
a820 11
  private void populateArg2Isas(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    arg2Isas = cycAccess.getArg2Isas(cycObject, inferenceMt);
    arg2Isas = filterSelectedConstants(arg2Isas);
    if (arg2Isas.size() > 0) {
      if (arg2Isas.size() > 1)
        Collections.sort(arg2Isas);
      logger.fine("    arg2Isas: " + arg2Isas.toString());
    }
d827 3
a829 6
  private void populateArg1Format(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    CycList arg1Formats = cycAccess.getArg1Formats(cycObject, inferenceMt);
    if (arg1Formats.size() > 0) {
a830 2
      logger.fine("    arg1Format: " + arg1Format.toString());
    }
d838 3
a840 6
  private void populateArg2Format(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    CycList arg2Formats = cycAccess.getArg2Formats(cycObject, inferenceMt);
    if (arg2Formats.size() > 0) {
a841 2
      logger.fine("    arg2Format: " + arg2Format);
    }
d848 4
a851 22
  private void populateDisjointWiths(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    assert theSetOfOWLSelectedClasses != null : "theSetOfOWLSelectedClasses must not be null";
    
    try {
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?COL");
      final String queryString =
        "(#$and " +
        "  (#$elementOf ?COL " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "  (#$disjointWith " + cycObject.cyclify() + " ?COL))";
      final CycList query = cycAccess.makeCycList(queryString);
      disjointWiths = cycAccess.queryVariable(queryVariable, query, inferenceMt, (HashMap) null, DISJOINT_WITH_PROBLEM_STORE_NAME);
      disjointWiths = cycAccess.getMinCols(disjointWiths, inferenceMt);
      sortCycObjects(disjointWiths);
      if (! disjointWiths.isEmpty())
        logger.fine("    disjointWiths: " + disjointWiths.cyclify());
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
d858 1
a858 4
  private void populateCoExtensionals(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
d860 1
a860 11
      final CycList candidateCoExtensionals = cycAccess.getCoExtensionals(cycObject, inferenceMt);
      coExtensionals = new CycList();
      for (int i = 0; i < candidateCoExtensionals.size(); i++) {
        final CycObject coExtensional = (CycObject) candidateCoExtensionals.get(i);
        if (owlSelectedClasses.contains(coExtensional))
          coExtensionals.add(coExtensional);
      }
      if (! coExtensionals.isEmpty()) {
        sortCycObjects(coExtensionals);
        logger.fine("    coExtensionals: " + coExtensionals.cyclify());
      }
d866 2
d870 3
a872 2
  /** Populates the interArgIsa1-2 and interArgCondIsa1-2 pairs (PRED COL-2) for a Cyc collection COL-1 such that
   * (interArgIsa1-2 RELN COL-1 COL-2) or (interArgCondIsa1-2 PRED COL-1 COL-2)
d874 1
a874 1
   * @@param cycObject The Cyc collection for which the the interArgIsa1-2 and interArgCondIsa1-2 (RELN COL-2) pairs are obtained.
d876 6
a881 6
  private void populateInterArgIsa1_2s(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgIsa1_2s = new CycList();
    if (owlSelectedProperties.isEmpty())
d883 1
d885 4
a888 56
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      final String queryString =
        "(#$and " +
        "  (#$interArgIsa1-2 ?PRED " + cycObject.cyclify() + " ?COL-2) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$interArgIsa1-2 ?PRED ?COL-1 ?COL-2))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, INTER_ARG_ISA1_2_PROBLEM_STORE_NAME);
      logger.finer("    interArgIsa query: " + queryString);
      logger.finer("    interArgIsa bindings: " + bindings);
      int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          false,                 // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          collection2,           // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "interArgIsa1-2");      // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection2);
        interArgIsa1_2s.addNew(pair);
      }
d894 15
a908 3
    if (! interArgIsa1_2s.isEmpty()) {
      sortCycObjects(interArgIsa1_2s);
      logger.fine("    interArgIsa1-2: " + interArgIsa1_2s.toString());
d912 1
a912 2
  /** Populates the interArgIsa2-1 and interArgCondIsa2-1 pairs (PRED COL-1) for a Cyc collection COL-2 such that
   * (interArgIsa2-1 RELN COL-1 COL-2) or (interArgCondIsa2-1 PRED COL-1 COL-2) holds.
d914 2
a915 1
   * @@param cycObject The Cyc collection for which the the interArgIsa1-2 and interArgCondIsa1-2 (RELN COL-2) pairs are obtained.
d917 5
a921 72
  private void populateInterArgIsa2_1s(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgIsa2_1s = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      final String queryString =
        "(#$and " +
        "  (#$interArgIsa2-1 ?PRED ?COL-1 " + cycObject.cyclify() + ") " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "          (#$interArgIsa2-1 ?PRED ?COL-1 ?COL-2))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, INTER_ARG_ISA2_1_PROBLEM_STORE_NAME);
      logger.finest("    interArgIsa2_1 bindings: " + bindings);
      int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          true,                  // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          collection1,           // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "interArgIsa2-1");      // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection1);
        interArgIsa2_1s.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! interArgIsa2_1s.isEmpty()) {
      sortCycObjects(interArgIsa2_1s);
      logger.fine("    interArgIsa2_1: " + interArgIsa2_1s.toString());
    }
d924 1
a924 2
  /** Populates the relationAllExists pairs (PRED COL-2) for a Cyc collection COL-1 such that
   * (relatiionAllExists PRED COL-1 COL-2).
d926 2
a927 1
   * @@param cycObject The Cyc collection for which the relationAllExists pairs (PRED COL-2) are obtained.
d929 11
a939 73
  private void populateRelationAllExists(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllExists = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      final String queryString =
        "(#$and " +
        "  (#$relationAllExists ?PRED " + cycObject.cyclify() + " ?COL-2) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + theSetOfOWLSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "         (#$relationAllExists ?PRED ?COL-1 ?COL-2))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null); 
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_PROBLEM_STORE_NAME);
      logger.finer("    relationAllExists query: " + query.toPrettyCyclifiedString(""));
      logger.finer("    relationAllExists bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          false,                 // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          null,                  // allValuesFrom
                          collection2,           // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "relationAllExists");   // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection2);
        relationAllExists.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllExists.isEmpty()) {
      sortCycObjects(relationAllExists);
      logger.fine("    relationAllExists: " + relationAllExists.toString());
    }
d942 1
a942 2546
  /** Populates the relationExistsAll pairs (PRED COL-1) for a Cyc collection COL-2 such that
   * (relatiionAllExists PRED COL-1 COL-2).
   *
   * @@param cycObject The Cyc collection for which the relationExistsAll pairs (PRED COL-1) are obtained.
   */
  private void populateRelationExistAlls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationExistsAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      String queryString =
        "(#$and " +
        "  (#$relationExistsAll ?PRED ?COL-1 " + cycObject.cyclify() + ") " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "         (#$relationExistsAll ?PRED ?COL-1 ?COL-2))))))";
      CycList query = cycAccess.makeCycList(queryString);
      CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_PROBLEM_STORE_NAME);
      logger.finest("    relationExistsAll query: " + query.toPrettyCyclifiedString(""));
      logger.finest("    relationExistsAll bindings: " + bindings);
      int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          true,                  // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          null,                  // allValuesFrom
                          collection1,           // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "relationExistsAll");   // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection1);
        relationExistsAlls.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsAlls.isEmpty()) {
      sortCycObjects(relationExistsAlls);
      logger.fine("    relationExistsAlls: " + relationExistsAlls.toString());
    }
  }
  
  /** Populates the relationAllInstance pairs (PRED THING) for a Cyc collection COL-1 such that
   * (relatiionAllInstance PRED COL-1 THING).
   *
   * @@param cycObject The Cyc collection for which the relationAllExists pairs (PRED THING) are obtained.
   */
  private void populateRelationAllInstances(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllInstances = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable thingVariable = CycObjectFactory.makeCycVariable("?THING");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(thingVariable);
      final String queryString =
        "(#$and " +
        "  (#$relationAllInstance ?PRED " + cycObject.cyclify() + " ?THING) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$relationAllInstance ?PRED ?COL-1 ?THING))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_INSTANCE_PROBLEM_STORE_NAME);
      logger.finest("    relationAllInstance bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        Object thing = binding.second();
        if (thing instanceof CycObject && ! selectedCycForts.contains(thing))
          continue;
        if (! (thing instanceof CycObject))
          thing = possiblyCreateIndividual(predicate, false, thing);
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          predicate,             // property
                          false,                 // isInverseProperty
                          thing,                 // hasValue
                          null,                  // valuesFrom
                          null,                  // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "relationAllInstance"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(thing);
        relationAllInstances.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllInstances.isEmpty()) {
      sortCycObjects(relationAllInstances);
      logger.fine("    relationAllInstance: " + relationAllInstances.toString());
    }
  }
    
  /** Populates the relationInstanceAll pairs (PRED THING) for a Cyc collection COL such that
   * (relatiionInstanceAll PRED THING COL).
   *
   * @@param cycObject The Cyc collection for which the relationInstanceAll pairs (PRED THING) are obtained.
   */
  private void populateRelationInstanceAlls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationInstanceAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collectionVariable = CycObjectFactory.makeCycVariable("?THING");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collectionVariable);
      final String queryString =
        "(#$and " + 
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$relationInstanceAll ?PRED ?THING " + cycObject.cyclify() + ") " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL " +
        "      (#$and " +
        "        (#$elementOf ?COL " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL) " +
        "        (#$different " + cycObject.cyclify() + " ?COL) " +
        "        (#$knownSentence " +
        "          (#$relationInstanceAll ?PRED ?THING ?COL))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME);
      logger.finest("    relationInstanceAll bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        Object thing = binding.second();
        if (thing instanceof CycObject && ! selectedCycForts.contains(thing))
          continue;
        if (! (thing instanceof CycObject))
          thing = possiblyCreateIndividual(predicate, true, thing);
        final Restriction restriction =
          new Restriction(TYPE_RESTRICTION,      // restrictionType
                          predicate,             // property
                          true,                  // isInverseProperty
                          thing,                 // hasValue
                          null,                  // valuesFrom
                          null,                  // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                         "relationInstanceAll"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(thing);
        relationInstanceAlls.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationInstanceAlls.isEmpty()) {
      sortCycObjects(relationInstanceAlls);
      logger.fine("    relationInstanceAll: " + relationInstanceAlls.toString());
    }
  }
  
  /** Populates the relationInstanceExists pairs (PRED COL) for a Cyc THING such that
   * (relationInstanceExists PRED THING COL).
   *
   * @@param thing The Cyc individual for which the relationInstanceExists pairs (PRED COL) are obtained.
   */
  private void populateRelationInstanceExists(final CycObject thing) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert thing != null : "thing must not be null";
    
    relationInstanceExists = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collectionVariable = CycObjectFactory.makeCycVariable("?COL");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collectionVariable);
      final String queryString =
        "(#$relationInstanceExists ?PRED " + thing.cyclify() + " ?COL)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME);
      logger.finest("    relationInstanceExists bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        final CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          continue;
        final CycObject collection = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection))
          continue;
        final Restriction restriction =
          new Restriction(TYPE_RESTRICTION,         // restrictionType
                          predicate,                // property
                          false,                    // isInverseProperty
                          null,                     // hasValue
                          null,                     // valuesFrom
                          null,                     // allValuesFrom
                          collection,               // someValuesFrom
                          -1,                       // cardinality
                          -1,                       // maxCardinality
                          -1,                       // minCardinality
                         "relationInstanceExists"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection);
        relationInstanceExists.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationInstanceExists.isEmpty()) {
      sortCycObjects(relationInstanceExists);
      logger.fine("    relationInstanceExists: " + relationInstanceExists.toString());
    }
  }
  
  /** Populates the relationExistsInstance pairs (PRED COL) for a Cyc THING such that
   * (relationExistsInstance PRED COL THING).
   *
   * @@param thing The Cyc individual for which the relationExistsInstance pairs (PRED COL) are obtained.
   */
  private void populateRelationExistsInstance(final CycObject thing) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert thing != null : "thing must not be null";
    
    relationExistsInstances = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collectionVariable = CycObjectFactory.makeCycVariable("?COL");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collectionVariable);
      final String queryString =
        "(#$relationExistsInstance ?PRED ?COL " + thing.cyclify() + ")";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME);
      logger.fine("    relationExistsInstance bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        final CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          continue;
        final CycObject collection = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection))
          continue;
        final Restriction restriction =
          new Restriction(TYPE_RESTRICTION,         // restrictionType
                          predicate,                // property
                          true,                     // isInverseProperty
                          null,                     // hasValue
                          null,                     // valuesFrom
                          null,                     // allValuesFrom
                          collection,               // someValuesFrom
                          -1,                       // cardinality
                          -1,                       // maxCardinality
                          -1,                       // minCardinality
                         "relationExistsInstance"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection);
        relationExistsInstances.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsInstances.isEmpty()) {
      sortCycObjects(relationExistsInstances);
      logger.fine("    relationExistsInstance: " + relationExistsInstances.toString());
    }
  }
  
  /** Populates the relationAllExistsCount tuples (PRED COL-1 COL-2 CARD) for a Cyc individual term THING such that
   * (relationAllExistsCount PRED COL-1 COL-2 NUM).
   *
   * @@param cycObject The Cyc individual for which the relationAllExistsCount tuples (PRED COL-2 CARD) are obtained.
   */
  private void populateRelationAllExistsCounts(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllExistsCounts = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationAllExistsCount ?PRED " + cycObject.cyclify() + " ?COL-2 ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$relationAllExistsCount ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ? 
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_COUNT_PROBLEM_STORE_NAME);
      logger.finest("    relationAllExistsCount bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Number cardinality = (Number) binding.third();
        if (! exportQualifiedCardinalityRestrictions && cardinality.intValue() == 0)
          continue;
        Restriction restriction = null;
        if (exportQualifiedCardinalityRestrictions)
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,     // restrictionType
                            predicate,                // property
                            false,                    // isInverseProperty
                            null,                     // hasValue
                            collection2,              // valuesFrom
                            null,                     // allValuesFrom
                            null,                     // someValuesFrom
                            cardinality.intValue(),   // cardinality
                            -1,                       // maxCardinality
                            -1,                       // minCardinality
                           "relationAllExistsCount"); // sourceRuleMacroPredicate
        else if (cardinality.intValue() > 0)
          // if QCRs not exported  and card > 0, then export same as relationAllExists
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,     // restrictionType
                            (CycFort) predicate,      // property
                            false,                    // isInverseProperty
                            null,                     // hasValue
                            null,                     // valuesFrom
                            null,                     // allValuesFrom
                            collection2,              // someValuesFrom
                            -1,                       // cardinality
                            -1,                       // maxCardinality
                            -1,                       // minCardinality
                           "relationAllExistsCount"); // sourceRuleMacroPredicate
        else
          // QCRs not exported and card = 0, so do not export the restriction
          continue;
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection2);
        tuple.add(cardinality);
        relationAllExistsCounts.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllExistsCounts.isEmpty()) {
      sortCycObjects(relationInstanceAlls);
      logger.fine("    relationAllExistsCounts: " + relationAllExistsCounts.toString());
    }
  }
  
  /** Populates the relationAllExistsMax tuples (PRED COL-1 COL-2 CARD) for a Cyc individual term THING such that
   * (relationAllExistsCount PRED COL-1 COL-2 NUM).
   *
   * @@param cycObject The Cyc individual for which the relationAllExistsMax tuples (PRED COL-2 CARD) are obtained.
   */
  private void populateRelationAllExistMaxs(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllExistMaxs = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationAllExistsMax ?PRED " + cycObject.cyclify() + " ?COL-2 ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$relationAllExistsMax ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_MAX_PROBLEM_STORE_NAME);
      logger.finest("    relationAllExistsMax bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Number cardinality = (Number) binding.third();
        if (! exportQualifiedCardinalityRestrictions)
          // drop this restriction if QCRs not exported
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,   // restrictionType
                          predicate,              // property
                          false,                  // isInverseProperty
                          null,                   // hasValue
                          collection2,            // valuesFrom
                          null,                   // allValuesFrom
                          null,                   // someValuesFrom
                          -1,                     // cardinality
                          cardinality.intValue(), // maxCardinality
                          -1,                     // minCardinality
                         "relationAllExistsMax"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection2);
        tuple.add(cardinality);
        relationAllExistMaxs.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllExistMaxs.isEmpty()) {
      sortCycObjects(relationAllExistMaxs);
      logger.fine("    relationAllExistMaxs: " + relationAllExistMaxs.toString());
    }
  }
  
  /** Populates the relationAllExistsMin tuples (PRED COL-1 COL-2 CARD) for a Cyc individual term THING such that
   * (relationAllExistsCount PRED COL-1 COL-2 NUM).
   *
   * @@param cycObject The Cyc individual for which the relationAllExistsMin tuples (PRED COL-2 CARD) are obtained.
   */
  private void populateRelationAllExistMins(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllExistMins = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationAllExistsMin ?PRED " + cycObject.cyclify() + " ?COL-2 ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$relationAllExistsMin ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_MIN_PROBLEM_STORE_NAME);
      logger.finest("    relationAllExistsMin bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Number cardinality = (Number) binding.third();
        Restriction restriction = null;
        if (exportQualifiedCardinalityRestrictions)
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            predicate,               // property
                            false,                   // isInverseProperty
                            null,                    // hasValue
                            collection2,             // valuesFrom
                            null,                    // allValuesFrom
                            null,                    // someValuesFrom
                            -1,                      // cardinality
                            -1,                      // maxCardinality
                            cardinality.intValue(),  // minCardinality
                           "relationAllExistsMin");  // sourceRuleMacroPredicate
        else if (cardinality.intValue() > 0)
          // if QCRs not exported  and card > 0, then export same as relationAllExists
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            (CycFort) predicate,     // property
                            false,                   // isInverseProperty
                            null,                    // hasValue
                            null,                    // valuesFrom
                            null,                    // allValuesFrom
                            collection2,             // someValuesFrom
                            -1,                      // cardinality
                            -1,                      // maxCardinality
                            -1,                      // minCardinality
                           "relationAllExistsMin");  // sourceRuleMacroPredicate
        else
          // QCRs not exported and card = 0, so do not export the restriction
          continue;
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection2);
        tuple.add(cardinality);
        relationAllExistMins.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllExistMins.isEmpty()) {
      sortCycObjects(relationAllExistMins);
      logger.fine("    relationAllExistMins: " + relationAllExistMins.toString());
    }
  }
  
  /** Populates the relationExistsCountAll tuples (PRED COL-1 CARD) for a Cyc collection term COL-1 such that
   * (relationExistsCountAll PRED COL-1 COL-2 CARD).
   *
   * @@param cycObject The Cyc collection for which the relationExistsCountAll tuples (PRED COL-1 CARD) are obtained.
   */
  private void populateRelationExistsCountAlls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationExistsCountAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationExistsCountAll ?PRED ?COL-1 " + cycObject.cyclify() + " ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "         (#$relationExistsCountAll ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_EXISTS_COUNT_ALL_PROBLEM_STORE_NAME);
      logger.finest("    relationExistsCountAll bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Number cardinality = (Number) binding.third();
        Restriction restriction;
        if (exportQualifiedCardinalityRestrictions)
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,     // restrictionType
                            predicate,                // property
                            true,                     // isInverseProperty
                            null,                     // hasValue
                            collection1,              // valuesFrom
                            null,                     // allValuesFrom
                            null,                     // someValuesFrom
                            cardinality.intValue(),   // cardinality
                            -1,                       // maxCardinality
                            -1,                       // minCardinality
                           "relationExistsCountAll"); // sourceRuleMacroPredicate
        else if (cardinality.intValue() > 0)
          // if QCRs not exported  and card > 0, then export same as relationExistsAll
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,     // restrictionType
                            (CycFort) predicate,      // property
                            true,                     // isInverseProperty
                            null,                     // hasValue
                            null,                     // valuesFrom
                            null,                     // allValuesFrom
                            collection1,              // someValuesFrom
                            -1,                       // cardinality
                            -1,                       // maxCardinality
                            -1,                       // minCardinality
                           "relationExistsCountAll"); // sourceRuleMacroPredicate
        else
          // if QCRs not exported and card == 0, then drop this restriction
          continue;
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection1);
        tuple.add(cardinality);
        relationExistsCountAlls.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsCountAlls.isEmpty()) {
      sortCycObjects(relationExistsCountAlls);
      logger.fine("    relationExistsCountAlls: " + relationExistsCountAlls.toString());
    }
  }
  
  /** Populates the relationExistsMaxAll tuples (PRED COL-1 CARD) for a Cyc collection term COL-2 such that
   * (relationExistsMaxAll PRED COL-1 COL-2 CARD).
   *
   * @@param cycObject The Cyc collection for which the relationExistsMaxAll tuples (PRED COL-1 CARD) are obtained.
   */
  private void populateRelationExistsMaxAlls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationExistsMaxAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationExistsMaxAll ?PRED ?COL-1 " + cycObject.cyclify() + " ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "         (#$relationExistsMaxAll ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_EXISTS_MAX_ALL_PROBLEM_STORE_NAME);
      logger.finest("    relationExistsMaxAll bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Number cardinality = (Number) binding.third();
        if (! exportQualifiedCardinalityRestrictions)
          // drop this restriction if QCRs not exported
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                          predicate,               // property
                          true,                    // isInverseProperty
                          null,                    // hasValue
                          collection1,             // valuesFrom
                          null,                    // allValuesFrom
                          null,                    // someValuesFrom
                          -1,                      // cardinality
                          cardinality.intValue(),  // maxCardinality
                          -1,                      // minCardinality
                         "relationExistsMaxAll");  // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection1);
        tuple.add(cardinality);
        relationExistsMaxAlls.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsMaxAlls.isEmpty()) {
      sortCycObjects(relationExistsMaxAlls);
      logger.fine("    relationExistsMaxAlls: " + relationExistsMaxAlls.toString());
    }
  }
  
  /** Populates the relationExistsMinAll tuples (PRED COL-1 CARD) for a Cyc collection term COL-2 such that
   * (relationExistsMinAll PRED COL-1 COL-2 CARD).
   *
   * @@param cycObject The Cyc collection for which the relationExistsMinAll tuples (PRED COL-1 CARD) are obtained.
   */
  private void populateRelationExistsMinAlls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationExistsMinAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$relationExistsMinAll ?PRED ?COL-1 " + cycObject.cyclify() + " ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "         (#$relationExistsMinAll ?PRED ?COL-1 ?COL-2 ?CARD))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_EXISTS_MIN_ALL_PROBLEM_STORE_NAME);
      logger.finest("    relationExistsMinAll bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Number cardinality = (Number) binding.third();
        Restriction restriction = null;
        if (exportQualifiedCardinalityRestrictions)
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            predicate,               // property
                            true,                    // isInverseProperty
                            null,                    // hasValue
                            collection1,             // valuesFrom
                            null,                    // allValuesFrom
                            null,                    // someValuesFrom
                            -1,                      // cardinality
                            -1,                      // maxCardinality
                            cardinality.intValue(),  // minCardinality
                           "relationExistsMinAll");  // sourceRuleMacroPredicate
        else if (cardinality.intValue() > 0)
          // if QCRs not exported and min > 0 then export same as relationExistsAll
          restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            (CycFort) predicate,     // property
                            true,                    // isInverseProperty
                            null,                    // hasValue
                            null,                    // valuesFrom
                            null,                    // allValuesFrom
                            collection1,             // someValuesFrom
                            -1,                      // cardinality
                            -1,                      // maxCardinality
                            -1,                      // minCardinality
                           "relationExistsMinAll");  // sourceRuleMacroPredicate
        else
          // if QCRs not exported and min == 0 then drop this restriction
          continue;
        addRestriction(restriction);
        final CycList tuple = new CycList(2);
        tuple.add(predicate);
        tuple.add(collection1);
        tuple.add(cardinality);
        relationExistsMinAlls.addNew(tuple);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsMinAlls.isEmpty()) {
      sortCycObjects(relationExistsMinAlls);
      logger.fine("    relationExistsMinAlls: " + relationExistsMinAlls.toString());
    }
  }
  
  
  // This method is de-activated.  Note that relationExistsAllMany is a spec pred of relationExistsAll, not clear
  // whether "many" can be expressed in OWL as a cardinality constraint.  If this is reinstated then add a
  // method for relationAllExistsMany.
  
  /** Populates the relationExistsAllMany pairs (PRED COL-2) for a Cyc collection term COL-1 such that
   * (relationExistsAllMany PRED COL-1 COL-2).
   *
   * @@param cycObject The Cyc collection for which the relationExistsAllMany pairs (PRED COL-2) are obtained.
   */
  private void populateRelationExistsAllMany(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationExistsAllManys = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      final String queryString =
      // TODO add the genls filter if this method is re-activated
        "(#$and " + 
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$relationExistsAllMany ?PRED " + cycObject.cyclify() + " ?COL-2))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_EXISTS_ALL_MANY_PROBLEM_STORE_NAME);
      logger.finest("    relationExistsAllMany bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Number cardinality = (Number) binding.third();
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                          predicate,               // property
                          true,                    // isInverseProperty
                          null,                    // hasValue
                          null,                    // valuesFrom
                          collection2,             // allValuesFrom
                          null,                    // someValuesFrom
                          -1,                      // cardinality
                          -1,                      // maxCardinality
                          cardinality.intValue(),  // minCardinality
                         "relationExistsAllMany"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection2);
        relationExistsAllManys.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationExistsAllManys.isEmpty()) {
      sortCycObjects(relationExistsAllManys);
      logger.fine("    relationExistsAllManys: " + relationExistsAllManys.toString());
    }
  }
  
  // TODO later for completeness, we should populate arg cardinality where the constraint is on the first
  // argument  as documented in the requirements.
  
  
  /** Populates the argCardinality pairs (PRED CARD) for a Cyc collection COL such that
   * (and (arg1Isa PRED COL) (argCardinality PRED 2 CARD)).
   *
   * @@param cycObject the given Cyc collection
   */
  private void populateArg2Cardinalities(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    arg2Cardinalities = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " +
        "  (#$argCardinality ?PRED 2 ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$assertedSentence " +
        "    (#$arg1Isa ?PRED " + cycObject.cyclify() + ")) " +
        "  (#$greaterThan ?CARD 1))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, ARG_CARDINALITY_PROBLEM_STORE_NAME);
      logger.finest("    argCardinality bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        final Number cardinality = (Number) binding.second();
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                          predicate,               // property
                          false,                   // isInverseProperty
                          null,                    // hasValue
                          null,                    // valuesFrom
                          null,                    // allValuesFrom
                          null,                    // someValuesFrom
                          -1,                      // cardinality
                          cardinality.intValue(),  // maxCardinality
                          -1,                      // minCardinality
                         "argCardinality");        // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(cardinality);
        arg2Cardinalities.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! arg2Cardinalities.isEmpty()) {
      sortCycObjects(arg2Cardinalities);
      logger.fine("    arg2Cardinalities: " + arg2Cardinalities.toString());
    }
  }
  
  /** Populates the interArgCardinality pairs (PRED CARD) for a Cyc collection COL such that
   * (interArgCardinality PRED 1 COL 2 CARD).
   *
   * @@param cycObject the given Cyc collection
   */
  private void populateInterArgCardinalities1_2(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgCardinalities1_2 = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$interArgCardinality ?PRED 1 " + cycObject.cyclify() + " 2 ?CARD))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, INTER_ARG_CARDINALITY_PROBLEM_STORE_NAME);
      logger.finest("    interArgCardinality 1 2 bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        //TODO later assert selectedCycForts.contains(predicate)
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        final Number cardinality = (Number) binding.second();
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,      // restrictionType
                          predicate,                 // property
                          false,                     // isInverseProperty
                          null,                      // hasValue
                          null,                      // valuesFrom
                          null,                      // allValuesFrom
                          null,                      // someValuesFrom
                          -1,                        // cardinality
                          cardinality.intValue(),    // maxCardinality
                          -1,                        // minCardinality
                         "interArgCardinality 1 2"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(cardinality);
        interArgCardinalities1_2.add(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! interArgCardinalities1_2.isEmpty()) {
      sortCycObjects(interArgCardinalities1_2);
      logger.fine("    interArgCardinalities1_2: " + interArgCardinalities1_2.toString());
    }
  }
  
  /** Populates the interArgCardinality pairs (PRED CARD) for a Cyc collection COL such that
   * (interArgCardinality PRED 2 COL 1 CARD), where PRED is the inverse form of the predicate.
   *
   * @@param cycObject the given Cyc collection
   */
  private void populateInterArgCardinalities2_1(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgCardinalities1_2 = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable cardinalityVariable = CycObjectFactory.makeCycVariable("?CARD");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(cardinalityVariable);
      final String queryString =
        "(#$and " + 
        "  (#$interArgCardinality ?PRED 2 " + cycObject.cyclify() + " 1 ?CARD) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, INTER_ARG_CARDINALITY_PROBLEM_STORE_NAME);
      logger.finest("    interArgCardinality 2 1 bindings: " + bindings);
      final int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        //TODO later assert selectedCycForts.contains(predicate)
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        final Number cardinality = (Number) binding.second();
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,      // restrictionType
                          predicate,                 // property
                          true,                      // isInverseProperty
                          null,                      // hasValue
                          null,                      // valuesFrom
                          null,                      // allValuesFrom
                          null,                      // someValuesFrom
                          -1,                        // cardinality
                          cardinality.intValue(),    // maxCardinality
                          -1,                        // minCardinality
                         "interArgCardinality 1 2"); // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(cardinality);
        interArgCardinalities1_2.add(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! interArgCardinalities1_2.isEmpty()) {
      sortCycObjects(interArgCardinalities1_2);
      logger.fine("    interArgCardinalities1_2: " + interArgCardinalities1_2.toString());
    }
  }
  
  /** Populates the interArgFormat1-2 PREDs for a Cyc collection COL such that
   * (interArgFormat1-2 PRED COL singleEntryFormatInArgs) or.
   * (interArgFormat1-2 PRED COL SingleEntry) or.
   *
   * @@param cycObject the given Cyc collection
   */
  private void populateInterArgFormats1_2(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgFormats1_2 = new CycList();
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final String queryString =
        "(#$and " + 
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$or " +
        "    (#$interArgFormat1-2 ?PRED " + cycObject.cyclify() + " #$singleEntryFormatInArgs) " +
        "    (#$interArgFormat1-2 ?PRED " + cycObject.cyclify() + " #$SingleEntry)))";
      final CycList query = cycAccess.makeCycList(queryString);
      interArgFormats1_2 = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null);
//      interArgFormats1_2 = cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null, INTER_ARG_FORMATS_PROBLEM_STORE_NAME);
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! interArgFormats1_2.isEmpty()) {
      sortCycObjects(interArgFormats1_2);
      logger.fine("    interArgFormat1_2s: " + interArgFormats1_2.toString());
      for (int i = 0; i < interArgFormats1_2.size(); i++) {
        final CycFort predicate = (CycFort) interArgFormats1_2.get(i);
        boolean haveCardinalityForPredicate = false;
        for (int j = 0; j < arg2Cardinalities.size(); j++) {
          final CycList pair = (CycList) arg2Cardinalities.get(j);
          if (pair.first().equals(predicate)) {
            haveCardinalityForPredicate = true;
            break;
          }
        }
        for (int j = 0; j < interArgFormats1_2.size(); j++) {
          final CycList pair = (CycList) interArgFormats1_2.get(j);
          if (pair.first().equals(predicate)) {
            haveCardinalityForPredicate = true;
            break;
          }
        }
        if (! selectedCycForts.contains(predicate))
          continue;
        if (! haveCardinalityForPredicate) {
          final Restriction restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            predicate,               // property
                            false,                   // isInverseProperty
                            null,                    // hasValue
                            null,                    // valuesFrom
                            null,                    // allValuesFrom
                            null,                    // someValuesFrom
                            -1,                      // cardinality
                            1,                       // maxCardinality
                            -1,                      // minCardinality
                            "interArgFormat1_2");    // sourceRuleMacroPredicate
          addRestriction(restriction);
        }
      }
    }
  }
  
  /** Populates the interArgFormat2-1 inverse PREDs for a Cyc collection COL such that
   * (interArgFormat2-1 PRED COL singleEntryFormatInArgs) or
   * (interArgFormat2-1 PRED COL SingleEntry).
   *
   * @@param cycObject the given Cyc collection
   */
  private void populateInterArgFormats2_1(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    interArgFormats2_1 = new CycList();
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final String queryString =
        "(#$and " + 
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$or " +
        "    (#$interArgFormat2-1 ?PRED " + cycObject.cyclify() + " #$singleEntryFormatInArgs) " +
        "    (#$interArgFormat2-1 ?PRED " + cycObject.cyclify() + " #$SingleEntry)))";
      final CycList query = cycAccess.makeCycList(queryString);
      interArgFormats2_1 = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null);
//      interArgFormats2_1 = cycAccess.queryVariable(predicateVariable, query, inferenceMt, (HashMap) null, INTER_ARG_FORMATS_PROBLEM_STORE_NAME);
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! interArgFormats2_1.isEmpty()) {
      sortCycObjects(interArgFormats2_1);
      logger.fine("    interArgFormat2_1s: " + interArgFormats2_1.toString());
      for (int i = 0; i < interArgFormats1_2.size(); i++) {
        final CycFort predicate = (CycFort) interArgFormats2_1.get(i);
        boolean haveCardinalityForPredicate = false;
        for (int j = 0; j < arg2Cardinalities.size(); j++) {
          final CycList pair = (CycList) arg2Cardinalities.get(j);
          if (pair.first().equals(predicate)) {
            haveCardinalityForPredicate = true;
            break;
          }
        }
        for (int j = 0; j < interArgFormats2_1.size(); j++) {
          final CycList pair = (CycList) interArgFormats1_2.get(j);
          if (pair.first().equals(predicate)) {
            haveCardinalityForPredicate = true;
            break;
          }
        }
        if (! selectedCycForts.contains(predicate))
          continue;
        if (! haveCardinalityForPredicate) {
          final Restriction restriction =
            new Restriction(SUBCLASS_RESTRICTION,    // restrictionType
                            predicate,               // property
                            true,                    // isInverseProperty
                            null,                    // hasValue
                            null,                    // valuesFrom
                            null,                    // allValuesFrom
                            null,                    // someValuesFrom
                            -1,                      // cardinality
                            1,                       // maxCardinality
                            -1,                      // minCardinality
                            "interArgFormat2_1");    // sourceRuleMacroPredicate
          addRestriction(restriction);
        }
      }
    }
  }
  
  /** Populates the typeGenls COL-2 for a Cyc collection COL-1 such that (typeGenls COL-1 COL-2).
   *
   * @@param cycObject The Cyc collection for which the typeGenls COL-2 for a Cyc collection COL-1 are obtained.
   */
  private void populateTypeGenls(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    typeGenls = new CycList();
    try {
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final String queryString =
        "(#$typeGenls " + cycObject.cyclify() + " ?COL-2)";
      final CycList query = cycAccess.makeCycList(queryString);
      typeGenls = cycAccess.queryVariable(collection2Variable, query, inferenceMt, (HashMap) null);
      typeGenls = findAllowedTermsOrGenls(typeGenls);
      if (! typeGenls.isEmpty()) {
        for (int i = 0; i < typeGenls.size(); i++) {
          final CycObject collection2 = (CycObject) typeGenls.get(i);
          final Restriction restriction =
            new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
            cycAccess.genls,       // property
            false,                 // isInverseProperty
            collection2,           // hasValue
            null,                  // valuesFrom
            null,                  // allValuesFrom
            null,                  // someValuesFrom
            -1,                    // cardinality
            -1,                    // maxCardinality
            -1,                    // minCardinality
            "typeGenls");          // sourceRuleMacroPredicate
          addRestriction(restriction);
        }
        
        sortCycObjects(typeGenls);
        logger.fine("    typeGenls: " + typeGenls);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
  }
  
  /** Populates the relationAllOnly pairs (PRED COL-2) for a Cyc collection COL-1 such that
   * (relationAllOnly RELN COL-1 COL-2) holds.
   *
   * @@param cycObject The Cyc collection for which the the relationAllOnly-2 (RELN COL-2) pairs are obtained.
   */
  private void populateRelationAllOnly(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationAllOnlys = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection2Variable = CycObjectFactory.makeCycVariable("?COL-2");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection2Variable);
      String queryString =
        "(#$and " +
        "  (#$relationAllOnly ?PRED " + cycObject.cyclify() + " ?COL-2) " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-2) (any-genl? ?COL-2 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-1 " +
        "      (#$and " +
        "        (#$elementOf ?COL-1 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-1) " +
        "        (#$knownSentence " +
        "          (#$relationAllOnly ?PRED ?COL-1 ?COL-2))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ALL_ONLY_PROBLEM_STORE_NAME);
      int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection2 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection2))
          collection2 = findSelectedGenls(collection2);
        if (! selectedCycForts.contains(collection2))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          false,                 // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          collection2,           // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                          "relationAllOnly");    // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection2);
        relationAllOnlys.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationAllOnlys.isEmpty()) {
      sortCycObjects(relationAllOnlys);
      logger.fine("    relationAllOnly: " + relationAllOnlys.toString());
    }
  }
  
  /** Populates the relationOnlyAll pairs (PRED COL-1) for a Cyc collection COL-2 such that
   * (relationOnlyAll-1 RELN COL-1 COL-2) holds.
   *
   * @@param cycObject The Cyc collection for which the the interArgIsa1-2 and interArgCondIsa1-2 (RELN COL-2) pairs are obtained.
   */
  private void populateRelationOnlyAll(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    relationOnlyAlls = new CycList();
    if (owlSelectedProperties.isEmpty())
      return;
    try {
      final CycVariable predicateVariable = CycObjectFactory.makeCycVariable("?PRED");
      final CycVariable collection1Variable = CycObjectFactory.makeCycVariable("?COL-1");
      final CycList variables = new CycList();
      variables.add(predicateVariable);
      variables.add(collection1Variable);
      String queryString =
        "(#$and " +
        "  (#$relationOnlyAll ?PRED ?COL-1 " + cycObject.cyclify() + ") " +
        "  (#$trueSubL (#$ExpandSubLFn (?PRED) (any-genl-predicate? ?PRED `" + owlSelectedProperties.cyclify() + "))) " +
        "  (#$trueSubL (#$ExpandSubLFn (?COL-1) (any-genl? ?COL-1 `" + owlSelectedClasses.cyclify() + "))) " +
        "  (#$unknownSentence " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$elementOf ?COL-2 " + theSetOfOWLSelectedClasses.cyclify() + ") " +
        "        (#$genls " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$different " + cycObject.cyclify() + " ?COL-2) " +
        "        (#$knownSentence " +
        "          (#$relationOnlyAll ?PRED ?COL-1 ?COL-2))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      CycList bindings = (PROBLEM_STORE_REUSE) ?
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, allQueriesProblemStoreName) :
        cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
//      CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null, RELATION_ONLY_ALL_PROBLEM_STORE_NAME);
      int bindings_size = bindings.size();
      for (int i = 0; i < bindings_size; i++) {
        final CycList binding = (CycList) bindings.get(i);
        CycObject predicate = (CycObject) binding.first();
        if (! selectedCycForts.contains(predicate))
          predicate = findSelectedGenlPreds(predicate);
        if (! selectedCycForts.contains(predicate))
          continue;
        CycObject collection1 = (CycObject) binding.second();
        if (! selectedCycForts.contains(collection1))
          collection1 = findSelectedGenls(collection1);
        if (! selectedCycForts.contains(collection1))
          continue;
        final Restriction restriction =
          new Restriction(SUBCLASS_RESTRICTION,  // restrictionType
                          (CycFort) predicate,   // property
                          true,                  // isInverseProperty
                          null,                  // hasValue
                          null,                  // valuesFrom
                          collection1,           // allValuesFrom
                          null,                  // someValuesFrom
                          -1,                    // cardinality
                          -1,                    // maxCardinality
                          -1,                    // minCardinality
                          "relationOnlyAll");    // sourceRuleMacroPredicate
        addRestriction(restriction);
        final CycList pair = new CycList(2);
        pair.add(predicate);
        pair.add(collection1);
        relationOnlyAlls.addNew(pair);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    if (! relationOnlyAlls.isEmpty()) {
      sortCycObjects(relationOnlyAlls);
      logger.fine("    relationOnlyAll: " + relationOnlyAlls.toString());
    }
  }
  
  /** Populates the instances of a completely asserted collection.
   *
   * @@param collection the given Cyc collection
   */
  private void populateCompletelyAssertedCollectionInstances(final CycObject collection) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert collection != null : "collection must not be null";
    
    if (! isCompletelyAssertedCollection(collection)) {
      completelyAssertedCollectionInstances = null;
      return;
    }
    try {
      completelyAssertedCollectionInstances = cycAccess.getInstances(collection, inferenceMt);
      for (int i = 0; i < completelyAssertedCollectionInstances.size(); i++)
        if (! selectedCycForts.contains(completelyAssertedCollectionInstances.get(i))) {
          completelyAssertedCollectionInstances = null;
          return;
        }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    sortCycObjects(completelyAssertedCollectionInstances);
    logger.fine("    completelyAssertedCollectionInstances: " + completelyAssertedCollectionInstances.toString());
  }
  
  /** Populates the list of selected individuals that are equal to the given individual.
   *
   * @@param cycObject The term which appears in the first argument position.
   */
  private void populateEquals(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    assert theSetOfOWLSelectedIndividuals != null : "theSetOfOWLSelectedClasses must not be null";
    
    try {
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?INDIVIDUAL");
      final String queryString =
        "(#$and " +
        "  (#$elementOf ?INDIVIDUAL " + theSetOfOWLSelectedIndividuals.cyclify() + ") " +
        "  (#$equals " + cycObject.cyclify() + " ?INDIVIDUAL))";
      final CycList query = cycAccess.makeCycList(queryString);
      equals = cycAccess.queryVariable(queryVariable, query, inferenceMt, (HashMap) null);
      equals.remove(cycObject);
      if (! equals.isEmpty()) {
        sortCycObjects(equals);
        logger.fine("    equals: " + equals.cyclify());
        nonDifferentIndividuals.addAllNew(equals);
      }
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
  }
  
  /** Populates the list of implication rules in which the term appears.
   *
   * @@param cycObject the given term
   */
  private void populateRules(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    if (! (cycObject instanceof CycFort))
      return;
    final String script = "(gather-filtered-el-rule-assertions-for-term " + cycObject.stringApiValue() + selectedCycForts.stringApiValue() + ")";
    CycList gatheredRulesForTerm = new CycList(0);
    try {
      gatheredRulesForTerm = cycAccess.converseList(script);
    }
    catch (Exception e) {
      logger.warning(StringUtils.getStringForException(e));
      return;
    }
    final int gatheredRulesForTerm_size = gatheredRulesForTerm.size();
    final CycList newRules = new CycList(gatheredRulesForTerm_size);
    for (int i = 0; i < gatheredRulesForTerm_size; i++) {
      final CycList gatheredRuleForTerm = (CycList) gatheredRulesForTerm.get(i);
      if (! rules.contains(gatheredRuleForTerm)) {
        rules.add(gatheredRuleForTerm);
        newRules.add(gatheredRuleForTerm);
      }
    }
    if (! newRules.isEmpty())
      logger.fine("    rules: " + newRules.cyclify());
  }
  
  /** Populates the non-definitional ground atomic formulas in which the the
   * predicate is an element of the list of applicable binary predicates and in
   * which the given term appears as the first argument.
   *
   * @@param cycObject The term which appears in the first argument position.
   */
  private void populatePropertyAssertions(final CycObject cycObject) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert cycObject != null : "cycObject must not be null";
    
    CycList candidatePropertyAssertions = null;
    propertyAssertions = new CycList();
    if (applicableBinaryPredicates.isEmpty())
      return;
    if (termsWithNoExtraProperties.contains(cycObject)) {
      logger.finest("      term with no extra properties: " + cycObject.cyclify());
      return;
    }
    try {
      final CycObject canonicalizedObject = (CycObject) cycAccess.getHLCycTerm(cycObject.cyclify());
      if (canonicalizedObject instanceof CycFort) {
        candidatePropertyAssertions = cycAccess.getGafsForPredicates(canonicalizedObject, applicableBinaryPredicates, inferenceMt);
        logger.finest("      candidatePropertyAssertions: " + candidatePropertyAssertions.cyclify());
      }
      else
        return;
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return;
    }
    candidatePropertyAssertions.remove(cycAccess.isa);
    candidatePropertyAssertions.remove(cycAccess.genls);
    for (int i = 0; i < candidatePropertyAssertions.size(); i++) {
      final CycList candidatePropertyAssertion = (CycList) candidatePropertyAssertions.get(i);
      final Object arg2 = candidatePropertyAssertion.third();
      if (arg2 instanceof CycObject) {
        if (selectedCycForts.contains(arg2)) {
          propertyAssertions.add(candidatePropertyAssertion);
          logger.fine("      " + candidatePropertyAssertion.cyclify());
        }
        else if (cycKbSubsetCollection != null)
          logger.finest("      quoted " + ((CycFort) candidatePropertyAssertion.third()).cyclify() + " is not a " + cycKbSubsetCollection.cyclify());
      }
      else {
        propertyAssertions.add(candidatePropertyAssertion);
        logger.fine("      " + candidatePropertyAssertion.cyclify());
      }
    }
    sortCycObjects(propertyAssertions);
  }
  
  /** Returns true if the given predicate is an owl:ObjectProperty.
   *
   * @@param predicate the given predicate
   * @@return true if the given predicate is an owl:ObjectProperty
   */
  private boolean isObjectProperty(final CycObject predicate) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    
    String query =
      "(#$and " +
      "   (#$isa " + predicate.cyclify() + " #$BinaryPredicate) " +
      "   (#$arg1Isa " + predicate.cyclify() + " ?ARG-1) " +
      "   (#$arg2Isa " + predicate.cyclify() + " ?ARG-2) " +
      "   (#$unknownSentence " +
      "       (#$thereExists ?COL-1 " +
      "           (#$thereExists ?XMLTYPE-1 " +
      "               (#$and " +
      "                 (#$owlDataTypeSemanticCorrelation ?XMLTYPE-1 ?COL-1) " +
      "                 (#$genls ?ARG-1 ?COL-1))))) " +
      "   (#$unknownSentence " +
      "       (#$thereExists ?COL-2 " +
      "           (#$thereExists ?XMLTYPE-2 " +
      "               (#$and " +
      "                   (#$owlDataTypeSemanticCorrelation ?XMLTYPE-2 ?COL-2) " +
      "                   (#$genls ?ARG-2 ?COL-2)))))) ";
    if (cycAccess.isQueryTrue(cycAccess.makeCycList(query), inferenceMt, (HashMap) null))
      return true;
    query =
      "(#$and " +
      "  (#$isa " + predicate.cyclify() + " #$VariableArityPredicate) " +
      "  (#$argsIsa " + predicate.cyclify() + " ?ARG) " +
      "  (#$unknownSentence " +
      "      (#$thereExists ?COL " +
      "          (#$thereExists ?XMLTYPE " +
      "              (#$and " +
      "                  (#$owlDataTypeSemanticCorrelation ?XMLTYPE ?COL) " +
      "                  (#$genls ?ARG ?COL)))))) ";   
    return cycAccess.isQueryTrue(cycAccess.makeCycList(query), inferenceMt, (HashMap) null);
  }
  
  /** Returns the object datatype if the given predicate is an owl:DatatypeProperty, otherwise returns null
   *
   * @@param predicate the given predicate
   * @@return the object datatype if the given predicate is an owl:DatatypeProperty, otherwise returns null
   */
  private String getDatatypePropertyDataype(final CycObject predicate) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    
    try {
      final CycVariable arg2Variable = CycObjectFactory.makeCycVariable("?ARG-2");
      final CycVariable xmlTypeVariable = CycObjectFactory.makeCycVariable("?XMLTYPE-2");
      final CycList variables = new CycList();
      variables.add(arg2Variable);
      variables.add(xmlTypeVariable);
      final String queryString =
        "(#$ist #$OWLMappingMt " +
        "  (#$and " +
        "    (#$isa " + predicate.cyclify() + " #$BinaryPredicate) " +
        "    (#$arg2Isa " + predicate.cyclify() + " ?ARG-2) " +
        "    (#$thereExists ?COL-2 " +
        "      (#$and " +
        "        (#$owlDataTypeSemanticCorrelation ?XMLTYPE-2 ?COL-2) " +
        "        (#$genls ?ARG-2 ?COL-2)))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
      logger.finest("    owlDataTypeSemanticCorrelation bindings: " + bindings);
      if (bindings.isEmpty())
        return null;
      final CycList binding = (CycList) bindings.first();
      final CycObject xsdTerm = (CycObject) binding.second(); 
      return translateTermToXMLSchemaDatatype(xsdTerm);
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return null;
    }
  }
  
  /** Returns the translated XML Schema datatype for the given CycL term that represents it, or null if none found.
   *
   * @@param xsdTerm the CycL term that represents an XML Schema datatype
   * @@return the translated XML Schema datatype for the given CycL term that represents it, or null if none found
   */
  private String translateTermToXMLSchemaDatatype(final CycObject xsdTerm) {
    //// Preconditions
    assert xsdTerm != null : "term must not be null";
    
    final String xsdType = xsdTerm.toString();
    if (xsdType.equals("xsd:uriReference"))
      return xsdUriReference;
    else if (xsdType.equals("xsd:decimal"))
      return xsdDecimal;
    else if (xsdType.equals("xsd:float"))
      return xsdDouble;
    else if (xsdType.equals("xsd:date"))
      return xsdDateTime;
    else if (xsdType.equals("xsd:nonNegativeInteger"))
      return xsdNonNegativeInteger;
    else if (xsdType.equals("xsd:integer"))
      return xsdInteger;
    else if (xsdType.equals("xsd:string"))
      return xsdString;
    else
      return null;
  }
  
  /** Examines the argument contraint of the given predicate with respect to the given non-CycObject thing,
   * and returns a new individual if the argument constraint is not mapped to an XML datatype.
   *
   * @@param predicate the restriction property
   * @@param isInverseProperty the indicator for whether the property is expressed as an inverse property
   * @@param thing the restriction owl:hasValue object
   * 
   * @@return a new individual if the argument constraint is not mapped to an XML datatype, otherwise
   * return the given thing
   */
  private Object possiblyCreateIndividual(final CycObject predicate,
                                          final boolean isInverseProperty,
                                          final Object thing) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    assert thing != null : "thing must not be null";

    CycObject argConstraint = null;
    if (isInverseProperty) {
      populateArg1Isas(predicate);
      if (! arg1Isas.isEmpty())
        argConstraint = (CycObject) arg1Isas.first();
    }
    else {
      populateArg2Isas(predicate);
      if (! arg2Isas.isEmpty())
        argConstraint = (CycObject) arg2Isas.first();
    }
    if (argConstraint == null)
      return thing;
    final String translatedTerm = (String) xsdSchemaMappingDictionary.get(argConstraint);
    if (translatedTerm != null)
      return thing;
    final CycNart individualThing = 
      new CycNart(cycAccess.getKnownConstantByName("InstanceNamedFn"),
                  thing.toString(),
                  argConstraint);
    if (! owlSelectedIndividuals.contains(individualThing)) {
      owlSelectedIndividuals.add(individualThing);
      createdIndividualValues.put(individualThing, thing);
      logger.fine("    created individual: " + individualThing.toString());
      return individualThing;
    }
    else
      return thing;
  }
  
  /** Returns the object datatype if the given predicate is an inverse owl:DatatypeProperty, otherwise returns null
   *
   * @@param predicate the given predicate
   * @@return the object datatype if the given predicate is an inverse owl:DatatypeProperty, otherwise returns null
   */
  private String getInverseDatatypePropertyDatatype(final CycObject predicate) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    
    try {
      final CycVariable arg2Variable = CycObjectFactory.makeCycVariable("?ARG-1");
      final CycVariable xmlTypeVariable = CycObjectFactory.makeCycVariable("?XMLTYPE-2");
      final CycList variables = new CycList();
      variables.add(arg2Variable);
      variables.add(xmlTypeVariable);
      final String queryString =
        "(#$ist #$OWLMappingMt " +
        "  (#$and " +
        "    (#$isa " + predicate.cyclify() + " #$BinaryPredicate) " +
        "    (#$arg1Isa " + predicate.cyclify() + " ?ARG-1) " +
        "    (#$arg2Isa " + predicate.cyclify() + " ?ARG-2) " +
        "    (#$owlDataTypeSemanticCorrelation ?XMLTYPE ?COL-1)" +
        "    (#$genls ?ARG-1 ?COL-1)" +
        "    (#$unknownSentence " +
        "      (#$thereExists ?COL-2 " +
        "        (#$thereExists ?XMLTYPE-2 " +
        "          (#$and " +
        "            (#$owlDataTypeSemanticCorrelation ?XMLTYPE-2 ?COL-2) " +
        "            (#$genls ?ARG-2 ?COL-2)))))))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycList bindings = cycAccess.queryVariables(variables, query, inferenceMt, (HashMap) null);
      logger.finest("    inverse owlDataTypeSemanticCorrelation bindings: " + bindings);
      if (bindings.isEmpty())
        return null;
      final CycList binding = (CycList) bindings.first();
      final CycObject xsdTerm = (CycObject) binding.second(); 
      return translateTermToXMLSchemaDatatype(xsdTerm);
    }
    catch (CycApiException e) {
      e.printStackTrace();
      return null;
    }
  }
  
  /** Returns true if the given predicate is an inverse owl:FunctionalProperty.
   *
   * @@param predicate the given predicate
   * @@return true if the given predicate is an inverse owl:FunctionalProperty
   */
  private boolean isFunctionalProperty(final CycObject predicate) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    
    final String query =
      "(#$or " +
      "  (#$isa " + predicate.cyclify() + " #$StrictlyFunctionalSlot) " +
      "  (#$strictlyFunctionalInArgs " + predicate.cyclify() + " 2) " +
      "  (#$argCardinality " + predicate.cyclify() + " 2 1))";
    final boolean result = cycAccess.isQueryTrue(cycAccess.makeCycList(query), inferenceMt,  (HashMap) null);
    return result;
  }
  
  /** Returns true if the given predicate is an inverse owl:InverseFunctionalProperty.
   *
   * @@param predicate the given predicate
   * @@return true if the given predicate is an inverse owl:InverseFunctionalProperty
   */
  private boolean isInverseFunctionalProperty(final CycObject predicate) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert predicate != null : "predicate must not be null";
    
    final String query =
      "(#$or " +
      "  (#$strictlyFunctionalInArgs " + predicate.cyclify() + " 1) " +
      "  (#$argCardinality " + predicate.cyclify() + " 1 1))";
    final boolean result = cycAccess.isQueryTrue(cycAccess.makeCycList(query), inferenceMt,  (HashMap) null);
    return result;
  }
  
  /** Returns true if the given collection is completely asserted.
   *
   * @@param collection the given collection
   * @@return true if the given collection is completely asserted
   */
  private boolean isCompletelyAssertedCollection(final CycObject collection) throws UnknownHostException, IOException, CycApiException {
    //// Preconditions
    assert collection != null : "collection must not be null";
    
    final String query =
      "(#$completelyAssertedCollection " + collection.cyclify() + ")";
    final boolean result = cycAccess.isQueryTrue(cycAccess.makeCycList(query), inferenceMt,  (HashMap) null);
    return result;
  }
  
  /** Returns an XML compliant name for the given term.
   *
   * @@param cycConstant the given term
   * @@return an XML compliant name for the given term
   */
  private String xmlName(final CycConstant cycConstant) {
    //// Preconditions
    assert cycConstant != null : "cycConstant must not be null";
    
    String xmlName = cycConstant.toString();
    if (Character.isDigit(xmlName.charAt(0)))
      xmlName = "N_" + xmlName;
    
    //// Preconditions
    assert xmlName != null : "xmlName must not be null";
    assert xmlName.length() > 0 : "xmlName must not be an empty string";
    
    return xmlName;
  }
  
  /** Adds a new inverse predicate to the export term set.
   *
   * @@param inversePredicate the inverse predicate
   */
  private void addInversePredicate(final CycFort inversePredicate) {
    //// Preconditions
    assert inversePredicate != null : "inversePredicate must not be null";
    assert inversePredicates != null : "inversePredicates must not be null";
    assert selectedCycForts != null : "selectedCycForts must not be null";
    
    if (selectedCycForts.contains(inversePredicate) || inversePredicates.contains(inversePredicate))
      return;
    logger.fine("    creating " + inversePredicate.toString());
    inversePredicates.add(inversePredicate);
  }
  
  /** Displays a list of the exported terms. */
  private void displayExportedTerms() {
    //// Preconditions
    assert percentProgressDictionary != null : "percentProgressDictionary must not be null";
    assert owlSelectedClasses != null : "owlSelectedClasses must not be null";
    assert owlSelectedProperties != null : "owlSelectedProperties must not be null";
    assert inversePredicates != null : "inversePredicates must not be null";
    assert owlSelectedIndividuals != null : "owlSelectedIndividuals must not be null";
    
    for (int i = 0; i < owlSelectedClasses.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedClasses.get(i);
      logger.info(cycObject.cyclify());
    }
    for (int i = 0; i < owlSelectedProperties.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedProperties.get(i);
      logger.info(cycObject.cyclify());
    }
    for (int i = 0; i < inversePredicates.size(); i++) {
      final CycObject cycObject = (CycObject) inversePredicates.get(i);
      logger.info(cycObject.cyclify());
    }
    for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedIndividuals.get(i);
      logger.info(cycObject.cyclify());
    }
  }
  
  /** Populates the OWL export percent progress dictionary, which during term export provides the
   * estimated percent progress at the given term.  Takes into account the expected differning durations of exporting
   * classes vs. properties vs. individuals. */
  private void populatePercentProgressDictionary() {
    //// Preconditions
    assert percentProgressDictionary != null : "percentProgressDictionary must not be null";
    assert owlSelectedClasses != null : "owlSelectedClasses must not be null";
    assert owlSelectedProperties != null : "owlSelectedProperties must not be null";
    assert owlSelectedIndividuals != null : "owlSelectedIndividuals must not be null";
    
    // the weight factors were obtained as the average millisecond duration of a term type on a certain test computer
    final double SELECTED_CLASSES_WEIGHT_FACTOR = 14337.0d;
    final double SELECTED_PROPERTIES_WEIGHT_FACTOR = 789.0d;
    final double SELECTED_INDIVIDUALS_WEIGHT_FACTOR = 216.0d;
    
    final double PERCENT_PROGRESS_RESERVED_FOR_VALIDATION = 2.0d;
    final double selectedClassesWeight = SELECTED_CLASSES_WEIGHT_FACTOR * (double) owlSelectedClasses.size();
    final double selectedPropertiesWeight = SELECTED_PROPERTIES_WEIGHT_FACTOR * (double) owlSelectedProperties.size();
    final double selectedIndividualsWeight = SELECTED_INDIVIDUALS_WEIGHT_FACTOR * (double) owlSelectedIndividuals.size();
    final double totalWeight = selectedClassesWeight + selectedPropertiesWeight + selectedIndividualsWeight;
    final double percentProgressAvailableForTerms = 100.0d - percentProgress - PERCENT_PROGRESS_RESERVED_FOR_VALIDATION;
    assert percentProgressAvailableForTerms > 0.0d : "percentProgressAvailableForTerms (" + percentProgressAvailableForTerms + ") must be positive";
    double percentProgressForTerm = percentProgress;
    final double percentProgressAvailableForClasses = percentProgressAvailableForTerms * selectedClassesWeight / totalWeight;
    final double percentProgressIncrementForClasses = percentProgressAvailableForClasses / (double) owlSelectedClasses.size();
    sortCycObjects(owlSelectedClasses);
    for (int i = 0; i < owlSelectedClasses.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedClasses.get(i);
      percentProgressDictionary.put(cycObject, new Double(percentProgressForTerm));
      percentProgressForTerm += percentProgressIncrementForClasses;
      logger.finest(cycObject.cyclify() + " " + percentProgressForTerm);
    }
    final double percentProgressAvailableForProperties = percentProgressAvailableForTerms * selectedPropertiesWeight / totalWeight;
    final double percentProgressIncrementForProperties = percentProgressAvailableForProperties / (double) owlSelectedProperties.size();
    sortCycObjects(owlSelectedProperties);
    for (int i = 0; i < owlSelectedProperties.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedProperties.get(i);
      percentProgressDictionary.put(cycObject, new Double(percentProgressForTerm));
      percentProgressForTerm += percentProgressIncrementForProperties;
      logger.finest(cycObject.cyclify() + " " + percentProgressForTerm);
    }
    final double percentProgressAvailableForIndividuals = percentProgressAvailableForTerms * selectedIndividualsWeight / totalWeight;
    final double percentProgressIncrementForIndividuals = percentProgressAvailableForIndividuals / (double) owlSelectedIndividuals.size();
    sortCycObjects(owlSelectedIndividuals);
    for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
      final CycObject cycObject = (CycObject) owlSelectedIndividuals.get(i);
      percentProgressDictionary.put(cycObject, new Double(percentProgressForTerm));
      percentProgressForTerm += percentProgressIncrementForIndividuals;
      logger.finest(cycObject.cyclify() + " " + percentProgressForTerm);
    }
  }
  
  /** Initializes the named problem store used to speed up the longer duration queries. */
  private void initializeProblemStores() throws UnknownHostException, IOException, CycApiException {
    cycAccess.initializeNamedInferenceProblemStore(DISJOINT_WITH_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_ISA1_2_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_COND_ISA1_2_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_ISA2_1_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_COND_ISA2_1_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_EXISTS_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_INSTANCE_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_EXISTS_COUNT_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_EXISTS_MAX_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_EXISTS_MIN_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_EXISTS_COUNT_ALL_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_EXISTS_MAX_ALL_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_EXISTS_MIN_ALL_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_EXISTS_ALL_MANY_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(ARG_CARDINALITY_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_CARDINALITY_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(INTER_ARG_FORMATS_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ALL_ONLY_PROBLEM_STORE_NAME, null);
    cycAccess.initializeNamedInferenceProblemStore(RELATION_ONLY_ALL_PROBLEM_STORE_NAME, null);
  }
  
  /** Destroys the named problem store used to speed up the longer duration queries. */
  private void destroyProblemStores() throws UnknownHostException, IOException, CycApiException {
    cycAccess.destroyInferenceProblemStoreByName(DISJOINT_WITH_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_ISA1_2_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_COND_ISA1_2_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_ISA2_1_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_COND_ISA2_1_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_EXISTS_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_INSTANCE_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_EXISTS_COUNT_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_EXISTS_MAX_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_EXISTS_MIN_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_EXISTS_COUNT_ALL_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_EXISTS_MAX_ALL_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_EXISTS_MIN_ALL_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_EXISTS_ALL_MANY_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(ARG_CARDINALITY_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_CARDINALITY_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(INTER_ARG_FORMATS_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ALL_ONLY_PROBLEM_STORE_NAME);
    cycAccess.destroyInferenceProblemStoreByName(RELATION_ONLY_ALL_PROBLEM_STORE_NAME);
  }
  
  /** Initializes the CycL term to OWL term mapping dictionary. */
  private void initializeMappingDictionary() throws UnknownHostException, IOException, CycApiException {
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("Thing"), owlThing);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("Nothing"), owlNothing);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("Ontology"), owlOntology);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("Collection"), owlClass);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OWLDeprecatedClass"), owlDeprecatedClass);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("BinaryPredicate"), rdfProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("TransitiveBinaryPredicate"), owlTransitiveProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("SymmetricBinaryPredicate"), owlSymmetricProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OWLObjectProperty"), owlObjectProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OWLDatatypeProperty"), owlDatatypeProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OWLDeprecatedProperty"), owlDeprecatedProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OntologyRelatingPredicate"), owlOntologyProperty);
    owlClassMappingDictionary.put(cycAccess.getKnownConstantByName("OntologyAnnotationPredicate"), owlAnnotationProperty);
    
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("SubLAtomicTerm"), rdfsLiteral);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("isa"), rdfType);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("genls"), rdfsSubClassOf);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("genlPreds"), rdfsSubPropertyOf);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("comment"), rdfsComment);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("disjointWith"), owlDisjointWith);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("different"), owlDifferentFrom);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("equals"), owlSameAs);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("arg1Isa"), rdfsDomain);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("arg2Isa"), rdfsRange);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("ontologyVersionInfo"), owlVersionInfo);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("ontologyPriorVersion"), owlPriorVersion);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("incompatibleOntology"), owlIncompatibleWith);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("owlDifferentFrom"), owlDifferentFrom);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("backwardsCompatibleOntology"), owlBackwardCompatibleWith);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("inverseBinaryPredicateOf"), owlInverseOf);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("coExtensional"), owlEquivalentClass);
    owlPropertyMappingDictionary.put(cycAccess.getKnownConstantByName("owlRestrictionAllValuesFrom"), owlAllValuesFrom);
    
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("UniformResourceIdentifier"), xsdUriReference);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("UniformResourceLocator"), xsdUriReference);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("Date"), xsdDate);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("SubLRealNumber"), xsdDouble);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("SubLString"), xsdString);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("SubLInteger"), xsdInteger);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("PositiveInteger"), xsdPositiveInteger);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("Integer"), xsdInteger);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("NonNegativeInteger"), xsdNonNegativeInteger);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("SubLBoolean"), xsdBoolean);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("CalendarSecond"), xsdDateTime);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("CalendarDay"), xsdDate);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("CalendarMonth"), xsdGYearMonth);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("CalendarYear"), xsdGYear);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("DayOfMonthType"), xsdGDay);
    xsdSchemaMappingDictionary.put(cycAccess.getKnownConstantByName("GregorianMonthType"), xsdGMonth);
  }
  
  /** Contains information about an Individual node. */
  private class IndividualNodeInfo {
    final String isaString;
    final String owlNameString;
    
    IndividualNodeInfo(final String isaString, final String owlNameString) {
      //// Preconditions
      assert isaString != null : "isaString must not be null";
      assert isaString.length() > 0 : "isaString must not be an empty string";
      assert owlNameString != null : "owlNameString must not be null";
      assert owlNameString.length() > 0 : "owlNameString must not be an empty string";
      
      this.isaString = isaString;
      this.owlNameString = owlNameString;
    }
  }
  
  
  /** Adds the given restriction to the list of restriction objects, subsuming them by cardinality.
   *
   * @@param restriction the given restriction to add
   */
  private void addRestriction(final Restriction restriction) {
    //// Preconditions
    assert restriction != null : "restriction must not be null";
    assert restrictions != null : "restrictions must not be null";
   
    if (restrictions.contains(restriction)) {
      logger.fine("      ignored dup   " + restriction.toString());
      return;
    }
    
    // sort out the existing matching restrictions
    Restriction cardinalityRestriction = null;
    Restriction maxCardinalityRestriction = null;
    Restriction minCardinalityRestriction = null;
    Restriction noCardinalityRestriction = null;
    for (int i = 0; i < restrictions.size(); i++) {
      final Restriction currentRestriction = (Restriction) restrictions.get(i);
      if (currentRestriction.matches(restriction)) {
        if (currentRestriction.cardinality > -1)
          cardinalityRestriction = currentRestriction;
        else if (currentRestriction.maxCardinality > -1)
          maxCardinalityRestriction = currentRestriction;
        else if (currentRestriction.minCardinality > -1)
          minCardinalityRestriction = currentRestriction;
        else 
          noCardinalityRestriction = currentRestriction;
      }
    }
    if (cardinalityRestriction != null) {
      // existing fixed cardinality trumps any new cardinality restriction
      logger.fine("      ignored       " + restriction.toString());
      return;
    }
    if (restriction.cardinality > -1) {
      // fixed cardinality trumps any previous max or min
      removeMatchingRestrictions(restriction);
      restrictions.add(restriction);
      logger.fine("      added new     " + restriction.toString());
      return;
    }
    if (restriction.maxCardinality > -1) {
      if (cardinalityRestriction != null || 
         (maxCardinalityRestriction != null && 
          maxCardinalityRestriction.maxCardinality >= restriction.maxCardinality)) {
        logger.fine("      ignored       " + restriction.toString());
        return;
      }
      if (maxCardinalityRestriction != null) {
        // max cardinality trumps any lower max 
        restrictions.remove(maxCardinalityRestriction);
        logger.fine("      removed       " + maxCardinalityRestriction.toString());
      }
      restrictions.add(restriction);
      logger.fine("      added new     " + restriction.toString());
      return;
    }
    if (restriction.minCardinality > -1) {
      if (cardinalityRestriction != null || 
         (minCardinalityRestriction != null && 
          minCardinalityRestriction.minCardinality <= restriction.minCardinality)) {
        logger.fine("      ignored       " + restriction.toString());
        return;
      }
      if (minCardinalityRestriction != null) {
        // min cardinality trumps any higher min
        restrictions.remove(minCardinalityRestriction);
        logger.fine("      removed       " + minCardinalityRestriction.toString());
      }
      restrictions.add(restriction);
      logger.fine("      added new     " + restriction.toString());
      return;
    }
    if (cardinalityRestriction == null &&
        maxCardinalityRestriction == null &&
        minCardinalityRestriction == null &&
        noCardinalityRestriction == null) {
      restrictions.add(restriction);
      logger.fine("      added new     " + restriction.toString());
    }
    else 
      logger.fine("      ignored redundant " + restriction.toString());
  }
  
  /** Remove any restrictions matching the given restriction
   *
   * @@param restriction the given restriction
   */
  private void removeMatchingRestrictions(final Restriction restriction) {
    //// Preconditions
    assert restriction != null : "restriction must not be null";
    assert restrictions != null : "restrictions must not be null";
   
    final Iterator restrictions_iter = restrictions.iterator();
    while (restrictions_iter.hasNext()) {
      final Restriction existingRestriction = (Restriction) restrictions_iter.next();
      if (existingRestriction.matches(restriction)) {
        restrictions_iter.remove();
        logger.fine("      removed       " + existingRestriction.toString());
      }
    }
  }
    
  /** the subject is an instance of the restriction */
  private final int TYPE_RESTRICTION = 0;
  
  /** the subject is a spec of the restriction */
  private final int SUBCLASS_RESTRICTION = 1;
  
  /** Contains information about a restriction. */
  private class Restriction implements Comparable {
    
    /** the restriction type */
    final int restrictionType;
    
    /** the restriction property */
    final CycObject property;
    
    /** the indicator for whether the property is expressed as an inverse property */
    final boolean isInverseProperty;
    
    /** the restriction owl:hasValue, or null if not present */
    final Object hasValue;
    
    /** the restriction owl:valuesFrom, or null if not present */
    final CycObject valuesFrom;
    
    /** the restriction owl:allValuesFrom, or null if not present */
    final CycObject allValuesFrom;
    
    /** the restriction owl:someValuesFrom, or null if not present */
    final CycObject someValuesFrom;
    
    /** the restriction cardinality, or -1 if not used */
    final int cardinality;
    
    /** the restriction maximum cardinality, or -1 if not used */
    final int maxCardinality;
    
    /** the restriction minimum cardinality, or -1 if not used */
    final int minCardinality;
    
    /** the source rule macro predicate as a string for debugging */
    final String sourceRuleMacroPredicate;
    
    
    /** Constructs a new Restriction object.
     *
     * @@param restrictionType the restriction type
     * @@param property the restriction property
     * @@param isInverseProperty the indicator for whether the property is expressed as an inverse property
     * @@param hasValue the restriction owl:hasValue, or null if not present
     * @@param allValuesFrom the restriction owl:allValuesFrom, or null if not present
     * @@param valuesFrom the restriction owl:valuesFrom, or null if not present
     * @@param someValuesFrom the restriction owl:someValuesFrom, or null if not present
     * @@param cardinality the restriction cardinality, or -1 if not used
     * @@param maxCardinality the restriction maximum cardinality, or -1 if not used
     * @@param minCardinality the restriction minimum cardinality, or -1 if not used
     * @@param sourceRuleMacroPredicate the distinguishing CycL source rule macro predicate for debugging, e.g. relationAllExists
     */
    Restriction(final int restrictionType,
                final CycObject property,
                final boolean isInverseProperty,
                final Object hasValue,
                final CycObject valuesFrom,
                final CycObject allValuesFrom,
                final CycObject someValuesFrom,
                final int cardinality,
                final int maxCardinality,
                final int minCardinality,
                final String sourceRuleMacroPredicate) {
      
      //// Preconditions
      assert restrictionType == TYPE_RESTRICTION || restrictionType == SUBCLASS_RESTRICTION :
        "restrictionType must be TYPE_RESTRICTION or SUBCLASS_RESTRICTION";
      assert property != null : "property must not be null";
      assert sourceRuleMacroPredicate != null : "sourceRuleMacroPredicate must not be null";
      assert sourceRuleMacroPredicate.length() > 0 : "sourceRuleMacroPredicate must not be an empty string";

      this.restrictionType = restrictionType;
      this.property = property;
      this.isInverseProperty = isInverseProperty;
      this.hasValue = hasValue;
      this.valuesFrom = valuesFrom;
      this.allValuesFrom = allValuesFrom;
      this.someValuesFrom = someValuesFrom;
      this.cardinality = cardinality;
      this.maxCardinality = maxCardinality;
      this.minCardinality = minCardinality;
      this.sourceRuleMacroPredicate = sourceRuleMacroPredicate;
    }
    
    /** Returns a string representation of this object. 
     *
     * @@return a string representation of this object
     */
    public String toString() {
      final StringBuffer stringBuffer = new StringBuffer(300);
      stringBuffer.append("[Restriction: ");
      if (isInverseProperty)
        stringBuffer.append(" inverse property ");
      stringBuffer.append(property.toString());
      if (hasValue != null) {
        stringBuffer.append(" hasValue: ");
        stringBuffer.append(hasValue.toString());
      }
      if (valuesFrom != null) {
        stringBuffer.append(" valuesFrom: ");
        stringBuffer.append(valuesFrom.toString());
      }
      if (allValuesFrom != null) {
        stringBuffer.append(" allValuesFrom: ");
        stringBuffer.append(allValuesFrom.toString());
      }
      if (someValuesFrom != null) {
        stringBuffer.append(" someValuesFrom: ");
        stringBuffer.append(someValuesFrom.toString());
      }
      if (cardinality > -1) {
        stringBuffer.append(" cardinality: ");
        stringBuffer.append(cardinality);
      }
      if (maxCardinality > -1) {
        stringBuffer.append(" maxCardinality: ");
        stringBuffer.append(maxCardinality);
      }
      if (minCardinality > -1) {
        stringBuffer.append(" minCardinality: ");
        stringBuffer.append(minCardinality);
      }
      stringBuffer.append(" source: ");
      stringBuffer.append(sourceRuleMacroPredicate.toString());
      stringBuffer.append(']');
      return stringBuffer.toString();
    }
    
    /** Compares the given object to this object, returning -1 if less than, 0 if equal, and +1 if greater than.
     *
     * @@param  obj the comparison object
     * @@return -1 if the this object is less than the comparison object, 0 if equal, and +1 if greater than
     */
    public int compareTo(Object obj) {
      assert obj instanceof Restriction : "obj (" + obj.getClass().getName() + ") must be a Restriction";
      
      final Restriction that = (Restriction) obj;
      if (this.restrictionType == TYPE_RESTRICTION && that.restrictionType == SUBCLASS_RESTRICTION)
        return -1;
      else if (this.restrictionType == SUBCLASS_RESTRICTION && that.restrictionType == TYPE_RESTRICTION)
        return 1;
      
      final int propertyComparison = property.compareTo(that.property);
      if (propertyComparison != 0)
        return propertyComparison;
      
      if (! this.isInverseProperty && that.isInverseProperty)
        return -1;
      else if (this.isInverseProperty && ! that.isInverseProperty)
        return 1;
      
      if (this.hasValue != null && that.hasValue == null)
        return -1;
      else if (this.hasValue == null && that.hasValue != null)
        return 1;
      
      if (this.valuesFrom != null && that.valuesFrom == null)
        return -1;
      else if (this.valuesFrom == null && that.valuesFrom != null)
        return 1;
      else if (this.valuesFrom != null && that.valuesFrom != null)
        return this.valuesFrom.compareTo(that.valuesFrom);
      
      if (this.allValuesFrom != null && that.allValuesFrom == null)
        return -1;
      else if (this.allValuesFrom == null && that.allValuesFrom != null)
        return 1;
      else if (this.allValuesFrom != null && that.allValuesFrom != null)
        return this.allValuesFrom.compareTo(that.allValuesFrom);
      
      if (this.someValuesFrom != null && that.someValuesFrom == null)
        return -1;
      else if (this.someValuesFrom == null && that.someValuesFrom != null)
        return 1;
      else if (this.someValuesFrom != null && that.someValuesFrom != null)
        return this.someValuesFrom.compareTo(that.someValuesFrom);
      
      return 0;
    }
    
    /** Returns true if the given restriction object matches this one.
     *
     * @@param the given object
     * @@return true if the given object is equal to this one
     */
    public boolean matches(final Restriction that) {
      assert that != null : "that must not be null";
      
      if (this.restrictionType != that.restrictionType ||
          (! this.property.equals(that.property)) ||
          this.isInverseProperty != that.isInverseProperty)
        return false;
      
      if ((this.hasValue == null && that.hasValue != null) ||
          (this.hasValue != null && that.hasValue == null))
        return false;
      if (this.hasValue != null && ! this.hasValue.equals(that.hasValue))
        return false;
      
      if ((this.valuesFrom == null && that.valuesFrom != null) ||
          (this.valuesFrom != null && that.valuesFrom == null))
        return false;
      if (this.valuesFrom != null && ! this.valuesFrom.equals(that.valuesFrom))
        return false;
      
      if ((this.allValuesFrom == null && that.allValuesFrom != null) ||
          (this.allValuesFrom != null && that.allValuesFrom == null))
        return false;
      if (this.allValuesFrom != null && ! this.allValuesFrom.equals(that.allValuesFrom))
        return false;
      
      if ((this.someValuesFrom == null && that.someValuesFrom != null) ||
          (this.someValuesFrom != null && that.someValuesFrom == null))
        return false;
      if (this.someValuesFrom != null && ! this.someValuesFrom.equals(that.someValuesFrom))
        return false;
      
      return true;
    }
    
    /** Returns true if the given object is equal to this one.
     *
     * @@param the given object
     * @@return true if the given object is equal to this one
     */
    public boolean equals(Object obj) {
      assert obj != null : "obj must not be null";
      assert obj instanceof Restriction : "obj (" + obj.getClass().getName() + ") must be a Restriction";
      
      final Restriction that = (Restriction) obj;
      if (! this.matches(that))
        return false;
      else return
        this.cardinality == that.cardinality &&
        this.maxCardinality == that.maxCardinality &&
        this.minCardinality == that.minCardinality;
    }
  }
  
  //// Internal Rep
d944 4
d949 7
a955 65
  private static final String cycOwlXMLBase = "http://www.cyc.com/2004/06/04/cyc";
  private static final String xmlNamespace = "http://www.w3.org/XML/1998/namespace";
  private static final String xsdNamespace = "http://www.w3.org/2001/XMLSchema#";
  private static final String rdfNamespace = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  private static final String rdfsNamespace = "http://www.w3.org/2000/01/rdf-schema#";
  private static final String rdfType = rdfNamespace + "type";
  private static final String rdfsLiteral = rdfsNamespace + "Literal";
  private static final String rdfsSubClassOf = rdfsNamespace + "subClassOf";
  private static final String rdfsSubPropertyOf = rdfsNamespace + "subPropertyOf";
  private static final String rdfProperty = rdfNamespace + "Property";
  private static final String rdfsComment = rdfsNamespace + "comment";
  private static final String rdfsDomain = rdfsNamespace + "domain";
  private static final String rdfsRange = rdfsNamespace + "range";
  private static final String owlNamespace = "http://www.w3.org/2002/07/owl#";
  private static final String swrlNamespace = "http://www.w3.org/2003/11/swrl#";
  private static final String rulemlNamespace = "http://www.w3.org/2003/11/swrl#";
  private static final String owlThing = owlNamespace + "Thing";
  private static final String owlNothing = owlNamespace + "Nothing";
  private static final String owlOntology = owlNamespace + "Ontology";
  private static final String owlClass = owlNamespace + "Class";
  private static final String owlDeprecatedClass = owlNamespace + "DeprecatedClass";
  private static final String owlTransitiveProperty = owlNamespace + "TransitiveProperty";
  private static final String owlSymmetricProperty = owlNamespace + "SymmetricProperty";
  private static final String owlObjectProperty = owlNamespace + "ObjectProperty";
  private static final String owlDatatypeProperty = owlNamespace + "DatatypeProperty";
  private static final String owlDeprecatedProperty = owlNamespace + "DeprecatedProperty";
  private static final String owlOntologyProperty = owlNamespace + "OntologyProperty";
  private static final String owlAnnotationProperty = owlNamespace + "AnnotationProperty";
  private static final String owlDisjointWith = owlNamespace + "disjointWith";
  private static final String owlDifferentFrom = owlNamespace + "differentFrom";
  private static final String owlSameAs = owlNamespace + "sameAs";
  private static final String owlOntologyVersionInfo = owlNamespace + "versionInfo";
  private static final String owlPriorVersion = owlNamespace + "priorVersion";
  private static final String owlIncompatibleWith = owlNamespace + "incompatibeWith";
  private static final String owlBackwardCompatibleWith = owlNamespace + "backwardCompatibeWith";
  private static final String owlInverseOf = owlNamespace + "inverseOf";
  private static final String owlEquivalentClass = owlNamespace + "equivalentClass";
  private static final String owlAllValuesFrom = owlNamespace + "allValuesFrom";
  private static final String owlInverseFunctionalProperty = owlNamespace + "InverseFunctionalProperty";
  private static final String owlFunctionalProperty = owlNamespace + "FunctionalProperty";
  
  private static final String xsdUriReference = xsdNamespace + "uriReference";
  private static final String xsdDate = xsdNamespace + "date";
  private static final String xsdDecimal = xsdNamespace + "decimal";
  private static final String xsdDouble = xsdNamespace + "double";
  private static final String xsdString = xsdNamespace + "string";
  private static final String xsdInteger = xsdNamespace + "integer";
  private static final String xsdInt = xsdNamespace + "int";
  private static final String xsdNonNegativeInteger = xsdNamespace + "nonNegativeInteger";
  private static final String xsdPositiveInteger = xsdNamespace + "positiveInteger";
  private static final String xsdBoolean = xsdNamespace + "boolean";
  private static final String xsdDateTime = xsdNamespace + "dateTime";
  private static final String xsdGYearMonth = xsdNamespace + "gYearMonth";
  private static final String xsdGYear = xsdNamespace + "gYear";
  private static final String xsdGDay = xsdNamespace + "gDay";
  private static final String xsdGMonth = xsdNamespace + "gMonth";
  
  private static final String swrlArgument1 = swrlNamespace + "argument1";
  private static final String swrlArgument2 = swrlNamespace + "argument2";
  private static final String swrlClassAtom = swrlNamespace + "ClassAtom";
  private static final String swrlClassPredicate = swrlNamespace + "classPredicate";
  private static final String swrlDatavaluedPropertyAtom = swrlNamespace + "datavaluedPropertyAtom";
  private static final String swrlIndividualPropertyAtom = swrlNamespace + "individualPropertyAtom";
  private static final String swrlPropertyPredicate = swrlNamespace + "propertyPredicate";
  private static final String swrlVariable = swrlNamespace + "Variable";
a956 9
  private static final String rulemlBody = rulemlNamespace + "body";
  private static final String rulemlHead = rulemlNamespace + "head";
  private static final String rulemlImp = rulemlNamespace + "Imp";
  private static final String rulemlVar = rulemlNamespace + "var";
  
  private static final String guidComment = "Permanent Global Unique ID for the associated concept.";
  private static final String externalIDComment = "Permanent ID string for the associated non-atomic concept.";
  private static final String nonAtomicFormulaComment = "This is the non-atomic concept expressed in CycL (Cyc's knowledge representation language).";
  private static final String literalValueComment = "Literal value of an individual which was created to contain a datatype value for a property whose domain or range is more general than the corresponding datatype value.";
d959 2
a960 2
  private Element rdfNode = null;
  private Element owlOntologyNode = null;
d962 1
a962 1
  private Element rdfsCommentNode = null;
a963 1
  private String externalID;
a965 2
  private String label;
  private String nonAtomicFormula;
d969 2
a970 2
  private CycList arg1Isas;
  private CycList arg2Isas;
a973 1
  private CycList equals;
a974 26
  private List restrictions;
  private CycList interArgIsa1_2s;
  private CycList interArgIsa2_1s;
  private CycList relationAllOnlys;
  private CycList relationOnlyAlls;
  private CycList relationAllExists;
  private CycList relationExistsAlls;
  private CycList typeGenls;
  private CycList relationAllInstances;
  private CycList relationInstanceAlls;
  private CycList relationInstanceExists;
  private CycList relationExistsInstances;
  private CycList relationAllExistsCounts;
  private CycList relationAllExistMaxs;
  private CycList relationAllExistMins;
  private CycList relationExistsCountAlls;
  private CycList relationExistsMinAlls;
  private CycList relationExistsMaxAlls;
  //TODO replace relationExistsAllMany with relationExistsAll (its genlPred)
  private CycList relationExistsAllManys;
  private CycList arg2Cardinalities = new CycList(0);
  private CycList interArgCardinalities1_2 = new CycList(0);
  private CycList interArgCardinalities2_1 = new CycList(0);
  private CycList interArgFormats1_2 = new CycList(0);
  private CycList interArgFormats2_1 = new CycList(0);
  private CycList completelyAssertedCollectionInstances = new CycList(0);
d976 4
a979 25
  private CycList allKbSubsetCollections = new CycList(0);
  private final HashMap owlClassMappingDictionary = new HashMap();
  private final HashMap owlPropertyMappingDictionary = new HashMap();
  private final HashMap xsdSchemaMappingDictionary = new HashMap();
  private final CycList inversePredicates = new CycList();
  private HashMap nartXMLNames = new HashMap();
  private int xmlNameSequence = 1;
  
  /** the dictionary of term --> OWL defining DOM element */
  private final HashMap termElementDictionary = new HashMap();
  
  /** the dictionary of term --> list of isas */
  private final HashMap termIsasDictionary = new HashMap();
  
  /** the dictionary of term --> list of genls */
  private final HashMap termGenlsDictionary = new HashMap();
  
  /** the dictionary of individual --> IndividualNodeInfo */
  private final HashMap individualNodeInfoDictionary = new HashMap();
  
  /* the list of individuals that are the same as one or more other individuals */
  private final CycList nonDifferentIndividuals = new CycList();
  
  /** the list of registered listeners */
  private final List listeners = new ArrayList();
a980 531
  /** the identifier that is returned with each progress event notification, allowing multiple OWL exports to
   * be managed by the caller */
  private final UUID uuid;
  
  /** the problem store name for the disjointWith query */
  private final static String DISJOINT_WITH_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgIsa1-2 query */
  private final static String INTER_ARG_ISA1_2_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgCondIsa1-2 query */
  private final static String INTER_ARG_COND_ISA1_2_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgIsa2-1 query */
  private final static String INTER_ARG_ISA2_1_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgCondIsa2-1 query */
  private final static String INTER_ARG_COND_ISA2_1_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllExists query */
  private final static String RELATION_ALL_EXISTS_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllInstance query */
  private final static String RELATION_ALL_INSTANCE_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationInstanceAll query */
  private final static String RELATION_INSTANCE_ALL_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllExistsCount query */
  private final static String RELATION_ALL_EXISTS_COUNT_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllExistsMax query */
  private final static String RELATION_ALL_EXISTS_MAX_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllExistsMin query */
  private final static String RELATION_ALL_EXISTS_MIN_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationExistsCountAll query */
  private final static String RELATION_ALL_EXISTS_COUNT_ALL_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationExistsMaxAll query */
  private final static String RELATION_EXISTS_MAX_ALL_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationExistsMinAll query */
  private final static String RELATION_EXISTS_MIN_ALL_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationExistsAllMany query */
  private final static String RELATION_EXISTS_ALL_MANY_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the argCardinality query */
  private final static String ARG_CARDINALITY_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgCardinality query */
  private final static String INTER_ARG_CARDINALITY_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the interArgFormats query */
  private final static String INTER_ARG_FORMATS_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationAllOnly query */
  private final static String RELATION_ALL_ONLY_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for the relationOnlyAll query */
  private final static String RELATION_ONLY_ALL_PROBLEM_STORE_NAME = UUID.randomUUID().toString(); 
  
  /** the problem store name for all queries on a given term */
  private String allQueriesProblemStoreName = null; 
  
  private static final boolean PROBLEM_STORE_REUSE = false;
  
  /** the dictionary of created individual values, term --> value object */
  private final HashMap createdIndividualValues = new HashMap();
  
  /** the indicator that the OWL export should be limited to OpenCyc content */
  private boolean isExportLimitedToOpenCycContent = false;
  
  /** the indicator that the OWL export should include rules in SWRL (Semantic Web Rule Language) */
  private boolean areRulesExported = false;
  
  /** the set of exported rules */
  private final Set rules = new HashSet();
  
  /** the license text */
  private String licenseText = null;
  
  //// Main
  
  /** Executes test methods for this class.
   *
   * @@param args not used
   */
  public static void main(final String[] args) {
//    try {
//      final CycAccess cycAccess = new CycAccess("localhost", 3640);
//      final CycList terms = cycAccess.makeCycList("(#$TransportationDevice #$providerOfMotiveForce #$transporter #$vehicle)");
//      final ExportOwl exportOwl = new ExportOwl(cycAccess);
//      exportOwl.selectedCycForts = terms;
//      exportOwl.cycKbSubsetFilterGuid = null;
//      exportOwl.outputPath = "/home/reed/ontology.owl";
//      exportOwl.useResearchCycOntology = false;
//      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
//      exportOwl.setAreRulesExported(true);
//      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
//      cycAccess.close();
//      System.exit(0);
//    }
//    catch (Exception e) {
//      System.err.println(e.getMessage());
//      e.printStackTrace();
//      System.exit(1);
//    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$EventOrRoleConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/event-or-role-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$ClimateConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/climate-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$FamilyRelationsConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/family-relations-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$GeodesyConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/geodesy-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$IndustrialConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/industrial-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$MereotopologyConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/mereotopology-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$MilitaryFacilityConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/military-facility-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$MilitaryOrganizationConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/military-organization-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$TerrainConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/terrain-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$WaterBodyConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/water-body-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$VegetationConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/vegetation-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$BuildingConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/building-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$MilitaryFacilityConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/military-facility-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM #$UnitOfMeasureConcept)";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/unit-of-measure-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM (#$ClumpConceptTypeByDomainFn #$Addresses-Geography-CSC))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/addresses-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM (#$ClumpConceptTypeByDomainFn #$Connections-Spatial-CSC))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/connections-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM (#$ClumpConceptTypeByDomainFn #$DirectionAndOrientationVocabulary-Spatial-CSC))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/direction-and-orientation-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM (#$ClumpConceptTypeByDomainFn #$ProximityAndLocation-Spatial-CSC))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/promity-and-location-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    try {
      final CycAccess cycAccess = new CycAccess();
      final String queryString = "(#$conceptOfDomain ?TERM (#$ClumpConceptTypeByDomainFn #$SurfacesPortalsAndCavities-Spatial-CSC))";
      final CycList query = cycAccess.makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?TERM");
      final CycObject mt = cycAccess.inferencePSC;
      final CycList terms = cycAccess.queryVariable(queryVariable, query, mt, null);
      final ExportOwl exportOwl = new ExportOwl(cycAccess);
      exportOwl.selectedCycForts = terms;
      exportOwl.cycKbSubsetFilterGuid = null;
      exportOwl.areRulesExported = true;
      exportOwl.outputPath = "/home/reed/surfaces-portals-and-cavities-concept.owl";
      exportOwl.useResearchCycOntology = false;
      exportOwl.setInferenceMt(cycAccess.makeELMt("CurrentWorldDataCollectorMt-NonHomocentric"));
      exportOwl.export(ExportOwl.EXPORT_SELECTED_TERMS);
      cycAccess.close();
    }
    catch (Exception e) {
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(1);
    }
    
    System.exit(0);  // kill all threads
  }
@


1.2
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@@


1.1
log
@New files cloned from DAML export files to support the Web Ontology Language.
@
text
@d3 43
a45 9
import  org.w3c.dom.*;
import  org.apache.xerces.dom.*;
import  org.apache.xml.serialize.*;
import  java.io.*;
import  java.net.*;
import  java.util.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.api.*;
import  org.opencyc.util.*;
d50 1
a50 1
 * @@version $Id: ExportOwl.java,v 1.23 2002/10/25 23:23:57 stephenreed Exp $
d53 1
a53 1
 * <p>Copyright 2003 Cycorp, Inc., license is open source GNU LGPL.
d71 297
a367 303
public class ExportOwl {

    /**
     * Command indicating that the OWL export contains only the marked KB
     * subset terms.  cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.  cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the upward closure.
     */
    public static final int EXPORT_KB_SUBSET = 1;

    /**
     * Command indicating that the OWL export contains the marked KB
     * subset terms plus all the terms in the upward closure to #$Thing.
     * cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.
     */
    public static final int EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE = 2;

    /**
     * Command indicating that the OWL export contains the collections whose
     * direct or indirect genl is the collection term indentified by rootTermGuid.
     * cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the export set.
     */
    public static final int EXPORT_KB_SUBSET_BELOW_TERM = 3;

    /**
     * Command indicating that the OWL export contains all the terms in the KB.
     */
    public static final int EXPORT_ENTIRE_KB = 4;

    /**
     * The command performed by the OWL extract process.
     */
    protected int exportCommand = 0;

    /**
     * The default verbosity of the OWL export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected static final int DEFAULT_VERBOSITY = 3;

    /**
     * Sets verbosity of the OWL export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public int verbosity = DEFAULT_VERBOSITY;

    /**
     * Indicates whether the upward closure of terms should be exported.  If so, the
     * upward closure terms are filtered by cycKbSubsetFilterGuid below.
     */
    public boolean includeUpwardClosure = false;

    /**
     * The CycKBSubsetCollection whose elements are exported to OWL.
     */
    public CycFort cycKbSubsetCollection = null;

    /**
     * The CycKBSubsetCollection whose elements are exported to OWL.
     */
    public Guid cycKbSubsetCollectionGuid = null;

    /**
     * The guid which identifies the CycKBSubsetCollection whose elements are exported to OWL if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    public Guid cycKbSubsetFilterGuid = null;

    /**
     * The CycKBSubsetCollection whose elements are exported to OWL if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    protected CycFort cycKbSubsetFilter = null;

    /**
     * List of applicable binary predicates.
     */
    public CycList applicableBinaryPredicates = new CycList();


    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The OWL export contains the collections whose direct or indirect genl is
     * the collection term indentified by this value.
     */
    public Guid rootTermGuid = null;

    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The OWL export contains the collections whose direct or indirect genl is
     * this collection term.
     */
    public CycFort rootTerm = null;

    /**
     * The OWL export path and file name.
     */
    public String outputPath = "export.owl";

    /**
     * The OWL comment that titles the output file.
     */
    public String title = "EELD Shared Ontology";

    private static final String xmlNamespace = "http://www.w3.org/XML/1998/namespace";
    private static final String rdfNamespace = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    private static final String rdfsNamespace = "http://www.w3.org/2000/01/rdf-schema#";
    private static final String owlNamespace = "http://www.w3.org/2002/07/owl#";
    private static final String cycOwlNamespace = "http://www.cyc.com/2002/04/08/cyc#";
    private static final String owlThing = "http://www.w3.org/2002/07/owl#Thing";
    private static final String owlProperty = "http://www.w3.org/2002/07/owl#Property";
    private static final String owlTransitiveProperty = "http://www.w3.org/2002/07/owl#TransitiveProperty";
    private static final String owlClass = "http://www.w3.org/2002/07/owl#Class";
    private static final String rdfsType = "http://www.w3.org/2000/01/rdf-schema#type";
    private static final String rdfsLiteral = "http://www.w3.org/2000/01/rdf-schema#Literal";
    private static final String guidComment =
        "Permanent Global Unique ID for the associated concept.";
    private CycAccess cycAccess;
    private Document document = new DocumentImpl();
    private String documentUrl = null;
    private Element rdf = null;
    private Element owlOntology = null;
    private Element owlVersionInfo = null;
    private Element rdfsComment = null;
    private Guid guid;
    private String name;
    private ArrayList owlSelectedConstants = new ArrayList();
    private CycConstant cycConstant;
    private String comment;
    private CycList isas;
    private CycList genls;
    private CycList genlPreds;
    private CycConstant arg1Isa;
    private CycConstant arg2Isa;
    private CycConstant arg1Format;
    private CycConstant arg2Format;
    private CycList disjointWiths;
    private CycList coExtensionals;
    private CycList propertyAssertions;
    private ArrayList owlSelectedClasses = new ArrayList();
    private ArrayList owlSelectedProperties = new ArrayList();
    private ArrayList owlSelectedIndividuals = new ArrayList();

    /**
     * Constructs a new ExportOwl object given the CycAccess object.
     *
     * @@param cycAccess the CycAccess object which manages the api connection
     */
    public ExportOwl (CycAccess cycAccess) {
        Log.makeLog();
        this.cycAccess = cycAccess;
    }

    /**
     * Exports the desired KB content into OWL.
     */
    public void export (int exportCommand) throws UnknownHostException, IOException, CycApiException {
        this.exportCommand = exportCommand;
        setup();
        if (verbosity > 2)
            Log.current.println("Getting terms from Cyc");
        CycList selectedConstants = new CycList();
        CycList selectedCycForts = null;
        if (exportCommand == ExportOwl.EXPORT_ENTIRE_KB)
            selectedCycForts = cycAccess.getAllInstances(cycAccess.thing);
        else if ((exportCommand == ExportOwl.EXPORT_KB_SUBSET) ||
            (exportCommand == ExportOwl.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
            selectedCycForts = cycAccess.getAllInstances(cycKbSubsetCollection);
        }
        else {
            // EXPORT_KB_SUBSET_BELOW_TERM
            selectedCycForts = cycAccess.getAllSpecs(rootTerm);
            selectedCycForts.add(rootTerm);
        }
        if (verbosity > 2)
            Log.current.println("Selected " + selectedCycForts.size() + " CycFort terms");
        if (includeUpwardClosure) {
            CycList upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
            if (verbosity > 2)
                Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
            selectedCycForts.addAll(upwardClosureCycForts);
            if (verbosity > 2)
                Log.current.println("All selected " + selectedCycForts.size() + " CycFort terms");
        }
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort selectedCycFort = (CycFort)selectedCycForts.get(i);
            if (selectedCycFort instanceof CycConstant)
                selectedConstants.add(selectedCycFort);
        }
        if (verbosity > 2)
            Log.current.println("Sorting " + selectedConstants.size() + " CycConstant terms");
        Collections.sort(selectedConstants);
        if (verbosity > 2)
            Log.current.println("Removing non-binary properties and partitioning by type.");
        for (int i = 0; i < selectedConstants.size(); i++) {
            CycConstant cycConstant = (CycConstant)selectedConstants.get(i);
            if (verbosity > 2) {
                if ((verbosity > 5) && (i % 100 == 0))
                    Log.current.println("... " + cycConstant.cyclify());
            }
            if (cycAccess.isCollection(cycConstant)) {
                owlSelectedConstants.add(cycConstant);
                owlSelectedClasses.add(cycConstant);
            }
            else if (cycAccess.isUnaryPredicate(cycConstant))
                // Do not export (for now) Cyc unary predicates, as they cannot be easily expressed in OWL.
                continue;
            else if (cycAccess.isBinaryPredicate(cycConstant)) {
                owlSelectedConstants.add(cycConstant);
                owlSelectedProperties.add(cycConstant);
            }
            else if (cycAccess.isFunction(cycConstant))
                // Do not export (for now) Cyc functions, as they cannot be expressed in OWL.
                continue;
            else if (cycAccess.isPredicate(cycConstant))
                // Do not export Cyc (for now) arity 3+ predicates, as they cannot be easily expressed in OWL.
                continue;
            else if (cycAccess.isIndividual(cycConstant)) {
                owlSelectedConstants.add(cycConstant);
                owlSelectedIndividuals.add(cycConstant);
            }
        }

        //createConstantNode("PhysicalDevice");
        if (verbosity > 2)
            Log.current.println("Building OWL model");

        for (int i = 0; i < owlSelectedClasses.size(); i++) {
            CycConstant cycConstant = (CycConstant) owlSelectedClasses.get(i);
            if (verbosity > 2)
                Log.current.print(cycConstant + "  Collection");
            createConstantNode(cycConstant);
        }
        for (int i = 0; i < owlSelectedProperties.size(); i++) {
            CycConstant cycConstant = (CycConstant) owlSelectedProperties.get(i);
            if (verbosity > 2)
                Log.current.print(cycConstant + "  BinaryPredicate");
            createConstantNode(cycConstant);
        }

        for (int i = 0; i < owlSelectedIndividuals.size(); i++) {
            CycConstant cycConstant = (CycConstant) owlSelectedIndividuals.get(i);
            if (verbosity > 2)
                Log.current.println(cycConstant + "  Individual");
            createConstantNode(cycConstant);
        }

        if (verbosity > 2)
            Log.current.println("Writing OWL output to " + outputPath);
        OutputFormat outputFormat = new OutputFormat(document, "UTF-8", true);
        BufferedWriter owlOut = new BufferedWriter(new FileWriter(outputPath));
        XMLSerializer xmlSerializer = new XMLSerializer(owlOut, outputFormat);
        xmlSerializer.asDOMSerializer();
        xmlSerializer.serialize(document);
        owlOut.close();
        if (verbosity > 2)
            Log.current.println("OWL export completed");
    }

    /**
     * Sets up the OWL export process.
     */
    protected void setup () throws UnknownHostException, IOException, CycApiException {
        createRdfNode();
        createOwlOntologyNode();
        createCycGuidNode();

        if (exportCommand == ExportOwl.EXPORT_ENTIRE_KB) {
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting Entire KB subset");
        }
        else if (exportCommand == ExportOwl.EXPORT_KB_SUBSET) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
        }
        else if (exportCommand == ExportOwl.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            includeUpwardClosure = true;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() +
                                   "\n  plus upward closure to #$Thing filtered by " + cycKbSubsetFilter.cyclify());
        }
        else if (exportCommand == ExportOwl.EXPORT_KB_SUBSET_BELOW_TERM) {
            rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            cycKbSubsetCollection = cycKbSubsetFilter;
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() +
                                   "\n  filtered by " + cycKbSubsetFilter.cyclify());
        }
        else {
            System.err.println("Invalid export comand " + exportCommand);
            System.exit(1);
        }
d369 33
a401 49


    /**
     * Creates an RDF node.
     */
    protected void createRdfNode () {
        rdf = document.createElementNS(rdfNamespace, "rdf:RDF");
        rdf.setAttribute("xmlns:rdf", rdfNamespace);
        rdf.setAttribute("xmlns:rdfs", rdfsNamespace);
        rdf.setAttribute("xmlns:owl", owlNamespace);
        rdf.setAttribute("xmlns", cycOwlNamespace);
        document.appendChild(rdf);
    }

    /**
     * Creates a OWL Ontology node.
     */
    protected void createOwlOntologyNode () {
        owlOntology = document.createElementNS(owlNamespace, "owl:Ontology");
        owlOntology.setAttribute("about", "");
        rdf.appendChild(owlOntology);
        owlVersionInfo = document.createElementNS(owlNamespace, "owl:versionInfo");
        owlVersionInfo.appendChild(document.createTextNode("$Id: ExportOwl.java,v 1.23 2003/03/31 13:46:57 stephenreed Exp $"));
        owlOntology.appendChild(owlVersionInfo);
        rdfsComment = document.createElementNS(rdfsNamespace, "rdfs:comment");
        rdfsComment.appendChild(document.createTextNode(title));
        owlOntology.appendChild(rdfsComment);
    }

    /**
     * Creates a OWL node for a single Cyc Constant.
     * @@parameter cycConstant the CycConstant from which the OWL node is created
     */
    protected void createConstantNode (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        guid = cycConstant.getGuid();
        populateComment(cycConstant);
        populateIsas(cycConstant);
        populatePropertyAssertions(cycConstant);
        if (cycAccess.isCollection(cycConstant))
            createClassNode(cycConstant);
        else if (cycAccess.isBinaryPredicate(cycConstant))
            createPropertyNode(cycConstant);
        else if (cycAccess.isIndividual(cycConstant))
            createIndividualNode(cycConstant);
        else {
            if (verbosity > 0)
                Log.current.println("Unhandled constant: " + cycConstant.toString());
        }
d403 2
a404 181

    /**
     * Creates a OWL class node for a single Cyc collection.
     * @@parameter cycConstant the Cyc collection from which the OWL class node is created
     */
    protected void createClassNode (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        populateGenls(cycConstant);
        populateDisjointWiths(cycConstant);
        populateCoExtensionals(cycConstant);
        Element classNode = document.createElementNS(owlNamespace, "owl:Class");
        rdf.appendChild(classNode);
        classNode.setAttributeNS(rdfNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
        String label = null;
        label = cycAccess.getPluralGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            Log.current.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        classNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        classNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        classNode.appendChild(guidNode);
        Element sameClassAsNode;
        if (cycConstant.equals(cycAccess.thing)) {
            sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlThing);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.binaryPredicate)) {
            sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlProperty);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.getKnownConstantByName("TransitiveBinaryPredicate"))) {
            sameClassAsNode = document.createElementNS(owlNamespace, "owl:equivalentClass");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlTransitiveProperty);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.collection)) {
            sameClassAsNode = document.createElementNS(owlNamespace, "equivalentClass");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", owlClass);
            classNode.appendChild(sameClassAsNode);
        }
        if (isas != null)
            for (int i = 0; i < isas.size(); i++) {
                Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
                typeNode.setAttributeNS(rdfNamespace,
                                        "rdf:resource",
                                        translateTerm((CycConstant)isas.get(i)));
                classNode.appendChild(typeNode);
            }
        if (genls != null)
            for (int i = 0; i < genls.size(); i++) {
                Element subClassNode = document.createElementNS(rdfsNamespace, "rdfs:subClassOf");
                subClassNode.setAttributeNS(rdfNamespace,
                                            "rdf:resource",
                                            translateTerm((CycConstant)genls.get(i)));
                classNode.appendChild(subClassNode);
            }
        if (disjointWiths != null)
            for (int i = 0; i < disjointWiths.size(); i++) {
                Element disjointWithNode = document.createElementNS(owlNamespace, "owl:disjointWith");
                disjointWithNode.setAttributeNS(rdfNamespace,
                                                "rdf:resource",
                                                translateTerm((CycConstant)disjointWiths.get(i)));
                classNode.appendChild(disjointWithNode);
            }
        if (coExtensionals != null)
            for (int i = 0; i < coExtensionals.size(); i++) {
                sameClassAsNode = document.createElementNS(owlNamespace, "equivalentClass");
                sameClassAsNode.setAttributeNS(rdfNamespace,
                                               "rdf:resource",
                                               translateTerm((CycConstant)coExtensionals.get(i)));
                classNode.appendChild(sameClassAsNode);
            }
        createPropertyAssertionNodes(classNode);
    }


    /**
     * Creates a property assertions node for the given Element.
     *
     * @@param element the given element
     */
    protected void createPropertyAssertionNodes (Element node)
        throws UnknownHostException, IOException, CycApiException {
        for (int i = 0; i < propertyAssertions.size(); i++) {
            CycList propertyAssertion = (CycList) propertyAssertions.get(i);
            CycConstant property = (CycConstant) propertyAssertion.first();
            Object value = propertyAssertion.third();
            Element propertyAssertionNode = document.createElement(property.toString());
            if (value instanceof String ||
                value instanceof Integer)
                propertyAssertionNode.appendChild(document.createTextNode(guid.toString()));
            else
                propertyAssertionNode.setAttributeNS(rdfNamespace,
                                           "rdf:resource",
                                           translateTerm((CycConstant) value));
            node.appendChild(propertyAssertionNode);
        }
    }

    /**
     * Creates a OWL individual node for a single Cyc individual.
     *
     * @@parameter cycConstant the Cyc individual from which the OWL individual node is created
     */
    protected void createIndividualNode (CycConstant cycConstant)
        throws UnknownHostException, IOException, CycApiException {
        if (isas == null || isas.size() == 0)
            return;
        Log.current.println("  Isas :" + isas.cyclify());
        CycConstant isa = bestIsaForIndividual();
        Log.current.println("  best isa: " + isa.cyclify());
        Element individualNode = document.createElement(isa.toString());
        rdf.appendChild(individualNode);
        individualNode.setAttributeNS(rdfsNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
        String label = cycAccess.getSingularGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            Log.current.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        individualNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        individualNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        individualNode.appendChild(guidNode);
        for (int i = 0; i < propertyAssertions.size(); i++) {
            CycList propertyAssertion = (CycList) propertyAssertions.get(i);
            if (this.verbosity > 5)
                Log.current.println("    " + propertyAssertion.cyclify());
            CycConstant property = (CycConstant) propertyAssertion.first();
            Object value = propertyAssertion.third();
            Element propertyAssertionNode = document.createElement(property.toString());
            if (value instanceof String ||
                value instanceof Integer)
                propertyAssertionNode.appendChild(document.createTextNode(guid.toString()));
            else
                propertyAssertionNode.setAttributeNS(rdfNamespace,
                                           "rdf:resource",
                                           translateTerm((CycConstant) value));
            individualNode.appendChild(propertyAssertionNode);
        }
        createPropertyAssertionNodes(individualNode);
    }

    /**
     * Returns the best isa for the current Individual term.
     *
     * @@return the best isa for the current Individual term
     */
    protected CycConstant bestIsaForIndividual ()
        throws UnknownHostException, IOException, CycApiException {
        CycConstant bestIsa = (CycConstant) isas.get(0);
        if (isas.size() == 1)
            return bestIsa;
        CycList candidateIsas = new CycList();
        for (int i = 0; i < isas.size(); i++) {
            CycConstant isa = (CycConstant) isas.get(i);
            if (! cycAccess.isQuotedCollection(isa))
                candidateIsas.add(isa);
        }
        if (candidateIsas.size() == 0)
            return bestIsa;
        else if (candidateIsas.size() == 1)
            return (CycConstant) candidateIsas.get(0);
        else {
            bestIsa = (CycConstant) cycAccess.getMinCol(candidateIsas);
            if (verbosity > 0)
                Log.current.println("    candidateIsas: " + candidateIsas +
                                    " best-isa: " + bestIsa);
            return bestIsa;
        }
d406 137
a542 23


    /**
     * Creates the OWL node that defines the guid property.  Note that there is
     * no rdfs:domain statement because Cyc's guid relationship applies to predicates,
     * collections and individuals, but in OWL properties are not instances of Thing.
     * The absence of the rdfs:domain restriction allows the guid property to be applied
     * to Cyc predicates.
     */
    protected void createCycGuidNode () {
        Element propertyNode = document.createElementNS(owlNamespace, "owl:FunctionalProperty");
        rdf.appendChild(propertyNode);
        propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", "guid");
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
        labelNode.appendChild(document.createTextNode("guid"));
        propertyNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(guidComment));
        propertyNode.appendChild(commentNode);
        Element rangeNode = document.createElementNS(owlNamespace, "rdfs:range");
        rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", rdfsLiteral);
        propertyNode.appendChild(rangeNode);
d544 37
a580 3

    /**
     * Creates a OWL property node for a single Cyc binary predicate.
d582 2
a583 1
     * @@parameter cycConstant the Cyc binary predicate from which the OWL property node is created
d585 7
a591 69
    protected void createPropertyNode (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        populateGenlPreds(cycConstant);
        populateArg1Isa(cycConstant);
        populateArg2Isa(cycConstant);
        populateArg1Format(cycConstant);
        populateArg2Format(cycConstant);
        Element propertyNode;
        if ((arg1Format != null) && arg1Format.equals("SingleEntry"))
            propertyNode = document.createElementNS(owlNamespace, "owl:InverseFunctionalProperty");
        else if ((arg2Format != null) && arg2Format.equals("SingleEntry"))
            propertyNode = document.createElementNS(owlNamespace, "owl:FunctionalProperty");
        else
            propertyNode = document.createElementNS(owlNamespace, "rdf:Property");
        rdf.appendChild(propertyNode);
        propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        labelNode.setAttributeNS(xmlNamespace, "xml:lang", "en");
        String label = null;
        label = cycAccess.getGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            Log.current.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        propertyNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        propertyNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        propertyNode.appendChild(guidNode);
        if (genlPreds != null)
            for (int i = 0; i < genlPreds.size(); i++) {
                Element subPropertyOfNode = document.createElementNS(owlNamespace, "rdfs:subPropertyOf");
                subPropertyOfNode.setAttributeNS(rdfNamespace, "rdf:resource", "#" + genlPreds.get(i).toString());
                propertyNode.appendChild(subPropertyOfNode);
            }
        if (arg1Isa != null) {
            Element domainNode = document.createElementNS(owlNamespace, "rdfs:domain");
            domainNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg1Isa));
            propertyNode.appendChild(domainNode);
        }
        if (arg2Isa != null) {
            Element rangeNode = document.createElementNS(owlNamespace, "rdfs:range");
            rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg2Isa));
            propertyNode.appendChild(rangeNode);
        }
        createPropertyAssertionNodes(propertyNode);
    }

    /**
     * Translates a Cyc term into a kind of OWL node: OWL Thing, OWL class, OWL property or
     * OWL transitive property.
     *
     * @@parameter cycConstant the Cyc term which is to be translated into a kind of OWL node.
     * @@return the kind of OWL node: OWL Thing, OWL class, OWL property or
     * OWL transitive property
     */
    protected String translateTerm (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        if (cycConstant.equals(cycAccess.thing))
            return  owlThing;
        else if (cycConstant.equals(cycAccess.collection))
            return  owlClass;
        else if (cycConstant.equals(cycAccess.binaryPredicate))
            return  owlProperty;
        else if (cycConstant.equals(cycAccess.getKnownConstantByName("TransitiveBinaryPredicate")))
            return  owlTransitiveProperty;
        else
            return  "#" + cycConstant.toString();
d593 2
a594 3

    /**
     * Populates the comment for a Cyc term.
d596 1
a596 1
     * @@parameter cycConstant the Cyc term for which the comment is obtained.
d598 6
a603 3
    protected void populateComment (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        comment = cycAccess.getComment(cycConstant);
d605 22
a626 3

    /**
     * Removes terms from the given list which are not elements of cycKbSubsetFilter.
d628 30
a657 19
     * @@parameter constants the given list of constants which is to be filtered
     * @@return the filtered list
     */
    protected ArrayList applyCycKbSubsetFilter (CycList constants)
        throws UnknownHostException, IOException, CycApiException{
        if (verbosity > 2)
            Log.current.println("Applying " + cycKbSubsetFilter.cyclify() + " filter");
        if (constants.size() == 0)
            return  constants;
        ArrayList result = new ArrayList();
        for (int i = 0; i < constants.size(); i++) {
            Object object = constants.get(i);
            if ((object instanceof CycConstant) &&
                cycAccess.isa((CycConstant) object, cycKbSubsetFilter))
                    result.add(object);
            else if (verbosity > 4)
                Log.current.println(" dropping " + object);
        }
        return  result;
d659 2
a660 3

    /**
     * Removes unselected terms from the given list.
d662 1
a662 2
     * @@parameter constants the given list of constants which is to be filtered
     * @@return the filtered list
d664 2
a665 12
    protected CycList filterSelectedConstants (CycList constants) {
        if (constants.size() == 0)
            return  constants;
        CycList result = new CycList();
        for (int i = 0; i < constants.size(); i++) {
            Object object = constants.get(i);
            if (isFilteredOwlSelectedConstant(object))
                result.add(object);
            else if (verbosity > 4)
                Log.current.println(" dropping " + object);
        }
        return  result;
d667 2
a668 4

    /**
     * Substitutes more general collection constants for functional collection
     * terms.
d670 1
a670 3
     * @@parameter cycForts the given list of cycForts which is to be processed
     * @@return the list of collection constant terms resulting from the substitution
     * of more general cycConstants for cycNarts
d672 2
a673 15
    protected CycList substituteGenlConstantsForNarts (CycList cycForts)
    throws UnknownHostException, IOException, CycApiException {
        CycList result = new CycList();
        for (int i = 0; i < cycForts.size(); i++) {
            CycFort cycFort = (CycFort) cycForts.get(i);
            if (cycFort instanceof CycConstant)
                result.add(cycFort);
            else {
                CycList genls = cycAccess.getGenls(cycFort);
                if (verbosity > 0)
                    Log.current.println(" substituting genls " + genls + " for " + cycFort);
                result.addAllNew(genls);
            }
        }
        return  result;
d675 2
a676 5


    /**
     * Return True iff the object is a selected constant. (OWL does not now
     * contain non-binary predicates nor function terms.)
d678 1
a678 2
     * @@parameter object the object under consideration as a selected constant
     * @@return True iff the object is a selected constant
d680 2
a681 2
    protected boolean isFilteredOwlSelectedConstant (Object object) {
        return  owlSelectedConstants.contains(object);
d683 2
a684 3

    /**
     * Return True iff the object is a instance of the desired KB subset collection
d686 1
a686 2
     * @@parameter object the object under consideration as an instance of the desired KB
     * subset collection
d688 2
a689 6
    protected boolean isFilteredSelectedConstant (Object object)
    throws UnknownHostException, IOException, CycApiException {
        if (!(object instanceof CycConstant))
            return  false;
        else
            return  cycAccess.isa(cycConstant, cycKbSubsetCollection);
d691 2
a692 3

    /**
     * Populates the isas for a Cyc term.
d694 1
a694 1
     * @@parameter cycConstant the Cyc term for which the isas are obtained.
d696 2
a697 6
    protected void populateIsas (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {

        isas = cycAccess.getIsas(cycConstant);
        isas = substituteGenlConstantsForNarts(isas);
        isas = filterSelectedConstants(isas);
d699 2
a700 3

    /**
     * Populates the genls for a Cyc term.
d702 1
a702 1
     * @@parameter cycConstant the Cyc term for which the genls are obtained.
d704 16
a719 5
    protected void populateGenls (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        genls = cycAccess.getGenls(cycConstant);
        genls = substituteGenlConstantsForNarts(genls);
        genls = filterSelectedConstants(genls);
d721 6
a726 3

    /**
     * Populates the genlPreds for a Cyc predicate.
d728 1
a728 1
     * @@parameter cycConstant the Cyc predicate for which the genlPreds are obtained.
d730 424
a1153 4
    protected void populateGenlPreds (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        genlPreds = cycAccess.getGenlPreds(cycConstant);
        genlPreds = filterSelectedConstants(genlPreds);
d1155 361
d1517 1891
a3407 12
    /**
     * Populates the argument 1 type constaint for a Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate for which the argument 1 type constaint is obtained.
     */
    protected void populateArg1Isa (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        CycList arg1Isas = cycAccess.getArg1Isas(cycConstant);
        arg1Isas = substituteGenlConstantsForNarts(arg1Isas);
        arg1Isas = filterSelectedConstants(arg1Isas);
        if (arg1Isas.size() > 0)
            arg1Isa = (CycConstant)arg1Isas.first();
d3409 95
a3503 1
            arg1Isa = null;
d3505 91
a3595 12

    /**
     * Populates the argument 2 type constaint for a Cyc predicate.
     * @@parameter cycConstant the Cyc predicate for which the argument 2 type constaint is obtained.
     */
    protected void populateArg2Isa (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        CycList arg2Isas = cycAccess.getArg2Isas(cycConstant);
        arg2Isas = substituteGenlConstantsForNarts(arg2Isas);
        arg2Isas = filterSelectedConstants(arg2Isas);
        if (arg2Isas.size() > 0)
            arg2Isa = (CycConstant)arg2Isas.first();
d3597 667
a4263 1
            arg2Isa = null;
d4265 751
a5015 3

    /**
     * Populates the argument 1 format for a Cyc predicate.
d5017 42
a5058 7
     * @@parameter cycConstant the Cyc predicate for which the argument 1 format is obtained.
     */
    protected void populateArg1Format (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        CycList arg1Formats = cycAccess.getArg1Formats(cycConstant);
        if (arg1Formats.size() > 0)
            arg1Format = (CycConstant)arg1Formats.first();
d5060 2
a5061 3

    /**
     * Populates the argument 2 format for a Cyc predicate.
d5063 1
a5063 1
     * @@parameter cycConstant the Cyc predicate for which the argument 2 format is obtained.
d5065 38
a5102 5
    protected void populateArg2Format (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        CycList arg2Formats = cycAccess.getArg2Formats(cycConstant);
        if (arg2Formats.size() > 0)
            arg2Format = (CycConstant)arg2Formats.first();
d5104 2
a5105 3

    /**
     * Populates the disjointWiths for a Cyc collection.
d5107 2
a5108 1
     * @@parameter cycConstant the Cyc collection for which the disjointWiths are obtained.
d5110 45
a5154 5
    protected void populateDisjointWiths (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        disjointWiths = cycAccess.getDisjointWiths(cycConstant);
        disjointWiths = substituteGenlConstantsForNarts(disjointWiths);
        disjointWiths = filterSelectedConstants(disjointWiths);
d5156 2
a5157 3

    /**
     * Populates the coExtensionals for a Cyc collection.
d5159 2
a5160 1
     * @@parameter cycConstant the Cyc collection for which the coExtensionals are obtained.
d5162 33
a5194 11
    protected void populateCoExtensionals (CycConstant cycConstant)
    throws UnknownHostException, IOException, CycApiException {
        try {
            coExtensionals = cycAccess.getCoExtensionals(cycConstant);
        }
        catch (CycApiException e) {
            e.printStackTrace();
            return;
        }
        coExtensionals = substituteGenlConstantsForNarts(coExtensionals);
        coExtensionals = filterSelectedConstants(coExtensionals);
d5196 2
a5197 5

    /**
     * Populates the non-definitional ground atomic formulas in which the the
     * predicate is an element of the list of applicable binary predicates and in
     * which the given term appears as the first argument.
d5199 2
a5200 1
     * @@parameter cycConstant the term which appears in the first argument position
d5202 689
a5890 18
    protected void populatePropertyAssertions (CycConstant cycConstant)
    throws UnknownHostException, IOException, CycApiException {
        CycList candidatePropertyAssertions = null;
        propertyAssertions = new CycList();
        try {
            candidatePropertyAssertions =
                cycAccess.getGafs(cycConstant,
                                  applicableBinaryPredicates);
        }
        catch (CycApiException e) {
            e.printStackTrace();
            return;
        }
        for (int i = 0; i < candidatePropertyAssertions.size(); i++) {
            CycList candidatePropertyAssertion = (CycList) candidatePropertyAssertions.get(i);
            if (isFilteredOwlSelectedConstant(candidatePropertyAssertion.third()))
                propertyAssertions.add(candidatePropertyAssertion);
        }
d5892 4
a5895 50

    /**
     * Gather the updward closure of the selected CycForts with regard to isas and genls
     * for collection terms, and with regard to genlPreds for predicate terms.
     *
     * @@parameter the selected CycForts
     * @@return the updward closure of the selected CycForts with regard to genls
     * for collection terms, and with regard to genlPreds for predicate terms
     */
    protected CycList gatherUpwardClosure (CycList selectedCycForts) throws UnknownHostException, IOException,
            CycApiException {
        CycList upwardClosure = new CycList();
        cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (cycAccess.isCollection(cycFort)) {
                CycList genls = new CycList();
                genls.addAllNew(cycAccess.getAllIsa(cycFort));
                genls.addAllNew(cycAccess.getAllGenls(cycFort));
                for (int j = 0; j < genls.size(); j++) {
                    CycFort genl = null;
                    try {
                        genl = (CycFort) genls.get(j);
                    }
                    catch (ClassCastException e) {
                        Log.current.println("***** Invalid genl: " + genls.get(j));
                        continue;
                    }
                    if ((!upwardClosure.contains(genl)) && (!selectedCycForts.contains(genl)) && cycAccess.isa(genl,
                            cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println("Upward closure genl " + genl);
                        upwardClosure.add(genl);
                    }
                }
            }
            else if ((cycFort instanceof CycConstant) && (cycAccess.isBinaryPredicate((CycConstant)cycFort))) {
                CycList genlPreds = cycAccess.getAllGenlPreds((CycConstant)cycFort);
                for (int j = 0; j < genlPreds.size(); j++) {
                    CycFort genlPred = (CycFort)genlPreds.get(j);
                    if ((!upwardClosure.contains(genlPred)) && (!selectedCycForts.contains(genlPred))
                            && cycAccess.isa(genlPred, cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println("Upward closure genlPred " + genlPred);
                        upwardClosure.add(genlPred);
                    }
                }
            }
        }
        return  upwardClosure;
d5897 3
@

