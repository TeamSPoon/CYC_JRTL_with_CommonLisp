head	1.45;
access;
symbols
	PRE_1_0:1.43;
locks; strict;
comment	@# @;


1.45
date	2006.10.21.17.01.59;	author dmiles;	state Exp;
branches;
next	1.44;

1.44
date	2006.10.18.14.21.30;	author dmiles;	state dead;
branches;
next	1.43;

1.43
date	2002.10.09.19.35.45;	author stephenreed;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.09.15.17.31;	author stephenreed;	state Exp;
branches;
next	1.41;

1.41
date	2002.10.09.04.01.57;	author stephenreed;	state Exp;
branches;
next	1.40;

1.40
date	2002.10.02.14.09.41;	author stephenreed;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.02.14.05.43;	author stephenreed;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.02.13.59.44;	author stephenreed;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.01.15.21.15;	author stephenreed;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.01.02.53.21;	author stephenreed;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.30.23.20.54;	author stephenreed;	state Exp;
branches;
next	1.34;

1.34
date	2002.09.30.14.33.29;	author stephenreed;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.27.15.09.48;	author stephenreed;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.27.14.42.04;	author stephenreed;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.25.15.10.15;	author stephenreed;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.24.21.36.19;	author stephenreed;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.23.16.15.12;	author stephenreed;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.23.15.45.50;	author stephenreed;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.23.14.47.35;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.22.22.27.56;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.22.20.32.06;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.20.22.38.50;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.20.14.01.40;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.20.02.33.33;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.19.19.54.13;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.18.17.20.17;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.18.14.39.16;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.18.03.47.02;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.17.15.18.13;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.16.13.55.22;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.16.09.16.30;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.16.08.52.34;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.23.58.51;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.13.22.55.51;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.12.15.03.24;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.12.03.22.11;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.12.00.48.32;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.14.46.54;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.11.08.31.30;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.11.03.41.52;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.10.21.14.09;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.13.02.03;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.10.03.31.39;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.09.13.39.56;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.09.03.19.25;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental classes.
@
text
@package org.opencyc.xml;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;

import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycNart;
import org.opencyc.util.Log;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import ViolinStrings.Strings;

import com.hp.hpl.jena.rdf.arp.ALiteral;
import com.hp.hpl.jena.rdf.arp.ARP;
import com.hp.hpl.jena.rdf.arp.AResource;
import com.hp.hpl.jena.rdf.arp.ParseException;
import com.hp.hpl.jena.rdf.arp.StatementHandler;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.impl.ResourceImpl;


/**
 * Abstract class to provide common functions for importing DAML xml content.
 * Subclasses will provide additional behavior tailored for the particular
 * DAML imports.<p>
 * <p>
 * The Another RDF Parser (ARP) is used to parse the input DAML document.
 * This class implements statement callbacks from ARP. Each triple in the
 * input file causes a call on one of the statement methods.
 * The same triple may occur more than once in a file, causing repeat calls
 * to the method.
 *
 * @@version $Id: ImportDaml.java,v 1.43 2002/10/09 19:35:45 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public abstract class ImportDaml implements StatementHandler {

    /**
     * The default verbosity of this application.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public static final int DEFAULT_VERBOSITY = 3;

    /**
     * When T, indicates that the import is performed othwise when false
     * indicates that the DAML document should be parsed but not imported.
     */
    public boolean actuallyImport = true;

    /**
     * Sets verbosity of this application.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public int verbosity = DEFAULT_VERBOSITY;

    /**
     * Another RDF Parser instance.
     */
    protected ARP arp;

    /**
     * Cyc terms which have semantic counterparts in DAML.
     * DAML term --> Cyc term
     */
    protected static HashMap equivalentDamlCycTerms;

    /**
     * Ontology library nicknames, which become namespace identifiers
     * upon import into Cyc.
     * namespace uri --> ontologyNickname
     */
    protected HashMap ontologyNicknames;

    /**
     * Previously imported term used to avoid redundant assertions.
     */
    protected DamlTermInfo previousDamlTermInfo = null;

    /**
     * URL string which defines the imported daml ontology
     */
    protected String damlOntologyDefiningURLString;

    /**
     * URL which defines the imported daml ontology
     */
    protected CycFort damlOntologyDefiningURL;

    /**
     * Ontology import microtheory name.
     */
    protected String importMtName;

    /**
     * Ontology import microtheory.
     */
    protected CycConstant importMt;

    /**
     * The current DAML Restriction object being constructed from sequential
     * RDF triples.
     */
    protected DamlRestriction damlRestriction;

    /**
     * CycAccess object to manage api connection the the Cyc server.
     */
    public CycAccess cycAccess;

    /**
     * The name of the KB Subset collection which identifies ontology import
     * terms in Cyc.
     */
    public String kbSubsetCollectionName;

    /**
     * The KB Subset collection which identifies ontology import
     * terms in Cyc.
     */
    protected CycConstant kbSubsetCollection;

    /**
     * The #$BookkeepingMt.
     */
    protected CycConstant bookkeepingMt;

    /**
     * Character encoding scheme of the DAML input (e.g. UTF-8), specified
     * if not ASCII.
     */
    protected String characterEncoding = null;

    /**
     * Constructs a new ImportDaml object.
     */
    public ImportDaml() {
        arp = new ARP();
        arp.setStatementHandler(this);
    }

    /**
     * Initializes the ImportDaml object.
     */
    public void initialize ()
        throws IOException, UnknownHostException, CycApiException {
        kbSubsetCollection = cycAccess.getKnownConstantByName(kbSubsetCollectionName);
        bookkeepingMt = cycAccess.getKnownConstantByName("BookkeepingMt");
    }

    /**
     * Parses and imports the given DAML URL.
     *
     * @@param damlOntologyDefiningURLString the URL to import
     * @@param importMtName the microtheory into which DAML content is asserted
     */
    public void importDaml (String damlOntologyDefiningURLString,
                            String importMtName)
        throws IOException, CycApiException {
        importDaml (damlOntologyDefiningURLString,
                    importMtName,
                    null);
    }

    /**
     * Parses and imports the given DAML URL.
     *
     * @@param damlOntologyDefiningURLString the URL to import
     * @@param importMtName the microtheory into which DAML content is asserted
     * @@param characterEncoding the character encoding scheme of the DAML imput
     * (e.g. "UTF-8", used when not the default ASCII
     */
    public void importDaml (String damlOntologyDefiningURLString,
                            String importMtName,
                            String characterEncoding)
        throws IOException, CycApiException {
        this.damlOntologyDefiningURLString = damlOntologyDefiningURLString;
        this.importMtName = importMtName;
        this.characterEncoding = characterEncoding;
        if (verbosity > 0) {
            if (characterEncoding == null)
                Log.current.println("\nImporting " + damlOntologyDefiningURLString +
                                    "\ninto " + importMtName);
            else
                Log.current.println("\nImporting " + damlOntologyDefiningURLString +
                                    " encoding " + characterEncoding +
                                    "\ninto " + importMtName);
        }
        importMt = cycAccess.getKnownConstantByName(importMtName);
        damlOntologyDefiningURL =
            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                        damlOntologyDefiningURLString);
        Log.current.println("Defining URL " + damlOntologyDefiningURL.cyclify());
        CycList gaf = new CycList();
        gaf.add(cycAccess.getKnownConstantByName("xmlNameSpace"));
        String nickname = (String) ontologyNicknames.get(damlOntologyDefiningURLString);
        if (nickname == null)
            throw new RuntimeException("Nickname not found for " +
                                       damlOntologyDefiningURLString);
        gaf.add(nickname);
        gaf.add(damlOntologyDefiningURL);
        cycAccess.assertGaf(gaf, importMt);
        Log.current.println("\nStatements\n");
        //cycAccess.traceOn();
        InputStreamReader in;
        URL url;
        try {
            File ff = new File(damlOntologyDefiningURLString);
            if (characterEncoding == null)
                in = new InputStreamReader(new FileInputStream(ff));
            else
                in = new InputStreamReader(new FileInputStream(ff), characterEncoding);
            url = ff.toURL();
        }
        catch (Exception ignore) {
            try {
                url = new URL(damlOntologyDefiningURLString);
                if (characterEncoding == null)
                    in = new InputStreamReader(url.openStream());
                else
                    in = new InputStreamReader(url.openStream(), characterEncoding);
            }
            catch (Exception e) {
                System.err.println("ARP: Failed to open: " + damlOntologyDefiningURLString);
                System.err.println("    " + ParseException.formatMessage(ignore));
                System.err.println("    " + ParseException.formatMessage(e));
                return;
            }
        }
        try {
            arp.load(in, url.toExternalForm());
        }
        catch (IOException e) {
            System.err.println("Error: " + damlOntologyDefiningURLString + ": " + ParseException.formatMessage(e));
        }
        catch (SAXException sax) {
            System.err.println("Error: " + damlOntologyDefiningURLString + ": " + ParseException.formatMessage(sax));
        }
        if (verbosity > 0)
            Log.current.println("\nDone importing " + damlOntologyDefiningURLString + "\n");
    }

    /**
     * Provides the ARP statement handler for triple having an Object.
     *
     * @@param subject the RDF Triple Subject
     * @@param predicate the RDF Triple Predicate
     * @@param object the RDF Triple Object
     */
    public void statement(AResource subject, AResource predicate, AResource object) {
        try {
            if (subject.isAnonymous()) {
            processRestrictionSubject(subject, predicate, object);
                return;
            }
            if (object.isAnonymous()) {
                processRestrictionObject(subject, predicate, object);
                return;
            }
            DamlTermInfo subjectTermInfo = resource(subject, null);
            DamlTermInfo predicateTermInfo = resource(predicate, null);
            DamlTermInfo objectTermInfo = resource(object, predicateTermInfo);
            displayTriple(subjectTermInfo,
                          predicateTermInfo,
                          objectTermInfo);
            importTriple(subjectTermInfo,
                         predicateTermInfo,
                         objectTermInfo);
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
        }
    }

    /**
     * Provides the ARP statement handler for triple having an Literal.
     *
     * @@param subject the RDF Triple Subject
     * @@param predicate the RDF Triple Predicate
     * @@param literal the RDF Triple Literal
     */
    public void statement(AResource subject, AResource predicate, ALiteral literal) {
        try {
            if (subject.isAnonymous()) {
                processRestrictionSubject(subject, predicate, literal);
            }
            else {
                DamlTermInfo subjectTermInfo = resource(subject, null);
                DamlTermInfo predicateTermInfo = resource(predicate, null);
                DamlTermInfo literalTermInfo = literal(literal);
                displayTriple(subjectTermInfo,
                              predicateTermInfo,
                              literalTermInfo);

                importTriple(subjectTermInfo,
                             predicateTermInfo,
                             literalTermInfo);
            }
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
        }
    }

    /**
     * Imports the RDF triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param predicateTermInfo the predicate DamlTermInfo object
     * @@param objLitTermInfo the object or literal DamlTermInfo object
     */
    protected void importTriple (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo predicateTermInfo,
                                  DamlTermInfo objLitTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        if (! actuallyImport)
            return;
        if (predicateTermInfo.isURI)
            predicateTermInfo.coerceToNamespace();
        String damlPredicate = predicateTermInfo.toString();
        if (! subjectTermInfo.hasEquivalentCycTerm()) {
            if (damlPredicate.equals("#$isa")) {
                importIsa(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$genls")) {
                // TODO generalize for argument order in KB.
                if (predicateTermInfo.constantName.startsWith("dmoz:narrow"))
                    importGenls(objLitTermInfo, subjectTermInfo);
                else
                    importGenls(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("daml:versionInfo")) {
                importVersionInfo(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("daml:imports")) {
                importImports(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$comment")) {
                importComment(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$nameString")) {
                importNameString(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$synonymousExternalConcept")) {
                importSynonymousExternalConcept(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$arg1Isa")) {
                importArg1Isa(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$arg2Isa")) {
                importArg2Isa(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$conceptuallyRelated")) {
                importConceptuallyRelated(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$containsInformationAbout")) {
                importContainsInformationAbout(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (damlPredicate.equals("#$genlPreds")) {
                importGenlPreds(subjectTermInfo, objLitTermInfo);
                return;
            }
            if (predicateTermInfo.ontologyNickname.equals("daml") ||
                predicateTermInfo.ontologyNickname.equals("rdfs") ||
                predicateTermInfo.ontologyNickname.equals("rdf")) {
                Log.current.println("\n\nUnhandled predicate: " + damlPredicate + "\n");
                return;
            }
        }
        CycFort subject = importTerm(subjectTermInfo);
        CycFort predicate = cycAccess.getConstantByName(damlPredicate);
        if (predicate == null) {
            predicate = importTerm(predicateTermInfo);
            cycAccess.assertIsaBinaryPredicate(predicate);
        }
        CycList arg1Constraints =
            cycAccess.getArg1Isas((CycConstant) predicate, cycAccess.universalVocabularyMt);
        assertForwardArgConstraints(subject, arg1Constraints);
        CycList arg2Constraints =
            cycAccess.getArg2Isas((CycConstant) predicate, cycAccess.universalVocabularyMt);

        // TODO - remove OpenCyc condition when inter-arg-isa1-2 is in the api.
        if (! cycAccess.isOpenCyc())
            arg2Constraints.addAllNew(cycAccess.getInterArgIsa1_2_forArg2((CycConstant) predicate,
                                                                          subject,
                                                                          cycAccess.universalVocabularyMt));

        if (objLitTermInfo.isLiteral) {
            if (! subjectTermInfo.hasEquivalentCycTerm())
                // No need to make assertions about mapped Cyc terms.
                importLiteralTriple(subject, predicate, objLitTermInfo, arg2Constraints);
            return;
        }
        CycFort object = cycAccess.getConstantByName(objLitTermInfo.toString());
        if (object == null)
            object = importTerm(objLitTermInfo);
        assertForwardArgConstraints(object, arg2Constraints);
        cycAccess.assertGaf(importMt,
                            predicate,
                            subject,
                            object);
        Log.current.println("(" + predicate.cyclify() + " " +
                            subject.cyclify() + " " +
                            object.cyclify() + ")\n");
    }

    /**
     * Imports the RDF literal triple.
     *
     * @@param subject the subject
     * @@param predicate the predicate
     * @@param LiteralTermInfo the literal DamlTermInfo object
     * @@param arg2Constraints the argument constraints on the type of literal permitted
     * by this assertion
     */
    protected void importLiteralTriple (CycFort subject,
                                        CycFort predicate,
                                        DamlTermInfo LiteralTermInfo,
                                        CycList arg2Constraints)
        throws IOException, UnknownHostException, CycApiException {
        if (arg2Constraints.size() == 0) {
            cycAccess.assertGaf(importMt,
                                predicate,
                                subject,
                                (String) escaped(LiteralTermInfo.literal));
        }
        else {
            if (arg2Constraints.size() > 1) {
            Log.current.println("*** ignoring extra literal argument constraints " +
                                arg2Constraints.cyclify());
            //TODO find most specific of the arg constraints.
            }
            CycFort arg2Constraint = (CycFort) arg2Constraints.first();
            if (arg2Constraint.equals(cycAccess.getKnownConstantByName("SubLString")) ||
                arg2Constraint.equals(cycAccess.getKnownConstantByName("CharacterString"))) {
                cycAccess.assertGaf(importMt,
                                    predicate,
                                    subject,
                                    (String) escaped(LiteralTermInfo.literal));

            }
            else if (arg2Constraint.equals(cycAccess.getKnownConstantByName("SubLRealNumber"))) {
                cycAccess.assertGaf(importMt,
                                    predicate,
                                    subject,
                                    new Double(LiteralTermInfo.literal));

            }
            else if (arg2Constraint.equals(cycAccess.getKnownConstantByName("SubLInteger"))) {
                cycAccess.assertGaf(importMt,
                                    predicate,
                                    subject,
                                    new Integer(LiteralTermInfo.literal));

            }
            else if (arg2Constraint.equals(cycAccess.getKnownConstantByName("Date"))) {
                CycFort date = new CycNart(cycAccess.getKnownConstantByName("DateDecodeStringFn"),
                                           "YYYY-MM-DD",
                                           LiteralTermInfo.literal);

                cycAccess.assertGaf(importMt,
                                    predicate,
                                    subject,
                                    date);

            }
            else if (arg2Constraint.equals(cycAccess.getKnownConstantByName("UniformResourceLocator"))) {
                CycFort urlFn = new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                           LiteralTermInfo.literal);

                cycAccess.assertGaf(importMt,
                                    predicate,
                                    subject,
                                    urlFn);

            }
            else
                Log.current.println("*** unhandled literal type constraint " +
                                    arg2Constraint.cyclify() + "\n");
        }
        Log.current.println("(" + predicate.cyclify() + " " +
                            subject.cyclify() + " \"" +
                            (String) LiteralTermInfo.literal + "\")\n");
    }

    /**
     * Returns the given string argument with embedded double quote characters
     * escaped.
     *
     * @@param string the given string
     * @@return the given string argument with embedded double quote characters
     * escaped
     */
    protected String escaped (String text) {
        String result = text.replace("\"", "\\\"");
        result = result.replace('\n', ' ');
        result = result.replace('\r', ' ');
        return result;
    }

    /**
     * Asserts argument constraints on a forward referenced term used
     * in an assertion.
     *
     * @@param term the given term
     * @@param argConstraints the list of collections for which term must be an instance
     */
    protected void assertForwardArgConstraints (CycFort term, CycList argConstraints)
        throws IOException, UnknownHostException, CycApiException  {
        for (int i = 0; i < argConstraints.size(); i++) {
            CycFort argConstraint = (CycFort) argConstraints.get(i);
            if (! cycAccess.isa(term, argConstraint)) {
                cycAccess.assertIsa(term, argConstraint, cycAccess.universalVocabularyMt);
                Log.current.println("*** asserting forward arg constraint " +
                                    "(#$isa " + term.cyclify() + " " +
                                    argConstraint.cyclify() + ")");
            }
        }
    }

    /**
     * Imports the rdf:type triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importIsa (DamlTermInfo subjectTermInfo,
                              DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort term = importTerm(subjectTermInfo);
        if (! subjectTermInfo.isURI) {
            cycAccess.assertGaf(cycAccess.bookkeepingMt,
                                cycAccess.getKnownConstantByName("damlOntology"),
                                term,
                                damlOntologyDefiningURL);
            if (! subjectTermInfo.isAnonymous)
                cycAccess.assertGaf(cycAccess.bookkeepingMt,
                                    cycAccess.getKnownConstantByName("damlURI"),
                                    term,
                                    new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                                subjectTermInfo.uri));
        }
        if (objectTermInfo.constantName.equals("daml:UnambiguousProperty")) {
            cycAccess.assertArg1FormatSingleEntry(subjectTermInfo.cycFort);
            Log.current.println("(#$arg1Format " +
                                term.cyclify() + " #$SingleEntryFormat)");
            return;
        }
        CycFort collection = importTerm(objectTermInfo);
        if (! cycAccess.isCollection(collection)) {
            cycAccess.assertIsaCollection(collection);
            Log.current.println("*** forward reference to collection " + collection.cyclify());
        }
        cycAccess.assertIsa(term,
                            collection);
        Log.current.println("(#$isa " +
                            term.cyclify() + " " +
                            collection.cyclify() + ")");
    }

    /**
     * Imports the rdf:subClassOf triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importGenls (DamlTermInfo subjectTermInfo,
                                DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort term = importTerm(subjectTermInfo);
        if (! cycAccess.isCollection(term)) {
            cycAccess.assertIsaCollection(term);
            Log.current.println("*** forward reference to collection " + term.cyclify());
        }
        CycFort collection = importTerm(objectTermInfo);
        if (! cycAccess.isCollection(collection)) {
            cycAccess.assertIsaCollection(collection);
            Log.current.println("*** forward reference to collection " + collection.cyclify());
        }
        cycAccess.assertGenls(term,
                              collection);
        Log.current.println("(#$genls " +
                            term.cyclify() + " " +
                            collection.cyclify() + ")");
    }

    /**
     * Imports the daml:samePropertyAs triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importSynonymousExternalConcept (DamlTermInfo subjectTermInfo,
                                                    DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        importTerm(subjectTermInfo);
        if (objectTermInfo.cycFort == null)
            importTerm(objectTermInfo);
        cycAccess.assertSynonymousExternalConcept(subjectTermInfo.toString(),
                                                  "WorldWideWeb-DynamicIndexedInfoSource",
                                                  objectTermInfo.toOriginalString(),
                                                  importMtName);
        Log.current.println("(#$synonymousExternalConcept " +
                            subjectTermInfo.cycFort.cyclify() + " " +
                            "WorldWideWeb-DynamicIndexedInfoSource \"" +
                            objectTermInfo.toOriginalString() + "\")");
    }

    /**
     * Imports the rdfs:domain triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importArg1Isa (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort term1 = importTerm(subjectTermInfo);
        CycFort term2 = importTerm(objectTermInfo);
        if (! cycAccess.isCollection(term2)) {
            cycAccess.assertIsaCollection(term2);
            Log.current.println("*** forward reference to collection " + term2.cyclify());
        }
        cycAccess.assertArgIsa(term1, 1, term2);
        Log.current.println("(#$arg1Isa " +
                            term1.cyclify() + " " +
                            term2.cyclify() + ")");
    }

    /**
     * Imports the rdfs:range triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importArg2Isa (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort term1 = importTerm(subjectTermInfo);
        CycFort term2 = importTerm(objectTermInfo);
        if (! cycAccess.isCollection(term2)) {
            cycAccess.assertIsaCollection(term2);
            Log.current.println("*** forward reference to collection " + term2.cyclify());
        }
        cycAccess.assertArgIsa(term1, 2, term2);
        Log.current.println("(#$arg2Isa " +
                          term1.cyclify() + " " +
                          term2.cyclify() + ")");
    }

    /**
     * Imports the rdfs:seeAlso triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importConceptuallyRelated (DamlTermInfo subjectTermInfo,
                                              DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort term1 = importTerm(subjectTermInfo);
        CycFort term2 = importTerm(objectTermInfo);
        cycAccess.assertConceptuallyRelated(term1,
                                            term2,
                                            importMt);
        Log.current.println("(#$conceptuallyRelated " +
                          term1.cyclify() + " " +
                          term2.cyclify() + ")");
    }

    /**
     * Imports the daml:subPropertyOf triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param objectTermInfo the object DamlTermInfo object
     */
    protected void importGenlPreds (DamlTermInfo subjectTermInfo,
                                    DamlTermInfo objectTermInfo)
        throws IOException, UnknownHostException, CycApiException  {
        CycFort specPred = importTerm(subjectTermInfo);
        CycFort genlPred = importTerm(objectTermInfo);
        if (! cycAccess.isBinaryPredicate((CycConstant) genlPred)) {
            // forward reference
            cycAccess.assertIsaBinaryPredicate(genlPred);
            Log.current.println("*** forward reference to predicate " + genlPred.cyclify());
        }
        cycAccess.assertGenlPreds(specPred,
                                  genlPred);
        Log.current.println("(#$genlPreds " +
                          specPred.cyclify() + " " +
                          genlPred.cyclify() + ")");
    }

    /**
     * Imports the daml:versionInfo triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param literalTermInfo the object DamlTermInfo object
     */
    protected void importVersionInfo (DamlTermInfo subjectTermInfo,
                                      DamlTermInfo literalTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        CycFort term = importTerm(subjectTermInfo);
        //TODO
    }

    /**
     * Imports the daml:imports triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param literalTermInfo the object DamlTermInfo object
     */
    protected void importImports (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo literalTermInfo)
        throws IOException, UnknownHostException, CycApiException {
    }

    /**
     * Imports the rdfs:comment triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param literalTermInfo the object DamlTermInfo object
     */
    protected void importComment (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo literalTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        CycFort term = importTerm(subjectTermInfo);
        String comment = literalTermInfo.literalValue().replace('\n', ' ');
        cycAccess.assertComment(term,
                                comment,
                                importMt);
        Log.current.println("(#$comment " +
                          term.cyclify() + " \"" +
                          comment + "\")");
    }

    /**
     * Imports the rdfs:label triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param literalTermInfo the object DamlTermInfo object
     */
    protected void importNameString (DamlTermInfo subjectTermInfo,
                                     DamlTermInfo literalTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        CycFort term = importTerm(subjectTermInfo);
        String nameString = literalTermInfo.literalValue();
        cycAccess.assertNameString(term,
                                   literalTermInfo.literalValue(),
                                   importMt);
        Log.current.println("(#$nameString " +
                          term.cyclify() + " \"" +
                          literalTermInfo.literalValue() + "\")");
        CycList nameStrings = cycAccess.getNameStrings(term, importMt);
        if (! nameStrings.contains(nameString)) {
            if (verbosity > 1) {
                Log.current.println("asserted " + nameString);
                if (nameStrings.size() == 1)
                    Log.current.println("queried  " + nameStrings.get(0));
                else
                    Log.current.println("queried  " + nameStrings);
            }
        }
    }

    /**
     * Imports the rdfs:isDefinedBy triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param literalTermInfo the object DamlTermInfo object
     */
    protected void importContainsInformationAbout (DamlTermInfo subjectTermInfo,
                                                   DamlTermInfo uriTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        CycFort term = importTerm(subjectTermInfo);
        CycFort resource = importTerm(uriTermInfo);
        cycAccess.assertGaf(importMt,
                            cycAccess.getKnownConstantByName("containsInformationAbout"),
                            resource,
                            term);
        Log.current.println("(#$containsInformationAbout " +
                            resource.cyclify() + " " +
                            term.cyclify() + ")");
    }

    /**
     * Imports the given DAML term and returns the Cyc term.
     *
     * @@param damlTermInfo the given daml term information
     * @@return the Cyc term resulting from the import of the given DAML term
     */
    protected CycFort importTerm (DamlTermInfo damlTermInfo)
        throws IOException, UnknownHostException, CycApiException {
        if (damlTermInfo.cycFort != null &&
            previousDamlTermInfo != null &&
            previousDamlTermInfo.equals(damlTermInfo))
            return previousDamlTermInfo.cycFort;

        CycFort cycFort = null;
        if (damlTermInfo.equivalentDamlCycTerm != null) {
            // not an imported term, but an equivalent existing Cyc term
            //Log.current.println("*** not importing " + cycFort.cyclify());
            previousDamlTermInfo = damlTermInfo;
            return damlTermInfo.cycFort;
        }
        else if (damlTermInfo.isURI) {
            cycFort = new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                  damlTermInfo.toString());
            damlTermInfo.cycFort = cycFort;
            previousDamlTermInfo = damlTermInfo;
            return cycFort;
        }
        else if (damlTermInfo.constantName != null &&
                 damlTermInfoWrapperTest(damlTermInfo.constantName))
            cycFort = damlTermInfoWrapper(damlTermInfo.constantName);
        else {
            String term = damlTermInfo.toString();
            try {
                cycFort = cycAccess.findOrCreate(term);
            }
            catch (CycApiException e) {
                Log.current.println("Error while importing " + term);
                Log.current.printStackTrace(e);
                System.exit(1);
            }
            if (cycFort == null)
                // error
                return cycFort;
        }
        if (verbosity > 1)
            Log.current.println("(#$isa  " + cycFort.cyclify() + " " +
                                kbSubsetCollection.cyclify() + ")");
        cycAccess.assertIsa(cycFort,
                            kbSubsetCollection,
                            bookkeepingMt);
        if (damlTermInfo.isAnonymous) {
            if (verbosity > 1)
                Log.current.println("(#$isa  " + cycFort.cyclify() + " #$DamlAnonymousClass)");
            cycAccess.assertIsa(cycFort,
                                cycAccess.getKnownConstantByName("DamlAnonymousClass"),
                                importMt);
        }
        additionalLexicalAssertions(cycFort);
        damlTermInfo.cycFort = cycFort;
        previousDamlTermInfo = damlTermInfo;
        return cycFort;
    }

    /**
     * Determines if the imported term should be wrapped with a functional
     * expression and imported as a NART.  Subclasses may override for desired
     * behavior.
     * @@param termName the daml term to be substituted and wrapped
     */
    protected boolean damlTermInfoWrapperTest (String termName) {
        return false;
    }

    /**
     * Wraps the impored term with the appropriate functional expression
     * so that it can be imported as a NART.  Subclasses may override for desired
     * behavior.
     * @@param termName the daml term to be substituted and wrapped
     */
    protected CycNart damlTermInfoWrapper (String termName)
        throws IOException, CycApiException {
        return null;
    }

    /**
     * Asserts additional lexical assertions about the given term which are specific to
     * the import of Open Directory terms. Subclasses may override for desired
     * behavior.
     *
     * @@param term the imported Open Directory (wrapped) term
     */
    protected void additionalLexicalAssertions (CycFort term)
        throws IOException, CycApiException {
    }

    /**
     * Displays the RDF triple.
     *
     * @@param subjectTermInfo the subject DamlTermInfo object
     * @@param predicateTermInfo the predicate DamlTermInfo object
     * @@param objLitTermInfo the object or literal DamlTermInfo object
     */
    protected void displayTriple (DamlTermInfo subjectTermInfo,
                                  DamlTermInfo predicateTermInfo,
                                  DamlTermInfo objLitTermInfo) {
        if (verbosity < 1)
            return;
        Log.current.println();
        StringBuffer stringBuffer = new StringBuffer();
        stringBuffer.append(subjectTermInfo.toOriginalString());
        stringBuffer.append(" ");
        stringBuffer.append(predicateTermInfo.toOriginalString());
        stringBuffer.append(" ");
        stringBuffer.append(objLitTermInfo.toOriginalString());
        Log.current.println(stringBuffer.toString());
    }

    /**
     * Returns the DamlTerm info of the given RDF resource.
     *
     * @@param aResource the RDF resource
     * @@param predicateTermInfo when processing the RDF triple object,
     * contains the predicate term info, otherwise is null;
     * @@return the DamlTerm info of the given RDF resource
     */
    protected DamlTermInfo resource(AResource aResource,
                                    DamlTermInfo predicateTermInfo) {
        DamlTermInfo damlTermInfo = new DamlTermInfo(this);
        String localName;
        String nameSpace;
        Resource resource = translateResource(aResource);
        damlTermInfo.uri = resource.toString();
        if (aResource.isAnonymous()) {
            damlTermInfo.isAnonymous = true;
            damlTermInfo.anonymousId = aResource.getAnonymousID();
            return damlTermInfo;
        }
        else if (aResource.getURI().indexOf("?") > -1) {
            damlTermInfo.isURI = false;
            int index = aResource.getURI().indexOf("?");
            localName = aResource.getURI().substring(index + 1);
            nameSpace = aResource.getURI().substring(0, index + 1);
        }
        else if (! hasUriNamespaceSyntax(aResource.getURI())) {
            damlTermInfo.isURI = true;
            if (! damlTermInfo.mustBeUri(predicateTermInfo))
                damlTermInfo.coerceToNamespace();
            return damlTermInfo;
        }
        else {
            localName = resource.getLocalName();
            nameSpace = resource.getNameSpace();
        }
        if (localName == null ||
            nameSpace == null)
            throw new RuntimeException("Invalid nameSpace " + nameSpace +
                                       " localName " + localName +
                                       " for resource " + resource.toString());
        damlTermInfo.localName = localName;
        damlTermInfo.nameSpace = nameSpace;
        String ontologyNickname = getOntologyNickname(nameSpace, resource);
        damlTermInfo.ontologyNickname = ontologyNickname;
        String constantName = ontologyNickname + ":" + localName;
        damlTermInfo.constantName = constantName;
        if (equivalentDamlCycTerms.containsKey(constantName)) {
            damlTermInfo.equivalentDamlCycTerm =
                (CycFort) equivalentDamlCycTerms.get(constantName);
            damlTermInfo.cycFort = damlTermInfo.equivalentDamlCycTerm;
        }
        else if (ontologyNickname.equals("xsd"))
            Log.current.println("\n*** unhandled primitive datatype: " + constantName + "\n");
        return damlTermInfo;
    }

    /**
     * Returns the DamlTerm info of the given RDF literal.
     *
     * @@param literal the RDF literal
     * @@return the DamlTerm info of the given RDF literal
     */
    protected DamlTermInfo literal(ALiteral literal) {
        DamlTermInfo damlTermInfo = new DamlTermInfo(this);
        String literalString = literal.toString();
        if (this.isProbableUri(literalString)) {
            damlTermInfo.isURI = true;
            damlTermInfo.uri = literalString;
        }
        else {
            damlTermInfo.isLiteral = true;
            damlTermInfo.literal = literalString;
        }
        return damlTermInfo;
    }

    /**
     * Returns true if the given string is likely to be a URI.
     *
     * @@param string the given string
     * @@return true if the given string is likely to be a URI
     */
    protected boolean isProbableUri (String string) {
        return
            string.startsWith("http://") ||
            string.startsWith("https://") ||
            string.startsWith("ftp://") ||
            string.startsWith("file:/") ||
            string.startsWith("urn:");
    }

    /**
     * Returns true if the given URI has embedded XML namespace separators.
     *
     * @@param uri the URI
     * @@return true if the given URI has embedded XML namespace separators, otherwise
     * false
     */
    protected boolean hasUriNamespaceSyntax (String uri) {
        return (uri.indexOf(":", 9) > -1) || (uri.indexOf("#") > -1);
    }

    /**
     * Records the components of a DAML Restriction.
     *
     * @@param subject the RDF Triple anonymous Subject
     * @@param predicate the RDF Triple Predicate
     * @@param object the RDF Triple Object
     */
    protected void processRestrictionSubject(AResource subject,
                                             AResource predicate,
                                             AResource object)
        throws IOException, UnknownHostException, CycApiException {
        DamlTermInfo subjectTermInfo = resource(subject, null);
        DamlTermInfo predicateTermInfo = resource(predicate, null);
        DamlTermInfo objectTermInfo = resource(object, null);
        displayTriple(subjectTermInfo,
                      predicateTermInfo,
                      objectTermInfo);
        if (predicateTermInfo.toString().equals("isa") &&
            objectTermInfo.toString().equals("daml:Restriction")) {
            damlRestriction = new DamlRestriction(this);
            damlRestriction.anonymousId = subject.getAnonymousID();
        }
        else if (damlRestriction == null) {
            // Not a Restriction, but an anonymous Class.
            importTriple(subjectTermInfo,
                         predicateTermInfo,
                         objectTermInfo);
            return;
        }
        else if (predicateTermInfo.toString().equals("daml:onProperty")) {
            if (objectTermInfo.cycFort == null)
                importTerm(objectTermInfo);
            damlRestriction.property = objectTermInfo.cycFort;
        }
        else if (predicateTermInfo.toString().equals("daml:toClass")) {
            if (objectTermInfo.cycFort == null)
                importTerm(objectTermInfo);
            damlRestriction.toClasses.add(objectTermInfo.cycFort);
        }
        else
            throw new RuntimeException("Unexpected restriction property " +
                                       predicateTermInfo.toString());
    }

    /**
     * Records the components of a DAML Restriction.
     *
     * @@param subject the RDF Triple anonymous Subject
     * @@param predicate the RDF Triple Predicate
     * @@param literal the RDF Triple Literal
     */
    protected void processRestrictionSubject(AResource subject,
                                             AResource predicate,
                                             ALiteral literal)
        throws IOException, UnknownHostException, CycApiException {
        DamlTermInfo subjectTermInfo = resource(subject, null);
        DamlTermInfo predicateTermInfo = resource(predicate, null);
        DamlTermInfo literalTermInfo = literal(literal);
        displayTriple(subjectTermInfo,
                      predicateTermInfo,
                      literalTermInfo);
        if (damlRestriction == null) {
            // Not a Restriction, but an anonymous Class.
            importTriple(subjectTermInfo,
                         predicateTermInfo,
                         literalTermInfo);
            return;
        }
        if (predicateTermInfo.toString().equals("daml:maxCardinality") ||
            predicateTermInfo.toString().equals("daml:cardinality"))
            damlRestriction.maxCardinality = new Integer(literalTermInfo.literalValue());
        else
            //TODO
            Log.current.println("\n*** unimplemented restriction triple \n    " +
                                subjectTermInfo.toString() + " " +
                                predicateTermInfo.toString() + " " +
                                literalTermInfo.toString() + "\n");
    }

    /**
     * Records the components of a DAML Restriction.
     *
     * @@param subject the RDF Triple anonymous Subject
     * @@param predicate the RDF Triple Predicate
     * @@param object the RDF Triple Object
     */
    protected void processRestrictionObject(AResource subject,
                                            AResource predicate,
                                            AResource object)
        throws IOException, UnknownHostException, CycApiException {
        DamlTermInfo subjectTermInfo = resource(subject, null);
        DamlTermInfo predicateTermInfo = resource(predicate, null);
        DamlTermInfo objectTermInfo = resource(object, null);
        displayTriple(subjectTermInfo,
                      predicateTermInfo,
                      objectTermInfo);
        if (damlRestriction == null) {
            // Not a Restriction, but an anonymous Class.
            try {
                importTriple(subjectTermInfo,
                             predicateTermInfo,
                             objectTermInfo);
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
            }
            return;
        }
        if (predicateTermInfo.toString().equals("genls")) {
            if (subjectTermInfo.cycFort == null)
                importTerm(subjectTermInfo);
            damlRestriction.fromClass = subjectTermInfo.cycFort;
        }
        else
            throw new RuntimeException("Unexpected restriction property " +
                                       predicateTermInfo.toString());
        try {
            damlRestriction.formInterArgConstraints();
            if (damlRestriction.interArgIsaConstraint != null) {
                if(actuallyImport)
                    cycAccess.assertGaf(damlRestriction.interArgIsaConstraint,
                                        importMt);
                Log.current.println(damlRestriction.interArgIsaConstraint.cyclify());
            }
            if (damlRestriction.interArgFormatConstraint != null) {
                if(actuallyImport)
                    cycAccess.assertGaf(damlRestriction.interArgFormatConstraint,
                                        importMt);
                Log.current.println(damlRestriction.interArgFormatConstraint.cyclify());
            }
            Log.current.println();
        }
        catch (Exception e) {
            Log.current.printStackTrace(e);
            System.exit(1);
        }
        damlRestriction = null;
    }

    /**
     * Returns the ontology nickname for the given XML namespace.
     *
     * @@param nameSpace the XML namespace for which the nickname is sought
     * @@param resource the resource containing the namespace, used for error messages
     * @@return the ontology nickname for the given XML namespace
     */
    protected String getOntologyNickname (String nameSpace, Resource resource) {
        int len = nameSpace.length() - 1;
        String key = nameSpace.substring(0, len);
        String nickname = (String) ontologyNicknames.get(key);
        if (nickname == null) {
            Log.current.println("\n*** Ontology nickname not found for " + key +
                                "\nResource " + resource.toString());
            nickname = "unknown";
        }
        return nickname;
    }

    /**
     * Converts an ARP resource into a Jena resource.
     *
     * @@param aResource The ARP resource.
     * @@return The Jena resource.
     */
    protected Resource translateResource(AResource aResource) {
        if (aResource.isAnonymous()) {
            String id = aResource.getAnonymousID();
            Resource rr = (Resource) aResource.getUserData();
            if (rr == null) {
                rr = new ResourceImpl();
                aResource.setUserData(rr);
            }
            return rr;
        }
        else
            return new ResourceImpl(aResource.getURI());
    }

    /**
     * Initializes the DAML ontology mt.
     */
    public void initializeDamlOntologyMt (String mtName)
        throws IOException, UnknownHostException, CycApiException {
        Log.current.println("Creating " + mtName);
        String comment = "A microtheory to contain imported DAML assertions.";
        ArrayList genlMts = new ArrayList();
        genlMts.add("BaseKB");
        String isaMtName = "SourceMicrotheory";
        cycAccess.createMicrotheory(mtName, comment, isaMtName, genlMts);
    }

    /**
     * Initializes the Ontology nicknames mapping.
     */
    public void initializeCommonOntologyNicknames () {
        if (verbosity > 1)
            Log.current.println("Creating common ontology nicknames");
        if (ontologyNicknames == null)
            ontologyNicknames = new HashMap();
        ontologyNicknames.put("http://www.w3.org/1999/02/22-rdf-syntax-ns", "rdf");
        ontologyNicknames.put("http://www.w3.org/2000/01/rdf-schema", "rdfs");
        ontologyNicknames.put("http://www.w3.org/2000/10/XMLSchema", "xsd");
        ontologyNicknames.put("http://www.daml.org/2001/03/daml+oil", "daml");

        ontologyNicknames.put("http://xmlns.com/foaf/0.1", "foaf");
        ontologyNicknames.put("http://xmlns.com/foaf/0.1/", "foaf");
        ontologyNicknames.put("http://xmlns.com/foaf", "foaf");
        ontologyNicknames.put("http://xmlns.com/wot/0.1", "wot");
        ontologyNicknames.put("http://xmlns.com/wordnet/1.6", "wn");
        ontologyNicknames.put("http://www.w3.org/2001/08/rdfweb", "rdfweb");
        ontologyNicknames.put("http://purl.org/dc/elements/1.1", "dublincore");
        ontologyNicknames.put("http://purl.org/dc/elements/1.0/", "dublincore");

        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/DC/3.2", "drc-dc");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2", "ves");
        ontologyNicknames.put("http://orlando.drc.com/daml/Ontology/daml-extension/3.2/daml-ext-ont", "daml-ext");
        ontologyNicknames.put("http://www.daml.org/cgi-bin/geonames", "geonames");
        ontologyNicknames.put("http://www.daml.org/cgi-bin/airport", "airport");
        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/factbook-ont.daml", "factbook");
        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/factbook-ont", "factbook");
        ontologyNicknames.put("http://www.daml.org/2001/12/factbook", "factbook");
        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/af.daml", "factbook");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology", "daml-experiment");

        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/internationalOrganizations.daml", "factbkorg");
        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/internationalOrganizations", "factbkorg");

        ontologyNicknames.put("http://www.daml.org/2002/02/chiefs/chiefs-ont.daml", "chiefs-ont");
        ontologyNicknames.put("http://www.daml.org/2002/02/chiefs/chiefs-ont", "chiefs-ont");

        ontologyNicknames.put("http://www.daml.org/2002/02/chiefs/af.daml", "chiefs");
        ontologyNicknames.put("http://www.daml.org/2002/02/chiefs/af", "chiefs");

        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/DC/3.2/dces-ont.daml", "dces");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/DC/3.2/dces-ont", "dces");

        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont.daml", "ves");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont", "ves");

        ontologyNicknames.put("http://www.daml.org/2001/10/html/airport-ont.daml", "airport");
        ontologyNicknames.put("http://www.daml.org/2001/10/html/airport-ont", "airport");

        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips-10-4-ont", "fips10-4");

        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips.daml", "fips");
        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips", "fips");

        ontologyNicknames.put("http://www.daml.org/2001/09/countries/iso-3166-ont", "iso3166");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont.daml", "enp");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont", "enp");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/objectives-ont.daml", "obj");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/objectives-ont", "obj");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/social-elements-ont.daml", "soci");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/social-elements-ont", "soci");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/political-elements-ont.daml", "poli");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/political-elements-ont", "poli");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/economic-elements-ont.daml", "econ");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/economic-elements-ont", "econ");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/infrastructure-elements-ont.daml", "infr");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/infrastructure-elements-ont", "infr");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/information-elements-ont.daml", "info");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/information-elements-ont", "info");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/military-elements-ont.daml", "mil");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/military-elements-ont", "mil");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/enp-characteristics.daml", "enp-char");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/enp-characteristics", "enp-char");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/entity-ont.daml", "entity-ont");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/entity-ont", "entity-ont");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/entity.daml", "entity");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/entity", "entity");


        ontologyNicknames.put("http://www.daml.org/experiment/ontology/ona.xsd", "dt");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/location-ont.daml", "loc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/location-ont", "loc");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/assessment-ont.daml", "assess");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/assessment-ont", "assess");

        ontologyNicknames.put("http://www.daml.org/2001/02/geofile/geofile-dt.xsd", "geodt");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/CINC-ont.daml", "cinc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/CINC-ont", "cinc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/cinc-ont", "cinc");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/agency-ont.daml", "agent");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/agency-ont", "agent");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/operation-ont.daml", "oper");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/operation-ont", "oper");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/target-ont.daml", "target-ont");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/target-ont", "target-ont");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit-ont.daml", "unit-ont");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit-ont", "unit-ont");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit-status.daml", "unit-status");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit-status", "unit-status");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit.daml", "unit");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/unit", "unit");

        ontologyNicknames.put("http://www.daml.org/2002/09/milservices/milservices-ont", "milsvcs-ont");

        ontologyNicknames.put("http://www.daml.org/2002/09/milservices/us", "milsvcs-us");
    }

    public void setOntologyNickname (String uri, String nickname) {
        if (ontologyNicknames == null)
            ontologyNicknames = new HashMap();
        ontologyNicknames.put(uri, nickname);
    }

    /**
     * Initializes common DAML mapped terms.
     */
    public void initializeCommonMappedTerms ()
        throws IOException, UnknownHostException, CycApiException {
        if (verbosity > 1)
            Log.current.println("Creating common mapped terms");
        assertMapping("daml:Thing",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#Thing",
                      "Thing");
        assertMapping("rdfs:Resource",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#Resource",
                      "Thing");

        assertMapping("daml:Class",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#Class",
                      "Collection");
        assertMapping("rdfs:Class",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#Class",
                      "Collection");

        assertMapping("daml:Ontology",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#Ontology",
                      "AbstractInformationStructure");

        assertMapping("daml:DatatypeProperty",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#DatatypeProperty",
                      "DamlDatatypeProperty");

        assertMapping("daml:ObjectProperty",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#ObjectProperty",
                      "DamlObjectProperty");

        assertMapping("daml:Property",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#Property",
                      "BinaryPredicate");
        assertMapping("rdfs:Property",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#Property",
                      "BinaryPredicate");
        assertMapping("rdf:Property",
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns",
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property",
                      "BinaryPredicate");

        assertMapping("daml:TransitiveProperty",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#TransitiveProperty",
                      "TransitiveBinaryPredicate");

        assertMapping("daml:Literal",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#Literal",
                      "SubLAtomicTerm");
        assertMapping("rdfs:Literal",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#Literal",
                      "SubLAtomicTerm");

        assertMapping("xsd:string",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#string",
                      "SubLString");
        assertMapping("xsd:decimal",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#decimal",
                      "SubLRealNumber");
        assertMapping("xsd:integer",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#integer",
                      "SubLInteger");
        assertMapping("xsd:float",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#float",
                      "SubLRealNumber");
        assertMapping("xsd:double",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#double",
                      "SubLRealNumber");
        assertMapping("xsd:date",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#date",
                      "Date");
        assertMapping("xsd:uriReference",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#uriReference",
                      "UniformResourceLocator");
        assertMapping("xsd:anyURI",
                      "http://www.w3.org/2000/10/XMLSchema",
                      "http://www.w3.org/2000/10/XMLSchema#anyURI",
                      "UniformResourceLocator");

        // Binary predicates
        assertMapping("daml:subClassOf",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#subClassOf",
                      "genls");
        assertMapping("rdfs:subClassOf",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#subClassOf",
                      "genls");

        assertMapping("daml:type",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#type",
                      "isa");
        assertMapping("rdfs:type",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#type",
                      "isa");
        assertMapping("rdf:type",
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns",
                      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                      "isa");

        assertMapping("daml:subPropertyOf",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#subPropertyOf",
                      "genlPreds");
        assertMapping("rdfs:subPropertyOf",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#subPropertyOf",
                      "genlPreds");

        assertMapping("daml:label",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#label",
                      "nameString");
        assertMapping("rdfs:label",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#label",
                      "nameString");

        assertMapping("daml:comment",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#comment",
                      "comment");
        assertMapping("rdfs:comment",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#comment",
                      "comment");

        assertMapping("daml:seeAlso",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#seeAlso",
                      "conceptuallyRelated");
        assertMapping("rdfs:seeAlso",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#seeAlso",
                      "conceptuallyRelated");

        assertMapping("daml:isDefinedBy",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#isDefinedBy",
                      "containsInformationAbout");
        assertMapping("rdfs:isDefinedBy",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#isDefinedBy",
                      "containsInformationAbout");

        assertMapping("daml:domain",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#domain",
                      "arg1Isa");
        assertMapping("rdfs:domain",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#domain",
                      "arg1Isa");

        assertMapping("daml:range",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#range",
                      "arg2Isa");
        assertMapping("rdfs:range",
                      "http://www.w3.org/2000/01/rdf-schema",
                      "http://www.w3.org/2000/01/rdf-schema#range",
                      "arg2Isa");

        assertMapping("daml:differentIndividualFrom",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#differentIndividualFrom",
                      "different");

        assertMapping("daml:samePropertyAs",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#samePropertyAs",
                      "synonymousExternalConcept");

        assertMapping("daml:disjointWith",
                      "http://www.daml.org/2001/03/daml+oil",
                      "http://www.daml.org/2001/03/daml+oil#disjointWith",
                      "disjointWith");



        // Get the above mappings plus any previously defined in the KB.
        getMappings();
    }

    /**
     * Asserts that the given DAML/RDFS/RDF term is mapped to the
     * given Cyc term, with the assertion placed in #$BaseKB.
     *
     * @@param damlTermName the given DAML/RDFS/RDF term
     * @@param damlOntology the Uniform Resource Locator in which the definition of
     * the daml term is found
     * @@param damlURI the Uniform Resource Locator which uniquely identifies the daml term
     * @@param cycTermName the given Cyc term
     */
    protected void assertMapping (String damlTermName,
                                  String damlOntology,
                                  String damlURI,
                                  String cycTermName)
        throws IOException, UnknownHostException, CycApiException {
        assertMapping (damlTermName,
                       damlOntology,
                       damlURI,
                       cycTermName,
                       "BaseKB");
    }

    /**
     * Asserts that the given DAML/RDFS/RDF term is mapped to the
     * given Cyc term.
     *
     * @@param damlTermName the given DAML/RDFS/RDF term
     * @@param damlOntology the Uniform Resource Locator in which the definition of
     * the daml term is found
     * @@param damlURI the Uniform Resource Locator which uniquely identifies the daml term
     * @@param cycTermName the given Cyc term
     * @@param mappingMt the microtheory in which the assertions are placed
     */
    protected void assertMapping (String damlTermName,
                                  String damlOntology,
                                  String damlURI,
                                  String cycTermName,
                                  String mappingMt)
        throws IOException, UnknownHostException, CycApiException {
        CycFort cycTerm;
        cycTermName = Strings.stripLeadingBlanks(cycTermName);
        cycTermName = Strings.stripTrailingBlanks(cycTermName);
        if (cycTermName.startsWith("(")) {
            CycList cycNartList = cycAccess.makeCycList(cycTermName);
            cycTerm = new CycNart(cycNartList);
        }
        else
            cycTerm = cycAccess.findOrCreate(cycTermName);
        if (verbosity > 1)
            Log.current.println("Mapping " + damlTermName + " to " + cycTerm.cyclify());
        cycAccess.assertSynonymousExternalConcept(cycTerm,
                                                  cycAccess.find("WorldWideWeb-DynamicIndexedInfoSource"),
                                                  damlTermName,
                                                  cycAccess.find(mappingMt));
        CycFort damlTerm = cycAccess.findOrCreate(damlTermName);
        cycAccess.assertComment(damlTerm,
                                damlTerm.cyclify() +
                                " is an imported DAML/XML term equivalent to the Cyc term " +
                                cycTerm.cyclify(),
                                cycAccess.getKnownConstantByName(mappingMt));
        // assert (#$isa damlTerm #$DamlConstant) in BookkeepingMt
        cycAccess.assertIsa(damlTerm,
                            cycAccess.getKnownConstantByName("DamlConstant"),
                            cycAccess.bookkeepingMt);
        // assert (#$damlOntology damlTerm ontologyURL) in BookkeepingMt
        cycAccess.assertGaf(cycAccess.bookkeepingMt,
                            cycAccess.getKnownConstantByName("damlOntology"),
                            damlTerm,
                            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                       damlOntology));
        // assert (#$damlURI damlTerm uri) in BookkeepingMt
        cycAccess.assertGaf(cycAccess.bookkeepingMt,
                            cycAccess.getKnownConstantByName("damlURI"),
                            damlTerm,
                            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                       damlURI));
    }

    /**
     * Asserts that the given DAML/RDFS/RDF property is mapped to the
     * given Cyc predicate with the arguments reversed.
     *
     * @@param damlPropertyName the given DAML/RDFS/RDF property
     * @@param damlOntology the Uniform Resource Locator in which the definition of
     * the daml term is found
     * @@param damlURI the Uniform Resource Locator which uniquely identifies the daml term
     * @@param cycBinaryPredicateName the given Cyc binary predicate
     * @@argumentMappingList a list of argument positions
     * @@param mappingMt the microtheory in which the assertions are placed
     */
    protected void assertArgumentMapping (String damlPropertyName,
                                          String damlOntology,
                                          String damlURI,
                                          String cycBinaryPredicateName,
                                          String argumentMappingList)
        throws IOException, UnknownHostException, CycApiException {
            assertArgumentMapping (damlPropertyName,
                                   damlOntology,
                                   damlURI,
                                   cycBinaryPredicateName,
                                   argumentMappingList,
                                   "UniversalVocabularyMt");
    }

    /**
     * Asserts that the given DAML/RDFS/RDF property is mapped to the
     * given Cyc predicate with the arguments reversed.
     *
     * @@param damlPropertyName the given DAML/RDFS/RDF property
     * @@param damlOntology the Uniform Resource Locator in which the definition of
     * the daml term is found
     * @@param damlURI the Uniform Resource Locator which uniquely identifies the daml term
     * @@param cycBinaryPredicateName the given Cyc binary predicate
     * @@argumentMappingList a list of argument positions
     * @@param mappingMt the microtheory in which the assertions are placed
     */
    protected void assertArgumentMapping (String damlPropertyName,
                                          String damlOntology,
                                          String damlURI,
                                          String cycBinaryPredicateName,
                                          String argumentMappingList,
                                          String mappingMt)
        throws IOException, UnknownHostException, CycApiException {
        CycFort cycBinaryPredicate = cycAccess.findOrCreate(cycBinaryPredicateName);
        Log.current.println("Mapping " + damlPropertyName + " to " + cycBinaryPredicate.cyclify());
        cycAccess.assertSynonymousExternalConcept(cycBinaryPredicateName,
                                                  "WorldWideWeb-DynamicIndexedInfoSource",
                                                  damlPropertyName,
                                                  mappingMt);
        //TODO assert synonymousRelnArgs

        CycFort damlProperty = cycAccess.findOrCreate(damlPropertyName);
        cycAccess.assertComment(damlProperty,
                                damlProperty.cyclify() +
                                " is an imported DAML/XML property equivalent to the Cyc predicate " +
                                cycBinaryPredicate.cyclify() +
                                " (with the arguments reversed).",
                                cycAccess.getKnownConstantByName(mappingMt));
        // assert (#$isa damlTerm #$DamlConstant) in BookkeepingMt
        cycAccess.assertIsa(damlProperty,
                            cycAccess.getKnownConstantByName("DamlConstant"),
                            cycAccess.bookkeepingMt);
        // assert (#$damlOntology damlProperty ontologyURL) in BookkeepingMt
        cycAccess.assertGaf(cycAccess.bookkeepingMt,
                            cycAccess.getKnownConstantByName("damlOntology"),
                            damlProperty,
                            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                       damlOntology));
        // assert (#$damlURI damlProperty uri) in BookkeepingMt
        cycAccess.assertGaf(cycAccess.bookkeepingMt,
                            cycAccess.getKnownConstantByName("damlURI"),
                            damlProperty,
                            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                       damlURI));
    }

    /**
     * Gets the asserted mappings between DAML/RDFS/RDF terms and Cyc terms.
     */
    protected void getMappings ()
        throws IOException, UnknownHostException, CycApiException {
        getMappings("BaseKB");
    }

    /**
     * Gets the asserted mappings between DAML/RDFS/RDF terms and Cyc terms.
     *
     * @@param mappingMt the microtheory from which the assertions are gathered
     */
    protected void getMappings (String mappingMt)
        throws IOException, UnknownHostException, CycApiException {
        equivalentDamlCycTerms = new HashMap();
        CycList mappings =
            cycAccess.getSynonymousExternalConcepts("WorldWideWeb-DynamicIndexedInfoSource",
                                                    mappingMt);
        for (int i = 0; i < mappings.size(); i++) {
            CycList pair = (CycList) mappings.get(i);
            CycFort cycTerm = (CycFort) pair.first();
            String damlTerm = (String) pair.second();
            Log.current.println(damlTerm + " --> " + cycTerm.cyclify());
            equivalentDamlCycTerms.put(damlTerm, cycTerm);
        }
    }

    /**
     * Initializes the DAML ontology vocabulary if not present.
     */
    public void initializeCommonDamlVocabulary ()
        throws IOException, UnknownHostException, CycApiException {
        if (verbosity > 1)
            Log.current.println("Creating common DAML vocabulary");
        if (cycAccess.isOpenCyc()) {
            cycAccess.setCyclist("CycAdministrator");
            cycAccess.setKePurpose("OpenCycProject");
        }
        else {
            cycAccess.setCyclist("SteveReed");
            cycAccess.setKePurpose("DAMLProject");
        }
        // #$DamlFort
        String term = "DamlFort";
        String comment = "The KB subset collection of DAML terms.";
        cycAccess.findOrCreate(term);
        cycAccess.assertComment(term, comment, "BaseKB");
        cycAccess.assertIsa(term, "VariableOrderCollection");
        cycAccess.assertGenls(term, "CycLReifiableDenotationalTerm");

        // DamlConstant
        term = "DamlConstant";
        comment = "The KB subset collection of DAML terms.";
        cycAccess.findOrCreate(term);
        cycAccess.assertComment(term, comment, "BaseKB");
        cycAccess.assertIsa(term, "VariableOrderCollection");
        cycAccess.assertGenls(term, "DamlFort");

        // #$DamlNart
        term = "DamlNart";
        comment = "The KB subset collection of DAML refified functional terms.";
        cycAccess.findOrCreate(term);
        cycAccess.assertComment(term, comment, "BaseKB");
        cycAccess.assertIsa(term, "VariableOrderCollection");
        cycAccess.assertGenls(term, "DamlFort");

        // #$DamlDatatypeProperty
        cycAccess.createCollection(
            "DamlDatatypeProperty",
            "The collection of #$Predicates having a " +
            "SubLAtomicTerm as the second argument.",
            "BaseKB",
            "PredicateCategory",
            "IrreflexiveBinaryPredicate");

        // #$DamlObjectProperty
        cycAccess.createCollection(
            "DamlObjectProperty",
            "The collection of #$Predicates not having a " +
            "SubLAtomicTerm as the second argument.",
            "BaseKB",
            "PredicateCategory",
            "BinaryPredicate");

        // #$DamlAnonymousClass
        cycAccess.createCollection(
            "DamlAnonymousClass",
            "The collection of DAML anonymous classes not having a " +
            "Uniform Resource Identifier (URI).",
            "BaseKB",
            "ObjectType",
            "IndeterminateTerm");

        if (cycAccess.find("WorldWideWeb-DynamicIndexedInfoSource") == null)
            // #$WorldWideWeb-DynamicIndexedInfoSource
            cycAccess.createIndividual(
                "WorldWideWeb-DynamicIndexedInfoSource",
                "The WorldWideWeb-DynamicIndexedInfoSource is an instance of " +
                "DynamicIndexedInfoSource. It is all of the information content " +
                "of the WorldWideWeb-Concrete.",
                "BaseKB",
                "IndexedInformationSource");

        // #$URLFn
        cycAccess.createIndivDenotingUnaryFunction(
            "URLFn",
            "An instance of both IndividualDenotingFunction and ReifiableFunction. " +
            "Given a URL string as its single argument, URLFn returns the corresponding " +
            "instance of UniformResourceLocator.",
            "BaseKB",
            "CharacterString",
            "UniformResourceLocator");

        // #$damlOntology
        String genlPreds = null;
        if (! cycAccess.isOpenCyc())
            genlPreds = "salientURL";
        cycAccess.createBinaryPredicate(
            "damlOntology",
            // predicate type
            null,
            // comment
            "A predicate relating an imported DAML (Darpa " +
            "Agent Markup Language) concept with its source" +
            "URL document.",
            // arg1Isa
            "CycLReifiableDenotationalTerm",
            // arg2Isa
            "UniformResourceLocator",
            // arg1Format
            null,
            // arg2Format
            "SingleEntry",
            genlPreds,
            // genFormatString
            "~a's DAML ontology URL is ~a",
            // genFormatList
            "()");

        // #$damlURI
        cycAccess.createBinaryPredicate(
            "damlURI",
            // predicate type
            null,
            // comment
            "A predicate relating an imported DAML (Darpa " +
            "Agent Markup Language) concept with its source" +
            "Uniform Resource Identifier.",
            // arg1Isa
            "CycLReifiableDenotationalTerm",
            // arg2Isa
            "UniformResourceLocator",
            // arg1Format
            null,
            // arg2Format
            "SingleEntry",
            // genlPreds
            "damlOntology",
            // genFormatString
            "~a's DAML URI is ~a",
            // genFormatList
            "()");

        // #$xmlNameSpace
        cycAccess.createBinaryPredicate(
            "xmlNameSpace",
            // predicate type
            null,
            // comment
            "A predicate relating an imported XML namespace string with its " +
            "source Uniform Resource Identifier.",
            // arg1Isa
            "SubLString",
            // arg2Isa
            "UniformResourceLocator",
            // arg1Format
            null,
            // arg2Format
            "SingleEntry",
            // genlPreds
            "conceptuallyRelated",
            // genFormatString
            "~a is an abbreviated reference for the xml namespace of ~a",
            // genFormatList
            "()");
    }

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }

    /**
     * Records the DAML term information for Cyc import.
     */
    protected class DamlTermInfo {
        ImportDaml parent;
        boolean isAnonymous = false;
        boolean isURI = false;
        boolean isLiteral = false;
        String anonymousId;
        String nameSpace;
        String ontologyNickname;
        String localName;
        String constantName;
        String uri;
        String literal;
        CycFort equivalentDamlCycTerm;
        CycFort cycFort;

        /**
         * Constructs a new DamlTermInfo object.
         */
        public DamlTermInfo(ImportDaml parent) {
            this.parent = parent;
        }

        /**
         * Returns <tt>true</tt> some object equals this object
         *
         * @@param object the <tt>Object</tt> for equality comparison
         * @@return equals <tt>boolean</tt> value indicating equality or non-equality.
         */
        public boolean equals(Object object) {
            if (! (object instanceof DamlTermInfo))
                return false;
            return this.toString().equals(object.toString());
        }

        /**
         * Returns a non-substituted string representation of this object.
         *
         * @@return a non-substituted string representation of this object
         */
        public String toOriginalString() {
            if (equivalentDamlCycTerm == null)
                return this.toString();
            else
                return constantName;
        }

        /**
         * Returns a string representation of this object.
         *
         * @@return a string representation of this object
         */
        public String toString() {
            if (isAnonymous)
                return "anon-" + anonymousId;
            else if (isURI)
                return uri;
            else if (isLiteral)
                return "\"" + literal + "\"";
            else if (equivalentDamlCycTerm != null)
                return equivalentDamlCycTerm.cyclify();
            else
                return constantName;
        }

        /**
         * Returns the literal value of this object.
         *
         * @@return the literal value of this object
         */
        public String literalValue() {
            if (isLiteral)
                return literal;
            else
                throw new RuntimeException(this.toString() + " is not a literal");
        }

        /**
         * Coerces a namespace:localname from the URI.
         * For example, http://xmlns.com/foaf/0.1/Person -->
         * http://xmlns.com/foaf/0.1#Person
         */
        public void coerceToNamespace() {
            int index = uri.lastIndexOf("/");
            nameSpace = uri.substring(0, index);
            localName = uri.substring(index + 1);
            if (localName.equals(""))
                return;
            ontologyNickname = (String) ontologyNicknames.get(nameSpace);
            if (ontologyNickname == null) {
                Log.current.println("*** nickname not found for " + nameSpace +
                                    "\nuri " + uri);
                ontologyNickname = "unknown";
            }
            constantName = ontologyNickname + ":" + localName;
            isURI = false;
        }

        /**
         * Returns true if the uri does not represent an RDF
         * object.  Heuristic patterns are used.
         *
         * @@param predicateTermInfo when present indicates that this
         * is the object of the RDF triple
         * @@return true if the uri does not represent an RDF
         * object
         */
        public boolean mustBeUri(DamlTermInfo predicateTermInfo) {
            if (predicateTermInfo != null) {
                if (predicateTermInfo.toString().equals("daml:imports") ||
                    predicateTermInfo.toString().equals("rdfs:isDefinedBy") ||
                    predicateTermInfo.toString().equals("rdfs:seeAlso"))
                    return true;
            }
            if (parent.ontologyNicknames.containsKey(uri))
                return true;
            if (uri.endsWith(".daml") ||
                uri.startsWith("news:") ||
                (uri.indexOf("daml+oil") > -1))
                return true;
            return false;
        }

        /**
         * Returns true if this term has an equivalent existing Cyc term.
         *
         * @@return true if this term has an equivalent existing Cyc term
         */
        public boolean hasEquivalentCycTerm () {
            return equivalentDamlCycTerm != null;
        }
    }


    /**
     * Records property use restrictions which get imported
     * as Cyc interArgIsa1-2 or interArgFormat1-2 assertions.
     */
    protected class DamlRestriction {

        /**
         * the parent ImportDaml object
         */
        ImportDaml importDaml;

        /**
         * Identifies all the RDF triples which contribute to this DAML
         * Restriction.
         */
        public String anonymousId;

        /**
         * The domain (Cyc arg1) class whose intstances are the subject of the property.
         */
        public CycFort fromClass;

        /**
         * The property (Cyc predicate arg0) which relates the subject and predicate instances.
         */
        public CycFort property;

        /**
         * The range (Cyc arg2) classes whose instances may be objects of the property in the
         * cases where subject is an instance of the given fromClass.
         */
        public ArrayList toClasses = new ArrayList();

        /**
         * the maxCardinality restriction
         */
        public Integer maxCardinality;

        /**
         * the interArgIsa constraint sentence
         */
        public CycList interArgIsaConstraint;

        /**
         * the interArgFormat constraint sentence
         */
        public CycList interArgFormatConstraint;

        /**
         * Constructs a new DamlRestriction object.
         */
        public DamlRestriction (ImportDaml importDaml) {
            this.importDaml = importDaml;
        }

        /**
         * Forms the restriction constraints.
         */
        protected void formInterArgConstraints()
            throws IOException, UnknownHostException, CycApiException {
            if (maxCardinality != null)
                formInterArgFormatConstraint();
            if (toClasses.size() > 0)
                formInterArgIsaConstraint();
        }

        /**
         * Forms the interArgIsa1-2 constraint.
         */
        protected void formInterArgIsaConstraint()
            throws IOException, UnknownHostException, CycApiException {
            if (toClasses.size() == 1) {
                if (! cycAccess.isBinaryPredicate((CycConstant) property)) {
                    cycAccess.assertIsaBinaryPredicate(property);
                    Log.current.println("*** forward reference to predicate " + property.cyclify());
                }
                CycFort toClass = (CycFort) toClasses.get(0);
                if (! cycAccess.isCollection(toClass)) {
                    cycAccess.assertIsaCollection(toClass);
                    Log.current.println("*** forward reference to collection " + toClass.cyclify());
                }
                String interArgIsaConstraintString =
                    "(#$interArgIsa1-2 " +
                    property.cyclify() + " " +
                    fromClass.cyclify() + " " +
                    toClass.cyclify() + ")";
                interArgIsaConstraint = cycAccess.makeCycList(interArgIsaConstraintString);
            }
            else
                //TODO
                throw new RuntimeException("Unhandled interArgIsa restriction case: " +
                                           toClasses.toString());
        }

        /**
         * Forms the interArgFormat1-2 constraint.
         */
        protected void formInterArgFormatConstraint()
            throws IOException, UnknownHostException, CycApiException {
            if (this.maxCardinality.intValue() == 1) {
                String interArgFormatConstraintString =
                    "(#$interArgFormat1-2 " +
                    property.cyclify() + " " +
                    fromClass.cyclify() + " " +
                    "#$SingleEntry)";
                interArgFormatConstraint = cycAccess.makeCycList(interArgFormatConstraintString);
            }
            else
                //TODO
                throw new RuntimeException("Unhandled maxCardinality restriction case: " +
                                           maxCardinality.toString());
        }

        /**
         * Returns a string representation of this object.
         *
         * @@return a string representation of this object
         */
        public String toString() {
            StringBuffer stringBuffer = new StringBuffer();
            stringBuffer.append("anon-");
            stringBuffer.append(anonymousId);
            stringBuffer.append(": ");
            stringBuffer.append(fromClass);
            stringBuffer.append(" ");
            stringBuffer.append(property);
            stringBuffer.append(" (");
            for (int i = 0; i < toClasses.size(); i++) {
                if (i > 0)
                    stringBuffer.append(", ");
                stringBuffer.append(toClasses.get(i).toString());
            }
            stringBuffer.append(") ");
            if (interArgIsaConstraint != null)
                stringBuffer.append(interArgIsaConstraint.cyclify());
            return stringBuffer.toString();
        }
    }
    /**
     * Implements a SAX ErrorHandler to report the XML parsing errors.
     */
    protected class MyErrorHandler implements ErrorHandler {

        /**
         * Constructs a new MyErrorHandler object.
         */
        public MyErrorHandler () {
        }

        /**
         * Handles SAX XML parsing warnings.
         */
        public void warning(SAXParseException exception) {
            Log.current.println("SAX warning: " + exception.getMessage());
        }

        /**
         * Handles SAX XML parsing errors.
         */
        public void error(SAXParseException exception) {
            Log.current.println("SAX error: " + exception.getMessage());
        }

        /**
         * Handles SAX XML parsing fatal errors.
         */
        public void fatalError(SAXParseException exception) {
            Log.current.println("SAX fatal error: " + exception.getMessage());
        }
    }



}@


1.44
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@d3 20
a22 11
import java.io.*;
import java.net.*;
import java.text.SimpleDateFormat;
import java.util.*;
import org.xml.sax.*;
import com.hp.hpl.jena.rdf.arp.*;
import com.hp.hpl.mesa.rdf.jena.common.*;
import com.hp.hpl.mesa.rdf.jena.model.*;
import org.opencyc.api.*;
import org.opencyc.cycobject.*;
import org.opencyc.util.*;
d25 9
d537 3
a539 3
        String result = Strings.change(text, "\"", "\\\"");
        result = Strings.change(result, "\n", " ");
        result = Strings.change(result, "\r", " ");
@


1.43
log
@Improving SONAT DAML import after refactoring.
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.42 2002/10/09 15:17:31 stephenreed Exp $
@


1.42
log
@Added well formed formula constraint ensuring method
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.41 2002/10/09 04:01:57 stephenreed Exp $
d335 1
a335 1
            if (damlPredicate.equals("isa")) {
d339 1
a339 1
            if (damlPredicate.equals("genls")) {
d355 1
a355 1
            if (damlPredicate.equals("comment")) {
d359 1
a359 1
            if (damlPredicate.equals("nameString")) {
d363 1
a363 1
            if (damlPredicate.equals("synonymousExternalConcept")) {
d367 1
a367 1
            if (damlPredicate.equals("arg1Isa")) {
d371 1
a371 1
            if (damlPredicate.equals("arg2Isa")) {
d375 1
a375 1
            if (damlPredicate.equals("conceptuallyRelated")) {
d379 1
a379 1
            if (damlPredicate.equals("containsInformationAbout")) {
d383 1
a383 1
            if (damlPredicate.equals("genlPreds")) {
d823 7
a829 1
        if (damlTermInfo.isURI) {
a851 7
            if (damlTermInfo.equivalentDamlCycTerm != null) {
                // not an imported term, but an equivalent existing Cyc term
                //Log.current.println("*** not importing " + cycFort.cyclify());
                damlTermInfo.cycFort = cycFort;
                previousDamlTermInfo = damlTermInfo;
                return cycFort;
            }
d973 1
a973 1
        if (equivalentDamlCycTerms.containsKey(constantName))
d975 3
a977 1
                (String) equivalentDamlCycTerms.get(constantName);
d1742 2
a1743 2
            Log.current.println(damlTerm + " --> " + cycTerm.toString());
            equivalentDamlCycTerms.put(damlTerm, cycTerm.toString());
d1932 1
a1932 1
        String equivalentDamlCycTerm;
d1979 1
a1979 1
                return equivalentDamlCycTerm;
@


1.41
log
@Improved SONAT import after refactoring.
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.40 2002/10/02 14:09:41 stephenreed Exp $
d1612 2
a1613 2
        cycAccess.assertSynonymousExternalConcept(cycTermName,
                                                  "WorldWideWeb-DynamicIndexedInfoSource",
d1615 1
a1615 1
                                                  mappingMt);
@


1.40
log
@Put a newline back in.
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.39 2002/10/02 14:05:43 stephenreed Exp $
d1601 9
a1609 1
        CycFort cycTerm = cycAccess.findOrCreate(cycTermName);
d1793 1
@


1.39
log
@Removed some newlines from output
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.38 2002/10/02 13:59:44 stephenreed Exp $
d580 1
a580 1
        Log.current.println("\n(#$isa " +
d917 1
@


1.38
log
@Experiments with UTF-8 character encoding scheme
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.37 2002/10/01 15:21:15 stephenreed Exp $
d570 1
a570 1
                                term.cyclify() + " #$SingleEntryFormat)\n");
d580 1
a580 1
        Log.current.println("(#$isa " +
d582 1
a582 1
                            collection.cyclify() + ")\n");
d608 1
a608 1
                            collection.cyclify() + ")\n");
d630 1
a630 1
                            objectTermInfo.toOriginalString() + "\")\n");
d651 1
a651 1
                            term2.cyclify() + ")\n");
d672 1
a672 1
                          term2.cyclify() + ")\n");
d691 1
a691 1
                          term2.cyclify() + ")\n");
d714 1
a714 1
                          genlPred.cyclify() + ")\n");
d757 1
a757 1
                          comment + "\")\n");
d806 1
a806 1
                            term.cyclify() + ")\n");
@


1.37
log
@Improved handling of lexical entries for imported DAML terms.
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.36 2002/10/01 02:53:21 stephenreed Exp $
d140 6
d169 18
a186 1
                               String importMtName)
d190 10
a199 2
        if (verbosity > 0)
            Log.current.println("\nImporting " + damlOntologyDefiningURLString + "\ninto " + importMtName);
d216 1
a216 1
        InputStream in;
d220 4
a223 1
            in = new FileInputStream(ff);
d229 4
a232 1
                in = url.openStream();
d770 1
d776 11
a786 1
                          literalTermInfo.literalValue() + "\")\n");
@


1.36
log
@Get ImportDamlApp working with new refactoring.
@
text
@d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.35 2002/09/30 23:20:54 stephenreed Exp $
a148 5
     *
     * @@param ontologyNicknames the dictionary associating each ontology uri with
     * the nickname used for the Cyc namespace qualifier
     * @@param kbSubsetCollectionName the name of the Cyc KbSubsetCollection
     * which identifies each of the imported terms
a566 6
        if (subjectTermInfo.constantName.startsWith("dmoz:DMOZ-"))
            term = new CycNart(cycAccess.getKnownConstantByName("OpenDirectoryTopicFn"),
                               term);
        if (objectTermInfo.constantName.startsWith("dmoz:DMOZ-"))
            collection = new CycNart(cycAccess.getKnownConstantByName("OpenDirectoryTopicFn"),
                                     collection);
d778 3
d783 2
a784 5
                 damlTermInfo.constantName.startsWith("dmoz:DMOZ-")) {
            //TODO generalize
            cycFort = new CycNart(cycAccess.getKnownConstantByName("OpenDirectoryTopicFn"),
                                  damlTermInfo.toString());
        }
d805 10
a814 1
            //Log.current.println("importing term: " + term);
d816 2
a817 6
                                kbSubsetCollection,
                                bookkeepingMt);
            if (damlTermInfo.isAnonymous)
                cycAccess.assertIsa(cycFort,
                                    cycAccess.getKnownConstantByName("DamlAnonymousClass"),
                                    importMt);
d819 1
d826 32
d867 2
d1599 26
d1704 8
d1713 10
a1722 2
        String term = "DamlConstant";
        String comment = "The KB subset collection of DAML terms.";
d1726 1
a1726 1
        cycAccess.assertGenls(term, "CycLConstant");
d1787 1
a1787 1
            "DamlConstant",
d1810 1
a1810 1
            "DamlConstant",
@


1.35
log
@Refactored DAML import classes
@
text
@d17 3
a19 1
 * Imports DAML xml content.<p>
d27 1
a27 1
 * @@version $Id: ImportDaml.java,v 1.34 2002/09/30 14:33:29 stephenreed Exp $
d48 1
a48 1
public class ImportDaml implements StatementHandler {
d66 1
a66 1
    protected int verbosity = DEFAULT_VERBOSITY;
d126 1
a126 1
    protected String kbSubsetCollectionName;
d600 1
a600 1
                                                  "DamlSonatSpindleHeadMt");
d790 3
a792 1
        else if (damlTermInfo.constantName.startsWith("dmoz:DMOZ-")) {
d1146 4
d1155 114
d1272 2
d1282 2
d1524 2
a1525 1
        Log.current.println("Mapping " + damlTermName + " to " + cycTerm.cyclify());
d1639 2
a1640 1
        Log.current.println("Creating common DAML vocabulary");
@


1.34
log
@Refactored DAML import classes to permit specialization for
the Open Directory DAML import.
@
text
@d25 1
a25 1
 * @@version $Id: ImportDaml.java,v 1.33 2002/09/27 15:09:48 stephenreed Exp $
d118 1
a118 1
    protected CycAccess cycAccess;
a138 7
     *
     * @@param cycAccess the CycAccess instance which manages the connection
     * to the Cyc server and provides Cyc API services
     * @@param ontologyNicknames the dictionary associating each ontology uri with
     * the nickname used for the Cyc namespace qualifier
     * @@param kbSubsetCollectionName the name of the Cyc KbSubsetCollection
     * which identifies each of the imported terms
d140 1
a140 8
    public ImportDaml(CycAccess cycAccess,
                      HashMap ontologyNicknames,
                      HashMap equivalentDamlCycTerms,
                      String kbSubsetCollectionName) {
        this.cycAccess = cycAccess;
        this.ontologyNicknames = ontologyNicknames;
        this.equivalentDamlCycTerms = equivalentDamlCycTerms;
        this.kbSubsetCollectionName = kbSubsetCollectionName;
a141 1
        //arp.setErrorHandler(new MyErrorHandler());
d147 5
d153 1
a153 1
    protected void initialize ()
d165 1
a165 1
    protected void importDaml (String damlOntologyDefiningURLString,
d1123 524
@


1.33
log
@Removed SAX error handler to get a better idea
of where the OpenDirectory RDF structure file has
its invalid unicode character.
@
text
@d14 1
d25 1
a25 1
 * @@version $Id: ImportDaml.java,v 1.32 2002/09/27 14:42:04 stephenreed Exp $
d240 1
a240 1
                processRestrictionSubject(subject, predicate, object);
d258 1
a259 1
            System.exit(1);
a285 5
                }
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
d287 5
d316 5
a320 1
                importGenls(subjectTermInfo, objLitTermInfo);
d381 7
a387 3
        arg2Constraints.addAllNew(cycAccess.getInterArgIsa1_2_forArg2((CycConstant) predicate,
                                                                      subject,
                                                                      cycAccess.universalVocabularyMt));
d389 3
a391 1
            importLiteralTriple(subject, predicate, objLitTermInfo, arg2Constraints);
d425 1
a425 1
                                (String) LiteralTermInfo.literal);
d439 1
a439 1
                                    (String) LiteralTermInfo.literal);
d487 15
d580 6
d797 4
a800 1
            //Log.current.println("importing term: " + cycFort.cyclify());
d941 1
a941 1
            string.startsWith("file://") ||
d953 1
a953 1
        return (uri.indexOf(":", 6) > -1) || (uri.indexOf("#") > -1);
d1264 2
a1265 1
               (uri.indexOf("daml+oil") > -1))
@


1.32
log
@Attempted to parse OpenDirectory structure RDF file.
Stopped by an invalid Unicode character in the file.
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.31 2002/09/25 15:10:15 stephenreed Exp $
d155 1
a155 1
        arp.setErrorHandler(new MyErrorHandler());
a159 33
     * Implements a SAX ErrorHandler to report the XML parsing errors.
     */
    protected class MyErrorHandler implements ErrorHandler {

        /**
         * Constructs a new MyErrorHandler object.
         */
        public MyErrorHandler () {
        }

        /**
         * Handles SAX XML parsing warnings.
         */
        public void warning(SAXParseException exception) {
            Log.current.println("SAX warning: " + exception.getMessage());
        }

        /**
         * Handles SAX XML parsing errors.
         */
        public void error(SAXParseException exception) {
            Log.current.println("SAX error: " + exception.getMessage());
        }

        /**
         * Handles SAX XML parsing fatal errors.
         */
        public void fatalError(SAXParseException exception) {
            Log.current.println("SAX fatal error: " + exception.getMessage());
        }
    }

    /**
d1383 33
@


1.31
log
@Added more definitional information to the mapped DAML terms.
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.30 2002/09/24 21:36:19 stephenreed Exp $
d155 1
d160 33
d1416 1
@


1.30
log
@Added synonymousExternalConcept mappings and xmlNameSpace assertions.
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.29 2002/09/23 16:15:12 stephenreed Exp $
d187 5
a191 1
        gaf.add(ontologyNicknames.get(damlOntologyDefiningURLString));
d333 2
a334 2
            if (damlPredicate.equals("equalSymbols")) {
                importEqualSymbols(subjectTermInfo, objLitTermInfo);
d566 2
a567 2
    protected void importEqualSymbols (DamlTermInfo subjectTermInfo,
                                    DamlTermInfo objectTermInfo)
d572 5
a576 3
        cycAccess.assertEqualSymbols(subjectTermInfo.toString(),
                                     objectTermInfo.toString());
        Log.current.println("(#$equalSymbols " +
d578 2
a579 1
                            objectTermInfo.cycFort.cyclify() + ")\n");
d790 4
@


1.29
log
@Reset the choice of imported DAML Sonat ontologies
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.28 2002/09/23 15:45:50 stephenreed Exp $
d148 1
d152 1
a162 72
        if (equivalentDamlCycTerms == null) {
            equivalentDamlCycTerms = new HashMap();

            //TODO - reify this mapping and discard this dictionary.

            // Collections
            equivalentDamlCycTerms.put("daml:Thing", "Thing");
            equivalentDamlCycTerms.put("rdfs:Resource", "Thing");

            equivalentDamlCycTerms.put("daml:Class", "Collection");
            equivalentDamlCycTerms.put("rdfs:Class", "Collection");

            equivalentDamlCycTerms.put("daml:Ontology", "AbstractInformationStructure");

            equivalentDamlCycTerms.put("daml:DatatypeProperty", "DamlDatatypeProperty");

            equivalentDamlCycTerms.put("daml:ObjectProperty", "DamlObjectProperty");

            equivalentDamlCycTerms.put("daml:Property", "BinaryPredicate");
            equivalentDamlCycTerms.put("rdfs:Property", "BinaryPredicate");
            equivalentDamlCycTerms.put("rdf:Property", "BinaryPredicate");

            equivalentDamlCycTerms.put("daml:TransitiveProperty", "TransitiveBinaryPredicate");

            equivalentDamlCycTerms.put("daml:Literal", "SubLAtomicTerm");
            equivalentDamlCycTerms.put("rdfs:Literal", "SubLAtomicTerm");

            equivalentDamlCycTerms.put("xsd:string", "SubLString");
            equivalentDamlCycTerms.put("xsd:decimal", "SubLRealNumber");
            equivalentDamlCycTerms.put("xsd:integer", "SubLInteger");
            equivalentDamlCycTerms.put("xsd:float", "SubLRealNumber");
            equivalentDamlCycTerms.put("xsd:double", "SubLRealNumber");
            equivalentDamlCycTerms.put("xsd:date", "Date");
            equivalentDamlCycTerms.put("xsd:uriReference", "UniformResourceLocator");
            equivalentDamlCycTerms.put("xsd:anyURI", "UniformResourceLocator");

            // Binary predicates
            equivalentDamlCycTerms.put("daml:subClassOf", "genls");
            equivalentDamlCycTerms.put("rdfs:subClassOf", "genls");

            equivalentDamlCycTerms.put("daml:type", "isa");
            equivalentDamlCycTerms.put("rdfs:type", "isa");
            equivalentDamlCycTerms.put("rdf:type", "isa");

            equivalentDamlCycTerms.put("daml:subPropertyOf", "genlPreds");
            equivalentDamlCycTerms.put("rdfs:subPropertyOf", "genlPreds");

            equivalentDamlCycTerms.put("daml:label", "nameString");
            equivalentDamlCycTerms.put("rdfs:label", "nameString");

            equivalentDamlCycTerms.put("daml:comment", "comment");
            equivalentDamlCycTerms.put("rdfs:comment", "comment");

            equivalentDamlCycTerms.put("daml:seeAlso", "conceptuallyRelated");
            equivalentDamlCycTerms.put("rdfs:seeAlso", "conceptuallyRelated");

            equivalentDamlCycTerms.put("daml:isDefinedBy", "containsInformationAbout");
            equivalentDamlCycTerms.put("rdfs:isDefinedBy", "containsInformationAbout");

            equivalentDamlCycTerms.put("daml:domain", "arg1Isa");
            equivalentDamlCycTerms.put("rdfs:domain", "arg1Isa");

            equivalentDamlCycTerms.put("daml:range", "arg2Isa");
            equivalentDamlCycTerms.put("rdfs:range", "arg2Isa");

            equivalentDamlCycTerms.put("daml:differentIndividualFrom", "different");

            equivalentDamlCycTerms.put("daml:samePropertyAs", "equalSymbols");

            equivalentDamlCycTerms.put("daml:disjointWith", "different");

        }
d185 5
@


1.28
log
@Fixed initialization of CycAccess.bookkeepingMt
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.27 2002/09/23 14:47:35 stephenreed Exp $
d565 1
a565 6
        cycAccess.assertGaf(cycAccess.bookkeepingMt,
                            cycAccess.getKnownConstantByName("damlOntology"),
                            term,
                            damlOntologyDefiningURL);
        if ((! subjectTermInfo.isURI) &&
            (! subjectTermInfo.isAnonymous))
d567 1
a567 1
                                cycAccess.getKnownConstantByName("damlURI"),
d569 8
a576 2
                                new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                            subjectTermInfo.uri));
@


1.27
log
@Added damlURI predicate.
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.26 2002/09/22 22:27:56 stephenreed Exp $
d565 1
a565 1
        cycAccess.assertGaf(importMt,
d569 7
a575 5
        cycAccess.assertGaf(importMt,
                            cycAccess.getKnownConstantByName("damlURI"),
                            term,
                            new CycNart(cycAccess.getKnownConstantByName("URLFn"),
                                        subjectTermInfo.uri));
@


1.26
log
@Modified damlOntology
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.25 2002/09/22 20:32:06 stephenreed Exp $
d366 1
a366 1
        if (predicateTermInfo.isURI) {
a367 1
        }
d369 55
a423 53
        if (damlPredicate.equals("isa")) {
            importIsa(subjectTermInfo, objLitTermInfo);
            return;
        }
        if (damlPredicate.equals("genls")) {
            importGenls(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("daml:versionInfo")) {
            importVersionInfo(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("daml:imports")) {
            importImports(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("comment")) {
            importComment(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("nameString")) {
            importNameString(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("equalSymbols")) {
            importEqualSymbols(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("arg1Isa")) {
            importArg1Isa(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("arg2Isa")) {
            importArg2Isa(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("conceptuallyRelated")) {
            importConceptuallyRelated(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("containsInformationAbout")) {
            importContainsInformationAbout(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (damlPredicate.equals("genlPreds")) {
            importGenlPreds(subjectTermInfo, objLitTermInfo);
            return;
        }
        else if (predicateTermInfo.ontologyNickname.equals("daml") ||
                 predicateTermInfo.ontologyNickname.equals("rdfs") ||
                 predicateTermInfo.ontologyNickname.equals("rdf")) {
            Log.current.println("\n\nUnhandled predicate: " + damlPredicate + "\n");
            return;
d565 9
a586 4
        cycAccess.assertGaf(importMt,
                            cycAccess.getKnownConstantByName("damlOntology"),
                            term,
                            damlOntologyDefiningURL);
d884 1
a897 1
            damlTermInfo.uri = resource.toString();
d1282 9
@


1.25
log
@Added #$damlOntology assertions.
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.24 2002/09/20 22:38:50 stephenreed Exp $
a553 1

a569 1

d577 4
a838 9


            // TODO be more selective about the defining assertion:
            // use rdf:type (#$isa)

            cycAccess.assertGaf(importMt,
                                cycAccess.getKnownConstantByName("damlOntology"),
                                cycFort,
                                damlOntologyDefiningURL);
@


1.24
log
@Improved mapping of xml schema primitive datatypes
@
text
@d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.23 2002/09/20 14:01:40 stephenreed Exp $
d89 10
d240 1
a240 1
     * @@param damlPath the URL to import
d243 1
a243 1
    protected void importDaml (String damlPath,
d246 1
d249 1
a249 1
            Log.current.println("\nImporting " + damlPath + "\ninto " + importMtName);
d251 4
d260 1
a260 1
            File ff = new File(damlPath);
d266 1
a266 1
                url = new URL(damlPath);
d270 1
a270 1
                System.err.println("ARP: Failed to open: " + damlPath);
d280 1
a280 1
            System.err.println("Error: " + damlPath + ": " + ParseException.formatMessage(e));
d283 1
a283 1
            System.err.println("Error: " + damlPath + ": " + ParseException.formatMessage(sax));
d286 1
a286 1
            Log.current.println("\nDone importing " + damlPath + "\n");
d479 1
d482 2
a483 1
            if (arg2Constraint.equals(cycAccess.getKnownConstantByName("SubLString"))) {
a814 1
            //Log.current.println("importing term: " + term);
d826 8
d837 9
@


1.23
log
@Added the assertion of forward arg constraints.
@
text
@d5 1
d24 1
a24 1
 * @@version $Id: ImportDaml.java,v 1.22 2002/09/20 02:33:33 stephenreed Exp $
d54 6
d178 7
a184 2
            equivalentDamlCycTerms.put("xsd:string", "CharacterString");

d349 2
d415 8
d424 1
a424 7
            cycAccess.assertGaf(importMt,
                                predicate,
                                subject,
                                (String) objLitTermInfo.literal);
            Log.current.println("(" + predicate.cyclify() + " " +
                                subject.cyclify() + " \"" +
                                (String) objLitTermInfo.literal + "\")\n");
d430 1
a430 14
        CycList arg2Constraints =
            cycAccess.getArg2Isas((CycConstant) predicate, cycAccess.universalVocabularyMt);
        arg2Constraints.addAllNew(cycAccess.getInterArgIsa1_2_forArg2((CycConstant) predicate,
                                                                      subject,
                                                                      cycAccess.universalVocabularyMt));
        for (int i = 0; i < arg2Constraints.size(); i++) {
            CycFort arg2Constraint = (CycFort) arg2Constraints.get(i);
            if (! cycAccess.isa(object, arg2Constraint)) {
                cycAccess.assertIsa(object, arg2Constraint, cycAccess.universalVocabularyMt);
                Log.current.println("*** asserting forward arg constraint " +
                                    "(#$isa " + object.cyclify() + " " +
                                    arg2Constraint.cyclify() + ")");
            }
        }
d441 98
d548 7
d577 4
d888 2
d1059 3
a1061 2
                cycAccess.assertGaf(damlRestriction.interArgIsaConstraint,
                                    importMt);
d1065 3
a1067 2
                cycAccess.assertGaf(damlRestriction.interArgFormatConstraint,
                                    importMt);
@


1.22
log
@Handle DAML term forward references.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.21 2002/09/19 19:54:13 stephenreed Exp $
d414 14
d736 1
a736 1
        DamlTermInfo damlTermInfo = new DamlTermInfo();
d786 1
a786 1
        DamlTermInfo damlTermInfo = new DamlTermInfo();
d1128 2
a1129 1
            if (parent.
@


1.21
log
@Improvements to bookkeeping and transcript handling when
creating constants.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.20 2002/09/18 17:20:17 stephenreed Exp $
d1002 1
d1019 2
a1020 1
        public DamlTermInfo() {
d1114 1
@


1.20
log
@Remaining fixes to import SONAT DAML ontologies, including Restrictions.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.19 2002/09/18 14:39:16 stephenreed Exp $
d433 2
a434 5
        String collectionName = objectTermInfo.toString();
        CycFort collection = cycAccess.getConstantByName(collectionName);
        if (collection == null) {
            Log.current.println("*** " + collectionName + " is undefined ***\n");
            collection = importTerm(objectTermInfo);
d436 1
d455 2
a456 9
        if (term == null) {
            Log.current.println("\n*** " + subjectTermInfo.toString() + " is an invalid constant ***");
            return;
        }
        String collectionName = objectTermInfo.toString();
        CycFort collection = cycAccess.getConstantByName(collectionName);
        if (collection == null) {
            Log.current.println("\n*** " + collectionName + " is undefined ***");
            collection = importTerm(objectTermInfo);
d458 1
d497 4
d518 4
d558 5
d1192 4
d1197 4
@


1.19
log
@More fixes to SONAT DAML import.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.18 2002/09/18 03:47:02 stephenreed Exp $
d173 2
a269 16
        if (subject.isAnonymous()) {
            processRestrictionSubject(subject, predicate, object);
            Log.current.println();
            return;
        }
        if (object.isAnonymous()) {
            processRestrictionObject(subject, predicate, object);
            Log.current.println();
        return;
        }
        DamlTermInfo subjectTermInfo = resource(subject, null);
        DamlTermInfo predicateTermInfo = resource(predicate, null);
        DamlTermInfo objectTermInfo = resource(object, predicateTermInfo);
        displayTriple(subjectTermInfo,
                      predicateTermInfo,
                      objectTermInfo);
d271 14
a291 1

d303 11
a313 10
        if (subject.isAnonymous()) {
            processRestrictionSubject(subject, predicate, literal);
        }
        else {
            DamlTermInfo subjectTermInfo = resource(subject, null);
            DamlTermInfo predicateTermInfo = resource(predicate, null);
            DamlTermInfo literalTermInfo = literal(literal);
            displayTriple(subjectTermInfo,
                          predicateTermInfo,
                          literalTermInfo);
a314 1
            try {
d318 1
a322 1

a323 1
        }
d485 2
d654 2
a655 1
        if (previousDamlTermInfo != null &&
d815 2
a816 1
                                             AResource object) {
d830 3
a832 9
            try {
                importTriple(subjectTermInfo,
                             predicateTermInfo,
                             objectTermInfo);
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
            }
d835 10
a844 4
        else if (predicateTermInfo.toString().equals("daml:onProperty"))
            damlRestriction.property = objectTermInfo.toString();
        else if (predicateTermInfo.toString().equals("daml:toClass"))
            damlRestriction.toClasses.add(objectTermInfo.toString());
d859 2
a860 1
                                             ALiteral literal) {
d869 3
a871 9
            try {
                importTriple(subjectTermInfo,
                             predicateTermInfo,
                             literalTermInfo);
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
            }
d874 9
a882 4
        throw new RuntimeException("Unexpected restriction triple \n" +
                                   subjectTermInfo.toString() + " " +
                                   predicateTermInfo.toString() + " " +
                                   literalTermInfo.toString());
d894 2
a895 1
                                            AResource object) {
d915 5
a919 2
        if (predicateTermInfo.toString().equals("genls"))
            damlRestriction.fromClass = subjectTermInfo.toString();
d924 12
a935 3
            damlRestriction.formInterArgIsaConstraint();
            cycAccess.assertGaf(damlRestriction.interArgIsaConstraint,
                                importMt);
a940 1
        Log.current.println("\n" + damlRestriction.interArgIsaConstraint.cyclify());
d1117 1
a1117 1
     * as Cyc interArgIsa1-2 assertions.
d1135 1
a1135 1
        public String fromClass;
d1140 1
a1140 1
        public String property;
d1149 6
a1154 1
         * The interArgIsa1-2 constraint sentence.
d1159 5
d1170 15
a1184 1
        public CycList formInterArgIsaConstraint()
d1187 1
d1189 4
a1192 3
                    "(#$interArgIsa1-2 #$" + property +
                    " #$" + fromClass +
                    " #$" + toClasses.get(0) + ")";
d1197 1
a1197 1
                throw new RuntimeException("Unhandled restriction case: " +
d1199 19
a1217 1
            return interArgIsaConstraint;
@


1.18
log
@Added more code to handle DAML restrictions
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.17 2002/09/17 15:18:13 stephenreed Exp $
d146 4
d151 2
d155 1
d157 1
d159 1
d161 3
d165 6
d172 36
a277 1

a280 1

a283 2
        Log.current.println();

a305 1
            Log.current.println();
a310 1

a313 1
            Log.current.println();
d343 1
a343 1
        if (damlPredicate.equals("rdf:type")) {
d347 1
a347 2
        if (damlPredicate.equals("rdfs:subClassOf") ||
            damlPredicate.equals("daml:subClassOf")) {
d359 1
a359 2
        else if (damlPredicate.equals("rdfs:comment") ||
                 damlPredicate.equals("daml:comment")) {
d363 1
a363 2
        else if (damlPredicate.equals("rdfs:label") ||
                 damlPredicate.equals("daml:label")) {
d367 1
a367 1
        else if (damlPredicate.equals("daml:samePropertyAs")) {
d371 1
a371 2
        else if (damlPredicate.equals("rdfs:domain") ||
                 damlPredicate.equals("daml:domain")) {
d375 1
a375 2
        else if (damlPredicate.equals("rdfs:range") ||
                 damlPredicate.equals("daml:range")) {
d379 1
a379 1
        else if (damlPredicate.equals("rdfs:seeAlso")) {
d383 2
a384 2
        else if (damlPredicate.equals("rdfs:isDefinedBy")) {
            importSubInformation(subjectTermInfo, objLitTermInfo);
d387 1
a387 2
        else if (damlPredicate.equals("rdfs:subPropertyOf") ||
                 damlPredicate.equals("daml:subPropertyOf")) {
d408 3
d420 3
a422 1

a435 2
        if (equivalentDamlCycTerms.containsKey(collectionName))
            collectionName = (String) equivalentDamlCycTerms.get(collectionName);
d444 3
a463 2
        if (equivalentDamlCycTerms.containsKey(collectionName))
            collectionName = (String) equivalentDamlCycTerms.get(collectionName);
d472 3
d489 3
d506 3
d523 3
d542 3
d560 3
a598 4
        if (term == null) {
            Log.current.println("\n*** " + subjectTermInfo.toString() + " is an invalid constant ***");
            return;
        }
d603 3
d621 3
d632 2
a633 2
    protected void importSubInformation (DamlTermInfo subjectTermInfo,
                                         DamlTermInfo uriTermInfo)
d638 6
a643 3
                            cycAccess.getKnownConstantByName("subInformation"),
                            term,
                            resource);
d698 1
a698 1
        stringBuffer.append(subjectTermInfo.toString());
d700 1
a700 1
        stringBuffer.append(predicateTermInfo.toString());
d702 2
a703 2
        stringBuffer.append(objLitTermInfo.toString());
        Log.current.print(stringBuffer.toString());
d753 3
d767 9
a775 2
        damlTermInfo.isLiteral = true;
        damlTermInfo.literal = literal.toString();
d780 26
d821 1
a821 1
        if (predicateTermInfo.toString().equals("rdf:type") &&
d826 13
d856 2
a857 2
                                            AResource predicate,
                                            ALiteral literal) {
a860 2


d864 13
d899 14
a912 1
        if (predicateTermInfo.toString().equals("daml:subClassOf"))
d919 2
d926 2
a927 1
        Log.current.println("\n   DamlRestriction: " + damlRestriction.toString());
a949 11
     * Returns true if the given URI has embedded XML namespace separators.
     *
     * @@param uri the URI
     * @@return true if the given URI has embedded XML namespace separators, otherwise
     * false
     */
    protected boolean hasUriNamespaceSyntax (String uri) {
        return (uri.indexOf(":", 6) > -1) || (uri.indexOf("#") > -1);
    }

    /**
d993 1
d1015 12
d1038 2
d1065 2
@


1.17
log
@Improved handling of DAML imported terms whose name
differs only in case from existing terms.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.16 2002/09/16 13:55:22 stephenreed Exp $
d153 1
a713 2

        /*
d717 12
a728 1
                      */
d745 1
a745 1
        /*
d749 4
a752 1
                      */
a767 2

        /*
d771 13
a783 1
                      */
d958 5
d966 1
a966 1
        String anonymousId;
d971 1
a971 1
        String fromClass;
d976 1
a976 1
        String property;
d982 29
a1010 1
        ArrayList toClasses;
d1023 2
a1025 1
            stringBuffer.append(property);
d1031 3
a1033 1
            stringBuffer.append(")");
@


1.16
log
@Fixed missing ontology nicknames for SONAT DAML import.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.15 2002/09/16 09:16:30 stephenreed Exp $
a358 4
            if (predicate == null) {
                Log.current.println("\n*** " + damlPredicate + " is an invalid constant ***");
                return;
            }
a387 4
        if (term == null) {
            Log.current.println("\n*** " + subjectTermInfo.toString() + " is an invalid constant ***");
            return;
        }
d578 1
a578 1
     * Imports the given term.
d581 1
@


1.15
log
@More fixes to SONAT DAML ontology import.  Only property
restrictions remain to be coded.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.14 2002/09/16 08:52:34 stephenreed Exp $
d326 2
a327 1
        else if (damlPredicate.equals("rdfs:domain")) {
d331 2
a332 1
        else if (damlPredicate.equals("rdfs:range")) {
@


1.14
log
@Further fixes to import DAML SONAT ontologies.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.12 2002/09/13 22:55:51 stephenreed Exp $
d299 2
a300 1
        if (damlPredicate.equals("rdfs:subClassOf")) {
d541 4
d665 1
a665 1
            nameSpace = aResource.getURI().substring(0, index);
@


1.13
log
@Fixes after unit testing SONAT DAML import
@
text
@d109 11
d148 1
d154 2
d224 3
a226 3
        DamlTermInfo subjectTermInfo = resource(subject);
        DamlTermInfo predicateTermInfo = resource(predicate);
        DamlTermInfo objectTermInfo = resource(object);
d258 2
a259 2
            DamlTermInfo subjectTermInfo = resource(subject);
            DamlTermInfo predicateTermInfo = resource(predicate);
d291 5
a295 2
        String predicate = predicateTermInfo.toString();
        if (predicate.equals("rdf:type")) {
d297 1
d299 5
a303 1
        else if (predicate.equals("daml:versionInfo")) {
d305 1
d307 1
a307 1
        else if (predicate.equals("daml:imports")) {
d309 1
d311 2
a312 1
        else if (predicate.equals("rdfs:comment")) {
d314 1
d316 2
a317 1
        else if (predicate.equals("rdfs:label")) {
d319 49
d369 8
a376 2
        else
            Log.current.println("\nUnhandled predicate: " + predicate);
d389 4
d394 1
a394 1
        if (this.equivalentDamlCycTerms.containsKey(collectionName))
d396 6
a401 1
        CycFort collection = cycAccess.getKnownConstantByName(collectionName);
d403 101
a503 2
                            collection,
                            importMt);
d516 1
a516 3
        cycAccess.assertNameString(term,
                                   literalTermInfo.literalValue(),
                                   importMt);
d562 17
d593 1
a593 1
            Log.current.println("importing term: " + cycFort.cyclify());
d597 15
a611 3
            Log.current.println("importing term: " + term);
            cycFort = cycAccess.findOrCreate(term);
            cycAccess.assertIsa(term, kbSubsetCollectionName);
d641 2
d645 2
a646 1
    protected DamlTermInfo resource(AResource aResource) {
d648 2
d654 7
d665 3
d670 2
a671 13
            String localName = resource.getLocalName();
            damlTermInfo.localName = localName;
            String nameSpace = resource.getNameSpace();
            damlTermInfo.nameSpace = nameSpace;
            if (localName == null ||
                nameSpace == null)
                throw new RuntimeException("Invalid nameSpace " + nameSpace +
                                           " localName " + localName +
                                           " for resource " + resource.toString());
            String ontologyNickname = getOntologyNickname(nameSpace, resource);
            damlTermInfo.ontologyNickname = ontologyNickname;
            String constantName = ontologyNickname + ":" + localName;
            damlTermInfo.constantName = constantName;
d673 11
d710 3
a712 3
        DamlTermInfo subjectTermInfo = resource(subject);
        DamlTermInfo predicateTermInfo = resource(predicate);
        DamlTermInfo objectTermInfo = resource(object);
d731 2
a732 2
        DamlTermInfo subjectTermInfo = resource(subject);
        DamlTermInfo predicateTermInfo = resource(predicate);
d752 3
a754 3
        DamlTermInfo subjectTermInfo = resource(subject);
        DamlTermInfo predicateTermInfo = resource(predicate);
        DamlTermInfo objectTermInfo = resource(object);
d775 3
a777 3
            boolean ans = hasUriNamespaceSyntax(resource.getURI());
            throw new RuntimeException("Ontology nickname not found for " + key +
                                       "\nResource " + resource.toString());
a813 11
     * Assert that the given term is an instance of the DamlSonatConstant KB
     * subset collection.
     *
     * @@param cycConstantName the name of the Cyc constant
     */
    protected void assertIsaDamlSonatConstant (String cycConstantName)
        throws IOException, CycApiException {
        cycAccess.assertIsa(cycConstantName, kbSubsetCollectionName, "BookkeepingMt");
    }

    /**
d872 1
d883 41
@


1.12
log
@Began importing some DAML
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.11 2002/09/12 15:03:24 stephenreed Exp $
d77 5
d84 6
a89 1
    protected String importMt;
d138 2
a139 2
            equivalentDamlCycTerms.put("daml:DatatypeProperty", "BinaryPredicate");
            equivalentDamlCycTerms.put("daml:ObjectProperty", "BinaryPredicate");
d148 1
a148 1
     * @@param importMt the microtheory into which DAML content is asserted
d151 1
a151 1
                               String importMt)
d153 1
a153 1
        this.importMt = importMt;
d155 2
a156 1
            Log.current.println("\nImporting " + damlPath + "\ninto " + importMt);
d158 1
d199 1
a199 1
        if (subject.isAnonymous())
d201 4
a204 1
        else if (object.isAnonymous())
d206 7
a212 4
        else {
            DamlTermInfo subjectTermInfo = resource(subject);
            DamlTermInfo predicateTermInfo = resource(predicate);
            DamlTermInfo objectTermInfo = resource(object);
d214 4
a217 3
            displayTriple(subjectTermInfo,
                          predicateTermInfo,
                          objectTermInfo);
d219 8
a226 8
            try {
                importTriple(subjectTermInfo,
                             predicateTermInfo,
                             objectTermInfo);
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
a227 1
            }
a228 1
        Log.current.println();
d239 1
a239 1
        if (subject.isAnonymous())
d241 2
d251 1
a263 1
        Log.current.println();
d285 1
a285 1
            importVersionInfo(subjectTermInfo, objLitTermInfo);
d304 10
a313 1
                              DamlTermInfo objectTermInfo) {
d323 17
a339 1
                                      DamlTermInfo literalTermInfo) {
d351 4
a354 3
        importTerm(subjectTermInfo);
        cycAccess.assertComment(subjectTermInfo.toString(),
                                literalTermInfo.toString(),
d365 6
a370 1
                                     DamlTermInfo literalTermInfo) {
a372 2


d378 1
a378 1
    protected void importTerm (DamlTermInfo damlTermInfo)
d380 5
a384 1
        String term;
d386 3
a388 1
            //term = "(StringMentionFn + term
d391 8
a398 10
            term = damlTermInfo.toString();
            try {
                cycAccess.findOrCreate(term);
            }
            catch (CycApiException e) {
                Log.current.println("importing term: " + damlTermInfo.toString());
                Log.current.printStackTrace(e);
            }
        }
        cycAccess.assertIsa(term, kbSubsetCollectionName);
d616 1
d625 12
d650 11
@


1.11
log
@Refactored ImportDaml into two classes.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.10 2002/09/12 03:22:11 stephenreed Exp $
d64 6
d123 9
d199 11
d232 11
d248 102
d430 1
d434 1
d451 1
d455 1
d472 1
d476 1
@


1.10
log
@Added more helper functions to CycAccess in preparation
to mass entry of DAML import terms.
@
text
@d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.9 2002/09/12 00:48:32 stephenreed Exp $
a63 5
     * The list of DAML web documents to import.
     */
    public static ArrayList documentsToImport = new ArrayList();

    /**
d68 1
a68 1
    protected HashMap ontologyNicknames = new HashMap();
d71 1
a71 2
     * Ontology import microtheories.
     * ontology url --> mt
d73 1
a73 1
    protected HashMap ontologyMts = new HashMap();
d87 2
a88 2
     * The KB Subset collection which identifies all DAML SONAT
     * ontology import terms in Cyc.
d90 1
a90 1
    protected CycConstant damlSonatConstant;
d94 14
a107 2
     */
    public ImportDaml() {
a112 51
     * Provides the main method for the ImportDaml application.
     *
     * @@param args ignored.
     */
    public static void main(String[] args) {
        Log.makeLog();
        initializeDocumentsToImport();
        for (int i = 16; i < 17; i++) {
        //for (int i = 0; i < documentsToImport.size(); i++) {
        //for (int i = 0; i < 5; i++) {
            String damlPath = (String) documentsToImport.get(i);
            ImportDaml importDaml = new ImportDaml();
            try {
            importDaml.initialize();
            importDaml.importDaml(damlPath);
            }
            catch (Exception e) {
                Log.current.printStackTrace(e);
                System.exit(1);
            }
        }
    }

    /**
     * Initializes the documents to import.
     */
    protected static void initializeDocumentsToImport () {
        documentsToImport.add("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont.daml");
        documentsToImport.add("http://www.daml.org/2001/10/html/airport-ont.daml");
        documentsToImport.add("http://www.daml.org/2001/09/countries/fips.daml");
        documentsToImport.add("http://www.daml.org/2001/09/countries/fips-10-4.daml");
        documentsToImport.add("http://www.daml.org/2001/12/factbook/factbook-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/agency-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/CINC-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/af-a.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/assessment-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/economic-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/information-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/infrastructure-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/location-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/military-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/objectives-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/operation-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/political-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/social-elements-ont.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/example1.daml");
        documentsToImport.add("http://www.daml.org/experiment/ontology/example2.daml");
    }

    /**
a116 120
        initializeOntologyMts();
        initializeOntologyNicknames();
        cycAccess = new CycAccess();
        initializeCycTerms();
    }

    /**
     * Initializes the Ontology url --> import mt mapping.
     */
    protected void initializeOntologyMts () {
        ontologyMts.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont.daml",
                        "DamlSonatDrcVesOntologyMt");
        ontologyMts.put("http://www.daml.org/2001/10/html/airport-ont.daml",
                        "DamlSonatAirportOntologyMt");
        ontologyMts.put("http://www.daml.org/2001/09/countries/fips.daml",
                        "DamlSonatFipsOntologyMt");
        ontologyMts.put("http://www.daml.org/2001/09/countries/fips-10-4.daml",
                        "DamlSonatFips10-4OntologyMt");
        ontologyMts.put("http://www.daml.org/2001/12/factbook/factbook-ont.daml",
                        "DamlSonatCiaFactbookOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/agency-ont.daml",
                        "DamlSonatAgencyOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/CINC-ont.daml",
                        "DamlSonatCincOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/af-a.daml",
                        "DamlSonatAfghanistanAOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/assessment-ont.daml",
                        "DamlSonatAssessmentOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/economic-elements-ont.daml",
                        "DamlSonatEconomicElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/elements-ont.daml",
                        "DamlSonatElementsOfNationalPowerOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/information-elements-ont.daml",
                        "DamlSonatInformationElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/infrastructure-elements-ont.daml",
                        "DamlSonatInfrastructureElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/location-ont.daml",
                        "DamlSonatLocationOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/military-elements-ont.daml",
                        "DamlSonatMilitaryElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/objectives-ont.daml",
                        "DamlSonatObjectivesOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/operation-ont.daml",
                        "DamlSonatOperationOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/political-elements-ont.daml",
                        "DamlSonatPoliticalElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/social-elements-ont.daml",
                        "DamlSonatSocialElementsOntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/example1.daml",
                        "DamlSonatExample1OntologyMt");
        ontologyMts.put("http://www.daml.org/experiment/ontology/example2.daml",
                        "DamlSonatExample2OntologyMt");
    }

    /**
     * Initializes the Ontology nicknames mapping.
     */
    protected void initializeOntologyNicknames () {
        ontologyNicknames.put("http://www.w3.org/1999/02/22-rdf-syntax-ns", "rdf");
        ontologyNicknames.put("http://www.w3.org/2000/01/rdf-schema", "rdfs");
        ontologyNicknames.put("http://www.w3.org/2000/10/XMLSchema", "xsd");

        ontologyNicknames.put("http://www.daml.org/2001/03/daml+oil", "daml");

        ontologyNicknames.put("http://orlando.drc.com/daml/Ontology/daml-extension/3.2/daml-ext-ont", "daml-ext");

        ontologyNicknames.put("http://www.daml.org/2001/12/factbook/factbook-ont.daml", "factbook");

        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont.daml", "ves");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont", "ves");

        ontologyNicknames.put("http://www.daml.org/2001/10/html/airport-ont.daml", "airport");

        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips-10-4-ont", "fips10-4");

        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips.daml", "fips");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont.daml", "enp");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont", "enp");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/objectives-ont.daml", "obj");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/objectives-ont", "obj");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/social-elements-ont.daml", "soci");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/social-elements-ont", "soci");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/political-elements-ont.daml", "poli");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/political-elements-ont", "poli");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/economic-elements-ont.daml", "econ");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/economic-elements-ont", "econ");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/infrastructure-elements-ont.daml", "infr");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/infrastructure-elements-ont", "infr");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/information-elements-ont.daml", "info");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/information-elements-ont", "info");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/military-elements-ont.daml", "mil");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/military-elements-ont", "mil");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/ona.xsd", "dt");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/location-ont.daml", "loc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/location-ont", "loc");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/assessment-ont.daml", "assess");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/assessment-ont", "assess");

        ontologyNicknames.put("http://www.daml.org/2001/02/geofile/geofile-dt.xsd", "geodt");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/CINC-ont.daml", "cinc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/CINC-ont", "cinc");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/cinc-ont", "cinc");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/agency-ont.daml", "agent");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/agency-ont", "agent");

        ontologyNicknames.put("http://www.daml.org/experiment/ontology/operation-ont.daml", "oper");
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/operation-ont", "oper");
a118 10

    /**
     * Initializes Cyc terms used in the DAML import.
     */
    protected void initializeCycTerms ()
        throws IOException, CycApiException {
        damlSonatConstant = cycAccess.getKnownConstantByName("DamlSonatConstant");
    }


d123 1
d125 2
a126 1
    protected void importDaml (String damlPath)
d128 1
a128 4
        String mtName = (String) ontologyMts.get(damlPath);
        if (mtName == null)
            throw new RuntimeException("No mt for damlPath " + damlPath);
        CycConstant importMt = cycAccess.getKnownConstantByName(mtName);
d130 1
a130 1
            Log.current.println("\nImporting " + damlPath + "\ninto " + importMt.cyclify());
a279 1
     *
a298 1
     *
a317 1
     *
d387 2
d390 1
a390 1
    protected void assertIsaDamlSonatConstant (CycConstant cycConstant)
d392 1
a392 1
        cycAccess.assertIsa(cycConstant, damlSonatConstant, cycAccess.bookkeepingMt);
@


1.9
log
@DAML additions
@
text
@d10 2
d23 1
a23 1
 * @@version $Id: ImportDaml.java,v 1.8 2002/09/11 14:46:54 stephenreed Exp $
d71 1
d76 6
d85 12
a96 1
    DamlRestriction damlRestriction;
d119 1
d122 5
d160 3
a162 1
    protected void initialize () {
d164 2
d169 49
a217 1
     * Initializes the ImportDaml object.
d286 9
d299 6
a304 1
    protected void importDaml (String damlPath) {
d306 1
a306 1
            Log.current.println("\nImporting " + damlPath);
a529 1

d549 1
a549 1
    static public Resource translateResource(AResource aResource) {
d564 9
a580 1

@


1.8
log
@Added DamlRestriction inner class to contain the
components used to import a DAML Restriction as
a Cyc interArg1-2 assertion.
@
text
@d21 1
a21 1
 * @@version $Id: ImportDaml.java,v 1.7 2002/09/11 08:31:30 stephenreed Exp $
d256 13
a268 3
        resource(subject);
        resource(predicate);
        resource(object);
d277 1
a277 1
     * @@param object the RDF Triple Object
d280 11
a290 11
        String lang = literal.getLang();
        String parseType = literal.getParseType();
        if (parseType != null) {
            Log.current.print("# ");
            if (parseType != null)
                Log.current.print("'" + parseType + "'");
            Log.current.println();
        }
        resource(subject);
        resource(predicate);
        literal(literal);
d295 1
a295 1
     * Displays the given RDF resource.
d297 21
a317 1
     * @@param aResource the RDF resource to be displayed
d319 11
a329 4
    protected void resource(AResource aResource) {
        Resource resource = this.translate(aResource);
        if (aResource.isAnonymous())
            Log.current.print("anon-" + aResource.getAnonymousID() + " ");
d332 1
d334 1
d336 8
a343 11
                nameSpace == null) {
                Log.current.print(resource.toString() + " ");
            }
            else if (! hasUriNamespaceSyntax(aResource.getURI())) {
                Log.current.print(resource.toString() + " ");
            }
            else {
                String nickname = getOntologyNickname(nameSpace, resource);
                String constantName = nickname + ":" + localName;
                Log.current.print(constantName + " ");
            }
d345 34
d382 1
a382 1
     * Displays the given RDF literal.
d384 4
a387 1
     * @@param literal the RDF literal to be displayed
d389 30
a418 10
    static private void literal(ALiteral literal) {
        if (literal.isWellFormedXML())
            Log.current.print("xml");
        Log.current.print("\"");
        Log.current.print(literal.toString());
        Log.current.print("\"");
        String lang = literal.getLang();
        if (lang != null && !lang.equals(""))
            Log.current.print("-" + lang);
        Log.current.print(" ");
d458 1
a458 1
    static public Resource translate(AResource aResource) {
d467 2
a468 1
        } else
d481 40
@


1.7
log
@Used Another RDF Parser (ARP) for DAML imports
because it streams and can handle larger DAML files
than the jena in-memory model.
@
text
@d21 1
a21 1
 * @@version $Id: ImportDaml.java,v 1.6 2002/09/11 03:41:52 stephenreed Exp $
d73 6
d214 2
a215 2
            System.out.println("\nImporting " + damlPath);
        System.out.println("\nStatements\n");
d245 1
a245 1
            System.out.println("\nDone importing " + damlPath + "\n");
d259 1
a259 1
        System.out.println();
d273 1
a273 1
            System.out.print("# ");
d275 2
a276 2
                System.out.print("'" + parseType + "'");
            System.out.println();
d281 1
a281 1
        System.out.println();
d292 1
a292 1
            System.out.print("anon-" + aResource.getAnonymousID() + " ");
d298 1
a298 1
                System.out.print(resource.toString() + " ");
d301 1
a301 1
                System.out.print(resource.toString() + " ");
d306 1
a306 1
                System.out.print(constantName + " ");
d318 4
a321 4
            System.out.print("xml");
        System.out.print("\"");
        System.out.print(literal.toString());
        System.out.print("\"");
d324 2
a325 2
            System.out.print("-" + lang);
        System.out.print(" ");
d388 50
@


1.6
log
@Added listing of RDF triples to evolving code of DAML import.
@
text
@d4 1
d6 3
a8 2
import com.hp.hpl.jena.daml.*;
import com.hp.hpl.jena.daml.common.DAMLModelImpl;
d21 1
a21 1
 * @@version $Id: ImportDaml.java,v 1.5 2002/09/10 21:14:09 stephenreed Exp $
d42 1
a42 1
public class ImportDaml {
d57 5
d76 2
d200 1
d202 3
a204 1
     * Imports the DAML document.
a206 1
        DAMLModel damlModel = new DAMLModelImpl();
d209 3
d213 3
a215 1
            damlModel.read(damlPath);
d217 11
a227 2
        catch (RDFException e) {
            e.printStackTrace();
a228 8
        System.out.println(damlModel.toString());
        System.out.println("Statements");

        String localName;
        String nameSpace;
        String nickname;
        String constantName;
        // list the statements in the graph
d230 1
a230 58
            StmtIterator stmtIter = damlModel.listStatements();

            while (stmtIter.hasNext()) {
                Statement statement = stmtIter.next();
                Resource subject = statement.getSubject();
                Property predicate = statement.getPredicate();
                RDFNode object = statement.getObject();

                if (subject instanceof Resource) {
                    Resource subjectResource = (Resource) subject;
                    localName = subjectResource.getLocalName();
                    nameSpace = subjectResource.getNameSpace();
                    if (localName == null || nameSpace == null) {
                        System.out.print(subjectResource.toString() + " ");
                    }
                    else {
                        nickname = getOntologyNickname(nameSpace, subjectResource);
                        constantName = nickname + ":" + localName;
                        System.out.print(constantName + " ");
                    }
                }
                else
                    System.out.print(subject + " ");

                if (predicate instanceof Resource) {
                    Resource predicateResource = (Resource) predicate;
                    localName = predicateResource.getLocalName();
                    nameSpace = predicateResource.getNameSpace();
                    if (localName == null || nameSpace == null) {
                        System.out.print(predicateResource.toString() + " ");
                    }
                    else {
                        nickname = getOntologyNickname(nameSpace, predicateResource);
                        constantName = nickname + ":" + localName;
                        System.out.print(constantName + " ");
                    }
                }
                else
                    System.out.print(predicate + " ");

                if (object instanceof Resource) {
                    Resource objectResource = (Resource) object;
                    localName = objectResource.getLocalName();
                    nameSpace = objectResource.getNameSpace();
                    if (localName == null || nameSpace == null) {
                        System.out.print(objectResource.toString() + " ");
                    }
                    else {
                        nickname = getOntologyNickname(nameSpace, objectResource);
                        constantName = nickname + ":" + localName;
                        System.out.print(constantName + " ");
                    }
                }
                else {
                    System.out.print(" \"" + object.toString() + "\"");
                }
                System.out.println(" .");
            }
d232 2
a233 3
        catch (RDFException e) {
            e.printStackTrace();
            System.exit(1);
d235 2
a236 6

        System.out.println("\nProperties");
        Iterator iter = damlModel.listDAMLProperties();
        while (iter.hasNext()) {
            DAMLProperty c = (DAMLProperty)iter.next();
            System.out.println(c.toString());
d238 3
d242 13
d256 14
a269 3
        System.out.println("Classes\n");
        iter = damlModel.listDAMLClasses();
        while (iter.hasNext()) {
d271 25
a295 5
            DAMLClass damlClass = (DAMLClass)iter.next();
            localName = damlClass.getLocalName();
            nameSpace = damlClass.getNameSpace();
            if (localName == null || nameSpace == null) {
                System.out.println(damlClass.toString());
d298 3
a300 32
                nickname = getOntologyNickname(nameSpace, damlClass);
                constantName = nickname + ":" + localName;
                System.out.println(constantName);
            }
            Literal literal = damlClass.prop_label().getValue();
            if (literal != null)
                System.out.println("  label " + literal.toString());
            Literal comment = damlClass.prop_comment().getValue();
            if (comment != null)
                System.out.println("  comment " + comment.toString());
            Iterator iterSuperClasses = damlClass.getSuperClasses(false);
            while (iterSuperClasses.hasNext()) {
                Object superClassObject = iterSuperClasses.next();
                if (superClassObject instanceof DAMLClass) {
                    DAMLClass superClass = (DAMLClass) superClassObject;
                    localName = superClass.getLocalName();
                    nameSpace = superClass.getNameSpace();
                    if (localName == null || nameSpace == null) {
                        System.out.println("  superclass " + superClass.toString());
                    }
                    else {
                        nickname = getOntologyNickname(nameSpace, superClass);
                        constantName = nickname + ":" + localName;
                        System.out.println("  superclass " + constantName);
                    }
                }
                else
                    System.out.println("  superclass " + superClassObject);
            }
            Iterator iterInstances = damlClass.getInstances();
            while (iterInstances.hasNext()) {
                System.out.println("  instances " + iterInstances.next().toString());
d302 2
d305 15
a319 3
        }
        if (verbosity > 0)
            System.out.println("\nDone importing " + damlPath + "\n");
d322 7
d333 2
a334 1
        if (nickname == null)
d337 1
d343 30
a380 1

@


1.5
log
@Added nickname handling for namspaces.
@
text
@d19 1
a19 1
 * @@version $Id: ImportDaml.java,v 1.4 2002/09/10 13:02:03 stephenreed Exp $
d79 1
d81 1
a81 1
        for (int i = 0; i < 5; i++) {
d93 5
d130 14
a143 1
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont.daml", "NS0");
a144 2
        ontologyNicknames.put("http://www.daml.org/2001/10/html/airport-ont.daml", "airport");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont.daml", "ves");
d182 1
d186 3
d205 31
a235 1
        System.out.println("Properties");
d237 41
a286 4
        String localName;
        String nameSpace;
        String nickname;
        String constantName;
d288 1
d296 1
a296 1
                nickname = getOntologyNickname(nameSpace);
d314 1
a314 1
                        System.out.println("  super class " + superClass.toString());
d317 1
a317 1
                        nickname = getOntologyNickname(nameSpace);
d319 1
a319 1
                        System.out.println("  super class " + constantName);
d323 1
a323 1
                    System.out.println("  super class " + superClassObject);
d335 1
a335 1
    protected String getOntologyNickname (String nameSpace) {
d340 2
a341 1
            throw new RuntimeException("Ontology nickname not found for " + key);
@


1.4
log
@Small improvement to display of DAML entities.
@
text
@d19 1
a19 1
 * @@version $Id: ImportDaml.java,v 1.3 2002/09/10 03:31:39 stephenreed Exp $
d124 6
a129 4
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/elements-ont", "NS0");
        ontologyNicknames.put("http://www.daml.org/2001/09/countries/fips", "fips");
        ontologyNicknames.put("http://www.daml.org/2001/10/html/airport-ont", "airport");
        ontologyNicknames.put("http://orlando.drc.com/daml/ontology/VES/3.2/drc-ves-ont", "ves");
d131 2
d134 2
d137 2
d140 2
d143 2
d146 2
d149 2
d152 1
d154 2
d157 2
d160 1
d162 5
a166 1
        ontologyNicknames.put("http://www.daml.org/experiment/ontology/cinc-ont", "cinc");
d195 4
d201 10
a210 1
            System.out.println(damlClass.toString());
d219 16
a234 1
                System.out.println("  super class " + iterSuperClasses.next().toString());
d244 10
@


1.3
log
@Added code for DAML import.
@
text
@d19 1
a19 1
 * @@version $Id: ImportDaml.java,v 1.2 2002/09/09 13:39:56 stephenreed Exp $
d80 1
a80 1
        for (int i = 0; i < 2; i++) {
d175 2
a176 2
            LiteralAccessor comment = damlClass.prop_comment();
            if (literal != null)
@


1.2
log
@Incorporated Jena/DAML API into ImportDaml.
@
text
@d19 1
a19 1
 * @@version $Id: ImportDaml.java,v 1.1 2002/09/09 03:19:25 stephenreed Exp $
d55 11
d74 1
a74 1
     * @@param args optionally provide the path to the DAML document.
d76 1
a76 1
    public static void main(String[] argv) {
d78 30
a107 6
        String damlPath = "file:///opencyc/xml/military-elements-ont-1.daml";
        //if (args.length > 0)
        //   umlModelPath = args[0];
        ImportDaml importDaml = new ImportDaml();
        importDaml.initialize();
        importDaml.importDaml(damlPath);
d114 28
d149 2
a150 1
        System.out.println("Loading " + damlPath);
d158 1
a158 1
        System.out.println("\nProperties\n");
d167 1
a167 1
        System.out.println("\nClasses and Properties\n");
d172 9
a180 3
            Iterator iterProperties = damlClass.getDefinedProperties();
            while (iterProperties.hasNext()) {
                System.out.println("    "+iterProperties.next().toString());
d182 5
d188 2
@


1.1
log
@Added new module for importing DAML content.
@
text
@d4 1
d19 1
a19 1
 * @@version $Id: ImportUmlModel.java,v 1.2 2002/03/07 14:35:43 stephenreed Exp $
d67 1
a67 2
        //String damlPath = "file:///opencyc/xml/test.daml";
        String damlPath = "file:///G:/Jena-1.5.0/doc/tutorial/DAML/solutions/vcard-daml.rdf";
d72 1
a72 8
        DAMLModel model = new DAMLModelImpl();
        try {
            model.read(damlPath);
        }
        catch (RDFException e) {
            e.printStackTrace();
        }
        System.out.println(model.toString());
d81 33
@

