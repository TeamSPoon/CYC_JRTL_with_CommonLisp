head	1.32;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.31.0.2
	OPENCYC_1_0_1:1.31
	PRE_1_0:1.29;
locks; strict;
comment	@# @;


1.32
date	2006.10.21.16.49.19;	author dmiles;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.18.14.21.30;	author dmiles;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.18.13.36.03;	author dmiles;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.09.00.00.27;	author stephenreed;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.23.18.37.13;	author stephenreed;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.23.20.17.22;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.13.17.39.06;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.20.22.44.59;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.19.19.52.26;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.10.22.17.07;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.05.04.40.56;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.05.03.58.39;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.05.03.02.06;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.05.02.50.38;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.05.01.32.48;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.05.00.43.02;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.05.00.24.40;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.04.22.49.32;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.04.22.00.11;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.04.21.46.52;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.04.21.15.31;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.04.17.03.29;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.03.18.07.23;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.25.23.40.15;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.24.19.22.05;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.23.17.16.35;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.21.20.21.18;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.21.19.59.15;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.08.15.02.31;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.04.22.12.58;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.04.05.35.40;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.03.22.07.13;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package  org.opencyc.xml;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.StringTokenizer;
import org.apache.html.dom.HTMLAnchorElementImpl;
import org.apache.html.dom.HTMLDocumentImpl;
import org.apache.html.dom.HTMLFontElementImpl;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XHTMLSerializer;
import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.api.CycConnection;
import org.opencyc.api.CycObjectFactory;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycNart;
import org.opencyc.cycobject.CycObject;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.cycobject.Guid;
import org.opencyc.util.Log;
import org.opencyc.util.StringUtils;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.html.HTMLAnchorElement;
import org.w3c.dom.html.HTMLDocument;
import org.w3c.dom.html.HTMLFontElement;

/**
 * HTML ontology export for OpenCyc/ResearchCyc.
 *
 * @@version $Id: ExportHtml.java,v 1.24 2005/02/16 21:35:10 reed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class ExportHtml extends OntologyExport {
  /**
   * Indicates whether hierarchy pages are produced.
   */
  public boolean produceHierarchyPages = false;
  /**
   * The HTML exported vocabulary path and file name.
   */
  public String exportedVocabularyOutputPath = "exported-vocabulary.html";
  /**
   * The HTML exported hierarchy path and file name.
   */
  public String exportedHierarchyOutputPath = "exported-hierarchy.html";
  /**
   * The NART note file name.
   */
  public String nartNoteOutputPath = "ontology-release-NARTs.html";
  /**
   * The html document.
   */
  protected HTMLDocument htmlDocument;
  /**
   * The HTML body element.
   */
  protected Element htmlBodyElement;
  /**
   * Indicates the presence of a comment for the current term.
   */
  protected boolean hasComment = false;
  /**
   * Indicates which terms have been previously expanded in the hierarchy page.
   */
  protected HashSet previouslyExpandedTerms;
  
  /**
   * Additional term guids not to appear in the list of direct instances even if
   * otherwise qualified to appear.
   */
  protected ArrayList filterFromDirectInstanceGuids = new ArrayList();
  
  /**
   * Additional terms not to appear in the list of direct instances even if
   * otherwise qualified to appear.
   */
  protected ArrayList filterFromDirectInstances = new ArrayList();
  
  /**
   * Export the GUID string for each term?
   */
  public boolean print_guid = false;
  
  /**
   * List of HTML vocabulary category page information items.
   */
  public ArrayList categories = new ArrayList();
  
  /**
   * Constructs a new ExportHtml object given the CycAccess object.
   *
   * @@param cycAccess The CycAccess object which manages the api connection.
   */
  public ExportHtml(CycAccess cycAccess) {
    super(cycAccess);
  }
  
  /**
   * Exports the desired KB content into HTML.
   */
  public void export(int exportCommand) throws UnknownHostException, IOException, CycApiException {
    this.exportCommand = exportCommand;
    setup();
    if (verbosity > 2)
      Log.current.println("Getting terms from Cyc");
    if ((exportCommand == ExportHtml.EXPORT_KB_SUBSET) || (exportCommand == ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
      selectedCycForts = cycAccess.getAllQuotedInstances(cycKbSubsetCollection, cycAccess.inferencePSC);
    }
    else {
      // EXPORT_KB_SUBSET_BELOW_TERM
      selectedCycForts = cycAccess.getAllSpecs(rootTerm);
      selectedCycForts.add(rootTerm);
    }
    selectedCycForts.add(cycAccess.thing);
    selectedCycForts.add(cycAccess.collection);
    selectedCycForts.add(cycAccess.getKnownConstantByName("Individual"));
    selectedCycForts.add(cycAccess.getKnownConstantByName("Predicate"));
    if (verbosity > 2)
      Log.current.println("Selected " + selectedCycForts.size() + " CycFort terms");
    if (includeUpwardClosure) {
      upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
      if (verbosity > 2)
        Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
      selectedCycForts.addAll(upwardClosureCycForts);
      if (verbosity > 2)
        Log.current.println("All selected " + selectedCycForts.size() + " CycFort terms");
    }
    if (verbosity > 2) {
      if (includeNonAtomicTerms)
        Log.current.println("Dropping quoted collection terms ");
      else
        Log.current.println("Dropping quoted collection terms and non-atomic terms");
    }
    CycList tempList = new CycList();
    for (int i = 0; i < selectedCycForts.size(); i++) {
      CycFort cycFort = (CycFort) selectedCycForts.get(i);
      if (cycAccess.isQuotedCollection(cycFort) || 
         (! includeNonAtomicTerms && ! (cycFort instanceof CycConstant))) {
        if (verbosity > 2)
          Log.current.println("  ommitting " + cycFort.cyclify());
      }
      else
        tempList.add(cycFort);
    }
    selectedCycForts = tempList;
    if (verbosity > 2)
      Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
    sortCycObjects(selectedCycForts);
    createVocabularyPage();
    if (categories.size() > 0)
      createCategorizedVocabularies();
    if (rootTerm != null &&
    produceHierarchyPages)
      createHierarchyPage(rootTerm);
    else if (includeUpwardClosure &&
    produceHierarchyPages)
      createHierarchyPage(CycAccess.thing);
    else if (verbosity > 0)
      Log.current.println("Ommiting ontology hierarchy export page");
    for (int i = 0; i < selectedCycForts.size(); i++) {
      final CycObject cycObject = (CycObject) selectedCycForts.get(i);
      if (verbosity > 2)
        Log.current.println(cycObject.cyclify());
    }
    if (verbosity > 0)
      Log.current.println("HTML export completed");
    cycAccess.close();
  }
  
  /**
   * Sets up the HTML export process.
   */
  protected void setup() throws UnknownHostException, IOException, CycApiException {
    assert cycAccess != null : "cycAccess cannot be null";
    
    if (exportCommand == OntologyExport.EXPORT_KB_SUBSET) {
      assert cycKbSubsetCollectionGuid != null : "cycKbSubsetCollectionGuid cannot be null";
      cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
      cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
      cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      includeUpwardClosure = true;
      if (verbosity > 1)
        Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() + "\n  plus upward closure to #$Thing filtered by "
        + cycKbSubsetFilter.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_KB_SUBSET_BELOW_TERM) {
      rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
      cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      cycKbSubsetCollection = cycKbSubsetFilter;
      includeUpwardClosure = false;
      if (verbosity > 1)
        Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() + "\n  filtered by " + cycKbSubsetFilter.cyclify());
    }
    else {
      System.err.println("Invalid export comand " + exportCommand);
      System.exit(1);
    }
    for (int i = 0; i < filterFromDirectInstanceGuids.size(); i++) {
      Guid guid = (Guid) filterFromDirectInstanceGuids.get(i);
      filterFromDirectInstances.add(cycAccess.getKnownConstantByGuid(guid));
    }
    for (int i = 0; i < upwardClosureKbSubsetCollectionGuids.size(); i++) {
      Guid guid = (Guid) upwardClosureKbSubsetCollectionGuids.get(i);
      upwardClosureKbSubsetCollections.add(cycAccess.getKnownConstantByGuid(guid));
    }
  }
  
  /**
   * Creates vocabulary HTML page.
   */
  protected void createVocabularyPage() throws UnknownHostException, IOException, CycApiException {
    if (verbosity > 2)
      Log.current.println("Building HTML model for vocabulary page");
    htmlDocument = new HTMLDocumentImpl();
    String title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
    htmlDocument.setTitle(title);
    Node htmlNode = htmlDocument.getChildNodes().item(0);
    htmlBodyElement = htmlDocument.createElement("body");
    htmlNode.appendChild(htmlBodyElement);
    Element headingElement = htmlDocument.createElement("h1");
    htmlBodyElement.appendChild(headingElement);
    Node headingTextNode = htmlDocument.createTextNode(title);
    headingElement.appendChild(headingTextNode);
    for (int i = 0; i < selectedCycForts.size(); i++) {
      CycFort cycFort = (CycFort)selectedCycForts.get(i);
      if (verbosity > 2)
        Log.current.print(cycFort + "  ");
      if (cycAccess.isCollection(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Collection");
      }
      else if (cycAccess.isPredicate(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Predicate");
      }
      else if (cycAccess.isIndividual(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Individual");
      }
      else {
        if (verbosity > 2)
          Log.current.println("other");
        continue;
      }
      if (cycFort instanceof CycConstant)
        createCycConstantNode((CycConstant) cycFort);
      else
        createCycNartNode((CycNart) cycFort);
    }
    serialize(htmlDocument, exportedVocabularyOutputPath);
  }
  
  /**
   * Creates a HTML node for a single Cyc Nart.
   * @@param cycNart The CycNart from which the HTML node is created.
   */
  protected void createCycNartNode(CycNart cycNart)
  throws UnknownHostException, IOException, CycApiException {
    horizontalRule();
    HTMLFontElement htmlFontElement =
    new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
    htmlFontElement.setSize("+1");
    htmlBodyElement.appendChild(htmlFontElement);
    HTMLAnchorElement htmlAnchorElement =
    new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
    htmlAnchorElement.setName(cycNart.cyclify());
    htmlFontElement.appendChild(htmlAnchorElement);
    String generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycNart);
    if (generatedPhrase.endsWith("(unclassified term)"))
      generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
    Node collectionTextNode = htmlDocument.createTextNode(cycNart.cyclify());
    htmlAnchorElement.appendChild(collectionTextNode);
    Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
    Node generatedPhraseNode =
    htmlDocument.createTextNode("   " + generatedPhrase);
    italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
    Element blockquoteElement = htmlDocument.createElement("blockquote");
    htmlBodyElement.appendChild(blockquoteElement);
    HTMLAnchorElement natNoteAnchorElement =
    new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
    natNoteAnchorElement.setHref("./" + nartNoteOutputPath);
    blockquoteElement.appendChild(natNoteAnchorElement);
    Node natNoteTextNode = htmlDocument.createTextNode("Note On Non-Atomic Terms");
    natNoteAnchorElement.appendChild(natNoteTextNode);
    createIsaNodes(cycNart, blockquoteElement);
    createGenlNodes(cycNart, blockquoteElement);
  }
  
  /**
   * Creates a HTML node for a single Cyc Constant.
   * @@param cycConstant The CycConstant from which the HTML node is created.
   */
  protected void createCycConstantNode(CycConstant cycConstant)
  throws UnknownHostException, IOException, CycApiException {
    horizontalRule();
    HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
    htmlFontElement.setSize("+1");
    htmlBodyElement.appendChild(htmlFontElement);
    HTMLAnchorElement htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
    htmlAnchorElement.setName(cycConstant.cyclify());
    htmlFontElement.appendChild(htmlAnchorElement);
    Node collectionTextNode = htmlDocument.createTextNode(cycConstant.cyclify());
    htmlAnchorElement.appendChild(collectionTextNode);
    boolean hasRewrite = processRewriteOf(cycConstant, htmlFontElement);
    if (! hasRewrite) {
      // If no rewriteOf text, then output the generated phrase.
      String generatedPhrase;
      if (cycAccess.isCollection(cycConstant))
        generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycConstant);
      else
        generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycConstant);
      if (generatedPhrase.endsWith("(unclassified term)"))
        generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
      Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
      Node generatedPhraseNode =
      htmlDocument.createTextNode("   " + generatedPhrase);
      italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
    }
    Element blockquoteElement = htmlDocument.createElement("blockquote");
    htmlBodyElement.appendChild(blockquoteElement);
    createCommentNodes(cycConstant, blockquoteElement);
    if (print_guid)
      createGuidNode(cycConstant, blockquoteElement);
    createIsaNodes(cycConstant, blockquoteElement);
    if (cycAccess.isCollection(cycConstant))
      createCollectionNode(cycConstant, blockquoteElement);
    else if (cycAccess.isPredicate(cycConstant))
      createPredicateNode(cycConstant, blockquoteElement);
    else if (cycAccess.isFunction(cycConstant))
      createFunctionNode(cycConstant, blockquoteElement);
    else if (cycAccess.isIndividual(cycConstant))
      createIndividualNode(cycConstant, blockquoteElement);
    else {
      if (verbosity > 0)
        Log.current.println("Unhandled constant: " + cycConstant.toString());
    }
  }
  
  /**
   * Processes the case where the given Cyc constant has a #$rewriteOf relationship
   * to a Cyc FORT (First Order Reified Term).  For example when the given term is
   * #$AttemptedKillingByCarAccident, then the KB contains the assertion
   * (#$rewriteOf #$AttemptedKillingByCarAccident ((KillingThroughEventTypeFn #$CarAccident))
   * and the phrase " is the atomic form of (KillingThroughEventTypeFn #$CarAccident)" is
   * output to the HTML document.
   *
   * @@param cycConstant The given CycConstant for processing if a #$rewriteOf.
   * @@param parentElement The parent HTML element for inserting rewriteOf text.
   * @@return True iff there is in fact a rewrite term.
   */
  protected boolean processRewriteOf(CycConstant cycConstant,
  Element parentElement)
  throws UnknownHostException, IOException, CycApiException {
    CycList query = new CycList();
    query.add(cycAccess.and);
    CycList query1 = new CycList();
    query.add(query1);
    
    query1.add(cycAccess.getKnownConstantByGuid(rewriteOfGuid));
    query1.add(cycConstant);
    CycVariable fortVariable = CycObjectFactory.makeCycVariable("?FORT");
    query1.add(fortVariable);
    CycConstant inferencePSC = cycAccess.getKnownConstantByGuid(inferencePSCGuid);
    // #$rewriteOf is reflexsive so constrain arg2 to be different from arg1.
    CycList query2 = new CycList();
    query.add(query2);
    query2.add(cycAccess.not);
    CycList query3 = new CycList();
    query2.add(query3);
    query3.add(cycAccess.getKnownConstantByGuid(equalSymbolsGuid));
    query3.add(cycConstant);
    query3.add(fortVariable);
    CycList cycForts = cycAccess.queryVariable(fortVariable, query, inferencePSC, (HashMap) null);
    if (cycForts.size() == 0)
      return false;
    if (! (cycForts.get(0) instanceof CycFort)) {
      Log.current.errorPrintln("\nError, rewriteOf " + cycConstant.cyclify() +
      "\n " + cycForts.get(0) + "\nis not a CycFort\n");
      return false;
    }
    if (! (cycForts.get(0) instanceof CycNart))
      return false;
    CycNart cycNart = (CycNart) cycForts.get(0);
    
    Node rewriteOfTextNode = htmlDocument.createTextNode("  is the atomic form of ");
    parentElement.appendChild(rewriteOfTextNode);
    
    processRewrittenNart(cycNart, parentElement);
    return true;
  }
  
  /**
   * Creates nodes for rewritten NARTs.  Recursive for the NART components, putting
   * hyperlinks where possible.
   *
   * @@param object The given ojbect for processing in a #$rewriteOf.
   * @@param parentElement The parent HTML element for inserting rewriteOf text.
   */
  protected void processRewrittenNart(Object object, Element parentElement)
  throws UnknownHostException, IOException, CycApiException {
    if (object instanceof CycList) {
      CycList cycList = (CycList) object;
      for (int i = 0; i < cycList.size(); i++) {
        Object item = cycList.get(i);
        parentElement.appendChild(htmlDocument.createTextNode(" "));
        // recurse for each list item
        processRewrittenNart(item, parentElement);
      }
      return;
    }
    if (object instanceof CycConstant) {
      CycConstant cycConstant = (CycConstant) object;
      if (selectedCycForts.contains(object)) {
        HTMLAnchorElement cycConstantAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        cycConstantAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycConstant.cyclify());
        parentElement.appendChild(cycConstantAnchorElement);
        cycConstantAnchorElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
      }
      else
        parentElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
      return;
    }
    if (object instanceof CycNart) {
      CycNart cycNart = (CycNart) object;
      if (selectedCycForts.contains(cycNart)) {
        HTMLAnchorElement cycFortAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        cycFortAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycNart.cyclify());
        parentElement.appendChild(cycFortAnchorElement);
        cycFortAnchorElement.appendChild(htmlDocument.createTextNode("( "));
      }
      else
        parentElement.appendChild(htmlDocument.createTextNode("("));
      CycFort functor = cycNart.getFunctor();
      // recurse for the functor
      processRewrittenNart(functor, parentElement);
      for (int i = 0; i < cycNart.getArguments().size(); i++) {
        Object argument = cycNart.getArguments().get(i);
        parentElement.appendChild(htmlDocument.createTextNode(" "));
        // recurse for each arg
        processRewrittenNart(argument, parentElement);
      }
      Node rightParenTextNode = htmlDocument.createTextNode(")");
      parentElement.appendChild(rightParenTextNode);
      return;
    }
    parentElement.appendChild(htmlDocument.createTextNode(object.toString()));
  }
  
  
  
  /**
   * Creates a paragraph break in the HTML document.
   */
  protected void paragraphBreak() {
    Element paragraphElement = htmlDocument.createElement("p");
    htmlBodyElement.appendChild(paragraphElement);
  }
  
  /**
   * Creates an italics element in the HTML document.
   *
   * @@param parentElement The parent HTML DOM element.
   * @@return The italics element.
   */
  protected Element italics(Element parentElement) {
    Element italicsElement = htmlDocument.createElement("i");
    parentElement.appendChild(italicsElement);
    return  italicsElement;
  }
  
  /**
   * Creates a line break in the HTML document.
   *
   * @@param parentElement The parent HTML DOM element.
   */
  protected void lineBreak(Element parentElement) {
    Element breakElement = htmlDocument.createElement("br");
    parentElement.appendChild(breakElement);
  }
  
  /**
   * Creates a horizontal rule in the HTML document.
   */
  protected void horizontalRule() {
    Element horizontalRuleElement = htmlDocument.createElement("hr");
    htmlBodyElement.appendChild(horizontalRuleElement);
  }
  
  /**
   * Creates HTML nodes for comment text containing CycConstants which are to be
   * represented as hyperlinks.
   *
   * @@param cycConstant The CycConstant for which isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createCommentNodes(CycConstant cycConstant, Element parentElement)
  throws IOException, CycApiException {
    String comment = cycAccess.getComment(cycConstant);
    if (comment.equals("")) {
      hasComment = false;
      return;
    }
    comment = comment.replaceAll("<code>", "");
    comment = comment.replaceAll("</code>", "");
    comment = comment.replaceAll("<p>", "");
    comment = comment.replaceAll("</p>", "");
    comment = comment.replaceAll("<i>", "");
    comment = comment.replaceAll("</i>", "");
    hasComment = true;
    StringTokenizer st = new StringTokenizer(comment);
    StringBuffer stringBuffer = new StringBuffer();
    CycConstant commentConstant;
    Node commentTextNode;
    Node linkTextNode;
    HTMLAnchorElement htmlAnchorElement;
    while (st.hasMoreTokens()) {
      String word = st.nextToken();
      boolean wordHasLeadingLeftParen = false;
      if (word.startsWith("(#$")) {
        wordHasLeadingLeftParen = true;
        word = word.substring(1);
      }
      if (word.startsWith("#$")) {
        StringBuffer nonNameChars = new StringBuffer();
        while (true) {
          // Move trailing non-name characters.
          char ch = word.charAt(word.length() - 1);
          if (Character.isLetterOrDigit(ch))
            break;
          word = word.substring(0, word.length() - 1);
          nonNameChars.insert(0, ch);
          if (word.length() == 0)
            break;
        }
        commentConstant = cycAccess.getConstantByName(word);
        if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
          stringBuffer.append(" ");
          commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
          parentElement.appendChild(commentTextNode);
          stringBuffer = new StringBuffer();
          htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
          htmlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + commentConstant.cyclify());
          parentElement.appendChild(htmlAnchorElement);
          if (wordHasLeadingLeftParen)
            stringBuffer.append('(');
          stringBuffer.append(word);
          stringBuffer.append(nonNameChars.toString());
          linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
          htmlAnchorElement.appendChild(linkTextNode);
          stringBuffer = new StringBuffer();
        }
        else if (commentConstant == null && word.endsWith("s")) {
          commentConstant = cycAccess.getConstantByName(word.substring(0, word.length() - 1));
          if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
            stringBuffer.append(" ");
            commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
            parentElement.appendChild(commentTextNode);
            stringBuffer = new StringBuffer();
            htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            htmlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + commentConstant.cyclify());
            parentElement.appendChild(htmlAnchorElement);
            if (wordHasLeadingLeftParen)
              stringBuffer.append('(');
            stringBuffer.append(word);
            stringBuffer.append(nonNameChars.toString());
            linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
            htmlAnchorElement.appendChild(linkTextNode);
            stringBuffer = new StringBuffer();
          }
          else {
            stringBuffer.append(" ");
            if (wordHasLeadingLeftParen)
              stringBuffer.append('(');
            stringBuffer.append(word);
            stringBuffer.append(nonNameChars.toString());
          }
        }
        else {
          stringBuffer.append(" ");
          if (wordHasLeadingLeftParen)
            stringBuffer.append('(');
          stringBuffer.append(word);
          stringBuffer.append(nonNameChars.toString());
        }
      }
      else {
        stringBuffer.append(" ");
        stringBuffer.append(word);
      }
    }
    if (stringBuffer.length() > 0) {
      commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
      parentElement.appendChild(commentTextNode);
    }
  }
  
  /**
   * Creates HTML node for guid.
   *
   * @@param cycConstant The CycConstant for which isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createGuidNode(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    Guid guid = cycConstant.getGuid();
    if (hasComment)
      lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node guidLabelTextNode = htmlDocument.createTextNode("guid: ");
    bElement.appendChild(guidLabelTextNode);
    Node guidTextNode = htmlDocument.createTextNode(guid.toString());
    parentElement.appendChild(guidTextNode);
  }
  
  /**
   * Creates HTML nodes for isa links.
   *
   * @@param cycConstant The CycConstant for which isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createIsaNodes(CycFort cycFort, Element parentElement) throws IOException, CycApiException {
    //if (cycFort.toString().equals("BiochemicallyHarmfulSubstance"))
    //    verbosity = 9;
    CycList isas = cycAccess.getIsas(cycFort);
    if (verbosity > 3)
      Log.current.println("  starting isas: " + isas.cyclify());
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node isasLabelTextNode = htmlDocument.createTextNode("direct instance of: ");
    bElement.appendChild(isasLabelTextNode);
    CycList createdIsas = new CycList();
    for (int i = 0; i < isas.size(); i++) {
      CycFort isa = (CycFort)isas.get(i);
      if (verbosity > 7) {
        Log.current.println("  considering " + isa.cyclify());
        Log.current.println("    selectedCycForts.contains(" + isa.cyclify() + ") " + selectedCycForts.contains(isa));
        Log.current.println("    cycAccess.isQuotedCollection(" + isa.cyclify() + ") " + cycAccess.isQuotedCollection(isa));
      }
      if (! selectedCycForts.contains(isa)) {
        isa = findSelectedGenls(isa);
        if (isa == null)
          continue;
      }
      if (createdIsas.contains(isa))
        continue;
      else if (cycAccess.isQuotedCollection(isa)) {
        if (verbosity > 2)
          Log.current.println("  omitting quoted direct-instance-of collection " + isa.cyclify());
      }
      else {
        if (verbosity > 7)
          Log.current.println("  adding direct instance of " + isa.cyclify());
        createdIsas.add(isa);
      }
    }
    createdIsas = specificCollections(createdIsas);
    // filter out any specified terms.
    createdIsas.removeAll(filterFromDirectInstances);
    for (int i = 0; i < createdIsas.size(); i++) {
      CycFort isa = (CycFort)createdIsas.get(i);
      HTMLAnchorElement isaAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      isaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + isa.cyclify());
      parentElement.appendChild(isaAnchorElement);
      Node isaTextNode = htmlDocument.createTextNode(isa.cyclify());
      isaAnchorElement.appendChild(isaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for genl links.
   *
   * @@param cycConstant The CycConstant for which genl links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createGenlNodes(CycFort cycFort, Element parentElement) throws IOException, CycApiException {
    CycList genls = cycAccess.getGenls(cycFort);
        /*
        if (cycFort.equals(cycAccess.getKnownConstantByName("CarAccident"))) {
            verbosity = 9;
        }
         */
    if (verbosity > 3)
      Log.current.println("  starting genls: " + genls.cyclify());
    genls = specificCollections(findAllowedTermsOrGenls(genls));
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node genlsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
    bElement.appendChild(genlsLabelTextNode);
    for (int i = 0; i < genls.size(); i++) {
      CycFort genl = (CycFort)genls.get(i);
      if (cycAccess.isQuotedCollection(genl)) {
        if (verbosity > 2)
          Log.current.println("  omitting quoted genl collection " + genl.cyclify());
      }
      else if (selectedCycForts.contains(genl)) {
        HTMLAnchorElement genlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        genlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + genl.cyclify());
        parentElement.appendChild(genlAnchorElement);
        Node genlTextNode = htmlDocument.createTextNode(genl.cyclify());
        genlAnchorElement.appendChild(genlTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
    }
    if ((genls.size() > 0) && produceHierarchyPages) {
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
      HTMLAnchorElement hierarchyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      hierarchyAnchorElement.setHref("./" + exportedHierarchyOutputPath + "./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
      parentElement.appendChild(hierarchyAnchorElement);
      Node hierarchyTextNode = htmlDocument.createTextNode("hierarchy");
      hierarchyAnchorElement.appendChild(hierarchyTextNode);
    }
  }
  
  /**
   * Creates an HTML node for a single Cyc predicate.
   *
   * @@param cycConstant The Cyc predicate from which the HTML node is created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createPredicateNode(CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
    createGenlPredsNodes(cycConstant, parentElement);
    int arity = cycAccess.getArity(cycConstant);
    if (arity > 0)
      createArg1IsaNodes(cycConstant, parentElement);
    if (arity > 1)
      createArg2IsaNodes(cycConstant, parentElement);
    if (arity > 2)
      createArg3IsaNodes(cycConstant, parentElement);
    if (arity > 3)
      createArg4IsaNodes(cycConstant, parentElement);
  }
  
  /**
   * Creates an HTML node for a single Cyc function.
   *
   * @@param cycConstant The Cyc function from which the HTML node is created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createFunctionNode(CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
    int arity = cycAccess.getArity(cycConstant);
    if (arity > 0)
      createArg1IsaNodes(cycConstant, parentElement);
    if (arity > 1)
      createArg2IsaNodes(cycConstant, parentElement);
    if (arity > 2)
      createArg3IsaNodes(cycConstant, parentElement);
    if (arity > 3)
      createArg4IsaNodes(cycConstant, parentElement);
    createResultIsaNodes(cycConstant, parentElement);
  }
  
  /**
   * Creates HTML nodes for genlPreds links.
   *
   * @@param cycConstant The CycConstant for which genlPreds links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createGenlPredsNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList genlPreds = filterSelectedConstants(cycAccess.getGenlPreds(cycConstant));
    if (verbosity > 4)
      Log.current.println("  genlPreds " + genlPreds);
    CycList tempList = new CycList();
    for (int i = 0; i < genlPreds.size(); i++) {
      CycConstant genlPred = (CycConstant)genlPreds.get(i);
      if (selectedCycForts.contains(genlPred))
        tempList.add(genlPred);
    }
    genlPreds = tempList;
    if (verbosity > 4)
      Log.current.println("  after filtering, genlPreds " + genlPreds);
    if (genlPreds.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node genlsPredsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
    bElement.appendChild(genlsPredsLabelTextNode);
    for (int i = 0; i < genlPreds.size(); i++) {
      CycConstant genlPred = (CycConstant)genlPreds.get(i);
      HTMLAnchorElement genlPredAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      genlPredAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + genlPred.cyclify());
      parentElement.appendChild(genlPredAnchorElement);
      Node genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
      genlPredAnchorElement.appendChild(genlPredTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for arg1Isa links.
   *
   * @@param cycConstant The CycConstant for which arg1Isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createArg1IsaNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList arg1Isas = findAllowedTermsOrGenls(cycAccess.getArg1Isas(cycConstant));
    if (verbosity > 4)
      Log.current.println("  arg1Isas " + arg1Isas);
    if (arg1Isas.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node arg1IsasLabelTextNode = htmlDocument.createTextNode("argument one is an instance of: ");
    bElement.appendChild(arg1IsasLabelTextNode);
    for (int i = 0; i < arg1Isas.size(); i++) {
      CycConstant arg1Isa = (CycConstant)arg1Isas.get(i);
      HTMLAnchorElement arg1IsaAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      arg1IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg1Isa.cyclify());
      parentElement.appendChild(arg1IsaAnchorElement);
      Node arg1IsaTextNode = htmlDocument.createTextNode(arg1Isa.cyclify());
      arg1IsaAnchorElement.appendChild(arg1IsaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for arg2Isa links.
   *
   * @@param cycConstant The CycConstant for which arg2Isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createArg2IsaNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList arg2Isas = findAllowedTermsOrGenls(cycAccess.getArg2Isas(cycConstant));
    if (verbosity > 4)
      Log.current.println("  arg2Isas " + arg2Isas);
    if (arg2Isas.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node arg2IsasLabelTextNode = htmlDocument.createTextNode("argument two is an instance of: ");
    bElement.appendChild(arg2IsasLabelTextNode);
    for (int i = 0; i < arg2Isas.size(); i++) {
      CycConstant arg2Isa = (CycConstant)arg2Isas.get(i);
      HTMLAnchorElement arg2IsaAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      arg2IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg2Isa.cyclify());
      parentElement.appendChild(arg2IsaAnchorElement);
      Node arg2IsaTextNode = htmlDocument.createTextNode(arg2Isa.cyclify());
      arg2IsaAnchorElement.appendChild(arg2IsaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for arg3Isa links.
   *
   * @@param cycConstant The CycConstant for which arg3Isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createArg3IsaNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList arg3Isas = findAllowedTermsOrGenls(cycAccess.getArg3Isas(cycConstant));
    if (verbosity > 4)
      Log.current.println("  arg3Isas " + arg3Isas);
    if (arg3Isas.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node arg3IsasLabelTextNode = htmlDocument.createTextNode("argument three is an instance of: ");
    bElement.appendChild(arg3IsasLabelTextNode);
    for (int i = 0; i < arg3Isas.size(); i++) {
      CycConstant arg3Isa = (CycConstant)arg3Isas.get(i);
      HTMLAnchorElement arg3IsaAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      arg3IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg3Isa.cyclify());
      parentElement.appendChild(arg3IsaAnchorElement);
      Node arg3IsaTextNode = htmlDocument.createTextNode(arg3Isa.cyclify());
      arg3IsaAnchorElement.appendChild(arg3IsaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for arg4Isa links.
   *
   * @@param cycConstant The CycConstant for which arg4Isa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createArg4IsaNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList arg4Isas = findAllowedTermsOrGenls(cycAccess.getArg4Isas(cycConstant));
    if (verbosity > 4)
      Log.current.println("  arg4Isas " + arg4Isas);
    if (arg4Isas.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node arg4IsasLabelTextNode = htmlDocument.createTextNode("argument four is an instance of: ");
    bElement.appendChild(arg4IsasLabelTextNode);
    for (int i = 0; i < arg4Isas.size(); i++) {
      CycConstant arg4Isa = (CycConstant)arg4Isas.get(i);
      HTMLAnchorElement arg4IsaAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      arg4IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg4Isa.cyclify());
      parentElement.appendChild(arg4IsaAnchorElement);
      Node arg4IsaTextNode = htmlDocument.createTextNode(arg4Isa.cyclify());
      arg4IsaAnchorElement.appendChild(arg4IsaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates HTML nodes for resultIsa links.
   *
   * @@param cycConstant The CycConstant for which resultIsa links are to be created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createResultIsaNodes(CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
    CycList resultIsas = findAllowedTermsOrGenls(cycAccess.getResultIsas(cycConstant));
    if (verbosity > 4)
      Log.current.println("  resultIsas " + resultIsas);
    if (resultIsas.size() == 0)
      return;
    lineBreak(parentElement);
    Element bElement = htmlDocument.createElement("b");
    parentElement.appendChild(bElement);
    Node resultIsasLabelTextNode = htmlDocument.createTextNode("result is an instance of: ");
    bElement.appendChild(resultIsasLabelTextNode);
    for (int i = 0; i < resultIsas.size(); i++) {
      CycConstant resultIsa = (CycConstant)resultIsas.get(i);
      HTMLAnchorElement resultIsaAnchorElement =
      new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
      resultIsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + resultIsa.cyclify());
      parentElement.appendChild(resultIsaAnchorElement);
      Node resultIsaTextNode = htmlDocument.createTextNode(resultIsa.cyclify());
      resultIsaAnchorElement.appendChild(resultIsaTextNode);
      Node spacesTextNode = htmlDocument.createTextNode("  ");
      parentElement.appendChild(spacesTextNode);
    }
  }
  
  /**
   * Creates an HTML individual node for a single Cyc individual.
   *
   * @@param cycConstant The Cyc individual from which the HTML individual node is created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createIndividualNode(CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
    HTMLAnchorElement individualAnchorElement =
    new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
    individualAnchorElement.setHref("##$Individual");
    parentElement.appendChild(individualAnchorElement);
    Node individualTextNode = htmlDocument.createTextNode("#$Individual");
    individualAnchorElement.appendChild(individualTextNode);
  }
  
  /**
   * Creates an HTML node for a single Cyc collection.
   *
   * @@param cycConstant The Cyc collection from which the HTML node is created.
   * @@param parentElement The parent HTML DOM element.
   */
  protected void createCollectionNode(CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
    createGenlNodes(cycConstant, parentElement);
  }
  
  /**
   * Creates hierarchy HTML page.
   *
   * @@param rootTerm The root term of the hierarchy tree.
   */
  protected void createHierarchyPage(CycFort rootTerm) throws UnknownHostException, IOException, CycApiException {
    if (verbosity > 2)
      Log.current.println("Building HTML model for hierarchy page");
    htmlDocument = new HTMLDocumentImpl();
    String title = "Cyc ontology hierarchy for " + cycKbSubsetCollection.cyclify();
    htmlDocument.setTitle(title);
    Node htmlNode = htmlDocument.getChildNodes().item(0);
    htmlBodyElement = htmlDocument.createElement("body");
    htmlNode.appendChild(htmlBodyElement);
    Element headingElement = htmlDocument.createElement("h1");
    htmlBodyElement.appendChild(headingElement);
    Node headingTextNode = htmlDocument.createTextNode(title);
    headingElement.appendChild(headingTextNode);
    previouslyExpandedTerms = new HashSet();
    createHierarchyNodes(rootTerm, 0);
    serialize(htmlDocument, exportedHierarchyOutputPath);
  }
  
  /**
   * Recursively creates hierarchy nodes for the given term and its spec collection terms.
   *
   * @@param cycFort The given term for which hierarchy nodes will be created.
   * @@param indent The current indent level.
   */
  protected void createHierarchyNodes(CycFort cycFort, int indent) throws IOException, CycApiException {
    if (indent > 0) {
      StringBuffer spaces = new StringBuffer(indent);
      StringBuffer nonBreakingSpaces = new StringBuffer(indent);
      for (int i = 0; i < indent; i++) {
        spaces.append(' ');
        nonBreakingSpaces.append("&nbsp;");
      }
      Node spacesText = htmlDocument.createTextNode(nonBreakingSpaces.toString());
      htmlBodyElement.appendChild(spacesText);
      if (verbosity > 2)
        Log.current.println(spaces.toString() + cycFort);
    }
    else {
      if (verbosity > 2)
        Log.current.println(cycFort.toString());
    }
    HTMLAnchorElement vocabularyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
    vocabularyAnchorElement.setHref("./" + exportedVocabularyOutputPath + "./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
    htmlBodyElement.appendChild(vocabularyAnchorElement);
    Node hierarchyTermTextNode = htmlDocument.createTextNode(cycFort.cyclify());
    vocabularyAnchorElement.appendChild(hierarchyTermTextNode);
    String generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycFort);
    if (generatedPhrase.endsWith("(unclassified term)"))
      generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
    Node generatedPhraseTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;" + generatedPhrase + "");
    htmlBodyElement.appendChild(generatedPhraseTextNode);
    CycList specs = cycAccess.getSpecs(cycFort);
    specs = filterSelectedConstants(specs);
    if (specs.size() == 0) {
      vocabularyAnchorElement.setName(cycFort.cyclify());
      lineBreak(htmlBodyElement);
    }
    else if (previouslyExpandedTerms.contains(cycFort)) {
      Node previouslyExpandedTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;... see above");
      htmlBodyElement.appendChild(previouslyExpandedTextNode);
      lineBreak(htmlBodyElement);
    }
    else {
      previouslyExpandedTerms.add(cycFort);
      vocabularyAnchorElement.setName(cycFort.cyclify());
      lineBreak(htmlBodyElement);
      for (int i = 0; i < specs.size(); i++)
        createHierarchyNodes((CycFort)specs.get(i), indent + 2);
    }
  }
  
  /**
   * Serializes the given HTML document to the given path.
   *
   * @@param htmlDocument The HTML document model for serialization.
   * @@param outputPath The file name of the serialized HTML document.
   */
  protected void serialize(HTMLDocument htmlDocument, String outputPath) throws IOException {
    if (verbosity > 2)
      Log.current.println("Writing HTML output to " + outputPath);
    OutputFormat outputFormat = new OutputFormat(htmlDocument, "UTF-8", true);
    BufferedWriter htmlOut = new BufferedWriter(new FileWriter(outputPath));
    XHTMLSerializer xhtmlSerializer = new XHTMLSerializer(htmlOut, outputFormat);
    xhtmlSerializer.asDOMSerializer();
    xhtmlSerializer.serialize(htmlDocument);
    htmlOut.close();
  }
  
  /**
   * Creates categorized vocabulary HTML pages.
   */
  protected void createCategorizedVocabularies()
  throws UnknownHostException, IOException, CycApiException {
    for (int i = 0; i < categories.size(); i++) {
      Category category = (Category) categories.get(i);
      createCategorizedVocabulary(category.title,
      category.queryString,
      category.mt,
      category.outputPath);
    }
  }
  
  /**
   * Creates the given categorized vocabulary HTML page.
   *
   * @@param title the title of the categorized vocabulary HTML page
   * @@param queryString the query string which finds the terms in the
   * category
   * @@param mt the mt in which the query is asked
   * @@param outputPath the name of the output HTML page
   */
  protected void createCategorizedVocabulary(String title,
  String queryString,
  CycConstant mt,
  String outputPath)
  throws UnknownHostException, IOException, CycApiException {
    CycList categoryTerms = askQueryString(queryString, mt);
    if (categoryTerms.size() == 0) {
      if (verbosity > 2)
        Log.current.println("No terms for query:\n" + queryString + "\n");
      return;
    }
    if (verbosity > 2)
      Log.current.println("Building HTML model for category: " + title);
    htmlDocument = new HTMLDocumentImpl();
    htmlDocument.setTitle(title);
    Node htmlNode = htmlDocument.getChildNodes().item(0);
    htmlBodyElement = htmlDocument.createElement("body");
    htmlNode.appendChild(htmlBodyElement);
    Element headingElement = htmlDocument.createElement("h1");
    htmlBodyElement.appendChild(headingElement);
    Node headingTextNode = htmlDocument.createTextNode(title);
    headingElement.appendChild(headingTextNode);
    for (int i = 0; i < categoryTerms.size(); i++) {
      CycFort cycFort = (CycFort) categoryTerms.get(i);
      if (verbosity > 2)
        Log.current.print(cycFort + "  ");
      if (cycAccess.isCollection(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Collection");
      }
      else if (cycAccess.isPredicate(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Predicate");
      }
      else if (cycAccess.isIndividual(cycFort)) {
        if (verbosity > 2)
          Log.current.println("Individual");
      }
      else {
        if (verbosity > 2)
          Log.current.println("other");
        continue;
      }
      if (cycFort instanceof CycConstant)
        createCycConstantNode((CycConstant)cycFort);
      else
        createCycNartNode((CycNart)cycFort);
    }
    serialize(htmlDocument, outputPath);
  }
  
  /**
   * Adds all categories to the HTML export.
   */
  protected void addAllCategories()
  throws CycApiException, IOException , UnknownHostException {
    addAllIETRef();
    addAllSyracuseRef();
    addAllSraRef();
    addAllVeridianRef();
    addAllSchemaMappingTypes();
    addScriptRepresentationVocabulary();
    addSemanticConstraintVocabulary();
    addAllPersonTypes();
    addAllOrganizationTypes();
    addAllEventTypes();
    addAllMaterials();
    addAllWeaponTypes();
    addAllRelations();
    addAllBinaryPredicates();
    addAllActorSlots();
    addAllPartonomicPredicates();
    addAllSpecializationsOfAffiliation();
    addAllSpecializationsOfVestedInterest();
    addAllDenotingFunctions();
    addAllTemporalRelations();
    addAllScriptedEventTypes();
    addEeldCoreOntology();
    addPublicSharedOntology();
  }
  
  /**
   * Categorizes all ontology constants directly referenced in the IET Mapping.
   */
  protected void addAllIETRef()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "IET Synthetic Data set constants";
    category.outputPath = "all-iet-ref.html";
    category.queryString =
    "(#$isa ?TERM #$EELDSyntheticDataConstant)\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all ontology constants directly referenced in the Syracuse Mapping.
   */
  protected void addAllSyracuseRef()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Constants corresponding to terms in the Syracuse ontology";
    category.outputPath = "all-syracuse-ref.html";
    category.queryString =
    "(#$thereExists ?STRING\n" +
    " (#$or\n" +
    "  (#$synonymousExternalConcept ?TERM #$SyracuseOntology ?STRING)\n" +
    "  (#$overlappingExternalConcept ?TERM #$SyracuseOntology ?STRING)))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all constants directly reference in the SRA NetOwl Mapping.
   */
  protected void addAllSraRef()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Constants corresponding to terms in the NetOwl template extraction ontology.";
    category.outputPath = "all-sra-ref.html";
    category.queryString =
    "(#$thereExists ?STRING\n" +
    " (#$or\n" +
    "  (#$synonymousExternalConcept\n" +
    "      ?TERM #$SRATemplateExtractionOntology ?STRING)\n" +
    "  (#$overlappingExternalConcept\n" +
    "      ?TERM #$SRATemplateExtractionOntology ?STRING)))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all ontology constants directly referenced in the Veridian Mapping.
   */
  protected void addAllVeridianRef()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Constants corresponding to terms referenced in the Veridian schema specification.";
    category.outputPath = "all-veridian-ref.html";
    category.queryString =
    "(#$thereExists ?PROP\n" +
    "  (#$and\n" +
    "    (#$isa ?TERM #$Collection)\n" +
    "    (#$unknownSentence\n" +
    "      (#$isa ?TERM #$SKSIConstant))\n" +
    "    (#$unknownSentence\n" +
    "      (#$isa ?TERM #$IndexicalConcept))\n" +
    "    (#$different ?TERM #$meaningSentenceOfSchema)\n" +
    "    (#$ist-Asserted #$VeridianMappingMt ?PROP)\n" +
    "    (#$assertedTermSentences ?TERM ?PROP)))";
    category.mt = cycAccess.getKnownConstantByName("#$VeridianMappingMt");
  }
  
  /**
   * Categorizes all schema mapping types.
   */
  protected void addAllSchemaMappingTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Terms used to specify the interpretation of the Veridian schema.";
    category.outputPath = "all-schema-mapping-types.html";
    category.queryString =
    "(#$and \n" +
    "  (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    "  (#$isa ?TERM #$SKSIConstant))\n";
    category.mt = cycAccess.getKnownConstantByName("#$SKSIMt");
  }
  
  /**
   * Categorizes script representation vocabulary.
   */
  protected void addScriptRepresentationVocabulary()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Relations used in representing scripts.";
    category.outputPath = "script-representation-vocabulary.html";
    category.queryString =
    "(#$and \n" +
    "  (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    "  (#$isa ?TERM #$ScriptRelation))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes semantic constraint vocabulary.
   */
  protected void addSemanticConstraintVocabulary()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Relations used to specify semantic constraints.";
    category.outputPath = "semantic-constraint-vocabulary.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$OpenCycDefinitionalPredicate))";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all person types.
   */
  protected void addAllPersonTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Classes of persons in the ontology release.";
    category.outputPath = "all-person-types.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genls ?TERM #$Person))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all organization types.
   */
  protected void addAllOrganizationTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Classes of organizations in the ontology release.";
    category.outputPath = "all-organization-types.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genls ?TERM #$Organization))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all event types.
   */
  protected void addAllEventTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Types of event.";
    category.outputPath = "all-event-types.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genls ?TERM #$Event))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all 'materials'.
   */
  protected void addAllMaterials()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Types of material.";
    category.outputPath = "all-materials.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$ExistingStuffType))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all weapon types.
   */
  protected void addAllWeaponTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Types of weapon.";
    category.outputPath = "all-weapon-types.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genls ?TERM #$Weapon))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all relations.
   */
  protected void addAllRelations()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All relations in the ontology.";
    category.outputPath = "all-relations.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$Relation))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all binary predicates.
   */
  protected void addAllBinaryPredicates()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "all binary predicates.";
    category.outputPath = "all-binary-predicates.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$BinaryPredicate))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all actorslots.
   */
  protected void addAllActorSlots()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All of the binary role relations obtaining between entities and events in the ontology.";
    category.outputPath = "all-actor-slots.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$ActorSlot))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all temporal relations.
   */
  protected void addAllTemporalRelations()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All of the temporal ordering relations in the ontology.";
    category.outputPath = "all-temporal-relations.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$ComplexTemporalPredicate))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all partonomic predicates.
   */
  protected void addAllPartonomicPredicates()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All of the part-whole relations in the ontology.";
    category.outputPath = "all-partonomic-predicates.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$PartPredicate))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all specializations of affiliation.
   */
  protected void addAllSpecializationsOfAffiliation()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All of the specializations of the affiliatedWith relation.";
    category.outputPath = "all-specializations-of-affiliation.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genlPreds ?TERM #$affiliatedWith))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all specializations of vested interest.
   */
  protected void addAllSpecializationsOfVestedInterest()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All of the specializations of the vestedInterest relation.";
    category.outputPath = "all-specializations-of-vested-interest.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$genlPreds ?TERM #$vestedInterest))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all denoting functions.
   */
  protected void addAllDenotingFunctions()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All denoting functions.";
    category.outputPath = "all-denoting-functions.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$Function-Denotational))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all scripted event types.
   */
  protected void addAllScriptedEventTypes()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "All scripted event types.";
    category.outputPath = "all-scripted-event-types.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$ScriptedEventType))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  
  /**
   * Categorizes the original EELD 'core' ontology.
   */
  protected void addEeldCoreOntology()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "EELD Core Ontology";
    category.outputPath = "all-core.html";
    category.queryString =
    "(#$isa ?TERM #$EELDSharedOntologyCoreConstant)";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes all public shared ontology constants.
   */
  protected void addPublicSharedOntology()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "Public Shared Ontology";
    category.outputPath = "all-public-shared.html";
    category.queryString =
    "(#$and\n" +
    " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
    " (#$isa ?TERM #$ProposedOrPublicConstant))\n";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Categorizes the original EELD 'core' ontology.
   */
  protected void askEeldCoreOntology()
  throws CycApiException, IOException , UnknownHostException {
    Category category = new Category();
    categories.add(category);
    category.title = "EELD Core Ontology";
    category.outputPath = "all-core.html";
    category.queryString =
    "(#$isa ?TERM #$EELDSharedOntologyCoreConstant)";
    category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
  }
  
  /**
   * Returns the sorted terms resulting from asking the given query string.
   *
   * @@param queryString the query, as a string
   * @@param mt the mt in which the query is asked
   * @@return the sorted terms resulting from asking the given query string
   */
  protected CycList askQueryString(String queryString, CycConstant mt)
  throws CycApiException, IOException , UnknownHostException {
    CycList query = cycAccess.makeCycList(queryString);
    CycVariable variable = CycObjectFactory.makeCycVariable("?TERM");
    CycList answer = cycAccess.queryVariable(variable, query, mt, (HashMap) null);
    if (verbosity > 2) {
      Log.current.println("query:\n" + queryString);
      Log.current.println("number of terms " + answer.size());
    }
    // Remove nauts which are returned as CycLists.
    CycList answerTemp = new CycList();
    for (int i = 0; i < answer.size(); i++) {
      Object obj = answer.get(i);
      if (obj instanceof CycFort)
        answerTemp.add(obj);
      else if (verbosity > 2)
        Log.current.println("Dropping non fort from answer\n" + obj.toString());
    }
    answer = answerTemp;
    Collections.sort(answer);
    return answer;
  }
  
  /**
   * Provides a container for term category information used to make
   * vocabulary category HTML pages.
   */
  public class Category {
    /**
     * The query string used to make this categorized vocabulary page.
     */
    public String queryString;
    
    /**
     * The mt in which the query is asked.
     */
    public CycConstant mt;
    
    /**
     * The file name used to output this categorized vocabulary page.
     */
    public String outputPath;
    
    /**
     * The title of this categorized vocabulary page.
     */
    public String title;
  }
  
  /**
   * Runs the ExportHtml application.
   *
   * @@param args The command line arguments.
   */
  public static void main(String[] args) {
    final Guid counterTerrorismConstantGuid = CycObjectFactory.makeGuid("bfe31c38-9c29-11b1-9dad-c379636f7270");
    final Guid terrorismOntologyConstantGuid = CycObjectFactory.makeGuid("93cfd306-4d27-41d9-8223-b22fa483c1eb");
    CycAccess cycAccess = null;
    try {
      cycAccess = new CycAccess(CycConnection.DEFAULT_HOSTNAME,
                                3600,
                                CycConnection.DEFAULT_COMMUNICATION_MODE,
                                CycAccess.DEFAULT_CONNECTION);
    }
    catch (Exception e) {
      Log.current.errorPrintln(e.getMessage());
      System.exit(1);
    }
    ExportHtml exportHtml = new ExportHtml(cycAccess);
    exportHtml.verbosity = 3;
    exportHtml.produceHierarchyPages = false;
    exportHtml.includeUpwardClosure = true;
    String choice = "terrorism-ontology-all";
    //        if (args.length > 0)
    //            choice = args[0];
    try {
      Log.current.println("Choosing KB selection: " + choice);
      // These require the ResearchCyc or full KB to work as setup below.
      if (choice.equals("terrorism-ontology")) {
        //                exportHtml.verbosity = 9;
        exportHtml.produceHierarchyPages = false;
        exportHtml.includeUpwardClosure = false;
        exportHtml.cycKbSubsetCollectionGuid = terrorismOntologyConstantGuid;
        exportHtml.exportedVocabularyOutputPath = "terrorism-ontology.html";
        exportHtml.upwardClosureKbSubsetCollectionGuids.add(publicConstantGuid);
        exportHtml.print_guid = false;
        exportHtml.cycKbSubsetFilterGuid = researchCycConstantGuid;
        exportHtml.export(EXPORT_KB_SUBSET);
        System.exit(0);
      }
      else if (choice.equals("terrorism-ontology-all")) {
        exportHtml.produceHierarchyPages = false;
        exportHtml.includeUpwardClosure = true;
        exportHtml.cycKbSubsetCollectionGuid = terrorismOntologyConstantGuid;
        exportHtml.exportedVocabularyOutputPath = "terrorism-ontology-all.html";
        exportHtml.upwardClosureKbSubsetCollectionGuids.add(publicConstantGuid);
        exportHtml.print_guid = false;
        exportHtml.cycKbSubsetFilterGuid = researchCycConstantGuid;
        exportHtml.export(EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
        System.exit(0);
      }
      else if (choice.equals("counter-terrorism")) {
        exportHtml.cycKbSubsetCollectionGuid = counterTerrorismConstantGuid;
        exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
        exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";
      }
      else {
        System.out.println("specified choice not found - " + choice);
        System.exit(1);
      }
      exportHtml.upwardClosureKbSubsetCollectionGuids.add(publicConstantGuid);
      
      Guid quaUnterestingWeaponSystemGuid =
      CycObjectFactory.makeGuid("c1085b99-9c29-11b1-9dad-c379636f7270");
      Guid economicInterestTypeGuid =
      CycObjectFactory.makeGuid("c02a0764-9c29-11b1-9dad-c379636f7270");
      
      exportHtml.filterFromDirectInstanceGuids.add(quaUnterestingWeaponSystemGuid);
      exportHtml.filterFromDirectInstanceGuids.add(economicInterestTypeGuid);
      exportHtml.print_guid = false;
      
      exportHtml.cycKbSubsetFilterGuid = ikbConstantGuid;
      exportHtml.export(EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
    } catch (Exception e) {
      e.printStackTrace();
      System.exit(1);
    }
  }
  
}
@


1.31
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@d28 1
a35 1

d39 1
a39 1
 * @@version $Id: ExportHtml.java,v 1.31 2005/08/23 16:01:28 reed Exp $
a115 3
  /** the web page title */
  public String title = null;
  
d131 2
a132 1
    logger.info("Getting terms from Cyc");
a135 2
    else if (exportCommand == ExportHtml.EXPORT_SELECTED_TERMS)
      ;
d145 2
a146 2
    logger.info("Selected " + selectedCycForts.size() + " CycFort terms");
    ensureSelectedTermsAreReified();
d149 2
a150 1
      logger.info("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
d152 8
a159 1
      logger.info("All selected " + selectedCycForts.size() + " CycFort terms");
a160 4
    if (includeNonAtomicTerms)
      logger.info("Dropping quoted collection terms ");
    else
      logger.info("Dropping quoted collection terms and non-atomic terms");
d163 5
a167 5
      CycObject cycObject = (CycObject) cycAccess.getHLCycTerm(((CycObject) selectedCycForts.get(i)).cyclify());
      if (cycObject instanceof CycList || 
         cycAccess.isQuotedCollection((CycFort) cycObject) || 
         (! includeNonAtomicTerms && ! (cycObject instanceof CycConstant))) {
        logger.info("  ommitting " + cycObject.cyclify());
d170 1
a170 1
        tempList.add(cycObject);
d172 3
a174 2
    selectedCycForts = omitTermsWithoutComments(tempList);
    logger.info("Sorting " + selectedCycForts.size() + " CycFort terms");
d179 2
a180 1
    if (rootTerm != null && produceHierarchyPages)
d182 2
a183 1
    else if (includeUpwardClosure && produceHierarchyPages)
d185 2
a186 1
    logger.info("Omitting ontology hierarchy export page");
d189 2
a190 1
      logger.info(cycObject.cyclify());
d192 2
a193 1
    logger.info("HTML export completed");
d207 2
a208 1
      logger.info("Exporting KB subset " + cycKbSubsetCollection.cyclify());
d214 2
a215 1
      logger.info("Exporting KB subset " + cycKbSubsetCollection.cyclify() + "\n  plus upward closure to #$Thing filtered by "
d223 2
a224 10
      logger.info("Exporting KB collections below root term " + rootTerm.cyclify() + "\n  filtered by " + cycKbSubsetFilter.cyclify());
    }
    else if (exportCommand == OntologyExport.EXPORT_SELECTED_TERMS) {
      cycKbSubsetFilter = (cycKbSubsetFilterGuid == null) ? null : cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
      cycKbSubsetCollection = cycKbSubsetFilter;
      includeUpwardClosure = false;
      if (cycKbSubsetFilter == null)
        logger.info("Exporting selected terms");
      else
        logger.info("Exporting selected terms filtered by " + cycKbSubsetFilter.cyclify());
d244 2
a245 1
    logger.info("Building HTML model for vocabulary page");
d247 1
a247 2
    if (title == null)
      title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
d258 2
a259 1
      logger.info(cycFort + "  ");
d261 2
a262 1
        logger.info("Collection");
d265 2
a266 1
        logger.info("Predicate");
d269 2
a270 1
        logger.info("Individual");
d273 2
a274 1
        logger.info("other");
d365 4
a368 2
    else
      logger.info("Unhandled constant: " + cycConstant.toString());
d408 2
a409 4
    final CycObject cycObject = (CycObject) cycAccess.getHLCycTerm(((CycObject) cycForts.get(0)).cyclify());
    
    if (! (cycObject instanceof CycFort)) {
      logger.severe("\nError, rewriteOf " + cycConstant.cyclify() +
d413 1
a413 1
    if (! (cycObject instanceof CycNart))
d415 1
a415 1
    CycNart cycNart = (CycNart) cycObject;
d659 2
a660 1
    logger.info("  starting isas: " + isas.cyclify());
d669 5
a673 3
      logger.finest("  considering " + isa.cyclify());
      logger.finest("    selectedCycForts.contains(" + isa.cyclify() + ") " + selectedCycForts.contains(isa));
      logger.finest("    cycAccess.isQuotedCollection(" + isa.cyclify() + ") " + cycAccess.isQuotedCollection(isa));
d682 2
a683 1
        logger.info("  omitting quoted direct-instance-of collection " + isa.cyclify());
d686 2
a687 1
        logger.finest("  adding direct instance of " + isa.cyclify());
d696 7
a702 14
      Node isaTextNode;
      if (selectedCycForts.contains(isa)) {
        HTMLAnchorElement isaAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        isaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + isa.cyclify());
        parentElement.appendChild(isaAnchorElement);
        isaTextNode = htmlDocument.createTextNode(isa.cyclify());
        isaAnchorElement.appendChild(isaTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        isaTextNode = htmlDocument.createTextNode(isa.cyclify() + "   ");
        parentElement.appendChild(isaTextNode);
      }
d719 2
a720 1
    logger.fine("  starting genls: " + genls.cyclify());
d730 2
a731 1
        logger.info("  omitting quoted genl collection " + genl.cyclify());
d800 2
a801 1
    logger.finer("  genlPreds " + genlPreds);
d804 1
a804 1
      CycObject genlPred = (CycObject)genlPreds.get(i);
d809 2
a810 1
    logger.finer("  after filtering, genlPreds " + genlPreds);
d819 9
a827 16
      CycFort genlPred = (CycFort)genlPreds.get(i);
      Node genlPredTextNode;
      if (selectedCycForts.contains(genlPred)) {
        HTMLAnchorElement genlPredAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        genlPredAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + genlPred.cyclify());
        parentElement.appendChild(genlPredAnchorElement);
        genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
        genlPredAnchorElement.appendChild(genlPredTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify() + "  ");
        parentElement.appendChild(genlPredTextNode);    
      }
d839 2
a840 1
    logger.finer("  arg1Isas " + arg1Isas);
d849 5
a853 1
      final CycFort arg1Isa = (CycFort)arg1Isas.get(i);
d855 3
a857 13
      if (selectedCycForts.contains(arg1Isa)) {
        HTMLAnchorElement arg1IsaAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        arg1IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg1Isa.cyclify());
        parentElement.appendChild(arg1IsaAnchorElement);
        arg1IsaTextNode = htmlDocument.createTextNode(arg1Isa.cyclify());
        arg1IsaAnchorElement.appendChild(arg1IsaTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        arg1IsaTextNode = htmlDocument.createTextNode(arg1Isa.cyclify() + "  ");
        parentElement.appendChild(arg1IsaTextNode);
      }
d869 2
a870 1
    logger.finer("  arg2Isas " + arg2Isas);
d879 9
a887 16
      final CycFort  arg2Isa = (CycFort)arg2Isas.get(i);
      Node arg2IsaTextNode;
      if (selectedCycForts.contains(arg2Isa)) {
        HTMLAnchorElement arg2IsaAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        arg2IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg2Isa.cyclify());
        parentElement.appendChild(arg2IsaAnchorElement);
        arg2IsaTextNode = htmlDocument.createTextNode(arg2Isa.cyclify());
        arg2IsaAnchorElement.appendChild(arg2IsaTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        arg2IsaTextNode = htmlDocument.createTextNode(arg2Isa.cyclify() + "  ");
        parentElement.appendChild(arg2IsaTextNode);
      }
d899 2
a900 1
    logger.finer("  arg3Isas " + arg3Isas);
d909 9
a917 16
      CycFort arg3Isa = (CycFort)arg3Isas.get(i);
      Node arg3IsaTextNode;
      if (selectedCycForts.contains(arg3Isa)) {
        HTMLAnchorElement arg3IsaAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        arg3IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg3Isa.cyclify());
        parentElement.appendChild(arg3IsaAnchorElement);
        arg3IsaTextNode = htmlDocument.createTextNode(arg3Isa.cyclify());
        arg3IsaAnchorElement.appendChild(arg3IsaTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        arg3IsaTextNode = htmlDocument.createTextNode(arg3Isa.cyclify() + "  ");
        parentElement.appendChild(arg3IsaTextNode);
      }
d929 2
a930 1
    logger.finer("  arg4Isas " + arg4Isas);
d939 9
a947 16
      CycFort arg4Isa = (CycFort)arg4Isas.get(i);
      Node arg4IsaTextNode;
      if (selectedCycForts.contains(arg4Isa)) {
        HTMLAnchorElement arg4IsaAnchorElement =
        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        arg4IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg4Isa.cyclify());
        parentElement.appendChild(arg4IsaAnchorElement);
        arg4IsaTextNode = htmlDocument.createTextNode(arg4Isa.cyclify());
        arg4IsaAnchorElement.appendChild(arg4IsaTextNode);
        Node spacesTextNode = htmlDocument.createTextNode("  ");
        parentElement.appendChild(spacesTextNode);
      }
      else {
        arg4IsaTextNode = htmlDocument.createTextNode(arg4Isa.cyclify() + "  ");
        parentElement.appendChild(arg4IsaTextNode);
      }
d959 2
a960 1
    logger.finer("  resultIsas " + resultIsas);
d1012 2
a1013 1
    logger.info("Building HTML model for hierarchy page");
d1045 2
a1046 1
      logger.info(spaces.toString() + cycFort);
d1049 2
a1050 1
      logger.info(cycFort.toString());
d1089 2
a1090 1
    logger.info("Writing HTML output to " + outputPath);
d1129 2
a1130 1
      logger.info("No terms for query:\n" + queryString + "\n");
d1133 2
a1134 1
    logger.info("Building HTML model for category: " + title);
d1146 14
a1159 7
      logger.info(cycFort + "  ");
      if (cycAccess.isCollection(cycFort))
        logger.info("Collection");
      else if (cycAccess.isPredicate(cycFort))
        logger.info("Predicate");
      else if (cycAccess.isIndividual(cycFort))
        logger.info("Individual");
d1161 2
a1162 1
        logger.info("other");
d1605 4
a1608 2
    logger.info("query:\n" + queryString);
    logger.info("number of terms " + answer.size());
d1615 2
a1616 1
      logger.info("Dropping non fort from answer\n" + obj.toString());
a1622 8
  /** Reports export progress to each of the listeners.
   *
   * @@param percentComplete the OWL export percent complete
   */
  protected void reportProgress(double percentComplete) {
    //TODO implement for HTML export monitoring
  }
  
d1660 3
a1662 1
                                3600);
d1665 1
a1665 1
      System.err.println(e.getMessage());
d1669 1
d1676 1
a1676 1
      exportHtml.logger.info("Choosing KB selection: " + choice);
@


1.30
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@@


1.29
log
@Changing the state machine interpreter to keep state in the Cyc server.
@
text
@d3 31
a33 11
import  java.io.*;
import  java.util.*;
import  java.net.*;
import  org.w3c.dom.*;
import  org.w3c.dom.html.*;
import  org.apache.html.dom.*;
import  org.apache.xml.serialize.*;
import  ViolinStrings.Strings;
import  org.opencyc.cycobject.*;
import  org.opencyc.api.*;
import  org.opencyc.util.*;
d37 1
a37 1
 * HTML ontology export for OpenCyc.
d39 1
a39 1
 * @@version $Id: ExportHtml.java,v 1.28 2002/08/23 18:37:13 stephenreed Exp $
d60 525
a584 787
public class ExportHtml {
    /**
     * Command indicating that the HTML export contains only the marked KB
     * subset terms.  cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.  cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the upward closure.
     */
    public static final int EXPORT_KB_SUBSET = 1;
    /**
     * Command indicating that the HTML export contains the marked KB
     * subset terms plus all the terms in the upward closure to #$Thing.
     * cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.
     */
    public static final int EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE = 2;
    /**
     * Command indicating that the HTML export contains the collections whose
     * direct or indirect genl is the collection term indentified by rootTermGuid.
     * cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the export set.
     */
    public static final int EXPORT_KB_SUBSET_BELOW_TERM = 3;
    /**
     * The command performed by the HTML extract process.
     */
    protected int exportCommand = 0;
    /**
     * The default verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected static final int DEFAULT_VERBOSITY = 3;
    /**
     * Sets verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public int verbosity = DEFAULT_VERBOSITY;
    /**
     * Indicates whether the upward closure of terms should be exported.  If so, the
     * upward closure terms are filtered by cycKbSubsetFilterGuid below.
     */
    public boolean includeUpwardClosure = false;
    /**
     * Indicates whether hierarchy pages are produced.
     */
    public boolean produceHierarchyPages = false;
    /**
     * Upward closure filtering kb subset collections guids.  These constrain the selected
     * upward closure collection terms to be members of any of these kb subset
     * collections.
     */
    public ArrayList upwardClosureKbSubsetCollectionGuids = new ArrayList();
    /**
     * Upward closure filtering kb subset collections.  These constrain the selected
     * upward closure collection terms to be members of any of these kb subset
     * collections.
     */
    protected  ArrayList upwardClosureKbSubsetCollections = new ArrayList();
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public CycFort cycKbSubsetCollection = null;
    /**
     * The #$EELDSharedOntologyConstant guid.
     */
    public static final Guid eeldSharedOntologyConstantGuid = CycObjectFactory.makeGuid("c06e4624-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$EELDSharedOntologyConstant guid.
     */
    public static final Guid eeldSharedOntologyCandidateConstantGuid =
        CycObjectFactory.makeGuid("bf21d357-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$EELDSharedOntologyCoreConstant guid.
     */
    public static final Guid eeldSharedOntologyCoreConstantGuid = CycObjectFactory.makeGuid("c12e44bd-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$CounterTerrorismConstant guid.
     */
    public static final Guid counterTerrorismConstantGuid = CycObjectFactory.makeGuid("bfe31c38-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$IKBConstant guid.
     */
    public static final Guid ikbConstantGuid = CycObjectFactory.makeGuid("bf90b3e2-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$PublicConstant guid.
     */
    public static final Guid publicConstantGuid =
        CycObjectFactory.makeGuid("bd7abd90-9c29-11b1-9dad-c379636f7270");
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public Guid cycKbSubsetCollectionGuid = null;
    /**
     * The guid which identifies the CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    public Guid cycKbSubsetFilterGuid = null;
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    protected CycFort cycKbSubsetFilter = null;
    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * the collection term indentified by this value.
     */
    public Guid rootTermGuid = null;
    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * this collection term.
     */
    public CycFort rootTerm = null;
    /**
     * #$rewriteOf guid
     */
    public static final Guid rewriteOfGuid =
        CycObjectFactory.makeGuid("c13bc0c4-9c29-11b1-9dad-c379636f7270");
    /**
     * #$equalSymbols guid
     */
    public static final Guid equalSymbolsGuid =
        CycObjectFactory.makeGuid("c05e110e-9c29-11b1-9dad-c379636f7270");
    /**
     * #$InferencePSC guid
     */
    public static final Guid inferencePSCGuid =
        CycObjectFactory.makeGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
    /**
     * The HTML exported vocabulary path and file name.
     */
    public String exportedVocabularyOutputPath = "exported-vocabulary.html";
    /**
     * The HTML exported hierarchy path and file name.
     */
    public String exportedHierarchyOutputPath = "exported-hierarchy.html";
    /**
     * The NART note file name.
     */
    public String nartNoteOutputPath = "ontology-release-NARTs.html";
        /**
     * the html document
     */
    protected HTMLDocument htmlDocument;
    /**
     * Manages connection to the cyc server api.
     */
    protected CycAccess cycAccess;
    /**
     * the HTML body element
     */
    protected Element htmlBodyElement;
    /**
     * the selected terms
     */
    protected CycList selectedCycForts;
    /**
     * Indicates the presence of a comment for the current term.
     */
    protected boolean hasComment = false;
    /**
     * indicates which terms have been previously expanded in the hierarchy page
     */
    protected HashSet previouslyExpandedTerms;
    protected String hostname = CycConnection.DEFAULT_HOSTNAME;
    protected int port = CycConnection.DEFAULT_BASE_PORT;

    /**
     * Additional term guids not to appear in the list of direct instances even if
     * otherwise qualified to appear.
     */
    protected ArrayList filterFromDirectInstanceGuids = new ArrayList();

    /**
     * Additional terms not to appear in the list of direct instances even if
     * otherwise qualified to appear.
     */
    protected ArrayList filterFromDirectInstances = new ArrayList();

    /**
     * Export the GUID string for each term?
     */
    public boolean print_guid = false;


    /**
     * List of HTML vocabulary category page information items.
     */
    public ArrayList categories = new ArrayList();

    /**
     * Constructs a new ExportHtml object.
     */
    public ExportHtml () {
        Log.makeLog();
    }

    /**
     * Constructs a new ExportHtml object which will connect to the cyc server
     * at hostname, port.
     *
     * @@param hostname the cyc server hostname
     * @@param port the cyc server base port
     */
    public ExportHtml (String hostname, int port) {
        this();
        this.hostname = hostname;
        this.port = port;
    }

    /**
     * Constructs a new ExportHtml object which will connect to the cyc server
     * at hostname, port.  print_guid value gates guid printing.
     *
     * @@param hostname the cyc server hostname
     * @@param port the cyc server base port
     * @@param print_guid gates guid presence in the HTML document
     */
    public ExportHtml (String hostname, int port, boolean print_guid) {
        this(hostname, port);
        this.print_guid = print_guid;
    }

    /**
     * Runs the ExportHtml application.
     *
     * @@param args the command line arguments.
     */
    public static void main (String[] args) {
        ExportHtml exportHtml = new ExportHtml();
        exportHtml.verbosity = 3;
        try {
            String localHostName = InetAddress.getLocalHost().getHostName();
            if (localHostName.equals("crapgame.cyc.com")) {
                exportHtml.cycAccess = new CycAccess("localhost",
                                          3620,
                                          CycConnection.DEFAULT_COMMUNICATION_MODE,
                                          CycAccess.DEFAULT_CONNECTION);
            }
            else {
                exportHtml.cycAccess = new CycAccess();
            }
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            System.exit(1);
        }
        exportHtml.produceHierarchyPages = false;
        exportHtml.includeUpwardClosure = true;

        // Hard coded for the most often requested EELD program
        String choice = "eeld";
        if (args.length > 0)
            choice = args[0];
        try {
            Log.current.println("Choosing KB selection: " + choice);
            // These require the Cycorp IKB or full KB to work as setup below.
            if (choice.equals("counter-terrorism")) {
                exportHtml.cycKbSubsetCollectionGuid = counterTerrorismConstantGuid;
                exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
                exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";
            }
            else if (choice.equals("eeld-core")) {
                exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
                exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
                exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";
                exportHtml.upwardClosureKbSubsetCollectionGuids.add(eeldSharedOntologyCoreConstantGuid);
                exportHtml.addAllCategories();
            }
            else if (choice.equals("eeld")) {
                exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
                exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
                exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";
                exportHtml.upwardClosureKbSubsetCollectionGuids.add(eeldSharedOntologyConstantGuid);
                exportHtml.addAllCategories();
            }
            else if (choice.equals("eeld-candidate")) {
                exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCandidateConstantGuid;
                exportHtml.exportedVocabularyOutputPath = "eeld-shared-candidate-vocabulary.html";
                exportHtml.exportedHierarchyOutputPath = "eeld-shared-candidate-hierarchy.html";
                exportHtml.upwardClosureKbSubsetCollectionGuids.add(eeldSharedOntologyCandidateConstantGuid);
            }
            else {
                System.out.println("specified choice not found - " + choice);
                System.exit(1);
            }
            exportHtml.upwardClosureKbSubsetCollectionGuids.add(publicConstantGuid);

            Guid quaUnterestingWeaponSystemGuid =
                CycObjectFactory.makeGuid("c1085b99-9c29-11b1-9dad-c379636f7270");
            Guid economicInterestTypeGuid =
                CycObjectFactory.makeGuid("c02a0764-9c29-11b1-9dad-c379636f7270");

            exportHtml.filterFromDirectInstanceGuids.add(quaUnterestingWeaponSystemGuid);
            exportHtml.filterFromDirectInstanceGuids.add(economicInterestTypeGuid);
            exportHtml.print_guid = false;

            exportHtml.cycKbSubsetFilterGuid = ikbConstantGuid;
            exportHtml.export(EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Exports the desired KB content into HTML.
     */
    public void export (int exportCommand) throws UnknownHostException, IOException, CycApiException {
        this.exportCommand = exportCommand;
        setup();
        if (verbosity > 2)
            Log.current.println("Getting terms from Cyc");
        if ((exportCommand == ExportHtml.EXPORT_KB_SUBSET) || (exportCommand == ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
            selectedCycForts = cycAccess.getAllInstances(cycKbSubsetCollection);
        }
        else {
            // EXPORT_KB_SUBSET_BELOW_TERM
            selectedCycForts = cycAccess.getAllSpecs(rootTerm);
            selectedCycForts.add(rootTerm);
        }
        if (verbosity > 2)
            Log.current.println("Selected " + selectedCycForts.size() + " CycFort terms");
        if (includeUpwardClosure) {
            CycList upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
            if (verbosity > 2)
                Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
            selectedCycForts.addAll(upwardClosureCycForts);
            if (verbosity > 2)
                Log.current.println("All selected " + selectedCycForts.size() + " CycFort terms");
        }
        if (verbosity > 2)
            Log.current.println("Ommitting quoted collection terms ");
        CycList tempList = new CycList();
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort) selectedCycForts.get(i);
            if (cycAccess.isQuotedCollection(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("  ommitting " + cycFort.cyclify());
            }
            else
                tempList.add(cycFort);
        }
        selectedCycForts = tempList;
        if (verbosity > 2)
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
        Collections.sort(selectedCycForts);
        createVocabularyPage();
        if (categories.size() > 0)
            createCategorizedVocabularies();
        if (rootTerm != null &&
            produceHierarchyPages)
            createHierarchyPage(rootTerm);
        else if (includeUpwardClosure &&
                 produceHierarchyPages)
            createHierarchyPage(CycAccess.thing);
        else if (verbosity > 0)
            Log.current.println("Ommiting ontology hierarchy export page");
        if (verbosity > 0)
            Log.current.println("HTML export completed");
        cycAccess.close();
    }

    /**
     * Sets up the HTML export process.
     */
    protected void setup () throws UnknownHostException, IOException, CycApiException {


        if (exportCommand == ExportHtml.EXPORT_KB_SUBSET) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
        }
        else if (exportCommand == ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            includeUpwardClosure = true;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() + "\n  plus upward closure to #$Thing filtered by "
                        + cycKbSubsetFilter.cyclify());
        }
        else if (exportCommand == ExportHtml.EXPORT_KB_SUBSET_BELOW_TERM) {
            rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            cycKbSubsetCollection = cycKbSubsetFilter;
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() + "\n  filtered by " + cycKbSubsetFilter.cyclify());
        }
        else {
            System.err.println("Invalid export comand " + exportCommand);
            System.exit(1);
        }
        for (int i = 0; i < filterFromDirectInstanceGuids.size(); i++) {
            Guid guid = (Guid) filterFromDirectInstanceGuids.get(i);
            filterFromDirectInstances.add(cycAccess.getKnownConstantByGuid(guid));
        }
        for (int i = 0; i < upwardClosureKbSubsetCollectionGuids.size(); i++) {
            Guid guid = (Guid) upwardClosureKbSubsetCollectionGuids.get(i);
            upwardClosureKbSubsetCollections.add(cycAccess.getKnownConstantByGuid(guid));
        }
    }

    /**
     * Creates vocabulary HTML page.
     */
    protected void createVocabularyPage () throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for vocabulary page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (verbosity > 2)
                Log.current.print(cycFort + "  ");
            if (cycAccess.isCollection(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Collection");
            }
            else if (cycAccess.isPredicate(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Predicate");
            }
            else if (cycAccess.isIndividual(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Individual");
            }
            else {
                if (verbosity > 2)
                    Log.current.println("other");
                continue;
            }
            if (cycFort instanceof CycConstant)
                createCycConstantNode((CycConstant) cycFort);
            else
                createCycNartNode((CycNart) cycFort);
        }
        serialize(htmlDocument, exportedVocabularyOutputPath);
    }

    /**
     * Creates a HTML node for a single Cyc Nart.
     * @@parameter cycNart the CycNart from which the HTML node is created
     */
    protected void createCycNartNode (CycNart cycNart)
        throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement =
            new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        htmlAnchorElement.setName(cycNart.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        String generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycNart);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node collectionTextNode = htmlDocument.createTextNode(cycNart.cyclify());
        htmlAnchorElement.appendChild(collectionTextNode);
        Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
        Node generatedPhraseNode =
            htmlDocument.createTextNode("   " + generatedPhrase);
        italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        HTMLAnchorElement natNoteAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        natNoteAnchorElement.setHref("./" + nartNoteOutputPath);
        blockquoteElement.appendChild(natNoteAnchorElement);
        Node natNoteTextNode = htmlDocument.createTextNode("Note On Non-Atomic Terms");
        natNoteAnchorElement.appendChild(natNoteTextNode);
        createIsaNodes(cycNart, blockquoteElement);
        createGenlNodes(cycNart, blockquoteElement);
    }

    /**
     * Creates a HTML node for a single Cyc Constant.
     * @@parameter cycConstant the CycConstant from which the HTML node is created
     */
    protected void createCycConstantNode (CycConstant cycConstant)
        throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        htmlAnchorElement.setName(cycConstant.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        Node collectionTextNode = htmlDocument.createTextNode(cycConstant.cyclify());
        htmlAnchorElement.appendChild(collectionTextNode);
        boolean hasRewrite = processRewriteOf(cycConstant, htmlFontElement);
        if (! hasRewrite) {
            // If no rewriteOf text, then output the generated phrase.
            String generatedPhrase;
            if (cycAccess.isCollection(cycConstant))
                generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycConstant);
            else
                generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycConstant);
            if (generatedPhrase.endsWith("(unclassified term)"))
                generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
            Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
            Node generatedPhraseNode =
                htmlDocument.createTextNode("   " + generatedPhrase);
            italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
        }
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        createCommentNodes(cycConstant, blockquoteElement);
        if (print_guid)
            createGuidNode(cycConstant, blockquoteElement);
        createIsaNodes(cycConstant, blockquoteElement);
        if (cycAccess.isCollection(cycConstant))
            createCollectionNode(cycConstant, blockquoteElement);
        else if (cycAccess.isPredicate(cycConstant))
            createPredicateNode(cycConstant, blockquoteElement);
        else if (cycAccess.isFunction(cycConstant))
            createFunctionNode(cycConstant, blockquoteElement);
        else if (cycAccess.isIndividual(cycConstant))
            createIndividualNode(cycConstant, blockquoteElement);
        else {
            if (verbosity > 0)
                Log.current.println("Unhandled constant: " + cycConstant.toString());
        }
    }

    /**
     * Processes the case where the given Cyc constant has a #$rewriteOf relationship
     * to a Cyc FORT (First Order Reified Term).  For example when the given term is
     * #$AttemptedKillingByCarAccident, then the KB contains the assertion
     * (#$rewriteOf #$AttemptedKillingByCarAccident ((KillingThroughEventTypeFn #$CarAccident))
     * and the phrase " is the atomic form of (KillingThroughEventTypeFn #$CarAccident)" is
     * output to the HTML document.
     *
     * @@param cycConstant the given CycConstant for processing if a #$rewriteOf
     * @@param parentElement the parent HTML element for inserting rewriteOf text
     * @@return true iff there is in fact a rewrite term
     */
    protected boolean processRewriteOf(CycConstant cycConstant,
                                    Element parentElement)
        throws UnknownHostException, IOException, CycApiException {
        CycList query = new CycList();
        query.add(cycAccess.and);
        CycList query1 = new CycList();
        query.add(query1);

        query1.add(cycAccess.getKnownConstantByGuid(rewriteOfGuid));
        query1.add(cycConstant);
        CycVariable fortVariable = CycObjectFactory.makeCycVariable("?FORT");
        query1.add(fortVariable);
        CycConstant inferencePSC = cycAccess.getKnownConstantByGuid(inferencePSCGuid);
        // #$rewriteOf is reflexsive so constrain arg2 to be different from arg1.
        CycList query2 = new CycList();
        query.add(query2);
        query2.add(cycAccess.not);
        CycList query3 = new CycList();
        query2.add(query3);
        query3.add(cycAccess.getKnownConstantByGuid(equalSymbolsGuid));
        query3.add(cycConstant);
        query3.add(fortVariable);
        CycList cycForts = cycAccess.askWithVariable(query, fortVariable, inferencePSC);
        if (cycForts.size() == 0)
            return false;
        if (! (cycForts.get(0) instanceof CycFort)) {
            Log.current.errorPrintln("\nError, rewriteOf " + cycConstant.cyclify() +
                                     "\n " + cycForts.get(0) + "\nis not a CycFort\n");
            return false;
        }
        if (! (cycForts.get(0) instanceof CycNart))
            return false;
        CycNart cycNart = (CycNart) cycForts.get(0);

        Node rewriteOfTextNode = htmlDocument.createTextNode("  is the atomic form of ");
        parentElement.appendChild(rewriteOfTextNode);

        processRewrittenNart(cycNart, parentElement);
        return true;
    }

    /**
     * Creates nodes for rewritten NARTs.  Recursive for the NART components, putting
     * hyperlinks where possible.
     *
     * @@param object the given ojbect for processing in a #$rewriteOf
     * @@param parentElement the parent HTML element for inserting rewriteOf text
     */
    protected void processRewrittenNart (Object object, Element parentElement)
        throws UnknownHostException, IOException, CycApiException {
        if (object instanceof CycList) {
            CycList cycList = (CycList) object;
            for (int i = 0; i < cycList.size(); i++) {
                Object item = cycList.get(i);
                parentElement.appendChild(htmlDocument.createTextNode(" "));
                // recurse for each list item
                processRewrittenNart(item, parentElement);
            }
            return;
        }
        if (object instanceof CycConstant) {
            CycConstant cycConstant = (CycConstant) object;
            if (selectedCycForts.contains(object)) {
                HTMLAnchorElement cycConstantAnchorElement =
                    new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                cycConstantAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycConstant.cyclify());
                parentElement.appendChild(cycConstantAnchorElement);
                cycConstantAnchorElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
            }
            else
                parentElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
            return;
        }
        if (object instanceof CycNart) {
            CycNart cycNart = (CycNart) object;
            if (selectedCycForts.contains(cycNart)) {
                HTMLAnchorElement cycFortAnchorElement =
                    new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                cycFortAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycNart.cyclify());
                parentElement.appendChild(cycFortAnchorElement);
                cycFortAnchorElement.appendChild(htmlDocument.createTextNode("( "));
            }
            else
                parentElement.appendChild(htmlDocument.createTextNode("("));
            CycFort functor = cycNart.getFunctor();
            // recurse for the functor
            processRewrittenNart(functor, parentElement);
            for (int i = 0; i < cycNart.getArguments().size(); i++) {
                Object argument = cycNart.getArguments().get(i);
                parentElement.appendChild(htmlDocument.createTextNode(" "));
                // recurse for each arg
                processRewrittenNart(argument, parentElement);
            }
            Node rightParenTextNode = htmlDocument.createTextNode(")");
            parentElement.appendChild(rightParenTextNode);
            return;
        }
        parentElement.appendChild(htmlDocument.createTextNode(object.toString()));
}



    /**
     * Creates a paragraph break in the HTML document.
     */
    protected void paragraphBreak () {
        Element paragraphElement = htmlDocument.createElement("p");
        htmlBodyElement.appendChild(paragraphElement);
    }

    /**
     * Creates an italics element in the HTML document.
     *
     * @@param parentElement the parent HTML DOM element
     * @@return the italics element
     */
    protected Element italics (Element parentElement) {
        Element italicsElement = htmlDocument.createElement("i");
        parentElement.appendChild(italicsElement);
        return  italicsElement;
    }

    /**
     * Creates a line break in the HTML document.
     *
     * @@param parentElement the parent HTML DOM element
     */
    protected void lineBreak (Element parentElement) {
        Element breakElement = htmlDocument.createElement("br");
        parentElement.appendChild(breakElement);
    }

    /**
     * Creates a horizontal rule in the HTML document.
     */
    protected void horizontalRule () {
        Element horizontalRuleElement = htmlDocument.createElement("hr");
        htmlBodyElement.appendChild(horizontalRuleElement);
    }

    /**
     * Creates HTML nodes for comment text containing CycConstants which are to be
     * represented as hyperlinks.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCommentNodes (CycConstant cycConstant, Element parentElement)
        throws IOException, CycApiException {
        String comment = cycAccess.getComment(cycConstant);
        if (comment.equals("")) {
            hasComment = false;
            return;
        }
        hasComment = true;
        StringTokenizer st = new StringTokenizer(comment);
        StringBuffer stringBuffer = new StringBuffer();
        CycConstant commentConstant;
        Node commentTextNode;
        Node linkTextNode;
        HTMLAnchorElement htmlAnchorElement;
        while (st.hasMoreTokens()) {
            String word = st.nextToken();
            boolean wordHasLeadingLeftParen = false;
            if (word.startsWith("(#$")) {
                wordHasLeadingLeftParen = true;
                word = word.substring(1);
            }
            if (word.startsWith("#$")) {
                StringBuffer nonNameChars = new StringBuffer();
                while (true) {
                    // Move trailing non-name characters.
                    char ch = word.charAt(word.length() - 1);
                    if (Character.isLetterOrDigit(ch))
                        break;
                    word = Strings.stripTrailing(word, ch);
                    nonNameChars.insert(0, ch);
                    if (word.length() == 0)
                        break;
                }
                commentConstant = cycAccess.getConstantByName(word);
                if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
                    stringBuffer.append(" ");
                    commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    parentElement.appendChild(commentTextNode);
                    stringBuffer = new StringBuffer();
                    htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                    htmlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + commentConstant.cyclify());
                    parentElement.appendChild(htmlAnchorElement);
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                    linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    htmlAnchorElement.appendChild(linkTextNode);
                    stringBuffer = new StringBuffer();
                }
                else if (commentConstant == null && word.endsWith("s")) {
                    commentConstant = cycAccess.getConstantByName(word.substring(0, word.length() - 1));
                    if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
                        stringBuffer.append(" ");
                        commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        parentElement.appendChild(commentTextNode);
                        stringBuffer = new StringBuffer();
                        htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                        htmlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + commentConstant.cyclify());
                        parentElement.appendChild(htmlAnchorElement);
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                        linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        htmlAnchorElement.appendChild(linkTextNode);
                        stringBuffer = new StringBuffer();
                    }
                    else {
                        stringBuffer.append(" ");
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                    }
                }
                else {
                    stringBuffer.append(" ");
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                }
            }
            else {
                stringBuffer.append(" ");
                stringBuffer.append(word);
            }
        }
        if (stringBuffer.length() > 0) {
d587 19
d607 104
a710 130
    }

    /**
     * Creates HTML node for guid.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGuidNode (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        Guid guid = cycConstant.getGuid();
        if (hasComment)
            lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node guidLabelTextNode = htmlDocument.createTextNode("guid: ");
        bElement.appendChild(guidLabelTextNode);
        Node guidTextNode = htmlDocument.createTextNode(guid.toString());
        parentElement.appendChild(guidTextNode);
    }

    /**
     * Creates HTML nodes for isa links.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIsaNodes (CycFort cycFort, Element parentElement) throws IOException, CycApiException {
        //if (cycFort.toString().equals("BiochemicallyHarmfulSubstance"))
        //    verbosity = 9;
        CycList isas = cycAccess.getIsas(cycFort);
        if (verbosity > 3)
            Log.current.println("  starting isas: " + isas.cyclify());
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node isasLabelTextNode = htmlDocument.createTextNode("direct instance of: ");
        bElement.appendChild(isasLabelTextNode);
        CycList createdIsas = new CycList();
        for (int i = 0; i < isas.size(); i++) {
            CycFort isa = (CycFort)isas.get(i);
            if (verbosity > 7) {
                Log.current.println("  considering " + isa.cyclify());
                Log.current.println("selectedCycForts.contains(isa) " + selectedCycForts.contains(isa));
                Log.current.println("cycAccess.isQuotedCollection(isa) " + cycAccess.isQuotedCollection(isa));
            }
            if (! selectedCycForts.contains(isa)) {
                isa = findSelectedGenls(isa);
                if (isa == null)
                    continue;
            }
            if (createdIsas.contains(isa))
                continue;
            else if (cycAccess.isQuotedCollection(isa)) {
                if (verbosity > 2)
                    Log.current.println("  omitting quoted direct-instance-of collection " + isa.cyclify());
            }
            else {
                if (verbosity > 7)
                    Log.current.println("  adding direct instance of " + isa.cyclify());
                createdIsas.add(isa);
            }
        }
        createdIsas = specificCollections(createdIsas);
        // filter out any specified terms.
        createdIsas.removeAll(filterFromDirectInstances);
        for (int i = 0; i < createdIsas.size(); i++) {
            CycFort isa = (CycFort)createdIsas.get(i);
            HTMLAnchorElement isaAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            isaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + isa.cyclify());
            parentElement.appendChild(isaAnchorElement);
            Node isaTextNode = htmlDocument.createTextNode(isa.cyclify());
            isaAnchorElement.appendChild(isaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Returns the first indirect genls above the given term which is a member of the selected
     * terms.
     *
     * @@param collection the cyc collection which is not a member of the selected terms.
     * @@return the first indirect genls above the given term which is a member of the selected
     * terms
     */
    protected CycFort findSelectedGenls (CycFort collection) throws IOException, CycApiException {
        if (collection.equals(cycAccess.getKnownConstantByName("CycKBSubsetCollection"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return  null;
        }
        Guid cycSecureFortGuid = new Guid("bf71b522-9c29-11b1-9dad-c379636f7270");
        if (collection.equals(cycAccess.getKnownConstantByGuid(cycSecureFortGuid))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return  null;
        }
        CycList genls = cycAccess.getGenls(collection);
        if (verbosity > 3)
            Log.current.println("  genls of " + collection.cyclify() + " are " + genls.cyclify());
        CycFort directGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort)genls.get(i);
            if (selectedCycForts.contains(directGenls)) {
                if (verbosity > 3)
                    Log.current.println("  traversed up from genls " + collection.cyclify() + " to find selected genls " + directGenls);
                return  directGenls;
            }
        }
        CycFort selectedGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort)genls.get(i);
            selectedGenls = findSelectedGenls(directGenls);
            if (selectedGenls != null) {
                if (verbosity > 3)
                    Log.current.println("  traversed up from genls " + collection.cyclify() + " to find selected genls " + selectedGenls);
                return  selectedGenls;
            }
        }
        return  null;
    }

    /**
     * Creates HTML nodes for genl links.
     *
     * @@param cycConstant the CycConstant for which genl links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlNodes (CycFort cycFort, Element parentElement) throws IOException, CycApiException {
        CycList genls = cycAccess.getGenls(cycFort);
a714 1139
        */
        if (verbosity > 3)
            Log.current.println("  starting genls: " + genls.cyclify());
        CycList tempList = filterSelectedConstants(genls);
        if (verbosity > 3)
            Log.current.println("  after filtering: " + tempList.cyclify());
        if (tempList.size() == 0) {
            for (int i = 0; i < genls.size(); i++) {
                CycFort genl = (CycFort) genls.get(i);
                CycFort tempGenl = findSelectedGenls(genl);
                if (tempGenl != null) {
                    tempList.add(tempGenl);
                    if (verbosity > 2)
                        Log.current.println("  replaced " + genl.cyclify() +
                                            " with " + tempGenl.cyclify());
                }
                else if (verbosity > 2)
                    Log.current.println("  cannot replace " + genl.cyclify() +
                                        " with a valid genl");
            }
        }
        if (tempList.contains(cycFort)) {
            tempList.remove(cycFort);
            if (verbosity > 2)
                Log.current.println("  removed " + cycFort.cyclify() + " as a spec of itself");
        }
        genls = specificCollections(tempList);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
        bElement.appendChild(genlsLabelTextNode);
        for (int i = 0; i < genls.size(); i++) {
            CycFort genl = (CycFort)genls.get(i);
            if (cycAccess.isQuotedCollection(genl)) {
                if (verbosity > 2)
                    Log.current.println("  omitting quoted genl collection " + genl.cyclify());
            }
            else if (selectedCycForts.contains(genl)) {
                HTMLAnchorElement genlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                genlAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + genl.cyclify());
                parentElement.appendChild(genlAnchorElement);
                Node genlTextNode = htmlDocument.createTextNode(genl.cyclify());
                genlAnchorElement.appendChild(genlTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("  ");
                parentElement.appendChild(spacesTextNode);
            }
        }
        if ((genls.size() > 0) && produceHierarchyPages) {
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
            HTMLAnchorElement hierarchyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            hierarchyAnchorElement.setHref("./" + exportedHierarchyOutputPath + "./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
            parentElement.appendChild(hierarchyAnchorElement);
            Node hierarchyTextNode = htmlDocument.createTextNode("hierarchy");
            hierarchyAnchorElement.appendChild(hierarchyTextNode);
        }
    }

    /**
     * Given a set of collection terms, returns a set which does not contain any collections
     * are more genl than the remaining collections.
     *
     * @@param collections the given set of collection terms
     * @@return a set of collection terms which does not contain any collections are more genl than the
     * remaining collections.
     */
    protected CycList specificCollections (CycList collections) throws IOException, CycApiException {
        if (verbosity > 3)
            Log.current.println("  specificCollections input: " + collections.cyclify());
        CycList result = new CycList();
        for (int i = 0; i < collections.size(); i++) {
            CycFort genlsCollection = (CycFort)collections.get(i);
            boolean genlsOf = false;
            for (int j = 0; j < collections.size(); j++) {
                CycFort specCollection = (CycFort)collections.get(j);
                if (i != j) {
                    if (verbosity > 6)
                        Log.current.println("  genlsCollection? " + genlsCollection + " specCollection? " + specCollection);
                    if (cycAccess.isGenlOf(genlsCollection, specCollection)) {
                        genlsOf = true;
                        if (verbosity > 4)
                            Log.current.println("  collection " + genlsCollection + " genls of " + specCollection + " and is dropped");
                        break;
                    }
                }
            }
            if (!genlsOf)
                result.add(genlsCollection);
        }
        if (verbosity > 3)
            Log.current.println("  specificCollections output: " + result.cyclify());
        return  result;
    }

    /**
     * Creates an HTML node for a single Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createPredicateNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        createGenlPredsNodes(cycConstant, parentElement);
        int arity = cycAccess.getArity(cycConstant);
        if (arity > 0)
            createArg1IsaNodes(cycConstant, parentElement);
        if (arity > 1)
            createArg2IsaNodes(cycConstant, parentElement);
        if (arity > 2)
            createArg3IsaNodes(cycConstant, parentElement);
        if (arity > 3)
            createArg4IsaNodes(cycConstant, parentElement);
    }

    /**
     * Creates an HTML node for a single Cyc function.
     *
     * @@parameter cycConstant the Cyc function from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createFunctionNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        int arity = cycAccess.getArity(cycConstant);
        if (arity > 0)
            createArg1IsaNodes(cycConstant, parentElement);
        if (arity > 1)
            createArg2IsaNodes(cycConstant, parentElement);
        if (arity > 2)
            createArg3IsaNodes(cycConstant, parentElement);
        if (arity > 3)
            createArg4IsaNodes(cycConstant, parentElement);
        createResultIsaNodes(cycConstant, parentElement);
    }

    /**
     * Creates HTML nodes for genlPreds links.
     *
     * @@param cycConstant the CycConstant for which genlPreds links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlPredsNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList genlPreds = filterSelectedConstants(cycAccess.getGenlPreds(cycConstant));
        if (verbosity > 4)
            Log.current.println("genlPreds " + genlPreds);
        CycList tempList = new CycList();
        for (int i = 0; i < genlPreds.size(); i++) {
            CycConstant genlPred = (CycConstant)genlPreds.get(i);
            if (selectedCycForts.contains(genlPred))
                tempList.add(genlPred);
        }
        genlPreds = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, genlPreds " + genlPreds);
        if (genlPreds.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsPredsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
        bElement.appendChild(genlsPredsLabelTextNode);
        for (int i = 0; i < genlPreds.size(); i++) {
            CycConstant genlPred = (CycConstant)genlPreds.get(i);
            HTMLAnchorElement genlPredAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            genlPredAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + genlPred.cyclify());
            parentElement.appendChild(genlPredAnchorElement);
            Node genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
            genlPredAnchorElement.appendChild(genlPredTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates HTML nodes for arg1Isa links.
     *
     * @@param cycConstant the CycConstant for which arg1Isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createArg1IsaNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList arg1Isas = filterSelectedConstants(cycAccess.getArg1Isas(cycConstant));
        if (verbosity > 4)
            Log.current.println("arg1Isas " + arg1Isas);
        CycList tempList = new CycList();
        for (int i = 0; i < arg1Isas.size(); i++) {
            CycConstant arg1Isa = (CycConstant) arg1Isas.get(i);
            if (selectedCycForts.contains(arg1Isa))
                tempList.add(arg1Isa);
        }
        arg1Isas = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, arg1Isas " + arg1Isas);
        if (arg1Isas.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node arg1IsasLabelTextNode = htmlDocument.createTextNode("argument one is an instance of: ");
        bElement.appendChild(arg1IsasLabelTextNode);
        for (int i = 0; i < arg1Isas.size(); i++) {
            CycConstant arg1Isa = (CycConstant)arg1Isas.get(i);
            HTMLAnchorElement arg1IsaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            arg1IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg1Isa.cyclify());
            parentElement.appendChild(arg1IsaAnchorElement);
            Node arg1IsaTextNode = htmlDocument.createTextNode(arg1Isa.cyclify());
            arg1IsaAnchorElement.appendChild(arg1IsaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates HTML nodes for arg2Isa links.
     *
     * @@param cycConstant the CycConstant for which arg2Isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createArg2IsaNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList arg2Isas = filterSelectedConstants(cycAccess.getArg2Isas(cycConstant));
        if (verbosity > 4)
            Log.current.println("arg2Isas " + arg2Isas);
        CycList tempList = new CycList();
        for (int i = 0; i < arg2Isas.size(); i++) {
            CycConstant arg2Isa = (CycConstant) arg2Isas.get(i);
            if (selectedCycForts.contains(arg2Isa))
                tempList.add(arg2Isa);
        }
        arg2Isas = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, arg2Isas " + arg2Isas);
        if (arg2Isas.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node arg2IsasLabelTextNode = htmlDocument.createTextNode("argument two is an instance of: ");
        bElement.appendChild(arg2IsasLabelTextNode);
        for (int i = 0; i < arg2Isas.size(); i++) {
            CycConstant arg2Isa = (CycConstant)arg2Isas.get(i);
            HTMLAnchorElement arg2IsaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            arg2IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg2Isa.cyclify());
            parentElement.appendChild(arg2IsaAnchorElement);
            Node arg2IsaTextNode = htmlDocument.createTextNode(arg2Isa.cyclify());
            arg2IsaAnchorElement.appendChild(arg2IsaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates HTML nodes for arg3Isa links.
     *
     * @@param cycConstant the CycConstant for which arg3Isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createArg3IsaNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList arg3Isas = filterSelectedConstants(cycAccess.getArg3Isas(cycConstant));
        if (verbosity > 4)
            Log.current.println("arg3Isas " + arg3Isas);
        CycList tempList = new CycList();
        for (int i = 0; i < arg3Isas.size(); i++) {
            CycConstant arg3Isa = (CycConstant) arg3Isas.get(i);
            if (selectedCycForts.contains(arg3Isa))
                tempList.add(arg3Isa);
        }
        arg3Isas = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, arg3Isas " + arg3Isas);
        if (arg3Isas.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node arg3IsasLabelTextNode = htmlDocument.createTextNode("argument three is an instance of: ");
        bElement.appendChild(arg3IsasLabelTextNode);
        for (int i = 0; i < arg3Isas.size(); i++) {
            CycConstant arg3Isa = (CycConstant)arg3Isas.get(i);
            HTMLAnchorElement arg3IsaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            arg3IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg3Isa.cyclify());
            parentElement.appendChild(arg3IsaAnchorElement);
            Node arg3IsaTextNode = htmlDocument.createTextNode(arg3Isa.cyclify());
            arg3IsaAnchorElement.appendChild(arg3IsaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates HTML nodes for arg4Isa links.
     *
     * @@param cycConstant the CycConstant for which arg4Isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createArg4IsaNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList arg4Isas = filterSelectedConstants(cycAccess.getArg4Isas(cycConstant));
        if (verbosity > 4)
            Log.current.println("arg4Isas " + arg4Isas);
        CycList tempList = new CycList();
        for (int i = 0; i < arg4Isas.size(); i++) {
            CycConstant arg4Isa = (CycConstant) arg4Isas.get(i);
            if (selectedCycForts.contains(arg4Isa))
                tempList.add(arg4Isa);
        }
        arg4Isas = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, arg4Isas " + arg4Isas);
        if (arg4Isas.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node arg4IsasLabelTextNode = htmlDocument.createTextNode("argument four is an instance of: ");
        bElement.appendChild(arg4IsasLabelTextNode);
        for (int i = 0; i < arg4Isas.size(); i++) {
            CycConstant arg4Isa = (CycConstant)arg4Isas.get(i);
            HTMLAnchorElement arg4IsaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            arg4IsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + arg4Isa.cyclify());
            parentElement.appendChild(arg4IsaAnchorElement);
            Node arg4IsaTextNode = htmlDocument.createTextNode(arg4Isa.cyclify());
            arg4IsaAnchorElement.appendChild(arg4IsaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates HTML nodes for resultIsa links.
     *
     * @@param cycConstant the CycConstant for which resultIsa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createResultIsaNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList resultIsas = filterSelectedConstants(cycAccess.getResultIsas(cycConstant));
        if (verbosity > 4)
            Log.current.println("resultIsas " + resultIsas);
        CycList tempList = new CycList();
        for (int i = 0; i < resultIsas.size(); i++) {
            CycConstant resultIsa = (CycConstant) resultIsas.get(i);
            if (selectedCycForts.contains(resultIsa))
                tempList.add(resultIsa);
        }
        resultIsas = tempList;
        if (verbosity > 4)
            Log.current.println("after filtering, resultIsas " + resultIsas);
        if (resultIsas.size() == 0)
            return;
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node resultIsasLabelTextNode = htmlDocument.createTextNode("result is an instance of: ");
        bElement.appendChild(resultIsasLabelTextNode);
        for (int i = 0; i < resultIsas.size(); i++) {
            CycConstant resultIsa = (CycConstant)resultIsas.get(i);
            HTMLAnchorElement resultIsaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            resultIsaAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + resultIsa.cyclify());
            parentElement.appendChild(resultIsaAnchorElement);
            Node resultIsaTextNode = htmlDocument.createTextNode(resultIsa.cyclify());
            resultIsaAnchorElement.appendChild(resultIsaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Creates an HTML individual node for a single Cyc individual.
     *
     * @@parameter cycConstant the Cyc individual from which the HTML individual node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIndividualNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        HTMLAnchorElement individualAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        individualAnchorElement.setHref("##$Individual");
        parentElement.appendChild(individualAnchorElement);
        Node individualTextNode = htmlDocument.createTextNode("#$Individual");
        individualAnchorElement.appendChild(individualTextNode);
    }

    /**
     * Creates an HTML node for a single Cyc collection.
     *
     * @@parameter cycConstant the Cyc collection from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCollectionNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        createGenlNodes(cycConstant, parentElement);
    }

    /**
     * Creates hierarchy HTML page.
     *
     * @@param rootTerm the root term of the hierarchy tree
     */
    protected void createHierarchyPage (CycFort rootTerm) throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for hierarchy page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology hierarchy for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        previouslyExpandedTerms = new HashSet();
        createHierarchyNodes(rootTerm, 0);
        serialize(htmlDocument, exportedHierarchyOutputPath);
    }

    /**
     * Recursively creates hierarchy nodes for the given term and its spec collection terms.
     *
     * @@param cycFort the given term for which hierarchy nodes will be created
     * @@param indent the current indent level
     */
    protected void createHierarchyNodes (CycFort cycFort, int indent) throws IOException, CycApiException {
        if (indent > 0) {
            StringBuffer spaces = new StringBuffer(indent);
            StringBuffer nonBreakingSpaces = new StringBuffer(indent);
            for (int i = 0; i < indent; i++) {
                spaces.append(' ');
                nonBreakingSpaces.append("&nbsp;");
            }
            Node spacesText = htmlDocument.createTextNode(nonBreakingSpaces.toString());
            htmlBodyElement.appendChild(spacesText);
            if (verbosity > 2)
                Log.current.println(spaces.toString() + cycFort);
        }
        else {
            if (verbosity > 2)
                Log.current.println(cycFort.toString());
        }
        HTMLAnchorElement vocabularyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        vocabularyAnchorElement.setHref("./" + exportedVocabularyOutputPath + "./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
        htmlBodyElement.appendChild(vocabularyAnchorElement);
        Node hierarchyTermTextNode = htmlDocument.createTextNode(cycFort.cyclify());
        vocabularyAnchorElement.appendChild(hierarchyTermTextNode);
        String generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycFort);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node generatedPhraseTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;" + generatedPhrase + "");
        htmlBodyElement.appendChild(generatedPhraseTextNode);
        CycList specs = cycAccess.getSpecs(cycFort);
        specs = filterSelectedConstants(specs);
        if (specs.size() == 0) {
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
        }
        else if (previouslyExpandedTerms.contains(cycFort)) {
            Node previouslyExpandedTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;... see above");
            htmlBodyElement.appendChild(previouslyExpandedTextNode);
            lineBreak(htmlBodyElement);
        }
        else {
            previouslyExpandedTerms.add(cycFort);
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
            for (int i = 0; i < specs.size(); i++)
                createHierarchyNodes((CycFort)specs.get(i), indent + 2);
        }
    }

    /**
     * Serializes the given HTML document to the given path.
     *
     * @@param htmlDocument the HTML document model for serialization
     * @@param outputPath the file name of the serialized HTML document
     */
    protected void serialize (HTMLDocument htmlDocument, String outputPath) throws IOException {
        if (verbosity > 2)
            Log.current.println("Writing HTML output to " + outputPath);
        OutputFormat outputFormat = new OutputFormat(htmlDocument, "UTF-8", true);
        BufferedWriter htmlOut = new BufferedWriter(new FileWriter(outputPath));
        XHTMLSerializer xhtmlSerializer = new XHTMLSerializer(htmlOut, outputFormat);
        xhtmlSerializer.asDOMSerializer();
        xhtmlSerializer.serialize(htmlDocument);
        htmlOut.close();
    }

    /**
     * Removes unselected terms from the given list.
     *
     * @@parameter constants the given list of constants which is to be filtered
     * @@return the filtered list
     */
    protected CycList filterSelectedConstants (CycList constants) {
        if (constants.size() == 0)
            return  constants;
        CycList result = new CycList();
        for (int i = 0; i < constants.size(); i++) {
            Object object = constants.get(i);
            if (selectedCycForts.contains(object))
                result.add(object);
            else if (verbosity > 4)
                Log.current.println(" dropping " + object);
        }
        return  result;
    }

    /**
     * Gather the updward closure of the selected CycForts with regard to isas and genls
     * for collection terms, and with regard to isas and genlPreds for predicate terms.
     *
     * @@parameter the selected CycForts
     * @@return the updward closure of the selected CycForts with regard to genls
     * for collection terms, and with regard to genlPreds for predicate terms
     */
    protected CycList gatherUpwardClosure (CycList selectedCycForts)
        throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2) {
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
            Collections.sort(selectedCycForts);
        }
        CycList upwardClosure = new CycList();
        // Redundant HashSets for efficient contains() method below.
        HashSet selectedCycFortsSet = new HashSet(selectedCycForts);
        HashSet upwardClosureSet = new HashSet(selectedCycForts.size());
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (cycAccess.isCollection(cycFort)) {
                CycList isasGenls = new CycList();
                isasGenls.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenls.addAllNew(cycAccess.getAllGenls(cycFort));

                if (cycFort instanceof CycNart) {
                    CycList allGenls = cycAccess.getAllGenls(cycFort);
                }

                for (int j = 0; j < isasGenls.size(); j++) {
                    CycFort isaGenl = null;
                    try {
                        isaGenl = (CycFort) isasGenls.get(j);
                    } catch (ClassCastException e) {
                        if (verbosity > 3)
                        Log.current.println("***** term: " + cycFort +
                                            " invalid genls " + isasGenls.get(j) +
                                            " (" + isasGenls.get(j).getClass() + ")");
                        continue;
                    }
                    if ((!upwardClosureSet.contains(isaGenl)) &&
                        (!selectedCycFortsSet.contains(isaGenl)) &&
                        isEligibleForUpwardClosureInclusion(isaGenl)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genl " + isaGenl);
                        upwardClosure.add(isaGenl);
                        upwardClosureSet.add(isaGenl);
                    }
                }
            }
            else if ((cycFort instanceof CycConstant) && (cycAccess.isPredicate((CycConstant)cycFort))) {
                CycList isasGenlPreds = new CycList();
                isasGenlPreds.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenlPreds.addAllNew(cycAccess.getAllGenlPreds((CycConstant)cycFort));
                for (int j = 0; j < isasGenlPreds.size(); j++) {
                    CycFort isaGenlPred = (CycFort)isasGenlPreds.get(j);
                    if ((!upwardClosureSet.contains(isaGenlPred)) &&
                        (!selectedCycFortsSet.contains(isaGenlPred)) &&
                        isEligibleForUpwardClosureInclusion(isaGenlPred)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genlPred " + isaGenlPred);
                        upwardClosure.add(isaGenlPred);
                        upwardClosureSet.add(isaGenlPred);
                    }
                }
            }
        }
        return  upwardClosure;
    }

    /**
     * Returns true if the given term is eligible for incusion in the upward closure.
     *
     * @@param cycFort the given term
     * @@return true if the given term is eligible for incusion in the upward closure
     */
    protected boolean isEligibleForUpwardClosureInclusion (CycFort cycFort)
        throws UnknownHostException, IOException, CycApiException {
        for (int i = 0; i < upwardClosureKbSubsetCollections.size(); i++) {
            CycFort collection = (CycFort) upwardClosureKbSubsetCollections.get(i);
            if (cycAccess.isa(cycFort, collection))
                return true;
        }
        return false;
    }

    /**
     * Creates categorized vocabulary HTML pages.
     */
    protected void createCategorizedVocabularies ()
        throws UnknownHostException, IOException, CycApiException {
        for (int i = 0; i < categories.size(); i++) {
            Category category = (Category) categories.get(i);
            createCategorizedVocabulary(category.title,
                                        category.queryString,
                                        category.mt,
                                        category.outputPath);
        }
    }

    /**
     * Creates the given categorized vocabulary HTML page.
     *
     * @@param title the title of the categorized vocabulary HTML page
     * @@param queryString the query string which finds the terms in the
     * category
     * @@param mt the mt in which the query is asked
     * @@param outputPath the name of the output HTML page
     */
    protected void createCategorizedVocabulary (String title,
                                                String queryString,
                                                CycConstant mt,
                                                String outputPath)
        throws UnknownHostException, IOException, CycApiException {
        CycList categoryTerms = askQueryString(queryString, mt);
        if (categoryTerms.size() == 0) {
            if (verbosity > 2)
                Log.current.println("No terms for query:\n" + queryString + "\n");
            return;
        }
        if (verbosity > 2)
            Log.current.println("Building HTML model for category: " + title);
        htmlDocument = new HTMLDocumentImpl();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        for (int i = 0; i < categoryTerms.size(); i++) {
            CycFort cycFort = (CycFort) categoryTerms.get(i);
            if (verbosity > 2)
                Log.current.print(cycFort + "  ");
            if (cycAccess.isCollection(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Collection");
            }
            else if (cycAccess.isPredicate(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Predicate");
            }
            else if (cycAccess.isIndividual(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Individual");
            }
            else {
                if (verbosity > 2)
                    Log.current.println("other");
                continue;
            }
            if (cycFort instanceof CycConstant)
                createCycConstantNode((CycConstant)cycFort);
            else
                createCycNartNode((CycNart)cycFort);
        }
        serialize(htmlDocument, outputPath);
    }

    /**
     * Adds all categories to the HTML export.
     */
    protected void addAllCategories ()
        throws CycApiException, IOException , UnknownHostException {
        addEeldFY03CoreOntology();
        addAllIETRef();
        addAllSyracuseRef();
        addAllSraRef();
        addAllVeridianRef();
        addAllSchemaMappingTypes();
        addScriptRepresentationVocabulary();
        addSemanticConstraintVocabulary();
        addAllPersonTypes();
        addAllOrganizationTypes();
        addAllEventTypes();
        addAllMaterials();
        addAllWeaponTypes();
        addAllRelations();
        addAllBinaryPredicates();
        addAllActorSlots();
        addAllPartonomicPredicates();
        addAllSpecializationsOfAffiliation();
        addAllSpecializationsOfVestedInterest();
        addAllDenotingFunctions();
        addAllTemporalRelations();
        addAllScriptedEventTypes();
        addEeldCoreOntology();
        addPublicSharedOntology();
    }


    /**
     * Categorizes all ontology constants directly referenced in the IET Mapping.
     */
    protected void addAllIETRef ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "IET Synthetic Data set constants";
        category.outputPath = "all-iet-ref.html";
        category.queryString =
            "(#$isa ?TERM #$EELDSyntheticDataConstant)\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all ontology constants directly referenced in the Syracuse Mapping.
     */
    protected void addAllSyracuseRef ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Constants corresponding to terms in the Syracuse ontology";
        category.outputPath = "all-syracuse-ref.html";
        category.queryString =
            "(#$thereExists ?STRING\n" +
            " (#$or\n" +
            "  (#$synonymousExternalConcept ?TERM #$SyracuseOntology ?STRING)\n" +
            "  (#$overlappingExternalConcept ?TERM #$SyracuseOntology ?STRING)))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all constants directly reference in the SRA NetOwl Mapping.
     */
    protected void addAllSraRef ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Constants corresponding to terms in the NetOwl template extraction ontology.";
        category.outputPath = "all-sra-ref.html";
        category.queryString =
            "(#$thereExists ?STRING\n" +
            " (#$or\n" +
            "  (#$synonymousExternalConcept\n" +
            "      ?TERM #$SRATemplateExtractionOntology ?STRING)\n" +
            "  (#$overlappingExternalConcept\n" +
            "      ?TERM #$SRATemplateExtractionOntology ?STRING)))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all ontology constants directly referenced in the Veridian Mapping.
     */
    protected void addAllVeridianRef ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Constants corresponding to terms referenced in the Veridian schema specification.";
        category.outputPath = "all-veridian-ref.html";
        category.queryString =
            "(#$thereExists ?PROP\n" +
            "  (#$and\n" +
            "    (#$isa ?TERM #$Collection)\n" +
            "    (#$unknownSentence\n" +
            "      (#$isa ?TERM #$SKSIConstant))\n" +
            "    (#$unknownSentence\n" +
            "      (#$isa ?TERM #$IndexicalConcept))\n" +
            "    (#$different ?TERM #$meaningSentenceOfSchema)\n" +
            "    (#$ist-Asserted #$VeridianMappingMt ?PROP)\n" +
            "    (#$assertedTermSentences ?TERM ?PROP)))";
        category.mt = cycAccess.getKnownConstantByName("#$VeridianMappingMt");
    }

    /**
     * Categorizes all schema mapping types.
     */
    protected void addAllSchemaMappingTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Terms used to specify the interpretation of the Veridian schema.";
        category.outputPath = "all-schema-mapping-types.html";
        category.queryString =
            "(#$and \n" +
            "  (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "  (#$isa ?TERM #$SKSIConstant))\n";
        category.mt = cycAccess.getKnownConstantByName("#$SKSIMt");
    }

    /**
     * Categorizes script representation vocabulary.
     */
    protected void addScriptRepresentationVocabulary ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Relations used in representing scripts.";
        category.outputPath = "script-representation-vocabulary.html";
        category.queryString =
            "(#$and \n" +
            "  (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "  (#$isa ?TERM #$ScriptRelation))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes semantic constraint vocabulary.
     */
    protected void addSemanticConstraintVocabulary ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Relations used to specify semantic constraints.";
        category.outputPath = "semantic-constraint-vocabulary.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$OpenCycDefinitionalPredicate))";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all person types.
     */
    protected void addAllPersonTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Classes of persons in the ontology release.";
        category.outputPath = "all-person-types.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genls ?TERM #$Person))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all organization types.
     */
    protected void addAllOrganizationTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Classes of organizations in the ontology release.";
        category.outputPath = "all-organization-types.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genls ?TERM #$Organization))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all event types.
     */
    protected void addAllEventTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Types of event.";
        category.outputPath = "all-event-types.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genls ?TERM #$Event))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all 'materials'.
     */
    protected void addAllMaterials ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Types of material.";
        category.outputPath = "all-materials.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$ExistingStuffType))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all weapon types.
     */
    protected void addAllWeaponTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Types of weapon.";
        category.outputPath = "all-weapon-types.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genls ?TERM #$Weapon))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all relations.
     */
    protected void addAllRelations ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All relations in the ontology.";
        category.outputPath = "all-relations.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$Relation))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all binary predicates.
     */
    protected void addAllBinaryPredicates ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "all binary predicates.";
        category.outputPath = "all-binary-predicates.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$BinaryPredicate))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all actorslots.
     */
    protected void addAllActorSlots ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All of the binary role relations obtaining between entities and events in the ontology.";
        category.outputPath = "all-actor-slots.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$ActorSlot))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all temporal relations.
     */
    protected void addAllTemporalRelations ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All of the temporal ordering relations in the ontology.";
        category.outputPath = "all-temporal-relations.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$ComplexTemporalPredicate))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all partonomic predicates.
     */
    protected void addAllPartonomicPredicates ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All of the part-whole relations in the ontology.";
        category.outputPath = "all-partonomic-predicates.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$PartPredicate))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all specializations of affiliation.
     */
    protected void addAllSpecializationsOfAffiliation ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All of the specializations of the affiliatedWith relation.";
        category.outputPath = "all-specializations-of-affiliation.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genlPreds ?TERM #$affiliatedWith))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all specializations of vested interest.
     */
    protected void addAllSpecializationsOfVestedInterest ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All of the specializations of the vestedInterest relation.";
        category.outputPath = "all-specializations-of-vested-interest.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$genlPreds ?TERM #$vestedInterest))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all denoting functions.
     */
    protected void addAllDenotingFunctions ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All denoting functions.";
        category.outputPath = "all-denoting-functions.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$Function-Denotational))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }


    /**
     * Categorizes all scripted event types.
     */
    protected void addAllScriptedEventTypes ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "All scripted event types.";
        category.outputPath = "all-scripted-event-types.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$ScriptedEventType))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }


    /**
     * Categorizes the original EELD 'core' ontology.
     */
    protected void addEeldCoreOntology ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "EELD Core Ontology";
        category.outputPath = "all-core.html";
        category.queryString =
            "(#$isa ?TERM #$EELDSharedOntologyCoreConstant)";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes all public shared ontology constants.
     */
    protected void addPublicSharedOntology ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "Public Shared Ontology";
        category.outputPath = "all-public-shared.html";
        category.queryString =
            "(#$and\n" +
            " (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            " (#$isa ?TERM #$ProposedOrPublicConstant))\n";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes the FY03 EELD 'core' ontology.
     */
    protected void addEeldFY03CoreOntology ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "FY03 EELD Core Ontology";
        category.outputPath = "all-fy03-core.html";
        category.queryString =
            "(#$isa ?TERM #$EELD-FY03CoreOntologyConstant)";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Categorizes the original EELD 'core' ontology.
     */
    protected void askEeldCoreOntology ()
        throws CycApiException, IOException , UnknownHostException {
        Category category = new Category();
        categories.add(category);
        category.title = "EELD Core Ontology";
        category.outputPath = "all-core.html";
        category.queryString =
            "(#$isa ?TERM #$EELDSharedOntologyCoreConstant)";
        category.mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
    }

    /**
     * Returns the sorted terms resulting from asking the given query string.
     *
     * @@param queryString the query, as a string
     * @@param mt the mt in which the query is asked
     * @@return the sorted terms resulting from asking the given query string
     */
    protected CycList askQueryString (String queryString, CycConstant mt)
        throws CycApiException, IOException , UnknownHostException {
        CycList query = cycAccess.makeCycList(queryString);
        CycVariable variable = CycObjectFactory.makeCycVariable("?TERM");
        CycList answer = cycAccess.askWithVariable(query, variable, mt);
        if (verbosity > 2) {
            Log.current.println("query:\n" + queryString);
            Log.current.println("number of terms " + answer.size());
        }
        // Remove nauts which are returned as CycLists.
        CycList answerTemp = new CycList();
        for (int i = 0; i < answer.size(); i++) {
            Object obj = answer.get(i);
            if (obj instanceof CycFort)
                answerTemp.add(obj);
            else if (verbosity > 2)
                Log.current.println("Dropping non fort from answer\n" + obj.toString());
        }
        answer = answerTemp;
        Collections.sort(answer);
        return answer;
    }

    /**
     * Provides a container for term category information used to make
     * vocabulary category HTML pages.
     */
    public class Category {
        /**
         * The query string used to make this categorized vocabulary page.
d716 1020
a1735 16
        public String queryString;

        /**
         * The mt in which the query is asked.
         */
        public CycConstant mt;

        /**
         * The file name used to output this categorized vocabulary page.
         */
        public String outputPath;

        /**
         * The title of this categorized vocabulary page.
         */
        public String title;
d1737 2
a1739 7







@


1.28
log
@Updates prior to release 0.7.0
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.27 2002/07/23 20:17:22 stephenreed Exp $
d274 10
a283 7

            exportHtml.port = 3620;
            exportHtml.cycAccess =
                new CycAccess(exportHtml.hostname,
                              exportHtml.port,
                              CycConnection.DEFAULT_COMMUNICATION_MODE,
                              CycAccess.DEFAULT_CONNECTION);
d291 2
d411 1
a411 1
        if (exportCommand == ExportDaml.EXPORT_KB_SUBSET) {
d417 1
a417 1
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
d425 1
a425 1
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_BELOW_TERM) {
d1634 1
d2035 14
@


1.27
log
@Handled embedded quotes within strings sent to Cyc.  This patch makes the ascii
and cfasl (binary) api commands behave the same.  Added unit test cases.
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.26 2002/05/13 17:39:06 stephenreed Exp $
a207 1
    //protected int port = 3620;
d274 2
a1643 1
        addAllTemporalRelations();
d1648 2
d1738 3
a1740 1
            "(#$isa ?TERM #$SKSIConstant)\n";
d1754 3
a1756 1
            "(#$isa ?TERM #$SKSIConstant)\n";
d1916 1
a1916 1
            " (#$isa ?TERM #$ComplexTemporalRelation))\n";
d1981 17
@


1.26
log
@Enhanced HTML vocabulary export for the EELD project.
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.25 2002/02/20 22:44:59 stephenreed Exp $
d303 1
d1628 1
a1628 1
        addAllHorusRef();
d1654 1
a1654 1
     * Categorizes all ontology constants directly referenced in the Horus Ontology.
d1656 1
a1656 1
    protected void addAllHorusRef ()
d1660 2
a1661 2
        category.title = "Constants corresponding to terms in the Horus ontology";
        category.outputPath = "all-horus-ref.html";
d1663 1
a1663 1
            " (#$isa ?TERM #$HorusConstant)\n";
@


1.25
log
@Adding RKF lexicon accessors to CycAccess. Added titles to the HTML export category pages.
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.24 2002/02/19 19:52:26 stephenreed Exp $
d208 1
d274 11
d402 2
a403 1
        cycAccess = new CycAccess(hostname, port, CycConnection.DEFAULT_COMMUNICATION_MODE, CycAccess.DEFAULT_CONNECTION);
d507 1
a507 1
            htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
d548 1
a548 1
                htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
d561 2
d914 2
a915 1
        if (collection.equals(cycAccess.getKnownConstantByName("CycSecureConstant"))) {
d1001 1
a1001 1
                Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
d1006 1
a1006 1
            Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
d1053 38
d1130 195
a1349 10
     * Creates an HTML node for a single Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createPredicateNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        createGenlPredsNodes(cycConstant, parentElement);
    }

    /**
d1557 1
d1568 1
d1573 1
d1576 1
a1576 1
        CycList categoryTerms = askQueryString(queryString);
d1625 3
a1627 2
    protected void addAllCategories () {
        addAllVeridianRef();
d1630 19
a1648 14
        addAllPublicIsas();
        addAllRoleIsas();
        addAllPredicateIsas();
        addAllFunctionIsas();
        addAllEventSpecs();
        addAllOrgSpecs();
        addAllOcctypeSpecs();
        addAllPersonSpecs();
        addAllPlaceIsas();
        addAllPlaceSpecs();
        addAllWeaponSpecs();
        addAllCwTopic();
        addAllScriptTopic();
        askEeldCoreOntology();
d1653 1
a1653 1
     * Categorizes all ontology constants directly referenced in the Veridian Mapping.
d1655 2
a1656 1
    protected void addAllVeridianRef () {
d1659 2
a1660 2
        category.title = "All release constants referenced in the current Veridian ontology mapping";
        category.outputPath = "all-veridian-ref.html";
d1662 2
a1663 7
            " (#$thereExists ?SOMETHING\n" +
            "  (#$and\n" +
            "    (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "    (#$or\n" +
            "      (#$synonymousExternalConcept ?TERM #$VeridianOntology ?SOMETHING) \n" +
            "      (#$overlappingExternalConcept ?TERM #$VeridianOntology ?SOMETHING)\n" +
            "      (#$synonymousListFields ?TERM #$VeridianOntology ?SOMETHING))))\n";
d1669 2
a1670 1
    protected void addAllSyracuseRef () {
d1673 1
a1673 1
        category.title = "All release constants referenced in the current Syracuse ontology mapping";
d1676 5
a1680 6
            " (#$thereExists ?SOMETHING\n" +
            "  (#$and\n" +
            "    (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "    (#$or\n" +
            "      (#$synonymousExternalConcept ?TERM #$SyracuseOntology ?SOMETHING)\n" +
            "      (#$overlappingExternalConcept ?TERM #$SyracuseOntology ?SOMETHING))))\n";
d1686 2
a1687 1
    protected void addAllSraRef () {
d1690 1
a1690 1
        category.title = "All release constants referenced in the currant SRA ontology mapping";
d1693 20
a1712 1
            " (#$thereExists ?SOMETHING\n" +
d1714 9
a1722 6
            "    (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "    (#$or\n" +
            "      (#$synonymousExternalConcept \n" +
            "         ?TERM #$SRATemplateExtractionOntology ?SOMETHING)\n" +
            "      (#$overlappingExternalConcept\n" +
            "         ?TERM #$SRATemplateExtractionOntology ?SOMETHING))))\n";
d1726 1
a1726 1
     * Categorizes all Cyc public constants in the shared ontology.
d1728 2
a1729 1
    protected void addAllPublicIsas () {
d1732 2
a1733 2
        category.title = "All Cycorp public release constants in the shared ontology";
        category.outputPath = "all-public-isas.html";
d1735 2
a1736 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$PublicConstant))\n";
d1740 1
a1740 1
     * Categorizes all Roles.
d1742 2
a1743 1
    protected void addAllRoleIsas () {
d1746 2
a1747 2
        category.title = "Roles";
        category.outputPath = "all-role-isas.html";
d1749 2
a1750 3
            " (#$and \n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$Role))\n";
d1754 1
a1754 1
     * Categorizes all Predicates.
d1756 2
a1757 1
    protected void addAllPredicateIsas () {
d1760 2
a1761 2
        category.title = "Predicates";
        category.outputPath = "all-predicate-isas.html";
d1763 4
a1766 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$Predicate))\n";
d1770 1
a1770 1
     * Categorizes all Functions.
d1772 2
a1773 1
    protected void addAllFunctionIsas () {
d1776 2
a1777 2
        category.title = "Functions";
        category.outputPath = "all-function-isas.html";
d1779 4
a1782 3
            " (#$and\n" +
            "  (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$Function-Denotational))\n";
d1786 1
a1786 1
     * Categorizes all Event Types.
d1788 2
a1789 1
    protected void addAllEventSpecs () {
d1792 2
a1793 2
        category.title = "Event types";
        category.outputPath = "all-event-specs.html";
d1795 4
a1798 3
            " (#$and \n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$genls ?TERM #$Event))\n";
d1802 1
a1802 1
     * Categorizes all Organization Types.
d1804 2
a1805 1
    protected void addAllOrgSpecs () {
d1808 2
a1809 2
        category.title = "Organization types";
        category.outputPath = "all-org-specs.html";
d1811 4
a1814 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$genls ?TERM #$Organization))\n";
d1818 1
a1818 1
     * Categorizes all Occupation Types.
d1820 2
a1821 1
    protected void addAllOcctypeSpecs () {
d1824 2
a1825 2
        category.title = "Occupation types";
        category.outputPath = "all-occtype-specs.html";
d1827 4
a1830 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$PersonTypeByOccupation))\n";
d1834 1
a1834 1
     * Categorizes all Kinds of Person.
d1836 2
a1837 1
    protected void addAllPersonSpecs () {
d1840 2
a1841 2
        category.title = "Person types";
        category.outputPath = "all-person-specs.html";
d1843 4
a1846 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$genls ?TERM #$Person))\n";
d1850 1
a1850 1
     * Categorizes all Places (GeographicalRegions).
d1852 2
a1853 1
    protected void addAllPlaceIsas () {
d1856 2
a1857 2
        category.title = "Place types";
        category.outputPath = "all-place-isas.html";
d1859 4
a1862 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$isa ?TERM #$GeographicalRegion))\n";
d1866 1
a1866 1
     * Categorizes all Location Types.
d1868 2
a1869 1
    protected void addAllPlaceSpecs () {
d1872 2
a1873 2
        category.title = "Location types";
        category.outputPath = "all-place-specs.html";
d1875 4
a1878 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$genls ?TERM #$Place))\n";
d1882 1
a1882 1
     * Categorizes all Weapon Types.
d1884 2
a1885 1
    protected void addAllWeaponSpecs () {
d1888 2
a1889 2
        category.title = "Weapon types";
        category.outputPath = "all-weapon-specs.html";
d1891 4
a1894 3
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$genls ?TERM #$Weapon))\n";
d1898 1
a1898 1
     * Categorizes all terms relating to the topic of Conceptual Works.
d1900 2
a1901 1
    protected void addAllCwTopic () {
d1904 2
a1905 2
        category.title = "Conceptual Works";
        category.outputPath = "all-cw-topic.html";
d1907 4
a1910 9
            " (#$and\n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)  \n" +
            "   (#$or    \n" +
            "     (#$genls ?TERM #$ConceptualWork)\n" +
            "     (#$thereExists ?ARG-COL\n" +
            "        (#$thereExists ?N\n" +
            "          (#$and\n" +
            "            (#$argIsa ?TERM ?N ?ARG-COL)\n" +
            "            (#$genls ?ARG-COL #$ConceptualWork))))))\n";
d1914 1
a1914 1
     * Categorizes all terms relating to the topic of Scripts.
d1916 34
a1949 1
    protected void addAllScriptTopic () {
d1952 2
a1953 2
        category.title = "Script related terms";
        category.outputPath = "all-script-topic.html";
d1955 4
a1958 5
            " (#$and \n" +
            "   (#$isa ?TERM #$EELDSharedOntologyConstant)\n" +
            "   (#$or\n" +
            "	  (#$isa ?TERM #$ScriptRelation)\n" +
            "	  (#$isa ?TERM #$ScriptedEventType)))\n";
d1962 17
d1981 2
a1982 1
    protected void askEeldCoreOntology () {
d1989 31
d2025 2
d2029 1
a2029 1
    protected CycList askQueryString (String queryString)
a2032 1
        CycFort mt = cycAccess.getKnownConstantByName("#$EELDOntologyAlignmentSpindleCollectorMt");
d2038 10
d2061 5
@


1.24
log
@Changed log file name to Cyc.log .  Added category pages to the HTML vocabulary export.
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.23 2002/02/10 22:17:07 stephenreed Exp $
a225 5
    /**
     * List of the query strings used to make categorized vocabulary
     * pages.  The sequence aligns with the categoryPageOutputPaths array.
     */
    public ArrayList categoryQueryStrings = new ArrayList();
d228 1
a228 2
     * List of the file names used to output categorized vocabulary
     * pages.  The sequence aligns with the categoryQueryStrings array.
d230 1
a230 1
    public ArrayList categoryPageOutputPaths = new ArrayList();
d371 1
a371 1
        if (categoryQueryStrings.size() > 0)
d937 5
d945 2
d962 5
d1314 5
a1318 4
        for (int i = 0; i < categoryQueryStrings.size(); i++) {
            String queryString = (String) categoryQueryStrings.get(i);
            String outputPath = (String) categoryPageOutputPaths.get(i);
            createCategorizedVocabulary(queryString, outputPath);
d1325 1
d1330 3
a1332 1
    protected void createCategorizedVocabulary (String queryString, String outputPath)
d1341 1
a1341 1
            Log.current.println("Building HTML model for category page " + outputPath);
a1342 1
        String title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
d1408 5
a1412 3
        String outputPath = "all-veridian-ref.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1419 1
        categoryQueryStrings.add(queryString);
d1426 5
a1430 3
        String outputPath = "all-syracuse-ref.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1436 1
        categoryQueryStrings.add(queryString);
d1443 5
a1447 3
        String outputPath = "all-sra-ref.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1455 1
        categoryQueryStrings.add(queryString);
d1462 5
a1466 3
        String outputPath = "all-public-isas.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1469 1
        categoryQueryStrings.add(queryString);
d1476 5
a1480 3
        String outputPath = "all-role-isas.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1483 1
        categoryQueryStrings.add(queryString);
d1490 5
a1494 3
        String outputPath = "all-predicate-isas.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1497 1
        categoryQueryStrings.add(queryString);
d1504 5
a1508 3
        String outputPath = "all-function-isas.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1511 1
        categoryQueryStrings.add(queryString);
d1518 5
a1522 3
        String outputPath = "all-event-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1525 1
        categoryQueryStrings.add(queryString);
d1532 5
a1536 3
        String outputPath = "all-org-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1539 1
        categoryQueryStrings.add(queryString);
d1546 5
a1550 3
        String outputPath = "all-occtype-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1553 1
        categoryQueryStrings.add(queryString);
d1560 5
a1564 3
        String outputPath = "all-person-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1567 1
        categoryQueryStrings.add(queryString);
d1574 5
a1578 3
        String outputPath = "all-place-isas.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1581 1
        categoryQueryStrings.add(queryString);
d1588 5
a1592 3
        String outputPath = "all-place-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1595 1
        categoryQueryStrings.add(queryString);
d1602 5
a1606 3
        String outputPath = "all-weapon-specs.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1609 1
        categoryQueryStrings.add(queryString);
d1616 5
a1620 3
        String outputPath = "all-cw-topic.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1629 1
        categoryQueryStrings.add(queryString);
d1636 5
a1640 3
        String outputPath = "all-script-topic.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1645 1
        categoryQueryStrings.add(queryString);
d1652 5
a1656 3
        String outputPath = "all-core.html";
        categoryPageOutputPaths.add(outputPath);
        String queryString =
a1657 1
        categoryQueryStrings.add(queryString);
d1677 21
@


1.23
log
@Initial check in of chat for OpenCyc
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.22 2002/02/05 04:40:56 stephenreed Exp $
d227 12
d303 1
d377 2
d471 1
a471 1
                createCycConstantNode((CycConstant)cycFort);
d473 1
a473 1
                createCycNartNode((CycNart)cycFort);
d639 1
a639 1
                cycConstantAnchorElement.setHref("#" + cycConstant.cyclify());
d652 1
a652 1
                cycFortAnchorElement.setHref("#" + cycNart.cyclify());
d761 1
a761 1
                    htmlAnchorElement.setHref("#" + commentConstant.cyclify());
d779 1
a779 1
                        htmlAnchorElement.setHref("#" + commentConstant.cyclify());
d882 1
a882 1
            isaAnchorElement.setHref("#" + isa.cyclify());
d975 1
a975 1
                genlAnchorElement.setHref("#" + genl.cyclify());
d987 1
a987 1
            hierarchyAnchorElement.setHref("./" + exportedHierarchyOutputPath + "#" + cycFort.cyclify());
d1060 1
a1060 1
            genlPredAnchorElement.setHref("#" + genlPred.cyclify());
d1151 1
a1151 1
        vocabularyAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
d1301 350
@


1.22
log
@More hyperlinks inside of CycLists
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.21 2002/02/05 03:58:39 stephenreed Exp $
d82 4
d266 3
d364 2
a365 1
        if (rootTerm != null)
d367 2
a368 1
        else if (includeUpwardClosure)
d826 1
a826 1
        //if (cycFort.toString().equals("AntiSymmetricBinaryPredicate"))
d863 1
a863 1
        createdIsas.removeAll(this.filterFromDirectInstances);
d930 17
a946 2
        genls = filterSelectedConstants(genls);
        genls = specificCollections(genls);
d968 1
a968 1
        if (genls.size() > 0) {
d1061 6
a1066 4
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node individualLabelTextNode = htmlDocument.createTextNode("Individual");
        bElement.appendChild(individualLabelTextNode);
@


1.21
log
@Nart link fix
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.20 2002/02/05 03:02:06 stephenreed Exp $
d592 2
a593 1
     * Creates nodes for rewritten NARTs.  Recursive for the NART components.
d600 18
a617 12
        if (! (object instanceof CycNart)) {
            if (object instanceof CycConstant) {
                CycConstant cycConstant = (CycConstant) object;
                if (selectedCycForts.contains(object)) {
                    HTMLAnchorElement cycConstantAnchorElement =
                        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                    cycConstantAnchorElement.setHref("#" + cycConstant.cyclify());
                    parentElement.appendChild(cycConstantAnchorElement);
                    cycConstantAnchorElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
                }
                else
                    parentElement.appendChild(htmlDocument.createTextNode(cycConstant.cyclify()));
d620 1
a620 1
                parentElement.appendChild(htmlDocument.createTextNode(object.toString()));
d623 23
a645 21
        CycNart cycNart = (CycNart) object;
        if (selectedCycForts.contains(cycNart)) {
            HTMLAnchorElement cycFortAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            cycFortAnchorElement.setHref("#" + cycNart.cyclify());
            parentElement.appendChild(cycFortAnchorElement);
            cycFortAnchorElement.appendChild(htmlDocument.createTextNode("( "));
        }
        else
            parentElement.appendChild(htmlDocument.createTextNode("("));
        CycFort functor = cycNart.getFunctor();
        // recurse for the functor
        processRewrittenNart(functor, parentElement);
        for (int i = 0; i < cycNart.getArguments().size(); i++) {
            Object argument = cycNart.getArguments().get(i);
            parentElement.appendChild(htmlDocument.createTextNode(" "));
            // recurse for each arg
            processRewrittenNart(argument, parentElement);
        }
        Node rightParenTextNode = htmlDocument.createTextNode(")");
        parentElement.appendChild(rightParenTextNode);
d647 4
@


1.20
log
@More tailoring of CycNart hyperlink
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.19 2002/02/05 02:50:38 stephenreed Exp $
a425 1
            //for (int i = 0; i < 20; i++) {
d586 31
a616 1
        Node leftParenTextNode = htmlDocument.createTextNode("( ");
d622 1
a622 1
            cycFortAnchorElement.appendChild(leftParenTextNode);
d625 1
a625 1
            parentElement.appendChild(leftParenTextNode);
d627 2
a628 9
        if (selectedCycForts.contains(functor)) {
            HTMLAnchorElement functorAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            functorAnchorElement.setHref("#" + functor.cyclify());
            parentElement.appendChild(functorAnchorElement);
            functorAnchorElement.appendChild(htmlDocument.createTextNode(functor.cyclify()));
        }
        else
            parentElement.appendChild(htmlDocument.createTextNode(functor.cyclify()));
d632 2
a633 14
            if (argument instanceof CycFort) {
                CycFort argumentCycFort = (CycFort) argument;
                if (selectedCycForts.contains(argumentCycFort)) {
                    HTMLAnchorElement argumentAnchorElement =
                        new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                    argumentAnchorElement.setHref("#" + argumentCycFort.cyclify());
                    parentElement.appendChild(argumentAnchorElement);
                    argumentAnchorElement.appendChild(htmlDocument.createTextNode(argumentCycFort.cyclify()));
                }
                else
                parentElement.appendChild(htmlDocument.createTextNode(argumentCycFort.cyclify()));
            }
            else
                parentElement.appendChild(htmlDocument.createTextNode(argument.toString()));
d637 1
a637 2
        return true;
    }
@


1.19
log
@Modified hyperlinking of rewriten nart terms
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.18 2002/02/05 01:32:48 stephenreed Exp $
d605 2
d608 1
a608 1
            CycFort argument = (CycFort) cycNart.getArguments().get(i);
d610 14
a623 5
            HTMLAnchorElement argumentAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            argumentAnchorElement.setHref("#" + argument.cyclify());
            parentElement.appendChild(argumentAnchorElement);
            argumentAnchorElement.appendChild(htmlDocument.createTextNode(argument.cyclify()));
@


1.18
log
@Fine tuning the rewriteOf phrase
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.17 2002/02/05 00:43:02 stephenreed Exp $
d462 2
a463 1
        HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
d476 2
a477 1
        Node generatedPhraseNode = htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
d581 4
a584 1
        CycFort cycFort = (CycFort) cycForts.get(0);
d587 2
a588 2
        Node cycFortTextNode = htmlDocument.createTextNode(cycFort.cyclify());
        if (selectedCycForts.contains(cycFort)) {
d591 1
a591 1
            cycFortAnchorElement.setHref("#" + cycFort.cyclify());
d593 1
a593 1
            cycFortAnchorElement.appendChild(cycFortTextNode);
d596 20
a615 1
            parentElement.appendChild(cycFortTextNode);
@


1.17
log
@Moved Nart note into blockquoted section
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.16 2002/02/05 00:24:40 stephenreed Exp $
d504 15
a518 11
        processRewriteOf(cycConstant, htmlFontElement);
        String generatedPhrase;
        if (cycAccess.isCollection(cycConstant))
            generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycConstant);
        else
            generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycConstant);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
        Node generatedPhraseNode = htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
        italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
d547 1
d549 1
a549 1
    protected void processRewriteOf(CycConstant cycConstant,
d573 1
a573 1
            return;
d577 1
a577 1
            return;
d592 1
@


1.16
log
@Added NART release note html link
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.15 2002/02/04 22:49:32 stephenreed Exp $
d440 1
a440 1
                    Log.current.print("Individual");
d477 2
a478 1

d482 1
a482 1
        htmlBodyElement.appendChild(natNoteAnchorElement);
a484 3

        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
@


1.15
log
@More tuning of HTML export parms
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.14 2002/02/04 22:00:11 stephenreed Exp $
d82 12
d119 5
d175 4
d277 1
d283 1
d289 1
d295 1
a301 3
            //exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyCandidateConstantGuid);
            //exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyCoreConstantGuid);
            //exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyConstantGuid);
d403 4
d459 2
a460 1
    protected void createCycNartNode (CycNart cycNart) throws UnknownHostException, IOException, CycApiException {
d465 2
a466 1
        HTMLAnchorElement htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
d477 8
d636 2
a637 1
    protected void createCommentNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
d940 11
d958 8
a965 9
            if (selectedCycForts.contains(genlPred)) {
                HTMLAnchorElement genlPredAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                genlPredAnchorElement.setHref("#" + genlPred.cyclify());
                parentElement.appendChild(genlPredAnchorElement);
                Node genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
                genlPredAnchorElement.appendChild(genlPredTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("  ");
                parentElement.appendChild(spacesTextNode);
            }
d1123 2
a1124 1
    protected CycList gatherUpwardClosure (CycList selectedCycForts) throws UnknownHostException, IOException, CycApiException {
a1132 1
        cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
d1157 1
a1157 1
                        cycAccess.isa(isaGenl, cycKbSubsetFilter)) {
d1171 3
a1173 2
                    if ((!upwardClosureSet.contains(isaGenlPred)) && (!selectedCycFortsSet.contains(isaGenlPred)) && cycAccess.isa(isaGenlPred,
                            cycKbSubsetFilter)) {
d1183 16
@


1.14
log
@Made KB subset selection a command line choice for convenience
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.13 2002/02/04 21:46:52 stephenreed Exp $
a106 4
     * The #$CycLConstant guid.
     */
    public static final Guid cycLConstantGuid = CycObjectFactory.makeGuid("bf3491c4-9c29-11b1-9dad-c379636f7270");
    /**
d272 10
a281 4
            exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyCandidateConstantGuid);
            exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyCoreConstantGuid);
            exportHtml.filterFromDirectInstanceGuids.add(eeldSharedOntologyConstantGuid);
            exportHtml.filterFromDirectInstanceGuids.add(cycLConstantGuid);
@


1.13
log
@Tailoring HTML export
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.12 2002/02/04 21:15:31 stephenreed Exp $
d245 3
d249 26
a274 15
            //exportHtml.cycKbSubsetCollectionGuid = counterTerrorismConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";

            exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCandidateConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-candidate-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-candidate-hierarchy.html";
@


1.12
log
@Fine tuning the HTML export
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.11 2002/02/04 17:03:29 stephenreed Exp $
d250 7
a256 7
            exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";
@


1.11
log
@Fix api handling of CycNarts. Refined HTML export.
@
text
@d19 1
a19 1
 * @@version $Id: ExportHtml.java,v 1.10 2002/02/03 18:07:23 stephenreed Exp $
a109 1
    protected CycConstant cycLConstant;
d187 17
a203 1
    protected boolean print_guid = true;
d262 6
d303 13
d361 4
a364 1
        cycLConstant = cycAccess.getKnownConstantByGuid(cycLConstantGuid);
a398 4
                if (verbosity > 2) {
                    String individualType = "  (type unknown)";
                    Log.current.println(individualType);
                }
d469 1
a469 1
            createGuidNode(cycConstant, blockquoteElement);                     //GUID printing turned on/off here
d703 2
d716 7
a722 2
            if (!selectedCycForts.contains(isa)) {
                isa = this.findSelectedGenls(isa);
d728 7
a734 1
            else
d736 1
d739 2
a740 2
        // filter out CycLConstant.
        createdIsas.remove(cycLConstant);
d816 5
a820 1
            if (selectedCycForts.contains(genl)) {
a1077 2
                    Log.current.println("  CycNart " + cycFort.cyclify());
                    cycAccess.traceOnDetailed();
a1078 1
                    Log.current.println("  genls " + allGenls);
d1086 4
a1089 1
                        Log.current.println("***** Invalid term: " + isasGenls.get(j));
@


1.10
log
@More JXTA interface code and fixing CycNart api bug
@
text
@d1 1076
a1076 1072
package  org.opencyc.xml;

import  java.io.*;
import  java.util.*;
import  java.net.*;
import  org.w3c.dom.*;
import  org.w3c.dom.html.*;
import  org.apache.html.dom.*;
import  org.apache.xml.serialize.*;
import  ViolinStrings.Strings;
import  org.opencyc.cycobject.*;
import  org.opencyc.api.*;
import  org.opencyc.util.*;


/**
 * HTML ontology export for OpenCyc.
 *
 * @@version $Id: ExportHtml.java,v 1.7 2002/02/01 19:02:37 mreimers Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class ExportHtml {
    /**
     * Command indicating that the HTML export contains only the marked KB
     * subset terms.  cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.  cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the upward closure.
     */
    public static final int EXPORT_KB_SUBSET = 1;
    /**
     * Command indicating that the HTML export contains the marked KB
     * subset terms plus all the terms in the upward closure to #$Thing.
     * cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.
     */
    public static final int EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE = 2;
    /**
     * Command indicating that the HTML export contains the collections whose
     * direct or indirect genl is the collection term indentified by rootTermGuid.
     * cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the export set.
     */
    public static final int EXPORT_KB_SUBSET_BELOW_TERM = 3;
    /**
     * The command performed by the HTML extract process.
     */
    protected int exportCommand = 0;
    /**
     * The default verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected static final int DEFAULT_VERBOSITY = 3;
    /**
     * Sets verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public int verbosity = DEFAULT_VERBOSITY;
    /**
     * Indicates whether the upward closure of terms should be exported.  If so, the
     * upward closure terms are filtered by cycKbSubsetFilterGuid below.
     */
    public boolean includeUpwardClosure = false;
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public CycFort cycKbSubsetCollection = null;
    /**
     * The #$EELDSharedOntologyConstant guid.
     */
    public static final Guid eeldSharedOntologyConstantGuid = CycObjectFactory.makeGuid("c06e4624-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$EELDSharedOntologyConstant guid.
     */
    public static final Guid eeldSharedOntologyCandidateConstantGuid =
        CycObjectFactory.makeGuid("bf21d357-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$EELDSharedOntologyCoreConstant guid.
     */
    public static final Guid eeldSharedOntologyCoreConstantGuid = CycObjectFactory.makeGuid("c12e44bd-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$CounterTerrorismConstant guid.
     */
    public static final Guid counterTerrorismConstantGuid = CycObjectFactory.makeGuid("bfe31c38-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$IKBConstant guid.
     */
    public static final Guid ikbConstantGuid = CycObjectFactory.makeGuid("bf90b3e2-9c29-11b1-9dad-c379636f7270");
    /**
     * The #$CycLConstant guid.
     */
    public static final Guid cycLConstantGuid = CycObjectFactory.makeGuid("bf3491c4-9c29-11b1-9dad-c379636f7270");
    protected CycConstant cycLConstant;
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public Guid cycKbSubsetCollectionGuid = null;
    /**
     * The guid which identifies the CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    public Guid cycKbSubsetFilterGuid = null;
    /**
     * The CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    protected CycFort cycKbSubsetFilter = null;
    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * the collection term indentified by this value.
     */
    public Guid rootTermGuid = null;
    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * this collection term.
     */
    public CycFort rootTerm = null;
    /**
     * #$rewriteOf guid
     */
    public static final Guid rewriteOfGuid =
        CycObjectFactory.makeGuid("c13bc0c4-9c29-11b1-9dad-c379636f7270");
    /**
     * #$equalSymbols guid
     */
    public static final Guid equalSymbolsGuid =
        CycObjectFactory.makeGuid("c05e110e-9c29-11b1-9dad-c379636f7270");
    /**
     * #$InferencePSC guid
     */
    public static final Guid inferencePSCGuid =
        CycObjectFactory.makeGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
    /**
     * The HTML exported vocabulary path and file name.
     */
    public String exportedVocabularyOutputPath = "exported-vocabulary.html";
    /**
     * The HTML exported hierarchy path and file name.
     */
    public String exportedHierarchyOutputPath = "exported-hierarchy.html";
    /**
     * the html document
     */
    protected HTMLDocument htmlDocument;
    /**
     * Manages connection to the cyc server api.
     */
    protected CycAccess cycAccess;
    /**
     * the HTML body element
     */
    protected Element htmlBodyElement;
    /**
     * the selected terms
     */
    protected CycList selectedCycForts;
    /**
     * Indicates the presence of a comment for the current term.
     */
    protected boolean hasComment = false;
    /**
     * indicates which terms have been previously expanded in the hierarchy page
     */
    protected HashSet previouslyExpandedTerms;
    protected String hostname = CycConnection.DEFAULT_HOSTNAME;
    protected int port = CycConnection.DEFAULT_BASE_PORT;
    protected boolean print_guid = true;

    /**
     * Constructs a new ExportHtml object.
     */
    public ExportHtml () {
        Log.makeLog();
    }

    /**
     * Constructs a new ExportHtml object which will connect to the cyc server
     * at hostname, port.
     *
     * @@param hostname the cyc server hostname
     * @@param port the cyc server base port
     */
    public ExportHtml (String hostname, int port) {
        this();
        this.hostname = hostname;
        this.port = port;
    }

    /**
     * Constructs a new ExportHtml object which will connect to the cyc server
     * at hostname, port.  print_guid value gates guid printing.
     *
     * @@param hostname the cyc server hostname
     * @@param port the cyc server base port
     * @@param print_guid gates guid presence in the HTML document
     */
    public ExportHtml (String hostname, int port, boolean print_guid) {
        this(hostname, port);
        this.print_guid = print_guid;
    }

    /**
     * Runs the ExportHtml application.
     *
     * @@param args the command line arguments.
     */
    public static void main (String[] args) {
        ExportHtml exportHtml = new ExportHtml();
        try {
            //exportHtml.cycKbSubsetCollectionGuid = counterTerrorismConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";

            exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCandidateConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "eeld-shared-candidate-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "eeld-shared-candidate-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";

            exportHtml.cycKbSubsetFilterGuid = ikbConstantGuid;
            exportHtml.export(EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Exports the desired KB content into HTML.
     */
    public void export (int exportCommand) throws UnknownHostException, IOException, CycApiException {
        this.exportCommand = exportCommand;
        setup();
        if (verbosity > 2)
            Log.current.println("Getting terms from Cyc");
        if ((exportCommand == ExportHtml.EXPORT_KB_SUBSET) || (exportCommand == ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
            selectedCycForts = cycAccess.getAllInstances(cycKbSubsetCollection);
        }
        else {
            // EXPORT_KB_SUBSET_BELOW_TERM
            selectedCycForts = cycAccess.getAllSpecs(rootTerm);
            selectedCycForts.add(rootTerm);
        }
        if (verbosity > 2)
            Log.current.println("Selected " + selectedCycForts.size() + " CycFort terms");
        if (includeUpwardClosure) {
            CycList upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
            if (verbosity > 2)
                Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
            selectedCycForts.addAll(upwardClosureCycForts);
            if (verbosity > 2)
                Log.current.println("All selected " + selectedCycForts.size() + " CycFort terms");
        }
        if (verbosity > 2)
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
        Collections.sort(selectedCycForts);
        createVocabularyPage();
        if (rootTerm != null)
            createHierarchyPage(rootTerm);
        else if (includeUpwardClosure)
            createHierarchyPage(CycAccess.thing);
        else if (verbosity > 0)
            Log.current.println("Ommiting ontology hierarchy export page");
        if (verbosity > 0)
            Log.current.println("HTML export completed");
        cycAccess.close();
    }

    /**
     * Sets up the HTML export process.
     */
    protected void setup () throws UnknownHostException, IOException, CycApiException {
        cycAccess = new CycAccess(hostname, port, CycConnection.DEFAULT_COMMUNICATION_MODE, CycAccess.DEFAULT_CONNECTION);
        if (exportCommand == ExportDaml.EXPORT_KB_SUBSET) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
        }
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            includeUpwardClosure = true;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() + "\n  plus upward closure to #$Thing filtered by "
                        + cycKbSubsetFilter.cyclify());
        }
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_BELOW_TERM) {
            rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            cycKbSubsetCollection = cycKbSubsetFilter;
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() + "\n  filtered by " + cycKbSubsetFilter.cyclify());
        }
        else {
            System.err.println("Invalid export comand " + exportCommand);
            System.exit(1);
        }
        cycLConstant = cycAccess.getKnownConstantByGuid(cycLConstantGuid);
    }

    /**
     * Creates vocabulary HTML page.
     */
    protected void createVocabularyPage () throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for vocabulary page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        for (int i = 0; i < selectedCycForts.size(); i++) {
            //for (int i = 0; i < 20; i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (verbosity > 2)
                Log.current.print(cycFort + "  ");
            if (cycAccess.isCollection(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Collection");
            }
            else if (cycAccess.isPredicate(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Predicate");
            }
            else if (cycAccess.isIndividual(cycFort)) {
                if (verbosity > 2)
                    Log.current.print("Individual");
                if (verbosity > 2) {
                    String individualType = "  (type unknown)";
                    Log.current.println(individualType);
                }
            }
            else {
                if (verbosity > 2)
                    Log.current.println("other");
                continue;
            }
            if (cycFort instanceof CycConstant)
                createCycConstantNode((CycConstant)cycFort);
            else
                createCycNartNode((CycNart)cycFort);
        }
        serialize(htmlDocument, exportedVocabularyOutputPath);
    }

    /**
     * Creates a HTML node for a single Cyc Nart.
     * @@parameter cycNart the CycNart from which the HTML node is created
     */
    protected void createCycNartNode (CycNart cycNart) throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        htmlAnchorElement.setName(cycNart.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        String generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycNart);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node collectionTextNode = htmlDocument.createTextNode(cycNart.cyclify());
        htmlAnchorElement.appendChild(collectionTextNode);
        Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
        Node generatedPhraseNode = htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
        italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        createIsaNodes(cycNart, blockquoteElement);
        createGenlNodes(cycNart, blockquoteElement);
    }

    /**
     * Creates a HTML node for a single Cyc Constant.
     * @@parameter cycConstant the CycConstant from which the HTML node is created
     */
    protected void createCycConstantNode (CycConstant cycConstant)
        throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl)htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        htmlAnchorElement.setName(cycConstant.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        Node collectionTextNode = htmlDocument.createTextNode(cycConstant.cyclify());
        htmlAnchorElement.appendChild(collectionTextNode);
        processRewriteOf(cycConstant, htmlFontElement);
        String generatedPhrase;
        if (cycAccess.isCollection(cycConstant))
            generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycConstant);
        else
            generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycConstant);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Element italicsGeneratedPhraseElement = italics(htmlAnchorElement);
        Node generatedPhraseNode = htmlDocument.createTextNode("&nbsp;&nbsp;&nbsp;" + generatedPhrase);
        italicsGeneratedPhraseElement.appendChild(generatedPhraseNode);
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        createCommentNodes(cycConstant, blockquoteElement);
        if (print_guid)
            createGuidNode(cycConstant, blockquoteElement);                     //GUID printing turned on/off here
        createIsaNodes(cycConstant, blockquoteElement);
        if (cycAccess.isCollection(cycConstant))
            createCollectionNode(cycConstant, blockquoteElement);
        else if (cycAccess.isPredicate(cycConstant))
            createPredicateNode(cycConstant, blockquoteElement);
        else if (cycAccess.isIndividual(cycConstant))
            createIndividualNode(cycConstant, blockquoteElement);
        else {
            if (verbosity > 0)
                Log.current.println("Unhandled constant: " + cycConstant.toString());
        }
    }

    /**
     * Processes the case where the given Cyc constant has a #$rewriteOf relationship
     * to a Cyc FORT (First Order Reified Term).  For example when the given term is
     * #$AttemptedKillingByCarAccident, then the KB contains the assertion
     * (#$rewriteOf #$AttemptedKillingByCarAccident ((KillingThroughEventTypeFn #$CarAccident))
     * and the phrase " is the atomic form of (KillingThroughEventTypeFn #$CarAccident)" is
     * output to the HTML document.
     *
     * @@param cycConstant the given CycConstant for processing if a #$rewriteOf
     * @@param parentElement the parent HTML element for inserting rewriteOf text
     */
    protected void processRewriteOf(CycConstant cycConstant,
                                    Element parentElement)
        throws UnknownHostException, IOException, CycApiException {
        CycList query = new CycList();
        query.add(cycAccess.and);
        CycList query1 = new CycList();
        query.add(query1);

        query1.add(cycAccess.getKnownConstantByGuid(rewriteOfGuid));
        query1.add(cycConstant);
        CycVariable fortVariable = CycObjectFactory.makeCycVariable("?FORT");
        query1.add(fortVariable);
        CycConstant inferencePSC = cycAccess.getKnownConstantByGuid(inferencePSCGuid);
        // #$rewriteOf is reflexsive so constrain arg2 to be different from arg1.
        CycList query2 = new CycList();
        query.add(query2);
        query2.add(cycAccess.not);
        CycList query3 = new CycList();
        query2.add(query3);
        query3.add(cycAccess.getKnownConstantByGuid(equalSymbolsGuid));
        query3.add(cycConstant);
        query3.add(fortVariable);
        CycList cycForts = cycAccess.askWithVariable(query, fortVariable, inferencePSC);
        if (cycForts.size() == 0)
            return;
        if (! (cycForts.get(0) instanceof CycFort)) {
            Log.current.errorPrintln("\nError, rewriteOf " + cycConstant.cyclify() +
                                     "\n " + cycForts.get(0) + "\nis not a CycFort\n");
            return;
        }
        CycFort cycFort = (CycFort) cycForts.get(0);
        Node rewriteOfTextNode = htmlDocument.createTextNode("  is the atomic form of ");
        parentElement.appendChild(rewriteOfTextNode);
        Node cycFortTextNode = htmlDocument.createTextNode(cycFort.cyclify());
        if (selectedCycForts.contains(cycFort)) {
            HTMLAnchorElement cycFortAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            cycFortAnchorElement.setHref("#" + cycFort.cyclify());
            parentElement.appendChild(cycFortAnchorElement);
            cycFortAnchorElement.appendChild(cycFortTextNode);
        }
        else
            parentElement.appendChild(cycFortTextNode);
    }

    /**
     * Creates a paragraph break in the HTML document.
     */
    protected void paragraphBreak () {
        Element paragraphElement = htmlDocument.createElement("p");
        htmlBodyElement.appendChild(paragraphElement);
    }

    /**
     * Creates an italics element in the HTML document.
     *
     * @@param parentElement the parent HTML DOM element
     * @@return the italics element
     */
    protected Element italics (Element parentElement) {
        Element italicsElement = htmlDocument.createElement("i");
        parentElement.appendChild(italicsElement);
        return  italicsElement;
    }

    /**
     * Creates a line break in the HTML document.
     *
     * @@param parentElement the parent HTML DOM element
     */
    protected void lineBreak (Element parentElement) {
        Element breakElement = htmlDocument.createElement("br");
        parentElement.appendChild(breakElement);
    }

    /**
     * Creates a horizontal rule in the HTML document.
     */
    protected void horizontalRule () {
        Element horizontalRuleElement = htmlDocument.createElement("hr");
        htmlBodyElement.appendChild(horizontalRuleElement);
    }

    /**
     * Creates HTML nodes for comment text containing CycConstants which are to be
     * represented as hyperlinks.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCommentNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        String comment = cycAccess.getComment(cycConstant);
        if (comment.equals("")) {
            hasComment = false;
            return;
        }
        hasComment = true;
        StringTokenizer st = new StringTokenizer(comment);
        StringBuffer stringBuffer = new StringBuffer();
        CycConstant commentConstant;
        Node commentTextNode;
        Node linkTextNode;
        HTMLAnchorElement htmlAnchorElement;
        while (st.hasMoreTokens()) {
            String word = st.nextToken();
            boolean wordHasLeadingLeftParen = false;
            if (word.startsWith("(#$")) {
                wordHasLeadingLeftParen = true;
                word = word.substring(1);
            }
            if (word.startsWith("#$")) {
                StringBuffer nonNameChars = new StringBuffer();
                while (true) {
                    // Move trailing non-name characters.
                    char ch = word.charAt(word.length() - 1);
                    if (Character.isLetterOrDigit(ch))
                        break;
                    word = Strings.stripTrailing(word, ch);
                    nonNameChars.insert(0, ch);
                    if (word.length() == 0)
                        break;
                }
                commentConstant = cycAccess.getConstantByName(word);
                if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
                    stringBuffer.append(" ");
                    commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    parentElement.appendChild(commentTextNode);
                    stringBuffer = new StringBuffer();
                    htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                    htmlAnchorElement.setHref("#" + commentConstant.cyclify());
                    parentElement.appendChild(htmlAnchorElement);
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                    linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    htmlAnchorElement.appendChild(linkTextNode);
                    stringBuffer = new StringBuffer();
                }
                else if (commentConstant == null && word.endsWith("s")) {
                    commentConstant = cycAccess.getConstantByName(word.substring(0, word.length() - 1));
                    if (commentConstant != null && selectedCycForts.contains(commentConstant)) {
                        stringBuffer.append(" ");
                        commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        parentElement.appendChild(commentTextNode);
                        stringBuffer = new StringBuffer();
                        htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                        htmlAnchorElement.setHref("#" + commentConstant.cyclify());
                        parentElement.appendChild(htmlAnchorElement);
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                        linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        htmlAnchorElement.appendChild(linkTextNode);
                        stringBuffer = new StringBuffer();
                    }
                    else {
                        stringBuffer.append(" ");
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                    }
                }
                else {
                    stringBuffer.append(" ");
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                }
            }
            else {
                stringBuffer.append(" ");
                stringBuffer.append(word);
            }
        }
        if (stringBuffer.length() > 0) {
            commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
            parentElement.appendChild(commentTextNode);
        }
    }

    /**
     * Creates HTML node for guid.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGuidNode (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        Guid guid = cycConstant.getGuid();
        if (hasComment)
            lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node guidLabelTextNode = htmlDocument.createTextNode("guid: ");
        bElement.appendChild(guidLabelTextNode);
        Node guidTextNode = htmlDocument.createTextNode(guid.toString());
        parentElement.appendChild(guidTextNode);
    }

    /**
     * Creates HTML nodes for isa links.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIsaNodes (CycFort cycFort, Element parentElement) throws IOException, CycApiException {
        CycList isas = cycAccess.getIsas(cycFort);
        if (verbosity > 3)
            Log.current.println("  starting isas: " + isas.cyclify());
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node isasLabelTextNode = htmlDocument.createTextNode("direct instance of: ");
        bElement.appendChild(isasLabelTextNode);
        CycList createdIsas = new CycList();
        for (int i = 0; i < isas.size(); i++) {
            CycFort isa = (CycFort)isas.get(i);
            if (!selectedCycForts.contains(isa)) {
                isa = this.findSelectedGenls(isa);
                if (isa == null)
                    continue;
            }
            if (createdIsas.contains(isa))
                continue;
            else
                createdIsas.add(isa);
        }
        createdIsas = specificCollections(createdIsas);
        // filter out CycLConstant.
        createdIsas.remove(cycLConstant);
        for (int i = 0; i < createdIsas.size(); i++) {
            CycFort isa = (CycFort)createdIsas.get(i);
            HTMLAnchorElement isaAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            isaAnchorElement.setHref("#" + isa.cyclify());
            parentElement.appendChild(isaAnchorElement);
            Node isaTextNode = htmlDocument.createTextNode(isa.cyclify());
            isaAnchorElement.appendChild(isaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Returns the first indirect genls above the given term which is a member of the selected
     * terms.
     *
     * @@param collection the cyc collection which is not a member of the selected terms.
     * @@return the first indirect genls above the given term which is a member of the selected
     * terms
     */
    protected CycFort findSelectedGenls (CycFort collection) throws IOException, CycApiException {
        if (collection.equals(cycAccess.getKnownConstantByName("CycKBSubsetCollection"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return  null;
        }
        if (collection.equals(cycAccess.getKnownConstantByName("CycSecureConstant"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return  null;
        }
        CycList genls = cycAccess.getGenls(collection);
        if (verbosity > 3)
            Log.current.println("  genls of " + collection.cyclify() + " are " + genls.cyclify());
        CycFort directGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort)genls.get(i);
            if (selectedCycForts.contains(directGenls)) {
                if (verbosity > 3)
                    Log.current.println("  traversed up from genls " + collection.cyclify() + " to find selected genls " + directGenls);
                return  directGenls;
            }
        }
        CycFort selectedGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort)genls.get(i);
            selectedGenls = findSelectedGenls(directGenls);
            if (selectedGenls != null) {
                if (verbosity > 3)
                    Log.current.println("  traversed up from genls " + collection.cyclify() + " to find selected genls " + selectedGenls);
                return  selectedGenls;
            }
        }
        return  null;
    }

    /**
     * Creates HTML nodes for genl links.
     *
     * @@param cycConstant the CycConstant for which genl links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlNodes (CycFort cycFort, Element parentElement) throws IOException, CycApiException {
        CycList genls = cycAccess.getGenls(cycFort);
        if (verbosity > 3)
            Log.current.println("  starting genls: " + genls.cyclify());
        genls = filterSelectedConstants(genls);
        genls = specificCollections(genls);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
        bElement.appendChild(genlsLabelTextNode);
        for (int i = 0; i < genls.size(); i++) {
            CycFort genl = (CycFort)genls.get(i);
            if (selectedCycForts.contains(genl)) {
                HTMLAnchorElement genlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                genlAnchorElement.setHref("#" + genl.cyclify());
                parentElement.appendChild(genlAnchorElement);
                Node genlTextNode = htmlDocument.createTextNode(genl.cyclify());
                genlAnchorElement.appendChild(genlTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
                parentElement.appendChild(spacesTextNode);
            }
        }
        if (genls.size() > 0) {
            Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
            parentElement.appendChild(spacesTextNode);
            HTMLAnchorElement hierarchyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
            hierarchyAnchorElement.setHref("./" + exportedHierarchyOutputPath + "#" + cycFort.cyclify());
            parentElement.appendChild(hierarchyAnchorElement);
            Node hierarchyTextNode = htmlDocument.createTextNode("hierarchy");
            hierarchyAnchorElement.appendChild(hierarchyTextNode);
        }
    }

    /**
     * Given a set of collection terms, returns a set which does not contain any collections
     * are more genl than the remaining collections.
     *
     * @@param collections the given set of collection terms
     * @@return a set of collection terms which does not contain any collections are more genl than the
     * remaining collections.
     */
    protected CycList specificCollections (CycList collections) throws IOException, CycApiException {
        if (verbosity > 3)
            Log.current.println("  specificCollections input: " + collections.cyclify());
        CycList result = new CycList();
        for (int i = 0; i < collections.size(); i++) {
            CycFort genlsCollection = (CycFort)collections.get(i);
            boolean genlsOf = false;
            for (int j = 0; j < collections.size(); j++) {
                CycFort specCollection = (CycFort)collections.get(j);
                if (i != j) {
                    if (verbosity > 6)
                        Log.current.println("  genlsCollection? " + genlsCollection + " specCollection? " + specCollection);
                    if (cycAccess.isGenlOf(genlsCollection, specCollection)) {
                        genlsOf = true;
                        if (verbosity > 4)
                            Log.current.println("  collection " + genlsCollection + " genls of " + specCollection + " and is dropped");
                        break;
                    }
                }
            }
            if (!genlsOf)
                result.add(genlsCollection);
        }
        if (verbosity > 3)
            Log.current.println("  specificCollections output: " + result.cyclify());
        return  result;
    }

    /**
     * Creates HTML nodes for genlPreds links.
     *
     * @@param cycConstant the CycConstant for which genlPreds links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlPredsNodes (CycConstant cycConstant, Element parentElement) throws IOException, CycApiException {
        CycList genlPreds = filterSelectedConstants(cycAccess.getGenlPreds(cycConstant));
        if (verbosity > 4)
            Log.current.println("genlPreds " + genlPreds);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsPredsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
        bElement.appendChild(genlsPredsLabelTextNode);
        for (int i = 0; i < genlPreds.size(); i++) {
            CycConstant genlPred = (CycConstant)genlPreds.get(i);
            if (selectedCycForts.contains(genlPred)) {
                HTMLAnchorElement genlPredAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
                genlPredAnchorElement.setHref("#" + genlPred.cyclify());
                parentElement.appendChild(genlPredAnchorElement);
                Node genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
                genlPredAnchorElement.appendChild(genlPredTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("  ");
                parentElement.appendChild(spacesTextNode);
            }
        }
    }

    /**
     * Creates an HTML individual node for a single Cyc individual.
     *
     * @@parameter cycConstant the Cyc individual from which the HTML individual node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIndividualNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node individualLabelTextNode = htmlDocument.createTextNode("Individual");
        bElement.appendChild(individualLabelTextNode);
    }

    /**
     * Creates an HTML node for a single Cyc collection.
     *
     * @@parameter cycConstant the Cyc collection from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCollectionNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        createGenlNodes(cycConstant, parentElement);
    }

    /**
     * Creates an HTML node for a single Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createPredicateNode (CycConstant cycConstant, Element parentElement) throws UnknownHostException, IOException, CycApiException {
        createGenlPredsNodes(cycConstant, parentElement);
    }

    /**
     * Creates hierarchy HTML page.
     *
     * @@param rootTerm the root term of the hierarchy tree
     */
    protected void createHierarchyPage (CycFort rootTerm) throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for hierarchy page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology hierarchy for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        previouslyExpandedTerms = new HashSet();
        createHierarchyNodes(rootTerm, 0);
        serialize(htmlDocument, exportedHierarchyOutputPath);
    }

    /**
     * Recursively creates hierarchy nodes for the given term and its spec collection terms.
     *
     * @@param cycFort the given term for which hierarchy nodes will be created
     * @@param indent the current indent level
     */
    protected void createHierarchyNodes (CycFort cycFort, int indent) throws IOException, CycApiException {
        if (indent > 0) {
            StringBuffer spaces = new StringBuffer(indent);
            StringBuffer nonBreakingSpaces = new StringBuffer(indent);
            for (int i = 0; i < indent; i++) {
                spaces.append(' ');
                nonBreakingSpaces.append("&nbsp;");
            }
            Node spacesText = htmlDocument.createTextNode(nonBreakingSpaces.toString());
            htmlBodyElement.appendChild(spacesText);
            if (verbosity > 2)
                Log.current.println(spaces.toString() + cycFort);
        }
        else {
            if (verbosity > 2)
                Log.current.println(cycFort.toString());
        }
        HTMLAnchorElement vocabularyAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl)htmlDocument, "a");
        vocabularyAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
        htmlBodyElement.appendChild(vocabularyAnchorElement);
        Node hierarchyTermTextNode = htmlDocument.createTextNode(cycFort.cyclify());
        vocabularyAnchorElement.appendChild(hierarchyTermTextNode);
        String generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycFort);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node generatedPhraseTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;" + generatedPhrase + "");
        htmlBodyElement.appendChild(generatedPhraseTextNode);
        CycList specs = cycAccess.getSpecs(cycFort);
        specs = filterSelectedConstants(specs);
        if (specs.size() == 0) {
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
        }
        else if (previouslyExpandedTerms.contains(cycFort)) {
            Node previouslyExpandedTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;... see above");
            htmlBodyElement.appendChild(previouslyExpandedTextNode);
            lineBreak(htmlBodyElement);
        }
        else {
            previouslyExpandedTerms.add(cycFort);
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
            for (int i = 0; i < specs.size(); i++)
                createHierarchyNodes((CycFort)specs.get(i), indent + 2);
        }
    }

    /**
     * Serializes the given HTML document to the given path.
     *
     * @@param htmlDocument the HTML document model for serialization
     * @@param outputPath the file name of the serialized HTML document
     */
    protected void serialize (HTMLDocument htmlDocument, String outputPath) throws IOException {
        if (verbosity > 2)
            Log.current.println("Writing HTML output to " + outputPath);
        OutputFormat outputFormat = new OutputFormat(htmlDocument, "UTF-8", true);
        BufferedWriter htmlOut = new BufferedWriter(new FileWriter(outputPath));
        XHTMLSerializer xhtmlSerializer = new XHTMLSerializer(htmlOut, outputFormat);
        xhtmlSerializer.asDOMSerializer();
        xhtmlSerializer.serialize(htmlDocument);
        htmlOut.close();
    }

    /**
     * Removes unselected terms from the given list.
     *
     * @@parameter constants the given list of constants which is to be filtered
     * @@return the filtered list
     */
    protected CycList filterSelectedConstants (CycList constants) {
        if (constants.size() == 0)
            return  constants;
        CycList result = new CycList();
        for (int i = 0; i < constants.size(); i++) {
            Object object = constants.get(i);
            if (selectedCycForts.contains(object))
                result.add(object);
            else if (verbosity > 4)
                Log.current.println(" dropping " + object);
        }
        return  result;
    }

    /**
     * Gather the updward closure of the selected CycForts with regard to isas and genls
     * for collection terms, and with regard to isas and genlPreds for predicate terms.
     *
     * @@parameter the selected CycForts
     * @@return the updward closure of the selected CycForts with regard to genls
     * for collection terms, and with regard to genlPreds for predicate terms
     */
    protected CycList gatherUpwardClosure (CycList selectedCycForts) throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2) {
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
            Collections.sort(selectedCycForts);
        }
        CycList upwardClosure = new CycList();
        // Redundant HashSets for efficient contains() method below.
        HashSet selectedCycFortsSet = new HashSet(selectedCycForts);
        HashSet upwardClosureSet = new HashSet(selectedCycForts.size());
        cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (cycAccess.isCollection(cycFort)) {
                CycList isasGenls = new CycList();
                isasGenls.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenls.addAllNew(cycAccess.getAllGenls(cycFort));

                if (cycFort instanceof CycNart) {
                    Log.current.println("  CycNart " + cycFort.cyclify());
                    cycAccess.traceOnDetailed();
                    CycList allGenls = cycAccess.getAllGenls(cycFort);
                    Log.current.println("  genls " + allGenls);
                }

                for (int j = 0; j < isasGenls.size(); j++) {
                    CycFort isaGenl = null;
                    try {
                        isaGenl = (CycFort) isasGenls.get(j);
                    } catch (ClassCastException e) {
                        Log.current.println("***** Invalid term: " + isasGenls.get(j));
                        continue;
                    }
                    if ((!upwardClosureSet.contains(isaGenl)) &&
                        (!selectedCycFortsSet.contains(isaGenl)) &&
                        cycAccess.isa(isaGenl, cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genl " + isaGenl);
                        upwardClosure.add(isaGenl);
                        upwardClosureSet.add(isaGenl);
                    }
                }
            }
            else if ((cycFort instanceof CycConstant) && (cycAccess.isPredicate((CycConstant)cycFort))) {
                CycList isasGenlPreds = new CycList();
                isasGenlPreds.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenlPreds.addAllNew(cycAccess.getAllGenlPreds((CycConstant)cycFort));
                for (int j = 0; j < isasGenlPreds.size(); j++) {
                    CycFort isaGenlPred = (CycFort)isasGenlPreds.get(j);
                    if ((!upwardClosureSet.contains(isaGenlPred)) && (!selectedCycFortsSet.contains(isaGenlPred)) && cycAccess.isa(isaGenlPred,
                            cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genlPred " + isaGenlPred);
                        upwardClosure.add(isaGenlPred);
                        upwardClosureSet.add(isaGenlPred);
                    }
                }
            }
        }
        return  upwardClosure;
    }
}



@


1.9
log
@Adding ACL messages
@
text
@d1 1072
a1072 986
package org.opencyc.xml;

import  java.io.*;
import  java.util.*;
import  java.net.*;
import  org.w3c.dom.*;
import  org.w3c.dom.html.*;
import  org.apache.html.dom.*;
import  org.apache.xml.serialize.*;
import  ViolinStrings.Strings;
import  org.opencyc.cycobject.*;
import  org.opencyc.api.*;
import  org.opencyc.util.*;

/**
 * HTML ontology export for OpenCyc.
 *
 * @@version $Id: ExportHtml.java,v 1.8 2002/01/24 19:22:05 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class ExportHtml {

    /**
     * Command indicating that the HTML export contains only the marked KB
     * subset terms.  cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.  cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the upward closure.
     */
    public static final int EXPORT_KB_SUBSET = 1;

    /**
     * Command indicating that the HTML export contains the marked KB
     * subset terms plus all the terms in the upward closure to #$Thing.
     * cycKbSubsetCollectionGuid contains the KB subset collection's
     * guid.
     */
    public static final int EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE = 2;

    /**
     * Command indicating that the HTML export contains the collections whose
     * direct or indirect genl is the collection term indentified by rootTermGuid.
     * cycKbSubsetFilterGuid contains the guid for the KB subset term that
     * filters membership in the export set.
     */
    public static final int EXPORT_KB_SUBSET_BELOW_TERM = 3;

    /**
     * The command performed by the HTML extract process.
     */
    protected int exportCommand = 0;

    /**
     * The default verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected static final int DEFAULT_VERBOSITY = 3;

    /**
     * Sets verbosity of the HTML export output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    public int verbosity = DEFAULT_VERBOSITY;

    /**
     * Indicates whether the upward closure of terms should be exported.  If so, the
     * upward closure terms are filtered by cycKbSubsetFilterGuid below.
     */
    public boolean includeUpwardClosure = false;

    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public CycFort cycKbSubsetCollection = null;

    /**
     * The #$EELDSharedOntologyConstant guid.
     */
    public static final Guid eeldSharedOntologyConstantGuid =
        CycObjectFactory.makeGuid("c06e4624-9c29-11b1-9dad-c379636f7270");

    /**
     * The #$EELDSharedOntologyCoreConstant guid.
     */
    public static final Guid eeldSharedOntologyCoreConstantGuid =
        CycObjectFactory.makeGuid("c12e44bd-9c29-11b1-9dad-c379636f7270");

    /**
     * The #$CounterTerrorismConstant guid.
     */
    public static final Guid counterTerrorismConstantGuid =
        CycObjectFactory.makeGuid("bfe31c38-9c29-11b1-9dad-c379636f7270");

    /**
     * The #$IKBConstant guid.
     */
    public static final Guid ikbConstantGuid =
        CycObjectFactory.makeGuid("bf90b3e2-9c29-11b1-9dad-c379636f7270");

    /**
     * The CycKBSubsetCollection whose elements are exported to HTML.
     */
    public Guid cycKbSubsetCollectionGuid = null;

    /**
     * The guid which identifies the CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    public Guid cycKbSubsetFilterGuid = null;

    /**
     * The CycKBSubsetCollection whose elements are exported to HTML if they
     * also generalizations of cycKbSubsetCollectionGuid collections or predicates above.
     * #$IKBConstant (not in OpenCyc)
     */
    protected CycFort cycKbSubsetFilter = null;

    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * the collection term indentified by this value.
     */
    public Guid rootTermGuid = null;

    /**
     * Used in the export command EXPORT_KB_SUBSET_BELOW_TERM.
     * The HTML export contains the collections whose direct or indirect genl is
     * this collection term.
     */
    public CycFort rootTerm = null;

    /**
     * The HTML exported vocabulary path and file name.
     */
    public String exportedVocabularyOutputPath = "exported-vocabulary.html";

    /**
     * The HTML exported hierarchy path and file name.
     */
    public String exportedHierarchyOutputPath = "exported-hierarchy.html";

    /**
     * the html document
     */
    protected HTMLDocument htmlDocument;

    /**
     * Manages connection to the cyc server api.
     */
    protected CycAccess cycAccess;

    /**
     * the HTML body element
     */
    protected Element htmlBodyElement;

    /**
     * the selected terms
     */
    protected CycList selectedCycForts;

    /**
     * Indicates the presence of a comment for the current term.
     */
    protected boolean hasComment = false;

    /**
     * indicates which terms have been previously expanded in the hierarchy page
     */
    protected HashSet previouslyExpandedTerms;

    /**
     * Constructs a new ExportHtml object.
     */
    public ExportHtml() {
        Log.makeLog();
    }

    /**
     * Runs the ExportHtml application.
     *
     * @@param args the command line arguments.
     */
    public static void main(String[] args) {
        ExportHtml exportHtml = new ExportHtml();
        try {
            //exportHtml.cycKbSubsetCollectionGuid = counterTerrorismConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";

            exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";

            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";

            exportHtml.cycKbSubsetFilterGuid = ikbConstantGuid;
            exportHtml.export(EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
        }
        catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Exports the desired KB content into HTML.
     */
    public void export (int exportCommand) throws UnknownHostException, IOException, CycApiException {
        this.exportCommand = exportCommand;
        setup();
        if (verbosity > 2)
            Log.current.println("Getting terms from Cyc");
        if ((exportCommand == ExportHtml.EXPORT_KB_SUBSET) ||
            (exportCommand == ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE)) {
            selectedCycForts = cycAccess.getAllInstances(cycKbSubsetCollection);
        }
        else {
            // EXPORT_KB_SUBSET_BELOW_TERM
            selectedCycForts = cycAccess.getAllSpecs(rootTerm);
            selectedCycForts.add(rootTerm);
        }
        if (verbosity > 2)
            Log.current.println("Selected " + selectedCycForts.size() + " CycFort terms");
        if (includeUpwardClosure) {
            CycList upwardClosureCycForts = gatherUpwardClosure(selectedCycForts);
            if (verbosity > 2)
                Log.current.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
            selectedCycForts.addAll(upwardClosureCycForts);
            if (verbosity > 2)
                Log.current.println("All selected " + selectedCycForts.size() + " CycFort terms");
        }
        if (verbosity > 2)
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");

        Collections.sort(selectedCycForts);

        createVocabularyPage();
        if (rootTerm != null)
            createHierarchyPage(rootTerm);
        else if (includeUpwardClosure)
            createHierarchyPage(CycAccess.thing);
        else if (verbosity > 0)
            Log.current.println("Ommiting ontology hierarchy export page");
        if (verbosity > 0)
            Log.current.println("HTML export completed");
        cycAccess.close();
    }

    /**
     * Sets up the HTML export process.
     */
    protected void setup () throws UnknownHostException, IOException, CycApiException {
        cycAccess = new CycAccess();
        if (exportCommand == ExportDaml.EXPORT_KB_SUBSET) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
        }
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE) {
            cycKbSubsetCollection = cycAccess.getKnownConstantByGuid(cycKbSubsetCollectionGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            includeUpwardClosure = true;
            if (verbosity > 1)
                Log.current.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() +
                                   "\n  plus upward closure to #$Thing filtered by " + cycKbSubsetFilter.cyclify());
        }
        else if (exportCommand == ExportDaml.EXPORT_KB_SUBSET_BELOW_TERM) {
            rootTerm = cycAccess.getKnownConstantByGuid(rootTermGuid);
            cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
            cycKbSubsetCollection = cycKbSubsetFilter;
            includeUpwardClosure = false;
            if (verbosity > 1)
                Log.current.println("Exporting KB collections below root term " + rootTerm.cyclify() +
                                   "\n  filtered by " + cycKbSubsetFilter.cyclify());
        }
        else {
            System.err.println("Invalid export comand " + exportCommand);
            System.exit(1);
        }
    }

    /**
     * Creates vocabulary HTML page.
     */
    protected void createVocabularyPage () throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for vocabulary page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology vocabulary for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        for (int i = 0; i < selectedCycForts.size(); i++) {
        //for (int i = 0; i < 20; i++) {

            CycFort cycFort = (CycFort) selectedCycForts.get(i);
            if (verbosity > 2)
                Log.current.print(cycFort + "  ");
            if (cycAccess.isCollection(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Collection");
            }
            else if (cycAccess.isPredicate(cycFort)) {
                if (verbosity > 2)
                    Log.current.println("Predicate");
            }
            else if (cycAccess.isIndividual(cycFort)) {
                if (verbosity > 2)
                    Log.current.print("Individual");
                if (verbosity > 2) {
                    String individualType = "  (type unknown)";
                    Log.current.println(individualType);
                }
            }
            else {
                if (verbosity > 2)
                    Log.current.println("other");
                continue;
            }
            if (cycFort instanceof CycConstant)
                createCycConstantNode((CycConstant) cycFort);
            else
                createCycNartNode((CycNart) cycFort);
        }
        serialize(htmlDocument, exportedVocabularyOutputPath);
    }

    /**
     * Creates a HTML node for a single Cyc Nart.
     * @@parameter cycNart the CycNart from which the HTML node is created
     */
    protected void createCycNartNode (CycNart cycNart)
        throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement =
            new HTMLFontElementImpl((HTMLDocumentImpl) htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
        htmlAnchorElement.setName(cycNart.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        String generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycNart);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node nartTextNode =
            htmlDocument.createTextNode(cycNart.cyclify() + "  (" + generatedPhrase + ")");
        htmlAnchorElement.appendChild(nartTextNode);
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        createIsaNodes(cycNart, blockquoteElement);
        createGenlNodes(cycNart, blockquoteElement);
    }

    /**
     * Creates a HTML node for a single Cyc Constant.
     * @@parameter cycConstant the CycConstant from which the HTML node is created
     */
    protected void createCycConstantNode (CycConstant cycConstant)
        throws UnknownHostException, IOException, CycApiException {
        horizontalRule();
        HTMLFontElement htmlFontElement =
            new HTMLFontElementImpl((HTMLDocumentImpl) htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement htmlAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
        htmlAnchorElement.setName(cycConstant.cyclify());
        htmlFontElement.appendChild(htmlAnchorElement);
        String generatedPhrase;
        if (cycAccess.isCollection(cycConstant))
            generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycConstant);
        else
            generatedPhrase = cycAccess.getSingularGeneratedPhrase(cycConstant);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node collectionTextNode =
            htmlDocument.createTextNode(cycConstant.cyclify() + "  (" + generatedPhrase + ")");
        htmlAnchorElement.appendChild(collectionTextNode);
        Element blockquoteElement = htmlDocument.createElement("blockquote");
        htmlBodyElement.appendChild(blockquoteElement);
        createCommentNodes(cycConstant, blockquoteElement);
        createGuidNode(cycConstant, blockquoteElement);
        createIsaNodes(cycConstant, blockquoteElement);

        if (cycAccess.isCollection(cycConstant))
            createCollectionNode(cycConstant, blockquoteElement);
        else if (cycAccess.isPredicate(cycConstant))
            createPredicateNode(cycConstant, blockquoteElement);
        else if (cycAccess.isIndividual(cycConstant))
            createIndividualNode(cycConstant, blockquoteElement);
        else {
            if (verbosity > 0)
                Log.current.println("Unhandled constant: " + cycConstant.toString());
        }
    }

    /**
     * Creates a paragraph break in the HTML document.
     */
    protected void paragraphBreak () {
        Element paragraphElement = htmlDocument.createElement("p");
        htmlBodyElement.appendChild(paragraphElement);
    }

    /**
     * Creates a line break in the HTML document.
     *
     * @@param parentElement the parent HTML DOM element
     */
    protected void lineBreak (Element parentElement) {
        Element breakElement = htmlDocument.createElement("br");
        parentElement.appendChild(breakElement);
    }

    /**
     * Creates a horizontal rule in the HTML document.
     */
    protected void horizontalRule () {
        Element horizontalRuleElement = htmlDocument.createElement("hr");
        htmlBodyElement.appendChild(horizontalRuleElement);
    }

    /**
     * Creates HTML nodes for comment text containing CycConstants which are to be
     * represented as hyperlinks.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCommentNodes (CycConstant cycConstant, Element parentElement)
        throws IOException, CycApiException {
        String comment = cycAccess.getComment(cycConstant);
        if (comment.equals("")) {
            hasComment = false;
            return;
        }
        hasComment = true;
        StringTokenizer st = new StringTokenizer(comment);
        StringBuffer stringBuffer = new StringBuffer();
        CycConstant commentConstant;
        Node commentTextNode;
        Node linkTextNode;
        HTMLAnchorElement htmlAnchorElement;
        while (st.hasMoreTokens()) {
            String word = st.nextToken();
            boolean wordHasLeadingLeftParen = false;
            if (word.startsWith("(#$")) {
                wordHasLeadingLeftParen = true;
                word = word.substring(1);
            }
            if (word.startsWith("#$")) {
                StringBuffer nonNameChars = new StringBuffer();
                while (true) {
                    // Move trailing non-name characters.
                    char ch = word.charAt(word.length() - 1);
                    if (Character.isLetterOrDigit(ch))
                        break;
                    word = Strings.stripTrailing(word, ch);
                    nonNameChars.insert(0, ch);
                    if (word.length() == 0)
                        break;
                }
                commentConstant = CycAccess.current().getConstantByName(word);
                if (commentConstant != null &&
                    selectedCycForts.contains(commentConstant)) {
                    stringBuffer.append(" ");
                    commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    parentElement.appendChild(commentTextNode);
                    stringBuffer = new StringBuffer();
                    htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
                    htmlAnchorElement.setHref("#" + commentConstant.cyclify());
                    parentElement.appendChild(htmlAnchorElement);
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                    linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                    htmlAnchorElement.appendChild(linkTextNode);
                    stringBuffer = new StringBuffer();
                }
                else if (commentConstant == null &&
                         word.endsWith("s")) {
                    commentConstant =
                        CycAccess.current().getConstantByName(word.substring(0, word.length() - 1));
                    if (commentConstant != null &&
                        selectedCycForts.contains(commentConstant)) {
                        stringBuffer.append(" ");
                        commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        parentElement.appendChild(commentTextNode);
                        stringBuffer = new StringBuffer();
                        htmlAnchorElement = new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
                        htmlAnchorElement.setHref("#" + commentConstant.cyclify());
                        parentElement.appendChild(htmlAnchorElement);
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                        linkTextNode = htmlDocument.createTextNode(stringBuffer.toString());
                        htmlAnchorElement.appendChild(linkTextNode);
                        stringBuffer = new StringBuffer();
                    }
                    else {
                        stringBuffer.append(" ");
                        if (wordHasLeadingLeftParen)
                            stringBuffer.append('(');
                        stringBuffer.append(word);
                        stringBuffer.append(nonNameChars.toString());
                    }
                }
                else {
                    stringBuffer.append(" ");
                    if (wordHasLeadingLeftParen)
                        stringBuffer.append('(');
                    stringBuffer.append(word);
                    stringBuffer.append(nonNameChars.toString());
                }
            }
            else {
                stringBuffer.append(" ");
                stringBuffer.append(word);
            }
        }
        if (stringBuffer.length() > 0) {
            commentTextNode = htmlDocument.createTextNode(stringBuffer.toString());
            parentElement.appendChild(commentTextNode);
        }
    }

    /**
     * Creates HTML node for guid.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGuidNode (CycConstant cycConstant, Element parentElement)
        throws IOException, CycApiException {
        Guid guid = cycConstant.getGuid();
        if (hasComment)
            lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node guidLabelTextNode = htmlDocument.createTextNode("guid: ");
        bElement.appendChild(guidLabelTextNode);
        Node guidTextNode = htmlDocument.createTextNode(guid.toString());
        parentElement.appendChild(guidTextNode);
    }

    /**
     * Creates HTML nodes for isa links.
     *
     * @@param cycConstant the CycConstant for which isa links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIsaNodes (CycFort cycFort, Element parentElement)
        throws IOException, CycApiException {
        CycList isas = cycAccess.getIsas(cycFort);
        if (verbosity > 4)
            Log.current.println("isas " + isas);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node isasLabelTextNode = htmlDocument.createTextNode("direct instance of: ");
        bElement.appendChild(isasLabelTextNode);
        ArrayList createdIsas = new ArrayList();
        for (int i = 0; i < isas.size(); i++) {
            CycFort isa = (CycFort) isas.get(i);
            if (! selectedCycForts.contains(isa)) {
                isa = findSelectedIsa(isa);
                if (isa == null)
                    continue;
            }
            if (createdIsas.contains(isa))
                continue;
            else
                createdIsas.add(isa);
            HTMLAnchorElement isaAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
            isaAnchorElement.setHref("#" + isa.cyclify());
            parentElement.appendChild(isaAnchorElement);
            Node isaTextNode = htmlDocument.createTextNode(isa.cyclify());
            isaAnchorElement.appendChild(isaTextNode);
            Node spacesTextNode = htmlDocument.createTextNode("  ");
            parentElement.appendChild(spacesTextNode);
        }
    }

    /**
     * Returns the first indirect isa above the given term which is a member of the selected
     * terms. The indirection is found via an upwards traversal of the genls links.
     *
     * @@param isa the cyc collection which is not a member of the selected terms.
     * @@return the first indirect isa above the given term which is a member of the selected
     * terms
     */
    protected CycFort findSelectedIsa (CycFort isa)
        throws IOException, CycApiException {
        if (isa.equals(cycAccess.getKnownConstantByName("CycKBSubsetCollection"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring isa " + isa);
            return null;
        }
        if (isa.equals(cycAccess.getKnownConstantByName("CycSecureConstant"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring isa " + isa);
            return null;
        }
        CycList isas = cycAccess.getIsas(isa);
        CycFort directIsa;
        CycFort indirectIsa;
        for (int i = 0; i < isas.size(); i++) {
            directIsa = (CycFort) isas.get(i);
            indirectIsa = findSelectedGenls(directIsa);
            if (indirectIsa != null) {
                if (verbosity > 2)
                    Log.current.println("  traversed up from isa " + isa.cyclify() +
                                        " to find selected isa " + indirectIsa);
                return indirectIsa;
            }
        }
        return null;
    }

    /**
     * Returns the first indirect genls above the given term which is a member of the selected
     * terms.
     *
     * @@param collection the cyc collection which is not a member of the selected terms.
     * @@return the first indirect genls above the given term which is a member of the selected
     * terms
     */
    protected CycFort findSelectedGenls (CycFort collection)
        throws IOException, CycApiException {
        if (collection.equals(cycAccess.getKnownConstantByName("CycKBSubsetCollection"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return null;
        }
        if (collection.equals(cycAccess.getKnownConstantByName("CycSecureConstant"))) {
            if (verbosity > 4)
                Log.current.println("  ignoring genls " + collection);
            return null;
        }
        CycList genls = cycAccess.getGenls(collection);
        CycFort directGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort) genls.get(i);
            if (selectedCycForts.contains(directGenls)) {
                if (verbosity > 2)
                    Log.current.println("  traversed up from genls " + collection.cyclify() +
                                        " to find selected genls " + directGenls);
                return directGenls;
            }
        }
        CycFort selectedGenls;
        for (int i = 0; i < genls.size(); i++) {
            directGenls = (CycFort) genls.get(i);
            selectedGenls = findSelectedIsa(directGenls);
            if (selectedGenls != null) {
                if (verbosity > 2)
                    Log.current.println("traversed up from genls " + collection.cyclify() +
                                        " to find selected genls " + selectedGenls);
                return selectedGenls;
            }
        }
        return null;
    }

    /**
     * Creates HTML nodes for genl links.
     *
     * @@param cycConstant the CycConstant for which genl links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlNodes (CycFort cycFort, Element parentElement)
        throws IOException, CycApiException {
        CycList genls = filterSelectedConstants(cycAccess.getGenls(cycFort));
        if (verbosity > 4)
            Log.current.println("genls " + genls);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsLabelTextNode = htmlDocument.createTextNode("direct subset of: ");
        bElement.appendChild(genlsLabelTextNode);
        for (int i = 0; i < genls.size(); i++) {
            CycFort genl = (CycFort) genls.get(i);
            if (selectedCycForts.contains(genl)) {
                HTMLAnchorElement genlAnchorElement =
                    new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
                genlAnchorElement.setHref("#" + genl.cyclify());
                parentElement.appendChild(genlAnchorElement);
                Node genlTextNode = htmlDocument.createTextNode(genl.cyclify());
                genlAnchorElement.appendChild(genlTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
                parentElement.appendChild(spacesTextNode);
            }
        }
        if (genls.size() > 0) {
            Node spacesTextNode = htmlDocument.createTextNode("&nbsp;&nbsp;");
            parentElement.appendChild(spacesTextNode);
            HTMLAnchorElement hierarchyAnchorElement =
                new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
            hierarchyAnchorElement.setHref("./" + exportedHierarchyOutputPath + "#" + cycFort.cyclify());
            parentElement.appendChild(hierarchyAnchorElement);
            Node hierarchyTextNode = htmlDocument.createTextNode("hierarchy");
            hierarchyAnchorElement.appendChild(hierarchyTextNode);
        }
    }

    /**
     * Creates HTML nodes for genlPreds links.
     *
     * @@param cycConstant the CycConstant for which genlPreds links are to be created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createGenlPredsNodes (CycConstant cycConstant, Element parentElement)
        throws IOException, CycApiException {
        CycList genlPreds = filterSelectedConstants(cycAccess.getGenlPreds(cycConstant));
        if (verbosity > 4)
            Log.current.println("genlPreds " + genlPreds);
        lineBreak(parentElement);
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node genlsPredsLabelTextNode = htmlDocument.createTextNode("direct specialization of: ");
        bElement.appendChild(genlsPredsLabelTextNode);
        for (int i = 0; i < genlPreds.size(); i++) {
            CycConstant genlPred = (CycConstant) genlPreds.get(i);
            if (selectedCycForts.contains(genlPred)) {
                HTMLAnchorElement genlPredAnchorElement =
                    new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
                genlPredAnchorElement.setHref("#" + genlPred.cyclify());
                parentElement.appendChild(genlPredAnchorElement);
                Node genlPredTextNode = htmlDocument.createTextNode(genlPred.cyclify());
                genlPredAnchorElement.appendChild(genlPredTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("  ");
                parentElement.appendChild(spacesTextNode);
            }
        }
    }

    /**
     * Creates an HTML individual node for a single Cyc individual.
     *
     * @@parameter cycConstant the Cyc individual from which the HTML individual node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createIndividualNode (CycConstant cycConstant, Element parentElement)
        throws UnknownHostException, IOException, CycApiException {
        Element bElement = htmlDocument.createElement("b");
        parentElement.appendChild(bElement);
        Node individualLabelTextNode = htmlDocument.createTextNode("Individual");
        bElement.appendChild(individualLabelTextNode);
    }

    /**
     * Creates an HTML node for a single Cyc collection.
     *
     * @@parameter cycConstant the Cyc collection from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createCollectionNode (CycConstant cycConstant, Element parentElement)
        throws UnknownHostException, IOException,
            CycApiException {
        createGenlNodes(cycConstant, parentElement);
    }

    /**
     * Creates an HTML node for a single Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate from which the HTML node is created
     * @@param parentElement the parent HTML DOM element
     */
    protected void createPredicateNode (CycConstant cycConstant, Element parentElement)
        throws UnknownHostException, IOException, CycApiException {
        createGenlPredsNodes(cycConstant, parentElement);
    }

    /**
     * Creates hierarchy HTML page.
     *
     * @@param rootTerm the root term of the hierarchy tree
     */
    protected void createHierarchyPage (CycFort rootTerm) throws UnknownHostException, IOException, CycApiException {
        if (verbosity > 2)
            Log.current.println("Building HTML model for hierarchy page");
        htmlDocument = new HTMLDocumentImpl();
        String title = "Cyc ontology hierarchy for " + cycKbSubsetCollection.cyclify();
        htmlDocument.setTitle(title);
        Node htmlNode = htmlDocument.getChildNodes().item(0);
        htmlBodyElement = htmlDocument.createElement("body");
        htmlNode.appendChild(htmlBodyElement);
        Element headingElement = htmlDocument.createElement("h1");
        htmlBodyElement.appendChild(headingElement);
        Node headingTextNode = htmlDocument.createTextNode(title);
        headingElement.appendChild(headingTextNode);
        previouslyExpandedTerms = new HashSet();
        createHierarchyNodes(rootTerm, 0);
        serialize(htmlDocument, exportedHierarchyOutputPath);
    }

    /**
     * Recursively creates hierarchy nodes for the given term and its spec collection terms.
     *
     * @@param cycFort the given term for which hierarchy nodes will be created
     * @@param indent the current indent level
     */
    protected void createHierarchyNodes(CycFort cycFort, int indent)
        throws IOException, CycApiException {
        if (indent > 0) {
            StringBuffer spaces = new StringBuffer(indent);
            StringBuffer nonBreakingSpaces = new StringBuffer(indent);
            for (int i = 0; i < indent; i++) {
                spaces.append(' ');
                nonBreakingSpaces.append("&nbsp;");
            }
            Node spacesText = htmlDocument.createTextNode(nonBreakingSpaces.toString());
            htmlBodyElement.appendChild(spacesText);
            if (verbosity > 2)
                Log.current.println(spaces.toString() + cycFort);
        }
        else {
            if (verbosity > 2)
                Log.current.println(cycFort.toString());
        }
        HTMLAnchorElement vocabularyAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
        vocabularyAnchorElement.setHref("./" + exportedVocabularyOutputPath + "#" + cycFort.cyclify());
        htmlBodyElement.appendChild(vocabularyAnchorElement);
        Node hierarchyTermTextNode = htmlDocument.createTextNode(cycFort.cyclify());
        vocabularyAnchorElement.appendChild(hierarchyTermTextNode);
        String generatedPhrase = cycAccess.getPluralGeneratedPhrase(cycFort);
        if (generatedPhrase.endsWith("(unclassified term)"))
            generatedPhrase = generatedPhrase.substring(0, generatedPhrase.length() - 20);
        Node generatedPhraseTextNode =
            htmlDocument.createTextNode("&nbsp;&nbsp;" + generatedPhrase + "");
        htmlBodyElement.appendChild(generatedPhraseTextNode);
        CycList specs = CycAccess.current().getSpecs(cycFort);
        specs = filterSelectedConstants(specs);
        if (specs.size() == 0) {
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
        }
        else if (previouslyExpandedTerms.contains(cycFort)) {
            Node previouslyExpandedTextNode =
                htmlDocument.createTextNode("&nbsp;&nbsp;... see above");
            htmlBodyElement.appendChild(previouslyExpandedTextNode);
            lineBreak(htmlBodyElement);
        }
        else {
            previouslyExpandedTerms.add(cycFort);
            vocabularyAnchorElement.setName(cycFort.cyclify());
            lineBreak(htmlBodyElement);
            for (int i = 0; i < specs.size(); i++)
                createHierarchyNodes((CycFort) specs.get(i), indent + 2);
        }
    }

    /**
     * Serializes the given HTML document to the given path.
     *
     * @@param htmlDocument the HTML document model for serialization
     * @@param outputPath the file name of the serialized HTML document
     */
    protected void serialize (HTMLDocument htmlDocument, String outputPath) throws IOException {
        if (verbosity > 2)
            Log.current.println("Writing HTML output to " + outputPath);
        OutputFormat outputFormat = new OutputFormat(htmlDocument, "UTF-8", true);
        BufferedWriter htmlOut = new BufferedWriter(new FileWriter(outputPath));
        XHTMLSerializer xhtmlSerializer = new XHTMLSerializer(htmlOut, outputFormat);
        xhtmlSerializer.asDOMSerializer();
        xhtmlSerializer.serialize(htmlDocument);
        htmlOut.close();
    }

    /**
     * Removes unselected terms from the given list.
     *
     * @@parameter constants the given list of constants which is to be filtered
     * @@return the filtered list
     */
    protected CycList filterSelectedConstants (CycList constants) {
        if (constants.size() == 0)
            return  constants;
        CycList result = new CycList();
        for (int i = 0; i < constants.size(); i++) {
            Object object = constants.get(i);
            if (selectedCycForts.contains(object))
                result.add(object);
            else if (verbosity > 4)
                Log.current.println(" dropping " + object);
        }
        return  result;
    }

    /**
     * Gather the updward closure of the selected CycForts with regard to isas and genls
     * for collection terms, and with regard to isas and genlPreds for predicate terms.
     *
     * @@parameter the selected CycForts
     * @@return the updward closure of the selected CycForts with regard to genls
     * for collection terms, and with regard to genlPreds for predicate terms
     */
    protected CycList gatherUpwardClosure (CycList selectedCycForts) throws UnknownHostException, IOException,
            CycApiException {
        if (verbosity > 2) {
            Log.current.println("Sorting " + selectedCycForts.size() + " CycFort terms");
            Collections.sort(selectedCycForts);
        }
        CycList upwardClosure = new CycList();
        // Redundant HashSets for efficient contains() method below.
        HashSet selectedCycFortsSet = new HashSet(selectedCycForts);
        HashSet upwardClosureSet = new HashSet(selectedCycForts.size());
        cycKbSubsetFilter = cycAccess.getKnownConstantByGuid(cycKbSubsetFilterGuid);
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort cycFort = (CycFort)selectedCycForts.get(i);
            if (cycAccess.isCollection(cycFort)) {
                CycList isasGenls = new CycList();
                isasGenls.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenls.addAllNew(cycAccess.getAllGenls(cycFort));
                for (int j = 0; j < isasGenls.size(); j++) {
                    CycFort isaGenl = null;
                    try {
                        isaGenl = (CycFort) isasGenls.get(j);
                    }
                    catch (ClassCastException e) {
                        Log.current.println("***** Invalid term: " + isasGenls.get(j));
                        continue;
                    }
                    if ((!upwardClosureSet.contains(isaGenl)) &&
                        (!selectedCycFortsSet.contains(isaGenl)) &&
                        cycAccess.isa(isaGenl, cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genl " + isaGenl);
                        upwardClosure.add(isaGenl);
                        upwardClosureSet.add(isaGenl);
                    }
                }
            }
            else if ((cycFort instanceof CycConstant) && (cycAccess.isPredicate((CycConstant)cycFort))) {
                CycList isasGenlPreds = new CycList();
                isasGenlPreds.addAllNew(cycAccess.getAllIsa(cycFort));
                isasGenlPreds.addAllNew(cycAccess.getAllGenlPreds((CycConstant) cycFort));
                for (int j = 0; j < isasGenlPreds.size(); j++) {
                    CycFort isaGenlPred = (CycFort) isasGenlPreds.get(j);
                    if ((!upwardClosureSet.contains(isaGenlPred)) &&
                        (!selectedCycFortsSet.contains(isaGenlPred)) &&
                        cycAccess.isa(isaGenlPred, cycKbSubsetFilter)) {
                        if (verbosity > 2)
                            Log.current.println(cycFort + " upward closure isa/genlPred " + isaGenlPred);
                        upwardClosure.add(isaGenlPred);
                        upwardClosureSet.add(isaGenlPred);
                    }
                }
            }
        }
        return  upwardClosure;
    }
}@


1.8
log
@Fixed an indirect isas bug which was traversing up the isa chain and not the
genls chain.
@
text
@d18 1
a18 1
 * @@version $Id: ExportHtml.java,v 1.7 2002/01/23 17:16:35 stephenreed Exp $
d268 1
@


1.7
log
@Made the org.opencyc.cycagent.coabs package optional, as the required CoABS grid
classes are not open source, nor freely downloadable.  The FIPA-OS package is
open source and OpenCyc can be configured to work with it alone.
@
text
@d18 1
a18 1
 * @@version $Id: ExportHtml.java,v 1.5 2002/01/21 19:59:15 stephenreed Exp $
d210 7
a216 7
            //exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyConstantGuid;
            //exportHtml.exportedVocabularyOutputPath = "eeld-shared-vocabulary.html";
            //exportHtml.exportedHierarchyOutputPath = "eeld-shared-hierarchy.html";

            exportHtml.cycKbSubsetCollectionGuid = eeldSharedOntologyCoreConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "eeld-shared-core-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "eeld-shared-core-hierarchy.html";
d617 1
a617 1
     * terms.
d625 1
a625 1
        if (cycAccess.isa(isa, cycAccess.getKnownConstantByName("CycKBSubsetCollection"))) {
d627 1
a627 1
                Log.current.println("  ignoring isa for " + isa);
d630 1
a630 1
        if (cycAccess.isa(isa, cycAccess.getKnownConstantByName("CycSecureConstant"))) {
d632 1
a632 1
                Log.current.println("  ignoring isa for " + isa);
d637 1
d640 2
a641 1
            if (selectedCycForts.contains(directIsa)) {
d644 36
a679 2
                                        " to find selected isa " + directIsa);
                return directIsa;
d682 5
a686 5
        CycFort selectedIsa;
        for (int i = 0; i < isas.size(); i++) {
            directIsa = (CycFort) isas.get(i);
            selectedIsa = findSelectedIsa(directIsa);
            if (selectedIsa != null) {
d688 3
a690 3
                    Log.current.println("traversed up from isa " + isa.cyclify() +
                                        " to find selected isa " + directIsa);
                return selectedIsa;
@


1.6
log
@Fixed bug with plural word form CycConstant hyperlinks.
@
text
@d641 1
a641 1
                    Log.current.println("traversed up from isa " + isa.cyclify() +
@


1.5
log
@Fixed some formatting bugs in the comment portion of HTML export.
@
text
@d18 1
a18 1
 * @@version $Id: ExportHtml.java,v 1.4 2002/01/08 15:02:31 stephenreed Exp $
d512 1
a512 1
                        CycAccess.current().getConstantByName(word.substring(0, word.length() - 2));
d631 1
a631 1
            if (verbosity > 2)
@


1.4
log
@Added SRA/NetOwl import function
@
text
@d10 1
d18 1
a18 1
 * @@version $Id: ExportHtml.java,v 1.3 2001/12/04 22:12:58 stephenreed Exp $
d474 5
d480 11
d501 5
a505 1
                    linkTextNode = htmlDocument.createTextNode(word);
d507 1
d522 5
a526 1
                        linkTextNode = htmlDocument.createTextNode(word);
d528 8
d540 2
d543 1
d584 1
a584 1
        CycList isas = filterSelectedConstants(cycAccess.getIsas(cycFort));
d592 1
d595 60
a654 9
            if (selectedCycForts.contains(isa)) {
                HTMLAnchorElement isaAnchorElement =
                    new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
                isaAnchorElement.setHref("#" + isa.cyclify());
                parentElement.appendChild(isaAnchorElement);
                Node isaTextNode = htmlDocument.createTextNode(isa.cyclify());
                isaAnchorElement.appendChild(isaTextNode);
                Node spacesTextNode = htmlDocument.createTextNode("  ");
                parentElement.appendChild(spacesTextNode);
d657 1
@


1.3
log
@Testing html export
@
text
@d17 1
a17 1
 * @@version $Id: ExportHtml.java,v 1.2 2001/12/04 05:35:40 stephenreed Exp $
d94 12
d205 14
a218 5
            exportHtml.cycKbSubsetCollectionGuid = ExportHtml.counterTerrorismConstantGuid;
            exportHtml.cycKbSubsetFilterGuid = ExportHtml.ikbConstantGuid;
            exportHtml.exportedVocabularyOutputPath = "counter-terrorism-vocabulary.html";
            exportHtml.exportedHierarchyOutputPath = "counter-terrorism-hierarchy.html";
            exportHtml.export(ExportHtml.EXPORT_KB_SUBSET_PLUS_UPWARD_CLOSURE);
@


1.2
log
@Output HTML cyc KB subset
@
text
@d12 1
d17 1
a17 1
 * @@version $Id: ExportHtml.java,v 1.1 2001/12/03 22:07:13 stephenreed Exp $
d139 1
a139 1
     * The HTML export path and file name.
d141 6
a146 1
    public String outputPath = "export.html";
d174 5
d182 1
d195 2
d212 1
a212 1
            System.out.println("Getting terms from Cyc");
d223 1
a223 1
            System.out.println("Selected " + selectedCycForts.size() + " CycFort terms");
d227 1
a227 1
                System.out.println("Upward closure added " + upwardClosureCycForts.size() + " CycFort terms");
d230 1
a230 1
                System.out.println("All selected " + selectedCycForts.size() + " CycFort terms");
d233 1
a233 1
            System.out.println("Sorting " + selectedCycForts.size() + " CycFort terms");
d237 9
a245 36
        if (verbosity > 2)
            System.out.println("Building HTML model");

        for (int i = 0; i < selectedCycForts.size(); i++) {
        //for (int i = 0; i < 20; i++) {

            CycFort cycFort = (CycFort) selectedCycForts.get(i);
            if (verbosity > 2)
                System.out.print(cycFort + "  ");
            if (cycAccess.isCollection(cycFort)) {
                if (verbosity > 2)
                    System.out.println("Collection");
            }
            else if (cycAccess.isPredicate(cycFort)) {
                if (verbosity > 2)
                    System.out.println("Predicate");
            }
            else if (cycAccess.isIndividual(cycFort)) {
                if (verbosity > 2)
                    System.out.print("Individual");
                if (verbosity > 2) {
                    String individualType = "  (type unknown)";
                    System.out.println(individualType);
                }
            }
            else {
                if (verbosity > 2)
                    System.out.println("other");
                continue;
            }
            if (cycFort instanceof CycConstant)
                createCycConstantNode((CycConstant) cycFort);
            else
                createCycNartNode((CycNart) cycFort);
        }
        serialize();
d257 1
a257 1
                System.out.println("Exporting KB subset " + cycKbSubsetCollection.cyclify());
d264 1
a264 1
                System.out.println("Exporting KB subset " + cycKbSubsetCollection.cyclify() +
d273 1
a273 1
                System.out.println("Exporting KB collections below root term " + rootTerm.cyclify() +
d280 8
d289 2
a290 1
        htmlDocument.setTitle("Cyc ontology for " + cycKbSubsetCollection.cyclify());
d294 6
a299 1
    }
d301 30
a330 14
    /**
     * Serializes the HTML document.
     */
    protected void serialize () throws IOException {
        if (verbosity > 2)
            System.out.println("Writing HTML output to " + outputPath);
        OutputFormat outputFormat = new OutputFormat(htmlDocument, "UTF-8", true);
        BufferedWriter htmlOut = new BufferedWriter(new FileWriter(outputPath));
        XHTMLSerializer xhtmlSerializer = new XHTMLSerializer(htmlOut, outputFormat);
        xhtmlSerializer.asDOMSerializer();
        xhtmlSerializer.serialize(htmlDocument);
        htmlOut.close();
        if (verbosity > 2)
            System.out.println("HTML export completed");
d399 1
a399 1
                System.out.println("Unhandled constant: " + cycConstant.toString());
d527 2
a528 1
        System.out.println("isas " + isas);
d558 2
a559 1
        System.out.println("genls " + genls);
d574 1
a574 1
                Node spacesTextNode = htmlDocument.createTextNode("  ");
d578 10
d599 2
a600 1
        System.out.println("genlPreds " + genlPreds);
d659 97
d769 2
a770 2
            else if (verbosity > 2)
                System.out.println(" dropping " + object);
d777 1
a777 1
     * for collection terms, and with regard to genlPreds for predicate terms.
d785 4
d790 3
d797 5
a801 5
                CycList genls = new CycList();
                genls.addAllNew(cycAccess.getAllIsa(cycFort));
                genls.addAllNew(cycAccess.getAllGenls(cycFort));
                for (int j = 0; j < genls.size(); j++) {
                    CycFort genl = null;
d803 1
a803 1
                        genl = (CycFort) genls.get(j);
d806 1
a806 1
                        System.out.println("***** Invalid genl: " + genls.get(j));
d809 3
a811 2
                    if ((!upwardClosure.contains(genl)) && (!selectedCycForts.contains(genl)) && cycAccess.isa(genl,
                            cycKbSubsetFilter)) {
d813 3
a815 2
                            System.out.println("Upward closure genl " + genl);
                        upwardClosure.add(genl);
d819 9
a827 6
            else if ((cycFort instanceof CycConstant) && (cycAccess.isBinaryPredicate((CycConstant)cycFort))) {
                CycList genlPreds = cycAccess.getAllGenlPreds((CycConstant)cycFort);
                for (int j = 0; j < genlPreds.size(); j++) {
                    CycFort genlPred = (CycFort)genlPreds.get(j);
                    if ((!upwardClosure.contains(genlPred)) && (!selectedCycForts.contains(genlPred))
                            && cycAccess.isa(genlPred, cycKbSubsetFilter)) {
d829 3
a831 2
                            System.out.println("Upward closure genlPred " + genlPred);
                        upwardClosure.add(genlPred);
@


1.1
log
@Initial check in
@
text
@d16 1
a16 1
 * @@version $Id: ExportHtml.java,v 1.8 2001/11/01 22:07:43 stephenreed Exp $
d152 14
a165 9
    private Element htmlBodyElement;
    private Guid guid;
    private String name;
    private ArrayList selectedConstants = new ArrayList();
    private CycConstant cycConstant;
    private String comment;
    private CycList isas;
    private CycList genls;
    private CycList genlPreds;
d181 5
a185 6
            Guid transportationDeviceGuid =
                CycObjectFactory.makeGuid("bd58d540-9c29-11b1-9dad-c379636f7270");
            exportHtml.rootTermGuid = transportationDeviceGuid;
            exportHtml.cycKbSubsetFilterGuid = ExportHtml.counterTerrorismConstantGuid;
            exportHtml.export(ExportHtml.EXPORT_KB_SUBSET_BELOW_TERM);
        } catch (Exception e) {
a198 2
        CycList selectedConstants = new CycList();
        CycList selectedCycForts = null;
a217 5
        for (int i = 0; i < selectedCycForts.size(); i++) {
            CycFort selectedCycFort = (CycFort)selectedCycForts.get(i);
            if (selectedCycFort instanceof CycConstant)
                selectedConstants.add(selectedCycFort);
        }
d219 4
a222 3
            System.out.println("Sorting " + selectedConstants.size() + " CycConstant terms");
        Collections.sort(selectedConstants);
        //createConstantNode("PhysicalDevice");
d225 5
a229 3
        //for (int i = 0; i < selectedConstants.size(); i++) {
        for (int i = 0; i < 60; i++) {
            CycConstant cycConstant = (CycConstant) selectedConstants.get(i);
d231 2
a232 2
                System.out.print(cycConstant + "  ");
            if (cycAccess.isCollection(cycConstant)) {
d236 1
a236 1
            else if (cycAccess.isPredicate(cycConstant)) {
d240 1
a240 1
            else if (cycAccess.isIndividual(cycConstant)) {
a242 1
                populateIsas(cycConstant);
a244 6
                    if (isas != null)
                        for (int j = 0; j < isas.size(); j++)
                            if (!isas.get(j).equals(cycKbSubsetCollection)) {
                                individualType = (" (a " + isas.get(j) + ")");
                                break;
                            }
d253 4
a256 1
            createConstantNode(cycConstant);
a297 2


d317 2
a318 3
     * Populates the comment for a Cyc term.
     *
     * @@parameter cycConstant the Cyc term for which the comment is obtained.
d320 21
a340 36
    protected void populateComment (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        comment = cycAccess.getComment(cycConstant);
    }

    /**
     * Populates the isas for a Cyc term.
     *
     * @@parameter cycConstant the Cyc term for which the isas are obtained.
     */
    protected void populateIsas (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        isas = cycAccess.getIsas(cycConstant);
        isas = filterSelectedConstants(isas);
    }

    /**
     * Populates the genls for a Cyc term.
     *
     * @@parameter cycConstant the Cyc term for which the genls are obtained.
     */
    protected void populateGenls (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        genls = cycAccess.getGenls(cycConstant);
        genls = filterSelectedConstants(genls);
    }

    /**
     * Populates the genlPreds for a Cyc predicate.
     *
     * @@parameter cycConstant the Cyc predicate for which the genlPreds are obtained.
     */
    protected void populateGenlPreds (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        genlPreds = cycAccess.getGenlPreds(cycConstant);
        genlPreds = filterSelectedConstants(genlPreds);
d347 27
a373 5
    protected void createConstantNode (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        guid = cycConstant.getGuid();
        populateComment(cycConstant);
        //populateIsas(cycConstant);
d375 1
a375 1
            createCollectionNode(cycConstant);
d377 1
a377 1
            createPredicateNode(cycConstant);
d379 1
a379 1
            createIndividualNode(cycConstant);
d396 2
d399 1
a399 1
    protected void lineBreak () {
d401 1
a401 1
        htmlBodyElement.appendChild(breakElement);
d415 3
d419 8
a426 1
    protected void createCommentNodes () throws IOException, CycApiException {
d438 2
a439 1
                    selectedConstants.contains(commentConstant)) {
d441 1
a441 1
                    htmlDocument.appendChild(commentTextNode);
d445 1
a445 1
                    htmlDocument.appendChild(htmlAnchorElement);
d454 2
a455 1
                        selectedConstants.contains(commentConstant)) {
d457 1
a457 1
                        htmlDocument.appendChild(commentTextNode);
d461 1
a461 1
                        htmlDocument.appendChild(htmlAnchorElement);
d478 110
a587 1
            htmlDocument.appendChild(commentTextNode);
d595 1
d597 6
a602 26
    protected void createIndividualNode (CycConstant cycConstant) throws UnknownHostException, IOException,
            CycApiException {
        if (isas == null || isas.size() == 0)
            return;
        horizontalRule();
        Element boldElement = htmlDocument.createElement("bold");
        htmlBodyElement.appendChild(boldElement);
        Node individualTextNode = htmlDocument.createTextNode(cycConstant.cyclify());
        boldElement.appendChild(individualTextNode);
        /*
        Element individualNode = document.createElement(isas.get(0).toString());
        rdf.appendChild(individualNode);
        individualNode.setAttributeNS(rdfsNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        String label = cycAccess.getSingularGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            System.out.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        individualNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        individualNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        individualNode.appendChild(guidNode);
        */
d607 1
d609 1
d611 2
a612 1
    protected void createCollectionNode (CycConstant cycConstant) throws UnknownHostException, IOException,
d614 1
a614 78
        horizontalRule();
        HTMLFontElement htmlFontElement = new HTMLFontElementImpl((HTMLDocumentImpl) htmlDocument, "font");
        htmlFontElement.setSize("+1");
        htmlBodyElement.appendChild(htmlFontElement);
        HTMLAnchorElement collectionAnchorElement =
            new HTMLAnchorElementImpl((HTMLDocumentImpl) htmlDocument, "a");
        collectionAnchorElement.setName(cycConstant.cyclify());
        htmlFontElement.appendChild(collectionAnchorElement);
        Node collectionTextNode = htmlDocument.createTextNode(cycConstant.cyclify());
        collectionAnchorElement.appendChild(collectionTextNode);
        lineBreak();
        this.createCommentNodes();
        /*
        populateGenls(cycConstant);
        populateDisjointWiths(cycConstant);
        populateCoExtensionals(cycConstant);
        Element classNode = document.createElementNS(damlNamespace, "daml:Class");
        rdf.appendChild(classNode);
        classNode.setAttributeNS(rdfNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        String label = null;
        label = cycAccess.getPluralGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            System.out.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        classNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        classNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        classNode.appendChild(guidNode);
        Element sameClassAsNode;
        if (cycConstant.equals(cycAccess.thing)) {
            sameClassAsNode = document.createElementNS(damlNamespace, "daml:sameClassAs");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", damlThing);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.binaryPredicate)) {
            sameClassAsNode = document.createElementNS(damlNamespace, "daml:sameClassAs");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", damlProperty);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.getKnownConstantByName("TransitiveBinaryPredicate"))) {
            sameClassAsNode = document.createElementNS(damlNamespace, "daml:sameClassAs");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", damlTransitiveProperty);
            classNode.appendChild(sameClassAsNode);
        }
        else if (cycConstant.equals(cycAccess.collection)) {
            sameClassAsNode = document.createElementNS(damlNamespace, "daml:sameClassAs");
            sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", damlClass);
            classNode.appendChild(sameClassAsNode);
        }
        if (isas != null)
            for (int i = 0; i < isas.size(); i++) {
                Element typeNode = document.createElementNS(rdfNamespace, "rdf:type");
                typeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm((CycConstant)isas.get(i)));
                classNode.appendChild(typeNode);
            }
        if (genls != null)
            for (int i = 0; i < genls.size(); i++) {
                Element subClassNode = document.createElementNS(rdfsNamespace, "rdfs:subClassOf");
                subClassNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm((CycConstant)genls.get(i)));
                classNode.appendChild(subClassNode);
            }
        if (disjointWiths != null)
            for (int i = 0; i < disjointWiths.size(); i++) {
                Element disjointWithNode = document.createElementNS(damlNamespace, "daml:disjointWith");
                disjointWithNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm((CycConstant)disjointWiths.get(i)));
                classNode.appendChild(disjointWithNode);
            }
        if (coExtensionals != null)
            for (int i = 0; i < coExtensionals.size(); i++) {
                sameClassAsNode = document.createElementNS(damlNamespace, "daml:sameClassAs");
                sameClassAsNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm((CycConstant)coExtensionals.get(i)));
                classNode.appendChild(sameClassAsNode);
            }
        */
d621 1
d623 1
a623 1
    protected void createPredicateNode (CycConstant cycConstant)
d625 1
a625 45
        /*
        populateGenlPreds(cycConstant);
        populateArg1Isa(cycConstant);
        populateArg2Isa(cycConstant);
        populateArg1Format(cycConstant);
        populateArg2Format(cycConstant);
        Element propertyNode;
        if ((arg1Format != null) && arg1Format.equals("SingleEntry"))
            propertyNode = document.createElementNS(damlNamespace, "daml:UnambiguousProperty");
        else if ((arg2Format != null) && arg2Format.equals("SingleEntry"))
            propertyNode = document.createElementNS(damlNamespace, "daml:UniqueProperty");
        else
            propertyNode = document.createElementNS(damlNamespace, "daml:Property");
        rdf.appendChild(propertyNode);
        propertyNode.setAttributeNS(rdfsNamespace, "rdf:ID", cycConstant.toString());
        Element labelNode = document.createElementNS(rdfsNamespace, "rdfs:label");
        String label = null;
        label = cycAccess.getGeneratedPhrase(cycConstant);
        if (verbosity > 2)
            System.out.println("  " + label);
        labelNode.appendChild(document.createTextNode(label));
        propertyNode.appendChild(labelNode);
        Element commentNode = document.createElementNS(rdfsNamespace, "rdfs:comment");
        commentNode.appendChild(document.createTextNode(comment));
        propertyNode.appendChild(commentNode);
        Element guidNode = document.createElement("guid");
        guidNode.appendChild(document.createTextNode(guid.toString()));
        propertyNode.appendChild(guidNode);
        if (genlPreds != null)
            for (int i = 0; i < genlPreds.size(); i++) {
                Element subPropertyOfNode = document.createElementNS(damlNamespace, "daml:subPropertyOf");
                subPropertyOfNode.setAttributeNS(rdfNamespace, "rdf:resource", "#" + genlPreds.get(i).toString());
                propertyNode.appendChild(subPropertyOfNode);
            }
        if (arg1Isa != null) {
            Element domainNode = document.createElementNS(damlNamespace, "daml:domain");
            domainNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg1Isa));
            propertyNode.appendChild(domainNode);
        }
        if (arg2Isa != null) {
            Element rangeNode = document.createElementNS(damlNamespace, "daml:range");
            rangeNode.setAttributeNS(rdfNamespace, "rdf:resource", translateTerm(arg2Isa));
            propertyNode.appendChild(rangeNode);
        }
        */
a627 1

d640 1
a640 1
            if (selectedConstants.contains(object))
d642 2
a643 2
            else if (verbosity > 4)
                System.out.println(" dropping " + cycConstant);
@

