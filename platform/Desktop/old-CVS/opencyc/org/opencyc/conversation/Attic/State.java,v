head	1.6;
access;
symbols
	PRE_1_0:1.6;
locks; strict;
comment	@# @;


1.6
date	2002.11.20.16.39.08;	author stephenreed;	state dead;
branches;
next	1.5;

1.5
date	2002.03.01.15.18.05;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.28.22.44.22;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.28.06.02.23;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.25.22.44.36;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.18.16.08.34;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Removing previous state machine implementation which is
replaced by org.opencyc.uml.statemachine package
@
text
@package org.opencyc.conversation;

import java.util.*;

/**
 * Contains the attributes and behavior of a chat fsm Finite
 * State Machine State.<p>
 *
 * @@version $Id: State.java,v 1.5 2002/03/01 15:18:05 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class State implements Comparable {

    /**
     * state identifier within the fsm
     */
    protected String stateId;

    /**
     * performative name --> Arc
     */
    protected HashMap arcs = new HashMap();

    /**
     * Constructs a new State object.
     *
     * @@param stateId unique state identifier within the fsm
     */
    public State(String stateId) {
        this.stateId = stateId;
    }

    /**
     * Constructs a new State object.
     *
     * @@param stateId unique state identifier within the fsm
     * @@param fsmClass the fsm class containing this new state
     */
    public State(String stateId, FsmClass fsmClass) {
        this.stateId = stateId;
        fsmClass.addState(this);
    }

    /**
     * Constructs a new State object.
     *
     * @@param stateId unique state identifier within the fsm
     * @@param fsm the fsm containing this new state
     */
    public State(String stateId, Fsm fsm) {
        this.stateId = stateId;
        fsm.addState(this);
    }

    /**
     * Returns the state id.
     *
     * @@return the state id
     */
    public String getStateId () {
        return stateId;
    }

    /**
     * Returns the collection of the arcs from this state.
     *
     * @@return the collection of the arcs from this state
     */
    public Collection getArcs () {
        return arcs.values();
    }

    /**
     * Records the arc to take when the its performative is observed.
     *
     * @@param arc the FSM arc which specifies a transition-to state and an action
     */
    public void addArc (Arc arc) {
         addArc(arc.getPerformative(), arc);
    }

    /**
     * Records the arc to take when the given performative is observed.
     *
     * @@param performative the given performative
     * @@param arc the FSM arc which specifies a transition-to state and an action
     */
    public void addArc (Performative performative,
                                 Arc arc) {
         arcs.put(performative.performativeName, arc);
    }

    /**
     * Returns the arc to take for the given performative.
     *
     * @@param performative the given performative
     * @@return the FSM arc which specifies a transition-to state and an action
     */
    public Arc getArc (Performative performative) {
        return (Arc) arcs.get(performative.performativeName);
    }

    /**
     * Compares this object with the specified object for order.
     * Returns a negative integer, zero, or a positive integer as this
     * object is less than, equal to, or greater than the specified object.
     *
     * @@param object the reference object with which to compare.
     * @@return a negative integer, zero, or a positive integer as this
     * object is less than, equal to, or greater than the specified object
     */
     public int compareTo (Object object) {
        if (! (object instanceof State))
            throw new ClassCastException("Must be a State object");
        return this.stateId.compareTo(((State) object).stateId);
     }

    /**
     * Returns <tt>true</tt> iff some object equals this object
     *
     * @@param object the <tt>Object</tt> for equality comparison
     * @@return equals <tt>boolean</tt> value indicating equality or non-equality.
     */
    public boolean equals(Object object) {
        if (! (object instanceof State))
            return false;
        return ((State) object).stateId.equals(stateId) &&
               ((State) object).arcs.equals(arcs);
    }

    /**
     * Returns the string representation of the <tt>State</tt>
     *
     * @@return the representation of the <tt>State</tt> as a <tt>String</tt>
     */
    public String toString() {
        StringBuffer stringBuffer = new StringBuffer();
        stringBuffer.append("\n  ");
        stringBuffer.append(stateId.toString());
        stringBuffer.append(", ");
        stringBuffer.append(arcs.size());
        stringBuffer.append(" arcs");
        Iterator arcsIterator = arcs.values().iterator();
        while (arcsIterator.hasNext()) {
            Arc arc = (Arc) arcsIterator.next();
            stringBuffer.append("\n    ");
            stringBuffer.append(arc.toString());
        }
        return stringBuffer.toString();
    }

    /**
     * Creates a clone of this object.
     */
    public Object clone () {
        State state = new State(this.stateId);
        state.arcs = (HashMap) this.arcs.clone();
        return state;
    }

}@


1.5
log
@Added validation to the Fsm and FsmClass classes
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.4 2002/02/28 22:44:22 stephenreed Exp $
@


1.4
log
@Renamed Conversation*.java to Fsm*.java
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.3 2002/02/28 06:02:23 stephenreed Exp $
d38 1
a38 1
     * performative --> Arc
d108 1
a108 1
         arcs.put(performative, arc);
d118 1
a118 1
        return (Arc) arcs.get(performative);
d155 13
a167 1
        return stateId;
@


1.3
log
@Refactored use of sub conversations
@
text
@d6 1
a6 1
 * Contains the attributes and behavior of a chat conversation Finite
d9 1
a9 1
 * @@version $Id: State.java,v 1.2 2002/02/25 22:44:36 stephenreed Exp $
d33 1
a33 1
     * state identifier within the conversation
d45 1
a45 1
     * @@param stateId unique state identifier within the conversation
d54 2
a55 2
     * @@param stateId unique state identifier within the conversation
     * @@param conversation the conversation containing this new state
d57 1
a57 1
    public State(String stateId, Conversation conversation) {
d59 1
a59 1
        conversation.addState(this);
d65 2
a66 4
     * @@param stateId unique state identifier within the conversation
     * @@param conversation the conversation containing this new state
     * @@param isInitialState when true, this is the initial state of the
     * conversation
d68 1
a68 1
    public State(String stateId, Conversation conversation, boolean isInitialState) {
d70 1
a70 3
        conversation.addState(this);
        if (isInitialState)
            conversation.setInitialState(this);
d156 9
@


1.2
log
@Added more methods.
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.1 2002/02/18 16:08:34 stephenreed Exp $
d44 2
d49 26
@


1.1
log
@Renamed chatterbot classes, add finite state machine for dialog, and template parser for understanding chat messages.
@
text
@d9 1
a9 1
 * @@version $Id: State.java,v 1.2 2002/02/11 20:14:24 stephenreed Exp $
a42 5
     * Dictionary of attribute and object values.
     */
    protected HashMap attributes = new HashMap();

    /**
a96 19
    /**
     * Sets the value for the given attribute.
     *
     * @@param attribute the key object
     * @@param value the value object
     */
    public void set (String attribute, Object value) {
        attributes.put(attribute, value);
    }

    /**
     * Returns the value for the given attribute.
     *
     * @@param attribute the key object
     * @@retrun the value for the given attribute
     */
    public Object get (Object attribute) {
        return attributes.get(attribute);
    }
@

