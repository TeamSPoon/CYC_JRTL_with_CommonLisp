head	1.7;
access;
symbols
	PRE_1_0:1.7;
locks; strict;
comment	@# @;


1.7
date	2002.02.28.22.44.22;	author stephenreed;	state dead;
branches;
next	1.6;

1.6
date	2002.02.28.06.02.23;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.27.03.40.50;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.26.23.33.06;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.25.22.44.36;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.20.23.11.00;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.18.16.08.34;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Renamed Conversation*.java to Fsm*.java
@
text
@package org.opencyc.conversation;

import java.util.*;
import org.opencyc.chat.*;
import org.opencyc.templateparser.*;

/**
 * Makes chat conversations which can be interpreted by the Interpreter.<p>
 *
 * The chat conversation is in the form of a text conversation using
 * asynchronous receiving and sending of messages.
 *
 * @@version $Id: ConversationFactory.java,v 1.6 2002/02/28 06:02:23 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class ConversationFactory {

    /**
     * Caches conversation objects to keep from making them twice.
     * name --> Conversation
     */
    protected static HashMap conversationCache = new HashMap();

    /**
     * Arcs which apply to every state.
     */
    protected static ArrayList globalArcs = new ArrayList();

    /**
     * Template object factory
     */
    protected TemplateFactory templateFactory;

    protected static final State currentState =
        new State("currentState");

    /**
     * Constructs a new ConversationFactory object.
     */
    public ConversationFactory() {
        templateFactory = new TemplateFactory();
    }

    /**
     * Resets the conversation caches.
     */
    public static void reset() {
        globalArcs = new ArrayList();
        conversationCache = new HashMap();
    }

    /**
     * Initializes this object.
     */
    public void initialize () {
        templateFactory.makeAllTemplates();
        makeAllGlobalArcs();
        makeAllConversations();
    }

    /**
     * Initializes the global arcs
     */
    protected void makeAllGlobalArcs () {
        makeQuitArc();
        makeDoNotUnderstoodArc();
    }

    /**
     * Initialize all the conversations.
     */
    protected void makeAllConversations () {
        makeChat();
        makeDisambiguateTermQuery();
        makeDisambiguatePhrase();
        makeTermQuery();
        fixupSubConversationForwardReferences();
    }

    /**
     * Returns the Conversation having the given name;
     *
     * @@param name the conversation name
     */
    public Conversation getConversation (String name) {
        return (Conversation) conversationCache.get(name);
    }

    /**
     * Returns the list of arcs which apply to every state.
     *
     * @@return the list of arcs which apply to every state
     */
    public ArrayList getGlobalArcs () {
        return this.getGlobalArcs();
    }

    /**
      * Makes a "do-not-understand" arc for every conversation state.
      * Initial state is current-state.
      * 1. If we are in the current-state state and get a not-understand performative,
      * transition to the current-state state, and perform the do-not-understand action. <br>
      */
    public void makeDoNotUnderstoodArc () {
        Performative notUnderstandPerformative =
            new Performative("not-understand");
        Action doNotUnderstandAction =
            new Action("do-not-understand");
        Arc notUnderstandArc =
            new Arc(currentState,
                    notUnderstandPerformative,
                    currentState,
                    null,
                    doNotUnderstandAction);
        globalArcs.add(notUnderstandArc);
    }

    /**
      * Makes a "quit" arc for every conversation state.
      * Initial state is current-state.
      * 1. If we are in the current-state state and get a quit performative,
      * transition to the final state, and perform the do-finalization action. <br>
      */
    public void makeQuitArc () {
        Performative quitPerformative =
            new Performative("quit");
        State finalState = new State("final");
        Action doFinalizationAction =
            new Action("do-finalization");
       Arc quitArc = new Arc(currentState,
                             quitPerformative,
                             finalState,
                             null,
                             doFinalizationAction);

        globalArcs.add(quitArc);
    }

    /**
      * Makes a "chat" Conversation.
      * Initial state is ready.
      * 1. If we are in the ready state and get a disambiguate-term-query performative,
      * transition to the ready state and perform the do-disambiguate-term-query action. <br>
      */
    public Conversation makeChat () {
        Conversation chat = (Conversation) conversationCache.get("chat");
        if (chat != null)
            return chat;
        chat = new Conversation("chat");
        State readyState = new State("ready");
        chat.setInitialState(readyState);
        chat.addState(readyState);

        Performative disambiguateTermQueryPerformative =
            new Performative("disambiguate-term-query");
        Conversation disambiguateTermQuery = new Conversation ("disambiguate-term-query");

        /**
          * 1. If we are in the ready state and get a disambiguate-term-query performative,
          * transition to the ready state and perform the do-disambiguate-term-query action. <br>
         */
        Arc arc1 = new Arc(readyState,
                           disambiguateTermQueryPerformative,
                           readyState,
                           disambiguateTermQuery,
                           null);
        conversationCache.put(chat.name, chat);
        return chat;
    }

    /**
     * Makes a "disambiguate-term-query" Sub Conversation.  <br>
     * Input "disambiguation words" --> ArrayList disambiguationWords <br>
     *
     * Initial state is start. <br>
     * 1. If we are in the start state and get a start-new-conversation performative,
     * transition to the disambiguate-phrase state and perform the
     * disambiguate-phrase sub conversation. <br>
     *
     * 2. If we are in the disambiguate-phrase state and get a resume-previous-conversation
     * performative, transition to the term-query state and perform the
     * term-query sub conversation. <br>
     *
     * 3. If we are in the term-query state and get a resume-previous-conversation performative,
     * transition to the end state and perform the
     * end-sub-conversation action. <br>
     */
    public Conversation makeDisambiguateTermQuery () {
        Conversation disambiguateTermQuery =
            (Conversation) conversationCache.get("disambiguate-term-query");
        if (disambiguateTermQuery != null)
            return disambiguateTermQuery;
        disambiguateTermQuery = new Conversation("disambiguate-term-query");

        State startState = new State("start", disambiguateTermQuery, true);
        State disambiguatePhraseState = new State("disambiguate-phrase", disambiguateTermQuery);
        State termQueryState = new State("term-query-phrase", disambiguateTermQuery);
        State endState = new State("end", disambiguateTermQuery);

        /**
         * 1. If we are in the start state and get a start-new-conversation performative,
         * transition to the disambiguate-phrase state and perform the
         * disambiguate-phrase sub conversation.
         */
        new Arc(startState,
                new Performative("start"),
                disambiguatePhraseState,
                new Conversation("disambiguate-phrase"),
                null);

        /**
         * 2. If we are in the disambiguate-phrase state and get a resume-previous-conversation
         * performative, transition to the term-query state and perform the
         * term-query sub conversation.
         */
        new Arc(disambiguatePhraseState,
                new Performative("resume-previous-conversation"),
                termQueryState,
                new Conversation("term-query"),
                null);

        /**
         * 3. If we are in the term-query state and get a resume-previous-conversation performative,
         * transition to the end state and perform the
         * end-sub-conversation action.
         */
        new Arc(termQueryState,
                new Performative("resume-previous-conversation"),
                endState,
                new Conversation("end-sub-conversation"),
                null);

        conversationCache.put(disambiguateTermQuery.name, disambiguateTermQuery);
        return disambiguateTermQuery;
    }

    /**
     * Makes a "disambiguate-phrase" Sub Conversation.  <br>
     * Input "disambiguation words" --> ArrayList disambiguationWords <br>
     * Output "disambiguated term" --> CycFort disambiguatedTerm <br>
     *
     * Initial state is start. <br>
     * 1. If we are in the start state and get a start performative,
     * transition to the disambiguate-phrase state and perform the
     * do-disambiguate-parse-phase action. <br>
     *
     * 2. If we are in the disambiguate-phrase state and get a term-match performative,
     * transition to the end state and perform the do-end-sub-conversation action. <br>
     *
     * 3. If we are in the disambiguate-phrase state and get a term-choice performative,
     * transition to the term-choice state and perform the do-disambiguate-term-choice action. <br>
     *
     * 4. If we are in the term-choice state and get a choice-is-number performative,
     * transition to (stay in) the term-choice state and perform the
     * do-disambiguate-choice-is-number action. <br>
     *
     * 5. If we are in the term-choice state and get a choice-is-phrase performative,
     * transition to (stay in) the term-choice state and perform the
     * do-disambiguate-choice-is-term action. <br>
     *
     * 6. If we are in the term-choice state and get an end performative,
     * transition to the end state and perform the do-end-sub-conversation action. <br>
     */
    public Conversation makeDisambiguatePhrase () {
        Conversation disambiguatePhrase =
            (Conversation) conversationCache.get("disambiguate-phrase");
        if (disambiguatePhrase != null)
            return disambiguatePhrase;
        disambiguatePhrase = new Conversation("disambiguate-phrase");

        State startState = new State("start", disambiguatePhrase, true);
        State disambiguatePhraseState = new State("disambiguate-phrase", disambiguatePhrase);
        State termChoiceState = new State("term-choice", disambiguatePhrase);
        State endState = new State("end", disambiguatePhrase);

        /**
         * 1. If we are in the start state and get a start performative,
         * transition to the disambiguate-phrase state and perform the
         * do-disambiguate-parse-phrase action.
         */
        new Arc(startState,
                new Performative("start"),
                disambiguatePhraseState,
                null,
                new Action("do-disambiguate-parse-phrase"));

        /**
         * 2. If we are in the disambiguate-phrase state and get a term-match performative,
         * transition to the end state and perform the do-end-sub-conversation action.
         */
        new Arc(disambiguatePhraseState,
                new Performative("term-match"),
                endState,
                null,
                new Action("do-end-sub-conversation"));

        /**
         * 3. If we are in the disambiguate-phrase state and get a term-choice performative,
         * transition to the term-choice state and perform the do-disambiguate-term-choice action.
         */
        new Arc(disambiguatePhraseState,
                new Performative("term-choice"),
                termChoiceState,
                null,
                new Action("do-disambiguate-term-choice"));
        /**
         * 4. If we are in the term-choice state and get a choice-is-number performative,
         * transition to (stay in) the term-choice state and perform the
         * do-disambiguate-choice-is-number action.
         */
        new Arc(termChoiceState,
                new Performative("choice-is-number"),
                termChoiceState,
                null,
                new Action("do-disambiguate-choice-is-number"));
        /**
         * 5. If we are in the term-choice state and get a choice-is-phrase performative,
         * transition to (stay in) the term-choice state and perform the
         * do-disambiguate-choice-is-term action.
         */
        new Arc(termChoiceState,
                new Performative("choice-is-phrase"),
                termChoiceState,
                null,
                new Action("do-disambiguate-choice-is-term"));
        /**
         * 6. If we are in the term-choice state and get an end performative,
         * transition to the end state and perform the do-end-sub-conversation action.
         */
        new Arc(termChoiceState,
                new Performative("end"),
                endState,
                null,
                new Action("do-end-sub-conversation"));

        conversationCache.put(disambiguatePhrase.name, disambiguatePhrase);
        return disambiguatePhrase;
    }

    /**
     * Makes a "term-query" Conversation. <br>
     *
     * input "disambiguated term" --> CycFort disambiguatedTerm <br>
     *
     * Initial state is start. <br>
     *
     * 1. If we are in the start state and get a term-query performative, transition to the
     * retrieve-first-fact state and perform the do-reply-with-first-fact action. <br>
     *
     * 2. If we are in the retrieve-first-fact state and get a more performative, transition to the
     * prompt-for-more state and perform the do-reply-with-next-fact action. <br>
     *
     * 3. If we are in the prompt-for-more state and get a done performative, transition to the end
     * state and perform the do-end-sub-conversation action.
     */
    public Conversation makeTermQuery () {
        Conversation termQuery = (Conversation) conversationCache.get("term-query");
        if (termQuery != null)
            return termQuery;
        termQuery = new Conversation("term-query");

        State startState = new State("start", termQuery, true);
        State retrieveFactState = new State("retrieve-fact", termQuery);
        State promptForMoreState = new State("prompt-for-more", termQuery);
        State endState = new State("end", termQuery);

        /**
         * 1. If we are in the start state and get a term-query performative, transition to the
         * retrieve-first-fact state and perform the do-reply-with-first-fact action.
         */
        new Arc(startState,
                new Performative("term-query"),
                retrieveFactState,
                null,
                new Action("do-reply-with-first-fact"));


        /**
         * 2. If we are in the retrieve-first-fact state and get a more performative, transition to the
         * prompt-for-more state and perform the do-reply-with-next-fact action.
         */
        new Arc(retrieveFactState,
                new Performative("more"),
                promptForMoreState,
                null,
                new Action("do-reply-with-next-fact"));
        /**
         * 3. If we are in the prompt-for-more state and get a done performative, transition to the end
         * state and perform the do-end-sub-conversation action.
         */
        new Arc(promptForMoreState,
                new Performative("done"),
                endState,
                null,
                new Action("do-end-sub-conversation"));

        conversationCache.put(termQuery.name, termQuery);
        return termQuery;
    }

    /**
     * Fixes up the sub conversation forward references.
     */
    protected void fixupSubConversationForwardReferences () {
        Iterator conversations = conversationCache.values().iterator();
        ArrayList conversationsList = new ArrayList();
        while (conversations.hasNext())
            conversationsList.add(conversations.next());
        for (int j = 0; j < conversationsList.size(); j++) {
            ArrayList statesList = new ArrayList();
            Conversation conversation = (Conversation) conversationsList.get(j);
            Iterator states = conversation.conversationFsmStates.values().iterator();
            while (states.hasNext())
                statesList.add(states.next());
            for (int i = 0; i < statesList.size(); i++) {
                State state = (State) statesList.get(i);
                Iterator arcs = state.getArcs().iterator();
                while (arcs.hasNext()) {
                    Arc arc = (Arc) arcs.next();
                    Conversation subConversation = arc.getSubConversation();
                    if ((arc.getSubConversation() != null) &&
                        (! conversationsList.contains(subConversation))) {
                        arc.setSubConversation(this.getConversation(subConversation.getName()));
                    }
                }
            }
        }
    }
}
@


1.6
log
@Refactored use of sub conversations
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.5 2002/02/27 03:40:50 stephenreed Exp $
@


1.5
log
@Added more code to Performer
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.4 2002/02/26 23:33:06 stephenreed Exp $
a47 5
     * Action object factory
     */
    protected ActionFactory actionFactory;

    /**
a58 1
        actionFactory = new ActionFactory();
d92 2
a93 1
        makeDisambiguateTerm();
d95 1
d131 1
d151 1
d160 2
a161 2
      * 1. If we are in the ready state and get a term-query performative, transition to the ready state
      * and perform the do-term-query action. <br>
d172 4
a175 4
        Performative termQueryPerformative =
            new Performative("term-query");
        Action doTermQueryAction =
            new Action("do-term-query");
d177 2
a178 2
         * 1. If we are in the ready state and get a term-query performative, transition
         * to the ready state and perform the do-term-query action.
d181 1
a181 1
                           termQueryPerformative,
d183 2
a184 1
                           doTermQueryAction);
d190 70
a259 1
     * Makes a "disambiguate-term" Conversation.
d262 31
a292 41
     * transition to the disambiguate-term state and perform the
     * disambiguate-parse-term action. <br>
     * 2. If we are in the disambiguate-term state and get a term-match performative,
     * transition to the done state and perform the
     * disambiguate-term-done action. <br>
     * 3. If we are in the disambiguate-term state and get a term-choice performative,
     * transition to the term-choice state and perform the
     * disambiguate-term-choice action. <br>
     * 4. If we are in the term-choice state and get a term-chosen performative,
     * transition to the done state and perform the
     * disambiguate-term-done action. <br>
     */
    public Conversation makeDisambiguateTerm () {
        Conversation disambiguateTerm = (Conversation) conversationCache.get("disambiguate-term");
        if (disambiguateTerm != null)
            return disambiguateTerm;
        disambiguateTerm = new Conversation("disambiguate-term");

        State startState = new State("start");
        disambiguateTerm.addState(startState);
        disambiguateTerm.setInitialState(startState);
        State disambiguateTermState = new State("disambiguate-term");
        disambiguateTerm.addState(disambiguateTermState);
        State termChoiceState = new State("term-choice");
        disambiguateTerm.addState(termChoiceState);
        State doneState = new State("done");
        disambiguateTerm.addState(doneState);

        Action disambiguateParseTermAction =
            actionFactory.makeAction("do-disambiguate-parse-term");
        Action disambiguateTermDoneAction =
            actionFactory.makeAction("do-disambiguate-term-done");
        Action disambiguateTermChoiceAction =
            actionFactory.makeAction("do-disambiguate-term-choice");

        Performative startPerformative = new Performative("start");
        Performative termMatchPerformative = new Performative("term-match");
        Performative termChoicePerformative = new Performative("term-choice");
        Performative termChosenPerformative = new Performative("term-chosen");

        disambiguateTerm.setDefaultPerformative(startPerformative);
d296 2
a297 2
         * transition to the disambiguate-term state and perform the
         * disambiguate-parse-term action. <br>
d299 5
a303 4
        Arc arc1 = new Arc(startState,
                           startPerformative,
                           disambiguateTermState,
                           disambiguateParseTermAction);
d306 2
a307 3
         * 2. If we are in the disambiguate-term state and get a term-match performative,
         * transition to the done state and perform the
         * disambiguate-term-done action.
d309 5
a313 4
        Arc arc2 = new Arc(disambiguateTermState,
                           termMatchPerformative,
                           doneState,
                           disambiguateTermDoneAction);
d316 12
a327 3
         * 3. If we are in the disambiguate-term state and get a term-choice performative,
         * transition to the term-choice state and perform the
         * disambiguate-term-choice action.
d329 5
a333 4
        Arc arc3 = new Arc(disambiguateTermState,
                           termChoicePerformative,
                           termChoiceState,
                           disambiguateTermChoiceAction);
d335 3
a337 3
         * 4. If we are in the term-choice state and get a term-chosen performative,
         * transition to the done state and perform the
         * disambiguate-term-done action.
d339 14
a352 4
        Arc arc4 = new Arc(termChoiceState,
                           termChosenPerformative,
                           doneState,
                           disambiguateTermDoneAction);
d354 2
a355 2
        conversationCache.put(disambiguateTerm.name, disambiguateTerm);
        return disambiguateTerm;
d359 14
a372 8
     * Makes a "term-query" Conversation.
     * Initial state is retrieve-fact. <br>
     * 1. If we are in the retrieve-fact state and get a term-query performative, transition to the
     * prompt-for-more state and perform the reply-with-first-fact action. <br>
     * 2. If we are in the prompt-for-more state and get a more performative, transition to the
     * prompt-for-more state and perform the reply-with-next-fact action. <br>
     * 3. If we are in the prompt-for-more state and get a done performative, transition to the done
     * state and perform no action.
d380 4
a383 18
        State retrieveFactState = new State("retrieve-fact");
        termQuery.setInitialState(retrieveFactState);
        termQuery.addState(retrieveFactState);

        State promptForMoreState = new State("prompt-for-more");
        termQuery.addState(promptForMoreState);

        State doneState = new State("done");
        termQuery.addState(doneState);

        Action replyWithFirstFactAction =
            actionFactory.makeAction("do-reply-with-first-fact");
        Action replyWithNextFactAction =
            actionFactory.makeAction("do-reply-with-next-fact");

        Performative termQueryPerformative = new Performative("term-query");
        Performative morePerformative = new Performative("more");
        Performative donePerformative = new Performative("done");
d386 2
a387 2
         * 1. If we are in the retrieve-fact state and get a term-query performative, transition
         * to the prompt-for-more state and perform the reply-with-first-fact action.
d389 6
a394 4
        Arc arc1 = new Arc(retrieveFactState,
                           termQueryPerformative,
                           promptForMoreState,
                           replyWithFirstFactAction);
d397 2
a398 2
         * 2. If we are in the prompt-for-more state and get a more performative, transition
         * to the prompt-for-more state and perform the reply-with-next-fact action.
d400 5
a404 4
        Arc arc3 = new Arc(promptForMoreState,
                           morePerformative,
                           promptForMoreState,
                           replyWithNextFactAction);
d406 2
a407 2
         * 3. If we are in the prompt-for-more state and get a done performative, transition to the done
         * state and perform no action.
d409 5
a413 4
        Arc arc4 = new Arc(promptForMoreState,
                           donePerformative,
                           doneState,
                           null);
d417 29
@


1.4
log
@Added code and refactoring Chat Conversation.
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.3 2002/02/25 22:44:36 stephenreed Exp $
d233 2
@


1.3
log
@Added more methods.
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.2 2002/02/20 23:11:00 stephenreed Exp $
d98 1
d191 87
a292 4
        State disambiguateTermsState = new State("disambiguate-terms");
        termQuery.setInitialState(disambiguateTermsState);
        termQuery.addState(disambiguateTermsState);

d294 1
a302 2
        Action disambiguateTermsAction =
            actionFactory.makeAction("disambiguateTerms");
d304 1
a304 1
            actionFactory.makeAction("reply-with-first-fact");
d306 1
a306 1
            actionFactory.makeAction("reply-with-next-fact");
a308 1
        Performative disambiguateTermsPerformative = new Performative("disambiguateTerms");
a310 6
        /**
         * 1. If we are in the disambiguate-terms state and get a , transition
         * to the prompt-for-more state and perform the reply-with-first-fact action.
         */


@


1.2
log
@Continuing to add term disambiguation conversation
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.1 2002/02/18 16:08:34 stephenreed Exp $
d230 1
a230 1
         * 1. If we are in the disambiguate-terms state and get a term-query performative, transition
@


1.1
log
@Renamed chatterbot classes, add finite state machine for dialog, and template parser for understanding chat messages.
@
text
@d13 1
a13 1
 * @@version $Id: ConversationFactory.java,v 1.2 2002/02/11 20:14:24 stephenreed Exp $
d205 4
a209 1
        termQuery.setInitialState(retrieveFactState);
d218 2
d226 1
d229 7
@

