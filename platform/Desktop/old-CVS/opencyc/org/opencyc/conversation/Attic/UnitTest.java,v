head	1.10;
access;
symbols
	PRE_1_0:1.10;
locks; strict;
comment	@# @;


1.10
date	2002.11.20.16.39.09;	author stephenreed;	state dead;
branches;
next	1.9;

1.9
date	2002.03.01.15.18.05;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.28.22.44.22;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.28.06.02.23;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.27.17.54.39;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.27.03.40.50;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.26.03.37.56;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.20.22.44.59;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.19.04.46.11;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.18.16.08.34;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Removing previous state machine implementation which is
replaced by org.opencyc.uml.statemachine package
@
text
@package org.opencyc.conversation;

import junit.framework.*;
import java.util.*;
import org.opencyc.api.*;
import org.opencyc.cycobject.*;
import org.opencyc.templateparser.*;
import org.opencyc.util.*;

/**
 * Provides a unit test suite for the <tt>org.opencyc.fsm</tt> package<p>
 *
 * @@version $Id: UnitTest.java,v 1.9 2002/03/01 15:18:05 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class UnitTest extends TestCase {

    /**
     * Creates a <tt>UnitTest</tt> object with the given name.
     */
    public UnitTest(String name) {
        super(name);
    }

    /**
     * Returns the test suite.
     *
     * @@return the test suite
     */
    public static Test suite() {
        TestSuite testSuite = new TestSuite();
        /*
        testSuite.addTest(new UnitTest("testAction"));
        testSuite.addTest(new UnitTest("testPerformative"));
        testSuite.addTest(new UnitTest("testState"));
        testSuite.addTest(new UnitTest("testArc"));
        */
        testSuite.addTest(new UnitTest("testFsmFactory"));
        //testSuite.addTest(new UnitTest("testInterpreter"));
        //testSuite.addTest(new UnitTest("testPerformer"));
        return testSuite;
    }

    /**
     * Main method in case tracing is prefered over running JUnit GUI.
     */
    public static void main(String[] args) {
        junit.textui.TestRunner.run(suite());
    }

    /**
     * Tests the Action object.
     */
    public void testAction () {
        System.out.println("\n**** testAction ****");
        String name = "my-action";
        Action action = new Action(name);
        Assert.assertNotNull(action);
        Assert.assertEquals(name, action.getName());
        Assert.assertEquals(name, action.toString());
        Action action2 = new Action(name);
        Assert.assertEquals(action, action2);

        System.out.println("**** testAction OK ****");
    }

    /**
     * Tests the Performative object.
     */
    public void testPerformative () {
        System.out.println("\n**** testPerformative ****");
        String performativeName = "my-performative";
        Performative performative =
            new Performative(performativeName);
        Assert.assertNotNull(performative);
        Assert.assertEquals(performativeName,
                            performative.getPerformativeName());
        Assert.assertEquals(performativeName, performative.toString());
        Performative performative2 =
            new Performative(performativeName);
        Assert.assertEquals(performative, performative2);
        performative.setContent(new CycList());
        Assert.assertTrue(! performative.equals(performative2));
        performative2.setContent(new CycList());
        Assert.assertTrue(performative.equals(performative2));

        ArrayList performatives = new ArrayList();
        performatives.add(performative);

        performative2.performativeName = "a-performative";
        performatives.add(performative2);
        Collections.sort(performatives);
        Assert.assertEquals(2, performatives.size());
        Assert.assertEquals(performative2, performatives.get(0));
        Assert.assertEquals(performative, performatives.get(1));

        System.out.println("**** testPerformative OK ****");
    }

    /**
     * Tests the State object.
     */
    public void testState () {
        System.out.println("\n**** testState ****");

        State startState = new State("start");
        Assert.assertNotNull(startState);
        Assert.assertEquals("start", startState.getStateId());
        State finalState = new State("final");
        Assert.assertEquals("final", finalState.getStateId());

        Action doTermQueryAction = new Action("do-term-query");
        Action doFinalizationAction = new Action("do-finalization");
        Performative termQueryPerformative = new Performative("term-query");
        Performative quitPerformative = new Performative("quit");
        /**
         * 1. If we are in the start state and get a term-query performative, transition
         * to the start state and perform the do-term-query action.
         */
        Arc arc1 = new Arc(startState,
                           termQueryPerformative,
                           startState,
                           null,
                           doTermQueryAction);
        Assert.assertNotNull(startState.arcs);
        Assert.assertEquals(1, startState.getArcs().size());
        Assert.assertTrue(startState.getArcs().contains(arc1));
        Assert.assertEquals(arc1, startState.getArc(termQueryPerformative));
        /**
         * 2. If we are in the start state and get a quit performative, transition
         * to the final state and perform the do-finalization action.
         */
        Arc arc2 = new Arc(startState,
                           quitPerformative,
                           finalState,
                           null,
                           doFinalizationAction);
        Assert.assertEquals(2, startState.getArcs().size());
        Assert.assertTrue(startState.getArcs().contains(arc1));
        Assert.assertTrue(startState.getArcs().contains(arc2));
        Assert.assertEquals(arc1, startState.getArc(termQueryPerformative));
        Assert.assertEquals(arc2, startState.getArc(quitPerformative));

        ArrayList states = new ArrayList();
        states.add(startState);
        states.add(finalState);
        Collections.sort(states);
        Assert.assertEquals(2, states.size());
        Assert.assertEquals(finalState, states.get(0));
        Assert.assertEquals(startState, states.get(1));

        System.out.println("**** testState OK ****");
    }

    /**
     * Tests the Arc object.
     */
    public void testArc () {
        System.out.println("\n**** testArc ****");

        State readyState = new State("ready");
        State finalState = new State("final");
        Action doTermQueryAction = new Action("do-term-query");
        Action doFinalizationAction = new Action("do-finalization");
        Performative termQueryPerformative = new Performative("term-query");
        Performative quitPerformative = new Performative("quit");
        /**
         * 1. If we are in the ready state and get a term-query performative, transition
         * to the ready state and perform the do-term-query action.
         */
        Arc arc1 = new Arc(readyState,
                           termQueryPerformative,
                           readyState,
                           null,
                           doTermQueryAction);
        Assert.assertNotNull(arc1);
        Assert.assertEquals(readyState, arc1.transitionFromState);
        Assert.assertEquals(termQueryPerformative, arc1.getPerformative());
        Assert.assertEquals(readyState, arc1.getTransitionToState());
        Assert.assertEquals(doTermQueryAction, arc1.getAction());
        Arc arc1Clone = new Arc(readyState,
                                termQueryPerformative,
                                readyState,
                                null,
                                doTermQueryAction);
        Assert.assertEquals(arc1, arc1Clone);
        Assert.assertEquals("[when term-query performative, transition ready --> ready, then do-term-query]", arc1.toString());
        /**
         * 2. If we are in the ready state and get a quit performative, transition
         * to the final state and perform the do-finalization action.
         */
        Arc arc2 = new Arc(readyState,
                           quitPerformative,
                           finalState,
                           null,
                           doFinalizationAction);
        Assert.assertNotNull(arc2);
        Assert.assertEquals(readyState, arc2.transitionFromState);
        Assert.assertEquals(quitPerformative, arc2.getPerformative());
        Assert.assertEquals(finalState, arc2.getTransitionToState());
        Assert.assertEquals(doFinalizationAction, arc2.getAction());
        Assert.assertTrue(! arc1.equals(arc2));
        Assert.assertEquals("[when quit performative, transition ready --> final, then do-finalization]", arc2.toString());
        ArrayList arcs = new ArrayList();
        arcs.add(arc1);
        arcs.add(arc2);
        Collections.sort(arcs);
        Assert.assertEquals(2, arcs.size());
        Assert.assertEquals(arc2, arcs.get(0));
        Assert.assertEquals(arc1, arcs.get(1));

        System.out.println("**** testArc OK ****");
    }

    /**
     * Tests the FsmFactory object.
     */
    public void testFsmFactory () {
        System.out.println("\n**** testFsmFactory ****");
        FsmFactory.reset();
        FsmFactory fsmFactory = new FsmFactory();
        fsmFactory.setVerbosity(3);
        fsmFactory.makeAllFsmClasses();
        fsmFactory.makeAllFsms();

        Iterator fsms = fsmFactory.fsmStore.values().iterator();
        while (fsms.hasNext()) {
            Fsm fsm = (Fsm) fsms.next();
            fsm.validateIntegrity();
        }

        Iterator fsmClasses = fsmFactory.fsmClassStore.values().iterator();
        while (fsmClasses.hasNext()) {
            FsmClass fsmClass = (FsmClass) fsms.next();
            fsmClass.validateIntegrity();
        }

        System.out.println("**** testFsmFactory OK ****");
    }

    /**
     * Tests the Interpreter object.
     */
    public void testInterpreter () {
        System.out.println("\n**** testInterpreter ****");

        FsmFactory.reset();
        FsmFactory fsmFactory = new FsmFactory();
        fsmFactory.initialize();
        Fsm chat = fsmFactory.getFsm("chat");
        Interpreter interpreter = new Interpreter();
        interpreter.initialize("initial", chat);
        Assert.assertNotNull(interpreter);
        Assert.assertNotNull(interpreter.fsmStacks);
        Assert.assertNotNull(interpreter.fsmStacks.get("initial"));
        Assert.assertTrue(interpreter.fsmStacks.get("initial") instanceof StackWithPointer);
        StackWithPointer fsmStack =
            (StackWithPointer) interpreter.fsmStacks.get("initial");
        Assert.assertEquals(1, fsmStack.size());
        Assert.assertTrue(fsmStack.peek() instanceof FsmStateInfo);
        FsmStateInfo fsmStateInfo =
            (FsmStateInfo) fsmStack.peek();
        Assert.assertEquals(chat, fsmStateInfo.getFsm());
        Assert.assertNull(fsmStateInfo.getCurrentState());
        Assert.assertEquals("start", interpreter.currentState.getStateId());
        String chatMessage = "xxxx";
        ParseResults parseResults = interpreter.templateParser.parse(chatMessage);
        Assert.assertTrue(! parseResults.isCompleteParse);
        Performative performative = parseResults.getPerformative();
        Assert.assertEquals("not-understand",
                            performative.getPerformativeName());
        Arc arc = interpreter.lookupArc(performative);
        interpreter.transitionState(arc);
        Assert.assertEquals("ready", interpreter.currentState.getStateId());

        interpreter.initialize("initial", chat);
        Assert.assertEquals("ready", interpreter.currentState.getStateId());
        chatMessage = "quit";
        parseResults = interpreter.templateParser.parse(chatMessage);
        Assert.assertTrue(parseResults.isCompleteParse);
        performative = parseResults.getPerformative();
        Assert.assertEquals("quit", performative.getPerformativeName());
        arc = interpreter.lookupArc(performative);
        interpreter.transitionState(arc);
        Assert.assertEquals("final", interpreter.currentState.getStateId());

        interpreter.initialize("initial", chat);
        fsmStack =
            (StackWithPointer) interpreter.fsmStacks.get("initial");
        Assert.assertEquals(1, fsmStack.size());
        Assert.assertTrue(fsmStack.peek() instanceof FsmStateInfo);
        fsmStateInfo =
            (FsmStateInfo) fsmStack.peek();
        Assert.assertEquals(chat, fsmStateInfo.getFsm());
        Assert.assertEquals("ready", interpreter.currentState.getStateId());
        chatMessage = "what do you know about penguins?";
        parseResults = interpreter.templateParser.parse(chatMessage);
        Assert.assertTrue(parseResults.isCompleteParse);
        performative = parseResults.getPerformative();
        Assert.assertEquals("disambiguate-term-query",
                            performative.getPerformativeName());
        arc = interpreter.lookupArc(performative);
        interpreter.transitionState(arc);
        Assert.assertEquals("ready", interpreter.currentState.getStateId());
        ArrayList expectedTextBinding = new ArrayList();
        expectedTextBinding.add("penguins");
        ArrayList actualTextBinding =
            parseResults.getTextBinding(CycObjectFactory.makeCycVariable("term"));
        Assert.assertEquals(expectedTextBinding, actualTextBinding);
        Fsm disambiguatePhrase = fsmFactory.getFsm("disambiguate-phrase");
        CycList disambiguationWords = new CycList();
        disambiguationWords.add("penguins");
        Object [] attributeValuePair = {"disambiguation words",
                disambiguationWords};
        ArrayList arguments = new ArrayList();
        arguments.add(attributeValuePair);
        interpreter.setupSubFsm(disambiguatePhrase, arguments);
        Assert.assertEquals("ready",
                            fsmStateInfo.getCurrentState().getStateId());
        Assert.assertEquals(2, fsmStack.size());
        Assert.assertTrue(fsmStack.peek() instanceof FsmStateInfo);
        fsmStateInfo = (FsmStateInfo) fsmStack.peek();
        Assert.assertNull(fsmStateInfo.getCurrentState());
        Assert.assertEquals(disambiguatePhrase, fsmStateInfo.getFsm());
        Assert.assertNotNull(interpreter.nextPerformative);

        System.out.println("**** testInterpreter OK ****");
    }

    /**
     * Tests the Performer object.
     */
    public void testPerformer () {
        System.out.println("\n**** testPerformer ****");

        Interpreter interpreter = new Interpreter();
        Performer performer = new Performer(interpreter);

        CycAccess cycAccess = null;
        try {
            cycAccess = new CycAccess();
            //System.out.println("CycAccess initialized");
            CycList terms = performer.parseTermsString("penguins");
            // #$Penguin
            Assert.assertTrue(terms.contains(cycAccess.getKnownConstantByGuid("bd58a986-9c29-11b1-9dad-c379636f7270")));
            // #$PittsburghPenguins
            Assert.assertTrue(terms.contains(cycAccess.getKnownConstantByGuid("c08dec11-9c29-11b1-9dad-c379636f7270")));

            CycList words = new CycList();
            words.add("penguins");
            String disambiguationPhrase = StringUtils.wordsToPhrase(words);
            terms = performer.parseTermsString(disambiguationPhrase);
            // #$Penguin
            Assert.assertTrue(terms.contains(cycAccess.getKnownConstantByGuid("bd58a986-9c29-11b1-9dad-c379636f7270")));
            // #$PittsburghPenguins
            Assert.assertTrue(terms.contains(cycAccess.getKnownConstantByGuid("c08dec11-9c29-11b1-9dad-c379636f7270")));

        }
        catch (Exception e) {
            Assert.fail(e.toString());
        }
        System.out.println("**** testPerformer OK ****");
    }


}
@


1.9
log
@Added validation to the Fsm and FsmClass classes
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.8 2002/02/28 22:44:22 stephenreed Exp $
@


1.8
log
@Renamed Conversation*.java to Fsm*.java
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.7 2002/02/28 06:02:23 stephenreed Exp $
d50 1
d55 1
d57 2
a58 2
        testSuite.addTest(new UnitTest("testInterpreter"));
        testSuite.addTest(new UnitTest("testPerformer"));
d94 2
a95 1
        Assert.assertEquals(performativeName, performative.getPerformativeName());
d124 3
a126 3
        State readyState = new State("ready");
        Assert.assertNotNull(readyState);
        Assert.assertEquals("ready", readyState.getStateId());
d135 2
a136 2
         * 1. If we are in the ready state and get a term-query performative, transition
         * to the ready state and perform the do-term-query action.
d138 1
a138 1
        Arc arc1 = new Arc(readyState,
d140 1
a140 1
                           readyState,
d143 4
a146 4
        Assert.assertNotNull(readyState.arcs);
        Assert.assertEquals(1, readyState.getArcs().size());
        Assert.assertTrue(readyState.getArcs().contains(arc1));
        Assert.assertEquals(arc1, readyState.getArc(termQueryPerformative));
d148 1
a148 1
         * 2. If we are in the ready state and get a quit performative, transition
d151 1
a151 1
        Arc arc2 = new Arc(readyState,
d156 5
a160 5
        Assert.assertEquals(2, readyState.getArcs().size());
        Assert.assertTrue(readyState.getArcs().contains(arc1));
        Assert.assertTrue(readyState.getArcs().contains(arc2));
        Assert.assertEquals(arc1, readyState.getArc(termQueryPerformative));
        Assert.assertEquals(arc2, readyState.getArc(quitPerformative));
d163 1
a163 1
        states.add(readyState);
d168 1
a168 1
        Assert.assertEquals(readyState, states.get(1));
d200 4
a203 4
                               termQueryPerformative,
                               readyState,
                               null,
                               doTermQueryAction);
d205 1
a205 1
        Assert.assertEquals("[ready, term-query, null, do-term-query, ready]", arc1.toString());
d211 4
a214 4
                          quitPerformative,
                          finalState,
                          null,
                          doFinalizationAction);
d221 1
a221 1
        Assert.assertEquals("[ready, quit, null, do-finalization, final]", arc2.toString());
d240 1
d243 7
d251 3
a253 64
        ArrayList fsmClassesList = new ArrayList();
        while (fsmClasses.hasNext())
            fsmClassesList.add(fsmClasses.next());
        for (int j = 0; j < fsmClassesList.size(); j++) {
            ArrayList statesList = new ArrayList();
            FsmClass fsmClass = (FsmClass) fsmClassesList.get(j);
            Iterator states = fsmClass.fsmStates.values().iterator();
            while (states.hasNext())
                statesList.add(states.next());
            // all states have arcs from them.
            Assert.assertTrue(statesList.size() > 0);
            for (int i = 0; i < statesList.size(); i++) {
                State state = (State) statesList.get(i);
                Iterator arcs = state.getArcs().iterator();
                while (arcs.hasNext()) {
                    Arc arc = (Arc) arcs.next();
                    // Each transitionFromState is a state in this fsm
                    Assert.assertTrue(statesList.contains(arc.getTransitionFromState()));
                    // Each transitionToState is a state in this fsm
                    Assert.assertTrue(statesList.contains(arc.getTransitionToState()));
                    Fsm subFsm = arc.getSubFsm();
                    // No arc has both an action and a subFsm.
                    Assert.assertTrue(arc.toString(),
                                      ! ((arc.getAction() != null) &&
                                         (subFsm != null)));
                    if (arc.getSubFsm() != null) {
                        // When specified, the sub fsm is a valid fsm
                        Assert.assertTrue(fsmClassesList.contains(subFsm));
                    }
                }
            }
        }
        Iterator fsms = fsmFactory.fsmStore.values().iterator();
        ArrayList fsmsList = new ArrayList();
        while (fsms.hasNext())
            fsmsList.add(fsms.next());
        for (int j = 0; j < fsmsList.size(); j++) {
            ArrayList statesList = new ArrayList();
            Fsm fsm = (Fsm) fsmsList.get(j);
            Iterator states = fsm.fsmStates.values().iterator();
            while (states.hasNext())
                statesList.add(states.next());
            // all states have arcs from them.
            Assert.assertTrue(statesList.size() > 0);
            for (int i = 0; i < statesList.size(); i++) {
                State state = (State) statesList.get(i);
                Iterator arcs = state.getArcs().iterator();
                while (arcs.hasNext()) {
                    Arc arc = (Arc) arcs.next();
                    // Each transitionFromState is a state in this fsm
                    Assert.assertTrue(statesList.contains(arc.getTransitionFromState()));
                    // Each transitionToState is a state in this fsm
                    Assert.assertTrue(statesList.contains(arc.getTransitionToState()));
                    Fsm subFsm = arc.getSubFsm();
                    // No arc has both an action and a subFsm.
                    Assert.assertTrue(arc.toString(),
                                      ! ((arc.getAction() != null) &&
                                         (subFsm != null)));
                    if (arc.getSubFsm() != null) {
                        // When specified, the sub fsm is a valid fsm
                        Assert.assertTrue(fsmsList.contains(subFsm));
                    }
                }
            }
d283 1
a283 1
        Assert.assertEquals("ready", interpreter.currentState.getStateId());
d288 2
a289 1
        Assert.assertEquals("not-understand", performative.getPerformativeName());
d318 2
a319 1
        Assert.assertEquals("disambiguate-term-query", performative.getPerformativeName());
d331 2
a332 1
        Object [] attributeValuePair = {"disambiguation words", disambiguationWords};
d336 2
a337 1
        Assert.assertEquals("ready", fsmStateInfo.getCurrentState().getStateId());
d384 1
a384 1
}@


1.7
log
@Refactored use of sub conversations
@
text
@d11 1
a11 1
 * Provides a unit test suite for the <tt>org.opencyc.conversation</tt> package<p>
d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.6 2002/02/27 17:54:39 stephenreed Exp $
d54 1
a54 1
        testSuite.addTest(new UnitTest("testConversationFactory"));
d231 1
a231 1
     * Tests the ConversationFactory object.
d233 11
a243 10
    public void testConversationFactory () {
        System.out.println("\n**** testConversationFactory ****");
        ConversationFactory.reset();
        ConversationFactory conversationFactory = new ConversationFactory();
        conversationFactory.makeAllConversations();
        Iterator conversations = conversationFactory.conversationCache.values().iterator();
        ArrayList conversationsList = new ArrayList();
        while (conversations.hasNext())
            conversationsList.add(conversations.next());
        for (int j = 0; j < conversationsList.size(); j++) {
d245 2
a246 2
            Conversation conversation = (Conversation) conversationsList.get(j);
            Iterator states = conversation.conversationFsmStates.values().iterator();
d256 1
a256 1
                    // Each transitionFromState is a state in this conversation
d258 1
a258 1
                    // Each transitionToState is a state in this conversation
d260 2
a261 2
                    Conversation subConversation = arc.getSubConversation();
                    // No arc has both an action and a subConversation.
d264 37
a300 4
                                         (subConversation != null)));
                    if (arc.getSubConversation() != null) {
                        // When specified, the sub conversation is a valid conversation
                        Assert.assertTrue(conversationsList.contains(subConversation));
d306 1
a306 1
        System.out.println("**** testConversationFactory OK ****");
d315 4
a318 4
        ConversationFactory.reset();
        ConversationFactory conversationFactory = new ConversationFactory();
        conversationFactory.initialize();
        Conversation chat = conversationFactory.makeChat();
d322 11
a332 11
        Assert.assertNotNull(interpreter.conversationStacks);
        Assert.assertNotNull(interpreter.conversationStacks.get("initial"));
        Assert.assertTrue(interpreter.conversationStacks.get("initial") instanceof StackWithPointer);
        StackWithPointer conversationStack =
            (StackWithPointer) interpreter.conversationStacks.get("initial");
        Assert.assertEquals(1, conversationStack.size());
        Assert.assertTrue(conversationStack.peek() instanceof ConversationStateInfo);
        ConversationStateInfo conversationStateInfo =
            (ConversationStateInfo) conversationStack.peek();
        Assert.assertEquals(chat, conversationStateInfo.getConversation());
        Assert.assertNull(conversationStateInfo.getCurrentState());
d355 7
a361 7
        conversationStack =
            (StackWithPointer) interpreter.conversationStacks.get("initial");
        Assert.assertEquals(1, conversationStack.size());
        Assert.assertTrue(conversationStack.peek() instanceof ConversationStateInfo);
        conversationStateInfo =
            (ConversationStateInfo) conversationStack.peek();
        Assert.assertEquals(chat, conversationStateInfo.getConversation());
d376 1
a376 1
        Conversation disambiguatePhrase = conversationFactory.makeDisambiguatePhrase();
d382 7
a388 7
        interpreter.setupSubConversation(disambiguatePhrase, arguments);
        Assert.assertEquals("ready", conversationStateInfo.getCurrentState().getStateId());
        Assert.assertEquals(2, conversationStack.size());
        Assert.assertTrue(conversationStack.peek() instanceof ConversationStateInfo);
        conversationStateInfo = (ConversationStateInfo) conversationStack.peek();
        Assert.assertNull(conversationStateInfo.getCurrentState());
        Assert.assertEquals(disambiguatePhrase, conversationStateInfo.getConversation());
@


1.6
log
@Added wordsToPhrase method
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.5 2002/02/27 03:40:50 stephenreed Exp $
d54 1
d138 1
d151 1
d189 1
d199 1
d202 1
a202 1
        Assert.assertEquals("[ready, term-query, do-term-query, ready]", arc1.toString());
d210 1
d218 1
a218 1
        Assert.assertEquals("[ready, quit, do-finalization, final]", arc2.toString());
d231 45
d333 1
a333 1
        Assert.assertEquals("term-query", performative.getPerformativeName());
d342 1
a342 1
        Conversation disambiguateTerm = conversationFactory.makeDisambiguateTerm();
d348 1
a348 1
        interpreter.setupSubConversation(disambiguateTerm, arguments);
d354 2
a355 2
        Assert.assertEquals(disambiguateTerm, conversationStateInfo.getConversation());
        Assert.assertEquals(interpreter.nextPerformative, disambiguateTerm.getDefaultPerformative());
@


1.5
log
@Added more code to Performer
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.4 2002/02/26 03:37:56 stephenreed Exp $
d330 2
a331 1
            terms = performer.parseTerms(words);
@


1.4
log
@Improving the initialization of the Interpreter
@
text
@d8 1
d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.3 2002/02/20 22:44:59 stephenreed Exp $
d237 11
d270 7
d291 14
d317 1
d321 1
a321 1

d330 1
a330 1
            terms = performer.parseTermsString(words);
@


1.3
log
@Adding RKF lexicon accessors to CycAccess. Added titles to the HTML export category pages.
@
text
@d12 1
a12 1
 * @@version $Id: UnitTest.java,v 1.2 2002/02/19 04:46:11 stephenreed Exp $
a228 3
        Interpreter interpreter = new Interpreter();
        interpreter.initialize();
        Assert.assertNotNull(interpreter);
a231 1

d233 3
a235 2

        interpreter.setCurrentState(chat.getInitialState());
d246 1
a246 1
        interpreter.setCurrentState(chat.getInitialState());
d257 1
a257 1
        interpreter.setCurrentState(chat.getInitialState());
@


1.2
log
@Added unit test cases for the Interpreter
@
text
@d12 1
a12 1
 * @@version $Id: UnitTest.java,v 1.1 2002/02/18 16:08:34 stephenreed Exp $
d54 1
d277 33
@


1.1
log
@Renamed chatterbot classes, add finite state machine for dialog, and template parser for understanding chat messages.
@
text
@d12 1
a12 1
 * @@version $Id: UnitTest.java,v 1.1 2002/02/11 20:14:24 stephenreed Exp $
d229 1
d234 1
d236 1
d246 1
d248 10
d259 15
a273 3



@

