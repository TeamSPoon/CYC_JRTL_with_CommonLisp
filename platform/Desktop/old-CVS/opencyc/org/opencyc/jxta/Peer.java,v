head	1.9;
access;
symbols
	PRE_1_0:1.8;
locks; strict;
comment	@# @;


1.9
date	2006.10.21.16.49.18;	author dmiles;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.10.22.17.07;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.04.17.03.26;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.03.18.07.22;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.30.23.05.03;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.29.18.17.50;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.28.03.00.56;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.25.23.40.14;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.23.21.49.51;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.jxta;

import java.io.IOException;

import net.jxta.document.StructuredDocument;
import net.jxta.exception.DiscardQueryException;
import net.jxta.exception.NoResponseException;
import net.jxta.exception.PeerGroupException;
import net.jxta.exception.ResendQueryException;
import net.jxta.impl.protocol.ResolverQuery;
import net.jxta.impl.protocol.ResolverResponse;
import net.jxta.peergroup.PeerGroup;
import net.jxta.peergroup.PeerGroupFactory;
import net.jxta.protocol.ResolverQueryMsg;
import net.jxta.protocol.ResolverResponseMsg;
import net.jxta.rendezvous.RendezVousService;
import net.jxta.resolver.QueryHandler;
import net.jxta.resolver.ResolverService;

import org.opencyc.api.CycAccess;
import org.opencyc.cycagent.AgentCommunityAdapter;
import org.opencyc.util.Log;
import org.opencyc.xml.TextUtil;

import fipaos.ont.fipa.ACL;
import fipaos.ont.fipa.FIPACONSTANTS;
import fipaos.ont.fipa.fipaman.AgentID;
import fipaos.parser.ParserException;

/**
 * Provides generic jxta peer capablilities for cyc agents.
 * <p>
 * 
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure. OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers. Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 * 
 * @@version $Id: Peer.java,v 1.8 2002/02/10 22:17:07 stephenreed Exp $
 * @@author Stephen L. Reed
 * 
 * <p>
 * Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p>
 * <a href="http://www.opencyc.org/license.txt">the license</a>
 * <p>
 * <a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p>
 * <a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE OPENCYC ORGANIZATION OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE BASE
 * CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

	/**
	 * A name to use to register the example handler with the Resolver service.
	 */
	public static final String ECHO_HANDLER_NAME = "opencyc.org-echo-handler";

	/**
	 * JXTA credentials
	 */
	public static StructuredDocument JXTA_CREDENTIALS;// = "JXTACRED";

	/**
	 * outbound message serial number
	 */
	public int msgSerialNumber = 0;

	/**
	 * jxta ResolverService query id
	 */
	public int queryId = 0;

	/**
	 * jxta peer group
	 */
	protected PeerGroup peerGroup = null;

	/**
	 * jxta ResolverService
	 */
	protected ResolverService resolverService;

	/**
	 * The default verbosity of the solution output. 0 --> quiet ... 9 ->
	 * maximum diagnostic input.
	 */
	// public static final int DEFAULT_VERBOSITY =
	// AgentCommunityAdapter.QUIET_VERBOSITY;
	public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.MAX_VERBOSITY;

	/**
	 * Sets verbosity of the constraint solver output. 0 --> quiet ... 9 ->
	 * maximum diagnostic input.
	 */
	protected int verbosity = DEFAULT_VERBOSITY;

	/**
	 * CycAccess connection to the local cyc server.
	 */
	protected CycAccess cycAccess;

	/**
	 * Constructs a new Peer object.
	 */
	public Peer() {
		Log.makeLog();
		try {
			cycAccess = new CycAccess();
		} catch (Exception e) {
			Log.current.errorPrintln(e.getMessage());
			Log.current.printStackTrace(e);
			System.exit(1);
		}
	}

	/**
	 * Closes the peer's local cyc connection and disconnects the peer from
	 * JXTA.
	 */
	public void close() {
		if (verbosity > 2)
			Log.current.println("Closing the peer's Cyc connection");
		if (cycAccess != null)
			cycAccess.close();
		if (verbosity > 2)
			Log.current.println("Stopping the peer's JXTA services");
		peerGroup.stopApp();
	}

	/**
	 * Provides a main method for testing this class.
	 * 
	 * @@param args
	 *            not used
	 */
	public static void main(String args[]) {
		Log.makeLog();
		Peer peer = new Peer();
		peer.startJxta();
		peer.registerEchoService();
		peer.test();
		peer.close();
		System.exit(0);
	}

	/**
	 * Tests the Peer.
	 */
	protected void test() {
		Log.current.println("\nHello from JXTA group "
				+ peerGroup.getPeerGroupName());
		Log.current.println("  Group ID = "
				+ peerGroup.getPeerGroupID().toString());
		Log.current.println("  Peer name = " + peerGroup.getPeerName());
		Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString());
		RendezVousService rendezVousService = peerGroup.getRendezVousService();
		if (rendezVousService.isRendezVous())
			Log.current.println("  is a rendezvous server");
		else
			Log.current.println("  is not a rendezvous server");
		if (rendezVousService.isConnectedToRendezVous())
			Log.current.println("  is connected to a rendezvous server");
		else
			Log.current.println("  is not connected to a rendezvous server");

		doResolverEcho("hello world!", 60);
	}

	/**
	 * Sends the echo message to peers via the ResolverService, and displays the
	 * echo responses.
	 * 
	 * @@param echoMessageText
	 *            the echo message
	 * @@param waitSeconds
	 *            seconds to wait for peer responses
	 */
	public void doResolverEcho(String echoMessageText, int waitSeconds) {
		ACL queryAcl = new ACL();
		queryAcl.setPerformative(FIPACONSTANTS.REQUEST);
		AgentID senderAid = new AgentID();
		senderAid.setName(peerGroup.getPeerName());
		queryAcl.setSenderAID(senderAid);
		String echoRequestXml = "\n<list>\n" + "  <symbol>ECHO</symbol>\n"
				+ "  <string>" + TextUtil.doEntityReference(echoMessageText)
				+ "</string>\n" + "</list>";
		queryAcl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
		queryAcl.setLanguage(FIPACONSTANTS.XML);
		queryAcl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
		queryAcl.setReplyWith(nextMessageId());
		queryAcl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);

		System.out.println("\nBroadcasting to peers:" + echoRequestXml
				+ "\nwaiting " + waitSeconds + " seconds for responses");
		ResolverQuery resolverQuery = new ResolverQuery(ECHO_HANDLER_NAME,
				JXTA_CREDENTIALS, peerGroup.getPeerID().toString(), queryAcl
						.toString(), ++queryId);
		sendQuery(null, resolverQuery);
		try {
			Thread.sleep((long) (1000 * waitSeconds));
		} catch (Exception e) {
		}
		Log.current.println("\n" + waitSeconds + " seconds elapsed\n");
	}

	/**
	 * Starts the JXTA system and obtains a reference to the netPeerGroup.
	 */
	protected void startJxta() {
		if (verbosity > 2)
			Log.current.println("Starting the peer's JXTA services");
		try {
			// create and start the default JXTA NetPeerGroup
			peerGroup = PeerGroupFactory.newNetPeerGroup();
		} catch (PeerGroupException e) {
			// could not instantiate the group, print the stack and exit
			Log.current.errorPrintln("fatal error : group creation failure");
			Log.current.printStackTrace(e);

			System.exit(1);
		}
	}

	/**
	 * Registers the echo service.
	 */
	protected void registerEchoService() {
		// Get the Resolver service for the current peer group.
		Log.current.println("\nGetting ResolverService");
		resolverService = peerGroup.getResolverService();
		String localPeerId = peerGroup.getPeerID().toString();

		// Register the handler with the resolver service.
		Log.current.println("Registering with ResolverService");
		resolverService.registerHandler(ECHO_HANDLER_NAME, this);
	}

	/**
	 * Sends the query to the given peer. If the peer is null, then th query is
	 * propagated.
	 * 
	 * @@param resolverQueryMsg
	 *            the query
	 * @@param receivingPeer
	 *            the peer to which the query will be sent
	 */
	protected void sendQuery(String receivingPeer,
			ResolverQueryMsg resolverQueryMsg) {
		System.out.println("\nsendQuery:" + resolverQueryMsg + " to peer "
				+ receivingPeer);
		resolverService.sendQuery(receivingPeer, resolverQueryMsg);
	}

	/**
	 * Receives the echo query from a peer, and generates the echo response.
	 * 
	 * @@param resolverQueryMsg
	 *            the message which this handler processes
	 * @@return the response to this message
	 */
	public ResolverResponseMsg processQuery(ResolverQueryMsg resolverQueryMsg)
			throws IOException, NoResponseException, DiscardQueryException,
			ResendQueryException {
		ACL queryAcl = null;
		if (JXTA_CREDENTIALS == null)
			JXTA_CREDENTIALS = resolverQueryMsg.getCredential();

		try {
			queryAcl = new ACL(resolverQueryMsg.getQuery());
		} catch (ParserException e) {
			Log.current.errorPrintln(e.getMessage());
			Log.current.printStackTrace(e);
			System.exit(1);
		}
		Log.current.println("Processing " + ECHO_HANDLER_NAME + " query\n"
				+ queryAcl.toString());
		ACL responseAcl = (ACL) queryAcl.clone();
		AgentID senderAid = new AgentID();
		senderAid.setName(peerGroup.getPeerName());
		responseAcl.setSenderAID(senderAid);
		responseAcl.setReceiverAID(queryAcl.getSenderAID());
		JXTA_CREDENTIALS = resolverQueryMsg.getCredential();
		ResolverResponse resolverResponse = new ResolverResponse(
				ECHO_HANDLER_NAME, JXTA_CREDENTIALS, resolverQueryMsg
						.getQueryId(), responseAcl.toString());

		Log.current.println("Responding with\n" + responseAcl.toString());
		return resolverResponse;
	}

	/**
	 * Processes the echo response messages.
	 * 
	 * @@param resolverResponseMsg
	 *            the response message to a previous query.
	 */
	public void processResponse(ResolverResponseMsg resolverResponseMsg) {
		ACL responseAcl = null;
		try {
			responseAcl = new ACL(resolverResponseMsg.getResponse());
		} catch (ParserException e) {
			Log.current.errorPrintln(e.getMessage());
			Log.current.printStackTrace(e);
			System.exit(1);
		}
		Log.current.println("Received " + ECHO_HANDLER_NAME + " response\n"
				+ responseAcl.toString());
	}

	/**
	 * Returns the next message serial number identifier.
	 * 
	 * @@return the next message serial number identifier
	 */
	public String nextMessageId() {
		return "message" + ++msgSerialNumber;
	}

	/**
	 * Sets verbosity of the output. 0 --> quiet ... 9 -> maximum diagnostic
	 * input.
	 * 
	 * @@param verbosity
	 *            0 --> quiet ... 9 -> maximum diagnostic input
	 */
	public void setVerbosity(int verbosity) {
		this.verbosity = verbosity;
	}

}
@


1.8
log
@Initial check in of chat for OpenCyc
@
text
@d1 1
a1 1
package  org.opencyc.jxta;
d3 26
a28 20
import  java.io.*;
import  java.util.*;
import  javax.naming.TimeLimitExceededException;
import  net.jxta.peergroup.*;
import  net.jxta.peer.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.rendezvous.*;
import  net.jxta.impl.protocol.*;
import  fipaos.ont.fipa.*;
import  fipaos.ont.fipa.fipaman.*;
import  fipaos.util.*;
import  fipaos.parser.ParserException;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.cycagent.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;
import  org.opencyc.chat.*;
d31 3
a33 2
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
d35 2
a36 2
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
d38 2
a39 2
 *
 * @@version $Id: Peer.java,v 1.7 2002/02/04 17:03:26 stephenreed Exp $
d41 5
a45 5
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
d47 15
a61 12
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d66 276
a341 272
    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String ECHO_HANDLER_NAME = "opencyc.org-echo-handler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number
     */
    public int msgSerialNumber = 0;

    /**
     * jxta ResolverService query id
     */
    public int queryId = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * jxta ResolverService
     */
    protected ResolverService resolverService;

    /**
     * The default verbosity of the solution output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    //public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.QUIET_VERBOSITY;
    public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.MAX_VERBOSITY;

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public void close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        Peer peer = new Peer();
        peer.startJxta();
        peer.registerEchoService();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString());
        RendezVousService rendezVousService = peerGroup.getRendezVousService();
        if (rendezVousService.isRendezVous())
            Log.current.println("  is a rendezvous server");
        else
            Log.current.println("  is not a rendezvous server");
        if (rendezVousService.isConnectedToRendezVous())
            Log.current.println("  is connected to a rendezvous server");
        else
            Log.current.println("  is not connected to a rendezvous server");

        doResolverEcho("hello world!", 60);
    }

    /**
     * Sends the echo message to peers via the ResolverService, and displays the echo responses.
     *
     * @@param echoMessageText the echo message
     * @@param waitSeconds seconds to wait for peer responses
     */
    public void doResolverEcho (String echoMessageText, int waitSeconds) {
        ACL queryAcl = new ACL();
        queryAcl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = new AgentID();
        senderAid.setName(peerGroup.getPeerName());
        queryAcl.setSenderAID(senderAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        queryAcl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        queryAcl.setLanguage(FIPACONSTANTS.XML);
        queryAcl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        queryAcl.setReplyWith(nextMessageId());
        queryAcl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);

        System.out.println("\nBroadcasting to peers:" + echoRequestXml +
                           "\nwaiting " + waitSeconds + " seconds for responses");
        ResolverQuery resolverQuery =
            new ResolverQuery(ECHO_HANDLER_NAME,
                              JXTA_CREDENTIALS,
                              peerGroup.getPeerID().toString(),
                              queryAcl.toString(),
                              ++queryId);
        sendQuery(null, resolverQuery);
        try {
            Thread.sleep((long) (1000 * waitSeconds));
        }
        catch (Exception e) {
        }
        Log.current.println("\n" + waitSeconds + " seconds elapsed\n");
    }


    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        }
        catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);

            System.exit(1);
        }
    }

    /**
     * Registers the echo service.
     */
    protected void registerEchoService () {
        // Get the Resolver service for the current peer group.
        Log.current.println("\nGetting ResolverService");
        resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.println("Registering with ResolverService");
        resolverService.registerHandler(ECHO_HANDLER_NAME, this);
    }

    /**
     * Sends the query to the given peer.  If the peer is null, then th
     * query is propagated.
     *
     * @@param resolverQueryMsg the query
     * @@param receivingPeer the peer to which the query will be sent
     */
    protected void sendQuery (String receivingPeer, ResolverQueryMsg resolverQueryMsg) {
        System.out.println("\nsendQuery:" + resolverQueryMsg + " to peer " + receivingPeer);
        resolverService.sendQuery(receivingPeer, resolverQueryMsg);
    }

    /**
     * Receives the echo query from a peer, and generates the echo response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg resolverQueryMsg)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        ACL queryAcl = null;
        try {
            queryAcl = new ACL(resolverQueryMsg.getQuery());
        }
        catch (ParserException e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
        Log.current.println("Processing " + ECHO_HANDLER_NAME +
                            " query\n" + queryAcl.toString());
        ACL responseAcl = (ACL) queryAcl.clone();
        AgentID senderAid = new AgentID();
        senderAid.setName(peerGroup.getPeerName());
        responseAcl.setSenderAID(senderAid);
        responseAcl.setReceiverAID(queryAcl.getSenderAID());
        ResolverResponse resolverResponse =
            new ResolverResponse(ECHO_HANDLER_NAME,
                                 JXTA_CREDENTIALS,
                                 resolverQueryMsg.getQueryId(),
                                 responseAcl.toString());

        Log.current.println("Responding with\n" + responseAcl.toString());
        return resolverResponse;
    }

    /**
     * Processes the echo response messages.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        ACL responseAcl = null;
        try {
            responseAcl = new ACL(resolverResponseMsg.getResponse());
        }
        catch (ParserException e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
        Log.current.println("Received " + ECHO_HANDLER_NAME +
                            " response\n" + responseAcl.toString());
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

    /**
     * Sets verbosity of the output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
a343 7







@


1.7
log
@Fix api handling of CycNarts. Refined HTML export.
@
text
@d22 1
d32 1
a32 1
 * @@version $Id: Peer.java,v 1.6 2002/02/03 18:07:22 stephenreed Exp $
d328 1
@


1.6
log
@More JXTA interface code and fixing CycNart api bug
@
text
@d1 334
a334 329
package  org.opencyc.jxta;

import  java.io.*;
import  java.util.*;
import  javax.naming.TimeLimitExceededException;
import  net.jxta.peergroup.*;
import  net.jxta.peer.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.rendezvous.*;
import  net.jxta.impl.protocol.*;
import  fipaos.ont.fipa.*;
import  fipaos.ont.fipa.fipaman.*;
import  fipaos.util.*;
import  fipaos.parser.ParserException;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.cycagent.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;

/**
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 *
 * @@version $Id: Peer.java,v 1.4 2002/01/29 18:17:50 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String ECHO_HANDLER_NAME = "opencyc.org-echo-handler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number
     */
    public int msgSerialNumber = 0;

    /**
     * jxta ResolverService query id
     */
    public int queryId = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * jxta ResolverService
     */
    protected ResolverService resolverService;

    /**
     * The default verbosity of the solution output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    //public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.QUIET_VERBOSITY;
    public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.MAX_VERBOSITY;

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        try {
            cycAccess = new CycAccess();
        }
        catch (Exception e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public void close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        Peer peer = new Peer();
        peer.startJxta();
        peer.registerEchoService();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString());
        RendezVousService rendezVousService = peerGroup.getRendezVousService();
        if (rendezVousService.isRendezVous())
            Log.current.println("  is a rendezvous server");
        else
            Log.current.println("  is not a rendezvous server");
        if (rendezVousService.isConnectedToRendezVous())
            Log.current.println("  is connected to a rendezvous server");
        else
            Log.current.println("  is not connected to a rendezvous server");

        doResolverEcho("hello world!", 60);
    }

    /**
     * Sends the echo message to peers via the ResolverService, and displays the echo responses.
     *
     * @@param echoMessageText the echo message
     * @@param waitSeconds seconds to wait for peer responses
     */
    public void doResolverEcho (String echoMessageText, int waitSeconds) {
        ACL queryAcl = new ACL();
        queryAcl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = new AgentID();
        senderAid.setName(peerGroup.getPeerName());
        queryAcl.setSenderAID(senderAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        queryAcl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        queryAcl.setLanguage(FIPACONSTANTS.XML);
        queryAcl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        queryAcl.setReplyWith(nextMessageId());
        queryAcl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);

        System.out.println("\nBroadcasting to peers:" + echoRequestXml +
                           "\nwaiting " + waitSeconds + " seconds for responses");
        ResolverQuery resolverQuery =
            new ResolverQuery(ECHO_HANDLER_NAME,
                              JXTA_CREDENTIALS,
                              peerGroup.getPeerID().toString(),
                              queryAcl.toString(),
                              ++queryId);
        sendQuery(null, resolverQuery);
        try {
            Thread.sleep((long) (1000 * waitSeconds));
        }
        catch (Exception e) {
        }
        Log.current.println("\n" + waitSeconds + " seconds elapsed\n");
    }


    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        }
        catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Registers the echo service.
     */
    protected void registerEchoService () {
        // Get the Resolver service for the current peer group.
        Log.current.println("\nGetting ResolverService");
        resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.println("Registering with ResolverService");
        resolverService.registerHandler(ECHO_HANDLER_NAME, this);
    }

    /**
     * Sends the query to the given peer.  If the peer is null, then the
     * query is propagated.
     *
     * @@param resolverQueryMsg the query
     * @@param receivingPeer the peer to which the query will be sent
     */
    protected void sendQuery (String receivingPeer, ResolverQueryMsg resolverQueryMsg) {
        System.out.println("\nsendQuery:" + resolverQueryMsg + " to peer " + receivingPeer);
        resolverService.sendQuery(receivingPeer, resolverQueryMsg);
    }

    /**
     * Receives the echo query from a peer, and generates the echo response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg resolverQueryMsg)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        ACL queryAcl = null;
        try {
            queryAcl = new ACL(resolverQueryMsg.getQuery());
        }
        catch (ParserException e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
        Log.current.println("Processing " + ECHO_HANDLER_NAME +
                            " query\n" + queryAcl.toString());
        ACL responseAcl = (ACL) queryAcl.clone();
        AgentID senderAid = new AgentID();
        senderAid.setName(peerGroup.getPeerName());
        responseAcl.setSenderAID(senderAid);
        responseAcl.setReceiverAID(queryAcl.getSenderAID());
        ResolverResponse resolverResponse =
            new ResolverResponse(ECHO_HANDLER_NAME,
                                 JXTA_CREDENTIALS,
                                 resolverQueryMsg.getQueryId(),
                                 responseAcl.toString());

        Log.current.println("Responding with\n" + responseAcl.toString());
        return resolverResponse;
    }

    /**
     * Processes the echo response messages.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        ACL responseAcl = null;
        try {
            responseAcl = new ACL(resolverResponseMsg.getResponse());
        }
        catch (ParserException e) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            System.exit(1);
        }
        Log.current.println("Received " + ECHO_HANDLER_NAME +
                            " response\n" + responseAcl.toString());
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

    /**
     * Sets verbosity of the output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}



@


1.5
log
@Removed extra lines on Windows.
@
text
@d1 329
a329 311
package  org.opencyc.jxta;

import  java.io.*;
import  javax.naming.TimeLimitExceededException;
import  net.jxta.peergroup.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.impl.protocol.ResolverResponse;
import  fipaos.ont.fipa.*;
import  fipaos.ont.fipa.fipaman.*;
import  fipaos.util.*;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.cycagent.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;

/**
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 *
 * @@version $Id: Peer.java,v 1.4 2002/01/29 18:17:50 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String ECHO_HANDLER_NAME = "opencyc.org-echo-handler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number.
     */
    public int msgSerialNumber = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * The default verbosity of the solution output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    //public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.QUIET_VERBOSITY;
    public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.MAX_VERBOSITY;

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        cycAccess = new CycAccess();
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public void close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        Peer peer = new Peer();
        peer.startJxta();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString() + "\n");

        doResolverEcho("hello world!", 10);

        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(queryAcl);
        ResolverResponse resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                                 JXTA_CREDENTIALS,
                                                                 0,
                                                                 cycApiResponseMsg.toString());

        resolverService.sendResponse(null, resolverResponse);


        String echoReplyXml = (String) replyAcl.getContentObject();
        Log.current.println("\nReceived from remote agent " + remoteAgentName + ":" + echoReplyXml);

    }

    /**
     * Sends the echo message to peers via the ResolverService, and displays the echo responses.
     *
     * @@param echoMessageText the echo message
     * @@param waitSeconds seconds to wait for peer responses
     */
    public void doResolverEcho (String echoMessageText, int waitSeconds) {
        ACL acl = new ACL();
        acl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = new AgentID();
        agentID.setName(peerGroup.getPeerName());
        acl.setSenderAID(senderAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        acl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        acl.setLanguage(FIPACONSTANTS.XML);
        acl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        acl.setReplyWith(nextMessageId());
        acl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);

        System.out.println("\nBroadcasting to peers:" + echoRequestXml +
                           "\nwaiting " + waitSeconds + " seconds for responses");
        resolverQuery(acl);
        try {
            Thread.sleep(1000 * waitSeconds);
        }
        catch (Exception e) {
        }
        Log.current.errorPrintln(waitSeconds + " elapsed");
    }


    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        }
        catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Registers the echo service.
     */
    protected void registerEchoService () {
        // Get the Resolver service for the current peer group.
        Log.current.errorPrintln("\nGetting ResolverService");
        ResolverService resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.errorPrintln("Registering with ResolverService");
        resolverService.registerHandler(ECHO_HANDLER_NAME, this);
    }

    /**
     * Queries the ResolverService with the given ACL.
     *
     * @@param queryAcl the Agent Communication Language query
     */
    protected resolverQuery (ACL queryAcl) {
    }

    /**
     * Processes the resolver query, and generate the response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg query)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        Log.current.println("Processing query...");
        ResolverResponse resolverResponse;
        CycApiQueryMsg cycApiQueryMsg;
        double answer = 0.0;

        try {
            cycApiQueryMsg =
                new CycApiQueryMsg(new ByteArrayInputStream((query.getQuery()).getBytes()));
        }
        catch (Exception e) {
            throw new IOException();
        }
        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(cycApiQueryMsg.getBase(),
                                                                    cycApiQueryMsg.getPower(),
                                                                    answer);

        // Wrap the response message in a resolver response message.
        resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                JXTA_CREDENTIALS,
                                                query.getQueryId(),
                                                cycApiResponseMsg.toString());

        return resolverResponse;
    }

    /**
     * Process a Resolver response message.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        Log.current.println("Processing response...");
        CycApiResponseMsg cycApiResponseMsg;

        try {
            // Extract the message from the Resolver response.
            cycApiResponseMsg =
                new CycApiResponseMsg(new ByteArrayInputStream((resolverResponseMsg.getResponse()).getBytes()));

            // Print out the answer given in the response.
            Log.current.println("\nThe value of " + cycApiResponseMsg.getBase() +
                                " raised to " + cycApiResponseMsg.getPower() +
                                " is " + cycApiResponseMsg.getAnswer() + "\n");
        }
        catch (Exception e) {
            // This is not the right type of response message, or
            // the message is improperly formed. Ignore the message,
            // do nothing.
        }
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

    /**
     * Sets verbosity of the output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}







@


1.4
log
@Decided to use Jxta pipes for api messaging and use the Jxta ResolverService for echo.
@
text
@d1 311
a311 307
package  org.opencyc.jxta;

import  java.io.*;
import  javax.naming.TimeLimitExceededException;
import  net.jxta.peergroup.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.impl.protocol.ResolverResponse;
import  fipaos.ont.fipa.*;
import  fipaos.ont.fipa.fipaman.*;
import  fipaos.util.*;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.cycagent.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;

/**
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 *
 * @@version $Id: Peer.java,v 1.2 2002/01/25 23:40:14 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String ECHO_HANDLER_NAME = "opencyc.org-echo-handler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number.
     */
    public int msgSerialNumber = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * The default verbosity of the solution output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    //public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.QUIET_VERBOSITY;
    public static final int DEFAULT_VERBOSITY = AgentCommunityAdapter.MAX_VERBOSITY;

    /**
     * Sets verbosity of the constraint solver output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     */
    protected int verbosity = DEFAULT_VERBOSITY;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        cycAccess = new CycAccess();
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public void close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        Peer peer = new Peer();
        peer.startJxta();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString() + "\n");

        doResolverEcho("hello world!", 10);

        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(queryAcl);
        ResolverResponse resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                                 JXTA_CREDENTIALS,
                                                                 0,
                                                                 cycApiResponseMsg.toString());

        resolverService.sendResponse(null, resolverResponse);


        String echoReplyXml = (String) replyAcl.getContentObject();
        Log.current.println("\nReceived from remote agent " + remoteAgentName + ":" + echoReplyXml);

    }

    /**
     * Sends the echo message to peers via the ResolverService, and displays the echo responses.
     *
     * @@param echoMessageText the echo message
     * @@param waitSeconds seconds to wait for peer responses
     */
    public void doResolverEcho (String echoMessageText, int waitSeconds) {
        ACL acl = new ACL();
        acl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = new AgentID();
        agentID.setName(peerGroup.getPeerName());
        acl.setSenderAID(senderAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        acl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        acl.setLanguage(FIPACONSTANTS.XML);
        acl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        acl.setReplyWith(nextMessageId());
        acl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);

        System.out.println("\nBroadcasting to peers:" + echoRequestXml +
                           "\nwaiting " + waitSeconds + " seconds for responses");
        resolverQuery(acl);
        try {
            Thread.sleep(1000 * waitSeconds);
        }
        catch (Exception e) {
        }
        Log.current.errorPrintln(waitSeconds + " elapsed");
    }


    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        }
        catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Registers the echo service.
     */
    protected void registerEchoService () {
        // Get the Resolver service for the current peer group.
        Log.current.errorPrintln("\nGetting ResolverService");
        ResolverService resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.errorPrintln("Registering with ResolverService");
        resolverService.registerHandler(ECHO_HANDLER_NAME, this);
    }

    /**
     * Queries the ResolverService with the given ACL.
     *
     * @@param queryAcl the Agent Communication Language query
     */
    protected resolverQuery (ACL queryAcl) {
    }

    /**
     * Processes the resolver query, and generate the response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg query)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        Log.current.println("Processing query...");
        ResolverResponse resolverResponse;
        CycApiQueryMsg cycApiQueryMsg;
        double answer = 0.0;

        try {
            cycApiQueryMsg =
                new CycApiQueryMsg(new ByteArrayInputStream((query.getQuery()).getBytes()));
        }
        catch (Exception e) {
            throw new IOException();
        }
        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(cycApiQueryMsg.getBase(),
                                                                    cycApiQueryMsg.getPower(),
                                                                    answer);

        // Wrap the response message in a resolver response message.
        resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                JXTA_CREDENTIALS,
                                                query.getQueryId(),
                                                cycApiResponseMsg.toString());

        return resolverResponse;
    }

    /**
     * Process a Resolver response message.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        Log.current.println("Processing response...");
        CycApiResponseMsg cycApiResponseMsg;

        try {
            // Extract the message from the Resolver response.
            cycApiResponseMsg =
                new CycApiResponseMsg(new ByteArrayInputStream((resolverResponseMsg.getResponse()).getBytes()));

            // Print out the answer given in the response.
            Log.current.println("\nThe value of " + cycApiResponseMsg.getBase() +
                                " raised to " + cycApiResponseMsg.getPower() +
                                " is " + cycApiResponseMsg.getAnswer() + "\n");
        }
        catch (Exception e) {
            // This is not the right type of response message, or
            // the message is improperly formed. Ignore the message,
            // do nothing.
        }
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

    /**
     * Sets verbosity of the output.  0 --> quiet ... 9 -> maximum
     * diagnostic input.
     *
     * @@param verbosity 0 --> quiet ... 9 -> maximum diagnostic input
     */
    public void setVerbosity(int verbosity) {
        this.verbosity = verbosity;
    }
}



@


1.3
log
@Removed extra new-lines from source files
@
text
@d1 307
a307 343
package  org.opencyc.jxta;

import  java.io.*;
import  net.jxta.peergroup.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.impl.protocol.ResolverResponse;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;

/**
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 *
 * @@version $Id: Peer.java,v 1.2 2002/01/25 23:40:14 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String HANDLER_NAME = "CycApiHandler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number.
     */
    public int msgSerialNumber = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        cycAccess = new CycAccess();
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        Peer peer = new Peer();
        peer.startJxta();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString() + "\n");

        // Get the Resolver service for the current peer group.
        Log.current.errorPrintln("\nGetting ResolverService");
        ResolverService resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.errorPrintln("Registering with ResolverService");
        resolverService.registerHandler(HANDLER_NAME, this);
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("cconcatenate"));
        command.add("hello");
        command.add(" ");
        command.add("world!");

        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(queryAcl);
        ResolverResponse resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                                 JXTA_CREDENTIALS,
                                                                 0,
                                                                 cycApiResponseMsg.toString());

        // Send (push) the (unsolicited) response using the resolver.
        Log.current.errorPrintln("Sending resolverResponse");
        try {
            Log.current.errorPrintln("Sleeping .5 second");
            Thread.sleep(500);
        }
        catch (Exception e) {
        }
        resolverService.sendResponse(null, resolverResponse);

        // Keep this process alive until killed by the user.
        while (true) {
            try {
                Log.current.errorPrintln("Sleeping 60 seconds while awaiting query from a peer");
                Thread.sleep(60000);
            }
            catch (Exception e) {
            }
        }
    }

    /**
     * Sends the echo message, and displays the echo response.
     *
     * @@param echoMessageText
     */
    public void doEcho (String echoMessageText) {
        ACL acl = new ACL();
        acl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = getAID(remoteAgentCommunity);
        acl.setSenderAID(senderAid);
        AgentID receiverAid = this.makeAID(remoteAgentName, remoteAgentCommunity);
        acl.addReceiverAID(receiverAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        acl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        acl.setLanguage(FIPACONSTANTS.XML);
        acl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        acl.setReplyWith(nextMessageId());
        acl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);
        System.out.println("\nSending to remote agent " + remoteAgentName + ":" + echoRequestXml);
        ACL replyAcl = null;
        try {
            //Timer timer = new Timer(this.oneMinuteDuration);
            Timer timer = new Timer(10000);
            replyAcl = converseMessage(acl, timer);
        }
        catch (TimeLimitExceededException e) {
            Log.current.errorPrintln("No reply from " + remoteAgentName + " within the time limit");
            System.exit(1);
        }
        catch (IOException e) {
            Log.current.errorPrintln("Error communicating with " + remoteAgentName + "\n" + e.getMessage());
            System.exit(1);
        }
        String echoReplyXml = (String) replyAcl.getContentObject();
        Log.current.println("\nReceived from remote agent " + remoteAgentName + ":" + echoReplyXml);
    }

    /**
     * Sends an Agent Communication Language message and returns the reply.
     *
     * @@param acl the Agent Communication Language message to be sent
     * @@param timer the Timer object controlling the maximum wait time for a reply message,
     * after which an excecption is thrown.
     * @@return the Agent Communication Language reply message which has been received for my agent
     *
     * @@thows TimeLimitExceededException when the time limit is exceeded before a reply message
     * is received.
     */
    public ACL converseMessage (ACL acl, org.opencyc.util.Timer timer)
        throws TimeLimitExceededException, IOException {
        Message requestMessage = new BasicMessage(acl.getReceiverAID().getName(),
                                                  "fipa-xml",
                                                  acl.toString());
        requestMessage.setSender(regHelper.getAgentRep());
        if (verbosity > 2)
            Log.current.println("\nSending " + requestMessage.toString() +
                                "\n  receiver: " + requestMessage.getReceiver());
        String replyWith = acl.getReplyWith();
        waitingReplyThreads.put(replyWith, Thread.currentThread());
        String receiverName = acl.getReceiverAID().getName();
        AgentRep receivingAgentRep = this.lookupAgentRep(receiverName);
        if (receivingAgentRep == null)
            throw new IOException("Receiving agent " + receiverName + " not found");
        waitingReplyThreads.put(replyWith, Thread.currentThread());
        receivingAgentRep.addMessage(requestMessage);
        while (true)
            try {
                Thread.sleep(500);
                if (timer.isTimedOut())
                    throw new IOException("Time limit exceeded - " + timer.getElapsedSeconds() +
                                          " seconds, while awaiting reply message to " + replyWith);
            }
            catch (InterruptedException e) {
                ACL replyAcl = (ACL) replyMessages.get(replyWith);
                if (replyAcl == null)
                    throw new RuntimeException("No reply message for " + replyWith);
                waitingReplyThreads.remove(replyWith);
                if (verbosity > 2)
                    Log.current.println("\nReceived reply to " + replyWith + "\n" + replyAcl);
                return replyAcl;
            }
    }

    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        } catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Processes the Resolver query message and returns a response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg query)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        Log.current.println("Processing query...");
        ResolverResponse resolverResponse;
        CycApiQueryMsg cycApiQueryMsg;
        double answer = 0.0;

        try {
            cycApiQueryMsg =
                new CycApiQueryMsg(new ByteArrayInputStream((query.getQuery()).getBytes()));
        }
        catch (Exception e) {
            throw new IOException();
        }

        // Perform the calculation.
        //answer = Math.pow(cycApiQueryMsg.getBase(), cycApiQueryMsg.getPower());

        // Create the response message.
        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(cycApiQueryMsg.getBase(),
                                                                    cycApiQueryMsg.getPower(),
                                                                    answer);

        // Wrap the response message in a resolver response message.
        resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                JXTA_CREDENTIALS,
                                                query.getQueryId(),
                                                cycApiResponseMsg.toString());

        return resolverResponse;
    }

    /**
     * Process a Resolver response message.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        Log.current.println("Processing response...");
        CycApiResponseMsg cycApiResponseMsg;

        try {
            // Extract the message from the Resolver response.
            cycApiResponseMsg =
                new CycApiResponseMsg(new ByteArrayInputStream((resolverResponseMsg.getResponse()).getBytes()));

            // Print out the answer given in the response.
            Log.current.println("\nThe value of " + cycApiResponseMsg.getBase() +
                                " raised to " + cycApiResponseMsg.getPower() +
                                " is " + cycApiResponseMsg.getAnswer() + "\n");
        }
        catch (Exception e) {
            // This is not the right type of response message, or
            // the message is improperly formed. Ignore the message,
            // do nothing.
        }
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

}







@


1.2
log
@Adding ACL messages
@
text
@d1 343
a343 339
package  org.opencyc.jxta;

import  java.io.*;
import  net.jxta.peergroup.*;
import  net.jxta.exception.*;
import  net.jxta.protocol.*;
import  net.jxta.resolver.*;
import  net.jxta.impl.protocol.ResolverResponse;
import  org.opencyc.api.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.xml.*;
import  org.opencyc.util.*;

/**
 * Provides generic jxta peer capablilities for cyc agents.<p>
 *
 * See www.jxta.org for more information on the Juxtaposition peer to peer
 * infrastructure.  OpenCyc uses the JXTA Resolver Service to pass messages to
 * discovered JXTA peers.  Between OpenCyc peers, the message content is a
 * FIPA-OS envelope and an enclosed FIPA-OS message represented in XML format.
 *
 * @@version $Id: Peer.java,v 1.1 2002/01/23 21:49:51 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public class Peer implements QueryHandler {

    /**
     * A name to use to register the example handler with the Resolver service.
     */
    public static final String HANDLER_NAME = "CycApiHandler";

    /**
     * JXTA credentials
     */
    public static final String JXTA_CREDENTIALS = "JXTACRED";

    /**
     * outbound message serial number.
     */
    public int msgSerialNumber = 0;

    /**
     * jxta peer group
     */
    protected PeerGroup peerGroup = null;

    /**
     * CycAccess connection to the local cyc server.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new Peer object.
     */
    public Peer () {
        Log.makeLog();
        cycAccess = new CycAccess();
    }

    /**
     * Closes the peer's local cyc connection and disconnects the peer from JXTA.
     */
    public close () {
        if (verbosity > 2)
            Log.current.println("Closing the peer's Cyc connection");
        if (cycAccess != null)
            cycAccess.close();
        if (verbosity > 2)
            Log.current.println("Stopping the peer's JXTA services");
        peerGroup.stopApp();
    }

    /**
     * Provides a main method for testing this class.
     *
     * @@param args not used
     */
    public static void main (String args[]) {
        Log.makeLog();
        if (verbosity > 2)
            Log.current.println("Starting the peer's JXTA services");
        Peer peer = new Peer();
        peer.startJxta();
        peer.test();
        peer.close();
        System.exit(0);
    }

    /**
     * Tests the Peer.
     */
    protected void test () {
        Log.current.println("\nHello from JXTA group " + peerGroup.getPeerGroupName());
        Log.current.println("  Group ID = " + peerGroup.getPeerGroupID().toString());
        Log.current.println("  Peer name = " + peerGroup.getPeerName());
        Log.current.println("  Peer ID = " + peerGroup.getPeerID().toString() + "\n");

        // Get the Resolver service for the current peer group.
        Log.current.errorPrintln("\nGetting ResolverService");
        ResolverService resolverService = peerGroup.getResolverService();
        String localPeerId = peerGroup.getPeerID().toString();

        // Register the handler with the resolver service.
        Log.current.errorPrintln("Registering with ResolverService");
        resolverService.registerHandler(HANDLER_NAME, this);
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("cconcatenate"));
        command.add("hello");
        command.add(" ");
        command.add("world!");

        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(queryAcl);
        ResolverResponse resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                                 JXTA_CREDENTIALS,
                                                                 0,
                                                                 cycApiResponseMsg.toString());

        // Send (push) the (unsolicited) response using the resolver.
        Log.current.errorPrintln("Sending resolverResponse");
        try {
            Log.current.errorPrintln("Sleeping .5 second");
            Thread.sleep(500);
        }
        catch (Exception e) {
        }
        resolverService.sendResponse(null, resolverResponse);

        // Keep this process alive until killed by the user.
        while (true) {
            try {
                Log.current.errorPrintln("Sleeping 60 seconds while awaiting query from a peer");
                Thread.sleep(60000);
            }
            catch (Exception e) {
            }
        }
    }

    /**
     * Sends the echo message, and displays the echo response.
     *
     * @@param echoMessageText
     */
    public void doEcho (String echoMessageText) {
        ACL acl = new ACL();
        acl.setPerformative(FIPACONSTANTS.REQUEST);
        AgentID senderAid = getAID(remoteAgentCommunity);
        acl.setSenderAID(senderAid);
        AgentID receiverAid = this.makeAID(remoteAgentName, remoteAgentCommunity);
        acl.addReceiverAID(receiverAid);
        String echoRequestXml =
            "\n<list>\n" +
            "  <symbol>ECHO</symbol>\n" +
            "  <string>" + TextUtil.doEntityReference(echoMessageText) + "</string>\n" +
            "</list>";
        acl.setContentObject(echoRequestXml, ACL.BYTELENGTH_ENCODING);
        acl.setLanguage(FIPACONSTANTS.XML);
        acl.setOntology(AgentCommunityAdapter.CYC_ECHO_ONTOLOGY);
        acl.setReplyWith(nextMessageId());
        acl.setProtocol(FIPACONSTANTS.FIPA_REQUEST);
        System.out.println("\nSending to remote agent " + remoteAgentName + ":" + echoRequestXml);
        ACL replyAcl = null;
        try {
            //Timer timer = new Timer(this.oneMinuteDuration);
            Timer timer = new Timer(10000);
            replyAcl = converseMessage(acl, timer);
        }
        catch (TimeLimitExceededException e) {
            Log.current.errorPrintln("No reply from " + remoteAgentName + " within the time limit");
            System.exit(1);
        }
        catch (IOException e) {
            Log.current.errorPrintln("Error communicating with " + remoteAgentName + "\n" + e.getMessage());
            System.exit(1);
        }
        String echoReplyXml = (String) replyAcl.getContentObject();
        Log.current.println("\nReceived from remote agent " + remoteAgentName + ":" + echoReplyXml);
    }

    /**
     * Sends an Agent Communication Language message and returns the reply.
     *
     * @@param acl the Agent Communication Language message to be sent
     * @@param timer the Timer object controlling the maximum wait time for a reply message,
     * after which an excecption is thrown.
     * @@return the Agent Communication Language reply message which has been received for my agent
     *
     * @@thows TimeLimitExceededException when the time limit is exceeded before a reply message
     * is received.
     */
    public ACL converseMessage (ACL acl, org.opencyc.util.Timer timer)
        throws TimeLimitExceededException, IOException {
        Message requestMessage = new BasicMessage(acl.getReceiverAID().getName(),
                                                  "fipa-xml",
                                                  acl.toString());
        requestMessage.setSender(regHelper.getAgentRep());
        if (verbosity > 2)
            Log.current.println("\nSending " + requestMessage.toString() +
                                "\n  receiver: " + requestMessage.getReceiver());
        String replyWith = acl.getReplyWith();
        waitingReplyThreads.put(replyWith, Thread.currentThread());
        String receiverName = acl.getReceiverAID().getName();
        AgentRep receivingAgentRep = this.lookupAgentRep(receiverName);
        if (receivingAgentRep == null)
            throw new IOException("Receiving agent " + receiverName + " not found");
        waitingReplyThreads.put(replyWith, Thread.currentThread());
        receivingAgentRep.addMessage(requestMessage);
        while (true)
            try {
                Thread.sleep(500);
                if (timer.isTimedOut())
                    throw new IOException("Time limit exceeded - " + timer.getElapsedSeconds() +
                                          " seconds, while awaiting reply message to " + replyWith);
            }
            catch (InterruptedException e) {
                ACL replyAcl = (ACL) replyMessages.get(replyWith);
                if (replyAcl == null)
                    throw new RuntimeException("No reply message for " + replyWith);
                waitingReplyThreads.remove(replyWith);
                if (verbosity > 2)
                    Log.current.println("\nReceived reply to " + replyWith + "\n" + replyAcl);
                return replyAcl;
            }
    }

    /**
     * Starts the JXTA system and obtains a reference to the netPeerGroup.
     */
    protected void startJxta () {
        try {
            // create and start the default JXTA NetPeerGroup
            peerGroup = PeerGroupFactory.newNetPeerGroup();
        } catch (PeerGroupException e) {
            // could not instantiate the group, print the stack and exit
            Log.current.errorPrintln("fatal error : group creation failure");
            Log.current.printStackTrace(e);
            System.exit(1);
        }
    }

    /**
     * Processes the Resolver query message and returns a response.
     *
     * @@param resolverQueryMsg the message which this handler processes
     * @@return the response to this message
     */
    public ResolverResponseMsg processQuery(ResolverQueryMsg query)
        throws IOException,
               NoResponseException,
               DiscardQueryException,
               ResendQueryException {
        Log.current.println("Processing query...");
        ResolverResponse resolverResponse;
        CycApiQueryMsg cycApiQueryMsg;
        double answer = 0.0;

        try {
            cycApiQueryMsg =
                new CycApiQueryMsg(new ByteArrayInputStream((query.getQuery()).getBytes()));
        }
        catch (Exception e) {
            throw new IOException();
        }

        // Perform the calculation.
        //answer = Math.pow(cycApiQueryMsg.getBase(), cycApiQueryMsg.getPower());

        // Create the response message.
        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(cycApiQueryMsg.getBase(),
                                                                    cycApiQueryMsg.getPower(),
                                                                    answer);

        // Wrap the response message in a resolver response message.
        resolverResponse = new ResolverResponse(HANDLER_NAME,
                                                JXTA_CREDENTIALS,
                                                query.getQueryId(),
                                                cycApiResponseMsg.toString());

        return resolverResponse;
    }

    /**
     * Process a Resolver response message.
     *
     * @@param resolverResponseMsg the response message to a previous query.
     */
    public void processResponse(ResolverResponseMsg resolverResponseMsg) {
        Log.current.println("Processing response...");
        CycApiResponseMsg cycApiResponseMsg;

        try {
            // Extract the message from the Resolver response.
            cycApiResponseMsg =
                new CycApiResponseMsg(new ByteArrayInputStream((resolverResponseMsg.getResponse()).getBytes()));

            // Print out the answer given in the response.
            Log.current.println("\nThe value of " + cycApiResponseMsg.getBase() +
                                " raised to " + cycApiResponseMsg.getPower() +
                                " is " + cycApiResponseMsg.getAnswer() + "\n");
        }
        catch (Exception e) {
            // This is not the right type of response message, or
            // the message is improperly formed. Ignore the message,
            // do nothing.
        }
    }

    /**
     * Returns the next message serial number identifier.
     *
     * @@return the next message serial number identifier
     */
    public String nextMessageId () {
        return "message" + ++msgSerialNumber;
    }

}



@


1.1
log
@Initial check in of JXTA interface for OpenCyc.
@
text
@d22 1
a22 1
 * @@version $Id: GenericAgent.java,v 1.11 2002/01/23 17:16:34 stephenreed Exp $
d57 5
d67 5
d76 14
d99 2
a100 1
        Log.current.println("Starting JXTA ....");
d104 1
d125 7
a131 4
        double base = 0.0;
        double power = 0.0;
        double answer = 0;
        CycApiResponseMsg cycApiResponseMsg = new CycApiResponseMsg(base, power, answer);
d159 87
d285 1
a285 1
        answer = Math.pow(cycApiQueryMsg.getBase(), cycApiQueryMsg.getPower());
d326 10
@

