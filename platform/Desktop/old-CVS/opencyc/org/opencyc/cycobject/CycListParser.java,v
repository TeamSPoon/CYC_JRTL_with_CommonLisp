head	1.26;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.25.0.2
	OPENCYC_1_0_1:1.25
	PRE_1_0:1.24
	start:1.1.1.1
	opencyc:1.1.1;
locks; strict;
comment	@# @;


1.26
date	2006.10.21.16.49.17;	author dmiles;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.18.13.36.03;	author dmiles;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.06.00.12.27;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.23.14.44.58;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.22.17.10.59;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.04.21.12.51;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.23.20.17.22;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.17.21.27.06;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.27.19.51.20;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.21.21.01.59;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.17.23.44.19;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.04.08.24.54;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.03.21.30.39;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.02.22.56.43;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.01.23.30.45;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.28.22.36.27;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.28.14.53.23;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.27.22.52.05;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.14.22.14.55;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.28.23.52.16;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.28.10.05.25;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.27.02.30.53;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.15.14.50.46;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.13.16.14.44;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.25.17.17.34;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.23.21.54.15;	author stephenreed;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.07.23.21.54.15;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.cycobject;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;

import org.opencyc.api.CycAccess;
import org.opencyc.api.CycApiException;
import org.opencyc.api.CycObjectFactory;
import org.opencyc.util.MyStreamTokenizer;
import org.opencyc.util.StackWithPointer;

/**
 * Provides a parser that reads a <tt>String</tt> representation and constructs
 * the corresponding <tt>CycList</tt>.  Has a weakness in that quoted strings must
 * not contain embedded newlines.
 *
 * @@version $0.1$
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class CycListParser  {
  
  // Read/scan functions' lexical analysis variables.
  private int tok;
  private boolean endQuote = false;
  private boolean dot = false;
  private boolean dotWord = false;
  private boolean dotParen = false;
  private int parenLevel = 0;
  private StackWithPointer readStack = new StackWithPointer();
  private StackWithPointer quoteStack = new StackWithPointer();
  private String currentString = "";
  
  /**
   * the stream tokenizer for the current string
   */
  protected MyStreamTokenizer st;
  
  /**
   * Cyc api support.
   */
  protected CycAccess cycAccess;
  
  private static final String consMarkerSymbol = "**consMarkerSymbol**";
  private static final int STWORD = MyStreamTokenizer.TT_WORD;
  private static final int STNUMBER = MyStreamTokenizer.TT_NUMBER;
  
  /**
   * Verbosity indicator <tt>0</tt> indicates quiet on a range of
   * <tt>0</tt> ... <tt>10</tt>
   */
  public static int verbosity = 0;
  
  /** Constructs a new <tt>CycListParser</tt> object.
   * @@param cycAccess the cyc access object
   */
  public CycListParser(CycAccess cycAccess) {
    this.cycAccess = cycAccess;
  }
  
  /** Parses a <tt>CycList</tt> string representation.
   * @@return the corresponding <tt>CycList</tt>
   * @@param string the string to be parsed
   * @@throws CycApiException when a Cyc API error occurs
   */
  public CycList read(String string) throws CycApiException {
    currentString = string;
    st = makeStreamTokenizer(string);
    return read(st);
  }
  
  /**
   * Returns the unused portion of the string after a CycList
   * expression has been parsed.
   *
   * @@return the unused portion of the string after a CycList
   * expression has been parsed
   */
  public String remainingString() {
    StringBuffer remainingStringBuffer = new StringBuffer();
    if (tok == st.TT_EOF)
      return "";
    st.resetSyntax();
    try {
      while (true) {
        tok = st.nextToken();
        if (tok == st.TT_EOF)
          break;
        remainingStringBuffer.append((char) tok);
      }
    }
    catch (IOException e) {
      throw new RuntimeException(e.getMessage());
    }
    return remainingStringBuffer.toString();
  }
  
  /**
   * Returns a configured StreamTokenizer.
   *
   * @@param string the string to be parsed
   * @@return a configured StreamTokenizer
   */
  protected static MyStreamTokenizer makeStreamTokenizer(String string) {
    StringReader stringReader = new StringReader(string);
    MyStreamTokenizer st = new MyStreamTokenizer(stringReader);
    st.resetSyntax();
    st.ordinaryChar('(');
    st.ordinaryChar(')');
    st.ordinaryChar('\'');
    st.ordinaryChar('`');
    st.ordinaryChar('.');
    st.whitespaceChars(0, ' ');
    st.quoteChar('"');
    st.wordChars('0', '9');
    st.wordChars('a', 'z');
    st.wordChars('A', 'Z');
    st.wordChars(128 + 32, 255);
    st.wordChars('=', '=');
    st.wordChars('+', '+');
    st.wordChars('-', '-');
    st.wordChars('_', '_');
    st.wordChars('<', '<');
    st.wordChars('>', '>');
    st.wordChars('*', '*');
    st.wordChars('/', '/');
    st.wordChars('#', '#');
    st.wordChars(':', ':');
    st.wordChars('!', '!');
    st.wordChars('$', '$');
    st.wordChars('?', '?');
    st.wordChars('%', '%');
    st.wordChars('&', '&');
    st.wordChars('.', '.');
    st.slashSlashComments(false);
    st.slashStarComments(false);
    st.commentChar(';');
    st.wordChars('?', '?');
    st.wordChars('%', '%');
    st.wordChars('&', '&');
    st.eolIsSignificant(false);
    return st;
  }
  
  /** Parses a <tt>CycList</tt> string representation.
   * @@return the corresponding <tt>CycList</tt>
   * @@param st a <tt>StreamTokenizer</tt> whose source is the
   * <tt>CycList</tt> string representation.
   * @@throws CycApiException when a Cyc API error is detected
   */
  public CycList read(MyStreamTokenizer st) throws CycApiException {
    endQuote = false;
    
    // Read and parse a lisp symbolic expression.
    try {
      while (true) {
        tok = st.nextToken();
        if (verbosity > 0)
          System.out.println("sval: " + st.sval +
          "  st: " + st.toString() +
          "  tok: " + tok);
        
        if (endQuote) {
          // Close a quoted expression by inserting a right paren.
          endQuote = false;
          st.pushBack();
          scanRightParen();
        }
        else if (tok == st.TT_EOF)
          break;
        else {
          switch (tok) {
            case STWORD:
              scanWord(st);
              break;
            case STNUMBER:
              throw new RuntimeException("Unexpected number");
              //scanNumber(st, true);
              //break;
            case 34:	// "
              scanString(st);
              break;
            case 39:	// Quote.
              scanQuote();
              continue;
            case 96:	// Backquote.
              scanBackquote();
              continue;
            case 40:	// Left Paren
              ScanLeftParen();
              continue;
            case 41:	// Right Paren
              scanRightParen();
              break;
            case 44:	// ,
              scanComma(st);
              break;
            case 45:	// -
              scanMinus();
              break;
            default:
              throw new RuntimeException("Invalid symbol: " + st.toString() +
              " token: " + tok +
              "\nstring: " + currentString);
          }
        }
        if ((readStack.sp > 0) && (parenLevel == 0)) {
          // Parsed a complete symbolic expression.
          Object object = readStack.pop();
          if (object.equals(CycObjectFactory.nil))
            return new CycList(new ArrayList());
          else
            return (CycList) reduceDottedPairs((CycList) object);
        }
      }
      if (readStack.sp > 0)
        throw new RuntimeException("Invalid expression, sval: " +
        st.sval +
        "  st: " +
        st.toString() +
        "  tok: " +
        tok +
        "\nreadStack: " + readStack.toString() +
        "\nstring: " + currentString);
    }
    catch ( IOException ioe ) {
      throw new RuntimeException(ioe.getMessage());
    }
    throw new RuntimeException("End of stream");
  }
  
  /**
   * Expands 's to (quote s  when reading.
   */
  private void scanQuote() {
    Integer i;
    if (verbosity > 5)
      System.out.println("'");
    
    if ((parenLevel > 0) && (parenLevel != readStack.sp))
      readStack.push(consMarkerSymbol);
    
    readStack.push(consMarkerSymbol);
    quoteStack.push(new Integer(++parenLevel));
    readStack.push(CycObjectFactory.quote);
  }
  
  /**
   * Expands #'s to (function s  when reading.
   */
  private void scanFunctionQuote() {
    Integer i;
    
    if (verbosity > 5)
      System.out.println("#'");
    
    if ((parenLevel > 0) && (parenLevel != readStack.sp))
      readStack.push(consMarkerSymbol);
    
    readStack.push(consMarkerSymbol);
    quoteStack.push(new Integer(++parenLevel));
    readStack.push(CycObjectFactory.makeCycSymbol("function"));
  }
  
  /**
   * Scans a left parenthesis when reading.
   */
  private void ScanLeftParen() {
    if (verbosity > 5)
      System.out.println("(");
    // Begin a list.
    readStack.push(consMarkerSymbol );
    ++parenLevel;
  }
  
  /**
   * Scans a right parenthesis when reading.
   */
  private void scanRightParen() {
    CycConstant cons;
    Object firstElement;
    Object remainingElements;
    
    if (verbosity > 5)
      System.out.println(")");
    
    if (parenLevel == 0)
      throw new RuntimeException( "read: Extra right parenthesis" );
    else if ((readStack.sp == parenLevel) &&
    (readStack.peek().equals(CycObjectFactory.cons)))
      // Have an empty list.
      readStack.pop();
    
    // Terminate the list.
    readStack.push(CycObjectFactory.nil);
    --parenLevel;
    
    checkQuotes();
    
    // Construct the list from cons cells.
    // 'a becomes (1)cons (2)quote (3)cons (4)a (5)nil
    // Transformed to (1) cons  (quote a)
    
    while (readStack.sp > 2) {
      remainingElements = readStack.pop();
      firstElement = readStack.pop();
      
      if ((readStack.peek()).equals(consMarkerSymbol) &&
      (! firstElement.equals(consMarkerSymbol)) &&
      (! remainingElements.equals(consMarkerSymbol))) {
        readStack.pop();	// Discard cons marker atom.
        // Replace it with cons cell.
        readStack.push(CycList.construct(firstElement, remainingElements));
      }
      else {
        // Not a cons, so restore readStack.
        readStack.push(firstElement);
        readStack.push(remainingElements);
        break;
      }
    }
  }
  
  /**
   * Scans a number while reading.
   *
   * @@param string the input string from which to get the numerical value.
   */
  private void scanNumber(String string) {
    Double parsedNumber = new Double(string);
    Double doubleNumber;
    Integer integerNumber;
    Long longNumber;
    Object number = null;
    
    if (verbosity > 5)
      System.out.println(string);
    // Try representing the scanned number as both java double and long.
    doubleNumber = parsedNumber;
    integerNumber = new Integer(doubleNumber.intValue());
    longNumber = new Long(doubleNumber.longValue());
    
    if (integerNumber.doubleValue() == doubleNumber.doubleValue())
      // Choose integer if no loss of accuracy.
      number = integerNumber;
    else if (longNumber.doubleValue() == doubleNumber.doubleValue())
      number = longNumber;
    else
      number = doubleNumber;
    
    if (( parenLevel > 0 ) && ( parenLevel != readStack.sp ))
      // Within a list.
      readStack.push( consMarkerSymbol );
    
    readStack.push(number);
    checkQuotes();
  }
  
  /**
   * Scans a minus while reading.
   */
  private void scanMinus() {
    if (verbosity > 5)
      System.out.println("-");
    CycSymbol w = CycObjectFactory.makeCycSymbol("-");
    
    if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
      // Within a list.
      readStack.push(consMarkerSymbol);
    
    readStack.push(w);
    checkQuotes();
  }
  
  /**
   * Scans a backquote while reading.
   */
  private void scanBackquote() {
    if (verbosity > 5)
      System.out.println("`");
    CycSymbol w = CycObjectFactory.makeCycSymbol("`");
    
    if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
      // Within a list.
      readStack.push(consMarkerSymbol);
    
    readStack.push(w);
    checkQuotes();
  }
  
  /**
   * Scans a comma while reading.
   */
  private void scanComma(MyStreamTokenizer st) throws IOException {
    CycSymbol w;
    if (st.nextToken() == '@@') {
      if (verbosity > 5)
        System.out.println(",@@");
      w = CycObjectFactory.makeCycSymbol(",@@");
    }
    else {
      if (verbosity > 5)
        System.out.println(",");
      w = CycObjectFactory.makeCycSymbol(",");
    }
    st.pushBack();
    
    if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
      // Within a list.
      readStack.push(consMarkerSymbol);
    
    readStack.push(w);
    checkQuotes();
  }
  
  /**
   * Scans a word while reading.
   *
   * @@param the input <tt>StreamTokenizer</tt> from which to get the word value.
   */
  private void scanWord(MyStreamTokenizer st)
  throws IOException, CycApiException {
    if (verbosity > 5)
      System.out.println(st.sval);
    Object w = null;
    char firstChar = st.sval.charAt(0);
    if (st.sval.startsWith("#$"))
      w = cycAccess.getKnownConstantByName(st.sval);
    else if (firstChar == '?')
      w = CycObjectFactory.makeCycVariable(st.sval);
    else if (st.sval.equals("#")) {
      int nextTok = st.nextToken();
      if (nextTok == 39) {
        scanFunctionQuote();
        return;
      }
      else {
        st.pushBack();
        w = CycObjectFactory.makeCycSymbol(st.sval);
      }
    }
    else if (((firstChar == '-') && (!st.sval.equals("-"))) ||
        Character.isDigit(firstChar)) {
      scanNumber(st.sval);
      return;
    }
    else
      w = CycObjectFactory.makeCycSymbol(st.sval);
    
    if ((parenLevel > 0) && (readStack.sp != parenLevel))
      // Within a list.
      readStack.push(consMarkerSymbol );
    
    readStack.push(w);
    checkQuotes();
  }
  
  /**
   * Scans a string while reading.
   */
  private void scanString(MyStreamTokenizer st) {
    String string = new String(st.sval);
    String line1;
    String line2;
    int index;
    
    //Replace `~ combination with crlf since StreamTokenizer cannot
    //span multiple lines.
    
    while (true) {
      index = string.indexOf("`~");
      if (index == -1)
        break;
      
      line1 = new String(string.substring( 0, index));
      line2 = new String( string.substring( index + 2));
      string = line1 + "\r\n" + line2;
    }
    
    if (verbosity > 5)
      System.out.println(st.sval);
    if ((parenLevel > 0 ) && (readStack.sp != parenLevel))
      // Within a list.
      readStack.push(consMarkerSymbol );
    
    readStack.push(string);
    checkQuotes();
  }
  
  /**
   * Read/Scan helper routine to check for the end of quoted forms.
   */
  private void checkQuotes() {
    if ((! quoteStack.empty()) &&
    (( (Integer) quoteStack.peek()).intValue() == parenLevel )) {
      quoteStack.pop();
      endQuote = true;
    }
  }
  
  /**
   * Performs a lexical analysis of the list and perform dot
   * cons cell operations.
   *
   * @@param the <tt>Object</tt> under consideration.
   * @@return the input <tt>Object</tt> if not a <tt>CycList</tt>, otherwise
   * reduce the dotted pairs in the list if possible.
   */
  private Object reduceDottedPairs(Object s ) {
    if (! (s instanceof CycList))
      return s;
    CycList cycList = (CycList) s;
    if (cycList.size() == 0)
      return s;
    else if (cycList.size() == 3 &&
    cycList.second().equals(CycObjectFactory.dot)) {
      Object first = reduceDottedPairs(cycList.first());
      Object third = reduceDottedPairs(cycList.third());
      if (cycList.third() instanceof CycList) {
        // Replace list (a . (b)) with list (a b)
        CycList reducedCycList = new CycList(first);
        reducedCycList.addAll((CycList) third);
        if (! ((CycList) third).isProperList())
          reducedCycList.setDottedElement(((CycList) third).getDottedElement());
        return reducedCycList;
      }
      else {
        // Mark list (a . b) as improper and remove the dot symbol.
        CycList improperList = new CycList(first);
        improperList.setDottedElement(third);
        return improperList;
      }
    }
    Object firstReducedDottedPair = reduceDottedPairs(cycList.first());
    Object restReducedDottedPair = reduceDottedPairs(cycList.rest());
    CycList constructedCycList = CycList.construct(firstReducedDottedPair,
    restReducedDottedPair);
    return constructedCycList;
  }
}
@


1.25
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@d6 1
d10 1
a11 1
import org.opencyc.util.MyStreamTokenizer;
@


1.24
log
@Added more code to the chat parser
@
text
@d3 8
a10 5
import java.util.*;
import java.io.*;
import ViolinStrings.*;
import org.opencyc.util.*;
import org.opencyc.api.*;
d39 65
a103 62

    // Read/scan functions' lexical analysis variables.
    private int tok;
    private boolean endQuote = false;
    private boolean dot = false;
    private boolean dotWord = false;
    private boolean dotParen = false;
    private int parenLevel = 0;
    private StackWithPointer readStack = new StackWithPointer();
    private StackWithPointer quoteStack = new StackWithPointer();
    private String currentString = "";


    /**
     * the stream tokenizer for the current string
     */
    protected StreamTokenizer st;

    /**
     * Cyc api support.
     */
    protected CycAccess cycAccess;

    private static final String consMarkerSymbol = "**consMarkerSymbol**";
    private static final int STWORD = StreamTokenizer.TT_WORD;
    private static final int STNUMBER = StreamTokenizer.TT_NUMBER;

    /**
     * Verbosity indicator <tt>0</tt> indicates quiet on a range of
     * <tt>0</tt> ... <tt>10</tt>
     */
    public static int verbosity = 0;

    /**
     * Constructs a new <tt>CycListParser</tt> object.
     */
    public CycListParser(CycAccess cycAccess) {
        this.cycAccess = cycAccess;
    }

    /**
     * Parses a <tt>CycList</tt> string representation.
     *
     * @@param st a <tt>StreamTokenizer</tt> whose source is the
     * <tt>CycList</tt> string representation.
     * @@return the corresponding <tt>CycList</tt>
     */
    public CycList read (String string) throws CycApiException {
        currentString = string;
        st = makeStreamTokenizer(string);
        return read(st);
    }

    /**
     * Returns the unused portion of the string after a CycList
     * expression has been parsed.
     *
     * @@return the unused portion of the string after a CycList
     * expression has been parsed
     */
    public String remainingString () {
        StringBuffer remainingStringBuffer = new StringBuffer();
d105 80
a184 319
            return "";
        st.resetSyntax();
        try {
            while (true) {
                tok = st.nextToken();
                if (tok == st.TT_EOF)
                    break;
                remainingStringBuffer.append((char) tok);
            }
        }
        catch (IOException e) {
            throw new RuntimeException (e.getMessage());
        }
        return remainingStringBuffer.toString();
    }

    /**
     * Returns a configured StreamTokenizer.
     *
     * @@param string the string to be parsed
     * @@return a configured StreamTokenizer
     */
    protected static StreamTokenizer makeStreamTokenizer (String string) {
        StringReader stringReader = new StringReader(string);
        StreamTokenizer st = new StreamTokenizer(stringReader);
        st.resetSyntax();
        st.ordinaryChar('(');
        st.ordinaryChar(')');
        st.ordinaryChar('\'');
        st.ordinaryChar('`');
        st.ordinaryChar('.');
        st.whitespaceChars(0, ' ');
        st.quoteChar('"');
        st.wordChars('0', '9');
        st.wordChars('a', 'z');
        st.wordChars('A', 'Z');
        st.wordChars(128 + 32, 255);
        st.wordChars('=', '=');
        st.wordChars('+', '+');
        st.wordChars('-', '-');
        st.wordChars('_', '_');
        st.wordChars('<', '<');
        st.wordChars('>', '>');
        st.wordChars('*', '*');
        st.wordChars('/', '/');
        st.wordChars('#', '#');
        st.wordChars(':', ':');
        st.wordChars('!', '!');
        st.wordChars('$', '$');
        st.wordChars('?', '?');
        st.wordChars('%', '%');
        st.wordChars('&', '&');
        st.wordChars('.', '.');
        st.slashSlashComments(false);
        st.slashStarComments(false);
        st.commentChar(';');
        st.wordChars('?', '?');
        st.wordChars('%', '%');
        st.wordChars('&', '&');
        st.eolIsSignificant(false);
        return st;
    }

    /**
     * Parses a <tt>CycList</tt> string representation.
     *
     * @@param st a <tt>StreamTokenizer</tt> whose source is the
     * <tt>CycList</tt> string representation.
     * @@return the corresponding <tt>CycList</tt>
     */
    public CycList read (StreamTokenizer st) throws CycApiException {
        endQuote = false;

        // Read and parse a lisp symbolic expression.
        try {
            while (true) {
                tok = st.nextToken();
                if (verbosity > 0)
                    System.out.println("sval: " + st.sval +
                                       "  st: " + st.toString() +
                                       "  tok: " + tok);

                if (endQuote) {
                    // Close a quoted expression by inserting a right paren.
                    endQuote = false;
                    st.pushBack();
                    scanRightParen();
                    }
                else if (tok == st.TT_EOF)
                    break;
                else {
                    switch (tok) {
                        case STWORD:
                            scanWord(st);
                            break;
                        case STNUMBER:
                            throw new RuntimeException("Unexpected number");
                            //scanNumber(st, true);
                            //break;
                        case 34:	// "
                            scanString(st);
                            break;
                        case 39:	// Quote.
                            scanQuote();
                            continue;
                        case 96:	// Backquote.
                            scanBackquote();
                            continue;
                        case 40:	// Left Paren
                            ScanLeftParen();
                            continue;
                        case 41:	// Right Paren
                            scanRightParen();
                            break;
                        case 44:	// ,
                            scanComma(st);
                            break;
                        case 45:	// -
                            scanMinus();
                            break;
                        default:
                            throw new RuntimeException("Invalid symbol: " + st.toString() +
                                                       " token: " + tok +
                                                       "\nstring: " + currentString);
                    }
                }
                if ((readStack.sp > 0) && (parenLevel == 0)) {
                    // Parsed a complete symbolic expression.
                    Object object = readStack.pop();
                    if (object.equals(CycObjectFactory.nil))
                        return new CycList(new ArrayList());
                    else
                        return (CycList) reduceDottedPairs((CycList) object);
                }
            }
            if (readStack.sp > 0)
                throw new RuntimeException ("Invalid expression, sval: " +
                                            st.sval +
                                            "  st: " +
                                            st.toString() +
                                            "  tok: " +
                                            tok +
                                            "\nreadStack: " + readStack.toString() +
                                            "\nstring: " + currentString);
        }
        catch ( IOException ioe ) {
            throw new RuntimeException(ioe.getMessage());
        }
        throw new RuntimeException("End of stream");
    }

    /**
     * Expands 's to (quote s  when reading.
     */
    private void scanQuote() {
        Integer i;
        if (verbosity > 5)
            System.out.println("'");

        if ((parenLevel > 0) && (parenLevel != readStack.sp))
            readStack.push(consMarkerSymbol);

        readStack.push(consMarkerSymbol);
        quoteStack.push(new Integer(++parenLevel));
        readStack.push(CycObjectFactory.quote);
    }

    /**
     * Expands #'s to (function s  when reading.
     */
    private void scanFunctionQuote() {
        Integer i;

        if (verbosity > 5)
            System.out.println("#'");

        if ((parenLevel > 0) && (parenLevel != readStack.sp))
            readStack.push(consMarkerSymbol);

        readStack.push(consMarkerSymbol);
        quoteStack.push(new Integer(++parenLevel));
        readStack.push(CycObjectFactory.makeCycSymbol("function"));
    }

    /**
     * Scans a left parenthesis when reading.
     */
    private void ScanLeftParen() {
        if (verbosity > 5)
            System.out.println("(");
        // Begin a list.
        readStack.push(consMarkerSymbol );
        ++parenLevel;
    }

    /**
     * Scans a right parenthesis when reading.
     */
    private void scanRightParen() {
        CycConstant cons;
        Object firstElement;
        Object remainingElements;

        if (verbosity > 5)
            System.out.println(")");

        if (parenLevel == 0)
            throw new RuntimeException( "read: Extra right parenthesis" );
        else if ((readStack.sp == parenLevel) &&
                 (readStack.peek().equals(CycObjectFactory.cons)))
            // Have an empty list.
            readStack.pop();

        // Terminate the list.
        readStack.push(CycObjectFactory.nil);
        --parenLevel;

        checkQuotes();

        // Construct the list from cons cells.
        // 'a becomes (1)cons (2)quote (3)cons (4)a (5)nil
        // Transformed to (1) cons  (quote a)

        while (readStack.sp > 2) {
            remainingElements = readStack.pop();
            firstElement = readStack.pop();

            if ((readStack.peek()).equals(consMarkerSymbol) &&
                 (! firstElement.equals(consMarkerSymbol)) &&
                 (! remainingElements.equals(consMarkerSymbol))) {
                readStack.pop();	// Discard cons marker atom.
                                    // Replace it with cons cell.
                readStack.push(CycList.construct(firstElement, remainingElements));
                }
            else {
                // Not a cons, so restore readStack.
                readStack.push(firstElement);
                readStack.push(remainingElements);
                break;
                }
            }
        }

    /**
     * Scans a number while reading.
     *
     * @@param string the input string from which to get the numerical value.
     */
    private void scanNumber(String string) {
        Double parsedNumber = new Double(string);
        Double doubleNumber;
        Integer integerNumber;
        Long longNumber;
        Object number = null;

        if (verbosity > 5)
            System.out.println(string);
        // Try representing the scanned number as both java double and long.
        doubleNumber = parsedNumber;
        integerNumber = new Integer(doubleNumber.intValue());
        longNumber = new Long(doubleNumber.longValue());

        if (integerNumber.doubleValue() == doubleNumber.doubleValue())
            // Choose integer if no loss of accuracy.
            number = integerNumber;
        else if (longNumber.doubleValue() == doubleNumber.doubleValue())
            number = longNumber;
        else
            number = doubleNumber;

        if (( parenLevel > 0 ) && ( parenLevel != readStack.sp ))
            // Within a list.
            readStack.push( consMarkerSymbol );

        readStack.push(number);
        checkQuotes();
    }

    /**
     * Scans a minus while reading.
     */
    private void scanMinus() {
        if (verbosity > 5)
            System.out.println("-");
        CycSymbol w = CycObjectFactory.makeCycSymbol("-");

        if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
            // Within a list.
            readStack.push(consMarkerSymbol);

        readStack.push(w);
        checkQuotes();
    }

    /**
     * Scans a backquote while reading.
     */
    private void scanBackquote() {
        if (verbosity > 5)
            System.out.println("`");
        CycSymbol w = CycObjectFactory.makeCycSymbol("`");

        if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
            // Within a list.
            readStack.push(consMarkerSymbol);

        readStack.push(w);
        checkQuotes();
    }

    /**
     * Scans a comma while reading.
     */
    private void scanComma(StreamTokenizer st) throws IOException {
        CycSymbol w;
        if (st.nextToken() == '@@') {
            if (verbosity > 5)
                System.out.println(",@@");
            w = CycObjectFactory.makeCycSymbol(",@@");
d186 2
d189 266
a454 4
            if (verbosity > 5)
                System.out.println(",");
            w = CycObjectFactory.makeCycSymbol(",");
        }
d456 2
a457 132

        if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
            // Within a list.
            readStack.push(consMarkerSymbol);

        readStack.push(w);
        checkQuotes();
    }

    /**
     * Scans a word while reading.
     *
     * @@param the input <tt>StreamTokenizer</tt> from which to get the word value.
     */
    private void scanWord(StreamTokenizer st)
        throws IOException, CycApiException {
        if (verbosity > 5)
            System.out.println(st.sval);
        Object w = null;
        String firstChar = st.sval.substring(0, 1);
        if (st.sval.startsWith("#$"))
            w = cycAccess.makeCycConstant(st.sval);
        else if (firstChar.equals("?"))
            w = CycObjectFactory.makeCycVariable(st.sval);
        else if (st.sval.equals("#")) {
            int nextTok = st.nextToken();
            if (nextTok == 39) {
                scanFunctionQuote();
                return;
            }
            else {
                st.pushBack();
                w = CycObjectFactory.makeCycSymbol(st.sval);
            }
        }
        else if ((firstChar.equals("-") && (! st.sval.equals("-"))) ||
                 Strings.isDigit(firstChar)) {
            scanNumber(st.sval);
            return;
        }
        else
            w = CycObjectFactory.makeCycSymbol(st.sval);

        if ((parenLevel > 0) && (readStack.sp != parenLevel))
            // Within a list.
            readStack.push(consMarkerSymbol );

        readStack.push(w);
        checkQuotes();
    }

    /**
     * Scans a string while reading.
     */
    private void scanString(StreamTokenizer st) {
        String string = new String(st.sval);
        String line1;
        String line2;
        int index;

        //Replace `~ combination with crlf since StreamTokenizer cannot
        //span multiple lines.

        while (true) {
            index = string.indexOf("`~");
            if (index == -1)
                break;

            line1 = new String (string.substring( 0, index));
            line2 = new String ( string.substring( index + 2));
            string = line1 + "\r\n" + line2;
        }

        if (verbosity > 5)
            System.out.println(st.sval);
        if ((parenLevel > 0 ) && (readStack.sp != parenLevel))
            // Within a list.
            readStack.push(consMarkerSymbol );

        readStack.push(string);
        checkQuotes();
    }

    /**
     * Read/Scan helper routine to check for the end of quoted forms.
     */
    private void checkQuotes() {
        if ((! quoteStack.empty()) &&
            (( (Integer) quoteStack.peek()).intValue() == parenLevel )) {
            quoteStack.pop();
            endQuote = true;
        }
    }

    /**
     * Performs a lexical analysis of the list and perform dot
     * cons cell operations.
     *
     * @@param the <tt>Object</tt> under consideration.
     * @@return the input <tt>Object</tt> if not a <tt>CycList</tt>, otherwise
     * reduce the dotted pairs in the list if possible.
     */
    private Object reduceDottedPairs (Object s ) {
        if (! (s instanceof CycList))
            return s;
        CycList cycList = (CycList) s;
        if (cycList.size() == 0)
            return s;
        else if (cycList.size() == 3 &&
                 cycList.second().equals(CycObjectFactory.dot)) {
            Object first = reduceDottedPairs(cycList.first());
            Object third = reduceDottedPairs(cycList.third());
            if (cycList.third() instanceof CycList) {
                // Replace list (a . (b)) with list (a b)
                CycList reducedCycList = new CycList(first);
                reducedCycList.addAll((CycList) third);
                if (! ((CycList) third).isProperList())
                    reducedCycList.setDottedElement(((CycList) third).getDottedElement());
                return reducedCycList;
            }
            else {
                // Mark list (a . b) as improper and remove the dot symbol.
                CycList improperList = new CycList(first);
                improperList.setDottedElement(third);
                return improperList;
            }
        }
        Object firstReducedDottedPair = reduceDottedPairs(cycList.first());
        Object restReducedDottedPair = reduceDottedPairs(cycList.rest());
        CycList constructedCycList = CycList.construct(firstReducedDottedPair,
                                                       restReducedDottedPair);
        return constructedCycList;
d459 99
a557 1
}@


1.23
log
@CVS synchronization with changes made for the DAML PI meeting.
@
text
@d38 1
d48 6
d57 1
a57 1
    CycAccess cycAccess;
d85 1
a85 1
        StreamTokenizer st = makeStreamTokenizer(string);
d90 26
a169 1
        int tok;
@


1.22
log
@Fix CycNart toString() bug.
@
text
@a2 1

d78 11
d91 1
d97 6
d126 1
a126 3
        st.parseNumbers();

        return read(st);
d163 3
a165 2
                            scanNumber(st, true);
                            break;
d313 1
a313 1
     * @@param the input <tt>StreamTokenizer</tt> from which to get the numerical value.
d315 2
a316 1
    private void scanNumber(StreamTokenizer st, boolean positive) {
d323 1
a323 1
            System.out.println(st.nval );
d325 3
a327 11
        if (positive) {
            doubleNumber = new Double (st.nval);
            integerNumber = new Integer(doubleNumber.intValue());
            longNumber = new Long(doubleNumber.longValue());
        }
        else {
            doubleNumber = new Double (- st.nval);
            integerNumber = new Integer(- doubleNumber.intValue());
            longNumber = new Long(- doubleNumber.longValue());
        }

a408 1

d412 1
d415 1
a415 1
        else if (st.sval.startsWith("?"))
d428 4
a431 9
        else if (st.sval.equals("-")) {
            int nextTok = st.nextToken();
            st.pushBack();
            if (nextTok == STNUMBER) {
                scanNumber(st, false);
                return;
            }
            else
                w = CycObjectFactory.makeCycSymbol(st.sval);
@


1.21
log
@Added Log class to the api package classes.
@
text
@a93 1
        st.wordChars('.', '.');
d101 1
d105 3
d109 1
@


1.20
log
@Handled embedded quotes within strings sent to Cyc.  This patch makes the ascii
and cfasl (binary) api commands behave the same.  Added unit test cases.
@
text
@d12 2
a13 1
 * the corresponding <tt>CycList</tt>.
d169 2
a170 1
                                                       " token: " + tok);
@


1.19
log
@Adapted regression test to work with recent alpha version of OpenCyc.
@
text
@d45 1
d77 1
d186 3
a188 1
                                            tok);
d451 2
a452 2
            line1 = new String (string.substring( 0, index ));
            line2 = new String ( string.substring( index + 2 ));
d457 2
a458 2
            System.out.println(st.sval );
        if (( parenLevel > 0 ) && ( readStack.sp != parenLevel ))
@


1.18
log
@Prepared ApiDemo class as first in a series for the programming tutorial.  Other modules
updated in preparation for public beta release.
@
text
@d76 1
a76 3
        String tempString = Strings.change(string, '\r', ' ');
        tempString = Strings.change(tempString, '\n', ' ');
        StringReader stringReader = new StringReader(tempString);
d78 25
a102 22
        st.commentChar( ';' );
        st.ordinaryChar( '(' );
        st.ordinaryChar( ')' );
        st.ordinaryChar( '\'' );
        st.ordinaryChar( '`' );
        st.ordinaryChar( '.' );
        st.wordChars( '=', '=' );
        st.wordChars( '+', '+' );
        st.wordChars( '-', '-' );
        st.wordChars( '_', '_' );
        st.wordChars( '<', '<' );
        st.wordChars( '>', '>' );
        st.wordChars( '*', '*' );
        st.wordChars( '/', '/' );
        st.wordChars( '.', '.' );
        st.wordChars( '#', '#' );
        st.wordChars( ':', ':' );
        st.wordChars( '!', '!' );
        st.wordChars( '$', '$' );
        st.wordChars( '?', '?' );
        st.wordChars( '%', '%' );
        st.wordChars( '&', '&' );
@


1.17
log
@Developing AgentManager for cyc agents
@
text
@d76 3
a78 1
        StringReader stringReader = new StringReader(string);
@


1.16
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@d287 4
a290 3
        Double d;
        Integer i;
        Object n = null;
d294 1
a294 1
        // Try representing the scanned number as both java double and integer.
d296 3
a298 2
            d = new Double (st.nval);
            i = new Integer(d.intValue());
d301 3
a303 2
            d = new Double (- st.nval);
            i = new Integer(- d.intValue());
d306 6
a311 3
        // Choose integer if no loss of accuracy.
        if ( i.doubleValue() == d.doubleValue() )
            n = i;
d313 1
a313 1
            n = d;
d319 1
a319 1
        readStack.push( n );
@


1.15
log
@Fixed parsing of dotted lists
@
text
@d75 1
a75 1
    public CycList read (String string) {
d111 1
a111 1
    public CycList read (StreamTokenizer st) {
d380 1
a380 1
        throws IOException {
@


1.14
log
@Fixed errors in mapdictionary api function discovered by unit test cases.
@
text
@d497 5
a501 2
        return CycList.construct(reduceDottedPairs(cycList.first()),
                                 reduceDottedPairs(cycList.rest()));
@


1.13
log
@Added more unit test cases for server SubL scripting
@
text
@d91 1
d194 2
a195 2

        //System.out.println("'");
d211 2
a212 1
        //System.out.println("#'");
d226 2
a227 1
        //System.out.println("(");
d241 2
a242 1
        //System.out.println(")");
d291 2
a292 1
        //System.out.println(st.nval );
d321 2
a322 1
        //System.out.println("-");
d337 2
a338 1
        //System.out.println("`");
d355 2
a356 1
            //System.out.println(",@@");
d360 2
a361 1
            //System.out.println(",");
d382 2
a383 1
        //System.out.println(st.sval );
d443 2
a444 1
        //System.out.println(st.sval );
@


1.12
log
@Added more test cases for SubL server scripting
@
text
@d137 1
a137 1
                            scanNumber(st);
d282 1
a282 1
    private void scanNumber(StreamTokenizer st) {
d289 8
a296 2
        d = new Double (st.nval);
        i = new Integer(d.intValue());
d389 10
@


1.11
log
@Added code to support backquoted expressions in the binary api
@
text
@d205 16
d373 11
@


1.10
log
@Added more unit test cases for SubL server scripting
@
text
@a38 1
    private boolean endComma = false;
a111 1

a112 1
        endComma = false;
a128 6
                else if (endComma) {
                    // Close a comma expression by inserting a right paren.
                    endComma = false;
                    st.pushBack();
                    scanRightParen();
                    }
d155 1
a155 1
                            scanComma();
a204 15
     * Expands `s to (backquote s  when reading.
     */
    private void scanBackquote() {
        Integer i;

        //System.out.println("`");
        if ((parenLevel > 0) && (parenLevel != readStack.sp))
            readStack.push(consMarkerSymbol);

        readStack.push(consMarkerSymbol);
        quoteStack.push(new Integer(++parenLevel));
        readStack.push(CycObjectFactory.backquote);
    }

    /**
d306 15
d323 11
a333 3
    private void scanComma() {
        //System.out.println(",");
        CycSymbol w = CycObjectFactory.makeCycSymbol(",");
@


1.9
log
@Added unit test cases for server side scripting in SubL
@
text
@a38 1
    private boolean endBackquote = false;
d83 1
a114 1
        endBackquote = false;
a131 6
                else if (endBackquote) {
                    // Close a backquoted expression by inserting a right paren.
                    endBackquote = false;
                    st.pushBack();
                    scanRightParen();
                    }
d154 3
d163 4
a166 1
                        case 45:	// ,
d170 2
a171 1
                            throw new RuntimeException("Invalid symbol: " + st.toString());
a204 1
        // Expand 's to (quote s .
d214 15
d320 15
@


1.8
log
@Created new CycObjectFactory class to contain all cyc object caches
@
text
@d6 1
@


1.7
log
@Added more backchain support - testing with one level of backchaining
@
text
@d176 1
a176 1
                    if (object.equals(CycSymbol.nil))
d210 1
a210 1
        readStack.push(CycSymbol.quote);
d236 1
a236 1
                 (readStack.peek().equals(CycSymbol.cons)))
d241 1
a241 1
        readStack.push(CycSymbol.nil);
d304 1
a304 1
        CycSymbol w = CycSymbol.makeCycSymbol("-");
d327 1
a327 1
            w = CycVariable.makeCycVariable(st.sval);
d329 1
a329 1
            w = CycSymbol.makeCycSymbol(st.sval);
d396 1
a396 1
                 cycList.second().equals(CycSymbol.dot)) {
@


1.6
log
@Refactored binary api support to pass all unit tests
@
text
@a78 6
/*
        st.wordChars('#', '#');
        st.wordChars('$', '$');
        st.wordChars(':', ':');
        st.wordChars('?', '?');
*/
d87 1
@


1.5
log
@Unit test cases for binary api connnection
@
text
@d282 1
a282 1
        Long i;
d286 3
a288 3
        // Try representing the scanned number as both java double and long.
        d = new Double ( st.nval );
        i = new Long( d.intValue() );
d290 1
a290 1
        // Choose long if no loss of accuracy.
@


1.4
log
@Made CycAccess the factory object for CycLists
@
text
@d309 1
a309 1
        CycSymbol w = new CycSymbol("-");
d334 1
a334 1
            w = new CycSymbol(st.sval);
@


1.3
log
@Revised copyright notice to Cycorp Inc.
@
text
@d7 1
d46 6
d65 2
a66 1
    public CycListParser() {
d324 2
a325 1
    private void scanWord(StreamTokenizer st) {
d330 1
a330 1
            w = CycConstant.makeCycConstant(st.sval);
@


1.2
log
@Updated javadoc comments.
Employed apache-oro cache classes
@
text
@d15 1
a15 1
 * <p>Copyright 2001 OpenCyc.org, license is open source GNU LGPL.
@


1.1
log
@Initial revision
@
text
@d8 2
a9 2
/*****************************************************************************
 * Provides a parser that reads <tt>String</tt> representation and constructs
d13 1
a13 2
 * @@author
 *      Stephen L. Reed<P>
d15 18
a32 5
 * Copyright 2001 OpenCyc.org, license is open source GNU LGPL.<p>
 * <a href="http://www.opencyc.org">www.opencyc.org</a>
 * <a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 *****************************************************************************/

d56 1
a56 1
     * Construct a new <tt>CycListParser</tt> object.
d62 1
a62 1
     * Parse a <tt>CycList</tt> string representation.
d101 1
a101 1
     * Parse a <tt>CycList</tt> string representation.
d194 1
a194 1
     * Expand 's to (quote s  when reading.
d211 1
a211 1
     * Scan a left parenthesis when reading.
d221 1
a221 1
     * Scan a right parenthesis when reading.
d268 1
a268 1
     * Scan a number while reading.
d297 1
a297 1
     * Scan a minus while reading.
d312 1
a312 1
     * Scan a word while reading.
d336 1
a336 1
     * Scan a string while reading.
d378 1
a378 1
     * Perform a lexical analysis of the list and perform dot
@


1.1.1.1
log
@Imported sources
@
text
@@
