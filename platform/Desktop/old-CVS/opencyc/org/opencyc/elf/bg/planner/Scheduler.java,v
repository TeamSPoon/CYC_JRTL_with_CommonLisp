head	1.31;
access;
symbols
	PRE_1_0:1.31;
locks; strict;
comment	@# @;


1.31
date	2003.10.20.21.55.13;	author stephenreed;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.20.15.21.50;	author stephenreed;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.02.19.15.42;	author stephenreed;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.01.22.57.16;	author stephenreed;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.30.02.57.56;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.23.13.49.01;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.23.00.06.33;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.22.22.55.19;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.22.14.06.55;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.22.02.30.03;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.19.22.21.42;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.18.22.54.18;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.18.22.02.47;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.18.21.22.56;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.18.03.05.17;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.17.23.07.43;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.14.13.58.03;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.10.15.48.15;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.28.20.32.47;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.25.18.25.02;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.25.13.09.49;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.15.22.45.16;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.14.23.36.39;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.14.22.01.05;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.13.18.26.20;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.13.13.58.01;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.13.13.37.15;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.12.23.12.49;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.12.23.11.04;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.11.21.24.17;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.08.13.22.24;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.31
log
@/home/reed/opencyc/org/opencyc/elf
replaced command with commandName in job
@
text
@package org.opencyc.elf.bg.planner;

//// Internal Imports
import org.opencyc.elf.BehaviorEngineException;
import org.opencyc.elf.BufferedNodeComponent;
import org.opencyc.elf.Node;
import org.opencyc.elf.NodeComponent;
import org.opencyc.elf.Result;
import org.opencyc.elf.Status;
import org.opencyc.elf.a.DirectActuator;
import org.opencyc.elf.bg.command.Command;
import org.opencyc.elf.bg.predicate.PredicateExpression;
import org.opencyc.elf.message.ExecuteScheduleMsg;
import org.opencyc.elf.message.ExecutorStatusMsg;
import org.opencyc.elf.message.GenericMsg;
import org.opencyc.elf.message.ReplanMsg;
import org.opencyc.elf.message.ScheduleConsistencyEvaluationMsg;
import org.opencyc.elf.message.ScheduleConsistencyRequestMsg;
import org.opencyc.elf.message.SchedulerStatusMsg;
import org.opencyc.elf.message.ScheduleJobMsg;
import org.opencyc.elf.s.DirectSensor;
import org.opencyc.elf.wm.NodeFactory;
import org.opencyc.elf.wm.ScheduleLibrary;

//// External Imports
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import EDU.oswego.cs.dl.util.concurrent.BoundedBuffer;
import EDU.oswego.cs.dl.util.concurrent.Channel;
import EDU.oswego.cs.dl.util.concurrent.Puttable;
import EDU.oswego.cs.dl.util.concurrent.Takable;
import EDU.oswego.cs.dl.util.concurrent.ThreadedExecutor;

/** Scheduler performs temporal task decomposition for a given assigned agent
 * and its allocated resources.  The given job is used to retreive schedule sets from
 * the schedule library.  Each schedule set is an alternative set of sequential commands for
 * accomplishing the job.  The alternative schedule sets are ranked according to desirability,
 * then the scheduler finds the first set containing an eligible schedule, which is sent
 * to the executor for execution.  The remaining schedules in the schedule set are retained and
 * retried for eligibility as the executor completes its current schedule.  When no schedules
 * are eligible, then the job assigned to the schedule is deemed complete and a status message
 * to that effect is sent back to the job assigner.
 * 
 * @@version $Id: Scheduler.java,v 1.30 2003/10/20 15:21:50 stephenreed Exp $
 * @@author Stephen L. Reed  
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class Scheduler extends BufferedNodeComponent {
  
  //// Constructors

  /** Creates a new instance of Scheduler with the given
   * input and output channels.
   *
   * @@param node the containing ELF node
   * @@param schedulerChannel the takable channel from which messages are input from the
   * job assigner
   */
  public Scheduler (Node node,
                    Takable schedulerChannel) {
    setNode(node);
    this.schedulerChannel = schedulerChannel;         
  }

  //// Public Area

  /** Initializes this scheduler and begins consuming jobs to schedule.
   *
   * @@param jobAssignerChannel the puttable channel to which messages are output to the
   * job assigner
   */
  public void initialize(Puttable jobAssignerChannel) {
    getLogger().info("Initializing Scheduler");
    consumer = new Consumer(schedulerChannel,
                            jobAssignerChannel,
                            this);
    consumerExecutor = new ThreadedExecutor();
    try {
      consumerExecutor.execute(consumer);
    }
    catch (InterruptedException e) {
      e.printStackTrace();
      System.exit(1);
    }
  }
 
  /** Returns a string representation of this object.
   * 
   * @@return a string representation of this object
   */
  public String toString() {
    StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append("[Scheduler ");
    if (job != null)
      stringBuffer.append(job.toString());
    if (schedule != null) {
      stringBuffer.append(" schedule: ");
      stringBuffer.append(schedule.toString());
    }
    stringBuffer.append("]");
    return stringBuffer.toString();
  }

  /** Gets the executor for this sceduler
   *
   * @@return the executor for this sceduler
   */
  public org.opencyc.elf.bg.executor.Executor getExecutor () {
    return executor;
  }

  /** Sets the executor for this sceduler
   *
   * @@param executor the executor for this sceduler
   */
  public void setExecutor (org.opencyc.elf.bg.executor.Executor executor) {
    this.executor = executor;
  }

  /** Gets the puttable channel for this node component to which other node
   * components can send messages.
   *
   * @@return the puttable channel for this node component to which other node
   * components can send messages
   */
  public Puttable getChannel() {
    return (Puttable) schedulerChannel;
  }

  /** Gets the resources required by this scheduler.
   *
   * @@return the resources required by this scheduler
   */
  public List getResources() {
    List resources = new ArrayList();
    //TODO iterate through the task frame schedule infos
    return resources;
  }
  
  //// Protected Area
  
  /** Thread which processes the input message channel. */
  protected class Consumer implements Runnable {
    
    /** the takable channel from which messages are input */
    protected final Takable schedulerChannel;
    
    /** the puttable channel to which messages are output to the job assigner */
    protected final Puttable jobAssignerChannel;
    
    /** the reference to this node component as a message sender */
    protected NodeComponent thisScheduler;
          
    /** the node's controlled resources */
    protected List controlledResources;
    
    /** Creates a new instance of Consumer.
     *
     * @@param schedulerChannel the takable channel from which messages are input
     * @@param jobAssignerChannel the puttable channel to which messages are output to the
     * job assigner
     * @@param thisScheduler the reference to this node component as a message sender
     */
    protected Consumer (Takable schedulerChannel,
                        Puttable jobAssignerChannel,
                        NodeComponent thisScheduler) { 
      getLogger().info("Creating Scheduler.Consumer");
      this.schedulerChannel = schedulerChannel;
      this.jobAssignerChannel = jobAssignerChannel;
      this.thisScheduler = thisScheduler;
    }

    /** Reads messages from the input queue and processes them. */
    public void run () {
      try {
        while (true) { 
          dispatchMsg((GenericMsg) schedulerChannel.take()); 
        }
      }
      catch (InterruptedException ex) {}
    }
     
    /** Dispatches the given input channel message by type.
     *
     * @@param genericMsg the given input channel message
     */
    void dispatchMsg (GenericMsg genericMsg) {
      if (genericMsg instanceof ScheduleJobMsg)
        processScheduleJobMsg((ScheduleJobMsg) genericMsg);
      else if (genericMsg instanceof ReplanMsg)
        processReplanMsg((ReplanMsg) genericMsg);
      else if (genericMsg instanceof ExecutorStatusMsg)
        processExecutorStatusMsg((ExecutorStatusMsg) genericMsg); 
      else if (genericMsg instanceof ScheduleConsistencyRequestMsg)
        processScheduleConsistencyRequestMsg((ScheduleConsistencyRequestMsg) genericMsg); 
      else
        throw new RuntimeException("Unhandled message " + genericMsg);
    }
  
    /** Processes the schedule job message.
     *
     * @@param scheduleJobMsg the schedule job message
     */
    protected void processScheduleJobMsg (ScheduleJobMsg scheduleJobMsg) {
      getLogger().info("Scheduler proccessing " + scheduleJobMsg);
      job = scheduleJobMsg.getJob();
      String commandName = job.getCommandName();
      List scheduleSets = ScheduleLibrary.getInstance().getScheduleSets(commandName);
      getLogger().info("schedule sets for " + commandName + " are " + scheduleSets);
      List schedules = determineBestScheduleSet(scheduleSets);
      getLogger().info("schedules " + schedules);
      Schedule schedule = determineEligibleSchedule(schedules);
      if (executor == null)
        createExecutor(schedule);
      getLogger().info("Scheduler sending to executor " + schedule);
      controlledResources = new ArrayList();
      //TODO populate controlledResources
      ExecuteScheduleMsg executeScheduleMsg = new ExecuteScheduleMsg(thisScheduler, schedule, controlledResources);
      thisScheduler.sendMsgToRecipient(executor.getChannel(), executeScheduleMsg);
      
    }
                
    /** Returns the first schedule from the schedules whose predicate expression is null.  
     *
     * @@param schedules the given schedule
     * @@return the first schedule from the schedules whose predicate expression is null
     */
    protected Schedule determineEligibleSchedule(List schedules) {
      getLogger().info("Considering schedules " + schedules);
      Iterator scheduleIterator = schedules.iterator();
      while (scheduleIterator.hasNext()) {
        Schedule schedule = (Schedule) scheduleIterator.next();
        PredicateExpression predicateExpression = schedule.getPredicateExpression();
        if (predicateExpression == null || 
            predicateExpression.evaluate(thisScheduler.getNode().getWorldModel().getState()).equals(Boolean.TRUE))
          return schedule;
      }
      throw new BehaviorEngineException("No schedule to send to executor among " + schedules);
    }
    
    /** Determines the best of the alternative schedule sets.
     *
     * @@param scheduleSets the alternative schedule sets
     * @@return the the best of the alternative schedule sets 
     */
    protected List determineBestScheduleSet(List scheduleSets) {
      //TODO for now just return the first one
      return (List) scheduleSets.get(0);
    }
    
    /** Creates a new executor for the given schedule.
     *
     * @@param schedule the given schedule
     */
    protected void createExecutor(Schedule schedule) {
      Channel executorChannel = new BoundedBuffer(NodeFactory.CHANNEL_CAPACITY);
      executor = new org.opencyc.elf.bg.executor.Executor(getNode(), executorChannel);
      executor.initialize((Puttable) schedulerChannel);
      getLogger().info("Created new executor: " + executor + " for schedule: " + schedule);
    }
    
    /** Processes the replan message.
     *
     * @@param replanMsg the replan message
     */
    protected void processReplanMsg (ReplanMsg replanMsg) {
      //TODO
    }
        
    /** Processes the executor status message.
     *
     * @@param executorStatusMsg the executor status message
     */
    protected void processExecutorStatusMsg (ExecutorStatusMsg executorStatusMsg) {
      Status status = executorStatusMsg.getStatus();
      if (status.isTrue(Status.SCHEDULE_FINISHED)) {
        status = new Status();
        status.setTrue(Status.SCHEDULE_FINISHED);
        SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(thisScheduler, status);
        thisScheduler.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
      }
      else if (status.isTrue(Status.EXCEPTION)) 
        handleExecutorException(status);
      else
        throw new BehaviorEngineException("Executor status not handled " + status); 
    }
    
    /** Handles an executor exception by finding the first schedule whose predicate expression evaluates true
     * in the current exceptional state and sending it to the executor.  If no predicate expression 
     * evaluates true, then the exception status is sent to the parent job assigner for this scheduler.
     *
     * @@param status the exception status from the executor
     */
    protected void handleExecutorException(Status status) {
      Iterator scheduleIterator = conditionalSchedules.iterator();
      while (scheduleIterator.hasNext()) {
        Schedule schedule = (Schedule) scheduleIterator.next();
        PredicateExpression predicateExpression = schedule.getPredicateExpression();
        if (predicateExpression != null &&
            predicateExpression.evaluate(thisScheduler.getNode().getWorldModel().getState()).equals(Boolean.TRUE)) {
          ExecuteScheduleMsg executeScheduleMsg = new ExecuteScheduleMsg(thisScheduler, schedule, controlledResources);
          thisScheduler.sendMsgToRecipient(executor.getChannel(), executeScheduleMsg);
          return;
        }
      }
      SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(thisScheduler, status);
      thisScheduler.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
    }
  
    /** Processes the schedule consistency message.
     *
     * @@param scheduleConsistencyRequestMsg the schedule consistency request message
     */
    protected void processScheduleConsistencyRequestMsg (ScheduleConsistencyRequestMsg scheduleConsistencyRequestMsg) {
      List peerControlledResources = scheduleConsistencyRequestMsg.getControlledResources();
      String peerCommandName = scheduleConsistencyRequestMsg.getCommandName();
      Schedule peerSchedule = scheduleConsistencyRequestMsg.getSchedule();
      //TODO
    }
    
    /** Sends the scheduler status message to the job assigner. */
    protected void sendSchedulerStatusMsg () {
      //TODO
      Status status = new Status();
      
      SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(thisScheduler, status);
      thisScheduler.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
    }
    
    /** Sends a schedule consistency request to a peer scheduler.
     *
     * @@param peerScheduler the peer scheduler
     */
    protected void sendScheduleConsistencyRequestMsg (Scheduler peerScheduler) {
      ScheduleConsistencyRequestMsg scheduleConsistencyRequestMsg = 
        new ScheduleConsistencyRequestMsg(thisScheduler,
                                          controlledResources,
                                          job.getCommandName(),
                                          schedule);
      scheduleConsistencyRequestMsg.setReplyToChannel((Puttable) schedulerChannel);
      thisScheduler.sendMsgToRecipient(peerScheduler.getChannel(), 
                                scheduleConsistencyRequestMsg);
    }    

    /** Sends a schedule consistency evaluation message to a peer scheduler in
     * response to its schedule consistency request.
     *
     * @@param scheduleConsistencyRequestMsg the given schedule consistency request message
     */
    protected void sendScheduleConsistencyEvaluationMsg (ScheduleConsistencyRequestMsg scheduleConsistencyRequestMsg) {
      ScheduleConsistencyEvaluationMsg scheduleConsistencyEvaluationMsg = 
        new ScheduleConsistencyEvaluationMsg(thisScheduler, schedule, controlledResources);
      scheduleConsistencyEvaluationMsg.setInReplyToMsg(scheduleConsistencyRequestMsg);
      thisScheduler.sendMsgToRecipient(scheduleConsistencyRequestMsg.getReplyToChannel(),
                                scheduleConsistencyEvaluationMsg);
    }    
  }
  
  //// Private Area

  //// Internal Rep

  /** the takable channel from which messages are input */
  protected Takable schedulerChannel;

  /** the thread which processes the input channel of messages */
  protected Consumer consumer;

  /** the consumer thread executor */
  protected EDU.oswego.cs.dl.util.concurrent.Executor consumerExecutor;
  
  /** the executor for this scheduler */
  protected org.opencyc.elf.bg.executor.Executor executor;
  
  /** the assigned job to schedule */
  protected Job job;
  
  /** the set of conditional schedules that accomplish the assigned job */
  protected List conditionalSchedules;
  
  /** the current schedule sent to the executor for execution */
  protected Schedule schedule;
    
}@


1.30
log
@moved commands to org.opencyc.elf.bg.command package
@
text
@d45 1
a45 1
 * @@version $Id: Scheduler.java,v 1.29 2003/10/02 19:15:42 stephenreed Exp $
d224 3
a226 3
      Command command = job.getCommand();
      List scheduleSets = ScheduleLibrary.getInstance().getScheduleSets(command.getName());
      getLogger().info("schedule sets for " + command.getName() + " are " + scheduleSets);
d333 1
a333 1
      Command peerCommand = scheduleConsistencyRequestMsg.getCommand();
d355 1
a355 1
                                          job.getCommand(),
@


1.29
log
@evaluate predicate expressions to choose the schedule set
@
text
@a9 1

d11 1
a11 1

a12 3

import org.opencyc.elf.bg.taskframe.Command;

a20 1

a21 1

a28 1

d45 1
a45 1
 * @@version $Id: Scheduler.java,v 1.28 2003/10/01 22:57:16 stephenreed Exp $
@


1.28
log
@added logging diagnostics
@
text
@d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.27 2003/09/30 02:57:56 stephenreed Exp $
d257 3
a259 1
        if (schedule.getPredicateExpression() == null) 
@


1.27
log
@fixed compilation errors
@
text
@d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.26 2003/09/23 13:49:01 stephenreed Exp $
d233 1
d235 1
@


1.26
log
@renamed status values
@
text
@d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.25 2003/09/23 00:06:33 stephenreed Exp $
d320 1
a320 1
            predicateExpression.evaluate(thisScheduler.getNode().getWorldModel().getState())) {
@


1.25
log
@/home/reed/opencyc/org/opencyc/elf
adding code to executor
@
text
@d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.24 2003/09/22 22:55:19 stephenreed Exp $
d277 1
a277 1
      executor = new org.opencyc.elf.bg.executor.Executor(getNode(), executorChannel, (Scheduler) thisScheduler);
d302 1
a302 1
      else if (status.isTrue(Status.EXECUTION_EXCEPTION)) 
@


1.24
log
@completed schedule algorithm
@
text
@d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.23 2003/09/22 14:06:55 stephenreed Exp $
d176 1
a176 1
    protected NodeComponent sender;
d186 1
a186 1
     * @@param sender the reference to this node component as a message sender
d190 1
a190 1
                        NodeComponent sender) { 
d194 1
a194 1
      this.sender = sender;
d240 2
a241 2
      ExecuteScheduleMsg executeScheduleMsg = new ExecuteScheduleMsg(sender, schedule, controlledResources);
      sender.sendMsgToRecipient(executor.getChannel(), executeScheduleMsg);
d277 1
a277 1
      executor = new org.opencyc.elf.bg.executor.Executor(getNode(), executorChannel);
d299 2
a300 2
        SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(sender, status);
        sender.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
d320 3
a322 3
            predicateExpression.evaluate(sender.getNode().getWorldModel().getState())) {
          ExecuteScheduleMsg executeScheduleMsg = new ExecuteScheduleMsg(sender, schedule, controlledResources);
          sender.sendMsgToRecipient(executor.getChannel(), executeScheduleMsg);
d326 2
a327 2
      SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(sender, status);
      sender.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
d346 2
a347 2
      SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg(sender, status);
      sender.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
d356 1
a356 1
        new ScheduleConsistencyRequestMsg(sender,
d361 1
a361 1
      sender.sendMsgToRecipient(peerScheduler.getChannel(), 
d372 1
a372 1
        new ScheduleConsistencyEvaluationMsg(sender, schedule, controlledResources);
d374 1
a374 1
      sender.sendMsgToRecipient(scheduleConsistencyRequestMsg.getReplyToChannel(),
@


1.23
log
@fixed the arguments when constructing an executor
@
text
@d4 1
d13 2
d17 1
d29 1
d33 1
d43 8
a50 1
 * and its allocated resources.
d52 1
a52 1
 * @@version $Id: Scheduler.java,v 1.22 2003/09/22 02:30:03 stephenreed Exp $
d231 4
a234 10
      
      // get the schedule sets corresponding to the job
      
      // evaluate the schedule sets and choose the best one
      
      
      
      
      
      
d237 5
a241 2
      
      // send the schedule to the executor
d245 27
a271 1
    /** Creates a new scheduler for the given schedule.
a294 1
      //TODO
d296 10
d308 22
@


1.22
log
@fixed compilation errors resulting from messages construct signature change
@
text
@d4 1
a26 1

d39 1
a39 1
 * @@version $Id: Scheduler.java,v 1.21 2003/09/19 22:21:42 stephenreed Exp $
d59 1
a59 1
public class Scheduler extends NodeComponent {
d67 1
a67 1
   * @@param schedulerChannel the takable channel from which messages are input
d78 1
a78 1
  /** Initializes the schedule and begins consuming schedules.
d105 4
a108 1
    if (schedule != null)
d110 1
d241 2
a242 5
      executor = new org.opencyc.elf.bg.executor.Executor();
      //executor.initialize((Puttable) schedulerChannel);
      
      //TODO make exectutor a buffered node component
      
@


1.21
log
@/home/reed/opencyc/org/opencyc/elf
refactored job and schedule
@
text
@d11 1
a11 1
import org.opencyc.elf.bg.taskframe.TaskCommand;
d39 1
a39 1
 * @@version $Id: Scheduler.java,v 1.20 2003/09/18 22:54:18 stephenreed Exp $
d73 1
a73 1
    this.schedulerChannel = schedulerChannel;           
d158 2
a159 2
    /** the parent node component */
    protected NodeComponent nodeComponent;
d169 1
a169 1
     * @@param nodeComponent the parent node component
d173 1
a173 1
                        NodeComponent nodeComponent) { 
d177 1
a177 1
      this.nodeComponent = nodeComponent;
d268 1
a268 1
      TaskCommand peerTaskCommand = scheduleConsistencyRequestMsg.getTaskCommand();
d278 2
a279 4
      SchedulerStatusMsg schedulerStatusMsg = new SchedulerStatusMsg();
      schedulerStatusMsg.setSender(nodeComponent);
      schedulerStatusMsg.setStatus(status);
      nodeComponent.sendMsgToRecipient(jobAssignerChannel, schedulerStatusMsg);
d288 4
a291 2
        new ScheduleConsistencyRequestMsg();
      scheduleConsistencyRequestMsg.setSender(nodeComponent);
d293 2
a294 5
      scheduleConsistencyRequestMsg.setControlledResources(controlledResources);
      scheduleConsistencyRequestMsg.setTaskCommand(taskCommand);
      scheduleConsistencyRequestMsg.setSchedule(schedule);
      nodeComponent.sendMsgToRecipient(peerScheduler.getChannel(), 
                                       scheduleConsistencyRequestMsg);
d304 1
a304 2
        new ScheduleConsistencyEvaluationMsg();
      scheduleConsistencyEvaluationMsg.setSender(nodeComponent);
d306 2
a307 5
      scheduleConsistencyEvaluationMsg.setControlledResources(controlledResources);
      scheduleConsistencyEvaluationMsg.setTaskCommand(taskCommand);
      scheduleConsistencyEvaluationMsg.setSchedule(schedule);
      nodeComponent.sendMsgToRecipient(scheduleConsistencyRequestMsg.getReplyToChannel(),
                                       scheduleConsistencyEvaluationMsg);
@


1.20
log
@began adding code to process the assigned job
@
text
@a10 1
import org.opencyc.elf.bg.planner.Schedule;
d39 1
a39 1
 * @@version $Id: Scheduler.java,v 1.19 2003/09/18 22:02:47 stephenreed Exp $
d213 11
a223 2
      schedule = scheduleJobMsg.getSchedule();
      taskCommand = scheduleJobMsg.getTaskCommand();
d227 1
a227 3
      
      
      // if the executor exists then pass the schedule actions one a time
d334 7
a340 4
  /** the node's commanded task */
  protected TaskCommand taskCommand;

  /** the schedule which is planned to accomplish the commanded task */
@


1.19
log
@/home/reed/opencyc/org/opencyc/elf
renamed scheduler.actuatorName to scheduler.directActuatorName and renamed scheduler.sensorName to scheduler.directSensorName
@
text
@a5 1

d9 2
d22 4
d31 2
d40 1
a40 1
 * @@version $Id: Scheduler.java,v 1.18 2003/09/18 21:22:56 stephenreed Exp $
d216 6
d225 14
@


1.18
log
@/home/reed/opencyc/org/opencyc/elf
removed equals(...)  method if present and reformatted multiline comments to one less line
@
text
@d33 1
a33 1
 * @@version $Id: Scheduler.java,v 1.17 2003/09/18 03:05:17 stephenreed Exp $
d78 1
d97 6
a102 2
    //TODO
    return "";
a157 6
    /** the node's commanded task */
    protected TaskCommand taskCommand;
        
    /** the schedule which is planned to accomplish the commanded task */
    protected Schedule schedule;
    
d168 1
a183 2
    //TODO think about conversations and thread safety
    
d197 2
d206 2
d209 1
a209 1
      //TODO
d299 8
a306 1
  org.opencyc.elf.bg.executor.Executor executor;
@


1.17
log
@added more scheduling code in the job assigner
@
text
@d30 1
a30 2
/**
 * Scheduler performs temporal task decomposition for a given assigned agent
d33 1
a33 1
 * @@version $Id: Scheduler.java,v 1.16 2003/09/17 23:07:43 stephenreed Exp $
d90 1
a90 17
  
  
  /** Returns true if the given object equals this object.
   * 
   * @@param obj the given object
   * 
   * @@return true if the given object equals this object
   */
  public boolean equals(Object obj) {
    if (!(obj instanceof Scheduler)) {
      return false;
    }

    //TODO
    return true;
  }

@


1.16
log
@set the node in the constructor
@
text
@d34 1
a34 1
 * @@version $Id: Scheduler.java,v 1.15 2003/09/14 13:58:03 stephenreed Exp $
a62 1
   * @@param jobAssignerChannel the puttable channel to which messages are output to the
d66 1
a66 2
                    Takable schedulerChannel,
                    Puttable jobAssignerChannel) {
d69 10
d91 2
a92 3

  //// Public Area

@


1.15
log
@Changed ArrayList to List, consistently formatted one line comments. ----------------------------------------------------------------------
@
text
@d4 1
a30 1
 * <P>
a32 1
 * </p>
d34 1
a34 1
 * @@version $Id: Scheduler.java,v 1.14 2003/09/10 15:48:15 stephenreed Exp $
d55 1
d58 1
a58 6
  /** Creates a new instance of Scheduler */
  public Scheduler() {
  }

  /** 
   * Creates a new instance of Scheduler with the given
d61 1
d66 2
a67 1
  public Scheduler (Takable schedulerChannel,
d69 1
d86 1
a86 2
  /**
   * Returns true if the given object equals this object.
d101 1
a101 2
  /**
   * Returns a string representation of this object.
d110 1
a110 2
  /**
   * Gets the executor for this sceduler
d118 1
a118 2
  /**
   * Sets the executor for this sceduler
d126 1
a126 2
  /**
   * Gets the puttable channel for this node component to which other node
d136 1
a136 2
  /**
   * Gets the resources required by this scheduler.
d148 1
a148 3
  /**
   * Thread which processes the input message channel.
   */
d169 1
a169 2
    /**
     * Creates a new instance of Consumer.
d184 1
a184 3
    /**
     * Reads messages from the input queue and processes them.
     */
d196 1
a196 2
    /**
     * Dispatches the given input channel message by type.
d211 1
a211 2
    /**
     * Processes the schedule job message.
d220 1
a220 2
    /**
     * Processes the replan message.
d228 1
a228 2
    /**
     * Processes the executor status message.
d237 1
a237 2
    /**
     * Processes the schedule consistency message.
d259 1
a259 2
    /**
     * Sends a schedule consistency request to a peer scheduler.
d275 1
a275 2
    /**
     * Sends a schedule consistency evaluation message to a peer scheduler in
@


1.14
log
@add getResources() method shell
@
text
@d23 1
d35 1
a35 1
 * @@version $Id: Scheduler.java,v 1.13 2003/08/28 20:32:47 stephenreed Exp $
d58 1
a58 3
  /**
   * Creates a new instance of Scheduler
   */
d148 2
a149 2
  public ArrayList getResources() {
    ArrayList resources = new ArrayList();
d161 1
a161 3
    /**
     * the takable channel from which messages are input
     */
d164 1
a164 4
    /**
     * the puttable channel to which messages are output to the
     * job assigner
     */
d167 1
a167 3
    /**
     * the parent node component
     */
d170 2
a171 4
    /**
     * the node's controlled resources
     */
    protected ArrayList controlledResources;
d173 1
a173 3
    /**
     * the node's commanded task
     */
d176 1
a176 3
    /**
     * the schedule which is planned to accomplish the commanded task
     */
d260 1
a260 1
      ArrayList peerControlledResources = scheduleConsistencyRequestMsg.getControlledResources();
d266 1
a266 3
    /**
     * Sends the scheduler status message to the job assigner.
     */
d317 1
a317 3
  /**
   * the takable channel from which messages are input
   */
d320 1
a320 3
  /**
   * the thread which processes the input channel of messages
   */
d323 1
a323 3
  /**
   * the consumer thread executor
   */
d326 1
a326 3
  /**
   * the executor for this scheduler
   */
@


1.13
log
@fixed cvs $Id:
@
text
@d34 1
a34 1
 * @@version $Id: BehaviorGeneration.java,v 1.3 2002/11/19 02:42:53 stephenreed Exp $
d144 11
@


1.12
log
@Removed messages that will become synchronous calls.
@
text
@d34 1
a34 2
 * @@version $Id: BehaviorGeneration.java,v 1.3 2002/11/19 02:42:53 stephenreed
 *          Exp $
@


1.11
log
@Syncronizing

----------------------------------------------------------------------
@
text
@a13 2
import org.opencyc.elf.message.PredictedInputMsg;
import org.opencyc.elf.message.PredictionRequestMsg;
a16 1
import org.opencyc.elf.message.ScheduleEvaluationResultMsg;
a18 2
import org.opencyc.elf.message.SimulateScheduleMsg;
import org.opencyc.elf.message.SimulationFailureNotificationMsg;
a70 3
   * @@param planSimulatorChannel the puttable channel to which messages are output to the
   * plan simulator
   * @@param predictorChannel the puttable channel to which messages are output to the predictor
d73 1
a73 3
                    Puttable jobAssignerChannel,
                    Puttable planSimulatorChannel,
                    Puttable predictorChannel) {
a76 2
                            planSimulatorChannel,
                            predictorChannel,
a163 11
     * the puttable channel to which messages are output to the
     * plan simulator
     */
    protected final Puttable planSimulatorChannel;
    
    /**
     * the puttable channel to which messages are output to the predictor
     */
    protected final Puttable predictorChannel;
    
    /**
a188 3
     * @@param planSimulatorChannel the puttable channel to which messages are output to the
     * plan simulator
     * @@param predictorChannel the puttable channel to which messages are output to the predictor
a192 2
                        Puttable planSimulatorChannel,
                        Puttable predictorChannel,
a195 2
      this.planSimulatorChannel = planSimulatorChannel;
      this.predictorChannel = predictorChannel;
a220 4
      else if (genericMsg instanceof PredictedInputMsg)
        processPredictedInputMsg((PredictedInputMsg) genericMsg);
      else if (genericMsg instanceof ScheduleEvaluationResultMsg)
        processScheduleEvaluationResultMsg((ScheduleEvaluationResultMsg) genericMsg);
d238 1
a238 22
        
    /**
     * Processes the predicted input message.
     *
     * @@param predictedInputMsg the predicted input message
     */
    protected void processPredictedInputMsg (PredictedInputMsg predictedInputMsg) {
      Object obj = predictedInputMsg.getObj();
      Object data = predictedInputMsg.getData();
      //TODO
    }
        
    /**
     * Processes the schedule evaluation result message.
     *
     * @@param scheduleEvaluationResult the schedule evaluation result message
     */
    protected void processScheduleEvaluationResultMsg (ScheduleEvaluationResultMsg scheduleEvaluationResultMsg) {
      //TODO
      Result result = scheduleEvaluationResultMsg.getResult();
    }
        
a282 27
    /**
     * Requests a predicted value for the given object.
     *
     * @@param obj the given object whose predicted value is requested from
     * the predictor
     */
    protected void sendPredictionRequestMsg (Object obj) {
      PredictionRequestMsg predictionRequestMsg = new PredictionRequestMsg();
      predictionRequestMsg.setSender(nodeComponent);
      predictionRequestMsg.setReplyToChannel((Puttable) schedulerChannel);
      predictionRequestMsg.setObj(obj);
      nodeComponent.sendMsgToRecipient(predictorChannel, predictionRequestMsg);
    }    

    /**
     * Sends a schedule simulation request message to the plan simulator.
     */
    protected void sendSimulateScheduleMsg () {
      SimulateScheduleMsg simulateScheduleMsg = new SimulateScheduleMsg();
      simulateScheduleMsg.setSender(nodeComponent);
      simulateScheduleMsg.setReplyToChannel((Puttable) schedulerChannel);
      simulateScheduleMsg.setControlledResources(controlledResources);
      simulateScheduleMsg.setTaskCommand(taskCommand);
      simulateScheduleMsg.setSchedule(schedule);
      nodeComponent.sendMsgToRecipient(planSimulatorChannel, simulateScheduleMsg);
    }    

@


1.10
log
@/home/reed/opencyc/org/opencyc/elf
Added methods to KnowledgeBase
@
text
@d6 1
d9 1
d12 13
d27 6
d69 31
a127 2
  //// Protected Area
  
d129 3
a131 1
   * Receives schedule job message from the job assigner
d133 2
a134 4
  protected void receiveScheduleJob () {
    //TODO
    // receive via channel from the job assigner
    // TaskCommand taskCommand
d136 1
a136 1
  
d138 1
a138 1
   * Receives the plan selector status message from the plan selector
d140 1
a140 3
   * @@param taskCommand the task command
   * @@param schedule the schedule
   * @@param the plan selector status
d142 2
a143 6
  protected void receivePlanSelectorStatus () {
    //TODO
    // receive via channel from the plan selector
    // TaskCommand taskCommand
    // Schedule schedule
    // Status status
d145 1
a145 1
  
d147 5
a151 2
   * Receives the executor status message from the executor associated with
   * this scheduler.
d153 2
a154 6
  protected void receiveExecutorStatus () {
    //TODO
    // receive via channel from he executor associated with this scheduler
    // TaskCommand taskCommand
    // Schedule schedule
    // Status status
d156 2
d160 1
a160 2
   * Receives the value judgement status from behavior generation which forwarded it
   * from value judgement.
d162 66
a227 7
  protected void receiveValueJudgementStatus () {
    //TODO
    // receive via channel from ?
    // TaskCommand taskCommand
    // Schedule schedule
    // Status status
  }
d229 170
a398 9
  /**
   * Receives simulation failure notification message forwarded from behavior generation on
   * behalf of world model.
   */
  protected void receiveSimulationFailureNotification () {
    // TODO
    // receive via channel from behavior generation
    // TaskCommand taskCommand
    // Schedule schedule
d401 4
d406 1
a406 1
   * Receives the check schedule consistent message from ?.
d408 1
a408 7
  protected void receiveCheckScheduleConsistent () {
    // TODO
    // receive via channel from ?
    // ArrayList controlledResources
    // TaskCommand taskCommand
    // Schedule schedule
  }
d411 1
a411 1
   * Receives the schedule consistency evaluation message from ?.
d413 2
a414 8
  protected void receiveScheduleConsistencyEvaluation () {
    // TODO
    // receive via channel from 
    // ArrayList controlledResources
    // TaskCommand taskCommand
    // Schedule schedule
  }
  
d416 1
a416 1
   * Sends the request simulate schedule message to behavior generation
d418 1
a418 9
  protected void requestSimulateSchedule () {
    // TODO
    // send via channel to ?
    // ArrayList controlledResources
    // TaskCommand taskCommand
    // Schedule schedule
    // send forwardSimulateSchedule(controlledResources, taskCommand, schedule)
    // to behaviorGeneration
  }
d421 1
a421 1
   * Sends the check if schedule consistent message to ?
d423 1
a423 35
  protected void checkIfScheduleConsistent () {
    // TODO
    // send via channel?
    // ArrayList controlledResources
    // TaskCommand taskCommand
    // Schedule schedule
  }
  
  /**
   * Sends the schedule consistency evaluation message to ?
   */
  protected void sendScheduleConsistencyEvaluation () {
    // TODO
    // send via channel to ?
    // ArrayList controlledResources
    // TaskCommand taskCommand
    // Schedule schedule
  }
  
  /**
   * Sends the scheduler status message to job assigner.
   */
  protected void schedulerStatus () {
    // TODO
    // send via channel to ?
    // ArrayList controlledResources
    // Status status
    // send schedulerStatus(controlledResources, status) to jobAssigner
  }
  
  public void run() {
  }
  
  //// Private Area
  //// Internal Rep
@


1.9
log
@Added TODO comments
@
text
@d205 3
@


1.8
log
@Added TODO comments
@
text
@d88 1
a88 1
   * Receives the plan selector status message from ?
d96 1
a96 1
    // receive via channel from ?
@


1.7
log
@/home/reed/opencyc/org/opencyc/elf
Refactored Result.java & Status.java into the org.opencyc.elf package.
@
text
@d79 1
a79 3
   * Receives the task command for scheduling.
   *
   * @@param taskCommand the task command
d81 1
a81 1
  protected void receiveScheduleJob (TaskCommand taskCommand) {
d83 2
a84 1
    // receive via channel
d88 1
a88 2
   * Receives the status from the plan selector given the task command and
   * schedule
d94 1
a94 3
  protected void receivePlanSelectorStatus (TaskCommand taskCommand,
                                         Schedule schedule,
                                         Status status) {
d96 4
a99 1
    // receive via channel
d103 2
a104 6
   * Receives the status from the executor given the task command and
   * schedule
   *
   * @@param taskCommand the task command
   * @@param schedule the schedule
   * @@param the executor status
d106 1
a106 3
  protected void receiveExecutorStatus (TaskCommand taskCommand,
                                     Schedule schedule,
                                     Status status) {
d108 4
a111 1
    // receive via channel
d115 2
a116 6
   * Receives the status from value judgement given the task command and
   * schedule
   *
   * @@param taskCommand the task command
   * @@param schedule the schedule
   * @@param the value judgement status
d118 1
a118 3
  protected void receiveValueJudgementStatus (TaskCommand taskCommand,
                                           Schedule schedule,
                                           Status status) {
d120 4
a123 1
    // receive via channel
d127 2
a128 1
   * Receives simulation failure notification from the simulator/predictor.
d132 1
a132 1
    // receive via channel
d138 1
a138 1
   * Receives the check schedule consistent information from ?.
d142 1
a142 1
    // receive via channel
d149 1
a149 1
   * Receives the schedule consistency evaluation from ?.
d153 1
a153 1
    // receive via channel
d160 1
a160 1
   * Requests schedule simulation.
d164 1
a164 1
    // send via channel?
d168 2
d173 1
a173 1
   * Checks if the schedule is consistent.
d184 1
a184 1
   * Sends the schedule consistency evaluation to ?
d195 1
a195 1
   * Provides the scheduler status to ?.
d202 1
@


1.6
log
@Extended NodeComponent.
@
text
@d6 1
a6 1
import org.opencyc.elf.bg.Status;
@


1.5
log
@Added/fixed method signatures.
@
text
@d4 2
d39 1
a39 1
public class Scheduler {
@


1.4
log
@N/A
@
text
@d49 28
d81 1
a81 1
  public void receiveScheduleJob (TaskCommand taskCommand) {
d94 1
a94 1
  public void receivePlanSelectorStatus (TaskCommand taskCommand,
d109 1
a109 1
  public void receiveExecutorStatus (TaskCommand taskCommand,
d124 1
a124 1
  public void receiveValueJudgementStatus (TaskCommand taskCommand,
d131 9
d141 21
d163 10
a172 1
  // TODO
d174 10
d186 1
a186 5
   * Returns true if the given object equals this object.
   * 
   * @@param obj the given object
   * 
   * @@return true if the given object equals this object
d188 6
a193 7
  public boolean equals(Object obj) {
    if (!(obj instanceof Scheduler)) {
      return false;
    }

    //TODO
    return true;
d195 1
a195 1

d197 1
a197 3
   * Returns a string representation of this object.
   * 
   * @@return a string representation of this object
d199 5
a203 3
  public String toString() {
    //TODO
    return "";
d205 1
a205 2

  //// Protected Area
@


1.3
log
@Added method signatures
@
text
@d104 1
@


1.2
log
@Reinserted the LGPL license clause that was wrongly removed by the Jalopy
indentation tool.
@
text
@d4 4
d48 59
@


1.1
log
@synchronized with work in progress.
@
text
@d14 18
a31 1
 * @@author reed <p><p><p><p><p>
@

