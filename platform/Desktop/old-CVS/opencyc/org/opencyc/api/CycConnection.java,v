head	1.49;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.48.0.2
	OPENCYC_1_0_1:1.48
	PRE_1_0:1.46;
locks; strict;
comment	@# @;


1.49
date	2006.10.21.16.49.16;	author dmiles;	state Exp;
branches;
next	1.48;

1.48
date	2006.10.18.14.21.33;	author dmiles;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.18.13.36.02;	author dmiles;	state Exp;
branches;
next	1.46;

1.46
date	2002.12.24.16.58.50;	author stephenreed;	state Exp;
branches;
next	1.45;

1.45
date	2002.10.04.21.12.46;	author stephenreed;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.15.23.58.49;	author stephenreed;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.13.22.55.46;	author stephenreed;	state Exp;
branches;
next	1.42;

1.42
date	2002.09.10.21.14.03;	author stephenreed;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.09.23.11.45;	author stephenreed;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.08.02.43.02;	author stephenreed;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.03.02.36.23;	author stephenreed;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.30.22.52.13;	author stephenreed;	state Exp;
branches;
next	1.37;

1.37
date	2002.08.30.02.55.18;	author stephenreed;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.23.20.17.19;	author stephenreed;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.17.21.27.05;	author stephenreed;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.30.20.00.22;	author stephenreed;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.27.19.51.19;	author stephenreed;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.16.21.17.17;	author stephenreed;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.08.15.02.30;	author stephenreed;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.27.23.27.27;	author stephenreed;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.26.05.14.01;	author stephenreed;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.25.18.31.13;	author stephenreed;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.21.18.05.50;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.17.00.32.47;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.13.02.16.51;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.09.22.09.33;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.09.02.50.59;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.24.17.00.29;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2001.10.17.23.44.18;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.12.22.45.36;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.09.16.09.01;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.04.22.24.01;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.28.22.36.27;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.18.17.54.39;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.17.18.46.55;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.14.22.14.55;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.07.23.43.03;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.03.22.30.50;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.30.00.06.54;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.28.10.05.25;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.27.22.30.44;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.24.22.39.27;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.23.22.14.25;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.23.09.33.13;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.23.00.47.46;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.21.23.28.16;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.15.23.49.55;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.15.14.50.45;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.14.23.49.56;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.api;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;

import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycObject;
import org.opencyc.cycobject.CycSymbol;
import org.opencyc.cycobject.DefaultCycObject;
import org.opencyc.util.Log;
import org.opencyc.util.StringUtils;
import org.opencyc.util.TimeOutException;
import org.opencyc.util.Timer;
import org.opencyc.util.UUID;

/**
 * Provides a binary connection and an ascii connection to the OpenCyc server.
 * The ascii connection is legacy and its use is deprecated.
 * 
 * <p>
 * Collaborates with the <tt>CycAccess</tt> class which wraps the api
 * functions. CycAccess may be specified as null in the CycConnection
 * constructors when the binary api is used. Concurrent api requests are
 * supported for binary (cfasl) mode. This is implemented by two socket
 * connections, the first being for asynchronous api requests sent to Cyc, and
 * the second for the asychronous api responses received from Cyc.
 * </p>
 * 
 * @@version $Id: CycConnection.java,v 1.63 2005/02/16 21:33:28 reed Exp $
 * @@author Stephen L. Reed
 *         <p>
 *         <p>
 *         <p>
 *         <p>
 *         <p>
 */
public class CycConnection implements CycConnectionInterface {
	/** Default host name for the OpenCyc server. */
	public static String DEFAULT_HOSTNAME = "localhost";

	// public static String DEFAULT_HOSTNAME = "207.207.8.185";

	/** Default base tcp port for the OpenCyc server. */
	public static final int DEFAULT_BASE_PORT = 3600;

	/** HTTP port offset for the OpenCyc server. */
	public static final int HTTP_PORT_OFFSET = 0;

	/** ASCII port offset for the OpenCyc server. */
	public static final int ASCII_PORT_OFFSET = 1;

	/** CFASL (binary) port offset for the OpenCyc server. */
	public static final int CFASL_PORT_OFFSET = 14;

	/**
	 * the listening port of this connection in which a value of zero indicates
	 * that the local operating system chooses a free port
	 */
	public static int clientPort = 0;

	/**
	 * the client host name of the connection in which a value of null indicates
	 * that the local operating system provides the host name
	 */
	public static String clientHostName = null;

	/** No api trace. */
	public static final int API_TRACE_NONE = 0;

	/** Message-level api trace. */
	public static final int API_TRACE_MESSAGES = 1;

	/** Detailed api trace. */
	public static final int API_TRACE_DETAILED = 2;

	/**
	 * Parameter that, when true, causes a trace of the messages to and from the
	 * server.
	 */
	protected int trace = API_TRACE_NONE;

	// protected int trace = API_TRACE_MESSAGES;
	// protected int trace = API_TRACE_DETAILED;

	/** Ascii mode connnection to the OpenCyc server. */
	public static final int ASCII_MODE = 1;

	/** CFASL (binary) mode connnection to the OpenCyc server. */
	public static final int BINARY_MODE = 2;

	/** Default communication mode connnection to the OpenCyc server. */
	public static final int DEFAULT_COMMUNICATION_MODE = BINARY_MODE;

	/**
	 * When true, indicates that two Cyc host socket connections will be
	 * established at the cfasl listening port, one for outbound (from here) api
	 * requests and the other for inbound api responses. When false, indicates
	 * that the inbound api responses are received by a listening java
	 * client-side socket. Passive connections are client-firewall friendly.
	 */
	public boolean passiveConnection = true;

	/** Indicator for whether to use the binary or acsii connection with OpenCyc. */
	protected int communicationMode = 0;

	/** Serial messaging mode to the OpenCyc server. */
	public static final int SERIAL_MESSAGING_MODE = 1;

	/** Concurrent messaging mode to the OpenCyc server. */
	public static final int CONCURRENT_MESSAGING_MODE = 2;

	/** Default messaging mode to the OpenCyc server. */
	public static final int DEFAULT_MESSAGING_MODE = CONCURRENT_MESSAGING_MODE;

	/** Messaging mode to the OpenCyc server. */
	public int messagingMode = DEFAULT_MESSAGING_MODE;

	/** The ascii interface input stream. */
	protected BufferedReader in;

	/** The ascii interface output stream. */
	protected BufferedWriter out;

	/** The binary interface input stream. */
	protected CfaslInputStream cfaslInputStream;

	/** The binary interface output stream. */
	protected CfaslOutputStream cfaslOutputStream;

	/** The name of the computer hosting the OpenCyc server. */
	protected String hostName;

	/** The tcp port from which the asciiPort and cfaslPorts are derived. */
	protected int basePort;

	/** The tcp port assigned to the ascii connection to the OpenCyc server. */
	protected int asciiPort;

	/** The tcp port assigned to the binary connection to the OpenCyc server. */
	protected int cfaslPort;

	/** The tcp socket assigned to the ascii connection to the OpenCyc server. */
	protected Socket asciiSocket;

	/** The tcp socket assigned to the binary connection to the OpenCyc server. */
	protected Socket cfaslSocket;

	/**
	 * The timer which optionally monitors the duration of requests to the
	 * OpenCyc server.
	 */
	protected static final Timer notimeout = new Timer();

	/**
	 * Indicates if the response from the OpenCyc server is a symbolic
	 * expression (enclosed in parentheses).
	 */
	protected boolean isSymbolicExpression = false;

	/**
	 * A reference to the parent CycAccess object for dereferencing constants in
	 * ascii symbolic expressions.
	 */
	protected CycAccess cycAccess;

	/**
	 * An indicator for ascii communications mode that strings should retain
	 * their quote delimiters.
	 */
	protected boolean quotedStrings;

	/** outbound request serial id */
	static protected int apiRequestId = 0;

	/** The default priority of a task-processor request. */
	public static final int DEFAULT_PRIORITY = 3;

	/** name of my api client */
	protected String myClientName = "api client";

	/**
	 * Implements an association: apiRequestId --> waiting thread info, where
	 * waiting thread info is an array of two objects: 1. the latch waiting for
	 * the response from the Cyc server (number 1 in no longer valid
	 * 
	 * @@todo fix this description) 2. the api-request in CycList form Used when
	 *       submitting concurrent requests to the task-processor.
	 */
	protected Hashtable waitingReplyThreads = new Hashtable();

	/**
	 * handles responses from task-processor requests in binary communication
	 * mode.
	 */
	protected TaskProcessorBinaryResponseHandler taskProcessorBinaryResponseHandler;

	/**
	 * Indicates to the taskProcessor response handlers that the server
	 * connection is closed.
	 */
	protected boolean taskProcessingEnded = false;

	/** Indicates that the task processing thread is dead */
	protected boolean taskProcessingThreadDead = false;

	/**
	 * Universally Unique ID that identifies this CycConnection to the Cyc
	 * server. It is used when establishing the (second) asychronous socket
	 * connection.
	 */
	protected UUID uuid;

	/**
	 * Constructs a new CycConnection using the given socket obtained from the
	 * parent AgentManager listener.
	 * 
	 * @@param cfaslSocket
	 *            tcp socket which forms the binary connection to the OpenCyc
	 *            server
	 * 
	 * @@throws IOException
	 *             when communication error occurs
	 */
	public CycConnection(Socket cfaslSocket) throws IOException {
		this.cfaslSocket = cfaslSocket;
		hostName = cfaslSocket.getInetAddress().getHostName();
		basePort = cfaslSocket.getPort() - CFASL_PORT_OFFSET;
		asciiPort = basePort + ASCII_PORT_OFFSET;
		communicationMode = BINARY_MODE;
		cycAccess = null;
		cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream());
		cfaslInputStream.trace = trace;
		cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream());
		cfaslOutputStream.trace = trace;
	}

	/**
	 * Constructs a new CycConnection object using the default host name,
	 * default base port number and binary communication mode. When CycAccess is
	 * null as in this case, diagnostic output is reduced.
	 * 
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 * @@throws IOException
	 *             when communications error occurs
	 * @@throws CycApiException
	 *             when an api error occurs
	 */
	public CycConnection() throws IOException, UnknownHostException,
			CycApiException {
		this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE,
				null);
	}

	/**
	 * Constructs a new CycConnection object using the default host name,
	 * default base port number with binary communication mode, and the given
	 * CycAccess object.
	 * 
	 * @@param cycAccess
	 *            the given CycAccess object which provides api services over
	 *            this CycConnection object
	 * 
	 * @@throws CycApiException
	 *             when a Cyc api exception occurs
	 * @@throws IOException
	 *             when communication error occurs
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 */
	public CycConnection(CycAccess cycAccess) throws IOException,
			UnknownHostException, CycApiException {
		this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE,
				cycAccess);
	}

	/**
	 * Constructs a new CycConnection object using a given host name, the given
	 * base port number, the given communication mode, and the given CycAccess
	 * object
	 * 
	 * @@param hostName
	 *            the cyc server host name
	 * @@param basePort
	 *            the base tcp port on which the OpenCyc server is listening for
	 *            connections.
	 * @@param communicationMode
	 *            either ASCII_MODE or BINARY_MODE
	 * @@param cycAccess
	 *            the given CycAccess object which provides api services over
	 *            this CycConnection object
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	public CycConnection(String hostName, int basePort, int communicationMode,
			CycAccess cycAccess) throws IOException, UnknownHostException,
			CycApiException {
		this(hostName, basePort, communicationMode,
				CycConnection.DEFAULT_MESSAGING_MODE, cycAccess);
	}

	/**
	 * Constructs a new CycConnection object using a given host name, the given
	 * base port number, the given communication mode, and the given CycAccess
	 * object
	 * 
	 * @@param hostName
	 *            the cyc server host name
	 * @@param basePort
	 *            the base tcp port on which the OpenCyc server is listening for
	 *            connections.
	 * @@param communicationMode
	 *            either ASCII_MODE or BINARY_MODE
	 * @@param messagingMode
	 *            either SERIAL_MESSAGING_MODE or CONCURRENT_MESSAGING_MODE
	 * @@param cycAccess
	 *            the given CycAccess object which provides api services over
	 *            this CycConnection object
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	public CycConnection(String hostName, int basePort, int communicationMode,
			int messagingMode, CycAccess cycAccess) throws IOException,
			UnknownHostException, CycApiException {
		this.hostName = hostName;
		this.basePort = basePort;
		asciiPort = basePort + ASCII_PORT_OFFSET;
		cfaslPort = basePort + CFASL_PORT_OFFSET;

		if ((communicationMode != ASCII_MODE)
				&& (communicationMode != BINARY_MODE)) {
			throw new CycApiException("Invalid communication mode "
					+ communicationMode);
		}

		this.communicationMode = communicationMode;

		if ((messagingMode != SERIAL_MESSAGING_MODE)
				&& (messagingMode != CONCURRENT_MESSAGING_MODE)) {
			throw new CycApiException("Invalid messaging mode " + messagingMode);
		}

		if ((communicationMode == ASCII_MODE)
				&& (messagingMode == CONCURRENT_MESSAGING_MODE)) {
			this.messagingMode = SERIAL_MESSAGING_MODE;
		} else {
			this.messagingMode = messagingMode;
		}

		final ConnectionTimer connectionTimer = new ConnectionTimer();
		connectionTimer.start();
		this.cycAccess = cycAccess;
		initializeApiConnections();

		if (trace > API_TRACE_NONE) {
			if (communicationMode == ASCII_MODE) {
				Log.current.println("Ascii connection " + asciiSocket);
			} else {
				Log.current.println("Binary connection " + cfaslSocket);
			}
		}

		uuid = UUID.randomUUID();

		if (this.messagingMode == CONCURRENT_MESSAGING_MODE) {
			initializeConcurrentProcessing();
		}

		/**
		 * for testing the connection timer try { Thread.sleep(100000); } catch
		 * (InterruptedException e) { }
		 */
		connectionTimer.isCycConnectionEstablished = true;
	}

	/**
	 * Sets the client listening port on which api response are received from
	 * Cyc
	 * 
	 * @@param _clientPort
	 *            the given port number, or zero if the operating system is to
	 *            choose a free port
	 */
	public static void setClientPort(int _clientPort) {
		clientPort = _clientPort;
	}

	/**
	 * Sets the client host name on which api response are received from Cyc.
	 * This is used when executing the client behind a firewall and using SSH
	 * port forwarding. The client must appear to reside on the same host as
	 * Cyc.
	 * 
	 * @@param _clientHostName
	 *            the given port number, or zero if the operating system is to
	 *            choose a free port
	 */
	public static void setClientHostName(String _clientHostName) {
		clientHostName = _clientHostName;
	}

	public int getConnectionType() {
		return CycAccess.PERSISTENT_CONNECTION;
	}

	/**
	 * Initializes the OpenCyc ascii socket and the OpenCyc binary socket
	 * connections.
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 */
	private void initializeApiConnections() throws IOException,
			UnknownHostException {
		if (Log.current == null) {
			Log.makeLog("cyc-api.log");
		}

		if (communicationMode == ASCII_MODE) {
			asciiSocket = new Socket(hostName, asciiPort);
			int val = asciiSocket.getReceiveBufferSize();
			asciiSocket.setReceiveBufferSize(val * 2);
			asciiSocket.setTcpNoDelay(true);
			in = new BufferedReader(new InputStreamReader(asciiSocket
					.getInputStream()));
			out = new BufferedWriter(new OutputStreamWriter(asciiSocket
					.getOutputStream()));
		} else {
			cfaslSocket = new Socket(hostName, cfaslPort);
			int val = cfaslSocket.getReceiveBufferSize();
			cfaslSocket.setReceiveBufferSize(val * 2);
			cfaslSocket.setTcpNoDelay(true);
			cfaslInputStream = new CfaslInputStream(cfaslSocket
					.getInputStream());
			cfaslInputStream.trace = trace;
			cfaslOutputStream = new CfaslOutputStream(cfaslSocket
					.getOutputStream());
			cfaslOutputStream.trace = trace;
		}
	}

	/**
	 * Initializes the concurrent processing mode. Use serial messaging mode to
	 * ensure the Cyc task processors are initialized, then start this
	 * connection's taskProcessor response handler thread.
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws UnknownHostException
	 *             when the cyc server cannot be found
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	protected void initializeConcurrentProcessing() throws IOException,
			UnknownHostException, CycApiException {
		taskProcessorBinaryResponseHandler = new TaskProcessorBinaryResponseHandler(
				Thread.currentThread(), this, clientPort);

		// the start method will not return until the inbound socket
		// has had time to initialize
		taskProcessorBinaryResponseHandler.start();

		if (!passiveConnection) {
			// Send request to Cyc server to open its outbound socket to
			// our awaiting listener.
			CycList request = new CycList();
			request.add(new CycSymbol("INITIALIZE-JAVA-API-SOCKET"));
			request.add(uuid.toString());
			if (clientHostName != null)
				request.add(clientHostName);
			else
				request.add(InetAddress.getLocalHost().getHostAddress());
			request
					.add(new Integer(
							taskProcessorBinaryResponseHandler.localClientListenerPort));
			sendBinary(request);
			// ignore response
			receiveBinary();
		}
	}

	/**
	 * Ensures that the api socket connections are closed when this object is
	 * garbage collected.
	 */
	protected void finalize() {
		close();
	}

	/**
	 * Close the api sockets and streams.
	 */
	public void close() {
		if (asciiSocket != null) {
			if (trace > API_TRACE_NONE) {
				Log.current.println("Closing asciiSocket " + asciiSocket);
			}

			if (out != null) {
				try {
					out.write("(API-QUIT)\n");
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error quitting the api connection "
							+ e.getMessage());
				}

				try {
					out.flush();
				} catch (Exception e) {
				}
			}

			if (in != null) {
				try {
					in.close();
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error finalizing the api connection "
							+ e.getMessage());
				}
			}

			if (asciiSocket != null) {
				try {
					asciiSocket.close();
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error closing the api connection "
							+ e.getMessage());
				}
			}
		}

		if (isValidBinaryConnection()) {
			if (trace > API_TRACE_NONE) {
				Log.current.println("Closing cfaslSocket " + cfaslSocket);
			}

			if (cfaslOutputStream != null) {
				CycList command;

				if (messagingMode == CONCURRENT_MESSAGING_MODE) {
					if (trace > API_TRACE_NONE) {
						Log.current.println("Closing server api socket, uuid: "
								+ uuid);
					}
					try {
						if (!passiveConnection) {
							command = new CycList();
							command.add(CycObjectFactory
									.makeCycSymbol("CLOSE-JAVA-API-SOCKET"));
							command.add(uuid.toString());
							sendBinary(command);
							if (cfaslInputStream != null)
								receiveBinary();
						}
					} catch (Exception e) {
					}
				}

				if (trace > API_TRACE_NONE) {
					Log.current.println("Sending API-QUIT to server");
				}

				command = new CycList();
				command.add(CycObjectFactory.makeCycSymbol("API-QUIT"));

				try {
					cfaslOutputStream.writeObject(command);
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error quitting the api connection "
							+ e.getMessage());
				}

				try {
					cfaslOutputStream.flush();
				} catch (Exception e) {
				}
			}

			if (cfaslInputStream != null) {
				if (trace > API_TRACE_NONE) {
					Log.current.println("Closing cfaslInputStream");
				}

				try {
					cfaslInputStream.close();
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error finalizing the api connection "
							+ e.getMessage());
				}
			}

			if (cfaslSocket != null) {
				if (trace > API_TRACE_NONE) {
					Log.current.println("Closing cfaslSocket");
				}

				try {
					cfaslSocket.close();
				} catch (Exception e) {
					Log.current.printStackTrace(e);
					Log.current.println("Error closing the api connection "
							+ e.getMessage());
				}
			}
		}

		if (messagingMode == CONCURRENT_MESSAGING_MODE) {
			taskProcessingEnded = true;

			if (trace > API_TRACE_NONE) {
				Log.current
						.println("Interrupting any threads awaiting replies");
			}

			interruptAllWaitingReplyThreads();

			try {
				taskProcessorBinaryResponseHandler.interrupt();
				taskProcessorBinaryResponseHandler.close();
				if (trace > API_TRACE_NONE) {
					Log.current
							.println("Waiting at most 500 milliseconds for the taskProcessorBinaryResponseHandler thread to die");
				}

				taskProcessorBinaryResponseHandler.join(500);

				if (!taskProcessingThreadDead) {
					if (trace > API_TRACE_NONE) {
						Log.current
								.println("The taskProcessorBinaryResponseHandler thread has not died, so continuing");
					}
				}
			} catch (Exception e) {
			}
		}

		if (trace > API_TRACE_NONE) {
			Log.current.println("Connection closed for " + connectionInfo());
		}
	}

	/**
	 * Return the name of the host to which the CycConnection is established.
	 * 
	 * @@return the name of the Host to which this <tt>CycConnection</tt> is
	 *         connected.
	 */
	public String getHostName() {
		return this.hostName;
	}

	/**
	 * Return the base port to which the CycConnection is established.
	 * 
	 * @@return the port to which this <tt>CycConnection</tt> is connected.
	 */
	public int getBasePort() {
		return this.basePort;
	}

	/**
	 * Return the ASCII port to which the CycConnection is established.
	 * 
	 * @@return the ASCII to which this <tt>CycConnection</tt> is connected.
	 */
	public int getAsciiPort() {
		return this.asciiPort;
	}

	/**
	 * Return the CFASL port to which the CycConnection is established.
	 * 
	 * @@return the CFASL port to which this <tt>CycConnection</tt> is
	 *         connected.
	 */
	public int getCfaslPort() {
		return this.cfaslPort;
	}

	/**
	 * Send a message to Cyc and return the <tt>Boolean</tt> true as the first
	 * element of an object array, and the cyc response Symbolic Expression as
	 * the second element. If an error occurs the first element is
	 * <tt>Boolean</tt> false and the second element is the error message
	 * string.
	 * 
	 * @@param message
	 *            the api command
	 * 
	 * @@return an array of two objects, the first is an response status object
	 *         either a Boolean (binary mode) or Integer (ascii mode), and the
	 *         second is the response object or error string.
	 * 
	 * @@throws IOException
	 *             when a commuications error occurs
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	public Object[] converse(Object message) throws IOException,
			CycApiException {
		return converse(message, notimeout);
	}

	/**
	 * Send a message to Cyc and return the response code as the first element
	 * of an object array, and the cyc response Symbolic Expression as the
	 * second element, spending no less time than the specified timer allows but
	 * throwing a <code>TimeOutException</code> at the first opportunity where
	 * that time limit is exceeded. If an error occurs the second element is the
	 * error message string.
	 * 
	 * @@param message
	 *            the api command which must be a String or a CycList
	 * @@param timeout
	 *            a <tt>Timer</tt> object giving the time limit for the api
	 *            call
	 * 
	 * @@return an array of two objects, the first is a Boolean response status
	 *         object, and the second is the response object or error string.
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws TimeOutException
	 *             when the time limit is exceeded
	 * @@throws CycApiException
	 *             when a Cyc api error occurs
	 * @@throws RuntimeException
	 *             if CycAccess is not present
	 */
	public Object[] converse(Object message, Timer timeout) throws IOException,
			TimeOutException, CycApiException {
		if (communicationMode == CycConnection.ASCII_MODE) {
			CycList messageCycList;

			if (message instanceof String) {
				if (cycAccess == null) {
					throw new RuntimeException(
							"CycAccess is required to process commands in string form");
				}

				messageCycList = cycAccess.makeCycList((String) message);
			} else if (message instanceof CycList) {
				messageCycList = (CycList) message;
			} else {
				throw new CycApiException("Invalid class for message "
						+ message);
			}

			String messageString = messageCycList.cyclifyWithEscapeChars();

			return converseAscii(messageString, timeout);
		} else { // Binary (CFASL) mode

			CycList messageCycList;

			if (message instanceof CycList) {
				messageCycList = (CycList) message;
			} else if (message instanceof String) {
				if (cycAccess == null) {
					throw new RuntimeException(
							"CycAccess is required to process commands in string form");
				}

				messageCycList = cycAccess.makeCycList((String) message);
			} else {
				throw new CycApiException("Invalid class for message "
						+ message);
			}

			messageCycList = substituteForBackquote(messageCycList, timeout);

			return converseBinary(messageCycList, timeout);
		}
	}

	/**
	 * Substitute a READ-FROM-STRING expression for expressions directly
	 * containing a backquote symbol. This transformation is only required for
	 * the binary api, which does not parse the backquoted expression.
	 * 
	 * @@param messageCycList
	 *            the given expression
	 * @@param timeout
	 *            a <tt>Timer</tt> object giving the time limit for the api
	 *            call
	 * 
	 * @@return the expression with a READ-FROM-STRING expression substituted for
	 *         expressions directly containing a backquote symbol
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws CycApiException
	 *             when a Cyc api error occurs
	 */
	protected CycList substituteForBackquote(CycList messageCycList,
			Timer timeout) throws IOException, CycApiException {
		if (messageCycList.treeContains(CycObjectFactory.backquote)) {
			CycList substituteCycList = new CycList();
			substituteCycList.add(CycObjectFactory
					.makeCycSymbol("read-from-string"));
			substituteCycList.add(messageCycList.cyclify());

			Object[] response = converseBinary(substituteCycList, timeout);

			if ((response[0].equals(Boolean.TRUE))
					&& (response[1] instanceof CycList)) {
				CycList backquoteExpression = (CycList) response[1];

				return backquoteExpression.subst(CycObjectFactory
						.makeCycSymbol("api-bq-list"), CycObjectFactory
						.makeCycSymbol("bq-list"));
			}

			throw new CycApiException("Invalid backquote substitution in "
					+ messageCycList + "\nstatus" + response[0] + "\nmessage "
					+ response[1]);
		}

		return messageCycList;
	}

	private class WaitingWorkerInfo {

		SubLWorker worker;

		CycList taskProcessorRequest;

		WaitingWorkerInfo(SubLWorker worker, CycList taskProcessorRequest) {
			this.worker = worker;
			this.taskProcessorRequest = taskProcessorRequest;
		}

		SubLWorker getWorker() {
			return worker;
		}

		CycObject getMessage() {
			return (CycObject) taskProcessorRequest.get(1);
		}

	}

	/**
	 * Send a message to Cyc and return the response code as the first element
	 * of an object array, and the cyc response Symbolic Expression as the
	 * second element, spending no less time than the specified timer allows but
	 * throwing a <code>TimeOutException</code> at the first opportunity where
	 * that time limit is exceeded. If an error occurs the second element is the
	 * error message string. The concurrent mode of Cyc server communication is
	 * supported by Cyc's pool of transaction processor threads, each of which
	 * can concurrently process an api request.
	 * 
	 * @@param message
	 *            the api command
	 * @@param timeout
	 *            a <tt>Timer</tt> object giving the time limit for the api
	 *            call
	 * 
	 * @@return an array of two objects, the first is an Boolean response code,
	 *         and the second is the response object or error string.
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws TimeOutException
	 *             when the time limit is exceeded
	 * @@throws CycApiException
	 *             when a Cyc api error occurs
	 */
	public Object[] converseBinary(CycList message, Timer timeout)
			throws IOException, TimeOutException, CycApiException {
		DefaultSubLWorkerSynch worker = new DefaultSubLWorkerSynch(message,
				this.cycAccess);
		Object[] result = new Object[2];
		try {
			result[1] = worker.getWork();
		} catch (IOException xcpt) {
			throw xcpt;
		} catch (TimeOutException xcpt) {
			throw xcpt;
		} catch (CycApiServerSideException xcpt) {
			// @@note: this implements a legacy API of converseBinary()
			result[0] = Boolean.FALSE;
			result[1] = xcpt.getMessage();
			return result;
		} catch (CycApiException xcpt) {
			throw xcpt;
		} catch (Exception xcpt) {
			throw new RuntimeException(xcpt);
		}
		result[0] = worker.getStatus() == SubLWorkerStatus.FINISHED_STATUS ? Boolean.TRUE
				: Boolean.FALSE;
		return result;
	}

	public void cancelCommunication(SubLWorker worker)
			throws java.io.IOException {
		Integer id = worker.getId();
		if (id.intValue() < 0) {
			// @@note serial communications cannot be canceled right now
			return;
		}
		String command = "(fif (" + "terminate-active-task-process" + " "
				+ worker.getId() + " \"" + uuid + "\" " + ":cancel"
				+ ") '(ignore) '(ignore))";
		sendBinary(cycAccess.makeCycList(command));
		// the SubL implementation of CANCEL will send a CANCEL event back,
		// which will cleanup the waiting thread info and signal the termination
		// event, so no need to perform event signaling and cleanup
	}

	public void abortCommunication(SubLWorker worker)
			throws java.io.IOException {
		Integer id = worker.getId();
		if (id.intValue() < 0) {
			// @@note serial communications cannot be canceled right now
			return;
		}
		try {
			String command = "(fif (" + "terminate-active-task-process" + " "
					+ worker.getId() + " \"" + uuid + "\" " + ":abort"
					+ ") '(ignore) '(ignore))";
			sendBinary(cycAccess.makeCycList(command));
		} finally {
			// the SubL implementation of ABORT will not send anything back,
			// so we do need to perform event signaling and cleanup
			worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
					SubLWorkerStatus.ABORTED_STATUS, null));
			waitingReplyThreads.remove(id);
		}
	}

	private boolean inAWTEventThread() {
		try {
			return javax.swing.SwingUtilities.isEventDispatchThread();
		} catch (Throwable e) {
			return false;
		}
	}

	protected void converseBinary(CycList message, Timer timeout,
			SubLWorker worker) throws IOException, TimeOutException,
			CycApiException {

		if ((worker instanceof SubLWorkerSynch) && inAWTEventThread()) {
			throw new CycApiException(
					"Invalid attempt to communicate with Cyc "
							+ "from the AWT event thread.\n\n" + worker);
		}
		if (this.messagingMode == SERIAL_MESSAGING_MODE) {
			SubLWorkerEvent event = new SubLWorkerEvent(worker, new Integer(-1));
			worker.fireSubLWorkerStartedEvent(event);
			sendBinary(message);
			Object[] result = receiveBinary();
			Object work = result[1];
			worker.fireSubLWorkerDataAvailableEvent(new SubLWorkerEvent(worker,
					work, 100.0f));
			worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
					SubLWorkerStatus.FINISHED_STATUS, null));
		} else { // CONCURRENT_MESSAGING_MODE
			CycSymbol taskProcessorRequestSymbol = CycObjectFactory
					.makeCycSymbol("task-processor-request");
			Integer id = null;
			CycList taskProcessorRequest = null;
			if (message.first().equals(taskProcessorRequestSymbol)) {
				// client has supplied the task-processor-request form
				taskProcessorRequest = message;
				id = (Integer) message.third();
			} else {
				id = nextApiRequestId();
				taskProcessorRequest = new CycList();
				taskProcessorRequest.add(taskProcessorRequestSymbol); // function
				taskProcessorRequest.add(message); // request
				taskProcessorRequest.add(id); // id
				taskProcessorRequest.add(new Integer(DEFAULT_PRIORITY)); // priority
				taskProcessorRequest.add(myClientName); // requestor
				taskProcessorRequest.add(CycObjectFactory.nil); // client-bindings
				taskProcessorRequest.add(uuid.toString()); // uuid to identify
															// this client
			}
			WaitingWorkerInfo waitingWorkerInfo = new WaitingWorkerInfo(worker,
					taskProcessorRequest);
			// tell everyone this is getting started
			waitingReplyThreads.put(id, waitingWorkerInfo);
			SubLWorkerEvent event = new SubLWorkerEvent(worker, id);
			worker.fireSubLWorkerStartedEvent(event);
			// start communication
			sendBinary(taskProcessorRequest);
		} // end-else: CONCURRENT_MESSAGING_MODE
	}

	/**
	 * Returns the next apiRequestId.
	 * 
	 * @@return the next apiRequestId
	 */
	static public synchronized Integer nextApiRequestId() {
		return new Integer(++apiRequestId);
	}

	/**
	 * Sends an object to the CYC server. If the connection is not already open,
	 * it is opened. The object must be a valid CFASL-translatable: an Integer,
	 * Float, Double, Boolean, String, or cyc object.
	 * 
	 * @@param message
	 *            the api command
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 */
	public synchronized void sendBinary(Object message) throws IOException {
		if (trace > API_TRACE_NONE) {
			if (message instanceof CycList) {
				Log.current.println(((CycList) message).safeToString()
						+ " --> cyc");
			} else if (message instanceof CycFort) {
				Log.current.println(((CycFort) message).safeToString()
						+ " --> cyc");
			} else {
				Log.current.println(message + " --> cyc");
			}
		}
		cfaslOutputStream.writeObject(message);
		cfaslOutputStream.flush();
	}

	/**
	 * Receives an object from the CYC server.
	 * 
	 * @@return an array of two objects, the first is a Boolean response, and the
	 *         second is the response object or error string.
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	public synchronized Object[] receiveBinary() throws IOException,
			CycApiException {
		Object status = cfaslInputStream.readObject();
		Object response = cfaslInputStream.readObject();
		Object[] answer = { null, null };

		if ((status == null) || status.equals(CycObjectFactory.nil)) {
			answer[0] = Boolean.FALSE;
			answer[1] = response;

			if (trace > API_TRACE_NONE) {
				String responseString = null;

				if (response instanceof CycList) {
					responseString = ((CycList) response).safeToString();
				} else if (response instanceof CycFort) {
					responseString = ((CycFort) response).safeToString();
				} else {
					responseString = response.toString();
				}

				Log.current.println("received error = (" + status + ") "
						+ responseString);
			}

			return answer;
		}

		answer[0] = Boolean.TRUE;

		if (cycAccess == null) {
			answer[1] = response;
		} else if (cycAccess.deferObjectCompletion) {
			answer[1] = response;
		} else {
			answer[1] = cycAccess.completeObject(response);
		}

		if (trace > API_TRACE_NONE) {
			String responseString = null;

			if (response instanceof CycList) {
				responseString = ((CycList) response).safeToString();
			} else if (response instanceof CycFort) {
				responseString = ((CycFort) response).safeToString();
			} else {
				responseString = response.toString();
			}

			Log.current
					.println("cyc --> (" + answer[0] + ") " + responseString);
		}

		return answer;
	}

	/**
	 * Receives a binary (cfasl) api request from a cyc server. Unlike the api
	 * response handled by the receiveBinary method, this method does not expect
	 * an input status object.
	 * 
	 * @@return the api request expression.
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws CycApiException
	 *             when a Cyc API exception occurs
	 */
	public CycList receiveBinaryApiRequest() throws IOException,
			CycApiException {
		CycList apiRequest = (CycList) cfaslInputStream.readObject();

		if (trace > API_TRACE_NONE) {
			Log.current.println("cyc --> (api-request) "
					+ apiRequest.safeToString());
		}

		return apiRequest;
	}

	/**
	 * Sends a binary (cfasl) api response to a cyc server. This method prepends
	 * a status object (the symbol T) to the message.
	 * 
	 * @@param message
	 *            the given binary api response
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 */
	public void sendBinaryApiResponse(Object message) throws IOException,
			CycApiException {
		if (trace > API_TRACE_NONE) {
			String messageString = null;

			if (message instanceof CycList) {
				messageString = ((CycList) message).safeToString();
			} else if (message instanceof CycFort) {
				messageString = ((CycFort) message).safeToString();
			} else {
				messageString = message.toString();
			}

			Log.current.println("(" + CycObjectFactory.t + ") " + messageString
					+ " --> cyc");
		}

		CycList apiResponse = new CycList();
		apiResponse.add(CycObjectFactory.t);
		apiResponse.add(message);
		cfaslOutputStream.writeObject(apiResponse);
	}

	/**
	 * Send a message to Cyc and return the Boolean response as the first
	 * element of an object array, and the cyc response Symbolic Expression as
	 * the second element, spending no less time than the specified timer allows
	 * but throwing a <code>TimeOutException</code> at the first opportunity
	 * where that time limit is exceeded. If an error occurs the first element
	 * is Boolean.FALSE and the second element is the error message string. The
	 * concurrent mode of Cyc server communication is supported by Cyc's pool of
	 * transaction processor threads, each of which can concurrently process an
	 * api request.
	 * 
	 * @@param message
	 *            the api command
	 * @@param timeout
	 *            a <tt>Timer</tt> object giving the time limit for the api
	 *            call
	 * 
	 * @@return an array of two objects, the first is an Integer response code,
	 *         and the second is the response object or error string.
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws TimeOutException
	 *             when the time limit is exceeded
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 * @@throws RuntimeException
	 *             if CycAccess is not present
	 */

	synchronized protected Object[] converseAscii(String message, Timer timeout)
			throws IOException, TimeOutException, CycApiException {
		isSymbolicExpression = false;

		Object[] response = converseUsingAsciiStrings(message, timeout);

		if (response[0].equals(Boolean.TRUE)) {
			String answer = ((String) response[1]).trim();

			if (StringUtils.isDelimitedString(answer)) {
				response[1] = StringUtils.removeDelimiters(answer);

				// Return the string.
				return response;
			}

			if (isSymbolicExpression) {
				// Recurse to complete contained CycConstant, CycNart objects.
				if (cycAccess == null) {
					throw new RuntimeException(
							"CycAccess is required to process commands in string form");
				}

				response[1] = CycAccess.current().makeCycList(answer);

				// Return the CycList object.
				return response;
			}

			if (answer.equals("NIL")) {
				response[1] = CycObjectFactory.nil;

				// Return the symbol nil.
				return response;
			}

			if (answer.startsWith("#$")) {
				if (cycAccess == null) {
					throw new RuntimeException(
							"CycAccess is required to process commands in string form");
				}

				response[1] = CycAccess.current().makeCycConstant(answer);

				// Return the constant.
				return response;
			}

			if (answer.startsWith("?")) {
				response[1] = CycObjectFactory.makeCycVariable(answer);

				// Return the variable.
				return response;
			}

			if (StringUtils.isNumeric(answer)) {
				response[1] = new Integer(answer);

				// Return the number.
				return response;
			}

			if (CycSymbol.isValidSymbolName(answer)) {
				response[1] = CycObjectFactory.makeCycSymbol(answer);

				// Return the symbol.
				return response;
			}

			try {
				double doubleAnswer = Double.parseDouble(answer);
				response[1] = new Double(doubleAnswer);

				// Return the double.
				return response;
			} catch (NumberFormatException e) {
			}

			if (answer.endsWith("d0")
					&& (StringUtils.hasNumericChar(answer.substring(0, answer
							.length() - 2)))) {
				String floatPart = answer.substring(0, answer.length() - 2);
				response[1] = new Double(floatPart);

				// Return the double.
				return response;
			}

			throw new CycApiException("Ascii api response not understood "
					+ answer);
		} else {
			return response;
		}
	}

	/**
	 * Send a message to Cyc and return the response code as the first element
	 * of a object array, and the Cyc response string as the second element.
	 * 
	 * @@param message
	 *            the given ascii message
	 * @@param timeout
	 *            the given time limit
	 * 
	 * @@return eturn the response code as the first element of a object array,
	 *         and the Cyc response string as the second element
	 * 
	 * @@throws IOException
	 *             when a communication error occurs
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 * @@throws TimeOutException
	 *             when the time limit is exceeded
	 */
	protected Object[] converseUsingAsciiStrings(String message, Timer timeout)
			throws IOException, CycApiException, TimeOutException {
		if (trace > API_TRACE_NONE) {
			Log.current.println(message + " --> cyc");
		}

		out.write(message);

		if (!message.endsWith("\n")) {
			out.newLine();
		}

		out.flush();

		if (trace > API_TRACE_NONE) {
			Log.current.print("cyc --> ");
		}

		Object[] answer = readAsciiCycResponse(timeout);

		if (trace > API_TRACE_NONE) {
			Log.current.println();
		}

		return answer;
	}

	/**
	 * Read the cyc response.
	 * 
	 * @@param timeout
	 *            the given time limit
	 * 
	 * @@return the Cyc response
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 * @@throws TimeOutException
	 *             when the time limit is exceeded
	 * @@throws RuntimeException
	 *             if CycAccess is not present
	 */
	private Object[] readAsciiCycResponse(Timer timeout) throws IOException,
			TimeOutException {
		Object[] answer = { null, null };

		// Parse the response code digits.
		StringBuffer responseCodeDigits = new StringBuffer();

		while (true) {
			if (timeout != null) {
				timeout.checkForTimeOut();
			}

			int ch = in.read();

			if (trace > API_TRACE_NONE) {
				Log.current.print((char) ch);
			}

			if (ch == ' ') {
				break;
			}

			responseCodeDigits.append((char) ch);
		}

		int responseCode = 0;

		try {
			responseCode = (new Integer(responseCodeDigits.toString().trim()))
					.intValue();
		} catch (NumberFormatException e) {
			throw new RuntimeException("Invalid response code digits "
					+ responseCodeDigits);
		}

		if (responseCode == 200) {
			answer[0] = Boolean.TRUE;
		} else {
			answer[0] = Boolean.FALSE;
		}

		in.mark(1);

		int ch = in.read();
		in.reset();

		if (ch == '(') {
			isSymbolicExpression = true;
			answer[1] = readSymbolicExpression();
		} else if (ch == '"') {
			answer[1] = readQuotedString();
		} else {
			answer[1] = readAtom();
		}

		// Read the terminating newline.
		ch = in.read();

		if (trace > API_TRACE_NONE) {
			Log.current.print((char) ch);
		}

		return answer;
	}

	/**
	 * Reads a complete symbolic expression as an ascii string.
	 * 
	 * @@return a complete symbolic expression as an ascii string
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 */
	private String readSymbolicExpression() throws IOException {
		int parenLevel = 0;
		boolean isQuotedString = false;
		StringBuffer result = new StringBuffer();
		int ch = in.read();

		if (trace > API_TRACE_NONE) {
			Log.current.print((char) ch);
		}

		parenLevel++;
		result.append((char) ch);

		while (parenLevel != 0) {
			ch = in.read();

			if (trace > API_TRACE_NONE) {
				Log.current.print((char) ch);
			}

			if (ch == '"') {
				if (isQuotedString) {
					isQuotedString = false;
				} else {
					isQuotedString = true;
				}
			}

			if (!isQuotedString) {
				if (ch == '(') {
					parenLevel++;
				}

				if (ch == ')') {
					parenLevel--;
				}
			}

			result.append((char) ch);
		}

		return result.toString();
	}

	/**
	 * Reads a quoted string
	 * 
	 * @@return the quoted string read
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 */
	private String readQuotedString() throws IOException {
		StringBuffer result = new StringBuffer();
		int ch = in.read();

		if (trace > API_TRACE_NONE) {
			Log.current.print((char) ch);
		}

		boolean escapedChar = false;

		while (true) {
			ch = in.read();

			if (trace > API_TRACE_NONE) {
				Log.current.print((char) ch);
			}

			if ((ch == '"') && (!escapedChar)) {
				return "\"" + result.toString() + "\"";
			}

			if (escapedChar) {
				escapedChar = false;

				if (ch == 'n') {
					result.append('\n');
				} else {
					result.append((char) ch);
				}
			} else if (ch == '\\') {
				escapedChar = true;
			} else {
				result.append((char) ch);
			}
		}
	}

	/**
	 * Reads an atom.
	 * 
	 * @@return the atom read as an ascii string
	 * 
	 * @@throws IOException
	 *             when a communications error occurs
	 */
	private String readAtom() throws IOException {
		StringBuffer result = new StringBuffer();

		while (true) {
			in.mark(1);

			int ch = in.read();

			if (trace > API_TRACE_NONE) {
				Log.current.print((char) ch);
			}

			if (ch == '\r') {
				break;
			}

			if (ch == '\n') {
				break;
			}

			result.append((char) ch);
		}

		in.reset();

		return result.toString();
	}

	/**
	 * Turns on the diagnostic trace of socket messages.
	 */
	public void traceOn() {
		trace = API_TRACE_MESSAGES;

		if (communicationMode == BINARY_MODE) {
			cfaslInputStream.trace = trace;
			cfaslOutputStream.trace = trace;
		}
	}

	/**
	 * Turns on the detailed diagnostic trace of socket messages.
	 */
	public void traceOnDetailed() {
		setTrace(API_TRACE_DETAILED);
	}

	/**
	 * Turns off the diagnostic trace of socket messages.
	 */
	public void traceOff() {
		setTrace(API_TRACE_NONE);
	}

	/**
	 * Returns the trace value.
	 * 
	 * @@return the trace value
	 */
	public int getTrace() {
		return trace;
	}

	/**
	 * Sets the socket messages diagnostic trace value.
	 * 
	 * @@param trace
	 *            the new socket messages diagnostic trace value
	 */
	public void setTrace(int trace) {
		this.trace = trace;

		if (communicationMode == BINARY_MODE) {
			cfaslInputStream.trace = trace;
			cfaslOutputStream.trace = trace;

			if (taskProcessorBinaryResponseHandler != null) {
				taskProcessorBinaryResponseHandler.inboundStream.trace = trace;
			}
		}
	}

	/**
	 * Answers true iff this is a valid binary (cfasl) connection to Cyc.
	 * 
	 * @@return true iff this is a valid binary (cfasl) connection to Cyc
	 */
	public boolean isValidBinaryConnection() {
		if (cfaslSocket == null) {
			return false;
		}

		// TODO enable the below statement when tomcat servers are typically 1.4
		// compliant
		// return cfaslSocket.isConnected();
		try {
			OutputStream outputStream = cfaslSocket.getOutputStream();
		} catch (IOException e) {
			return false;
		}

		if ((taskProcessorBinaryResponseHandler == null)
				|| (taskProcessorBinaryResponseHandler.inboundSocket == null)) {
			return false;
		}

		try {
			OutputStream outputStream = taskProcessorBinaryResponseHandler.inboundSocket
					.getOutputStream();
		} catch (IOException e) {
			return false;
		}

		return true;
	}

	/**
	 * Returns connection information, suitable for diagnostics.
	 * 
	 * @@return connection information, suitable for diagnostics
	 */
	public String connectionInfo() {
		return "host " + hostName + ", asciiPort " + asciiPort + ", cfaslPort "
				+ cfaslPort;
	}

	/**
	 * Gets the UUID that identifies this java api client connection.
	 * 
	 * @@return the UUID that identifies this java api client connection
	 */
	public UUID getUuid() {
		return uuid;
	}

	/**
	 * Sets the client name of this api connection.
	 * 
	 * @@param myClientName
	 *            the client name of this api connection
	 */
	public void setMyClientName(String myClientName) {
		this.myClientName = myClientName;
	}

	/**
	 * Gets the client name of this api connection.
	 * 
	 * @@return the client name of this api connection
	 */
	public String getMyClientname() {
		return myClientName;
	}

	/**
	 * Recovers from a socket error by interrupting all the waiting reply
	 * threads. Each awakened thread will detect the error condition and throw
	 * an IOExecption.
	 */
	protected void interruptAllWaitingReplyThreads() {
		Iterator iter = waitingReplyThreads.values().iterator();

		while (iter.hasNext()) {
			WaitingWorkerInfo waitingWorkerInfo = (WaitingWorkerInfo) iter
					.next();
			if (trace > API_TRACE_NONE) {
				Log.current.println("Interrupting reply worker "
						+ waitingWorkerInfo.getWorker());
			}
			try {
				waitingWorkerInfo.worker.cancel();
			} catch (java.io.IOException xcpt) {
				if (trace > API_TRACE_NONE) {
					Log.current.println("Could not interrupt reply worker "
							+ waitingWorkerInfo.getWorker() + ": exception: "
							+ xcpt);
				}
			}
		}
	}

	/**
	 * Gets the dictionary of waiting reply thread information objects.
	 * 
	 * @@return the dictionary of waiting reply thread information objects
	 */
	public Hashtable getWaitingReplyThreadInfos() {
		return waitingReplyThreads;
	}

	/**
	 * Resets the Cyc task processor which is currently processing the
	 * api-request specified by the given id. If none of the task processors is
	 * currently processessing the specified api-request, then the reset request
	 * is ignored. When reset, the Cyc task processor returns an error message
	 * to the waiting client thread. The error message consists of
	 * "reset\nTHE-API-REQUEST".
	 * 
	 * @@param id
	 *            the id of the api-request which is to be interrupted and
	 *            cancelled
	 * 
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 * @@throws IOException
	 *             when a communication error occurs
	 */
	public void resetTaskProcessorById(Integer id) throws CycApiException,
			IOException {
		resetTaskProcessorById(id.intValue());
	}

	/**
	 * Resets the Cyc task processor which is currently processing the
	 * api-request specified by the given id. If none of the task processors is
	 * currently processessing the specified api-request, then the reset request
	 * is ignored. When reset, the Cyc task processor returns an error message
	 * to the waiting client thread.
	 * 
	 * @@param id
	 *            the id of the api-request which is to be interrupted and
	 *            cancelled
	 * 
	 * @@throws CycApiException
	 *             when a Cyc API error occurs
	 * @@throws IOException
	 *             when a communications error occurs
	 */
	public void resetTaskProcessorById(int id) throws CycApiException,
			IOException {
		CycList command = new CycList();
		command.add(CycObjectFactory
				.makeCycSymbol("reset-api-task-processor-by-id"));
		command.add(myClientName);
		command.add(new Integer(id));
		cycAccess.converseCycObject(command);
	}

	/**
	 * Class TaskProcessorBinaryResponseHandler handles responses from
	 * task-processor requests in binary communication mode.
	 */
	protected class TaskProcessorBinaryResponseHandler extends Thread {

		/**
		 * specifies a free port where the java api listens for responses from
		 * the Cyc server
		 */
		public int localClientListenerPort;

		/** Maximum number of local cyc clients supported by this listener. */
		public static final int MAX_LOCAL_CLIENT_CLIENTS = 50;

		/** The socket which listens for new connections. */
		protected ServerSocket listenerSocket = null;

		/**
		 * The socket which receives asychronous inbound messages from the Cyc
		 * server.
		 */
		protected Socket inboundSocket = null;

		/**
		 * The binary interface input stream which receives asychronous messages
		 * from the Cyc server
		 */
		public CfaslInputStream inboundStream;

		/**
		 * The binary interface output stream, which is the output side of the
		 * bidirectional socket, is used only to start up and close down the
		 * socket.
		 */
		protected CfaslOutputStream inboundOutputStream;

		/**
		 * Reference to the parent thread which will sleep until this handler is
		 * initialized.
		 */
		protected Thread parentThread;

		/**
		 * The (ignore) message from the Cyc server to test if the connection is
		 * alive.
		 */
		protected CycList ignoreMessage;

		/** the parent CycConnection */
		protected CycConnection cycConnection;

		/** the synchronization object to ensure that the streams are ready */
		private Object lockObject;

		private boolean initialized;

		/**
		 * Constructs a TaskProcessorBinaryResponseHandler object.
		 * 
		 * @@param parentThread
		 *            the parent thread of this thread
		 * @@param cycConnection
		 *            the parent CycConnection
		 * @@param localClientListenerPort
		 *            pecifies a free port where the java api listens for
		 *            responses from the Cyc server
		 */
		public TaskProcessorBinaryResponseHandler(Thread parentThread,
				CycConnection cycConnection, int localClientListenerPort) {
			this.parentThread = parentThread;
			this.cycConnection = cycConnection;
			this.localClientListenerPort = localClientListenerPort;
			ignoreMessage = new CycList();
			ignoreMessage.add(new CycSymbol("IGNORE"));
		}

		public void start() {
			initializeSynchronization();
			super.start();
			waitOnSetupToComplete();
		}

		/**
		 * Opens the response socket with Cyc, blocks until the next
		 * task-processor response is available, then awakens the client thread
		 * that made the request.
		 */
		public void run() {
			Thread.currentThread()
					.setName("TaskProcessorBinaryResponseHandler");
			try {
				if (cycConnection.passiveConnection) {
					// Open a second api socket connection and use it for
					// asychronous api responses.
					inboundSocket = new Socket(hostName, cfaslPort);
					int val = inboundSocket.getReceiveBufferSize();
					inboundSocket.setReceiveBufferSize(val * 2);
					inboundSocket.setTcpNoDelay(true);
					inboundStream = new CfaslInputStream(inboundSocket
							.getInputStream());
					inboundStream.trace = trace;
					inboundOutputStream = new CfaslOutputStream(inboundSocket
							.getOutputStream());
					// Send request to Cyc server to start sending back api
					// responses on this socket connection.
					CycList request = new CycList();
					request.add(new CycSymbol(
							"INITIALIZE-JAVA-API-PASSIVE-SOCKET"));
					request.add(cycConnection.uuid.toString());
					inboundOutputStream.writeObject(request);
					inboundOutputStream.flush();
					// ignore the first response
					inboundStream.readObject();
					inboundStream.readObject();
				} else {
					// Create a listener socket awaiting the Cyc connection.
					listenerSocket = new ServerSocket(localClientListenerPort,
							MAX_LOCAL_CLIENT_CLIENTS);
					localClientListenerPort = listenerSocket.getLocalPort();
					parentThread.interrupt();
					inboundSocket = listenerSocket.accept();
					inboundStream = new CfaslInputStream(inboundSocket
							.getInputStream());
					inboundStream.trace = trace;
					listenerSocket.close();
				}
			} catch (IOException e) {
				Log.current.printStackTrace(e);
				System.exit(1);
			}
			// this is probably to signal that we are ready to go
			notifySetupCompleted();

			// Handle messsages received on the asychronous inbound Cyc
			// connection.
			while (true) {
				Object status = null;
				CycList taskProcessorResponse = null;

				try {
					status = inboundStream.readObject();
					taskProcessorResponse = (CycList) inboundStream
							.readObject();

					// Log.current.println("taskProcessorResponse: " +
					// taskProcessorResponse.safeToString());
				} catch (Exception e) {
					if (taskProcessingEnded) {
						if (trace > API_TRACE_NONE) {
							Log.current
									.println("Ending binary mode task processor handler.");
						}
					}

					if (e instanceof CfaslInputStreamClosedException) {
						if (trace > API_TRACE_NONE) {
							Log.current.errorPrintln(e.getMessage());
							// Log.current.printStackTrace(e);
						}
					} else if (e instanceof RuntimeException) {
						Log.current.errorPrintln(e.getMessage());
						Log.current.printStackTrace(e);
						continue;
					} else if (trace > API_TRACE_NONE) {
						Log.current
								.println("Cyc Server ended binary mode task processor handler.");
					}

					taskProcessingThreadDead = true;

					return;
				}

				if (trace > API_TRACE_NONE) {
					String responseString = null;
					Log.current.println("cyc --> (" + status + ") "
							+ taskProcessorResponse.safeToString());
				}

				if (taskProcessorResponse.equals(ignoreMessage)) {
					continue;
				}

				try {
					// @@note and please explain, why are these not constants?
					Integer id = (Integer) taskProcessorResponse.get(2);
					Object response = taskProcessorResponse.get(5);
					Object taskStatus = taskProcessorResponse.get(6);
					// handle Cyc images that either support or do not support
					// (legacy) the finished flag
					Object finishedFlag = (taskProcessorResponse.size() > 7) ? taskProcessorResponse
							.get(7)
							: CycObjectFactory.t;

					boolean finished = !(finishedFlag == CycObjectFactory.nil);

					WaitingWorkerInfo waitingWorkerInfo = (WaitingWorkerInfo) waitingReplyThreads
							.get(id);
					if (waitingWorkerInfo == null) {
						continue;
					}
					SubLWorker worker = waitingWorkerInfo.getWorker();

					if (taskStatus == CycObjectFactory.nil) {
						// no error occurred, no exceptions
						List referencedConstants = DefaultCycObject
								.getReferencedConstants(response);
						for (Iterator iter = referencedConstants.listIterator(); iter
								.hasNext();) {
							if (((CycConstant) iter.next()).safeGetName() != null) {
								iter.remove();
							}
						}
						if (referencedConstants.size() > 0) {
							new GetConstantNamesAndForwardResultsThread(
									referencedConstants, worker, response,
									finished).start();
						} else {
							worker
									.fireSubLWorkerDataAvailableEvent(new SubLWorkerEvent(
											worker, response, -1.0f));
							if (finished) {
								worker
										.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(
												worker,
												SubLWorkerStatus.FINISHED_STATUS,
												null));
							}
						}
					} else {
						// Error, status contains the error message

						// @@ToDo need to diferrentiate between exceptions and
						// cancel messages!!!!!!!!!
						finished = true;
						if (taskStatus instanceof String) {
							worker
									.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(
											worker,
											SubLWorkerStatus.EXCEPTION_STATUS,
											new CycApiServerSideException(
													taskStatus.toString())));
						} else if (taskStatus instanceof CycSymbol) {
							worker
									.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(
											worker,
											SubLWorkerStatus.CANCELED_STATUS,
											null));
						}
					}

					if (worker.isDone()) {
						waitingReplyThreads.remove(id);
					}
				} catch (Exception xcpt) {
					Log.current.errorPrintln(xcpt.getMessage());
					Log.current.printStackTrace(xcpt);
					continue;
				}
			} // while-forever
		}

		/**
		 * Closes the passive inbound api response socket by sending an
		 * (api-quit) through it to Cyc.
		 */
		public void close() throws IOException {
			CycList request = new CycList();
			request.add(new CycSymbol("API-QUIT"));
			// request.add(cycConnection.uuid.toString());
			inboundOutputStream.writeObject(request);
			inboundOutputStream.flush();
		}

		private void waitOnSetupToComplete() {
			// avoid blocking on this ptr, which would stop the
			// notifySetupCompleted method from working correctly
			synchronized (lockObject) {
				boolean isInitialized = false;
				synchronized (this) {
					isInitialized = this.initialized;
				}
				while (!isInitialized) {
					try {
						lockObject.wait();
					} catch (InterruptedException xcpt) {
						System.err
								.println("Interrupted during wait(): " + xcpt);
					}
					synchronized (this) {
						isInitialized = this.initialized;
					}
				}
			}
		}

		private void initializeSynchronization() {
			synchronized (this) {
				initialized = false;
				lockObject = new String("Lock object");
			}
		}

		private void notifySetupCompleted() {
			synchronized (this) {
				initialized = true;
			}
			synchronized (lockObject) {
				lockObject.notify();
			}
		}
	}

	private static class GetConstantNamesAndForwardResultsThread extends Thread {

		public GetConstantNamesAndForwardResultsThread(List partialConstants,
				SubLWorker worker, Object response, boolean isFinished) {
			this.partialConstants = partialConstants;
			this.worker = worker;
			this.response = response;
			this.isFinished = isFinished;
		}

		public void run() {
			try {
				worker.getCycServer().obtainConstantNames(partialConstants);
				worker.fireSubLWorkerDataAvailableEvent(new SubLWorkerEvent(
						worker, response, -1.0f));
				if (isFinished) {
					worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(
							worker, SubLWorkerStatus.FINISHED_STATUS, null));
				}
			} catch (Exception xcpt) {
				Log.current.printStackTrace(xcpt);
			}
		}

		private List partialConstants;

		private SubLWorker worker;

		private Object response;

		private boolean isFinished;
	}

	/**
	 * Provides a timer thread for cancelling the connection if it takes too
	 * long to establish.
	 */
	private class ConnectionTimer extends Thread {

		/** Constucts a new ConnectionTimer instance. */
		ConnectionTimer() {
		}

		/**
		 * Waits for either the CycConnection constructor thread to set the done
		 * indicator, or kills the connection after the timeout is exceeded.
		 */
		public void run() {
			try {
				while (!isCycConnectionEstablished) {
					Thread.sleep(WAIT_TIME_INCREMENT);
					timerMillis = timerMillis + WAIT_TIME_INCREMENT;
					if (timerMillis > TIMEOUT_MILLIS)
						throw new InterruptedException();
				}
			} catch (InterruptedException e) {
				Log.current
						.println("Timeout while awaiting Cyc connection establishment, closing sockets");
				// close the socket connections to Cyc and kill any awaiting api
				// request threads
				if (trace == CycConnection.API_TRACE_NONE)
					trace = CycConnection.API_TRACE_MESSAGES;
				close();
			}
		}

		/** the timeout duration in milliseconds (one minute) */
		final long TIMEOUT_MILLIS = 60000;

		/** the wait time increment */
		final long WAIT_TIME_INCREMENT = 1000;

		/** the wait time so far in milliseconds */
		long timerMillis = 0;

		/**
		 * set by the CycConnection constructor process to indicate that the
		 * connection to Cyc is established
		 */
		boolean isCycConnectionEstablished = false;

	}

	public void converseBinary(SubLWorker worker) throws IOException,
			TimeOutException, CycApiException {
		converseBinary(worker.getSubLCommand(),new Timer(300));
	}

}
@


1.48
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@d3 6
a8 2
import java.io.*;

a12 1

a15 1
import java.util.logging.Logger;
d17 1
d19 1
a19 1
import org.opencyc.cycobject.CycConstant;
a20 1
import org.opencyc.cycobject.CycList;
a22 1

d30 2
a31 2
 * Provides a binary connection and an ascii connection to the OpenCyc server. The ascii connection
 * is legacy and its use is deprecated.
d34 6
a39 5
 * Collaborates with the <tt>CycAccess</tt> class which wraps the api functions.  CycAccess may be
 * specified as null in the CycConnection constructors when the binary api is used. Concurrent api
 * requests are supported for binary (cfasl) mode. This is implemented by two socket connections,
 * the first being for asynchronous api requests sent to Cyc, and the second for the asychronous
 * api responses received from Cyc.
d42 7
a48 2
 * @@version $Id: CycConnection.java,v 1.80.4.1 2006/07/13 14:20:21 karen Exp $
 * @@author Stephen L. Reed <p><p><p><p><p>
d51 4
a54 2
  /** Default host name for the OpenCyc server. */
  public static String DEFAULT_HOSTNAME = "localhost";
d56 2
a57 1
  //public static String DEFAULT_HOSTNAME = "207.207.8.185";
d59 2119
a2177 2
  /** Default base tcp port for the OpenCyc server. */
  public static final int DEFAULT_BASE_PORT = 3600;
a2178 1236
  /** HTTP port offset for the OpenCyc server. */
  public static final int HTTP_PORT_OFFSET = 0;

  /** CFASL (binary) port offset for the OpenCyc server. */
  public static final int CFASL_PORT_OFFSET = 14;

  /** No api trace. */
  public static final int API_TRACE_NONE = 0;

  /** Message-level api trace. */
  public static final int API_TRACE_MESSAGES = 1;

  /** Detailed api trace. */
  public static final int API_TRACE_DETAILED = 2;

  /** Parameter that, when true, causes a trace of the messages to and from the server. */
  protected int trace = API_TRACE_NONE;

//  protected int trace = API_TRACE_MESSAGES;
//  protected int trace = API_TRACE_DETAILED;

  /** CFASL (binary) mode connnection to the Cyc server (preferred). */
  public static final int BINARY_MODE = 2;

  /** The binary interface input stream. */
  protected CfaslInputStream cfaslInputStream;

  /** The binary interface output stream. */
  protected CfaslOutputStream cfaslOutputStream;

  /** The name of the computer hosting the OpenCyc server. */
  protected String hostName;

  /** The tcp port from which the asciiPort and cfaslPorts are derived. */
  protected int basePort;

  /** The tcp port assigned to the binary connection to the OpenCyc server. */
  protected int cfaslPort;

  /** The tcp socket assigned to the binary connection to the OpenCyc server. */
  protected Socket cfaslSocket;

  /** The timer which optionally monitors the duration of requests to the OpenCyc server. */
  protected static final Timer notimeout = new Timer();

  /**
   * Indicates if the response from the OpenCyc server is a symbolic expression (enclosed in
   * parentheses).
   */
  protected boolean isSymbolicExpression = false;

  /**
   * A reference to the parent CycAccess object for dereferencing constants in ascii symbolic
   * expressions.
   */
  protected CycAccess cycAccess;

  /** outbound request serial id */
  static private int apiRequestId = 0;

  /** The priorities for the task processors. These correspond to the
      SubL priorities for SL:SET-PROCESS-PRIORITY */
  public static final Integer MAX_PRIORITY = new Integer(10);
  public static final Integer CRITICAL_PRIORITY = new Integer(7);
  public static final Integer NORMAL_PRIORITY = new Integer(5);
  public static final Integer BACKGROUND_PRIORITY = new Integer(3);
  public static final Integer MIN_PRIORITY = new Integer(1);
  // @@legacy
  public static final int DEFAULT_PRIORITY = NORMAL_PRIORITY.intValue();

  /** name of my api client */
  protected String myClientName = "api client";

  /**
   * Implements an association:  apiRequestId --> waiting thread info, where waiting thread info is
   * an array of two objects: 1.  the latch waiting for the response from the Cyc server
   * (number 1 in no longer valid @@todo fix this description) 2.  the
   * api-request in CycList form Used when submitting concurrent requests to the task-processor.
   */
  protected Hashtable waitingReplyThreads = new Hashtable();

  /** handles responses from task-processor requests in binary communication mode. */
  protected TaskProcessorBinaryResponseHandler taskProcessorBinaryResponseHandler;

  /** Indicates to the taskProcessor response handlers that the server connection is closed. */
  protected boolean taskProcessingEnded = false;

  /** Indicates that the task processing thread is dead */
  protected boolean taskProcessingThreadDead = false;

  /**
   * Universally Unique ID that identifies this CycConnection to the Cyc server. It is used when
   * establishing the (second) asychronous socket connection.
   */
  protected UUID uuid;

  /** the logger */
  protected final Logger logger;
  
  /**
   * Constructs a new CycConnection using the given socket obtained from the parent AgentManager
   * listener.
   * 
   * @@param cfaslSocket tcp socket which forms the binary connection to the OpenCyc server
   * 
   * @@throws IOException when communication error occurs
   */
  public CycConnection(Socket cfaslSocket) throws IOException {
    logger = Logger.getLogger("org.opencyc.CycConnection");
    this.cfaslSocket = cfaslSocket;
    hostName = cfaslSocket.getInetAddress().getHostName();
    basePort = cfaslSocket.getPort() - CFASL_PORT_OFFSET;
    cycAccess = null;
    cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream());
    cfaslInputStream.trace = trace;
    cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream());
    cfaslOutputStream.trace = trace;
  }

  /**
   * Constructs a new CycConnection object using the default host name and default base port numbe.  
   * When CycAccess is null as in this case, diagnostic output is reduced.
   * 
   * @@throws UnknownHostException when the cyc server cannot be found
   * @@throws IOException when communications error occurs
   * @@throws CycApiException when an api error occurs
   */
  public CycConnection() throws IOException, UnknownHostException, CycApiException {
    this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, null);
  }

  /**
   * Constructs a new CycConnection object using the default host name, default base port number
   * and the given CycAccess object.
   * 
   * @@param cycAccess the given CycAccess object which provides api services over this
   *        CycConnection object
   * 
   * @@throws CycApiException when a Cyc api exception occurs
   * @@throws IOException when communication error occurs
   * @@throws UnknownHostException when the cyc server cannot be found
   */
  public CycConnection(CycAccess cycAccess) throws IOException, UnknownHostException, CycApiException {
    this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, cycAccess);
  }

  /**
   * Constructs a new CycConnection object using a given host name, the given base port number, the
   * given communication mode, and the given CycAccess object
   * 
   * @@param hostName the cyc server host name
   * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
   * @@param cycAccess the given CycAccess object which provides api services over this
   *        CycConnection object
   * 
   * @@throws IOException when a communications error occurs
   * @@throws UnknownHostException when the cyc server cannot be found
   * @@throws CycApiException when a Cyc API error occurs
   */
  public CycConnection(String hostName, int basePort, CycAccess cycAccess) throws IOException, UnknownHostException, CycApiException {
    logger = Logger.getLogger("org.opencyc.CycConnection");
    this.hostName = hostName;
    this.basePort = basePort;
    cfaslPort = basePort + CFASL_PORT_OFFSET;
    final ConnectionTimer connectionTimer = new ConnectionTimer();
    connectionTimer.start();
    this.cycAccess = cycAccess;
    initializeApiConnections();

    if (trace > API_TRACE_NONE) {
      Log.current.println("CFASL connection " + cfaslSocket);
    }

    uuid = UUID.randomUUID();
    initializeConcurrentProcessing();

    
    /** for testing the connection timer 
    try {
      Thread.sleep(100000);
    }
    catch (InterruptedException e) {
    }
    */
    connectionTimer.isCycConnectionEstablished = true;
  }

  public int getConnectionType() {
    return CycAccess.PERSISTENT_CONNECTION;
  }
  
  /**
   * Initializes the OpenCyc CFASL socket connections.
   * 
   * @@throws IOException when a communications error occurs
   * @@throws UnknownHostException when the cyc server cannot be found
   */
  private void initializeApiConnections()
                                 throws IOException, UnknownHostException {
    if (Log.current == null) {
      Log.makeLog("cyc-api.log");
    }
    cfaslSocket = new Socket(hostName, cfaslPort);
    int val = cfaslSocket.getReceiveBufferSize();
    cfaslSocket.setReceiveBufferSize(val * 2);
    cfaslSocket.setTcpNoDelay(true);
    cfaslSocket.setKeepAlive(true);
    cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream());
    cfaslInputStream.trace = trace;
    cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream());
    cfaslOutputStream.trace = trace;
  }

  /**
   * Initializes the concurrent processing mode.  Use serial messaging mode to ensure the Cyc task
   * processors are initialized, then start this connection's taskProcessor response handler
   * thread.
   * 
   * @@throws IOException when a communications error occurs
   * @@throws UnknownHostException when the cyc server cannot be found
   * @@throws CycApiException when a Cyc API error occurs
   */
  protected void initializeConcurrentProcessing()
                                         throws IOException, UnknownHostException, CycApiException {
    taskProcessorBinaryResponseHandler = 
      new TaskProcessorBinaryResponseHandler(Thread.currentThread(), this);
    
    // the start method will not return until the inbound socket
    // has had time to initialize 
    taskProcessorBinaryResponseHandler.start();
  }

  /**
   * Ensures that the api socket connections are closed when this object is garbage collected.
   */
  protected void finalize() {
    close();
  }

  /**
   * Close the api sockets and streams.
   */
  public void close() {
    if (isValidBinaryConnection(true)) {
      if (cfaslOutputStream != null) {
        CycList command;
        if (trace > API_TRACE_NONE) {
          Log.current.println("Closing server's api response socket associated with uuid: " + uuid);
        }
        command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("RELEASE-RESOURCES-FOR-JAVA-API-CLIENT"));
        command.add(uuid);
        try {
          cfaslOutputStream.writeObject(command);
        }
         catch (Exception e) {
          Log.current.printStackTrace(e);
          Log.current.println("Error closing server's api response socket " + e.getMessage());
        }
        if (trace > API_TRACE_NONE) {
          Log.current.println("Sending API-QUIT to server that will close its api request socket and its handling thread");
        }
        command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("API-QUIT"));

        try {
          cfaslOutputStream.writeObject(command);
        }
         catch (Exception e) {
          Log.current.printStackTrace(e);
          Log.current.println("Error quitting the api connection " + e.getMessage());
        }

        try {
          cfaslOutputStream.flush();
        }
         catch (Exception e) {
        }
      }
    }
    if (cfaslInputStream != null) {
      if (trace > API_TRACE_NONE) {
        Log.current.println("Closing cfaslInputStream");
      }

      try {
        cfaslInputStream.close();
      }
       catch (Exception e) {
        Log.current.printStackTrace(e);
        Log.current.println("Error finalizing the api connection " + e.getMessage());
      }
    }

    if (cfaslSocket != null) {
      if (trace > API_TRACE_NONE) {
        Log.current.println("Closing cfaslSocket");
      }

      try {
        cfaslSocket.close();
      }
       catch (Exception e) {
        Log.current.printStackTrace(e);
        Log.current.println("Error closing the api connection " + e.getMessage());
      }
    }

    taskProcessingEnded = true;

    if (trace > API_TRACE_NONE) {
      Log.current.println("Interrupting any threads awaiting replies");
    }

    interruptAllWaitingReplyThreads();

    try {
      taskProcessorBinaryResponseHandler.interrupt();
      taskProcessorBinaryResponseHandler.close();
      if (trace > API_TRACE_NONE) {
        Log.current.println("Waiting at most 500 milliseconds for the taskProcessorBinaryResponseHandler thread to die");
      }

      taskProcessorBinaryResponseHandler.join(500);

      if (!taskProcessingThreadDead) {
        if (trace > API_TRACE_NONE) {
          Log.current.println("The taskProcessorBinaryResponseHandler thread has not died, so continuing");
        }
      }
    }
    catch (Exception e) {
    }

    if (trace > API_TRACE_NONE) {
      Log.current.println("Connection closed for " + connectionInfo());
    }
  }

  /**
   * Return the name of the host to which the CycConnection is established.
   * 
   * @@return the name of the Host to which this <tt>CycConnection</tt> is connected.
   */
  public String getHostName() {
    return this.hostName;
  }

  /**
   * Return the base port to which the CycConnection is established.
   * 
   * @@return the port to which this <tt>CycConnection</tt> is connected.
   */
  public int getBasePort() {
    return this.basePort;
  }

  /**
   * Return the CFASL port to which the CycConnection is established.
   * 
   * @@return the CFASL port to which this <tt>CycConnection</tt> is connected.
   */
  public int getCfaslPort() {
    return this.cfaslPort;
  }

  /**
   * Send a message to Cyc and return the <tt>Boolean</tt> true as the first element of an object
   * array, and the cyc response Symbolic Expression as the second element.  If an error occurs
   * the first element is <tt>Boolean</tt> false and the second element is the error message
   * string.
   * 
   * @@param message the api command
   * 
   * @@return an array of two objects, the first is an response status object either a Boolean
   *         (binary mode) or Integer (ascii mode), and the second is the response object or error
   *         string.
   * 
   * @@throws IOException when a commuications error occurs
   * @@throws CycApiException when a Cyc API error occurs
   */
  public Object[] converse(Object message)
                    throws IOException, CycApiException {
    return converse(message, 
                    notimeout);
  }

  /**
   * Send a message to Cyc and return the response code as the first element of an object array,
   * and the cyc response Symbolic Expression as the second element, spending no less time than
   * the specified timer allows but throwing a <code>TimeOutException</code> at the first
   * opportunity where that time limit is exceeded. If an error occurs the second element is the
   * error message string.
   * 
   * @@param message the api command which must be a String or a CycList
   * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
   * 
   * @@return an array of two objects, the first is a Boolean response status object, and the second
   *         is the response object or error string.
   * 
   * @@throws IOException when a communications error occurs
   * @@throws TimeOutException when the time limit is exceeded
   * @@throws CycApiException when a Cyc api error occurs
   * @@throws RuntimeException if CycAccess is not present
   */
  public Object[] converse(Object message, 
                           Timer timeout)
                    throws IOException, TimeOutException, CycApiException {
    CycList messageCycList;
    if (message instanceof CycList) {
      messageCycList = (CycList) message;
    }
    else if (message instanceof String) {
      if (cycAccess == null) {
        throw new RuntimeException("CycAccess is required to process commands in string form");
      }
      messageCycList = cycAccess.makeCycList((String) message);
    }
    else {
      throw new CycApiException("Invalid class for message " + message);
    }
    messageCycList = substituteForBackquote(messageCycList, 
                                            timeout);
    return converseBinary(messageCycList, timeout);
  }

  /**
   * Substitute a READ-FROM-STRING expression for expressions directly containing a backquote
   * symbol.  This transformation is only required for the binary api, which does not parse the
   * backquoted expression.
   * 
   * @@param messageCycList the given expression
   * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
   * 
   * @@return the expression with a READ-FROM-STRING expression substituted for expressions directly
   *         containing a backquote symbol
   * 
   * @@throws IOException when a communication error occurs
   * @@throws CycApiException when a Cyc api error occurs
   */
  protected CycList substituteForBackquote(CycList messageCycList, 
                                           Timer timeout)
                                    throws IOException, CycApiException {
    if (messageCycList.treeContains(CycObjectFactory.backquote)) {
      CycList substituteCycList = new CycList();
      substituteCycList.add(CycObjectFactory.makeCycSymbol(
                                  "read-from-string"));
      String tempString = messageCycList.cyclify();
      tempString = tempString.replaceAll("\\|\\,\\|", ",");
      substituteCycList.add(tempString);
      Object[] response = converseBinary(substituteCycList, 
                                         timeout);
      if ((response[0].equals(Boolean.TRUE)) && (response[1] instanceof CycList)) {
        CycList backquoteExpression = (CycList) response[1];
        return backquoteExpression.subst(CycObjectFactory.makeCycSymbol(
                                               "api-bq-list"), 
                                         CycObjectFactory.makeCycSymbol(
                                               "bq-list"));
      }
      throw new CycApiException("Invalid backquote substitution in " + messageCycList + 
                                "\nstatus" + response[0] + "\nmessage " + response[1]);
    }
    return messageCycList;
  }
  
  private class WaitingWorkerInfo {

    final SubLWorker worker;
    final boolean isReturnWholeTaskProcessorResponse;
    final CycList taskProcessorRequest;
    
    WaitingWorkerInfo(final SubLWorker worker, final CycList taskProcessorRequest, final boolean isReturnWholeTaskProcessorResponse) {
      this.worker = worker;
      this.taskProcessorRequest = taskProcessorRequest;
      this.isReturnWholeTaskProcessorResponse = isReturnWholeTaskProcessorResponse;
    }
    
    SubLWorker getWorker() {
      return worker;
    }
    
    CycObject getMessage() {
      return (CycObject)taskProcessorRequest.get(1);
    }
    
  }
  
  /**
   * Send a message to Cyc and return the response code as the first element of an object array,
   * and the cyc response Symbolic Expression as the second element, spending no less time than
   * the specified timer allows but throwing a <code>TimeOutException</code> at the first
   * opportunity where that time limit is exceeded. If an error occurs the second element is the
   * error message string. The concurrent mode of Cyc server communication is supported by Cyc's
   * pool of transaction processor threads, each of which can concurrently process an api request.
   * 
   * @@param message the api command
   * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
   * 
   * @@return an array of two objects, the first is an Boolean response code, and the second is the
   *         response object or error string.
   * 
   * @@throws IOException when a communication error occurs
   * @@throws TimeOutException when the time limit is exceeded
   * @@throws CycApiException when a Cyc api error occurs
   */
  public Object[] converseBinary(CycList message, Timer timeout) throws IOException, TimeOutException, CycApiException {
    DefaultSubLWorkerSynch worker = new DefaultSubLWorkerSynch(message, cycAccess, 
      timeout.getAllotedMSecs());
    Object[] result = new Object[2];
    try {
      result[1] = worker.getWork();
    } catch (IOException xcpt) {
      throw xcpt;
    } catch (TimeOutException xcpt) {
      throw xcpt;      
    } catch (CycApiServerSideException xcpt) {
      // @@note: this implements a legacy API of converseBinary()
      result[0] = Boolean.FALSE;
      result[1] = xcpt.getMessage();
      return result;
    } catch (CycApiException xcpt) {
      throw xcpt;
    } catch (RuntimeException re) {
      throw re;
    } catch (Exception xcpt) {
      throw new RuntimeException(xcpt);
    }
    result[0] = worker.getStatus() == SubLWorkerStatus.FINISHED_STATUS ? Boolean.TRUE : Boolean.FALSE;
    return result;
  }
  
  public void cancelCommunication(SubLWorker worker) throws java.io.IOException {
    Integer id = worker.getId();
    if (id.intValue() < 0) {
      //@@note serial communications cannot be canceled right now
      return;
    }
    String command = "(fif (" + "terminate-active-task-process"
        + " " + worker.getId() + " \"" + uuid + "\" " + ":cancel" + 
        ") '(ignore) '(ignore))";
    sendBinary(cycAccess.makeCycList(command));
    // the SubL implementation of CANCEL will send a CANCEL event back,
    // which will cleanup the waiting thread info and signal the termination 
    // event, so no need to perform event signaling and cleanup
  }
  
  
  public void abortCommunication(SubLWorker worker) throws java.io.IOException {
    Integer id = worker.getId();
    if (id.intValue() < 0) {
      //@@note serial communications cannot be canceled right now
      return;
    }
    try {
      String command = "(fif (" + "terminate-active-task-process"
        + " " + worker.getId() + " \"" + uuid + "\" " + ":abort" + 
        ") '(ignore) '(ignore))";
      sendBinary(cycAccess.makeCycList(command));
    } finally {
    // the SubL implementation of ABORT will not send anything back,
    // so we do need to perform event signaling and cleanup
      worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
        SubLWorkerStatus.ABORTED_STATUS, null));
      waitingReplyThreads.remove(id);
    }
  }
  
  private boolean inAWTEventThread() {
    try {
      return javax.swing.SwingUtilities.isEventDispatchThread();
    } catch (Throwable e) { return false; }
  }

  /**
   * Send a message to Cyc spending no less time than the specified timer allows but throwing a <code>TimeOutException</code> 
   * at the first opportunity where that time limit is exceeded. The concurrent mode of Cyc server communication 
   * is supported by Cyc's pool of transaction processor threads, each of which can concurrently process an api request.  The
   * SubLWorker object notifies the caller when the api response is aschronously received.
   * 
   * @@param worker a <tt>SubLWorker</tt> object that notifies the caller when work is done
   * 
   * @@throws IOException when a communication error occurs
   * @@throws TimeOutException when the time limit is exceeded
   * @@throws CycApiException when a Cyc api error occurs
   */
  public void converseBinary(final SubLWorker worker)
  throws IOException, TimeOutException, CycApiException {
    logger.finest("API request: " + worker.toString());
    if (cycAccess.isClosed()) {
      throw new CycApiException("Attempt to communicate to Cyc using a closed connection.");
    }
    /*if ((!worker.shouldIgnoreInvalidLeases()) && (!cycAccess.hasValidLease())) {
      throw new CycApiException("Attempt to communicate to Cyc using a connection with an invalid lease." +
                                "\nSubLCommand: " + worker.getSubLCommand().toPrettyCyclifiedString(""));
    }*/
    //System.out.println("worker: " + worker);
    if ((worker instanceof SubLWorkerSynch) && inAWTEventThread()) {
      throw new CycApiException("Invalid attempt to synchronously communicate with Cyc " + 
      "from the AWT event thread.\n\n" + worker);
    }
    CycSymbol taskProcessorRequestSymbol = CycObjectFactory.
      makeCycSymbol("task-processor-request");
    Integer id = null;
    CycList taskProcessorRequest = null;
    boolean isReturnWholeTaskProcessorResponse = false;
    CycList subLCommand = worker.getSubLCommand();
    final Integer priority = worker.getPriority();
    if (subLCommand.first().equals(CycObjectFactory.makeCycSymbol("return-whole-task-processor-response"))) {
      isReturnWholeTaskProcessorResponse = true;
      subLCommand = (CycList)subLCommand.second();
    }
    if (subLCommand.first().equals(taskProcessorRequestSymbol)) {
      // client has supplied the task-processor-request form
      taskProcessorRequest = subLCommand;
      id = (Integer)subLCommand.third();
      taskProcessorRequest.set(6, uuid.toString());  // override the uuid to identify this client
    } else {
      id = nextApiRequestId();
      taskProcessorRequest = new CycList();
      taskProcessorRequest.add(taskProcessorRequestSymbol); // function
      taskProcessorRequest.add(subLCommand); // request
      taskProcessorRequest.add(id); // id
      taskProcessorRequest.add( clampPriority(priority)); // priority
      taskProcessorRequest.add(myClientName); // requestor
      taskProcessorRequest.add(CycObjectFactory.nil); // client-bindings
      taskProcessorRequest.add(uuid.toString()); // uuid to identify this client
    }
    final CycList actualRequest = (CycList) taskProcessorRequest.get(1);
    if (actualRequest.toString().startsWith("(FIF (TERMINATE-ACTIVE-TASK-PROCESS ")) {
      // override the uuid used to identify this client
      // (fif (terminate-active-task-process id uuid :cancel) (quote (ignore)) (quote (ignore)))
      final CycList temp = (CycList) actualRequest.second();
      temp.set(2, uuid.toString());
    }
    logger.finest("taskProcessorRequest: " + taskProcessorRequest.toPrettyCyclifiedString(""));
    WaitingWorkerInfo waitingWorkerInfo = new WaitingWorkerInfo(worker, taskProcessorRequest, isReturnWholeTaskProcessorResponse);
    // tell everyone this is getting started
    waitingReplyThreads.put(id, waitingWorkerInfo);
    SubLWorkerEvent event = new SubLWorkerEvent(worker, id); 
    worker.fireSubLWorkerStartedEvent(event);
    //start communication
    sendBinary(taskProcessorRequest);
  }
  
  static public Integer clampPriority( Integer priority) {
    if (priority.intValue() > MAX_PRIORITY.intValue()) {
      priority = MAX_PRIORITY;
    } else if (priority.intValue() < MIN_PRIORITY.intValue()) {
      priority = MIN_PRIORITY;
    }
    return priority;
  }

  /**
   * Returns the next apiRequestId.
   * 
   * @@return the next apiRequestId
   */
  static public synchronized Integer nextApiRequestId() {
    return new Integer(++apiRequestId);
  }

  /**
   * Sends an object to the CYC server.  If the connection is not already open, it is opened.  The
   * object must be a valid CFASL-translatable: an Integer, Float, Double, Boolean, String, or cyc
   * object.
   * 
   * @@param message the api command
   * 
   * @@throws IOException when a communication error occurs
   */
  public synchronized void sendBinary(Object message)
                               throws IOException {
    logger.finest("sendBinary: " + message.toString());
    cfaslOutputStream.writeObject(message);
    cfaslOutputStream.flush();
  }

  /**
   * Receives an object from the CYC server.
   * 
   * @@return an array of three objects, the first is a Boolean response, the second is the
   *         response object or error string, and the third is an indication that the otherwise
   *         good response contains an invalid object.
   * 
   * @@throws IOException when a communications error occurs
   * @@throws CycApiException when a Cyc API error occurs
   */
  public synchronized Object[] receiveBinary()
                                      throws IOException, CycApiException {
    cfaslInputStream.resetIsInvalidObject();
    final Object status = cfaslInputStream.readObject();
    cfaslInputStream.resetIsInvalidObject();
    final Object response = cfaslInputStream.readObject();
    final Object[] answer = { null, null, null };
    answer[1] = response;
    // TODO handle the invalid object in the callers of this seldom-used method. 
    answer[2] = new Boolean(cfaslInputStream.isInvalidObject());
    if ((status == null) || status.equals(CycObjectFactory.nil)) {
      answer[0] = Boolean.FALSE;

      if (trace > API_TRACE_NONE) {
        final String responseString = response.toString();
        Log.current.println("received error = (" + status + ") " + responseString);
      }
      return answer;
    }
    answer[0] = Boolean.TRUE;
    return answer;
  }

  /**
   * Receives a binary (cfasl) api request from a cyc server.  Unlike the api response handled by
   * the receiveBinary method, this method does not expect an input status object.
   * 
   * @@return the api request expression.
   * 
   * @@throws IOException when a communication error occurs
   * @@throws CycApiException when a Cyc API exception occurs
   */
  public CycList receiveBinaryApiRequest()
                                  throws IOException, CycApiException {
    cfaslInputStream.resetIsInvalidObject();
    CycList apiRequest = (CycList) cfaslInputStream.readObject();
    return apiRequest;
  }

  /**
   * Sends a binary (cfasl) api response to a cyc server.  This method prepends a status object
   * (the symbol T) to the message.
   * 
   * @@param message the given binary api response
   * 
   * @@throws IOException when a communication error occurs
   * @@throws CycApiException when a Cyc API error occurs
   */
  public void sendBinaryApiResponse(Object message)
                             throws IOException, CycApiException {
    CycList apiResponse = new CycList();
    apiResponse.add(CycObjectFactory.t);
    apiResponse.add(message);
    cfaslOutputStream.writeObject(apiResponse);
  }

  /**
   * Turns on the diagnostic trace of socket messages.
   */
  public void traceOn() {
    trace = API_TRACE_MESSAGES;
    cfaslInputStream.trace = trace;
    cfaslOutputStream.trace = trace;
  }

  /**
   * Turns on the detailed diagnostic trace of socket messages.
   */
  public void traceOnDetailed() {
    setTrace(API_TRACE_DETAILED);
  }

  /**
   * Turns off the diagnostic trace of socket messages.
   */
  public void traceOff() {
    setTrace(API_TRACE_NONE);
  }

  /**
   * Returns the trace value.
   * 
   * @@return the trace value
   */
  public int getTrace() {
    return trace;
  }

  /**
   * Sets the socket messages diagnostic trace value.
   * 
   * @@param trace the new socket messages diagnostic trace value
   */
  public void setTrace(int trace) {
    this.trace = trace;
    cfaslInputStream.trace = trace;
    cfaslOutputStream.trace = trace;
    if (taskProcessorBinaryResponseHandler != null)
      taskProcessorBinaryResponseHandler.inboundStream.trace = trace;
  }

  /** Answers true iff this is a valid binary (cfasl) connection to Cyc.
   * 
   * @@return true iff this is a valid binary (cfasl) connection to Cyc
   */
  public boolean isValidBinaryConnection() {
    return isValidBinaryConnection(false);
  }

  /** Answers true iff this is a valid binary (cfasl) connection to Cyc.
   * 
   * @@param isQuiet the indicator for no informational logging
   * @@return true iff this is a valid binary (cfasl) connection to Cyc
   */
  public boolean isValidBinaryConnection(final boolean isQuiet) {
    if (cfaslSocket == null) {
      if (! isQuiet)
        Log.current.println("Invalid binary connection because cfaslSocket is null");
      return false;
    }

    if (! cfaslSocket.isConnected()) {
      if (! isQuiet)
        Log.current.println("Invalid binary connection because cfaslSocket is not connected");
      return false;
    }
    if ((taskProcessorBinaryResponseHandler == null) || 
            (taskProcessorBinaryResponseHandler.inboundSocket == null)) {
      if (! isQuiet)
        Log.current.println("Invalid binary connection because taskProcessorBinaryResponseHandler.inboundSocket is null");
      return false;
    }
    if (! taskProcessorBinaryResponseHandler.inboundSocket.isConnected()) {
      if (! isQuiet)
        Log.current.println("Invalid binary connection because taskProcessorBinaryResponseHandler.inboundSocket is not connected");
      return false;
    }
    return true;
  }

  /**
   * Returns connection information, suitable for diagnostics.
   * 
   * @@return connection information, suitable for diagnostics
   */
  public String connectionInfo() {
    return "host " + hostName + ", cfaslPort " + cfaslPort;
  }

  /**
   * Gets the UUID that identifies this java api client connection.
   * 
   * @@return the UUID that identifies this java api client connection
   */
  public UUID getUuid() {
    return uuid;
  }

  /**
   * Sets the client name of this api connection.
   * 
   * @@param myClientName the client name of this api connection
   */
  public void setMyClientName(String myClientName) {
    this.myClientName = myClientName;
  }

  /**
   * Gets the client name of this api connection.
   * 
   * @@return the client name of this api connection
   */
  public String getMyClientname() {
    return myClientName;
  }

  /**
   * Recovers from a socket error by interrupting all the waiting reply threads.  Each awakened
   * thread will detect the error condition and throw an IOExecption.
   */
  protected void interruptAllWaitingReplyThreads() {
    Iterator iter = waitingReplyThreads.values().iterator();

    while (iter.hasNext()) {
      WaitingWorkerInfo waitingWorkerInfo = (WaitingWorkerInfo) iter.next();
      if (trace > API_TRACE_NONE) {
        Log.current.println("Interrupting reply worker " + waitingWorkerInfo.getWorker());
      }
      try {
        waitingWorkerInfo.worker.cancel();
      } catch (java.io.IOException xcpt) {
        if (trace > API_TRACE_NONE) {
          Log.current.println("Could not interrupt reply worker " + waitingWorkerInfo.getWorker()
            + ": exception: " + xcpt);
      }
      }
    }
  }

  /**
   * Gets the dictionary of waiting reply thread information objects.
   * 
   * @@return the dictionary of waiting reply thread information objects
   */
  public Hashtable getWaitingReplyThreadInfos() {
    return waitingReplyThreads;
  }

  /**
   * Resets the Cyc task processor which is currently processing the api-request specified by the
   * given id.  If none of the task processors is currently processessing the specified
   * api-request, then the reset request is ignored.  When reset, the Cyc task processor returns
   * an error message to the waiting client thread.  The error message consists of
   * "reset\nTHE-API-REQUEST".
   * 
   * @@param id the id of the api-request which is to be interrupted and cancelled
   * 
   * @@throws CycApiException when a Cyc API error occurs
   * @@throws IOException when a communication error occurs
   */
  public void resetTaskProcessorById(Integer id)
                              throws CycApiException, IOException {
    resetTaskProcessorById(id.intValue());
  }

  /**
   * Resets the Cyc task processor which is currently processing the api-request specified by the
   * given id.  If none of the task processors is currently processessing the specified
   * api-request, then the reset request is ignored.  When reset, the Cyc task processor returns
   * an error message to the waiting client thread.
   * 
   * @@param id the id of the api-request which is to be interrupted and cancelled
   * 
   * @@throws CycApiException when a Cyc API error occurs
   * @@throws IOException when a communications error occurs
   */
  public void resetTaskProcessorById(int id)
                              throws CycApiException, IOException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("reset-api-task-processor-by-id"));
    command.add(myClientName);
    command.add(new Integer(id));
    cycAccess.converseCycObject(command);
  }

  /**
   * Class TaskProcessorBinaryResponseHandler handles responses from task-processor requests in
   * binary communication mode.
   */
  protected class TaskProcessorBinaryResponseHandler extends Thread {
    
    /** Maximum number of local cyc clients supported by this listener. */
    public static final int MAX_LOCAL_CLIENT_CLIENTS = 50;

    /** The socket which listens for new connections. */
    protected ServerSocket listenerSocket = null;

    /** The socket which receives asychronous inbound messages from the Cyc server. */
    protected Socket inboundSocket = null;

    /** The binary interface input stream which receives asychronous messages from the Cyc server */
    public CfaslInputStream inboundStream;

    /** 
     * The binary interface output stream, which is the output side of the bidirectional socket, is
     * used only to start up and close down the socket.
     */
    protected CfaslOutputStream inboundOutputStream;
    
    /** Reference to the parent thread which will sleep until this handler is initialized. */
    protected Thread parentThread;

    /** The (ignore) message from the Cyc server to test if the connection is alive. */
    protected CycList ignoreMessage;

    /** the parent CycConnection */
    protected CycConnection cycConnection;
    
    /** the synchronization object to ensure that the streams are ready */
    private Object lockObject;
    private boolean initialized;
    
    /** the indices into the task processor response object, which is a list */
    final static int TASK_PROCESSOR_RESPONSE_ID = 2;
    final static int TASK_PROCESSOR_RESPONSE_RESPONSE = 5;
    final static int TASK_PROCESSOR_RESPONSE_STATUS = 6;
    final static int TASK_PROCESSOR_RESPONSE_FINISHED_FLAG = 7;
          
    /**
     * Constructs a TaskProcessorBinaryResponseHandler object.
     * 
     * @@param parentThread the parent thread of this thread
     * @@param cycConnection the parent CycConnection
     */
    public TaskProcessorBinaryResponseHandler(Thread parentThread, CycConnection cycConnection) {
      this.parentThread = parentThread;
      this.cycConnection = cycConnection;
      ignoreMessage = new CycList();
      ignoreMessage.add(new CycSymbol("IGNORE"));
    }
    
    public void start() {
      initializeSynchronization();
      super.start();
      waitOnSetupToComplete();
    }

    /**
     * Opens the response socket with Cyc, blocks until the next task-processor response is available, 
     * then awakens the client thread that made the request.
     */
    public void run() {
      Thread.currentThread().setName("TaskProcessorBinaryResponseHandler");
      try {
        // Open a second api socket connection and use it for asychronous api responses.
        inboundSocket = new Socket(hostName, cfaslPort);
        int val = inboundSocket.getReceiveBufferSize();
        inboundSocket.setReceiveBufferSize(val * 2);
        inboundSocket.setTcpNoDelay(true);
        inboundSocket.setKeepAlive(true);
        inboundStream = new CfaslInputStream(inboundSocket.getInputStream());
        inboundStream.trace = trace;
        inboundOutputStream = new CfaslOutputStream(inboundSocket.getOutputStream());
        // send a one-time request the to Cyc server to configure this connection for subsequent api reponses
        CycList request = new CycList();
        request.add(new CycSymbol("INITIALIZE-JAVA-API-PASSIVE-SOCKET"));
        request.add(cycConnection.uuid.toString());
        inboundOutputStream.writeObject(request);
        inboundOutputStream.flush();
        // read and ignore the status
        inboundStream.resetIsInvalidObject();
        inboundStream.readObject();
        // read and ignore the response 
        inboundStream.resetIsInvalidObject();
        inboundStream.readObject();
        inboundStream.trace = cycConnection.getTrace();
      }
      catch (IOException e) {
        Log.current.printStackTrace(e);
        System.exit(1);
      }
      // signal that we are ready to go
      notifySetupCompleted();
      // Handle messsages received on the asychronous inbound Cyc connection.
      while (true) {
        Object status = null;
        CycList taskProcessorResponse = null;
        boolean isInvalidObject = false;
        
        try {
          // read status
          inboundStream.resetIsInvalidObject();
          status = inboundStream.readObject();
          // read task processor response 
          inboundStream.resetIsInvalidObject();
          taskProcessorResponse = (CycList) inboundStream.readObject();
          logger.finest("API response: " + taskProcessorResponse.toString());
          isInvalidObject = inboundStream.isInvalidObject();
        }
        catch (Exception e) {
          logger.fine("Exception: " + e.getMessage());
          if (taskProcessingEnded) {
            if (trace > API_TRACE_NONE) {
              Log.current.println("Ending binary mode task processor handler.");
            }
          }
          
          if (e instanceof CfaslInputStreamClosedException) {
            if (trace > API_TRACE_NONE) {
              Log.current.errorPrintln(e.getMessage());
              //Log.current.printStackTrace(e);
            }
          }
          else if (e instanceof RuntimeException) {
            Log.current.errorPrintln(e.getMessage());
            Log.current.printStackTrace(e);
            continue;
          }
          else if (trace > API_TRACE_NONE) {
            Log.current.println("Cyc Server ended binary mode task processor handler.");
          }
          
          taskProcessingThreadDead = true;
          
          return;
        }
        
        logger.finest("API status: " + status);
        if (trace == API_TRACE_DETAILED) {
          String responseString = null;
          Log.current.println("cyc --> (" + status + ") " + taskProcessorResponse.toString());
        }
        
        if (taskProcessorResponse.equals(ignoreMessage)) {
          continue;
        }
        
        try {
          Integer id = (Integer) taskProcessorResponse.get(TASK_PROCESSOR_RESPONSE_ID);
          Object response = taskProcessorResponse.get(TASK_PROCESSOR_RESPONSE_RESPONSE);
          Object taskStatus = taskProcessorResponse.get(TASK_PROCESSOR_RESPONSE_STATUS);
          // handle Cyc images that either support or do not support (legacy) the finished flag
          Object finishedFlag = 
            (taskProcessorResponse.size() > TASK_PROCESSOR_RESPONSE_FINISHED_FLAG) ? 
            taskProcessorResponse.get(TASK_PROCESSOR_RESPONSE_FINISHED_FLAG) : 
            CycObjectFactory.t;

          boolean finished = !(finishedFlag == CycObjectFactory.nil);
          
          final WaitingWorkerInfo waitingWorkerInfo = (WaitingWorkerInfo) waitingReplyThreads.get(id);
          if (waitingWorkerInfo == null) {
            continue;
          }
          SubLWorker worker = waitingWorkerInfo.getWorker();
          if (waitingWorkerInfo.isReturnWholeTaskProcessorResponse)
            // used for example in the XML soap service where there is an upstream SOAPBinaryCycConnection object that 
            // needs the whose task processor response.
            response = taskProcessorResponse;

          if (taskStatus == CycObjectFactory.nil) {
            if (! isInvalidObject) {
              // no error occurred, no exception
              worker.fireSubLWorkerDataAvailableEvent(new SubLWorkerEvent(worker, response, -1.0f));
              if (finished) {
                //System.out.println("Exiting normally");
                worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
                SubLWorkerStatus.FINISHED_STATUS, null));
              }
            }
            else {    
              // no API error sent from the server but the response contains an invalid object
              worker.fireSubLWorkerTerminatedEvent(
                new SubLWorkerEvent(worker,
                                    SubLWorkerStatus.EXCEPTION_STATUS,
                                    new CycApiServerSideException("API response contains an invalid object: " + response.toString())));              
            }
          } else {
            // Error, status contains the error message
            
            //@@ToDo need to diferrentiate between exceptions and cancel messages!!!!!!!!!
            finished = true;
            if (taskStatus instanceof String) {
              worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
                SubLWorkerStatus.EXCEPTION_STATUS,
                new CycApiServerSideException(taskStatus.toString())));
            } else if (taskStatus instanceof CycSymbol) {
              worker.fireSubLWorkerTerminatedEvent(new SubLWorkerEvent(worker,
                SubLWorkerStatus.CANCELED_STATUS, null));
            }
          }
          
          if (worker.isDone()) {
            waitingReplyThreads.remove(id);
          }
        } catch (Exception xcpt) {
          Log.current.errorPrintln(xcpt.getMessage());
          Log.current.printStackTrace(xcpt);
          continue;
        }
      } // while-forever 
    }
    
    /** Closes the passive inbound api response socket. */
    public void close () throws IOException {
      inboundOutputStream.close();
      if (trace > API_TRACE_NONE)
        Log.current.println("closed inbound socket associated with " + uuid);
    }
    
    private void waitOnSetupToComplete() {
      // avoid blocking on this ptr, which would stop the
      // notifySetupCompleted method from working correctly
      synchronized (lockObject) {
        boolean isInitialized = false;
        synchronized (this) {
          isInitialized = this.initialized;
        }
        while (!isInitialized) {
          try {
            lockObject.wait();
          } catch (InterruptedException xcpt) {
            System.err.println( "Interrupted during wait(): "
            + xcpt);
          }
          synchronized (this) {
            isInitialized = this.initialized;
          }
        }
      }
    }
    
    private void initializeSynchronization() {
      synchronized (this) {
        initialized = false;
        lockObject = new String("Lock object");
      }
    }
    
    private void notifySetupCompleted() {
      synchronized (this) {
       initialized = true;
      }
      synchronized (lockObject) {
       lockObject.notify(); 
      }
    }
  }
  
  /** Provides a timer thread for cancelling the connection if it takes too long to establish. */
  private class ConnectionTimer extends Thread {
    
    /** Constucts a new ConnectionTimer instance. */
    ConnectionTimer() {
    }
    
    /** Waits for either the CycConnection constructor thread to set the done indicator, or kills the
     * connection after the timeout is exceeded. */
    public void run() {
      try {
        while (! isCycConnectionEstablished) {
          Thread.sleep(WAIT_TIME_INCREMENT);
          timerMillis = timerMillis + WAIT_TIME_INCREMENT;
          if (timerMillis > TIMEOUT_MILLIS)
            throw new InterruptedException();
        }
      }
      catch (InterruptedException e) {
        Log.current.println("Timeout while awaiting Cyc connection establishment, closing sockets");
        // close the socket connections to Cyc and kill any awaiting api request threads
        if (trace == CycConnection.API_TRACE_NONE)
          trace = CycConnection.API_TRACE_MESSAGES;
        close();
      }
    }
    /** the timeout duration in milliseconds (one minute) */
    final long TIMEOUT_MILLIS = 60000;
    
    /** the wait time increment */
    final long WAIT_TIME_INCREMENT = 1000;
    
    /** the wait time so far in milliseconds */
    long timerMillis = 0;
    
    /** set by the CycConnection constructor process to indicate that the connection to Cyc is established */
    volatile boolean isCycConnectionEstablished = false;
    
  }
  
@


1.47
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@@


1.46
log
@Fixing bugs in the constraint solver.
@
text
@d1 1
a1 1
package  org.opencyc.api;
d3 24
a26 8
import  java.net.*;
import  java.io.*;
import  java.util.Hashtable;
import  java.util.Iterator;
import  ViolinStrings.*;
import  org.doomdark.uuid.*;
import  org.opencyc.util.*;
import  org.opencyc.cycobject.*;
d29 4
a32 3
 * Provides a binary connection and an ascii connection to the OpenCyc server.  The ascii connection is
 * legacy and its use is deprecated.<p>
 *
d34 8
a41 26
 * specified as null in the CycConnection constructors when the binary api is used.
 *
 * Concurrent api requests are supported for binary (cfasl) mode. This is implemented by two
 * socket connections, the first being for asynchronous api requests sent to Cyc, and the
 * second for the asychronous api responses received from Cyc.
 *
 * @@version $Id: CycConnection.java,v 1.45 2002/10/04 21:12:46 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d44 2
d47 1
a47 233
    /**
     * Default host name for the OpenCyc server.
     */
    public static String DEFAULT_HOSTNAME = "localhost";
    //public static String DEFAULT_HOSTNAME = "MCCARTHY";

    /**
     * Default base tcp port for the OpenCyc server.
     */
    public static final int DEFAULT_BASE_PORT = 3600;
    //public static final int DEFAULT_BASE_PORT = 4600;

    /**
     * HTTP port offset for the OpenCyc server.
     */
    public static final int HTTP_PORT_OFFSET = 0;

    /**
     * ASCII port offset for the OpenCyc server.
     */
    public static final int ASCII_PORT_OFFSET = 1;

    /**
     * CFASL (binary) port offset for the OpenCyc server.
     */
    public static final int CFASL_PORT_OFFSET = 14;

    /**
     * No api trace.
     */
    public static final int API_TRACE_NONE = 0;

    /**
     * Message-level api trace.
     */
    public static final int API_TRACE_MESSAGES = 1;

    /**
     * Detailed api trace.
     */
    public static final int API_TRACE_DETAILED = 2;

    /**
     * Parameter that, when true, causes a trace of the messages to and from the server.
     */
    protected int trace = API_TRACE_NONE;
    //protected int trace = API_TRACE_MESSAGES;

    /**
     * Ascii mode connnection to the OpenCyc server.
     */
    public static final int ASCII_MODE = 1;

    /**
     * CFASL (binary) mode connnection to the OpenCyc server.
     */
    public static final int BINARY_MODE = 2;

    /**
     * Default communication mode connnection to the OpenCyc server.
     */
    public static final int DEFAULT_COMMUNICATION_MODE = BINARY_MODE;

    /**
     * Indicator for whether to use the binary or acsii connection with OpenCyc.
     */
    protected int communicationMode = 0;

    /**
     * Serial messaging mode to the OpenCyc server.
     */
    public static final int SERIAL_MESSAGING_MODE = 1;

    /**
     * Concurrent messaging mode to the OpenCyc server.
     */
    public static final int CONCURRENT_MESSAGING_MODE = 2;

    /**
     * Default messaging mode to the OpenCyc server.
     */
    public static final int DEFAULT_MESSAGING_MODE = SERIAL_MESSAGING_MODE;

    /**
     * Messaging mode to the OpenCyc server.
     */
    public int messagingMode = DEFAULT_MESSAGING_MODE;

    /**
     * The ascii interface input stream.
     */
    protected BufferedReader in;

    /**
     * The ascii interface output stream.
     */
    protected BufferedWriter out;

    /**
     * The binary interface input stream</tt>.
     */
    protected CfaslInputStream cfaslInputStream;

    /**
     * The binary interface output stream</tt>.
     */
    protected CfaslOutputStream cfaslOutputStream;

    /**
     * The name of the computer hosting the OpenCyc server.
     */
    protected String hostName;

    /**
     * The tcp port from which the asciiPort and cfaslPorts are derived.
     */
    protected int basePort;

    /**
     * The tcp port assigned to the ascii connection to the OpenCyc server.
     */
    protected int asciiPort;

    /**
     * The tcp port assigned to the binary connection to the OpenCyc server.
     */
    protected int cfaslPort;

    /**
     * The tcp socket assigned to the ascii connection to the OpenCyc server.
     */
    protected Socket asciiSocket;

    /**
     * The tcp socket assigned to the binary connection to the OpenCyc server.
     *
     */
    protected Socket cfaslSocket;

    /**
     * The timer which optionally monitors the duration of requests to the OpenCyc server.
     */
    protected static final Timer notimeout = new Timer();

    /**
     * Indicates if the response from the OpenCyc server is a symbolic expression (enclosed in
     * parentheses).
     */
    protected boolean isSymbolicExpression = false;

    /**
     * A reference to the parent CycAccess object for dereferencing constants in ascii symbolic expressions.
     */
    protected CycAccess cycAccess;

    /**
     * An indicator for ascii communications mode that strings should retain their quote delimiters.
     */
    protected boolean quotedStrings;

    /**
     * outbound request serial id
     */
    public int apiRequestId = 0;

    /**
     * The default priority of a task-processor request.
     */
    protected static final int DEFAULT_PRIORITY = 3;

    /**
     * name of my api client
     */
    protected String myClientName = "api client";

    /**
     * Implements an association:  apiRequestId --> waiting thread for the response.
     * Used when submitting concurrent requests to the task-processor.
     */
    protected Hashtable waitingReplyThreads = new Hashtable();

    /**
     * Implements an association:  apiRequestId --> response message.
     * Used when submitting concurrent requests to the task-processor.
     */
    protected Hashtable responseMessages = new Hashtable();

    /**
     * handles responses from task-processor requests in binary communication mode.
     */
    protected TaskProcessorBinaryResponseHandler taskProcessorBinaryResponseHandler;

    /**
     * Indicates to the taskProcessor response handlers that the server connection
     * is closed.
     */
    protected boolean taskProcessingEnded = false;

    /**
     * Universally Unique ID that identifies this CycConnection to the Cyc server. It
     * is used when establishing the (second) asychronous socket connection.
     */
    protected UUID uuid;

    /**
     * Constructs a new CycConnection using the given socket obtained from the parent AgentManager
     * listener.
     *
     * @@param cfaslSocket tcp socket which forms the binary connection to the OpenCyc server
     */
    public CycConnection (Socket cfaslSocket) throws IOException {
        this.cfaslSocket = cfaslSocket;
        hostName = cfaslSocket.getInetAddress().getHostName();
        basePort = cfaslSocket.getPort() - CFASL_PORT_OFFSET;
        asciiPort = basePort + ASCII_PORT_OFFSET;
        communicationMode = BINARY_MODE;
        cycAccess = null;
        cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream());
        cfaslInputStream.trace = trace;
        cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream());
        cfaslOutputStream.trace = trace;
    }

    /**
     * Constructs a new CycConnection object using the default host name, default base port number
     * and binary communication mode.  When CycAccess is null as in this case, diagnostic output is
     * reduced.
     */
    public CycConnection ()
        throws IOException, UnknownHostException, CycApiException {
        this(DEFAULT_HOSTNAME,
             DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE, null);
    }
d49 2
a50 34
    /**
     * Constructs a new CycConnection object using the default host name, default base port number
     * with binary communication mode, and the given CycAccess object.
     *
     * @@param cycAccess the given CycAccess object which provides api services over
     * this CycConnection object
     */
    public CycConnection (CycAccess cycAccess)
        throws IOException, UnknownHostException, CycApiException {
        this(DEFAULT_HOSTNAME,
             DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE, cycAccess);
    }

    /**
     * Constructs a new CycConnection object using a given host name, the given base port number,
     * the given communication mode, and the given CycAccess object
     *
     * @@param host the name of the computer hosting the OpenCyc server.
     * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     * @@param cycAccess the given CycAccess object which provides api services over
     * this CycConnection object
     */
    public CycConnection (String hostName,
                          int basePort,
                          int communicationMode,
                          CycAccess cycAccess)
        throws IOException, UnknownHostException, CycApiException {
        this (hostName,
              basePort,
              communicationMode,
              CycConnection.DEFAULT_MESSAGING_MODE,
              cycAccess);
    }
d52 246
a297 35
    /**
     * Constructs a new CycConnection object using a given host name, the given base port number,
     * the given communication mode, and the given CycAccess object
     *
     * @@param host the name of the computer hosting the OpenCyc server.
     * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     * @@param messagingMode either SERIAL_MESSAGING_MODE or CONCURRENT_MESSAGING_MODE
     * @@param cycAccess the given CycAccess object which provides api services over
     * this CycConnection object
     */
    public CycConnection (String hostName,
                          int basePort,
                          int communicationMode,
                          int messagingMode,
                          CycAccess cycAccess)
        throws IOException, UnknownHostException, CycApiException {
        this.hostName = hostName;
        this.basePort = basePort;
        asciiPort = basePort + ASCII_PORT_OFFSET;
        cfaslPort = basePort + CFASL_PORT_OFFSET;
        if ((communicationMode != ASCII_MODE)
                && (communicationMode != BINARY_MODE))
            throw  new CycApiException("Invalid communication mode " + communicationMode);
        this.communicationMode = communicationMode;
        if ((messagingMode != SERIAL_MESSAGING_MODE)
                && (messagingMode != CONCURRENT_MESSAGING_MODE))
            throw  new CycApiException("Invalid messaging mode " + messagingMode);
        if ((communicationMode == ASCII_MODE)
                && (messagingMode == CONCURRENT_MESSAGING_MODE))
            this.messagingMode = SERIAL_MESSAGING_MODE;
        else
            this.messagingMode = messagingMode;
        this.cycAccess = cycAccess;
        initializeApiConnections();
d299 1
a299 4
            if (communicationMode == ASCII_MODE)
                Log.current.println("Ascii connection " + asciiSocket);
            else
                Log.current.println("Binary connection " + cfaslSocket);
d301 5
a305 16
        uuid = UUIDGenerator.getInstance().generateTimeBasedUUID();
        if (this.messagingMode == CONCURRENT_MESSAGING_MODE)
            initializeConcurrentProcessing();
    }

    /**
     * Initializes the OpenCyc ascii socket and the OpenCyc binary socket connections.
     */
    private void initializeApiConnections () throws IOException,
        UnknownHostException {
        if (Log.current == null)
            Log.makeLog("cyc-api.log");
        if (communicationMode == ASCII_MODE) {
            asciiSocket = new Socket(hostName, asciiPort);
            in = new BufferedReader(new InputStreamReader(asciiSocket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(asciiSocket.getOutputStream()));
d307 3
a309 6
        else {
            cfaslSocket = new Socket(hostName, cfaslPort);
            cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream());
            cfaslInputStream.trace = trace;
            cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream());
            cfaslOutputStream.trace = trace;
d311 2
a312 21
    }

    /**
     * Initializes the concurrent processing mode.  Use serial messaging mode to
     * ensure the Cyc task processors are initialized, then start this
     * connection's taskProcessor response handler thread.
     */
    protected void initializeConcurrentProcessing ()
        throws IOException, UnknownHostException, CycApiException {
        taskProcessorBinaryResponseHandler =
            new TaskProcessorBinaryResponseHandler(Thread.currentThread());
        taskProcessorBinaryResponseHandler.start();

        // sleep until listening socket is initialized.
        while (true) {
            try {
                Thread.sleep(1000);
            }
            catch (InterruptedException e) {
                break;
            }
d314 2
a315 11
        // Send request to Cyc server to open its outbound socket to
        // our awaiting listener.
        CycList request = new CycList();
        request.add(new CycSymbol("INITIALIZE-JAVA-API-SOCKET"));
        request.add(uuid.toString());
        request.add(InetAddress.getLocalHost().getHostName());
        request.add(new Integer(TaskProcessorBinaryResponseHandler.LOCAL_CLIENT_LISTENER_PORT));
        sendBinary(request);
        // ignore response
        receiveBinary();
    }
d317 2
a318 44
    /**
     * Ensures that the api socket connections are closed when this object is garbage collected.
     */
    protected void finalize() {
        close();
    }

    /**
     * Close the api sockets and streams.
     */
    public void close () {
        if (asciiSocket != null) {
            if (out != null) {
                try {
                    out.write("(API-QUIT)\n");
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error quitting the api connection " + e.getMessage());
                }
                try {
                    out.flush();
                }
                catch (Exception e) {
                }
            }
            if (in != null) {
                try {
                    in.close();
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error finalizing the api connection " + e.getMessage());
                }
            }
            if (asciiSocket != null) {
                try {
                    asciiSocket.close();
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error closing the api connection " + e.getMessage());
                }
            }
d320 3
a322 48
        if (cfaslSocket != null) {
            if (cfaslOutputStream != null) {
                CycList command;
                if (messagingMode == CONCURRENT_MESSAGING_MODE) {
                    command = new CycList();
                    command.add(CycObjectFactory.makeCycSymbol("CLOSE-JAVA-API-SOCKET"));
                    command.add(uuid.toString());
                    try {
                        sendBinary(command);
                        if (cfaslInputStream != null)
                            receiveBinary();
                    }
                    catch (Exception e) {
                    }
                }
                command = new CycList();
                command.add(CycObjectFactory.makeCycSymbol("API-QUIT"));
                try {
                    cfaslOutputStream.writeObject(command);
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error quitting the api connection " + e.getMessage());
                }
                try {
                    cfaslOutputStream.flush();
                }
                catch (Exception e) {
                }
            }
            if (cfaslInputStream != null) {
                try {
                    cfaslInputStream.close();
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error finalizing the api connection " + e.getMessage());
                }
            }
            if (cfaslSocket != null) {
                try {
                    cfaslSocket.close();
                }
                catch (Exception e) {
                    Log.current.printStackTrace(e);
                    Log.current.println("Error closing the api connection " + e.getMessage());
                }
            }
a323 3
        if (messagingMode == CONCURRENT_MESSAGING_MODE) {
            taskProcessingEnded = true;
            interruptAllWaitingReplyThreads();
d325 4
a328 5
            try {
                taskProcessorBinaryResponseHandler.join();
            }
            catch (InterruptedException e) {
            }
d330 6
d337 7
d346 4
a349 6
    /**
     * Return the name of the host to which the CycConnection is established.
     * @@return the name of the Host to which this <tt>CycConnection</tt> is
     * connected.
     */
    public String getHostName() {return this.hostName;}
d351 7
a357 35
    /**
     * Return the base port to which the CycConnection is established.
     * @@return the port to which this <tt>CycConnection</tt> is
     * connected.
     */
    public int getBasePort() {return this.basePort;}

    /**
     * Return the ASCII port to which the CycConnection is established.
     * @@return the ASCII to which this <tt>CycConnection</tt> is
     * connected.
     */
    public int getAsciiPort() {return this.asciiPort;}

    /**
     * Return the CFASL port to which the CycConnection is established.
     * @@return the CFASL port to which this <tt>CycConnection</tt> is
     * connected.
     */
    public int getCfaslPort() {return this.cfaslPort;}

    /**
     * Send a message to Cyc and return the <tt>Boolean</tt> true as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element.  If an error occurs the first element is <tt>Boolean</tt>
     * false and the second element is the error message string.
     *
     * @@param message the api command
     * @@return an array of two objects, the first is an response status object
     * either a Boolean (binary mode) or Integer (ascii mode), and the second is the
     * response object or error string.
     */
    public Object[] converse (Object message) throws IOException,
        CycApiException {
        return  converse(message, notimeout);
d360 1
a360 72
    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the second element is the error message string.
     *
     * @@param message the api command which must be a String or a CycList
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is a Boolean response status
     * object, and the second is the response object or error string.
     */
    public Object[] converse (Object message, Timer timeout)
        throws IOException, TimeOutException, CycApiException {
        if (communicationMode == CycConnection.ASCII_MODE) {
            CycList messageCycList;
            if (message instanceof String) {
                if (cycAccess == null)
                    throw new RuntimeException("CycAccess is required to process commands in string form");
                messageCycList = cycAccess.makeCycList((String) message);
            }
            else if (message instanceof CycList)
                messageCycList = (CycList) message;
            else
                throw new CycApiException("Invalid class for message " + message);
            String messageString = messageCycList.cyclifyWithEscapeChars();
            return  converseAscii(messageString, timeout);
        }
        else { // Binary (CFASL) mode
            CycList messageCycList;
            if (message instanceof CycList)
                messageCycList = (CycList) message;
            else if (message instanceof String) {
                if (cycAccess == null)
                    throw new RuntimeException("CycAccess is required to process commands in string form");
                messageCycList = cycAccess.makeCycList((String) message);
            }
            else
                throw new CycApiException("Invalid class for message " + message);
            messageCycList = substituteForBackquote(messageCycList, timeout);
            return  converseBinary(messageCycList, timeout);
        }
    }

    /**
     * Substitute a READ-FROM-STRING expression for expressions directly containing a
     * backquote symbol.  This transformation is only required for the binary api,
     * which does not parse the backquoted expression.
     *
     * @@param messageCyclist the input expression to be checked for directly containing
     * a backquote symbol.
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return the expression with a READ-FROM-STRING expression substituted for
     * expressions directly containing a backquote symbol
     */
    protected CycList substituteForBackquote(CycList messageCycList,
                                             Timer timeout)
        throws IOException, CycApiException {
        if (messageCycList.treeContains(CycObjectFactory.backquote)) {
            CycList substituteCycList = new CycList();
            substituteCycList.add(CycObjectFactory.makeCycSymbol("read-from-string"));
            substituteCycList.add(messageCycList.cyclify());
            Object[] response = converseBinary(substituteCycList, timeout);
            if ((response[0].equals(Boolean.TRUE)) &&
                    (response[1] instanceof CycList)) {
                CycList backquoteExpression = (CycList) response[1];
                return backquoteExpression.subst(CycObjectFactory.makeCycSymbol("api-bq-list"),
                                                 CycObjectFactory.makeCycSymbol("bq-list"));
            }
            throw new CycApiException("Invalid backquote substitution in " + messageCycList +
                                      "\nstatus" + response[0] + "\nmessage " + response[1]);
d362 2
a363 2
        }
        return messageCycList;
d366 1
a366 81
    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the second element is the error message string.
     * The concurrent mode of Cyc server communication is supported by
     * Cyc's pool of transaction processor threads, each of which can
     * concurrently process an api request.
     *
     * @@param message the api command
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    protected Object[] converseBinary (CycList message,
                                                    Timer timeout)
        throws IOException, TimeOutException, CycApiException {
        if (this.messagingMode == SERIAL_MESSAGING_MODE) {
            sendBinary(message);
            return receiveBinary();
        }
        else { // CONCURRENT_MESSAGING_MODE
            CycSymbol taskProcessorRequestSymbol =
                CycObjectFactory.makeCycSymbol("task-processor-request");
            Integer id = null;
            CycList taskProcessorRequest = null;
            if (message.first().equals(taskProcessorRequestSymbol)) {
                // client has supplied the task-processor-request form
                taskProcessorRequest = message;
                id = (Integer) message.third();
            }
            else {
                id = nextApiRequestId();
                taskProcessorRequest = new CycList();
                // function
                taskProcessorRequest.add(taskProcessorRequestSymbol);
                // request
                taskProcessorRequest.add(message);
                // id
                taskProcessorRequest.add(id);
                // priority
                taskProcessorRequest.add(new Integer(DEFAULT_PRIORITY));
                // requestor
                taskProcessorRequest.add(myClientName);
                // client-bindings
                taskProcessorRequest.add(CycObjectFactory.nil);
                // uuid to identify this client
                taskProcessorRequest.add(uuid.toString());
            }
            waitingReplyThreads.put(id, Thread.currentThread());
            sendBinary(taskProcessorRequest);
            while (true) {
                try {
                    Thread.sleep(10000);
                }
                catch (InterruptedException e) {
                    break;
                }
            }
            Object[] answer =  {
                null, null
            };
            CycList taskProcessorResponse = (CycList) responseMessages.get(id);
            responseMessages.remove(id);
            Object response = taskProcessorResponse.get(5);
            Object status = taskProcessorResponse.get(6);
            if (status == CycObjectFactory.nil) {
                // OK
                answer[0] = Boolean.TRUE;
                answer[1] = response;
            }
            else {
                // Error, status contains the error message
                answer[0] = Boolean.FALSE;
                answer[1] = status;
            }
            return answer;
        }
    }
d368 6
a373 8
    /**
     * Returns the next apiRequestId.
     *
     * @@return the next apiRequestId
     */
    public synchronized Integer nextApiRequestId () {
        return new Integer(++apiRequestId);
    }
d375 1
a375 19
    /**
     * Sends an object to the CYC server.  If the connection is not already open, it is
     * opened.  The object must be a valid CFASL-translatable: an Integer, Float, Double,
     * Boolean, String, or cyc object.
     *
     * @@param message the api command
     */
    public synchronized void sendBinary (Object message) throws IOException {
        if (trace > API_TRACE_NONE) {
            if (message instanceof CycList)
                Log.current.println(((CycList) message).safeToString() + " --> cyc");
            else if (message instanceof CycFort)
                Log.current.println(((CycFort) message).safeToString() + " --> cyc");
            else
                Log.current.println(message + " --> cyc");
        }
        cfaslOutputStream.writeObject(message);
        cfaslOutputStream.flush();
    }
d377 1
a377 35
    /**
     * Receives an object from the CYC server.
     *
     * @@return an array of two objects, the first is a Boolean response, and the second is the
     * response object or error string.
     */
    public synchronized Object[] receiveBinary () throws IOException, CycApiException {
        Object status = cfaslInputStream.readObject();
        Object response = cfaslInputStream.readObject();
        Object[] answer =  {
            null, null
        };
        if (status == null ||
                status.equals(CycObjectFactory.nil)) {
            answer[0] = Boolean.FALSE;
            answer[1] = response;
            if (trace > API_TRACE_NONE) {
                String responseString = null;
                if (response instanceof CycList)
                    responseString = ((CycList) response).safeToString();
                else if (response instanceof CycFort)
                    responseString = ((CycFort) response).safeToString();
                else
                    responseString = response.toString();
                Log.current.println("received error = (" + status + ") " + responseString);
            }
            return answer;
        }
        answer[0] = Boolean.TRUE;
        if (cycAccess == null)
            answer[1] = response;
        else if (cycAccess.deferObjectCompletion)
            answer[1] = response;
        else
            answer[1] = cycAccess.completeObject(response);
d379 1
a379 8
            String responseString = null;
            if (response instanceof CycList)
                responseString = ((CycList) response).safeToString();
            else if (response instanceof CycFort)
                responseString = ((CycFort) response).safeToString();
            else
                responseString = response.toString();
            Log.current.println("cyc --> (" + answer[0] + ") " + responseString);
d381 1
a381 1
        return  answer;
d383 1
a383 14

    /**
     * Receives a binary (cfasl) api request from a cyc server.  Unlike the api response handled
     * by the receiveBinary method, this method does not expect an input status object.
     *
     * @@return the api request expression.
     */
    public CycList receiveBinaryApiRequest () throws IOException,
        CycApiException {
        CycList apiRequest = (CycList) cfaslInputStream.readObject();
        if (trace > API_TRACE_NONE) {
            Log.current.println("cyc --> (api-request) " + apiRequest.safeToString());
        }
        return apiRequest;
d386 545
a930 8
    /**
     * Sends a binary (cfasl) api response to a cyc server.  This method prepends a status
     * object (the symbol T) to the message.
     *
     * @@param the api response object
     */
    public void sendBinaryApiResponse (Object message) throws IOException,
        CycApiException {
d932 172
a1103 43
            String messageString = null;
            if (message instanceof CycList)
                messageString = ((CycList) message).safeToString();
            else if (message instanceof CycFort)
                messageString = ((CycFort) message).safeToString();
            else
                messageString = message.toString();
            Log.current.println("(" + CycObjectFactory.t + ") " + messageString + " --> cyc");
        }
        CycList apiResponse = new CycList();
        apiResponse.add(CycObjectFactory.t);
        apiResponse.add(message);
        cfaslOutputStream.writeObject(apiResponse);
    }

    /**
     * Send a message to Cyc and return the Boolean response as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the first element is Boolean.FALSE and the second element
     * is the error message string.
     * The concurrent mode of Cyc server communication is supported by
     * Cyc's pool of transaction processor threads, each of which can
     * concurrently process an api request.
     *
     * @@param message the api command
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    synchronized protected Object[] converseAscii (String message,
                                                   Timer timeout)
        throws IOException, TimeOutException, CycApiException {
        isSymbolicExpression = false;
        Object[] response = converseUsingAsciiStrings(message, timeout);
        if (response[0].equals(Boolean.TRUE)) {
            String answer = ((String)response[1]).trim();
            if (StringUtils.isDelimitedString(answer)) {
                response[1] = StringUtils.removeDelimiters(answer);
                // Return the string.
                return response;
d1105 6
a1110 24
            if (isSymbolicExpression) {
                // Recurse to complete contained CycConstant, CycNart objects.
                if (cycAccess == null)
                    throw new RuntimeException("CycAccess is required to process commands in string form");
                response[1] = CycAccess.current().makeCycList(answer);
                // Return the CycList object.
                return response;
            }
            if (answer.equals("NIL")) {
                response[1] = CycObjectFactory.nil;
                // Return the symbol nil.
                return response;
            }
            if (answer.startsWith("#$")) {
                if (cycAccess == null)
                    throw new RuntimeException("CycAccess is required to process commands in string form");
                response[1] = CycAccess.current().makeCycConstant(answer);
                // Return the constant.
                return response;
            }
            if (answer.startsWith("?")) {
                response[1] = CycObjectFactory.makeCycVariable(answer);
                // Return the variable.
                return response;
d1112 23
a1134 28
            if (StringUtils.isNumeric(answer)) {
                response[1] = new Integer(answer);
                // Return the number.
                return response;
            }
            if (CycSymbol.isValidSymbolName(answer)) {
                response[1] = CycObjectFactory.makeCycSymbol(answer);
                // Return the symbol.
                return response;
            }

            try {
                double doubleAnswer = Double.parseDouble(answer);
                response[1] = new Double(doubleAnswer);
                // Return the double.
                return response;
            }
            catch (NumberFormatException e) {
            }
            if (answer.endsWith("d0") &&
                    (ViolinStrings.Strings.indexOfAnyOf(answer.substring(0,
                                                                         answer.length() - 2), "0123456789") > -1)) {
                String floatPart = answer.substring(0, answer.length() - 2);
                response[1] = new Double(floatPart);
                // Return the double.
                return response;
            }
            throw new CycApiException("Ascii api response not understood " + answer);
d1136 1
a1136 47
        else
            return response;
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of a object array, and the Cyc response string as the second
     * element.
     */
    protected Object[] converseUsingAsciiStrings (String message,
                                                  Timer timeout)
        throws IOException, CycApiException, TimeOutException {
        if (trace > API_TRACE_NONE)
            Log.current.println(message + " --> cyc");
        out.write(message);
        if (! message.endsWith("\n"))
            out.newLine();
        out.flush();
        if (trace > API_TRACE_NONE)
            Log.current.print("cyc --> ");
        Object[] answer = readAsciiCycResponse(timeout);
        if (trace > API_TRACE_NONE)
            Log.current.println();
        return  answer;
    }

    /**
     * Read the cyc response.
     */
    private Object[] readAsciiCycResponse (Timer timeout) throws IOException,
        TimeOutException {
        Object[] answer =  {
            null, null
        };
        // Parse the response code digits.
        StringBuffer responseCodeDigits = new StringBuffer();
        while (true) {
            if (timeout != null)
                timeout.checkForTimeOut();
            int ch = in.read();
            if (trace > API_TRACE_NONE)
                Log.current.print((char)ch);
            if (ch == ' ')
                break;
            responseCodeDigits.append((char)ch);
        }
        int responseCode = 0;
d1138 135
a1272 25
            responseCode = (new Integer(responseCodeDigits.toString().trim())).intValue();
        }
        catch (NumberFormatException e) {
            throw new RuntimeException("Invalid response code digits " + responseCodeDigits);
        }
        if (responseCode == 200)
            answer[0] = Boolean.TRUE;
        else
            answer[0] = Boolean.FALSE;
        in.mark(1);
        int ch = in.read();
        in.reset();
        if (ch == '(') {
            isSymbolicExpression = true;
            answer[1] = readSymbolicExpression();
        }
        else if (ch == '"')
            answer[1] = readQuotedString();
        else
            answer[1] = readAtom();
        // Read the terminating newline.
        ch = in.read();
        if (trace > API_TRACE_NONE)
            Log.current.print((char)ch);
        return  answer;
d1274 14
a1287 268

    /**
     * Reads a complete symbolic expression as an ascii string.
     *
     * @@return a complete symbolic expression as an ascii string
     */
    private String readSymbolicExpression () throws IOException {
        int parenLevel = 0;
        boolean isQuotedString = false;
        StringBuffer result = new StringBuffer();
        int ch = in.read();
        if (trace > API_TRACE_NONE)
            Log.current.print((char)ch);
        parenLevel++;
        result.append((char)ch);
        while (parenLevel != 0) {
            ch = in.read();
            if (trace > API_TRACE_NONE)
                Log.current.print((char)ch);
            if (ch == '"')
                if (isQuotedString)
                    isQuotedString = false;
                else
                    isQuotedString = true;
            if (! isQuotedString) {
                if (ch == '(')
                    parenLevel++;
                if (ch == ')')
                    parenLevel--;
            }
            result.append((char) ch);
        }
        return  result.toString();
    }

    /**
     * Reads a quoted string
     *
     * @@return the quoted string read
     */
    private String readQuotedString () throws IOException {
        StringBuffer result = new StringBuffer();
        int ch = in.read();
        if (trace > API_TRACE_NONE)
            Log.current.print((char)ch);
        boolean escapedChar = false;
        while (true) {
            ch = in.read();
            if (trace > API_TRACE_NONE)
                Log.current.print((char)ch);
            if ((ch == '"')  && (! escapedChar))
                return  "\"" + result.toString() + "\"";
            if (escapedChar)
                escapedChar = false;
            else if (ch == '\\')
                escapedChar = true;
            result.append((char)ch);
        }
    }

    /**
     * Reads an atom.
     *
     * @@return the atom read as an ascii string
     */
    private String readAtom () throws IOException {
        StringBuffer result = new StringBuffer();
        while (true) {
            in.mark(1);
            int ch = in.read();
            if (trace > API_TRACE_NONE)
                Log.current.print((char)ch);
            if (ch == '\r')
                break;
            if (ch == '\n')
                break;
            result.append((char)ch);
        }
        in.reset();
        return  result.toString();
    }

    /**
     * Returns the trace value.
     */
    public int getTrace() {
        return trace;
    }

    /**
     * Sets the trace value.
     * @@param trace the trace value
     */
    public void setTrace(int trace) {
        this.trace = trace;
    }

    /**
     * Turns on the diagnostic trace of socket messages.
     */
    public void traceOn() {
        trace = API_TRACE_MESSAGES;
        if (communicationMode == BINARY_MODE) {
            cfaslInputStream.trace = trace;
            cfaslOutputStream.trace = trace;
        }
    }

    /**
     * Turns on the detailed diagnostic trace of socket messages.
     */
    public void traceOnDetailed() {
        trace = API_TRACE_DETAILED;
        if (communicationMode == BINARY_MODE) {
            cfaslInputStream.trace = trace;
            cfaslOutputStream.trace = trace;
        }
    }

    /**
     * Turns off the diagnostic trace of socket messages.
     */
    public void traceOff() {
        trace = API_TRACE_NONE;
        if (communicationMode == BINARY_MODE) {
            cfaslInputStream.trace = trace;
            cfaslOutputStream.trace = trace;
        }
    }

    /**
     * Returns connection information, suitable for diagnostics.
     */
    public String connectionInfo () {
        return "host " + hostName +
            ", asciiPort " + asciiPort +
            ", cfaslPort " + cfaslPort;
    }

    /**
     * Returns the UUID that identifies this java api client connection.
     *
     * @@return the UUID that identifies this java api client connection
     */
    public UUID getUuid () {
        return uuid;
    }

    /**
     * Recovers from a socket error by interrupting all the
     * waiting reply threads.  Each awakened thread will detect
     * the error condition and throw an IOExecption.
     */
    protected void interruptAllWaitingReplyThreads() {
        Iterator iter = waitingReplyThreads.values().iterator();
        while(iter.hasNext()) {
            Thread thread = (Thread) iter.next();
            thread.interrupt();
        }
    }

    /**
     * Class TaskProcessorBinaryResponseHandler handles responses
     * from task-processor requests in binary communication mode.
     */
    protected class TaskProcessorBinaryResponseHandler extends Thread {

        /**
         * Well known port where the java api listens for requests from cyc clients.
         */
        public static final int LOCAL_CLIENT_LISTENER_PORT = 3615;

        /**
         * Maximum number of local cyc clients supported by this listener.
         */
        public static final int MAX_LOCAL_CLIENT_CLIENTS = 50;

        /**
         * The socket which listens for new connections.
         */
        protected ServerSocket listenerSocket = null;

        /**
         * The socket which receives asychronous inbound messages
         * from the Cyc server.
         */
        protected Socket inboundSocket = null;

        /**
         * The binary interface input stream which receives asychronous
         * messages from the Cyc server.</tt>.
         */
        public CfaslInputStream inboundStream;

        /**
         * Reference to the parent thread which will sleep until
         * this handler is initialized.
         */
        protected Thread parentThread;

        /**
         * The (ignore) message from the Cyc server to test if the
         * connection is alive.
         */
        protected CycList ignoreMessage;

        /**
         * Constructs a TaskProcessorBinaryResponseHandler object.
         */
        public TaskProcessorBinaryResponseHandler(Thread parentThread) {
            this.parentThread = parentThread;
            ignoreMessage = new CycList();
            ignoreMessage.add(new CycSymbol("IGNORE"));
        }

        /**
         * Blocks until the next task-processor response is available,
         * then awakens the client thread that made the request.
         */
        public void run() {
            // Create a listener socket awaiting the Cyc connection.
            try {
                listenerSocket = new ServerSocket(LOCAL_CLIENT_LISTENER_PORT,
                        MAX_LOCAL_CLIENT_CLIENTS);
                parentThread.interrupt();
                inboundSocket = listenerSocket.accept();
                inboundStream = new CfaslInputStream(inboundSocket.getInputStream());
                inboundStream.trace = trace;
                listenerSocket.close();
            }
            catch (IOException e) {
                Log.current.printStackTrace(e);
                System.exit(1);
            }

            // Handle messsages received on the asychronous inbound Cyc connection.
            while (true) {
                Object status = null;
                CycList taskProcessorResponse = null;
                try {
                    status = inboundStream.readObject();
                    taskProcessorResponse = (CycList) inboundStream.readObject();
                 }
                catch (Exception e) {
                    if (taskProcessingEnded) {
                        if (trace > API_TRACE_NONE)
                            Log.current.println("Ending binary mode task processor handler.");
                        return;
                    }
                    Log.current.errorPrintln(e.getMessage());
                    Log.current.printStackTrace(e);
                }
                if (trace > API_TRACE_NONE) {
                    String responseString = null;
                    Log.current.println("cyc --> (" + status + ") " +
                                       taskProcessorResponse.safeToString());
                }
                if (taskProcessorResponse.equals(ignoreMessage))
                    continue;
                Integer id = (Integer) taskProcessorResponse.get(2);
                responseMessages.put(id, taskProcessorResponse);
                Thread clientThread = (Thread) waitingReplyThreads.get(id);
                waitingReplyThreads.remove(id);
                clientThread.interrupt();
            }
        }
    }

a1288 7







@


1.45
log
@Added Log class to the api package classes.
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.15 2002/10/04 17:46:49 reed Exp $
d356 1
a405 1
        uuid = UUIDGenerator.getInstance().generateTimeBasedUUID();
d1134 9
@


1.44
log
@Fixes after unit testing SONAT DAML import
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.43 2002/09/13 22:55:46 stephenreed Exp $
d352 1
a352 1
                System.out.println("Ascii connection " + asciiSocket);
d354 1
a354 1
                System.out.println("Binary connection " + cfaslSocket);
d365 2
d431 2
a432 2
                    e.printStackTrace();
                    System.out.println("Error quitting the api connection " + e.getMessage());
d445 2
a446 2
                    e.printStackTrace();
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d454 2
a455 2
                    e.printStackTrace();
                    System.out.println("Error closing the api connection " + e.getMessage());
d480 2
a481 2
                    e.printStackTrace();
                    System.out.println("Error quitting the api connection " + e.getMessage());
d494 2
a495 2
                    e.printStackTrace();
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d503 2
a504 2
                    e.printStackTrace();
                    System.out.println("Error closing the api connection " + e.getMessage());
d743 1
a743 1
                System.out.println(((CycList) message).safeToString() + " --> cyc");
d745 1
a745 1
                System.out.println(((CycFort) message).safeToString() + " --> cyc");
d747 1
a747 1
                System.out.println(message + " --> cyc");
d777 1
a777 1
                System.out.println("received error = (" + status + ") " + responseString);
d796 1
a796 1
            System.out.println("cyc --> (" + answer[0] + ") " + responseString);
d811 1
a811 1
            System.out.println("cyc --> (api-request) " + apiRequest.safeToString());
d832 1
a832 1
            System.out.println("(" + CycObjectFactory.t + ") " + messageString + " --> cyc");
d936 1
a936 1
            System.out.println(message + " --> cyc");
d942 1
a942 1
            System.out.print("cyc --> ");
d945 1
a945 1
            System.out.println();
d964 1
a964 1
                System.out.print((char)ch);
d994 1
a994 1
            System.out.print((char)ch);
d1009 1
a1009 1
            System.out.print((char)ch);
d1015 1
a1015 1
                System.out.print((char)ch);
d1041 1
a1041 1
            System.out.print((char)ch);
d1046 1
a1046 1
                System.out.print((char)ch);
d1068 1
a1068 1
                System.out.print((char)ch);
d1219 1
a1219 1
                e.printStackTrace();
d1234 1
a1234 1
                            System.out.println("Ending binary mode task processor handler.");
d1237 2
a1238 2
                    System.err.println(e.getMessage());
                    e.printStackTrace();
d1242 1
a1242 1
                    System.out.println("cyc --> (" + status + ") " +
@


1.43
log
@Began importing some DAML
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.42 2002/09/10 21:14:03 stephenreed Exp $
d50 1
d56 1
a56 1
    //public static final int DEFAULT_BASE_PORT = 3640;
@


1.42
log
@Added nickname handling for namspaces.
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.41 2002/09/09 23:11:45 stephenreed Exp $
d90 2
a91 2
    //protected int trace = API_TRACE_NONE;
    protected int trace = API_TRACE_MESSAGES;
@


1.41
log
@Fixes for concurrent api requests - requires OpenCyc 0.7.0
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.40 2002/09/08 02:43:02 stephenreed Exp $
d54 2
a55 2
    //public static final int DEFAULT_BASE_PORT = 3600;
    public static final int DEFAULT_BASE_PORT = 3640;
d90 2
a91 1
    protected int trace = API_TRACE_NONE;
d126 1
a126 1
    public static final int DEFAULT_MESSAGING_MODE = CONCURRENT_MESSAGING_MODE;
a348 1
        //if (trace >= API_TRACE_NONE) {
@


1.40
log
@Concurrent api calls
@
text
@d23 1
a23 1
 * @@version $Id: CycConnection.java,v 1.39 2002/09/03 02:36:23 stephenreed Exp $
d54 2
a55 1
    public static final int DEFAULT_BASE_PORT = 3600;
a421 5
        if (messagingMode == CONCURRENT_MESSAGING_MODE) {
            taskProcessingEnded = true;
            interruptAllWaitingReplyThreads();
            taskProcessorBinaryResponseHandler.interrupt();
        }
d505 11
d1177 1
a1177 1
        protected CfaslInputStream inboundStream;
d1213 1
@


1.39
log
@Concurrent api calls.
@
text
@d8 1
d19 5
a23 1
 * @@version $Id: CycConnection.java,v 1.38 2002/08/30 22:52:13 stephenreed Exp $
d89 1
a89 2
    //protected int trace = API_TRACE_NONE;
    protected int trace = API_TRACE_MESSAGES;
d114 1
a114 1
    public static final int SERIAL_MESSAGING_MODE = 0;
d119 1
a119 1
    public static final int CONCURRENT_MESSAGING_MODE = 1;
d124 1
a124 1
    public static final int DEFAULT_MESSAGING_MODE = SERIAL_MESSAGING_MODE;
a230 5
     * handles responses from task-processor requests in ascii communication mode.
     */
    protected TaskProcessorAsciiResponseHandler taskProcessorAsciiResponseHandler;

    /**
d242 6
d340 5
a344 1
        this.messagingMode = messagingMode;
d354 1
a354 1
        if (messagingMode == CONCURRENT_MESSAGING_MODE)
d384 12
a395 7
        if (communicationMode == ASCII_MODE) {
            taskProcessorAsciiResponseHandler = new TaskProcessorAsciiResponseHandler();
            taskProcessorAsciiResponseHandler.start();
        }
        else {
            taskProcessorBinaryResponseHandler = new TaskProcessorBinaryResponseHandler();
            taskProcessorBinaryResponseHandler.start();
d397 11
d421 5
a425 1
        taskProcessingEnded = true;
d462 14
a475 1
                CycList command = new CycList();
d550 1
a550 1
    public synchronized Object[] converse (Object message) throws IOException,
d568 1
a568 1
    public synchronized Object[] converse (Object message, Timer timeout)
d648 1
a648 1
    synchronized protected Object[] converseBinary (CycList message,
d668 1
d680 2
d683 1
a684 1
            waitingReplyThreads.put(id, Thread.currentThread());
d730 1
a730 1
    public void sendBinary (Object message) throws IOException {
d749 1
a749 1
    public Object[] receiveBinary () throws IOException, CycApiException {
a751 13
        return receiveBinary(status, response);
    }

    /**
     * Receives an object from the CYC server.
     *
     * @@param status the received status object
     * @@param response the received response object
     * @@return an array of two objects, the first is a Boolean response, and the second is the
     * response object or error string.
     */
    public Object[] receiveBinary (Object status, Object response)
    throws IOException, CycApiException {
d927 10
a936 93
        if (messagingMode == SERIAL_MESSAGING_MODE) {
            out.write(message);
            if (! message.endsWith("\n"))
                out.newLine();
            out.flush();
            if (trace > API_TRACE_NONE)
                System.out.print("cyc --> ");
            Object[] answer = readAsciiCycResponse(timeout);
            if (trace > API_TRACE_NONE)
                System.out.println();
            return  answer;
        }
        else { // CONCURRENT_MESSAGING_MODE
            String taskProcessorRequest = null;
            Integer id = null;
            if (message.startsWith("(task-processor-request ")) {
                // client has supplied the task-processor-request form
                taskProcessorRequest = message;
                CycList messageList = cycAccess.makeCycList(message);
                id = (Integer) messageList.third();
            }
            else {
                id = nextApiRequestId();
                StringBuffer taskProcessorRequestBuffer = new StringBuffer();
                taskProcessorRequestBuffer.append("(task-processor-request ");
                // request
                taskProcessorRequestBuffer.append(message);
                taskProcessorRequestBuffer.append(" ");
                // id
                taskProcessorRequestBuffer.append(id.toString());
                taskProcessorRequestBuffer.append(" ");
                // priority
                taskProcessorRequestBuffer.append((new Integer(DEFAULT_PRIORITY)).toString());
                taskProcessorRequestBuffer.append(" \"");
                // requestor
                taskProcessorRequestBuffer.append(myClientName);
                taskProcessorRequestBuffer.append("\" ");
                // client-bindings
                taskProcessorRequestBuffer.append(" nil)");
                taskProcessorRequest = taskProcessorRequestBuffer.toString();
            }
            waitingReplyThreads.put(id, Thread.currentThread());
            System.out.println(taskProcessorRequest);
            out.write(taskProcessorRequest);
            if (! taskProcessorRequest.endsWith("\n"))
                out.newLine();
            out.flush();
            while (true) {
                try {
                    Thread.sleep(10000);
                }
                catch (InterruptedException e) {
                    break;
                }
            }
            if (taskProcessingEnded)
                throw new IOException("Socket closed");
            Object[] answer =  {
                null, null
            };
            CycList taskProcessorResponse = (CycList) responseMessages.get(id);
            responseMessages.remove(id);
            String response = null;
            Object responseObject = taskProcessorResponse.get(5);
            if (responseObject instanceof CycFort) {
                response = ((CycFort) responseObject).cyclify();
                isSymbolicExpression = false;
            }
            else if (responseObject instanceof CycList) {
                response = ((CycList) responseObject).cyclify();
                isSymbolicExpression = true;
            }
            else if (responseObject instanceof String) {
                response = "\"" + responseObject + "\"";
                isSymbolicExpression = false;
            }
            else {
                response = responseObject.toString();
                isSymbolicExpression = false;
            }
            CycSymbol status = (CycSymbol) taskProcessorResponse.get(6);
            if (status.equals(CycObjectFactory.nil)) {
                // OK
                answer[0] = Boolean.TRUE;
                answer[1] = response;
            }
            else {
                // Error, status contains the error message
                answer[0] = Boolean.FALSE;
                answer[1] = status;
            }
            return answer;
        }
a952 5
            if (ch == -1) {
                taskProcessingEnded = true;
                interruptAllWaitingReplyThreads();
                throw new IOException("Socket closed");
            }
d1140 2
a1141 2
     * Class TaskProcessorAsciiResponseHandler handles responses
     * from task-processor requests in ascii communication mode.
d1143 11
a1153 1
    protected class TaskProcessorAsciiResponseHandler extends Thread {
d1156 1
a1156 1
         * Constructs a TaskProcessorAsciiResponseHandler object.
d1158 13
a1170 2
        public TaskProcessorAsciiResponseHandler() {
        }
d1173 2
a1174 2
         * Blocks until the next task-processor response is available,
         * then awakens the client thread that made the request.
d1176 1
a1176 33
        public void run() {
            while (true) {
                Object[] answer = null;
                CycList taskProcessorResponse = null;
                try {
                    answer = readAsciiCycResponse (null);
                }
                catch (IOException e) {
                    if (taskProcessingEnded) {
                        if (trace > API_TRACE_NONE)
                            System.out.println("Ending ascii mode task processor handler.");
                        return;
                    }
                    System.err.println(e.getMessage());
                    e.printStackTrace();
                }
                String taskProcessorResponseString = (String) answer[1];
                if (cycAccess == null)
                    throw new RuntimeException("CycAccess required for concurrent ascii mode.");
                try {
                    taskProcessorResponse = cycAccess.makeCycList(taskProcessorResponseString.trim());
                }
                catch (CycApiException e) {
                   throw new RuntimeException("Error while parsing CycList " + taskProcessorResponseString);
                }
                Integer id = (Integer) taskProcessorResponse.get(2);
                responseMessages.put(id, taskProcessorResponse);
                Thread clientThread = (Thread) waitingReplyThreads.get(id);
                waitingReplyThreads.remove(id);
                clientThread.interrupt();
            }
        }
    }
d1178 5
a1182 5
    /**
     * Class TaskProcessorBinaryResponseHandler handles responses
     * from task-processor requests in binary communication mode.
     */
    protected class TaskProcessorBinaryResponseHandler extends Thread {
d1187 4
a1190 1
        public TaskProcessorBinaryResponseHandler() {
d1198 15
d1214 1
a1214 1
                Object[] answer = null;
d1217 3
a1219 2
                    answer = receiveBinary();
                }
d1229 7
a1235 1
                taskProcessorResponse = (CycList) answer[1];
@


1.38
log
@Added concurrent processing for ascii communications mode.
Next will add it for binary mode.  Concurrent processing will be supported by
OpenCyc release 0.7.0.
@
text
@d6 1
d18 1
a18 1
 * @@version $Id: CycConnection.java,v 1.37 2002/08/30 02:55:18 stephenreed Exp $
d84 2
a85 1
    protected int trace = API_TRACE_NONE;
d937 1
d950 2
d1004 5
d1180 13
@


1.37
log
@Added more code to the concurrent api request processing.
@
text
@d17 1
a17 1
 * @@version $Id: CycConnection.java,v 1.36 2002/07/23 20:17:19 stephenreed Exp $
d298 24
a325 2
        this.communicationMode = communicationMode;
        this.cycAccess = cycAccess;
d329 6
d367 3
a369 1
     * Initializes the concurrent processing mode.
d371 2
a372 1
    protected void initializeConcurrentProcessing () {
d521 2
a522 3
     * @@return an array of two objects, the first is an response status object
     * either a Boolean (binary mode) or Integer (ascii mode), and the second is the
     * response object or error string.
d540 1
a540 1
        else {
d646 4
a649 1
            Object[] answer = (Object[]) responseMessages.get(id);
d651 12
a662 2
            //Object response = taskProcessorResponse.get(5);
            //Object status = taskProcessorResponse.get(6);
d893 1
a893 1
        if (this.messagingMode == SERIAL_MESSAGING_MODE) {
d926 1
a926 1
                taskProcessorRequestBuffer.append(" ");
d929 1
a929 1
                taskProcessorRequestBuffer.append(" ");
d934 1
a938 1
            waitingReplyThreads.put(id, Thread.currentThread());
d947 4
a950 1
            Object[] answer = (Object[]) responseMessages.get(id);
d952 29
d1204 9
a1212 1
                taskProcessorResponse = (CycList) answer[1];
@


1.36
log
@Handled embedded quotes within strings sent to Cyc.  This patch makes the ascii
and cfasl (binary) api commands behave the same.  Added unit test cases.
@
text
@d17 1
a17 1
 * @@version $Id: CycConnection.java,v 1.35 2002/07/17 21:27:05 stephenreed Exp $
d235 6
d260 3
a262 2
     * Constructs a new CycConnection object using the default host name, default base port number and
     * binary communication mode.  When CycAccess is null, diagnostic output is reduced.
d265 3
a267 2
    throws IOException, UnknownHostException, CycApiException {
        this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE, null);
d271 5
a275 2
     * Constructs a new CycConnection object using the default host name, default base port number and
     * binary communication mode.
d278 3
a280 2
    throws IOException, UnknownHostException, CycApiException {
        this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE, cycAccess);
d284 2
a285 2
     * Constructs a new CycConnection object using a given host name, the given base port number, and
     * the given communication mode.
d290 2
d293 4
a296 1
    public CycConnection (String hostName, int basePort, int communicationMode, CycAccess cycAccess)
d304 2
a305 1
        if ((communicationMode != ASCII_MODE) && (communicationMode != BINARY_MODE))
d322 2
a323 1
    private void initializeApiConnections () throws IOException, UnknownHostException {
d342 8
a349 4
        taskProcessorAsciiResponseHandler = new TaskProcessorAsciiResponseHandler();
        taskProcessorAsciiResponseHandler.start();
        taskProcessorBinaryResponseHandler = new TaskProcessorBinaryResponseHandler();
        taskProcessorBinaryResponseHandler.start();
a351 1

d363 1
d436 27
a462 27
  /**
   * Return the name of the host to which the CycConnection is established.
   * @@return the name of the Host to which this <tt>CycConnection</tt> is
   * connected.
   */
  public String getHostName() {return this.hostName;}

  /**
   * Return the base port to which the CycConnection is established.
   * @@return the port to which this <tt>CycConnection</tt> is
   * connected.
   */
  public int getBasePort() {return this.basePort;}

  /**
   * Return the ASCII port to which the CycConnection is established.
   * @@return the ASCII to which this <tt>CycConnection</tt> is
   * connected.
   */
  public int getAsciiPort() {return this.asciiPort;}

  /**
   * Return the CFASL port to which the CycConnection is established.
   * @@return the CFASL port to which this <tt>CycConnection</tt> is
   * connected.
   */
  public int getCfaslPort() {return this.cfaslPort;}
d475 2
a476 1
    public synchronized Object[] converse (Object message) throws IOException, CycApiException {
d537 2
a538 1
    protected CycList substituteForBackquote(CycList messageCycList, Timer timeout)
d546 1
a546 1
                (response[1] instanceof CycList)) {
d565 3
d574 2
a575 1
    synchronized protected Object[] converseBinary (CycList message, Timer timeout)
d606 1
a606 1
            sendBinary(message);
d616 1
a616 1
            CycList taskProcessorResponse = (CycList) responseMessages.get(id);
d618 3
a620 39
            Object response = taskProcessorResponse.get(5);
            Object status = taskProcessorResponse.get(6);
            Object[] answer =  {
                null, null
            };

            if (status.equals(CycObjectFactory.nil)) {
                answer[0] = Boolean.FALSE;
                answer[1] = response;
                if (trace > API_TRACE_NONE) {
                    String responseString = null;
                    if (response instanceof CycList)
                        responseString = ((CycList) response).safeToString();
                    else if (response instanceof CycFort)
                        responseString = ((CycFort) response).safeToString();
                    else
                        responseString = response.toString();
                    System.out.println("received error = (" + status + ") " + responseString);
                }
                return answer;
            }
            answer[0] = Boolean.TRUE;
            if (cycAccess == null)
                answer[1] = response;
            else if (cycAccess.deferObjectCompletion)
                answer[1] = response;
            else
                answer[1] = cycAccess.completeObject(response);
            if (trace > API_TRACE_NONE) {
                String responseString = null;
                if (response instanceof CycList)
                    responseString = ((CycList) response).safeToString();
                else if (response instanceof CycFort)
                    responseString = ((CycFort) response).safeToString();
                else
                    responseString = response.toString();
                System.out.println("cyc --> (" + answer[0] + ") " + responseString);
            }
            return  answer;
d660 15
a677 2
        Object status = cfaslInputStream.readObject();
        Object response = cfaslInputStream.readObject();
d679 1
a679 1
            status.equals(CycObjectFactory.nil)) {
d720 2
a721 1
    public CycList receiveBinaryApiRequest () throws IOException, CycApiException {
d735 2
a736 1
    public void sendBinaryApiResponse (Object message) throws IOException, CycApiException {
d761 3
d770 3
a772 2
    synchronized protected Object[] converseAscii (String message, Timer timeout)
    throws IOException, TimeOutException, CycApiException {
d827 2
a828 1
                (ViolinStrings.Strings.indexOfAnyOf(answer.substring(0, answer.length() - 2), "0123456789") > -1)) {
d845 3
a847 1
    protected Object[] converseUsingAsciiStrings (String message, Timer timeout) throws IOException, TimeOutException {
d850 58
a907 10
        out.write(message);
        if (!message.endsWith("\n"))
            out.newLine();
        out.flush();
        if (trace > API_TRACE_NONE)
            System.out.print("cyc --> ");
        Object[] answer = readAsciiCycResponse(timeout);
        if (trace > API_TRACE_NONE)
            System.out.println();
        return  answer;
d913 2
a914 1
    private Object[] readAsciiCycResponse (Timer timeout) throws IOException, TimeOutException {
d1093 2
a1094 2
               ", asciiPort " + asciiPort +
               ", cfaslPort " + cfaslPort;
d1121 5
d1163 5
@


1.35
log
@Adapted regression test to work with recent alpha version of OpenCyc.
@
text
@d17 1
a17 1
 * @@version $Id: CycConnection.java,v 1.34 2002/05/30 20:00:22 stephenreed Exp $
d473 6
a478 3
            String messageString;
            if (message instanceof String)
                messageString = (String) message;
d480 1
a480 1
                messageString = ((CycList) message).cyclify();
d483 1
@


1.34
log
@Unit test compliance mods.
@
text
@d17 1
a17 1
 * @@version $Id: CycConnection.java,v 1.33 2002/03/27 19:51:19 stephenreed Exp $
d43 1
a43 1
    public static final String DEFAULT_HOSTNAME = "localhost";
d350 5
d385 5
@


1.33
log
@Prepared ApiDemo class as first in a series for the programming tutorial.  Other modules
updated in preparation for public beta release.
@
text
@d5 1
d17 1
a17 1
 * @@version $Id: CycConnection.java,v 1.32 2002/01/16 21:17:17 stephenreed Exp $
d88 1
a89 1
    public static final int ASCII_MODE = 1;
d106 20
d198 37
d297 2
d320 11
d348 1
a348 1
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d366 1
a366 1
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d379 1
a379 1
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d397 1
a397 1
                    System.out.println("Error finalizing the api connection " + e.getMessage());
d532 1
a532 1
    synchronized protected Object[] converseBinary (Object message, Timer timeout)
d534 90
a623 2
        sendBinary(message);
        return  receiveBinary();
d843 2
a844 1
            timeout.checkForTimeOut();
d1017 74
@


1.32
log
@Changed default host name back to localhost
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.31 2002/01/08 15:02:30 stephenreed Exp $
d437 3
a439 1
                return (CycList) response[1];
d792 2
@


1.31
log
@Added SRA/NetOwl import function
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.30 2001/11/27 23:27:27 stephenreed Exp $
d42 1
a42 2
    //public static final String DEFAULT_HOSTNAME = "localhost";
    public static final String DEFAULT_HOSTNAME = "192.168.202.108";
a47 1
    //public static final int DEFAULT_BASE_PORT = 3640;
@


1.30
log
@More cyc agent client support
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.29 2001/11/26 05:14:01 stephenreed Exp $
d42 2
a43 1
    public static final String DEFAULT_HOSTNAME = "localhost";
@


1.29
log
@Refactoring Cyc agent client
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.28 2001/11/25 18:31:13 stephenreed Exp $
d532 37
@


1.28
log
@Renamed CycInputHandler to CycClientHandler
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.27 2001/11/21 18:05:50 stephenreed Exp $
d473 1
a473 1
    private void sendBinary (Object message) throws IOException {
d492 1
a492 1
    private Object[] receiveBinary () throws IOException, CycApiException {
@


1.27
log
@Refactored CycProxy class
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.26 2001/11/17 00:32:47 stephenreed Exp $
d136 1
a136 1
     * The tcp port assigned to the the ascii connection to the OpenCyc server.
d141 1
a141 1
     * The tcp port assigned to the the binary connection to the OpenCyc server.
d146 1
a146 1
     * The tcp socket assigned to the the ascii connection to the OpenCyc server.
d151 1
a151 1
     * The tcp socket assigned to the the binary connection to the OpenCyc server.
d176 19
@


1.26
log
@CoAbs agent tests
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.25 2001/11/13 02:16:51 stephenreed Exp $
d450 1
a450 1
     * Boolean, String, Symbol, ArrayList, or an implementor of the CfaslTranslatingObject.
d455 8
a462 2
        if (trace > API_TRACE_NONE)
            System.out.println(message + " --> cyc");
@


1.25
log
@Continued testing
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.24 2001/11/09 22:09:33 stephenreed Exp $
d179 9
d394 1
a394 1
            messageCycList = substituteForBackquote(messageCycList);
d406 1
d410 1
a410 1
    protected CycList substituteForBackquote(CycList messageCycList)
d412 1
a412 1
        if (messageCycList.contains(CycObjectFactory.makeCycSymbol("`"))) {
d416 4
a419 9
            if (cycAccess == null)
                throw new RuntimeException("CycAccess is required to process commands with backquote");
            return cycAccess.converseList(substituteCycList);
        }
        else {
            for (int i = 1; i < messageCycList.size(); i++) {
                Object element = messageCycList.get(i);
                if (element instanceof CycList)
                    messageCycList.set(i, substituteForBackquote((CycList) element));
d421 3
a423 1
            return messageCycList;
d425 1
d477 10
a486 2
            if (trace > API_TRACE_NONE)
                System.out.println("received error = (" + status + ") " + response);
d496 10
a505 2
        if (trace > API_TRACE_NONE)
            System.out.println("cyc --> (" + answer[0] + ") " + answer[1]);
d629 7
a635 1
        int responseCode = (new Integer(responseCodeDigits.toString().trim())).intValue();
d702 1
d707 1
a707 1
            if (ch == '"')
d709 4
d757 4
a760 2
        cfaslInputStream.trace = trace;
        cfaslOutputStream.trace = trace;
d768 4
a771 2
        cfaslInputStream.trace = trace;
        cfaslOutputStream.trace = trace;
d779 4
a782 2
        cfaslInputStream.trace = trace;
        cfaslOutputStream.trace = trace;
@


1.24
log
@Initial check in
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.23 2001/11/09 02:50:59 stephenreed Exp $
d340 2
a341 1
     * @@return an array of two objects, the first is an Integer response code, and the second is the
d358 2
a359 1
     * @@return an array of two objects, the first is an Integer response code, and the second is the
@


1.23
log
@Initial check in
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.22 2001/10/24 17:00:29 stephenreed Exp $
d740 9
@


1.22
log
@Modifications to support jini agent interface to OpenCyc
@
text
@d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.21 2001/10/17 23:44:18 stephenreed Exp $
d37 1
a37 1
public class CycConnection {
d698 15
@


1.21
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@d13 2
a14 1
 * Collaborates with the <tt>CycAccess</tt> class which wraps the api functions.
d16 1
a16 1
 * @@version $Id: CycConnection.java,v 1.20 2001/10/12 22:45:36 stephenreed Exp $
d83 1
a83 1
    public int trace = API_TRACE_NONE;
d225 4
a228 2
            cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream(), this);
            cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream(), this);
d376 5
a380 2
            else if (message instanceof String)
                messageCycList = this.cycAccess.makeCycList((String) message);
d404 2
d472 3
a474 1
        if (cycAccess.deferObjectCompletion)
d510 2
d522 2
d699 28
@


1.20
log
@Added test case for check-type SubL function.
Fixed cyclify() for CycNarts.
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.19 2001/10/09 16:09:01 stephenreed Exp $
d180 2
a181 1
    public CycConnection (CycAccess cycAccess) throws IOException, UnknownHostException {
d194 1
a194 1
        throws IOException, UnknownHostException {
d202 1
a202 1
            throw  new RuntimeException("Invalid communication mode " + communicationMode);
d340 1
a340 1
    public synchronized Object[] converse (Object message) throws IOException {
d358 1
a358 1
        throws IOException, TimeOutException {
d366 1
a366 1
                throw new RuntimeException("Invalid class for message " + message);
d376 1
a376 1
                throw new RuntimeException("Invalid class for message " + message);
d392 2
a393 1
    protected CycList substituteForBackquote(CycList messageCycList) throws IOException {
d424 1
a424 1
        throws IOException, TimeOutException {
d449 1
a449 1
    private Object[] receiveBinary () throws IOException {
d487 2
a488 2
    synchronized protected Object[] converseAscii (String message, Timer timeout) throws IOException,
            TimeOutException {
d545 1
a545 1
            throw new RuntimeException("Ascii api response not understood " + answer);
@


1.19
log
@Added connection accessors and pretty printing for CycLists.
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.6 2001/10/09 15:24:52 bertolo Exp $
d46 2
a47 2
    //public static final int DEFAULT_BASE_PORT = 3600;
    public static final int DEFAULT_BASE_PORT = 3640;
d203 1
d307 1
a307 1
  
d527 9
d540 1
a540 1
                // Return the symbol.
@


1.18
log
@Added more server side SubL scripting tests
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.17 2001/09/28 22:36:27 stephenreed Exp $
d299 28
@


1.17
log
@Added code to support backquoted expressions in the binary api
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.16 2001/09/18 17:54:39 stephenreed Exp $
d495 7
@


1.16
log
@Added shared CycAccess instance to the class for convenience in multithreading situations
where the application controls sharing.
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.15 2001/09/17 18:46:55 stephenreed Exp $
d347 1
d349 27
@


1.15
log
@Added accessors for host connection info
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.2 2001/09/17 16:17:53 reed Exp $
d46 2
a47 1
    public static final int DEFAULT_BASE_PORT = 3600;
@


1.14
log
@Created new CycObjectFactory class to contain all cyc object caches
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.13 2001/09/07 23:43:03 stephenreed Exp $
@


1.13
log
@Added defered completion of CycForts in the binary api. Continued with HashJoiner.
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.12 2001/09/03 22:30:50 stephenreed Exp $
d269 1
a269 1
                command.add(CycSymbol.makeCycSymbol("API-QUIT"));
d396 1
a396 1
            status.equals(CycSymbol.nil)) {
d445 1
a445 1
                response[1] = CycSymbol.nil;
d455 1
a455 1
                response[1] = CycVariable.makeCycVariable(answer);
d465 1
a465 1
                response[1] = CycSymbol.makeCycSymbol(answer);
@


1.12
log
@Reworking ProblemParser to handle high cardinality domains better
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.11 2001/08/30 00:06:54 stephenreed Exp $
d404 4
a407 1
        answer[1] = cycAccess.completeObject(response);
@


1.11
log
@Changed CycAccess parameters from CycConstants to CycForts, more backchaining tests
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.10 2001/08/28 10:05:25 stephenreed Exp $
d64 15
d81 1
a81 1
    public boolean trace = false;
d202 1
a202 1
        if (trace) {
d377 2
a378 2
        if (trace)
            System.out.println("send = " + message);
d399 1
a399 1
            if (trace)
d405 2
a406 2
        if (trace)
            System.out.println("receive = (" + answer[0] + ") " + answer[1]);
d478 1
a478 1
        if (trace)
d484 1
a484 1
        if (trace)
d487 1
a487 1
        if (trace)
d504 1
a504 1
            if (trace)
d528 1
a528 1
        if (trace)
d543 1
a543 1
        if (trace)
d549 1
a549 1
            if (trace)
d575 1
a575 1
        if (trace)
d579 1
a579 1
            if (trace)
d597 1
a597 1
            if (trace)
@


1.10
log
@Refactored binary api support to pass all unit tests
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.9 2001/08/27 22:30:44 stephenreed Exp $
d378 4
a381 1
        if (cfaslInputStream.readObject() == null)
d383 7
a389 3
        else
            answer[0] = Boolean.TRUE;
        answer[1] = cycAccess.completeObject(cfaslInputStream.readObject());
@


1.9
log
@Additional api test cases
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.8 2001/08/24 22:39:27 stephenreed Exp $
d405 1
a405 1
        Object[] response = converseUsingStrings(message, timeout);
d408 7
a414 2
            if (isSymbolicExpression)
                // Recurse if list contains CycConstant objects.
d416 29
a444 5
            else if (answer.equals("NIL"))
                response[1] = new CycList();
            else
                // Treat a non-string object as a string.
                response[1] = answer;
d446 2
a447 1
        return  response;
d455 1
a455 1
    protected Object[] converseUsingStrings (String message, Timer timeout) throws IOException, TimeOutException {
d464 1
a464 1
        Object[] answer = readCycResponse(timeout);
d473 1
a473 1
    private Object[] readCycResponse (Timer timeout) throws IOException, TimeOutException {
d501 1
a501 1
            answer[1] = readString();
d512 3
a514 1
     * Read a symbolic expression.
d534 1
a534 1
            if (!isQuotedString) {
d540 1
a540 1
            result.append((char)ch);
d546 3
a548 1
     * Read a quoted string.
d550 1
a550 1
    private String readString () throws IOException {
d566 3
a568 1
     * Read an atom.
@


1.8
log
@Continued binary api test cases
@
text
@d5 1
d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.7 2001/08/23 22:14:25 stephenreed Exp $
d156 5
d294 1
a294 1
    public Object[] converse (Object message) throws IOException {
d311 2
a312 1
    public Object[] converse (Object message, Timer timeout) throws IOException, TimeOutException {
d414 1
d526 1
a526 1
                return  result.toString();
@


1.7
log
@Continuing unit test cases for binary api
@
text
@d14 1
a14 1
 * @@version $Id: CycConnection.java,v 1.6 2001/08/23 09:33:13 stephenreed Exp $
d375 1
a375 4
        answer[1] = cfaslInputStream.readObject();
        if (answer[1] instanceof CycList)
            // Get constant names and guids for any constants in the CycList.
            cycAccess.completeCycList((CycList) answer[1]);
a500 3
            if ((!isQuotedString) && (result.length() > 3) && (result.toString().endsWith(" . ")))
                // Convert lists of the form ( x y . z) into (x y z).
                result.setLength(result.length() - 2);
@


1.6
log
@Continued unit testing binary api
@
text
@d12 3
a14 1
 * @@version $Id: CycConnection.java,v 1.5 2001/08/23 00:47:46 stephenreed Exp $
d80 1
a80 1
    public static final int DEFAULT_COMMUNICATION_MODE = ASCII_MODE;
d206 1
a206 1
     * Close the cyc api sockets.
d208 68
a275 5
    public void close () throws IOException {
        if (asciiSocket != null)
            asciiSocket.close();
        if (cfaslSocket != null)
            cfaslSocket.close();
d376 3
@


1.5
log
@Continuing integration of legacy binary api
@
text
@d1 485
a485 457
package  org.opencyc.api;

import  java.net.*;
import  java.io.*;
import  org.opencyc.util.*;
import  org.opencyc.cycobject.*;


/**
 * Provides a binary connection and an ascii connection to the OpenCyc server.  The ascii connection is
 * legacy and its use is deprecated.<p>
 *
 * @@version $Id: CycConnection.java,v 1.4 2001/08/21 23:28:16 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class CycConnection {
    /**
     * Default host name for the OpenCyc server.
     */
    public static final String DEFAULT_HOSTNAME = "localhost";
    /**
     * Default base tcp port for the OpenCyc server.
     */
    public static final int DEFAULT_BASE_PORT = 3600;
    /**
     * HTTP port offset for the OpenCyc server.
     */
    public static final int HTTP_PORT_OFFSET = 0;
    /**
     * ASCII port offset for the OpenCyc server.
     */
    public static final int ASCII_PORT_OFFSET = 1;
    /**
     * CFASL (binary) port offset for the OpenCyc server.
     */
    public static final int CFASL_PORT_OFFSET = 14;
    /**
     * Parameter that, when true, causes a trace of the messages to and from the server.
     */
    public boolean trace = false;
    /**
     * Ascii mode connnection to the OpenCyc server.
     */
    public static final int ASCII_MODE = 1;
    /**
     * CFASL (binary) mode connnection to the OpenCyc server.
     */
    public static final int BINARY_MODE = 2;
    /**
     * Default communication mode connnection to the OpenCyc server.
     */
    public static final int DEFAULT_COMMUNICATION_MODE = ASCII_MODE;
    /**
     * Indicator for whether to use the binary or acsii connection with OpenCyc.
     */
    protected int communicationMode = 0;
    /**
     * The ascii interface input stream.
     */
    protected BufferedReader in;
    /**
     * The ascii interface output stream.
     */
    protected BufferedWriter out;
    /**
     * The binary interface input stream</tt>.
     */
    protected CfaslInputStream cfaslInputStream;
    /**
     * The binary interface output stream</tt>.
     */
    protected CfaslOutputStream cfaslOutputStream;
    /**
     * The name of the computer hosting the OpenCyc server.
     */
    protected String hostName;
    /**
     * The tcp port from which the asciiPort and cfaslPorts are derived.
     */
    protected int basePort;
    /**
     * The tcp port assigned to the the ascii connection to the OpenCyc server.
     */
    protected int asciiPort;
    /**
     * The tcp port assigned to the the binary connection to the OpenCyc server.
     */
    protected int cfaslPort;
    /**
     * The tcp socket assigned to the the ascii connection to the OpenCyc server.
     */
    protected Socket asciiSocket;
    /**
     * The tcp socket assigned to the the binary connection to the OpenCyc server.
     */
    protected Socket cfaslSocket;
    /**
     * The timer which optionally monitors the duration of requests to the OpenCyc server.
     */
    protected static final Timer notimeout = new Timer();
    /**
     * Indicates if the response from the OpenCyc server is a symbolic expression (enclosed in
     * parentheses).
     */
    protected boolean isSymbolicExpression = false;
    /**
     * A reference to the parent CycAccess object for dereferencing constants in ascii symbolic expressions.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new CycConnection object using the default host name, default base port number and
     * binary communication mode.
     */
    public CycConnection () throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT, DEFAULT_COMMUNICATION_MODE);
    }

    /**
     * Constructs a new CycConnection object using a given host name, the given base port number, and
     * the given communication mode.
     *
     * @@param host the name of the computer hosting the OpenCyc server.
     * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     */
    public CycConnection (String hostName, int basePort, int communicationMode) throws IOException,
            UnknownHostException {
        this.hostName = hostName;
        this.basePort = basePort;
        asciiPort = basePort + ASCII_PORT_OFFSET;
        cfaslPort = basePort + CFASL_PORT_OFFSET;
        this.communicationMode = communicationMode;
        if ((communicationMode != ASCII_MODE) && (communicationMode != BINARY_MODE))
            throw  new RuntimeException("Invalid communication mode " + communicationMode);
        initializeApiConnections();
        if (trace) {
            if (communicationMode == ASCII_MODE)
                System.out.println("Ascii connection " + asciiSocket);
            else
                System.out.println("Binary connection " + cfaslSocket);
        }
    }

    /**
     * Initializes the OpenCyc ascii socket and the OpenCyc binary socket connections.
     */
    private void initializeApiConnections () throws IOException, UnknownHostException {
        if (communicationMode == ASCII_MODE) {
            asciiSocket = new Socket(hostName, asciiPort);
            in = new BufferedReader(new InputStreamReader(asciiSocket.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(asciiSocket.getOutputStream()));
        }
        else {
            cfaslSocket = new Socket(hostName, cfaslPort);
            cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream(), this);
            cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream(), this);
        }
    }

    /**
     * Close the cyc api sockets.
     */
    public void close () throws IOException {
        if (asciiSocket != null)
            asciiSocket.close();
        if (cfaslSocket != null)
            cfaslSocket.close();
    }

    /**
     * Send a message to Cyc and return the <tt>Boolean</tt> true as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element.  If an error occurs the first element is <tt>Boolean</tt>
     * false and the second element is the error message string.
     *
     * @@param message the api command
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    public Object[] converse (Object message) throws IOException {
        return  converse(message, notimeout);
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the second element is the error message string.
     *
     * @@param message the api command which must be a String or a CycList
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    public Object[] converse (Object message, Timer timeout) throws IOException, TimeOutException {
        if (communicationMode == CycConnection.ASCII_MODE) {
            String messageString;
            if (message instanceof String)
                messageString = (String) message;
            else if (message instanceof CycList)
                messageString = ((CycList) message).cyclify();
            else
                throw new RuntimeException("Invalid class for message " + message);
            return  converseAscii(messageString, timeout);
        }
        else {
            CycList messageCycList;
            if (message instanceof CycList)
                messageCycList = (CycList) message;
            else if (message instanceof String)
                messageCycList = this.cycAccess.makeCycList((String) message);
            else
                throw new RuntimeException("Invalid class for message " + message);
            return  converseBinary(messageCycList, timeout);
        }
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the second element is the error message string.
     *
     * @@param message the api command
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    synchronized protected Object[] converseBinary (Object message, Timer timeout)
        throws IOException, TimeOutException {
        sendBinary(message);
        return  receiveBinary();
    }

    /**
     * Sends an object to the CYC server.  If the connection is not already open, it is
     * opened.  The object must be a valid CFASL-translatable: an Integer, Float, Double,
     * Boolean, String, Symbol, ArrayList, or an implementor of the CfaslTranslatingObject.
     *
     * @@param message the api command
     */
    private void sendBinary (Object message) throws IOException {
        if (trace)
            System.out.println("send = " + message);
        cfaslOutputStream.writeObject(message);
        cfaslOutputStream.flush();
    }

    /**
     * Receives an object from the CYC server.
     *
     * @@return an array of two objects, the first is a Boolean response, and the second is the
     * response object or error string.
     */
    private Object[] receiveBinary () throws IOException {
        Object[] answer =  {
            null, null
        };
        if (cfaslInputStream.readObject() == null)
            answer[0] = Boolean.FALSE;
        else
            answer[0] = Boolean.TRUE;
        answer[1] = cfaslInputStream.readObject();
        if (trace)
            System.out.println("receive = (" + answer[0] + ") " + answer[1]);
        return  answer;
    }

    /**
     * Send a message to Cyc and return the Boolean response as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the first element is Boolean.FALSE and the second element
     * is the error message string.
     *
     * @@param message the api command
     * @@param timeout a <tt>Timer</tt> object giving the time limit for the api call
     * @@return an array of two objects, the first is an Integer response code, and the second is the
     * response object or error string.
     */
    synchronized protected Object[] converseAscii (String message, Timer timeout) throws IOException,
            TimeOutException {
        isSymbolicExpression = false;
        Object[] response = converseUsingStrings(message, timeout);
        if (response[0].equals(Boolean.TRUE)) {
            String answer = ((String)response[1]).trim();
            if (isSymbolicExpression)
                // Recurse if list contains CycConstant objects.
                response[1] = CycAccess.current().makeCycList(answer);
            else if (answer.equals("NIL"))
                response[1] = new CycList();
            else
                response[1] = answer;
        }
        return  response;
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of a object array, and the Cyc response string as the second
     * element.
     */
    protected Object[] converseUsingStrings (String message, Timer timeout) throws IOException, TimeOutException {
        if (trace)
            System.out.println(message + " --> cyc");
        out.write(message);
        if (!message.endsWith("\n"))
            out.newLine();
        out.flush();
        if (trace)
            System.out.print("cyc --> ");
        Object[] answer = readCycResponse(timeout);
        if (trace)
            System.out.println();
        return  answer;
    }

    /**
     * Read the cyc response.
     */
    private Object[] readCycResponse (Timer timeout) throws IOException, TimeOutException {
        Object[] answer =  {
            null, null
        };
        // Parse the response code digits.
        StringBuffer responseCodeDigits = new StringBuffer();
        while (true) {
            timeout.checkForTimeOut();
            int ch = in.read();
            if (trace)
                System.out.print((char)ch);
            if (ch == ' ')
                break;
            responseCodeDigits.append((char)ch);
        }
        int responseCode = (new Integer(responseCodeDigits.toString().trim())).intValue();
        if (responseCode == 200)
            answer[0] = Boolean.TRUE;
        else
            answer[0] = Boolean.FALSE;
        in.mark(1);
        int ch = in.read();
        in.reset();
        if (ch == '(') {
            isSymbolicExpression = true;
            answer[1] = readSymbolicExpression();
        }
        else if (ch == '"')
            answer[1] = readString();
        else
            answer[1] = readAtom();
        // Read the terminating newline.
        ch = in.read();
        if (trace)
            System.out.print((char)ch);
        return  answer;
    }

    /**
     * Read a symbolic expression.
     */
    private String readSymbolicExpression () throws IOException {
        int parenLevel = 0;
        boolean isQuotedString = false;
        StringBuffer result = new StringBuffer();
        int ch = in.read();
        if (trace)
            System.out.print((char)ch);
        parenLevel++;
        result.append((char)ch);
        while (parenLevel != 0) {
            ch = in.read();
            if (trace)
                System.out.print((char)ch);
            if (ch == '"')
                if (isQuotedString)
                    isQuotedString = false;
                else
                    isQuotedString = true;
            if (!isQuotedString) {
                if (ch == '(')
                    parenLevel++;
                if (ch == ')')
                    parenLevel--;
            }
            result.append((char)ch);
            if ((!isQuotedString) && (result.length() > 3) && (result.toString().endsWith(" . ")))
                // Convert lists of the form ( x y . z) into (x y z).
                result.setLength(result.length() - 2);
        }
        return  result.toString();
    }

    /**
     * Read a quoted string.
     */
    private String readString () throws IOException {
        StringBuffer result = new StringBuffer();
        int ch = in.read();
        if (trace)
            System.out.print((char)ch);
        while (true) {
            ch = in.read();
            if (trace)
                System.out.print((char)ch);
            if (ch == '"')
                return  result.toString();
            result.append((char)ch);
        }
    }

    /**
     * Read an atom.
     */
    private String readAtom () throws IOException {
        StringBuffer result = new StringBuffer();
        while (true) {
            in.mark(1);
            int ch = in.read();
            if (trace)
                System.out.print((char)ch);
            if (ch == '\n')
                break;
            result.append((char)ch);
        }
        in.reset();
        return  result.toString();
    }
}



@


1.4
log
@Added new binary api connection classes
@
text
@d1 457
a457 366
package org.opencyc.api;

import java.net.*;
import java.io.*;
import org.opencyc.util.*;
import org.opencyc.cycobject.*;

/**
 * Provides a binary connection and an ascii connection to the OpenCyc server.  The ascii connection is
 * legacy and its use is deprecated.<p>
 *
 * @@version $Id: CycConnection.java,v 1.3 2001/08/15 23:49:55 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class CycConnection {

    /**
     * Default host name for the OpenCyc server.
     */
    public static final String DEFAULT_HOSTNAME = "localhost";

    /**
     * Default base tcp port for the OpenCyc server.
     */
    public static final int DEFAULT_BASE_PORT = 3600;

    /**
     * HTTP port offset for the OpenCyc server.
     */
    public static final int HTTP_PORT_OFFSET = 0;

    /**
     * ASCII port offset for the OpenCyc server.
     */
    public static final int ASCII_PORT_OFFSET = 1;

    /**
     * CFASL (binary) port offset for the OpenCyc server.
     */
    public static final int CFASL_PORT_OFFSET = 14;

    /**
     * Parameter that, when true, causes a trace of the messages to and from the server.
     */
    public boolean trace = false;

    /**
     * The ascii interface input stream.
     */
    protected BufferedReader in;

    /**
     * The ascii interface output stream.
     */
    protected BufferedWriter out;

    /**
     * The binary interface input stream</tt>.
     */
    protected CfaslInputStream cfaslInputStream;

    /**
     * The binary interface output stream</tt>.
     */
    protected CfaslOutputStream cfaslOutputStream;

    /**
     * The name of the computer hosting the OpenCyc server.
     */
    protected String hostName;

    /**
     * The tcp port from which the asciiPort and cfaslPorts are derived.
     */
    protected int basePort;

    /**
     * The tcp port assigned to the the ascii connection to the OpenCyc server.
     */
    protected int asciiPort;

    /**
     * The tcp port assigned to the the binary connection to the OpenCyc server.
     */
    protected int cfaslPort;

    /**
     * The tcp socket assigned to the the ascii connection to the OpenCyc server.
     */
    protected Socket asciiSocket;

    /**
     * The tcp socket assigned to the the binary connection to the OpenCyc server.
     */
    protected Socket cfaslSocket;

    /**
     * The timer which optionally monitors the duration of requests to the OpenCyc server.
     */
    protected static final Timer notimeout = new Timer();

    /**
     * Indicates if the response from the OpenCyc server is a symbolic expression (enclosed in
     * parentheses).
     */
    protected boolean isSymbolicExpression = false;

    /**
     * A reference to the parent CycAccess object for dereferencing constants in ascii symbolic expressions.
     */
    protected CycAccess cycAccess;

    /**
     * Constructs a new CycConnection object using the default host name and base port number.
     */
    public CycConnection() throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, DEFAULT_BASE_PORT);
    }

    /**
     * Constructs a new CycConnection object using a given host name and the default base port number.
     *
     * @@param host the name of the computer hosting the OpenCyc server.
     */
    public CycConnection(String host)
        throws IOException, UnknownHostException {
        this(host, DEFAULT_BASE_PORT);
    }

    /**
     * Constructs a new CycConnection object using the default host name and a given base port number.
     *
     * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
     */
    public CycConnection(int basePort)
        throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, basePort);
    }

    /**
     * Constructs a new CycConnection object using a given host name and a given base port number.
     *
     * @@param host the name of the computer hosting the OpenCyc server.
     * @@param basePort the base tcp port on which the OpenCyc server is listening for connections.
     */
    public CycConnection(String hostName, int basePort)
        throws IOException, UnknownHostException {
        this.hostName = hostName;
        this.basePort = basePort;
        asciiPort = basePort + ASCII_PORT_OFFSET;
        cfaslPort = basePort + CFASL_PORT_OFFSET;
        initializeApiConnections();
        System.out.println("Connection " + asciiSocket);
        System.out.println("Connection " + cfaslSocket);
    }

    /**
     * Initializes the OpenCyc ascii socket and the OpenCyc binary socket connections.
     */
    private void initializeApiConnections() throws IOException, UnknownHostException {
        asciiSocket = new Socket(hostName, asciiPort);
        in = new BufferedReader(new InputStreamReader(asciiSocket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(asciiSocket.getOutputStream()));
        cfaslSocket = new Socket(hostName, cfaslPort);
        cfaslInputStream = new CfaslInputStream(cfaslSocket.getInputStream(), this);
        cfaslOutputStream = new CfaslOutputStream(cfaslSocket.getOutputStream(), this);
    }

    /**
     * Close the cyc api sockets.
     */
    public void close () throws IOException {
        if (asciiSocket != null)
            asciiSocket.close();
        if (cfaslSocket != null)
            cfaslSocket.close();
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element, spending no less time than the specified timer allows
     * but throwing a <code>TimeOutException</code> at the first opportunity
     * where that time limit is exceeded.
     * If an error occurs the second element is the error message string.
     */
    public Object[] converse(String message, Timer timeout)
      throws IOException, TimeOutException {
        isSymbolicExpression = false;
        Object [] response = converseUsingStrings(message, timeout);
        if (((Integer) response[0]).intValue() == 200) {
            String answer = ((String) response[1]).trim();
            if (isSymbolicExpression)
                // Recurse if list contains CycConstant objects.
                response[1] = CycAccess.current().makeCycList(answer);
            else if (answer.equals("NIL"))
                response[1] = new CycList();
            else
                response[1] = answer;
        }
        return response;
    }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of an object array, and the cyc response Symbolic Expression as
     * the second element.  If an error occurs the second element is the error
     * message string.
     */
  public Object[] converse(String message) throws IOException {
    return converse(message, notimeout);
  }

    /**
     * Send a message to Cyc and return the response code as the first
     * element of a object array, and the Cyc response string as the second
     * element.
     */
    private Object [] converseUsingStrings(String message, Timer timeout)
      throws IOException, TimeOutException {
        if (trace)
            System.out.println(message + " --> cyc");
        out.write(message);
        if (! message.endsWith("\n"))
            out.newLine();
        out.flush();
        if (trace)
            System.out.print("cyc --> ");
        Object [] answer = readCycResponse(timeout);
        if (trace)
            System.out.println();
        return answer;
    }

    /**
     * Read the cyc response.
     */
     private Object[] readCycResponse(Timer timeout) throws IOException, TimeOutException {
         Object [] answer = {new Integer(0), ""};
         // Parse the response code digits.
         StringBuffer responseCodeDigits = new StringBuffer();
         while (true) {
         timeout.checkForTimeOut();
             int ch = in.read();
             if (trace)
                 System.out.print((char) ch);
             if (ch == ' ')
                 break;
             responseCodeDigits.append((char) ch);
         }
         answer[0] = new Integer(responseCodeDigits.toString().trim());
         in.mark(1);
         int ch = in.read();
         in.reset();
         if (ch == '(') {
             isSymbolicExpression = true;
             answer[1] = readSymbolicExpression();
         }
         else if (ch == '"')
             answer[1] = readString();
         else
             answer[1] = readAtom();
         // Read the terminating newline.
         ch = in.read();
         if (trace)
             System.out.print((char) ch);
         return answer;
     }


    /**
     * Read a symbolic expression.
     */
    private String readSymbolicExpression() throws IOException {
        int parenLevel = 0;
        boolean isQuotedString = false;
        StringBuffer result = new StringBuffer();

        int ch = in.read();
        if (trace)
            System.out.print((char) ch);
        parenLevel++;
        result.append((char) ch);

        while (parenLevel != 0) {
            ch = in.read();
            if (trace)
                System.out.print((char) ch);
            if (ch == '"')
                if (isQuotedString)
                    isQuotedString = false;
            else
                isQuotedString = true;

            if (! isQuotedString) {
                if (ch == '(')
                    parenLevel++;
                if  (ch == ')')
                    parenLevel--;
            }
            result.append((char) ch);
            if ((! isQuotedString) &&
                (result.length() > 3) &&
                (result.toString().endsWith(" . ")))
                // Convert lists of the form ( x y . z) into (x y z).
                result.setLength(result.length() - 2);

        }
        return result.toString();
    }

    /**
     * Read a quoted string.
     */
    private String readString() throws IOException {
        StringBuffer result = new StringBuffer();
        int ch = in.read();
        if (trace)
            System.out.print((char) ch);

        while (true) {
            ch = in.read();
            if (trace)
                System.out.print((char) ch);
            if (ch == '"')
                return result.toString();
            result.append((char) ch);
        }
    }

    /**
     * Read an atom.
     */
    private String readAtom() throws IOException {
        StringBuffer result = new StringBuffer();
        while (true) {
            in.mark(1);
            int ch = in.read();
            if (trace)
                System.out.print((char) ch);
            if (ch == '\n')
                break;
            result.append((char) ch);
        }
        in.reset();
        return result.toString();
    }
}
@


1.3
log
@Cached CycAccess instances by thread and introduced European Cathedrals
constraint problem that evaluates its rules in OpenCyc.
@
text
@d9 2
a10 1
 * Provides a connection to the OpenCyc server.<p>
d12 1
a12 1
 * @@version $Id: CycConnection.java,v 1.2 2001/08/15 14:50:45 stephenreed Exp $
d35 19
a53 2
    public BufferedReader in;
    public BufferedWriter out;
d55 4
a58 5
    private CycAccess cycAccess;
    private Socket apiSocket;
    private String hostName;
    private int port;
    private static final Timer notimeout = new Timer();
d60 3
a62 2
    public static final String DEFAULT_HOSTNAME = "localhost";
    public static final int DEFAULT_PORT = 3601;
a63 1
    private boolean isSymbolicExpression = false;
d66 26
a91 1
     * Constructs a new CycConnection object.
d93 1
d95 39
d135 1
a135 1
        this(DEFAULT_HOSTNAME, DEFAULT_PORT);
d137 6
d145 1
a145 1
        this(host, DEFAULT_PORT);
d147 7
a153 1
    public CycConnection(int port)
d155 1
a155 1
        this(DEFAULT_HOSTNAME, port);
d157 8
a164 1
    public CycConnection(String hostName, int port)
d167 6
a172 3
        this.port = port;
        initializeApiConnection();
        System.out.println("Connection " + apiSocket);
d176 1
a176 1
     * Initialize a cyc api socket.
d178 7
a184 4
    private void initializeApiConnection() throws IOException, UnknownHostException {
        apiSocket = new Socket(hostName, DEFAULT_PORT);
        in = new BufferedReader(new InputStreamReader(apiSocket.getInputStream()));
        out = new BufferedWriter(new OutputStreamWriter(apiSocket.getOutputStream()));
d188 1
a188 1
     * Close the cyc api socket.
d191 4
a194 2
        if (apiSocket != null)
            apiSocket.close();
@


1.2
log
@Made CycAccess the factory object for CycLists
@
text
@d11 1
a11 1
 * @@version $Id: CycConnection.java,v 1.1 2001/08/14 23:49:56 stephenreed Exp $
d52 2
a53 2
    public CycConnection(CycAccess cycAccess) throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, DEFAULT_PORT, cycAccess);
d55 1
a55 1
    public CycConnection(String host, CycAccess cycAccess)
d57 1
a57 1
        this(host, DEFAULT_PORT, cycAccess);
d59 1
a59 1
    public CycConnection(int port, CycAccess cycAccess)
d61 1
a61 1
        this(DEFAULT_HOSTNAME, port, cycAccess);
d63 1
a63 1
    public CycConnection(String hostName, int port, CycAccess cycAccess)
a66 1
        this.cycAccess = cycAccess;
d104 1
a104 1
                response[1] = cycAccess.makeCycList(answer);
@


1.1
log
@Added OpenCyc server connection classes
@
text
@d11 1
a11 1
 * @@version $Id: UnitTest.java,v 1.3 2001/08/13 16:14:44 stephenreed Exp $
d37 1
d49 1
a49 1
     * Construct a new CycConnection object.
d52 2
a53 2
    public CycConnection() throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, DEFAULT_PORT);
d55 7
a61 2
    public CycConnection(String host) throws IOException, UnknownHostException {
        this(host, DEFAULT_PORT);
d63 2
a64 4
    public CycConnection(int port) throws IOException, UnknownHostException {
        this(DEFAULT_HOSTNAME, port);
    }
    public CycConnection(String hostName, int port) throws IOException, UnknownHostException {
d67 1
d104 2
a105 1
                response[1] = new CycList(answer);
@

