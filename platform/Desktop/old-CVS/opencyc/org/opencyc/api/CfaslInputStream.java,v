head	1.24;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.23.0.2
	OPENCYC_1_0_1:1.23
	PRE_1_0:1.21;
locks; strict;
comment	@# @;


1.24
date	2006.10.21.16.49.15;	author dmiles;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.18.14.21.33;	author dmiles;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.18.13.36.02;	author dmiles;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.04.21.12.46;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.02.13.59.26;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.10.21.14.01;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.23.20.17.19;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.27.19.51.19;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.17.00.32.47;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.14.01.15.16;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.24.17.00.29;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.22.17.03.15;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.03.21.30.37;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.14.22.14.55;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.07.23.43.03;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.03.22.30.50;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.28.23.52.15;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.28.10.05.25;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.27.14.39.27;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.27.02.30.53;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.24.22.39.27;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.23.09.33.13;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.23.00.47.45;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.23.28.16;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.api;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.util.HashMap;

import org.opencyc.cycobject.ByteArray;
import org.opencyc.cycobject.CycAssertion;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycNart;
import org.opencyc.cycobject.CycObject;
import org.opencyc.cycobject.CycSymbol;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.cycobject.Guid;
import org.opencyc.util.Log;


/**
 * A CFASL translating input stream.  All Java-native types which have logical sublisp equivalents
 * are translated automatically by this stream.  Classes implementing the CfaslTranslatingObject
 * interface are created using thier readObject() method.  Other CYC objects, such as
 * binding-lists and formulas, must be explicitly coerced using their static constructors.
 * 
 * @@version $Id: CfaslInputStream.java,v 1.28 2004/11/09 15:11:12 reed Exp $
 * @@author Stephen L. Reed <p><p><p><p><p>
 */
public class CfaslInputStream
  extends BufferedInputStream {
  /** No api trace. */
  public static final int API_TRACE_NONE = 0;

  /** Message-level api trace. */
  public static final int API_TRACE_MESSAGES = 1;

  /** Detailed api trace. */
  public static final int API_TRACE_DETAILED = 2;

  /** Parameter that, when true, causes a trace of the messages to and from the server. */
  public int trace = API_TRACE_NONE;

  /**
   * Parameter that when set true, causes CFASL object errors to be reported back as strings the
   * caller.
   */
  public boolean reportCfaslErrors = false;

  /** CFASL code */
  protected static final int CFASL_IMMEDIATE_FIXNUM_CUTOFF = 128;

  /** CFASL code */
  protected static final int CFASL_IMMEDIATE_FIXNUM_OFFSET = 256 - CFASL_IMMEDIATE_FIXNUM_CUTOFF;

  /** CFASL code */
  protected static final int CFASL_P_8BIT_INT = 0;

  /** CFASL code */
  protected static final int CFASL_N_8BIT_INT = 1;

  /** CFASL code */
  protected static final int CFASL_P_16BIT_INT = 2;

  /** CFASL code */
  protected static final int CFASL_N_16BIT_INT = 3;

  /** CFASL code */
  protected static final int CFASL_P_24BIT_INT = 4;

  /** CFASL code */
  protected static final int CFASL_N_24BIT_INT = 5;

  /** CFASL code */
  protected static final int CFASL_P_32BIT_INT = 6;

  /** DCFASL code */
  protected static final int CFASL_N_32BIT_INT = 7;

  /** DCFASL code */
  protected static final int CFASL_P_FLOAT = 8;

  /** CFASL code */
  protected static final int CFASL_N_FLOAT = 9;

  /** CFASL code */
  protected static final int CFASL_KEYWORD = 10;

  /** CFASL code */
  protected static final int CFASL_SYMBOL = 11;

  /** CFASL code */
  protected static final int CFASL_NIL = 12;

  /** CFASL code */
  protected static final int CFASL_LIST = 13;

  /** CFASL code */
  protected static final int CFASL_DOTTED = 17;

  /** CFASL code */
  protected static final int CFASL_VECTOR = 14;

  /** CFASL code */
  protected static final int CFASL_STRING = 15;

  /** CFASL code */
  protected static final int CFASL_CHARACTER = 16;

  /** CFASL code */
  protected static final int CFASL_HASHTABLE = 18;

  /** CFASL code */
  protected static final int CFASL_BTREE_LOW_HIGH = 19;

  /** CFASL code */
  protected static final int CFASL_BTREE_LOW = 20;

  /** CFASL code */
  protected static final int CFASL_BTREE_HIGH = 21;

  /** CFASL code */
  protected static final int CFASL_BTREE_LEAF = 22;

  /** CFASL code */
  protected static final int CFASL_P_BIGNUM = 23;

  /** CFASL code */
  protected static final int CFASL_N_BIGNUM = 24;

  /** CFASL code */
  protected static final int CFASL_GUID = 25;

  /** CFASL code */
  protected static final int CFASL_BYTE_VECTOR = 26;

  /** CFASL code */
  protected static final int CFASL_CONSTANT = 30;

  /** CFASL code */
  protected static final int CFASL_NART = 31;

  /** CFASL code */
  protected static final int CFASL_ASSERTION = 33;

  /** CFASL code */
  protected static final int CFASL_ASSERTION_SHELL = 34;

  /** CFASL code */
  protected static final int CFASL_ASSERTION_DEF = 35;

  /** CFASL code */
  protected static final int CFASL_SOURCE = 36;

  /** CFASL code */
  protected static final int CFASL_SOURCE_DEF = 37;

  /** CFASL code */
  protected static final int CFASL_AXIOM = 38;

  /** CFASL code */
  protected static final int CFASL_AXIOM_DEF = 39;

  /** CFASL code */
  protected static final int CFASL_VARIABLE = 40;

  /** CFASL code */
  protected static final int CFASL_INDEX = 41;

  /** CFASL code */
  protected static final int CFASL_SPECIAL_OBJECT = 50;

  /** CFASL code */
  protected static final int CFASL_EXTERNALIZATION = 51;

  /** CFASL code */
  protected static final int CFASL_UNICODE_CHAR = 52;

  /** CFASL code */
  protected static final int CFASL_UNICODE_STRING = 53;

  /** CFASL code */
  protected static final int CFASL_DICTIONARY = 64;

  /** CFASL code */
  protected static final int CFASL_SERVER_DEATH = -1;

  /** CFASL code */
  protected static final int DEFAULT_READ_LIMIT = 8192;
  static HashMap cfaslOpcodeDescriptions = null;

  /**
   * Initializes the opcode descriptions used in trace output.
   */
  protected void initializeOpcodeDescriptions() {
    cfaslOpcodeDescriptions = new HashMap();
    cfaslOpcodeDescriptions.put(new Integer(CFASL_IMMEDIATE_FIXNUM_CUTOFF), 
                                "CFASL_IMMEDIATE_FIXNUM_CUTOFF");
   
    cfaslOpcodeDescriptions.put(new Integer(CFASL_IMMEDIATE_FIXNUM_OFFSET), 
                                "CFASL_IMMEDIATE_FIXNUM_OFFSET");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_8BIT_INT), 
                                "CFASL_P_8BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_8BIT_INT), 
                                "CFASL_N_8BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_16BIT_INT), 
                                "CFASL_P_16BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_16BIT_INT), 
                                "CFASL_N_16BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_24BIT_INT), 
                                "CFASL_P_24BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_24BIT_INT), 
                                "CFASL_N_24BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_32BIT_INT), 
                                "CFASL_P_32BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_32BIT_INT), 
                                "CFASL_N_32BIT_INT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_FLOAT), 
                                "CFASL_P_FLOAT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_FLOAT), 
                                "CFASL_N_FLOAT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_KEYWORD), 
                                "CFASL_KEYWORD");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_SYMBOL), 
                                "CFASL_SYMBOL");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_NIL), 
                                "CFASL_NIL");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_LIST), 
                                "CFASL_LIST");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_VECTOR), 
                                "CFASL_VECTOR");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_STRING), 
                                "CFASL_STRING");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_CHARACTER), 
                                "CFASL_CHARACTER");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_DOTTED), 
                                "CFASL_DOTTED");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_HASHTABLE), 
                                "CFASL_HASHTABLE");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_BTREE_LOW_HIGH), 
                                "CFASL_BTREE_LOW_HIGH");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_BTREE_LOW), 
                                "CFASL_BTREE_LOW");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_BTREE_HIGH), 
                                "CFASL_BTREE_HIGH");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_BTREE_LEAF), 
                                "CFASL_BTREE_LEAF");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_P_BIGNUM), 
                                "CFASL_P_BIGNUM");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_N_BIGNUM), 
                                "CFASL_N_BIGNUM");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_GUID), 
                                "CFASL_GUID");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_BYTE_VECTOR), 
                                "CFASL_BYTE_VECTOR");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_CONSTANT), 
                                "CFASL_CONSTANT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_NART), 
                                "CFASL_NART");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_ASSERTION), 
                                "CFASL_ASSERTION");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_ASSERTION_SHELL), 
                                "CFASL_ASSERTION_SHELL");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_ASSERTION_DEF), 
                                "CFASL_ASSERTION_DEF");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_SOURCE), 
                                "CFASL_SOURCE");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_SOURCE_DEF), 
                                "CFASL_SOURCE_DEF");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_AXIOM), 
                                "CFASL_AXIOM");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_AXIOM_DEF), 
                                "CFASL_AXIOM_DEF");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_VARIABLE), 
                                "CFASL_VARIABLE");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_INDEX), 
                                "CFASL_INDEX");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_SPECIAL_OBJECT), 
                                "CFASL_SPECIAL_OBJECT");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_EXTERNALIZATION),
                                "CFASL_EXTERNALIZATION");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_UNICODE_CHAR), 
                                "CFASL_UNICODE_CHAR");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_UNICODE_STRING), 
                                "CFASL_UNICODE_STRING");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_DICTIONARY), 
                                "CFASL_DICTIONARY");
    
    cfaslOpcodeDescriptions.put(new Integer(CFASL_SERVER_DEATH), 
                                "CFASL_SERVER_DEATH");
  }

  /**
   * Creates a new CfaslInputStream to read data from the specified underlying input stream.
   * 
   * @@param in the underlying input stream.
   */
  public CfaslInputStream(InputStream in) {
    super(in, DEFAULT_READ_LIMIT);
    initializeOpcodeDescriptions();

    if (Log.current == null) {
      Log.makeLog("cfasl.log");
    }
  }

  /**
   * Reads an Object from this CfaslInputStream.  Basic Java types are wrapped as appropriate (e.g.
   * ints become Integer objects).  New constants are missing name and GUID values and will be
   * completed by the caller to avoid recursion within the api call.
   * 
   * @@return the object read from the binary OpenCyc input stream
   * 
   * @@throws IOException if a communications error occurs
   */
  public Object readObject()
                    throws IOException {
    int cfaslOpcode = read();

    if (cfaslOpcode == CFASL_EXTERNALIZATION) {
      if (trace == API_TRACE_DETAILED) {
        Log.current.println("reading opcode = " + cfaslOpcode + " (" + 
                            cfaslOpcodeDescriptions.get(
                                  new Integer(cfaslOpcode)) + ")");
      }

      cfaslOpcode = read();
    }

    Object o = null;

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("reading opcode = " + cfaslOpcode + " (" + 
                          cfaslOpcodeDescriptions.get(new Integer(
                                                            cfaslOpcode)) + ")");
    }

    if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
      o = new Integer(cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET);

      if (trace == API_TRACE_DETAILED) {
        Log.current.println("Reading Immediate Fixnum: " + o);
      }
    }
    else {
      switch (cfaslOpcode) {
      case CFASL_P_8BIT_INT:
        o = new Integer(readFixnumBody(1, 
                                       1));

        break;

      case CFASL_N_8BIT_INT:
        o = new Integer(readFixnumBody(1, 
                                       -1));

        break;

      case CFASL_P_16BIT_INT:
        o = new Integer(readFixnumBody(2, 
                                       1));

        break;

      case CFASL_N_16BIT_INT:
        o = new Integer(readFixnumBody(2, 
                                       -1));

        break;

      case CFASL_P_24BIT_INT:
        o = new Integer(readFixnumBody(3, 
                                       1));

        break;

      case CFASL_N_24BIT_INT:
        o = new Integer(readFixnumBody(3, 
                                       -1));

        break;

      case CFASL_P_32BIT_INT:
        o = new Integer(readFixnumBody(4, 
                                       1));

        break;

      case CFASL_N_32BIT_INT:
        o = new Integer(readFixnumBody(4, 
                                       -1));

        break;

      case CFASL_P_FLOAT:
        o = new Double(readFloatBody(1));

        break;

      case CFASL_N_FLOAT:
        o = new Double(readFloatBody(-1));

        break;

      case CFASL_P_BIGNUM:
        o = readBignumBody(1);

        break;

      case CFASL_N_BIGNUM:
        o = readBignumBody(-1);

        break;

      case CFASL_KEYWORD:

        // Keywords can be distinguished from Symbols by internal evidence
        o = readKeyword();

        break;

      case CFASL_SYMBOL:
        o = readSymbol();

        break;

      case CFASL_NIL:
        o = CycObjectFactory.nil;

        break;

      case CFASL_LIST:
        o = readCycList();

        break;

      case CFASL_DOTTED:
        o = readCons();

        break;

      case CFASL_VECTOR:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_STRING:

        int off = 0;
        int len = readInt();
        byte[] s = new byte[len];

        while (off < len) {
          off += read(s, 
                      off, 
                      len - off);
        }

        o = new String(s, 
                       "UTF-8");

        break;

      case CFASL_CHARACTER:
        o = new Character((char) read());

        break;

      case CFASL_HASHTABLE:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_BTREE_LOW_HIGH:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_BTREE_LOW:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_BTREE_HIGH:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_BTREE_LEAF:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_GUID:
        o = readGuid();
        break;

      case CFASL_UNICODE_STRING:
        o = readUnicodeString();
        break;

      case CFASL_UNICODE_CHAR:
        o = readUnicodeChar();
        break;

      case CFASL_BYTE_VECTOR:
        o = readByteArray();
      break;

      case CFASL_CONSTANT:
        o = readConstant();

        break;

      case CFASL_NART:
        o = readNart();

        break;

      case CFASL_ASSERTION:
        o = readAssertion();

        break;

      case CFASL_ASSERTION_SHELL:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_ASSERTION_DEF:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_SOURCE:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_SOURCE_DEF:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_AXIOM:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_AXIOM_DEF:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_VARIABLE:
        o = readVariable();

        break;

      case CFASL_INDEX:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_SPECIAL_OBJECT:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_DICTIONARY:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      case CFASL_SERVER_DEATH:
        return reportUnhandledCfaslOpcode(cfaslOpcode);

      default:
        return reportUnhandledCfaslOpcode(cfaslOpcode);
      }
    }

    if (trace == API_TRACE_DETAILED) {
      try {
        // If object o understands the safeToString method, then use it.
        Method safeToString = o.getClass().getMethod("safeToString", 
                                                     null);
        Log.current.println("readObject = " + safeToString.invoke(
                                                    o, 
                                                    null) + " (" + o.getClass() + ")");
      }
       catch (Exception e) {
        Log.current.println("readObject = " + o + " (" + o.getClass() + ")");
      }
    }

    return o;
  }

  /**
   * Reports the unhandled cfasl opcode or throws an exception.
   * 
   * @@param cfaslOpcode the unhandled cfasl opcode
   * 
   * @@return the unhandled cfasl opcode
   * 
   * @@throws CfaslInputStreamClosedException if the socket connection is closed by the peer
   * @@throws RuntimeException if the error is not logged and ignored
   */
  protected Object reportUnhandledCfaslOpcode(int cfaslOpcode) {
    String errorMessage;

    if (cfaslOpcode == -1) {
      throw new CfaslInputStreamClosedException("Cfasl connection closed by peer");
    }
    else {
      errorMessage = "Unknown cfasl opcode: " + cfaslOpcode;
    }

    if (reportCfaslErrors) {
      Log.current.println(errorMessage);

      return Integer.toString(cfaslOpcode);
    }
    else {
      //TODO create a new exception class for this case.
      throw new RuntimeException(errorMessage);
    }
  }

  /**
   * Reads an char from this CfaslInputStream.  If the next item on the stream is not a char, throw
   * an exception, and leave that object on the input stream.
   * 
   * @@return the character read
   * 
   * @@throws IOException if a communications error occurs
   * @@throws RuntimeException if an unexpected cfasl opcode occurs
   */
  public char readChar()
                throws IOException {
    mark(DEFAULT_READ_LIMIT);

    int cfaslOpcode = read();

    if (cfaslOpcode == CFASL_CHARACTER) {
      return (char) read();
    }

    reset();
    throw new RuntimeException("Expected a char but received opCode=" + cfaslOpcode);
  }

  /**
   * Reads a double from this CfaslInputStream.  If the next item on the stream is not a double,
   * throw an exception, and leave that object on the input stream.
   * 
   * @@return the double read
   * 
   * @@throws IOException if a communications error occurs
   * @@throws RuntimeException if an unexpected cfasl opcode occurs
   */
  public double readDouble()
                    throws IOException {
    mark(DEFAULT_READ_LIMIT);

    int cfaslOpcode = read();

    switch (cfaslOpcode) {
    case CFASL_P_FLOAT:
      return readFloatBody(1);

    case CFASL_N_FLOAT:
      return readFloatBody(-1);

    default:
      reset();
      throw new RuntimeException("Expected a double but received OpCode=" + cfaslOpcode);
    }
  }

  /**
   * Reads an int from this CfaslInputStream.  If the next item on the stream is not an int, throw
   * an exception, and leave that object on the input stream.  Bignum ints are not allowed.
   * 
   * @@return the int read
   * 
   * @@throws IOException if a communications error occurs
   * @@throws RuntimeException if an unexpected cfasl opcode occurs
   */
  public int readInt()
              throws IOException {
    mark(DEFAULT_READ_LIMIT);

    int cfaslOpcode = read();

    if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
      return cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET;
    }
    else {
      switch (cfaslOpcode) {
      case CFASL_P_8BIT_INT:
        return readFixnumBody(1, 
                              1);

      case CFASL_N_8BIT_INT:
        return readFixnumBody(1, 
                              -1);

      case CFASL_P_16BIT_INT:
        return readFixnumBody(2, 
                              1);

      case CFASL_N_16BIT_INT:
        return readFixnumBody(2, 
                              -1);

      case CFASL_P_24BIT_INT:
        return readFixnumBody(3, 
                              1);

      case CFASL_N_24BIT_INT:
        return readFixnumBody(3, 
                              -1);

      case CFASL_P_32BIT_INT:
        return readFixnumBody(4, 
                              1);

      case CFASL_N_32BIT_INT:
        return readFixnumBody(4, 
                              -1);

      default:
        reset();
        throw new RuntimeException("Expected an int but received OpCode=" + cfaslOpcode);
      }
    }
  }

  /**
   * Reads the body of a CFASL Fixnum (everything but the opcode) from this CFASL input stream.
   * 
   * @@param nBytes  The number of bytes to read
   * @@param sign    The sign of the Fixnum (-1 or +1)
   * 
   * @@return an int holding the CFASL Fixnum read in
   * 
   * @@throws IOException if a communications error occurs
   * @@throws ArithmeticException if nBytes > 4 or if the integer read in does not fit into a signed
   *         32 bit integer (i.e. the sign bit is being used for magnitude).
   */
  private int readFixnumBody(int nBytes, 
                             int sign)
                      throws IOException {
    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readFixnumBody sign=" + sign + " length=" + nBytes);
    }

    if (nBytes > 4) {
      throw new ArithmeticException("Cannot fit " + nBytes + " bytes into an int");
    }

    int num = 0;

    for (int i = 0; i < nBytes; i++) {
      int j = read();

      if (trace == API_TRACE_DETAILED) {
        Log.current.println("\t" + j);
      }

      num |= (j << (8 * i));
    }

    // num should always be positive here.  Negatives indicate overflows.
    if (num < 0) {
      throw new ArithmeticException("Overflow: " + ((long) num & 0xFFFFFFFFL) + 
                                    " does not fit into an int");
    }

    return (sign * num);
  }

  /**
   * Reads the body of a CFASL Bignum (everything but the opcode) off of this CFASL input stream.
   * 
   * @@param sign    The sign of the Bignum (-1 or +1)
   * 
   * @@return a BigInteger holding the CFASL Bignum read in
   * 
   * @@throws IOException if a communications error occurs
   */
  private BigInteger readBignumBody(int sign)
                             throws IOException {
    int length = readInt();

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readBignumBody sign=" + sign + " length=" + length);
    }

    byte[] b = new byte[length];

    for (int i = length - 1; i >= 0; i--) {
      int j = readInt();

      if (trace == API_TRACE_DETAILED) {
        Log.current.println("\t" + j);
      }

      b[i] = (byte) j;
    }

    return new BigInteger(sign, 
                          b);
  }

  /**
   * Reads the body of a CFASL Float (everything but the opcode) off of this CFASL input stream.
   * 
   * @@param sign    The sign of the Float (-1 or +1)
   * 
   * @@return a double holding the CFASL Float read in
   * 
   * @@throws IOException if a communications error occurs
   * @@throws ArithmeticException if significand cannot fit into a 64 bit signed long int
   */
  private double readFloatBody(int sign)
                        throws IOException {
    long signif;
    long exp;

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readFloatBody sign=" + sign);
    }

    Object obj = readObject();

    if (obj instanceof BigInteger) {
      BigInteger bi = (BigInteger) obj;

      if (bi.bitCount() < 64) {
        signif = bi.longValue();
      }
      else {
        throw new ArithmeticException("Overflow reading significand of float");
      }
    }
    else {
      signif = ((Number) obj).longValue();
    }

    exp = readInt();

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readFloatBody sign=" + sign + " signif=" + signif + " exp= " + exp);
    }

    return ((double) sign * (double) signif * Math.pow(
                                                    2.0, 
                                                    exp));
  }

  /**
   * Reads the body of a keyword Symbol from the CfaslInputStream.  The CFASL opcode has already
   * been read in at this point, so we only read in what follows.
   * 
   * @@return the keyword <tt>CycSymbol</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycSymbol readKeyword()
                        throws IOException {
    String keywordString = (String) readObject();

    if (!(keywordString.startsWith(":"))) {
      keywordString = ":" + keywordString;
    }

    return CycObjectFactory.makeCycSymbol(keywordString);
  }

  /**
   * Reads the body of a Symbol or EL variable from the CfaslInputStream.  The CFASL opcode has
   * already been read in at this point, so we only read in what follows.
   * 
   * @@return the <tt>CycSymbol</tt> or EL <tt>CycVariable</tt>
   * 
   * @@throws IOException if a communications error occurs
   */
  public Object readSymbol()
                    throws IOException {
    String name = (String) readObject();

    if (name.startsWith("?")) {
      return CycObjectFactory.makeCycVariable(name);
    }
    else {
      return CycObjectFactory.makeCycSymbol(name);
    }
  }

  /**
   * Reads the body of a Guid from the CfaslInputStream.  The CFASL opcode has already been read in
   * at this point, so we only read in what follows.
   * 
   * @@return the <tt>Guid</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public Guid readGuid()
                throws IOException {
    Guid guid = CycObjectFactory.makeGuid((String) readObject());

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readGuid: " + guid);
    }

    return guid;
  }

  /**
   * Reads the body of a Unicode Character from the CfaslInputStream.  
   * The CFASL opcode has already been read in
   * at this point, so we only read in what follows.
   * 
   * @@return the <tt>Integer</tt> of the unicode value read
   * 
   * @@throws IOException if a communications error occurs
   */
  public Integer readUnicodeChar()
                throws IOException {

    int off = 0;
    int len = readInt();
    byte[] s = new byte[len];
    

    while (off < len) {
      off += read(s, 
		  off, 
		  len - off);
    }

    String charString = new String(s, 
			       "UTF-8");
    int retval = (int)charString.charAt(0); 
    // NOTE: When we upgrade to java 1.5 change the above line to 
    //     int retval = charString.codePointAt(0);
    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readUnicodeChar: 0x" + Integer.toHexString(retval));
    }

    return new Integer(retval);
  }

  /**
   * Reads the body of a Unicode String from the CfaslInputStream.  
   * The CFASL opcode has already been read in
   * at this point, so we only read in what follows.
   * 
   * @@return the <tt>String</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public String readUnicodeString()
                throws IOException {
    int off = 0;
    int len = readInt();
    byte[] s = new byte[len];
    

    while (off < len) {
      off += read(s, 
		  off, 
		  len - off);
    }

    String retval = new String(s, 
			       "UTF-8");
    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readUnicodeString: " + retval);
    }

    return retval;
  }

  /**
   * Reads a byte vector from the CfaslInputStream. The CFASL opcode has already been read in at
   * this point, so we only read in what follows.
   * 
   * @@return the <tt>ByteArray</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public ByteArray readByteArray()
                          throws IOException {
    int off = 0;
    int len = readInt();
    byte[] bytes = new byte[len];

    while (off < len) {
      off += read(bytes, 
                  off, 
                  len - off);
    }

    return new ByteArray(bytes);
  }

  /**
   * Reads a list from the CfaslInputStream.  The CFASL opcode has already been read in at this
   * point, so we only read in what follows.
   * 
   * @@return the <tt>CycList</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycList readCycList()
                      throws IOException {
    int size = readInt();

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readCycList.size: " + size);
    }

    CycList cycList = new CycList();

    for (int i = 0; i < size; i++) {
      cycList.add(readObject());
    }

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readCycList.readObject: " + cycList.safeToString());
    }

    return cycList;
  }

  /**
   * Reads a dotted list from the CfaslInputStream.  The CFASL opcode has already been read in at
   * this point, so we only read in what follows.
   * 
   * @@return the <tt>CycList</tt> read
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycList readCons()
                   throws IOException {
    int size = readInt();

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readCons.size: " + size);
    }

    CycList cycList = new CycList();

    //for (int i = 0; i < (size - 1); i++) {
    for (int i = 0; i < size; i++) {
      Object consObject = readObject();

      if (trace == API_TRACE_DETAILED) {
        if (consObject instanceof CycFort)
          Log.current.println("readCons.consObject: " + ((CycFort) consObject).safeToString());
        else
          Log.current.println("readCons.consObject: " + consObject);
      }

      cycList.add(consObject);
    }

    Object cdrObject = readObject();

    if (trace == API_TRACE_DETAILED) {
        try {
          // If element understands the safeToString method, then use it.
          final Method safeToString = cdrObject.getClass().getMethod("safeToString", null);
          Log.current.println("readCons.cdrObject: " + safeToString.invoke(cdrObject, null));
        } catch (Exception e) {
          Log.current.println("readCons.cdrObject: " + cdrObject.toString());
        }
    }
    cycList.setDottedElement(cdrObject);

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readCons.readCons: " + cycList.safeToString());
    }

    return cycList;
  }

  /**
   * Reads a constant from a CfaslInputStream.
   * 
   * @@return an incomplete <tt>CycConstant</tt> having the input id or guid
   * 
   * @@throws IOException if a communications error occurs
   * @@throws RuntimeException if an unexpected constant id type occurs
   */
  public CycConstant readConstant()
                           throws IOException {
    CycConstant cycConstant = null;

    //cycConstant = new CycConstant();
    Object idObject = readObject();

    if (idObject instanceof Integer) {
      // deprecated legacy code support for SUIDs
      cycConstant = CycObjectFactory.getCycConstantCacheById((Integer) idObject);
      if (cycConstant == null) {
        cycConstant = new CycConstant();
        cycConstant.setId((Integer) idObject);
        CycObjectFactory.addCycConstantCacheById(cycConstant);
      }
    }
    else if (idObject instanceof Guid) {
      cycConstant = CycObjectFactory.getCycConstantCacheByGuid((Guid) idObject);
      if (cycConstant == null) {
        cycConstant = new CycConstant();
        cycConstant.setGuid((Guid) idObject);
        CycObjectFactory.addCycConstantCacheByGuid(cycConstant);
      }
    }
    else if ((idObject instanceof CycSymbol) && 
                 (idObject.equals(CycObjectFactory.makeCycSymbol(":FREE")))) {
      cycConstant = new CycConstant();
      cycConstant.setFree();
    }
    else {
      // Log.current.println("Unknown Constant ID type " + idObject + " (" + idObject.getClass() + ")");
      cycConstant = null;
    }

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readConstant: " + cycConstant.safeToString());
    }

    return cycConstant;
  }

  /**
   * Reads a variable from the CfaslInputStream.
   * 
   * @@return an incomplete <tt>CycVariable</tt> having the input id
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycVariable readVariable()
                           throws IOException {
    CycVariable cycVariable = new CycVariable();
    cycVariable.hlVariableId = new Integer(readInt());

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readVariable: " + cycVariable.safeToString());
    }

    return cycVariable;
  }

  /**
   * Reads a NART from a CfaslInputStream.
   * 
   * @@return a the CycNart having the input HL Formula or having the input id, or NIL if the nart is invalid
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycObject readNart()
                   throws IOException {
    CycNart cycNart = null;
    mark(10);

    int cfaslOpcode = read();

    if (cfaslOpcode == CFASL_LIST) {
      cycNart = new CycNart(readCycList());
    }
    else {
      if (trace == API_TRACE_DETAILED) {
        Log.current.println("readNart using id, cfasl opcode?: " + cfaslOpcode);
      }
      reset();
      cycNart = new CycNart();
      try {
        cycNart.setId(new Integer(readInt()));
      }
      catch (RuntimeException e) {
        if (cfaslOpcode == CFASL_NIL) {
          read();
          if (trace == API_TRACE_DETAILED)
            Log.current.println("readNart: invalid nart replaced with NIL");
          return CycObjectFactory.nil;
        }
        else
          throw new RuntimeException(e);
      }
    }

    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readNart: " + cycNart.safeToString());
    }

    return cycNart;
  }

  /**
   * Reads an assertion from a CfaslInputStream.
   * 
   * @@return an incomplete <tt>CycAssertion</tt> having the input id
   * 
   * @@throws IOException if a communications error occurs
   */
  public CycAssertion readAssertion()
                             throws IOException {
    CycList formula = (CycList) readObject();
    CycObject mt = (CycObject) readObject();
    CycAssertion cycAssertion = new CycAssertion(formula, mt);
    if (trace == API_TRACE_DETAILED) {
      Log.current.println("readAssertion: " + cycAssertion.safeToString());
    }

    return cycAssertion;
  }
}
@


1.23
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@a5 1

a6 1

a7 1

d10 10
a19 2
import org.opencyc.cycobject.*;

d29 1
a29 1
 * @@version $Id: CfaslInputStream.java,v 1.33 2005/09/15 20:58:10 reed Exp $
d101 3
a112 3
  protected static final int CFASL_DOTTED = 17;

  /** CFASL code */
a145 3
  protected static final int CFASL_COMPLETE_CONSTANT = 32;

  /** CFASL code */
a172 3
  protected static final int CFASL_COMPLETE_VARIABLE = 42;

  /** CFASL code */
d193 1
a193 4
  
  /** indicator that the input contains something invalid, for example an invalid constant */
  protected boolean isInvalidObject = false;
  
a291 3
    cfaslOpcodeDescriptions.put(new Integer(CFASL_COMPLETE_CONSTANT), 
                                "CFASL_COMPLETE_CONSTANT");
    
a318 3
    cfaslOpcodeDescriptions.put(new Integer(CFASL_COMPLETE_VARIABLE), 
                                "CFASL_COMPLETE_VARIABLE");
    
d337 1
a337 1
  
a351 13
  /** Gets the indicator that the input contains something invalid, for example an invalid constant.
   *
   * @@return the indicator that the input contains something invalid, for example an invalid constant
   */
  public boolean isInvalidObject() {
    return isInvalidObject;
  }
  
  /** Resets the indicator that the input contains something invalid, for example an invalid constant.  */
  public void resetIsInvalidObject() {
    isInvalidObject = false;
  }
  
d544 3
a546 1
        return reportUnhandledCfaslOpcode(cfaslOpcode);
a552 5
      case CFASL_COMPLETE_CONSTANT:
        o = readCompleteConstant();

        break;

d577 4
a580 2
        return reportUnhandledCfaslOpcode(cfaslOpcode);
        
a583 5
      case CFASL_COMPLETE_VARIABLE:
        o = readCompleteVariable();

        break;

d1049 1
a1049 1
      Log.current.println("readCycList.readObject: " + cycList.toString());
d1079 1
a1079 1
          Log.current.println("readCons.consObject: " + ((CycFort) consObject).toString());
d1101 1
a1101 1
      Log.current.println("readCons.readCons: " + cycList.toString());
d1108 1
a1108 1
   * Reads a complete constant from a CfaslInputStream.
d1110 1
a1110 1
   * @@return an complete <tt>CycConstant</tt> having the input guid and name
d1115 1
a1115 1
  public CycConstant readCompleteConstant()
d1118 2
d1122 16
a1137 6
    if (idObject instanceof Guid) {
      final Guid guid = (Guid) idObject;
      final String name = (String) readObject();
      cycConstant = CycObjectFactory.getCycConstantCacheByGuid(guid);
      if (cycConstant == null)
        cycConstant = new CycConstant(name, guid);
d1141 2
a1142 1
      cycConstant = CycObjectFactory.FREE_CONSTANT;
d1145 2
a1146 4
      // ignore the name, which is expected to be blank
      readObject();
      cycConstant = CycObjectFactory.INVALID_CONSTANT;
      isInvalidObject = true;
d1150 1
a1150 1
      Log.current.println("readConstant: " + cycConstant.toString());
d1159 1
a1159 1
   * @@return an complete <tt>CycVariable</tt> having the name
d1163 1
a1163 1
  public CycVariable readCompleteVariable()
d1165 6
a1170 5
    final Integer hlVariableId = (Integer) readObject();
    final String name = (String) readObject();
    CycVariable cycVariable = new CycVariable(name, hlVariableId);
    if (trace == API_TRACE_DETAILED) 
      Log.current.println("readVariable: " + cycVariable.toString());
d1185 2
d1189 21
a1209 8
    if (cfaslOpcode == CFASL_NIL) {
        cycNart = CycObjectFactory.INVALID_NART;
        isInvalidObject = true;
    }
    else if (cfaslOpcode != CFASL_LIST) {
      if (cfaslOpcode == CFASL_SYMBOL) {
        String name = (String) readObject();
        System.err.println("readNart, symbol=" + name);
a1210 1
      throw new RuntimeException("reading nart, expected a list, found " + cfaslOpcode);
a1211 2
    else 
      cycNart = new CycNart(readCycList());
d1213 3
a1215 2
    if (trace == API_TRACE_DETAILED)
      Log.current.println("readNart: " + cycNart.toString());
d1229 3
a1231 20
    CycList formula = null;
    Object formulaObject = null;
    CycAssertion cycAssertion = null;
      formulaObject = readObject();
      if (formulaObject.toString().equals("NIL")) {
        // bypass invalid assertion mt
        readObject();
        cycAssertion = CycObjectFactory.INVALID_ASSERTION;
        isInvalidObject = true;
      }
      else {
      try {
        formula = (CycList) formulaObject;
        CycObject mt = (CycObject) readObject();
        cycAssertion = new CycAssertion(formula, mt);
        }
        catch (ClassCastException e) {
          System.err.println("formulaObject " + formulaObject.toString() + "(" + formulaObject.getClass().getName() + ")");
        }
      }
d1233 1
a1233 1
      Log.current.println("readAssertion: " + cycAssertion.toString());
@


1.22
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@@


1.21
log
@Added Log class to the api package classes.
@
text
@d1 15
a15 1
package  org.opencyc.api;
a16 6
import  java.io.*;
import  java.math.BigInteger;
import  java.util.HashMap;
import  java.lang.reflect.*;
import  org.opencyc.cycobject.*;
import  org.opencyc.util.*;
d19 7
a25 26
 * A CFASL translating input stream.  All Java-native types which have logical
 * sublisp equivalents are translated automatically by this stream.  Classes
 * implementing the CfaslTranslatingObject interface are created using thier
 * readObject() method.  Other CYC objects, such as binding-lists and formulas,
 * must be explicitly coerced using their static constructors.
 *
 * @@version $Id: CfaslInputStream.java,v 1.10 2002/10/04 17:37:19 reed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d27 391
a417 1
public class CfaslInputStream extends BufferedInputStream {
d419 104
a522 155
    /**
     * No api trace.
     */
    public static final int API_TRACE_NONE = 0;

    /**
     * Message-level api trace.
     */
    public static final int API_TRACE_MESSAGES = 1;

    /**
     * Detailed api trace.
     */
    public static final int API_TRACE_DETAILED = 2;

    /**
     * Parameter that, when true, causes a trace of the messages to and from the server.
     */
    public int trace = API_TRACE_NONE;

    /**
     * Parameter that when set true, causes CFASL object errors to be reported back as strings
     * the caller.
     */
    public boolean reportCfaslErrors = false;

    protected static final int CFASL_IMMEDIATE_FIXNUM_CUTOFF = 128;
    protected static final int CFASL_IMMEDIATE_FIXNUM_OFFSET = 256 - CFASL_IMMEDIATE_FIXNUM_CUTOFF;
    protected static final int CFASL_P_8BIT_INT = 0;
    protected static final int CFASL_N_8BIT_INT = 1;
    protected static final int CFASL_P_16BIT_INT = 2;
    protected static final int CFASL_N_16BIT_INT = 3;
    protected static final int CFASL_P_24BIT_INT = 4;
    protected static final int CFASL_N_24BIT_INT = 5;
    protected static final int CFASL_P_32BIT_INT = 6;
    protected static final int CFASL_N_32BIT_INT = 7;
    protected static final int CFASL_P_FLOAT = 8;
    protected static final int CFASL_N_FLOAT = 9;
    protected static final int CFASL_KEYWORD = 10;
    protected static final int CFASL_SYMBOL = 11;
    protected static final int CFASL_NIL = 12;
    protected static final int CFASL_LIST = 13;
    protected static final int CFASL_DOTTED = 17;
    protected static final int CFASL_VECTOR = 14;
    protected static final int CFASL_STRING = 15;
    protected static final int CFASL_CHARACTER = 16;
    protected static final int CFASL_HASHTABLE = 18;
    protected static final int CFASL_BTREE_LOW_HIGH = 19;
    protected static final int CFASL_BTREE_LOW = 20;
    protected static final int CFASL_BTREE_HIGH = 21;
    protected static final int CFASL_BTREE_LEAF = 22;
    protected static final int CFASL_P_BIGNUM = 23;
    protected static final int CFASL_N_BIGNUM = 24;
    protected static final int CFASL_GUID = 25;
    protected static final int CFASL_BYTE_VECTOR = 26;
    protected static final int CFASL_CONSTANT = 30;
    protected static final int CFASL_NART = 31;
    protected static final int CFASL_ASSERTION = 33;
    protected static final int CFASL_ASSERTION_SHELL = 34;
    protected static final int CFASL_ASSERTION_DEF = 35;
    protected static final int CFASL_SOURCE = 36;
    protected static final int CFASL_SOURCE_DEF = 37;
    protected static final int CFASL_AXIOM = 38;
    protected static final int CFASL_AXIOM_DEF = 39;
    protected static final int CFASL_VARIABLE = 40;
    protected static final int CFASL_INDEX = 41;
    protected static final int CFASL_SPECIAL_OBJECT = 50;
    protected static final int CFASL_DICTIONARY = 64;
    protected static final int CFASL_SERVER_DEATH = -1;
    protected static final int DEFAULT_READ_LIMIT = 1024;

    static HashMap cfaslOpcodeDescriptions = null;

    /**
     * Initializes the opcode descriptions used in trace output.
     */
    protected void initializeOpcodeDescriptions() {
        cfaslOpcodeDescriptions = new HashMap();
        cfaslOpcodeDescriptions.put(new Integer(128), "CFASL_IMMEDIATE_FIXNUM_CUTOFF");
        cfaslOpcodeDescriptions.put(new Integer(256 - CFASL_IMMEDIATE_FIXNUM_CUTOFF),
                                    "CFASL_IMMEDIATE_FIXNUM_OFFSET");
        cfaslOpcodeDescriptions.put(new Integer(0), "CFASL_P_8BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(1), "CFASL_N_8BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(2), "CFASL_P_16BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(3), "CFASL_N_16BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(4), "CFASL_P_24BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(5), "CFASL_N_24BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(6), "CFASL_P_32BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(7), "CFASL_N_32BIT_INT");
        cfaslOpcodeDescriptions.put(new Integer(8), "CFASL_P_FLOAT");
        cfaslOpcodeDescriptions.put(new Integer(9), "CFASL_N_FLOAT");
        cfaslOpcodeDescriptions.put(new Integer(10), "CFASL_KEYWORD");
        cfaslOpcodeDescriptions.put(new Integer(11), "CFASL_SYMBOL");
        cfaslOpcodeDescriptions.put(new Integer(12), "CFASL_NIL");
        cfaslOpcodeDescriptions.put(new Integer(13), "CFASL_LIST");
        cfaslOpcodeDescriptions.put(new Integer(14), "CFASL_VECTOR");
        cfaslOpcodeDescriptions.put(new Integer(15), "CFASL_STRING");
        cfaslOpcodeDescriptions.put(new Integer(16), "CFASL_CHARACTER");
        cfaslOpcodeDescriptions.put(new Integer(17), "CFASL_DOTTED");
        cfaslOpcodeDescriptions.put(new Integer(18), "CFASL_HASHTABLE");
        cfaslOpcodeDescriptions.put(new Integer(19), "CFASL_BTREE_LOW_HIGH");
        cfaslOpcodeDescriptions.put(new Integer(20), "CFASL_BTREE_LOW");
        cfaslOpcodeDescriptions.put(new Integer(21), "CFASL_BTREE_HIGH");
        cfaslOpcodeDescriptions.put(new Integer(22), "CFASL_BTREE_LEAF");
        cfaslOpcodeDescriptions.put(new Integer(23), "CFASL_P_BIGNUM");
        cfaslOpcodeDescriptions.put(new Integer(24), "CFASL_N_BIGNUM");
        cfaslOpcodeDescriptions.put(new Integer(25), "CFASL_GUID");
        cfaslOpcodeDescriptions.put(new Integer(26), "CFASL_BYTE_VECTOR");
        cfaslOpcodeDescriptions.put(new Integer(30), "CFASL_CONSTANT");
        cfaslOpcodeDescriptions.put(new Integer(31), "CFASL_NART");
        cfaslOpcodeDescriptions.put(new Integer(33), "CFASL_ASSERTION");
        cfaslOpcodeDescriptions.put(new Integer(34), "CFASL_ASSERTION_SHELL");
        cfaslOpcodeDescriptions.put(new Integer(35), "CFASL_ASSERTION_DEF");
        cfaslOpcodeDescriptions.put(new Integer(36), "CFASL_SOURCE");
        cfaslOpcodeDescriptions.put(new Integer(37), "CFASL_SOURCE_DEF");
        cfaslOpcodeDescriptions.put(new Integer(38), "CFASL_AXIOM");
        cfaslOpcodeDescriptions.put(new Integer(39), "CFASL_AXIOM_DEF");
        cfaslOpcodeDescriptions.put(new Integer(40), "CFASL_VARIABLE");
        cfaslOpcodeDescriptions.put(new Integer(41), "CFASL_INDEX");
        cfaslOpcodeDescriptions.put(new Integer(50), "CFASL_SPECIAL_OBJECT");
        cfaslOpcodeDescriptions.put(new Integer(64), "CFASL_DICTIONARY");
        cfaslOpcodeDescriptions.put(new Integer(-1), "CFASL_SERVER_DEATH");
    }

    /**
     * Creates a new CfaslInputStream to read data from the
     * specified underlying input stream.
     *
     * @@param in the underlying input stream.
     */
    public CfaslInputStream (InputStream in) {
        super(in, DEFAULT_READ_LIMIT);
        initializeOpcodeDescriptions();
        if (Log.current == null)
            Log.makeLog("cyc-api.log");
    }

    /**
     * Reads an Object from this CfaslInputStream.  Basic Java types are
     * wrapped as appropriate (e.g. ints become Integer objects).  New constants are missing
     * name and GUID values and will be completed by the caller to avoid recursion within the
     * api call.
     *
     * @@return the object read from the binary OpenCyc input stream
     */
    public Object readObject () throws IOException {
        int cfaslOpcode = read();
        Object o = null;
        if (trace == API_TRACE_DETAILED)
            Log.current.println("reading opcode = " + cfaslOpcode + " (" +
                               cfaslOpcodeDescriptions.get(new Integer(cfaslOpcode)) +")");
        if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
            o = new Integer(cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET);
            if (trace == API_TRACE_DETAILED)
                Log.current.println("Reading Immediate Fixnum: " + o);
d524 199
a722 136
        else {
            switch (cfaslOpcode) {
                case CFASL_P_8BIT_INT:
                    o = new Integer(readFixnumBody(1, 1));
                    break;
                case CFASL_N_8BIT_INT:
                    o = new Integer(readFixnumBody(1, -1));
                    break;
                case CFASL_P_16BIT_INT:
                    o = new Integer(readFixnumBody(2, 1));
                    break;
                case CFASL_N_16BIT_INT:
                    o = new Integer(readFixnumBody(2, -1));
                    break;
                case CFASL_P_24BIT_INT:
                    o = new Integer(readFixnumBody(3, 1));
                    break;
                case CFASL_N_24BIT_INT:
                    o = new Integer(readFixnumBody(3, -1));
                    break;
                case CFASL_P_32BIT_INT:
                    o = new Integer(readFixnumBody(4, 1));
                    break;
                case CFASL_N_32BIT_INT:
                    o = new Integer(readFixnumBody(4, -1));
                    break;
                case CFASL_P_FLOAT:
                    o = new Double(readFloatBody(1));
                    break;
                case CFASL_N_FLOAT:
                    o = new Double(readFloatBody(-1));
                    break;
                case CFASL_P_BIGNUM:
                    o = readBignumBody(1);
                    break;
                case CFASL_N_BIGNUM:
                    o = readBignumBody(-1);
                    break;
                case CFASL_KEYWORD:
                    // Keywords can be distinguished from Symbols by internal evidence
                    o = readKeyword();
                    break;
                case CFASL_SYMBOL:
                    o = readSymbol();
                    break;
                case CFASL_NIL:
                    o = CycObjectFactory.nil;
                    break;
                case CFASL_LIST:
                    o = readCycList();
                    break;
                case CFASL_DOTTED:
                    o = readCons();
                    break;
                case CFASL_VECTOR:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_STRING:
                    int off = 0;
                    int len = readInt();
                    byte s[] = new byte[len];
                    while (off < len) {
                        off += read(s, off, len - off);
                    }
                    //o = new String(s);
                    /**
                     * Enable when/if UTF-8 is supported by Cyc
                     */
                    o = new String(s, "UTF-8");
                    break;
                case CFASL_CHARACTER:
                    o = new Character((char)read());
                    break;
                case CFASL_HASHTABLE:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_BTREE_LOW_HIGH:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_BTREE_LOW:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_BTREE_HIGH:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_BTREE_LEAF:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_GUID:
                    o = readGuid();
                    break;
                case CFASL_BYTE_VECTOR:
                o = readByteArray();
                    break;
                case CFASL_CONSTANT:
                    o = readConstant();
                    break;
                case CFASL_NART:
                    o = readNart();
                    break;
                case CFASL_ASSERTION:
                    o = readAssertion();
                    break;
                case CFASL_ASSERTION_SHELL:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_ASSERTION_DEF:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_SOURCE:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_SOURCE_DEF:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_AXIOM:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_AXIOM_DEF:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_VARIABLE:
                    o = readVariable();
                    break;
                case CFASL_INDEX:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_SPECIAL_OBJECT:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_DICTIONARY:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                case CFASL_SERVER_DEATH:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
                default:
                    return reportUnhandledCfaslOpcode(cfaslOpcode);
            }
        }
        if (trace == API_TRACE_DETAILED) {
            try {
                // If object o understands the safeToString method, then use it.
                Method safeToString = o.getClass().getMethod("safeToString", null);
                Log.current.println("readObject = " + safeToString.invoke(o, null) +
                                   " (" + o.getClass() + ")");
            }
            catch (Exception e) {
                Log.current.println("readObject = " + o + " (" + o.getClass() + ")");
            }
        }
        return  o;
d724 1
d726 17
a742 15
    /**
     * Reports the unhandled cfasl opcode or throws an exception.
     */
    protected Object reportUnhandledCfaslOpcode (int cfaslOpcode) {
        String errorMessage;
        if (cfaslOpcode == -1)
            errorMessage = "Cyc server closed the connection";
        else
            errorMessage = "Unknown cfasl opcode: " + cfaslOpcode;
        if (reportCfaslErrors) {
            Log.current.println(errorMessage);
            return Integer.toString(cfaslOpcode);
        }
        else
            throw  new RuntimeException(errorMessage);
d744 33
d778 1
a778 12
    /**
     * Reads an char from this CfaslInputStream.  If the next item
     * on the stream is not a char, throw an exception, and leave
     * that object on the input stream.
     *
     * @@return the character read
     */
    public char readChar () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        if (cfaslOpcode == CFASL_CHARACTER)
            return  (char)read();
d780 121
a900 1
        throw  new RuntimeException("Expected a char but received opCode=" + cfaslOpcode);
d903 58
a960 19
    /**
     * Reads a double from this CfaslInputStream.  If the next item
     * on the stream is not a double, throw an exception, and leave
     * that object on the input stream.
     *
     * @@return the double read
     */
    public double readDouble () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        switch (cfaslOpcode) {
            case CFASL_P_FLOAT:
                return  readFloatBody(1);
            case CFASL_N_FLOAT:
                return  readFloatBody(-1);
            default:
                reset();
                throw  new RuntimeException("Expected a double but received OpCode=" + cfaslOpcode);
        }
d963 24
a986 36
    /**
     * Reads an int from this CfaslInputStream.  If the next item
     * on the stream is not an int, throw an exception, and leave
     * that object on the input stream.  Bignum ints are not allowed.
     *
     * @@return the int read
     */
    public int readInt () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
            return  cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET;
        }
        else {
            switch (cfaslOpcode) {
                case CFASL_P_8BIT_INT:
                    return  readFixnumBody(1, 1);
                case CFASL_N_8BIT_INT:
                    return  readFixnumBody(1, -1);
                case CFASL_P_16BIT_INT:
                    return  readFixnumBody(2, 1);
                case CFASL_N_16BIT_INT:
                    return  readFixnumBody(2, -1);
                case CFASL_P_24BIT_INT:
                    return  readFixnumBody(3, 1);
                case CFASL_N_24BIT_INT:
                    return  readFixnumBody(3, -1);
                case CFASL_P_32BIT_INT:
                    return  readFixnumBody(4, 1);
                case CFASL_N_32BIT_INT:
                    return  readFixnumBody(4, -1);
                default:
                    reset();
                    throw  new RuntimeException("Expected an int but received OpCode=" + cfaslOpcode);
            }
        }
d989 7
a995 48
    /**
     * Reads the body of a CFASL Fixnum (everything but the opcode)
     * from this CFASL input stream.
     *
     * @@param nBytes  The number of bytes to read
     * @@param sign    The sign of the Fixnum (-1 or +1)
     * @@return an int holding the CFASL Fixnum read in
     * @@throws ArithmeticException if nBytes > 4 or if the integer read in does
     *         not fit into a signed 32 bit integer (i.e. the sign bit is being
     *         used for magnitude).
     */
    private int readFixnumBody (int nBytes, int sign) throws IOException {
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readFixnumBody sign=" + sign + " length=" + nBytes);
        if (nBytes > 4)
            throw  new ArithmeticException("Cannot fit " + nBytes + " bytes into an int");
        int num = 0;
        for (int i = 0; i < nBytes; i++) {
            int j = read();
            if (trace == API_TRACE_DETAILED)
                Log.current.println("\t" + j);
            num |= (j << (8*i));
        }
        // num should always be positive here.  Negatives indicate overflows.
        if (num < 0)
            throw  new ArithmeticException("Overflow: " + ((long)num & 0xFFFFFFFFL) + " does not fit into an int");
        return  (sign*num);
    }

    /**
     * Reads the body of a CFASL Bignum (everything but the opcode)
     * off of this CFASL input stream.
     *
     * @@param sign    The sign of the Bignum (-1 or +1)
     * @@return a BigInteger holding the CFASL Bignum read in
     */
    private BigInteger readBignumBody (int sign) throws IOException {
        int length = readInt();
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readBignumBody sign=" + sign + " length=" + length);
        byte b[] = new byte[length];
        for (int i = length - 1; i >= 0; i--) {
            int j = readInt();
            if (trace == API_TRACE_DETAILED)
                Log.current.println("\t" + j);
            b[i] = (byte)j;
        }
        return  new BigInteger(sign, b);
d998 23
a1020 50
    /**
     * Reads the body of a CFASL Float (everything but the opcode)
     * off of this CFASL input stream.
     *
     * @@param sign    The sign of the Float (-1 or +1)
     * @@return a double holding the CFASL Float read in
     * @@throws ArithmeticException if significand cannot fit into a 64 bit signed long int
     */
    private double readFloatBody (int sign) throws IOException {
        long signif, exp;
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readFloatBody sign=" + sign);
        Object obj = readObject();
        if (obj instanceof BigInteger) {
            BigInteger bi = (BigInteger)obj;
            if (bi.bitCount() < 64)
                signif = bi.longValue();
            else
                throw  new ArithmeticException("Overflow reading significand of float");
        }
        else
            signif = ((Number)obj).longValue();
        exp = readInt();
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readFloatBody sign=" + sign + " signif=" + signif + " exp= " + exp);
        return  ((double)sign*(double)signif*Math.pow(2.0, exp));
    }

    /**
     * Reads the body of a keyword Symbol from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the keyword <tt>CycSymbol</tt> read
     */
    public CycSymbol readKeyword () throws IOException {
        return  CycObjectFactory.makeCycSymbol(":" + (String)readObject());
    }

    /**
     * Reads the body of a Symbol or EL variable from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycSymbol</tt> or EL <tt>CycVariable</tt>
     */
    public Object readSymbol () throws IOException {
        String name = (String) readObject();
        if (name.startsWith("?"))
            return  CycObjectFactory.makeCycVariable(name);
        else
            return  CycObjectFactory.makeCycSymbol(name);
d1023 4
a1026 11
    /**
     * Reads the body of a Guid from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>Guid</tt> read
     */
    public Guid readGuid () throws IOException {
        Guid guid = CycObjectFactory.makeGuid((String)readObject());
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readGuid: " + guid);
        return guid;
d1029 3
d1033 3
a1035 3
   * Reads a byte vector from the CfaslInputStream. The CFASL opcode
   * has already been read in at this point, so we only read in what follows.
   *
d1037 2
d1040 2
a1041 1
  public ByteArray readByteArray() throws IOException {
d1045 1
d1047 3
a1049 1
      off += read(bytes, off, len - off);
d1051 1
d1055 70
a1124 13
    /**
     * Reads a list from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycList</tt> read
     */
    public CycList readCycList () throws IOException {
        int size = readInt();
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readCycList.size: " + size);
        CycList cycList = new CycList();
        for (int i = 0; i < size; i++) {
            cycList.add(readObject());
d1126 39
a1164 81
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readCycList.readObject: " + cycList.safeToString());
        return  cycList;
    }

    /**
     * Reads a dotted list from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycList</tt> read
     */
    public CycList readCons () throws IOException {
        int size = readInt();
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readCons.size: " + size);
        CycList cycList = new CycList();
        //for (int i = 0; i < (size - 1); i++) {
        for (int i = 0; i < size; i++) {
            Object consObject = readObject();
            if (trace == API_TRACE_DETAILED)
                Log.current.println("readCons.consObject: " + consObject);
            cycList.add(consObject);
        }
        Object cdrObject = readObject();
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readCons.cdrObject: " + cdrObject);
        cycList.setDottedElement(cdrObject);
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readCons.readCons: " + cycList);
        return  cycList;
    }

    /**
     * Reads a constant from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycConstant</tt> having the input id
     */
    public CycConstant readConstant () throws IOException {
        CycConstant cycConstant = new CycConstant();
        cycConstant.setId(new Integer(readInt()));
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readConstant: " + cycConstant.safeToString());
        return  cycConstant;
    }

    /**
     * Reads a variable from the CfaslInputStream.
     *
     * @@return an incomplete <tt>CycVariable</tt> having the input id
     */
    public CycVariable readVariable () throws IOException {
        CycVariable cycVariable = new CycVariable();
        cycVariable.id = new Integer(readInt());
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readVariable: " + cycVariable.safeToString());
        return  cycVariable;
    }

    /**
     * Reads a NART from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycConstant</tt> having the input id
     */
    public CycNart readNart () throws IOException {
        CycNart cycNart = new CycNart();
        cycNart.setId(new Integer(readInt()));
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readNart: " + cycNart.safeToString());
        return  cycNart;
    }

    /**
     * Reads an assertion from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycAssertion</tt> having the input id
     */
    public CycAssertion readAssertion () throws IOException {
        CycAssertion cycAssertion = new CycAssertion(new Integer(readInt()));
        if (trace == API_TRACE_DETAILED)
            Log.current.println("readAssertion: " + cycAssertion.safeToString());
        return cycAssertion;
d1167 3
a1169 1
}
d1171 2
d1174 14
d1189 2
d1192 28
d1221 2
d1224 32
d1257 3
@


1.20
log
@Experiments with UTF-8 character encoding scheme
@
text
@d8 1
d17 1
a17 1
 * @@version $Id: CfaslInputStream.java,v 1.19 2002/09/10 21:14:01 stephenreed Exp $
d173 2
d189 1
a189 1
            System.out.println("reading opcode = " + cfaslOpcode + " (" +
d194 1
a194 1
                System.out.println("Reading Immediate Fixnum: " + o);
d259 1
a259 1
                    o = new String(s);
d263 1
a263 1
                    //o = new String(s, "UTF-8");
d324 1
a324 1
                System.out.println("readObject = " + safeToString.invoke(o, null) +
d328 1
a328 1
                System.out.println("readObject = " + o + " (" + o.getClass() + ")");
d344 1
a344 1
            System.out.println(errorMessage);
d439 1
a439 1
            System.out.println("readFixnumBody sign=" + sign + " length=" + nBytes);
d446 1
a446 1
                System.out.println("\t" + j);
d465 1
a465 1
            System.out.println("readBignumBody sign=" + sign + " length=" + length);
d470 1
a470 1
                System.out.println("\t" + j);
d487 1
a487 1
            System.out.println("readFloatBody sign=" + sign);
d500 1
a500 1
            System.out.println("readFloatBody sign=" + sign + " signif=" + signif + " exp= " + exp);
d537 1
a537 1
            System.out.println("readGuid: " + guid);
d566 1
a566 1
            System.out.println("readCycList.size: " + size);
d572 1
a572 1
            System.out.println("readCycList.readObject: " + cycList.safeToString());
d585 1
a585 1
            System.out.println("readCons.size: " + size);
d591 1
a591 1
                System.out.println("readCons.consObject: " + consObject);
d596 1
a596 1
            System.out.println("readCons.cdrObject: " + cdrObject);
d599 1
a599 1
            System.out.println("readCons.readCons: " + cycList);
d612 1
a612 1
            System.out.println("readConstant: " + cycConstant.safeToString());
d625 1
a625 1
            System.out.println("readVariable: " + cycVariable.safeToString());
d638 1
a638 1
            System.out.println("readNart: " + cycNart.safeToString());
d650 1
a650 1
            System.out.println("readAssertion: " + cycAssertion.safeToString());
@


1.19
log
@Added nickname handling for namspaces.
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.18 2002/07/23 20:17:19 stephenreed Exp $
d257 4
@


1.18
log
@Handled embedded quotes within strings sent to Cyc.  This patch makes the ascii
and cfasl (binary) api commands behave the same.  Added unit test cases.
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.17 2002/03/27 19:51:19 stephenreed Exp $
d331 5
d337 1
a337 1
            System.out.println("Unknown cfasl opcode: " + cfaslOpcode);
d341 1
a341 1
            throw  new RuntimeException("Unknown cfasl opcode: " + cfaslOpcode);
@


1.17
log
@Prepared ApiDemo class as first in a series for the programming tutorial.  Other modules
updated in preparation for public beta release.
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.16 2001/11/17 00:32:47 stephenreed Exp $
d146 1
a146 1
    cfaslOpcodeDescriptions.put(new Integer(26), "CFASL_BYTE_VECTOR");
@


1.16
log
@CoAbs agent tests
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.15 2001/11/14 01:15:16 stephenreed Exp $
d59 6
d248 1
a248 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d262 1
a262 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d264 1
a264 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d266 1
a266 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d268 1
a268 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d270 1
a270 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d287 1
a287 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d289 1
a289 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d291 1
a291 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d293 1
a293 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d295 1
a295 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d297 1
a297 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d302 1
a302 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d304 1
a304 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d306 1
a306 4
                    throw  new RuntimeException("Dictionaries are not supported on the client.\n" +
                                                "Assign a new dictionary to a server side variable\n" +
                                                "whose value is never returned to the client.  Then\n" +
                                                "access the dictionary using server side SubL functions.");
d308 1
a308 1
                    throw  new IOException("CFASL server closed connection.");
d310 1
a310 1
                    throw  new RuntimeException("Unknown cfasl opcode: " + cfaslOpcode);
d327 2
a328 5
    /*
     * The methods below read Java primative types without wrapping them
     * in Objects.  Some, like readInt, may be called a lot, so the savings
     * from not having to allocate heap space may be large.  This justifies
     * the extra maintainence burden caused by code repetition.
d330 9
@


1.15
log
@Completed first round of CoABS agent tests with the OpenCyc api
@
text
@d6 1
d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.14 2001/10/24 17:00:29 stephenreed Exp $
d310 11
a320 2
        if (trace == API_TRACE_DETAILED)
            System.out.println("readObject = " + o + " (" + o.getClass() + ")");
d514 4
a517 1
        return  CycObjectFactory.makeGuid((String)readObject());
d551 1
a551 1
            System.out.println("readCycList.readObject: " + cycList);
d590 2
d603 2
d616 2
d627 4
a630 1
        return  new CycAssertion(new Integer(readInt()));
d632 1
@


1.14
log
@Modifications to support jini agent interface to OpenCyc
@
text
@a6 2
import  org.opencyc.util.ByteArray;

d15 1
a15 1
 * @@version $Id: CfaslInputStream.java,v 1.13 2001/10/22 17:03:15 stephenreed Exp $
@


1.13
log
@Added ByteArray class, updated jini classes as a result of testing.
@
text
@d17 1
a17 1
 * @@version $Id: CfaslInputStream.java,v 1.5 2001/10/19 21:08:34 aldag Exp $
d39 21
a103 1
    protected CycConnection cycConnection;
d141 1
a141 1
	cfaslOpcodeDescriptions.put(new Integer(26), "CFASL_BYTE_VECTOR");
a162 1
     * @@param cycConnection the parent <tt>CycConnection</tt> object
d164 1
a164 1
    public CfaslInputStream (InputStream in, CycConnection cycConnection) {
a165 1
        this.cycConnection = cycConnection;
d180 1
a180 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d185 1
a185 1
            if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d270 1
a270 1
	            o = readByteArray();
d311 1
a311 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d409 1
a409 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d416 1
a416 1
            if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d435 1
a435 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d440 1
a440 1
            if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d457 1
a457 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d470 1
a470 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d510 1
a510 1
   * Reads a byte vector from the CfaslInputStream. The CFASL opcode 
d514 1
a514 1
   */ 
d533 1
a533 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d539 1
a539 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d552 1
a552 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d558 1
a558 1
            if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d563 1
a563 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
d566 1
a566 1
        if (cycConnection.trace == CycConnection.API_TRACE_DETAILED)
@


1.12
log
@Fixed errors in mapdictionary api function discovered by unit test cases.
@
text
@d7 1
d17 1
a17 1
 * @@version $Id: CfaslInputStream.java,v 1.11 2001/09/14 22:14:55 stephenreed Exp $
d67 1
d121 1
d251 3
d490 16
@


1.11
log
@Created new CycObjectFactory class to contain all cyc object caches
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.10 2001/09/07 23:43:03 stephenreed Exp $
d78 1
d131 1
d276 5
@


1.10
log
@Added defered completion of CycForts in the binary api. Continued with HashJoiner.
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.9 2001/09/03 22:30:50 stephenreed Exp $
d211 1
a211 1
                    o = CycSymbol.nil;
d451 1
a451 1
        return  CycSymbol.makeCycSymbol(":" + (String)readObject());
d463 1
a463 1
            return  CycVariable.makeCycVariable(name);
d465 1
a465 1
            return  CycSymbol.makeCycSymbol(name);
d475 1
a475 1
        return  Guid.makeGuid((String)readObject());
@


1.9
log
@Reworking ProblemParser to handle high cardinality domains better
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.8 2001/08/28 23:52:15 stephenreed Exp $
d531 1
a531 1
        cycConstant.id = new Integer(readInt());
d553 1
a553 1
        cycNart.id = new Integer(readInt());
@


1.8
log
@Added more backchain support - testing with one level of backchaining
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.7 2001/08/28 10:05:25 stephenreed Exp $
d157 1
a157 1
        if (cycConnection.trace)
d162 1
a162 1
            if (cycConnection.trace)
d280 1
a280 1
        if (cycConnection.trace)
d378 1
a378 1
        if (cycConnection.trace)
d385 1
a385 1
            if (cycConnection.trace)
d404 1
a404 1
        if (cycConnection.trace)
d409 1
a409 1
            if (cycConnection.trace)
d426 1
a426 1
        if (cycConnection.trace)
d439 1
a439 1
        if (cycConnection.trace)
d486 1
a486 1
        if (cycConnection.trace)
d492 1
a492 1
        if (cycConnection.trace)
d505 1
a505 1
        if (cycConnection.trace)
d511 1
a511 1
            if (cycConnection.trace)
d516 1
a516 1
        if (cycConnection.trace)
d519 1
a519 1
        if (cycConnection.trace)
@


1.7
log
@Refactored binary api support to pass all unit tests
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.6 2001/08/27 14:39:27 stephenreed Exp $
d455 1
a455 1
     * Reads the body of a Symbol from the CfaslInputStream.  The CFASL opcode
d458 1
a458 1
     * @@return the <tt>CycSymbol</tt> read
d460 6
a465 2
    public CycSymbol readSymbol () throws IOException {
        return  CycSymbol.makeCycSymbol((String)readObject());
@


1.6
log
@Added id to CycVariable, completed binary api test cases.
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.5 2001/08/27 02:30:53 stephenreed Exp $
d211 1
a211 1
                    o = null;
d280 2
a281 6
        if (cycConnection.trace) {
            if (o == null)
                System.out.println("readObject = nil/null");
            else
                System.out.println("readObject = " + o + " (" + o.getClass() + ")");
            }
@


1.5
log
@Unit test cases for binary api connnection
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.4 2001/08/24 22:39:27 stephenreed Exp $
d268 2
a269 1
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
d530 14
a543 3
        CycConstant answer = new CycConstant();
        answer.id = new Integer(readInt());
        return  answer;
d552 3
a554 3
        CycNart answer = new CycNart();
        answer.id = new Integer(readInt());
        return  answer;
@


1.4
log
@Continued binary api test cases
@
text
@d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.3 2001/08/23 09:33:13 stephenreed Exp $
a105 1
        cfaslOpcodeDescriptions.put(new Integer(17), "CFASL_DOTTED");
d109 1
d486 1
a486 1
            System.out.println("CycList.size: " + size);
d492 1
a492 1
            System.out.println("CycList.readObject: " + cycList);
d504 2
d507 13
a519 3
        for (int i = 0; i < (size - 1); i++)
            cycList.add(readObject());
        cycList.setDottedElement(readObject());
@


1.3
log
@Continued unit testing binary api
@
text
@d5 1
d16 1
a16 1
 * @@version $Id: CfaslInputStream.java,v 1.2 2001/08/23 00:47:45 stephenreed Exp $
d82 51
d143 1
d158 2
a159 1
            System.out.println("opcode = " + cfaslOpcode);
d279 1
a279 1
        if (cycConnection.trace)
d284 1
d454 1
a454 1
        return  CycSymbol.makeCycSymbol((String)readObject());
d485 2
@


1.2
log
@Continuing integration of legacy binary api
@
text
@d1 491
a491 483
package  org.opencyc.api;

import  java.io.*;
import  java.math.BigInteger;
import  org.opencyc.cycobject.*;


/**
 * A CFASL translating input stream.  All Java-native types which have logical
 * sublisp equivalents are translated automatically by this stream.  Classes
 * implementing the CfaslTranslatingObject interface are created using thier
 * readObject() method.  Other CYC objects, such as binding-lists and formulas,
 * must be explicitly coerced using their static constructors.
 *
 * @@version $Id: CfaslInputStream.java,v 1.1 2001/08/21 23:28:16 stephenreed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
public class CfaslInputStream extends BufferedInputStream {
    protected static final int CFASL_IMMEDIATE_FIXNUM_CUTOFF = 128;
    protected static final int CFASL_IMMEDIATE_FIXNUM_OFFSET = 256 - CFASL_IMMEDIATE_FIXNUM_CUTOFF;
    protected static final int CFASL_P_8BIT_INT = 0;
    protected static final int CFASL_N_8BIT_INT = 1;
    protected static final int CFASL_P_16BIT_INT = 2;
    protected static final int CFASL_N_16BIT_INT = 3;
    protected static final int CFASL_P_24BIT_INT = 4;
    protected static final int CFASL_N_24BIT_INT = 5;
    protected static final int CFASL_P_32BIT_INT = 6;
    protected static final int CFASL_N_32BIT_INT = 7;
    protected static final int CFASL_P_FLOAT = 8;
    protected static final int CFASL_N_FLOAT = 9;
    protected static final int CFASL_KEYWORD = 10;
    protected static final int CFASL_SYMBOL = 11;
    protected static final int CFASL_NIL = 12;
    protected static final int CFASL_LIST = 13;
    protected static final int CFASL_DOTTED = 17;
    protected static final int CFASL_VECTOR = 14;
    protected static final int CFASL_STRING = 15;
    protected static final int CFASL_CHARACTER = 16;
    protected static final int CFASL_HASHTABLE = 18;
    protected static final int CFASL_BTREE_LOW_HIGH = 19;
    protected static final int CFASL_BTREE_LOW = 20;
    protected static final int CFASL_BTREE_HIGH = 21;
    protected static final int CFASL_BTREE_LEAF = 22;
    protected static final int CFASL_P_BIGNUM = 23;
    protected static final int CFASL_N_BIGNUM = 24;
    protected static final int CFASL_GUID = 25;
    protected static final int CFASL_CONSTANT = 30;
    protected static final int CFASL_NART = 31;
    protected static final int CFASL_ASSERTION = 33;
    protected static final int CFASL_ASSERTION_SHELL = 34;
    protected static final int CFASL_ASSERTION_DEF = 35;
    protected static final int CFASL_SOURCE = 36;
    protected static final int CFASL_SOURCE_DEF = 37;
    protected static final int CFASL_AXIOM = 38;
    protected static final int CFASL_AXIOM_DEF = 39;
    protected static final int CFASL_VARIABLE = 40;
    protected static final int CFASL_INDEX = 41;
    protected static final int CFASL_SPECIAL_OBJECT = 50;
    protected static final int CFASL_SERVER_DEATH = -1;
    protected static final int DEFAULT_READ_LIMIT = 1024;
    protected CycConnection cycConnection;

    /**
     * Creates a new CfaslInputStream to read data from the
     * specified underlying input stream.
     *
     * @@param in the underlying input stream.
     * @@param cycConnection the parent <tt>CycConnection</tt> object
     */
    public CfaslInputStream (InputStream in, CycConnection cycConnection) {
        super(in, DEFAULT_READ_LIMIT);
        this.cycConnection = cycConnection;
    }

    /**
     * Reads an Object from this CfaslInputStream.  Basic Java types are
     * wrapped as appropriate (e.g. ints become Integer objects).  New constants are missing
     * name and GUID values and will be completed by the caller to avoid recursion within the
     * api call.
     *
     * @@return the object read from the binary OpenCyc input stream
     */
    public Object readObject () throws IOException {
        int cfaslOpcode = read();
        Object o = null;
        if (cycConnection.trace)
            System.out.println("opcode = " + cfaslOpcode);
        if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
            o = new Integer(cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET);
            if (cycConnection.trace)
                System.out.println("Reading Immediate Fixnum: " + o);
        }
        else {
            switch (cfaslOpcode) {
                case CFASL_P_8BIT_INT:
                    o = new Integer(readFixnumBody(1, 1));
                    break;
                case CFASL_N_8BIT_INT:
                    o = new Integer(readFixnumBody(1, -1));
                    break;
                case CFASL_P_16BIT_INT:
                    o = new Integer(readFixnumBody(2, 1));
                    break;
                case CFASL_N_16BIT_INT:
                    o = new Integer(readFixnumBody(2, -1));
                    break;
                case CFASL_P_24BIT_INT:
                    o = new Integer(readFixnumBody(3, 1));
                    break;
                case CFASL_N_24BIT_INT:
                    o = new Integer(readFixnumBody(3, -1));
                    break;
                case CFASL_P_32BIT_INT:
                    o = new Integer(readFixnumBody(4, 1));
                    break;
                case CFASL_N_32BIT_INT:
                    o = new Integer(readFixnumBody(4, -1));
                    break;
                case CFASL_P_FLOAT:
                    o = new Double(readFloatBody(1));
                    break;
                case CFASL_N_FLOAT:
                    o = new Double(readFloatBody(-1));
                    break;
                case CFASL_P_BIGNUM:
                    o = readBignumBody(1);
                    break;
                case CFASL_N_BIGNUM:
                    o = readBignumBody(-1);
                    break;
                case CFASL_KEYWORD:
                    // Keywords can be distinguished from Symbols by internal evidence
                    o = readKeyword();
                    break;
                case CFASL_SYMBOL:
                    o = readSymbol();
                    break;
                case CFASL_NIL:
                    o = null;
                    break;
                case CFASL_LIST:
                    o = readCycList();
                    break;
                case CFASL_DOTTED:
                    o = readCons();
                    break;
                case CFASL_VECTOR:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_STRING:
                    int off = 0;
                    int len = readInt();
                    byte s[] = new byte[len];
                    while (off < len) {
                        off += read(s, off, len - off);
                    }
                    o = new String(s);
                    break;
                case CFASL_CHARACTER:
                    o = new Character((char)read());
                    break;
                case CFASL_HASHTABLE:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_BTREE_LOW_HIGH:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_BTREE_LOW:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_BTREE_HIGH:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_BTREE_LEAF:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_GUID:
                    o = readGuid();
                    break;
                case CFASL_CONSTANT:
                    o = readConstant();
                    break;
                case CFASL_NART:
                    o = readNart();
                    break;
                case CFASL_ASSERTION:
                    o = readAssertion();
                    break;
                case CFASL_ASSERTION_SHELL:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_ASSERTION_DEF:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_SOURCE:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_SOURCE_DEF:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_AXIOM:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_AXIOM_DEF:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_VARIABLE:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_INDEX:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_SPECIAL_OBJECT:
                    throw  new RuntimeException("CFASL opcode " + cfaslOpcode + " is not supported");
                case CFASL_SERVER_DEATH:
                    throw  new IOException("CFASL server closed connection.");
                default:
                    throw  new RuntimeException("Unknown cfasl opcode: " + cfaslOpcode);
            }
        }
        if (cycConnection.trace)
            if (o == null)
                System.out.println("readObject = nil/null");
            else
                System.out.println("readObject = " + o + " (" + o.getClass() + ")");
        return  o;
    }

    /*
     * The methods below read Java primative types without wrapping them
     * in Objects.  Some, like readInt, may be called a lot, so the savings
     * from not having to allocate heap space may be large.  This justifies
     * the extra maintainence burden caused by code repetition.
     */
    /**
     * Reads an char from this CfaslInputStream.  If the next item
     * on the stream is not a char, throw an exception, and leave
     * that object on the input stream.
     *
     * @@return the character read
     */
    public char readChar () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        if (cfaslOpcode == CFASL_CHARACTER)
            return  (char)read();
        reset();
        throw  new RuntimeException("Expected a char but received opCode=" + cfaslOpcode);
    }

    /**
     * Reads a double from this CfaslInputStream.  If the next item
     * on the stream is not a double, throw an exception, and leave
     * that object on the input stream.
     *
     * @@return the double read
     */
    public double readDouble () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        switch (cfaslOpcode) {
            case CFASL_P_FLOAT:
                return  readFloatBody(1);
            case CFASL_N_FLOAT:
                return  readFloatBody(-1);
            default:
                reset();
                throw  new RuntimeException("Expected a double but received OpCode=" + cfaslOpcode);
        }
    }

    /**
     * Reads an int from this CfaslInputStream.  If the next item
     * on the stream is not an int, throw an exception, and leave
     * that object on the input stream.  Bignum ints are not allowed.
     *
     * @@return the int read
     */
    public int readInt () throws IOException {
        mark(DEFAULT_READ_LIMIT);
        int cfaslOpcode = read();
        if (cfaslOpcode >= CFASL_IMMEDIATE_FIXNUM_OFFSET) {
            return  cfaslOpcode - CFASL_IMMEDIATE_FIXNUM_OFFSET;
        }
        else {
            switch (cfaslOpcode) {
                case CFASL_P_8BIT_INT:
                    return  readFixnumBody(1, 1);
                case CFASL_N_8BIT_INT:
                    return  readFixnumBody(1, -1);
                case CFASL_P_16BIT_INT:
                    return  readFixnumBody(2, 1);
                case CFASL_N_16BIT_INT:
                    return  readFixnumBody(2, -1);
                case CFASL_P_24BIT_INT:
                    return  readFixnumBody(3, 1);
                case CFASL_N_24BIT_INT:
                    return  readFixnumBody(3, -1);
                case CFASL_P_32BIT_INT:
                    return  readFixnumBody(4, 1);
                case CFASL_N_32BIT_INT:
                    return  readFixnumBody(4, -1);
                default:
                    reset();
                    throw  new RuntimeException("Expected an int but received OpCode=" + cfaslOpcode);
            }
        }
    }

    /**
     * Reads the body of a CFASL Fixnum (everything but the opcode)
     * from this CFASL input stream.
     *
     * @@param nBytes  The number of bytes to read
     * @@param sign    The sign of the Fixnum (-1 or +1)
     * @@return an int holding the CFASL Fixnum read in
     * @@throws ArithmeticException if nBytes > 4 or if the integer read in does
     *         not fit into a signed 32 bit integer (i.e. the sign bit is being
     *         used for magnitude).
     */
    private int readFixnumBody (int nBytes, int sign) throws IOException {
        if (cycConnection.trace)
            System.out.println("readFixnumBody sign=" + sign + " length=" + nBytes);
        if (nBytes > 4)
            throw  new ArithmeticException("Cannot fit " + nBytes + " bytes into an int");
        int num = 0;
        for (int i = 0; i < nBytes; i++) {
            int j = read();
            if (cycConnection.trace)
                System.out.println("\t" + j);
            num |= (j << (8*i));
        }
        // num should always be positive here.  Negatives indicate overflows.
        if (num < 0)
            throw  new ArithmeticException("Overflow: " + ((long)num & 0xFFFFFFFFL) + " does not fit into an int");
        return  (sign*num);
    }

    /**
     * Reads the body of a CFASL Bignum (everything but the opcode)
     * off of this CFASL input stream.
     *
     * @@param sign    The sign of the Bignum (-1 or +1)
     * @@return a BigInteger holding the CFASL Bignum read in
     */
    private BigInteger readBignumBody (int sign) throws IOException {
        int length = readInt();
        if (cycConnection.trace)
            System.out.println("readBignumBody sign=" + sign + " length=" + length);
        byte b[] = new byte[length];
        for (int i = length - 1; i >= 0; i--) {
            int j = readInt();
            if (cycConnection.trace)
                System.out.println("\t" + j);
            b[i] = (byte)j;
        }
        return  new BigInteger(sign, b);
    }

    /**
     * Reads the body of a CFASL Float (everything but the opcode)
     * off of this CFASL input stream.
     *
     * @@param sign    The sign of the Float (-1 or +1)
     * @@return a double holding the CFASL Float read in
     * @@throws ArithmeticException if significand cannot fit into a 64 bit signed long int
     */
    private double readFloatBody (int sign) throws IOException {
        long signif, exp;
        if (cycConnection.trace)
            System.out.println("readFloatBody sign=" + sign);
        Object obj = readObject();
        if (obj instanceof BigInteger) {
            BigInteger bi = (BigInteger)obj;
            if (bi.bitCount() < 64)
                signif = bi.longValue();
            else
                throw  new ArithmeticException("Overflow reading significand of float");
        }
        else
            signif = ((Number)obj).longValue();
        exp = readInt();
        if (cycConnection.trace)
            System.out.println("readFloatBody sign=" + sign + " signif=" + signif + " exp= " + exp);
        return  ((double)sign*(double)signif*Math.pow(2.0, exp));
    }

    /**
     * Reads the body of a keyword Symbol from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the keyword <tt>CycSymbol</tt> read
     */
    public CycSymbol readKeyword () throws IOException {
        return  CycSymbol.makeCycSymbol((String)readObject());
    }

    /**
     * Reads the body of a Symbol from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycSymbol</tt> read
     */
    public CycSymbol readSymbol () throws IOException {
        return  CycSymbol.makeCycSymbol((String)readObject());
    }

    /**
     * Reads the body of a Guid from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>Guid</tt> read
     */
    public Guid readGuid () throws IOException {
        return  Guid.makeGuid((String)readObject());
    }

    /**
     * Reads a list from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycList</tt> read
     */
    public CycList readCycList () throws IOException {
        int size = readInt();
        CycList cycList = new CycList();
        for (int i = 0; i < size; i++) {
            cycList.add(readObject());
        }
        if (cycConnection.trace)
            System.out.println("CycList.readObject: " + cycList);
        return  cycList;
    }

    /**
     * Reads a dotted list from the CfaslInputStream.  The CFASL opcode
     * has already been read in at this point, so we only read in what follows.
     *
     * @@return the <tt>CycList</tt> read
     */
    public CycList readCons () throws IOException {
        int size = readInt();
        CycList cycList = new CycList();
        for (int i = 0; i < (size - 1); i++)
            cycList.add(readObject());
        cycList.setDottedElement(readObject());
        return  cycList;
    }

    /**
     * Reads a constant from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycConstant</tt> having the input id
     */
    public CycConstant readConstant () throws IOException {
        return  new CycConstant(readInt());
    }

    /**
     * Reads a NART from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycConstant</tt> having the input id
     */
    public CycNart readNart () throws IOException {
        return  new CycNart(readInt());
    }

    /**
     * Reads an assertion from a CfaslInputStream.
     *
     * @@return an incomplete <tt>CycAssertion</tt> having the input id
     */
    public CycAssertion readAssertion () throws IOException {
        return  new CycAssertion(new Integer(readInt()));
    }
}



@


1.1
log
@Added new binary api connection classes
@
text
@d15 1
a15 1
 * @@version $Id: CycConnection.java,v 1.3 2001/08/15 23:49:55 stephenreed Exp $
d64 1
d189 3
d410 10
@

