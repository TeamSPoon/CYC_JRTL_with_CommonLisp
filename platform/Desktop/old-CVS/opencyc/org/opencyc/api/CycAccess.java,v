head	1.123;
access;
symbols
	BRANCH_OPENCYC_1_0_1:1.122.0.2
	OPENCYC_1_0_1:1.122
	PRE_1_0:1.120;
locks; strict;
comment	@# @;


1.123
date	2006.10.21.16.49.15;	author dmiles;	state Exp;
branches;
next	1.122;

1.122
date	2006.10.18.14.21.33;	author dmiles;	state Exp;
branches;
next	1.121;

1.121
date	2006.10.18.13.36.02;	author dmiles;	state Exp;
branches;
next	1.120;

1.120
date	2003.04.22.19.54.19;	author stephenreed;	state Exp;
branches;
next	1.119;

1.119
date	2003.04.03.20.51.47;	author stephenreed;	state Exp;
branches;
next	1.118;

1.118
date	2003.02.24.22.41.11;	author stephenreed;	state Exp;
branches;
next	1.117;

1.117
date	2003.02.07.21.06.14;	author stephenreed;	state Exp;
branches;
next	1.116;

1.116
date	2003.01.29.00.18.03;	author stephenreed;	state Exp;
branches;
next	1.115;

1.115
date	2003.01.27.22.49.17;	author stephenreed;	state Exp;
branches;
next	1.114;

1.114
date	2003.01.23.23.15.35;	author stephenreed;	state Exp;
branches;
next	1.113;

1.113
date	2003.01.13.23.57.58;	author stephenreed;	state Exp;
branches;
next	1.112;

1.112
date	2003.01.10.22.31.21;	author stephenreed;	state Exp;
branches;
next	1.111;

1.111
date	2003.01.09.21.51.51;	author stephenreed;	state Exp;
branches;
next	1.110;

1.110
date	2002.12.24.16.58.50;	author stephenreed;	state Exp;
branches;
next	1.109;

1.109
date	2002.12.06.00.12.16;	author stephenreed;	state Exp;
branches;
next	1.108;

1.108
date	2002.11.27.14.08.32;	author stephenreed;	state Exp;
branches;
next	1.107;

1.107
date	2002.11.26.00.15.18;	author stephenreed;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.14.22.05.44;	author stephenreed;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.14.00.35.36;	author stephenreed;	state Exp;
branches;
next	1.104;

1.104
date	2002.10.29.23.29.56;	author stephenreed;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.21.18.31.36;	author stephenreed;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.09.21.28.27;	author stephenreed;	state Exp;
branches;
next	1.101;

1.101
date	2002.10.09.19.35.38;	author stephenreed;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.09.15.17.21;	author stephenreed;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.09.04.01.48;	author stephenreed;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.09.01.36.14;	author stephenreed;	state Exp;
branches;
next	1.97;

1.97
date	2002.10.04.21.12.46;	author stephenreed;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.02.13.59.26;	author stephenreed;	state Exp;
branches;
next	1.95;

1.95
date	2002.10.01.15.21.11;	author stephenreed;	state Exp;
branches;
next	1.94;

1.94
date	2002.09.30.14.33.28;	author stephenreed;	state Exp;
branches;
next	1.93;

1.93
date	2002.09.26.16.06.36;	author stephenreed;	state Exp;
branches;
next	1.92;

1.92
date	2002.09.25.15.10.09;	author stephenreed;	state Exp;
branches;
next	1.91;

1.91
date	2002.09.24.21.36.16;	author stephenreed;	state Exp;
branches;
next	1.90;

1.90
date	2002.09.23.15.45.45;	author stephenreed;	state Exp;
branches;
next	1.89;

1.89
date	2002.09.22.20.32.03;	author stephenreed;	state Exp;
branches;
next	1.88;

1.88
date	2002.09.20.22.38.47;	author stephenreed;	state Exp;
branches;
next	1.87;

1.87
date	2002.09.20.14.01.27;	author stephenreed;	state Exp;
branches;
next	1.86;

1.86
date	2002.09.19.19.54.07;	author stephenreed;	state Exp;
branches;
next	1.85;

1.85
date	2002.09.19.00.09.47;	author stephenreed;	state Exp;
branches;
next	1.84;

1.84
date	2002.09.18.14.39.13;	author stephenreed;	state Exp;
branches;
next	1.83;

1.83
date	2002.09.18.01.18.55;	author stephenreed;	state Exp;
branches;
next	1.82;

1.82
date	2002.09.17.16.11.27;	author stephenreed;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.17.15.18.02;	author stephenreed;	state Exp;
branches;
next	1.80;

1.80
date	2002.09.16.22.21.25;	author stephenreed;	state Exp;
branches;
next	1.79;

1.79
date	2002.09.16.08.52.31;	author stephenreed;	state Exp;
branches;
next	1.78;

1.78
date	2002.09.15.23.58.49;	author stephenreed;	state Exp;
branches;
next	1.77;

1.77
date	2002.09.13.22.55.45;	author stephenreed;	state Exp;
branches;
next	1.76;

1.76
date	2002.09.12.23.41.10;	author stephenreed;	state Exp;
branches;
next	1.75;

1.75
date	2002.09.12.15.03.19;	author stephenreed;	state Exp;
branches;
next	1.74;

1.74
date	2002.09.12.03.22.09;	author stephenreed;	state Exp;
branches;
next	1.73;

1.73
date	2002.09.10.21.14.02;	author stephenreed;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.08.02.43.02;	author stephenreed;	state Exp;
branches;
next	1.71;

1.71
date	2002.08.30.22.52.12;	author stephenreed;	state Exp;
branches;
next	1.70;

1.70
date	2002.08.29.21.59.19;	author stephenreed;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.29.03.01.30;	author stephenreed;	state Exp;
branches;
next	1.68;

1.68
date	2002.08.29.02.13.54;	author stephenreed;	state Exp;
branches;
next	1.67;

1.67
date	2002.08.27.20.44.58;	author stephenreed;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.23.20.17.19;	author stephenreed;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.17.21.27.04;	author stephenreed;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.30.22.15.16;	author stephenreed;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.30.14.18.37;	author stephenreed;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.13.17.39.05;	author stephenreed;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.23.02.59.01;	author stephenreed;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.27.19.51.19;	author stephenreed;	state Exp;
branches;
next	1.59;

1.59
date	2002.02.28.06.02.22;	author stephenreed;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.25.21.08.11;	author stephenreed;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.21.22.18.29;	author stephenreed;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.20.22.44.57;	author stephenreed;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.04.21.15.30;	author stephenreed;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.04.17.02.57;	author stephenreed;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.03.18.07.21;	author stephenreed;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.08.20.03.43;	author stephenreed;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.08.18.38.48;	author stephenreed;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.08.15.02.30;	author stephenreed;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.04.05.35.39;	author stephenreed;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.17.00.32.47;	author stephenreed;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.15.21.37.34;	author stephenreed;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.13.02.16.51;	author stephenreed;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.12.03.56.48;	author stephenreed;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.09.02.50.59;	author stephenreed;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.05.22.34.36;	author stephenreed;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.31.00.00.52;	author stephenreed;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.24.17.00.29;	author stephenreed;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.17.23.44.18;	author stephenreed;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.15.22.34.00;	author stephenreed;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.10.18.02.49;	author stephenreed;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.07.12.36.34;	author stephenreed;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.06.23.06.22;	author stephenreed;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.04.22.24.01;	author stephenreed;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.18.18.08.47;	author stephenreed;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.18.17.54.39;	author stephenreed;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.14.22.14.55;	author stephenreed;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.14.19.58.53;	author stephenreed;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.10.18.47.09;	author stephenreed;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.07.23.43.03;	author stephenreed;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.06.21.43.25;	author stephenreed;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.06.15.30.52;	author stephenreed;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.05.22.58.59;	author stephenreed;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.03.22.30.50;	author stephenreed;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.31.23.30.33;	author stephenreed;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.31.15.45.42;	author stephenreed;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.30.23.35.11;	author stephenreed;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.30.00.06.54;	author stephenreed;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.28.23.52.15;	author stephenreed;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.28.10.05.25;	author stephenreed;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.27.22.30.44;	author stephenreed;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.27.14.39.27;	author stephenreed;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.27.02.30.53;	author stephenreed;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.24.22.39.27;	author stephenreed;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.23.22.14.25;	author stephenreed;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.23.09.33.13;	author stephenreed;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.23.00.47.46;	author stephenreed;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.21.23.28.16;	author stephenreed;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.20.23.16.59;	author stephenreed;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.20.21.26.24;	author stephenreed;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.20.14.00.06;	author stephenreed;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.17.13.57.21;	author stephenreed;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.16.23.04.57;	author stephenreed;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.16.14.25.26;	author stephenreed;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.15.23.49.55;	author stephenreed;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.15.18.00.34;	author stephenreed;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.15.14.50.45;	author stephenreed;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.14.23.49.56;	author stephenreed;	state Exp;
branches;
next	;


desc
@@


1.123
log
@Post OpenCyc 1.0 Cyc Java API - This includes the adding back of many exprmental packages
@
text
@package org.opencyc.api;

import java.io.IOException;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Stack;
import java.util.Map.Entry;

import org.apache.oro.util.Cache;
import org.apache.oro.util.CacheLRU;
import org.opencyc.cycobject.CycAssertion;
import org.opencyc.cycobject.CycConstant;
import org.opencyc.cycobject.CycFort;
import org.opencyc.cycobject.CycList;
import org.opencyc.cycobject.CycListParser;
import org.opencyc.cycobject.CycNart;
import org.opencyc.cycobject.CycObject;
import org.opencyc.cycobject.CycSymbol;
import org.opencyc.cycobject.CycVariable;
import org.opencyc.cycobject.ELMt;
import org.opencyc.cycobject.ELMtConstant;
import org.opencyc.cycobject.ELMtCycList;
import org.opencyc.cycobject.ELMtNart;
import org.opencyc.cycobject.Guid;
import org.opencyc.util.Log;


/**
 * Provides wrappers for the OpenCyc API.
 * 
 * <p>
 * Collaborates with the <tt>CycConnection</tt> class which manages the api connections.
 * </p>
 * 
 * @@version $Id: CycAccess.java,v 1.81 2005/02/16 22:05:06 reed Exp $
 * @@author Stephen L. Reed <p><p><p><p><p>
 */
public class CycAccess {
  /**
   * Dictionary of CycAccess instances, indexed by thread so that the application does not have to
   * keep passing around a CycAccess object reference.
   */
  public static HashMap cycAccessInstances = new HashMap();

  /**
   * Shared CycAccess instance when thread synchronization is entirely handled by the application.
   * Use of the CycAccess.current() method returns this reference if the lookup by process thread
   * fails.
   */
  public static CycAccess sharedCycAccessInstance = null;

  /**
   * When true performs tracing of binary mode messages with constant names displayed, which
   * involves recursive api requests.
   */
  public boolean traceWithNames = false;

  /**
   * indicates whether to eagerly obtain constant names for constants returned from the api
   */
  public boolean eagerlyObtainConstantNames = true;
  
  /**
   * the threshold above which constant names are automatically obtained for constants returned
   * from the api
   */
  public int eagerlyObtainConstantNamesThreshold = 10;
  
  /**
   * the list of constants returned from the api that currently have no constant name
   */
  public CycList constantsHavingNoName = new CycList();
  
  /**
   * Stack to prevent tracing of recursive api calls whose sole purpose is to obtain names for
   * traceWithNames.
   */
  protected Stack traceWithNamesStack = new Stack();

  /** Value indicating that the OpenCyc api socket is created and then closed for each api call. */
  public static final int TRANSIENT_CONNECTION = 1;

  /** Value indicating that the OpenCyc api should use one TCP socket for the entire session. */
  public static final int PERSISTENT_CONNECTION = 2;

  /** Value indicating that the OpenCyc api should use one TCP socket for the entire session. */
  public static final int XML_SOAP_CONNECTION = 3;

  /**
   * Default value indicating that the OpenCyc api should use one TCP socket for the entire
   * session.
   */
  public static final int DEFAULT_CONNECTION = PERSISTENT_CONNECTION;

  /**
   * Parameter indicating whether the OpenCyc binary api defers the completion of CycConstant
   * attributes until used for the first time.
   */
  public boolean deferObjectCompletion = true;

  /**
   * Parameter indicating whether the OpenCyc api should use one TCP socket for the entire session,
   * or if the socket is created and then closed for each api call, or if an XML SOAP service
   * provides the message transport.
   */
  public int persistentConnection = DEFAULT_CONNECTION;

  /** Parameter indicating the serial or concurrent messaging mode to the OpenCyc server. */
  public int messagingMode = CycConnection.DEFAULT_MESSAGING_MODE;

  /** Parameter indicating that compatibility with older versions of the OpenCyc api is desired. */
  protected boolean isLegacyMode = false;

  /** Default value for isLegacyMode is no compatibility with older versions of the OpenCyc api. */
  public static final boolean DEFAULT_IS_LEGACY_MODE = false;

  /** the Cyc server host name */
  protected String hostName;

  /** the Cyc server host tcp port number */
  protected int port;

  /** the Cyc server communication mode */
  protected int communicationMode;

  /** the Cyc server OK response code */
  protected static final Integer OK_RESPONSE_CODE = new Integer(200);

  /**
   * Parameter that, when true, causes a trace of the messages to and from the server. This
   * variable preserves the value of the CycConnection trace between instantiations when the
   * connection is transient.
   */
  protected int saveTrace = CycConnection.API_TRACE_NONE;

  /** Convenient reference to #$BaseKb. */
  public static ELMt baseKB = null;

  /** Convenient reference to #$isa. */
  public static CycConstant isa = null;

  /** Convenient reference to #$genls. */
  public static CycConstant genls = null;

  /** Convenient reference to #$genlMt. */
  public static CycConstant genlMt = null;

  /** Convenient reference to #$comment. */
  public static CycConstant comment = null;

  /** Convenient reference to #$Collection. */
  public static CycConstant collection = null;

  /** Convenient reference to #$binaryPredicate. */
  public static CycConstant binaryPredicate = null;

  /** Convenient reference to #$elementOf. */
  public static CycConstant elementOf = null;

  /** Convenient reference to #$numericallyEqual. */
  public static CycConstant numericallyEqual = null;
  
  /************************* constants needed by CycL parser *********/
  
  /** Convenient reference to #$True. */
  public static CycConstant trueConst = null; 
  
  /** Convenient reference to #$False. */
  public static CycConstant falseConst = null;
  
  /** Convenient reference to #$not. */
  public static CycConstant not = null;
  
  /** Convenient reference to #$and. */
  public static CycConstant and = null;

  /** Convenient reference to #$or. */
  public static CycConstant or = null;

  /** Convenient reference to #$xor. */
  public static CycConstant xorConst = null;
  
  /** Convenient reference to #$equiv. */
  public static CycConstant equivConst = null;
  
  /** Convenient reference to #$implies. */
  public static CycConstant impliesConst = null;
  
  /** Convenient reference to #$forAll. */
  public static CycConstant forAllConst = null;
  
  /** Convenient reference to #$thereExists. */
  public static CycConstant thereExistsConst = null;
  
  /** Convenient reference to #$thereExistExactly. */
  public static CycConstant thereExistExactlyConst = null;
  
  /** Convenient reference to #$thereExistAtMost. */
  public static CycConstant thereExistAtMostConst = null;
  
  /** Convenient reference to #$thereExistAtLeast. */
  public static CycConstant thereExistAtLeastConst = null;
  
  /** Convenient reference to #$ExapndSubLFn. */
  public static CycConstant expandSubLFnConst = null;
  
  /** Convenient reference to #$SubLQuoteFn. */
  public static CycConstant sublQuoteFnConst = null;
  
  /********************************************************************/


  /** Convenient reference to #$PlusFn. */
  public static CycConstant plusFn = null;

  /** Convenient reference to #$different. */
  public static CycConstant different = null;

  /** Convenient reference to #$Thing. */
  public static CycConstant thing = null;

  /** Convenient reference to #$InferencePSC. */
  public static ELMt inferencePSC = null;

  /** Convenient reference to #$UniversalVocabularyMt. */
  public static ELMt universalVocabularyMt = null;

  /** Convenient reference to #$bookkeepingMt. */
  public static ELMt bookkeepingMt = null;

  /** the current Cyc Cyclist (user) */
  private CycFort cyclist = null;

  /** the current Cyc project */
  private CycFort project = null;

  /** Least Recently Used Cache of ask results. */
  protected Cache askCache = new CacheLRU(500);

  /** Least Recently Used Cache of countAllInstances results. */
  protected Cache countAllInstancesCache = new CacheLRU(
                                                 500);

  /** Least Recently Used Cache of isCollection results. */
  protected Cache isCollectionCache = new CacheLRU(500);

  /** Least Recently Used Cache of isGenlOf results. */
  protected Cache isGenlOfCache = new CacheLRU(500);

  /**
   * Reference to <tt>CycConnection</tt> object which manages the api connection to the OpenCyc
   * server.
   */
  protected CycConnectionInterface cycConnection;
  
  /** the query properties */
  private final HashMap queryProperties = new HashMap();
  
  /**
   * Constructs a new CycAccess object.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess()
            throws IOException, UnknownHostException, CycApiException {
    this(CycConnection.DEFAULT_HOSTNAME, CycConnection.DEFAULT_BASE_PORT, 
         CycConnection.DEFAULT_COMMUNICATION_MODE, 
         CycAccess.DEFAULT_CONNECTION, 
         CycAccess.DEFAULT_IS_LEGACY_MODE);
  }
  
  public CycAccess(CycConnectionInterface conn)
            throws IOException, CycApiException {
    hostName = conn.getHostName();
    port = conn.getBasePort();
    communicationMode = CycConnection.BINARY_MODE;
    
    
    persistentConnection = XML_SOAP_CONNECTION;
    persistentConnection = PERSISTENT_CONNECTION;
    
    cycConnection = conn;
    commonInitialization();
  }

  /**
   * Constructs a new CycAccess object for a SOAP connection.
   * 
   * @@param endpointURL the SOAP XML endpoint URL which indicates the Cyc API web services host
   * @@param hostName the name of the computer hosting the Cyc server
   * @@param port the Cyc server listening port
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(URL endpointURL, 
                   String hostName, 
                   int port)
            throws IOException, CycApiException {
    throw new RuntimeException("Not implememted");
  }

  /**
   * Constructs a new CycAccess object given a host name.
   * 
   * @@param hostName the host name
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName)
            throws IOException, UnknownHostException, CycApiException {
    this(hostName, CycConnection.DEFAULT_BASE_PORT, CycConnection.DEFAULT_COMMUNICATION_MODE, 
         CycAccess.DEFAULT_CONNECTION, 
         false);
  }

  /**
   * Constructs a new CycAccess object given a host name and base port
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName, int basePort)
            throws IOException, UnknownHostException, CycApiException {
    this(hostName, basePort, CycConnection.DEFAULT_COMMUNICATION_MODE, 
         CycAccess.DEFAULT_CONNECTION, 
         false);
  }

  /**
   * Constructs a new CycAccess object given a host name, port, communication mode, persistence
   * indicator and legacy mode.
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   * @@param communicationMode either ASCII_MODE or BINARY_MODE
   * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with the
   *        OpenCyc server
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName, 
                   int basePort, 
                   int communicationMode, 
                   int persistentConnection)
            throws IOException, UnknownHostException, CycApiException {
    this(hostName, basePort, communicationMode, persistentConnection, false);
  }

  /**
   * Constructs a new CycAccess object given a host name, port, communication mode, persistence
   * indicator and legacy mode.
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   * @@param communicationMode either ASCII_MODE or BINARY_MODE
   * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with the
   *        OpenCyc server
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName, 
                   int basePort, 
                   int communicationMode, 
                   boolean persistentConnection)
            throws IOException, UnknownHostException, CycApiException {
    this(hostName, basePort, communicationMode, 
         persistentConnection ? PERSISTENT_CONNECTION : TRANSIENT_CONNECTION, 
         false);
  }

  /**
   * Constructs a new CycAccess object given a host name, port, communication mode, persistence
   * indicator and legacy mode.
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   * @@param communicationMode either ASCII_MODE or BINARY_MODE
   * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with the
   *        OpenCyc server
   * @@param isLegacyMode indicates if legacy OpenCyc server compatibility is desired
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName, 
                   int basePort, 
                   int communicationMode, 
                   int persistentConnection, 
                   boolean isLegacyMode)
            throws IOException, UnknownHostException, CycApiException {
    this.hostName = hostName;
    this.port = basePort;
    this.communicationMode = communicationMode;
    this.persistentConnection = persistentConnection;
    this.isLegacyMode = isLegacyMode;

    if (persistentConnection == CycAccess.PERSISTENT_CONNECTION) {
      cycConnection = new CycConnection(hostName, 
                                        port, 
                                        communicationMode, 
                                        this);
    }

    commonInitialization();
  }

  /**
   * Constructs a new CycAccess object given a host name, port, communication mode, persistence
   * indicator, and messaging mode
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   * @@param communicationMode either ASCII_MODE or BINARY_MODE
   * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with the
   *        OpenCyc server
   * @@param messagingMode either SERIAL_MESSAGING_MODE or CONCURRENT_MESSAGING_MODE
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAccess(String hostName, 
                   int basePort, 
                   int communicationMode, 
                   int persistentConnection, 
                   int messagingMode)
            throws IOException, UnknownHostException, CycApiException {
    this.hostName = hostName;
    this.port = basePort;

    if (messagingMode == CycConnection.CONCURRENT_MESSAGING_MODE) {
      if (persistentConnection != PERSISTENT_CONNECTION) {
        throw new CycApiException("Concurrent Messaging requires Persistent Connections");
      }
    }

    this.communicationMode = communicationMode;
    this.persistentConnection = persistentConnection;
    this.messagingMode = messagingMode;

    if (persistentConnection == this.PERSISTENT_CONNECTION) {
      cycConnection = new CycConnection(hostName, 
                                        port, 
                                        communicationMode, 
                                        messagingMode, 
                                        this);
    }

    commonInitialization();
  }

  /**
   * Provides common local and remote CycAccess object initialization.
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  protected void commonInitialization()
                               throws IOException, CycApiException {
    if (Log.current == null) {
      Log.makeLog("cyc-api.log");
    }

    cycAccessInstances.put(Thread.currentThread(), 
                           this);

    if (sharedCycAccessInstance == null) {
      sharedCycAccessInstance = this;
    }

    initializeConstants();
  }

  /**
   * Returns a string representation of this object.
   * 
   * @@return a string representation of this object
   */
  public String toString() {
    return cycConnection.connectionInfo();
  }

  /**
   * Returns the <tt>CycAccess</tt> object for this thread.
   * 
   * @@return the <tt>CycAccess</tt> object for this thread
   * 
   * @@throws RuntimeException when there is no CycAcess object for this thread
   */
  public static CycAccess current() {
    CycAccess cycAccess = (CycAccess) cycAccessInstances.get(Thread.currentThread());

    if (cycAccess == null) {
      if (sharedCycAccessInstance != null) {
        return sharedCycAccessInstance;
      }
      else {
        throw new RuntimeException("No CycAccess object for this thread");
      }
    }

    return cycAccess;
  }

  /**
   * Returns true if there is a CycAccess object for this thread.
   * 
   * @@return true if there is a CycAccess object for this thread.
   */
  public static boolean hasCurrent() {
    CycAccess cycAccess = (CycAccess) cycAccessInstances.get(Thread.currentThread());

    if (cycAccess == null) {
      if (sharedCycAccessInstance != null) {
        return true;
      }
      else {
        return false;
      }
    }
    return true;
  }

  /**
   * Sets the shared <tt>CycAccess</tt> instance.
   * 
   * @@param sharedCycAccessInstance shared<tt>CycAccess</tt> instance
   */
  public static void setSharedCycAccessInstance(CycAccess sharedCycAccessInstance) {
    CycAccess.sharedCycAccessInstance = sharedCycAccessInstance;
  }

  /**
   * Turns on the diagnostic trace of socket messages.
   */
  public void traceOn() {
    cycConnection.traceOn();
    saveTrace = CycConnection.API_TRACE_MESSAGES;
  }

  /**
   * Turns on the detailed diagnostic trace of socket messages.
   */
  public void traceOnDetailed() {
    if (cycConnection != null) {
      cycConnection.traceOnDetailed();
    }

    saveTrace = CycConnection.API_TRACE_DETAILED;
  }

  /**
   * Turns off the diagnostic trace of socket messages.
   */
  public void traceOff() {
    cycConnection.traceOff();
    saveTrace = CycConnection.API_TRACE_NONE;
  }

  /**
   * Turns on the diagnostic trace of messages with constant names looked up via recursive api
   * request.
   */
  public void traceNamesOn() {
    traceWithNames = true;
  }

  /**
   * Turns on the diagnostic trace of messages with constant names looked up via recursive api
   * request.
   */
  public void traceNamesOff() {
    traceWithNames = false;
  }

  /**
   * gets the hostname of the connection
   * 
   * @@return the hostname of the connection
   */
  public String getHostName() {
    // @@hack: we dont actually know if this is a CycConnection object,
    // so this cast may fail woefully -> fix later
    return ((CycConnection) cycConnection).getHostName();
  }

  /**
   * gets the baseport of the connection
   * 
   * @@return the baseport of the connection
   */
  public int getBasePort() {
    // @@hack: we dont actually know if this is a CycConnection object,
    // so this cast may fail woefully -> fix later
    return ((CycConnection) cycConnection).getBasePort();
  }

  /**
   * Returns the CycConnection object.
   * 
   * @@return the CycConnection object
   */
  public CycConnectionInterface getCycConnection() {
    return cycConnection;
  }

  /** Indicates whether the connection is closed */
  private boolean isClosed = false;

  /**
   * Closes the CycConnection object. Modified by APB to be able to handle multiple calls to
   * close() safely.
   */
  public synchronized void close() {
    if (isClosed) {
      return;
    }

    isClosed = true;

    if (cycConnection != null) {
      try {
        /*if (cycConnection instanceof RemoteCycConnection) {
          try {
            this.converseVoid(CycObjectFactory.END_CYC_CONNECTION);
          }
           catch (UnknownHostException e) {
          }
           catch (IOException e) {
          }
           catch (CycApiException e) {
          }
        }*/
      }

      // in case the org.opencyc.cycagent package is omitted
       catch (java.lang.NoClassDefFoundError e) {
      }

      cycConnection.close();
    }

    cycAccessInstances.remove(Thread.currentThread());
  }

  /**
   * Returns the communication mode.
   * 
   * @@return the communication mode
   */
  public int getCommunicationMode() {
    return communicationMode;
  }

  /**
   * Contains trace with names information
   * 
   * @@version $Revision: 1.81 $
   * @@author $author$
   */
  protected class TraceWithNamesInfo {
    /** indicates whether to trace with names */
    public boolean traceWithNames;

    /** indicates whether a constant name request is bypassed */
    public boolean bypassConstantNameRequest;

    /**
     * Creates a new TraceWithNamesInfo object.
     */
    public TraceWithNamesInfo() {
    }
  }
  
  /**
   * indicates that the thread is within the converse method
   */
  protected boolean isWithinConverse = false;
  
  /**
   * Converses with Cyc to perform an API command.  Creates a new connection for this command if
   * the connection is not persistent.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result as an object array of two objects
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  protected Object[] converse(Object command)
                       throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };

    // stack discipline is required to prevent tracing of recursive
    // name-seeking api requests.
    TraceWithNamesInfo traceWithNamesInfo = new TraceWithNamesInfo();
    boolean bypassConstantNameRequest = false;

    if (traceWithNames) {
      traceWithNamesInfo.traceWithNames = true;

      CycList commandCyclist;

      if (command instanceof String) {
        commandCyclist = this.makeCycList((String) command);
      }
      else {
        commandCyclist = (CycList) command;
      }

      if (commandCyclist.first().equals(CycObjectFactory.makeCycSymbol(
                                              "constant-name"))) {
        traceWithNamesInfo.bypassConstantNameRequest = true;
      }
      else {
        Log.current.println(commandCyclist.cyclify() + " --> cyc");
      }

      traceWithNames = false;
    }

    traceWithNamesStack.push(traceWithNamesInfo);

    if (persistentConnection == this.TRANSIENT_CONNECTION) {
      cycConnection = new CycConnection(hostName, 
                                        port, 
                                        communicationMode, 
                                        messagingMode, 
                                        this);
      cycConnection.setTrace(saveTrace);
    }

    response = cycConnection.converse(command);

    if (persistentConnection == this.TRANSIENT_CONNECTION) {
      saveTrace = cycConnection.getTrace();
      cycConnection.close();
    }

    traceWithNamesInfo = (TraceWithNamesInfo) traceWithNamesStack.pop();
    traceWithNames = traceWithNamesInfo.traceWithNames;
    bypassConstantNameRequest = traceWithNamesInfo.bypassConstantNameRequest;

    if (traceWithNames && !bypassConstantNameRequest) {
      String responseString;

      if (response[1] instanceof CycList) {
        responseString = ((CycList) response[1]).cyclify();
      }
      else if (response[1] instanceof CycFort) {
        responseString = ((CycFort) response[1]).cyclify();
      }
      else {
        responseString = response[1].toString();
      }

      Log.current.println("cyc --> " + responseString);
    }

    if (eagerlyObtainConstantNames  && (! isWithinConverse)) {
      if (response[1] instanceof CycList) {
        CycList constantNames = ((CycList) response[1]).treeConstants();
        Iterator iter = constantNames.iterator();
        while (iter.hasNext()) { 
          CycConstant cycConstant = (CycConstant) iter.next();
          if (cycConstant.safeGetName() == null)
            constantsHavingNoName.add(cycConstant);
        }
      }
      else if (response[1] instanceof CycConstant &&
               ((CycConstant) response[1]).safeGetName() == null)
        constantsHavingNoName.add(response[1]);
      if (constantsHavingNoName.size() >= eagerlyObtainConstantNamesThreshold) {
        CycList constantsHavingNoName1 = (CycList) constantsHavingNoName.clone();
        constantsHavingNoName = new CycList();
        isWithinConverse = true;
        obtainConstantNames(constantsHavingNoName1);
        isWithinConverse = false;
      }
    }
        
    return response;
  }

  /**
   * Obtains constant names for a list of constants
   *
   * @@param constants the given list of constants having no name yet
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void obtainConstantNames (List constants)
                            throws IOException, UnknownHostException, CycApiException {
    CycList guidStrings = new CycList();
    Iterator iter = constants.iterator();
    while (iter.hasNext()) {
      CycConstant cycConstant = (CycConstant) iter.next();
      if (cycConstant.safeGetName() == null)
        guidStrings.add(cycConstant.getGuid().toString());
    }
    if (guidStrings.size() == 0)
      return;
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-info-from-guid-strings"));
    command.addQuoted(guidStrings);
    CycList constantInfos = converseList(command);
    iter = constantInfos.iterator();
    while (iter.hasNext()) {
      Object constantInfoObject = iter.next();

      if (constantInfoObject instanceof CycList) {
        CycList constantInfo = (CycList) constantInfoObject;
        Guid guid = CycObjectFactory.makeGuid((String) constantInfo.first());
        CycConstant cycConstant = CycObjectFactory.getCycConstantCacheByGuid(guid);
        if (cycConstant != null) {
          String name = (String) constantInfo.second();
          cycConstant.setName(name);
          CycObjectFactory.addCycConstantCacheByName(cycConstant);
        }
      }
    }
  }
  
  /**
   * Obtains constant guids for a list of constants
   *
   * @@param constants the given list of constants having no Guid yet
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void obtainConstantGuids (List constants)
                            throws IOException, UnknownHostException, CycApiException {
    CycList guidStrings = new CycList();
    Iterator iter = constants.iterator();
    while (iter.hasNext()) {
      CycConstant cycConstant = (CycConstant) iter.next();
      if (cycConstant.safeGetGuid() == null)
        guidStrings.add(cycConstant.getName());
    }
    if (guidStrings.size() == 0)
      return;
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-info-from-name-strings"));
    command.addQuoted(guidStrings);
    //System.out.println("Calling: " + command);
    CycList constantInfos = converseList(command);
    iter = constantInfos.iterator();
    while (iter.hasNext()) {
      Object constantInfoObject = iter.next();

      if (constantInfoObject instanceof CycList) {
        CycList constantInfo = (CycList) constantInfoObject;
        String name = (String) constantInfo.second();
        //Guid guid = CycObjectFactory.makeGuid((String) constantInfo.first());
        CycConstant cycConstant = CycObjectFactory.getCycConstantCacheByName(name);
        if (cycConstant != null) {
          Guid guid = (Guid)constantInfo.first();
          cycConstant.setGuid(guid);
          CycObjectFactory.addCycConstantCacheByGuid(cycConstant);
        }
      }
    }
  }
    
  /**
   * Converses with Cyc to perform an API command whose result is returned as an object.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Object converseObject(Object command)
                        throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      return response[1];
    }
    else {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Converses with Cyc to perform an API command whose result is returned as a list.  The symbol
   * nil is returned as the empty list.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList converseList(Object command)
                       throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (response[1].equals(CycObjectFactory.nil)) {
        return new CycList();
      }
      else {
        if (response[1] instanceof CycList)
          return (CycList) response[1];
      }
    }
    String request;
    if (command instanceof CycList)
      request = ((CycList) command).cyclify();
    else
      request = (String) command;
    throw new CycApiException(response[1].toString() + "\nrequest: " + request);
  }

  /**
   * Converses with Cyc to perform an API command whose result is returned as a CycObject.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycObject converseCycObject(Object command)
                              throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (response[1].equals(CycObjectFactory.nil)) {
        return new CycList();
      }
      else {
        return (CycObject) response[1];
      }
    }
    else {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Converses with Cyc to perform an API command whose result is returned as a String.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws CycApiException if the api request results in a cyc server error
   * @@throws RuntimeException if the return from Cyc is not a string
   */
  public String converseString(Object command)
                        throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (!(response[1] instanceof String)) {
        throw new RuntimeException("Expected String but received (" + response[1].getClass() + 
                                   ") " + response[1] + "\n in response to command " + command);
      }

      return (String) response[1];
    }
    else {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Converses with Cyc to perform an API command whose result is returned as a boolean.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean converseBoolean(Object command)
                          throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (response[1].toString().equals("T")) {
        return true;
      }
      else {
        return false;
      }
    }
    else {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Converses with Cyc to perform an API command whose result is returned as an int.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int converseInt(Object command)
                  throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      return (new Integer(response[1].toString())).intValue();
    }
    else {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Converses with Cyc to perform an API command whose result is void.
   * 
   * @@param command the command string or CycList
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void converseVoid(Object command)
                    throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.FALSE)) {
      String request;

      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }

      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
    }
  }

  /**
   * Sets the print-readable-narts feature on.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void setReadableNarts()
                        throws IOException, UnknownHostException, CycApiException {
    converseVoid("(csetq *print-readable-narts t)");
  }

  /**
   * Initializes common cyc constants.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  private void initializeConstants()
                            throws IOException, UnknownHostException, CycApiException {
    CycList guidStrings = new CycList();
    guidStrings.add("bd588111-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588104-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd58810e-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880e5-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588109-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880cc-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588102-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("c0659a2b-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880f9-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880fa-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880fb-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd589d90-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880ae-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd63f343-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880f4-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd58915a-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("dff4a041-4da2-11d6-82c0-0002b34c7c9f");
    guidStrings.add("beaed5bd-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880d9-9c29-11b1-9dad-c379636f7270"); // true
    guidStrings.add("bd5880d8-9c29-11b1-9dad-c379636f7270"); // false
    guidStrings.add("bde7f9f2-9c29-11b1-9dad-c379636f7270"); // xor
    guidStrings.add("bda887b6-9c29-11b1-9dad-c379636f7270"); // equiv
    guidStrings.add("bd5880f8-9c29-11b1-9dad-c379636f7270"); // implies
    guidStrings.add("bd5880f7-9c29-11b1-9dad-c379636f7270"); // forAll
    guidStrings.add("bd5880f6-9c29-11b1-9dad-c379636f7270"); // thereExists
    guidStrings.add("c10ae7b8-9c29-11b1-9dad-c379636f7270"); // thereExistExactly
    guidStrings.add("c10af932-9c29-11b1-9dad-c379636f7270"); // thereExistAtMost
    guidStrings.add("c10af5e7-9c29-11b1-9dad-c379636f7270"); // thereExistAtLeast
    guidStrings.add("94f07021-8b0d-11d7-8701-0002b3a8515d"); // SubLQuoteFn
    guidStrings.add("c0b2bc13-9c29-11b1-9dad-c379636f7270"); // ExpandSubLFn

    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-info-from-guid-strings"));
    command.addQuoted(guidStrings);

    CycList constantInfos = converseList(command);
    Iterator iter = constantInfos.iterator();
    HashMap constantInfoDictionary = new HashMap();

    while (iter.hasNext()) {
      Object constantInfoObject = iter.next();

      if (constantInfoObject instanceof CycList) {
        CycList constantInfo = (CycList) constantInfoObject;
        Guid guid = CycObjectFactory.makeGuid((String) constantInfo.first());
        String name = (String) constantInfo.second();
        constantInfoDictionary.put(guid, name);
      }
    }

    Guid guid = null;
    
    if (this.trueConst == null) { 
      trueConst = makePrefetchedConstant("bd5880d9-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.falseConst == null) { 
      falseConst = makePrefetchedConstant("bd5880d8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.xorConst == null) { 
      xorConst = makePrefetchedConstant("bde7f9f2-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.equivConst == null) { 
      equivConst = makePrefetchedConstant("bda887b6-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.impliesConst == null) { 
      impliesConst = makePrefetchedConstant("bd5880f8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.forAllConst == null) { 
      forAllConst = makePrefetchedConstant("bd5880f7-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistsConst == null) { 
      thereExistsConst = makePrefetchedConstant("bd5880f6-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistExactlyConst == null) { 
      thereExistExactlyConst = makePrefetchedConstant("c10ae7b8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistAtMostConst == null) { 
      thereExistAtMostConst = makePrefetchedConstant("c10af932-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistAtLeastConst == null) { 
      thereExistAtLeastConst = makePrefetchedConstant("c10af5e7-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.sublQuoteFnConst == null) { 
      sublQuoteFnConst = makePrefetchedConstant("94f07021-8b0d-11d7-8701-0002b3a8515d", constantInfoDictionary);
    }
    if (this.expandSubLFnConst == null) { 
      expandSubLFnConst = makePrefetchedConstant("c0b2bc13-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    
    if (baseKB == null) {
      guid = CycObjectFactory.makeGuid("bd588111-9c29-11b1-9dad-c379636f7270");
      baseKB = makeELMt(makeConstantWithGuidName(guid, 
                                                 (String) constantInfoDictionary.get(guid)));
      CycObjectFactory.addCycConstantCacheByName((CycConstant) baseKB);
      CycObjectFactory.addCycConstantCacheByGuid((CycConstant) baseKB);
    }

    if (isa == null) {
      guid = CycObjectFactory.makeGuid("bd588104-9c29-11b1-9dad-c379636f7270");
      isa = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCacheByName(isa);
      CycObjectFactory.addCycConstantCacheByGuid(isa);
    }

    if (genls == null) {
      guid = CycObjectFactory.makeGuid("bd58810e-9c29-11b1-9dad-c379636f7270");
      genls = makeConstantWithGuidName(guid, 
                                       (String) constantInfoDictionary.get(
                                             guid));
      CycObjectFactory.addCycConstantCacheByName(genls);
      CycObjectFactory.addCycConstantCacheByGuid(genls);
    }

    if (genlMt == null) {
      guid = CycObjectFactory.makeGuid("bd5880e5-9c29-11b1-9dad-c379636f7270");
      genlMt = makeConstantWithGuidName(guid, 
                                        (String) constantInfoDictionary.get(
                                              guid));
      CycObjectFactory.addCycConstantCacheByName(genlMt);
      CycObjectFactory.addCycConstantCacheByGuid(genlMt);
    }

    if (comment == null) {
      guid = CycObjectFactory.makeGuid("bd588109-9c29-11b1-9dad-c379636f7270");
      comment = makeConstantWithGuidName(guid, 
                                         (String) constantInfoDictionary.get(
                                               guid));
      CycObjectFactory.addCycConstantCacheByName(comment);
      CycObjectFactory.addCycConstantCacheByGuid(comment);
    }

    if (collection == null) {
      guid = CycObjectFactory.makeGuid("bd5880cc-9c29-11b1-9dad-c379636f7270");
      collection = makeConstantWithGuidName(guid, 
                                            (String) constantInfoDictionary.get(
                                                  guid));
      CycObjectFactory.addCycConstantCacheByName(collection);
      CycObjectFactory.addCycConstantCacheByGuid(collection);
    }

    if (binaryPredicate == null) {
      guid = CycObjectFactory.makeGuid("bd588102-9c29-11b1-9dad-c379636f7270");
      binaryPredicate = makeConstantWithGuidName(guid, 
                                                 (String) constantInfoDictionary.get(
                                                       guid));
      CycObjectFactory.addCycConstantCacheByName(binaryPredicate);
      CycObjectFactory.addCycConstantCacheByGuid(binaryPredicate);
    }

    if (elementOf == null) {
      guid = CycObjectFactory.makeGuid("c0659a2b-9c29-11b1-9dad-c379636f7270");
      elementOf = makeConstantWithGuidName(guid, 
                                           (String) constantInfoDictionary.get(
                                                 guid));
      CycObjectFactory.addCycConstantCacheByName(elementOf);
      CycObjectFactory.addCycConstantCacheByGuid(elementOf);
    }

    if (and == null) {
      guid = CycObjectFactory.makeGuid("bd5880f9-9c29-11b1-9dad-c379636f7270");
      and = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCacheByName(and);
      CycObjectFactory.addCycConstantCacheByGuid(and);
    }

    if (or == null) {
      guid = CycObjectFactory.makeGuid("bd5880fa-9c29-11b1-9dad-c379636f7270");
      or = makeConstantWithGuidName(guid, 
                                    (String) constantInfoDictionary.get(
                                          guid));
      CycObjectFactory.addCycConstantCacheByName(or);
      CycObjectFactory.addCycConstantCacheByGuid(or);
    }

    if (not == null) {
      guid = CycObjectFactory.makeGuid("bd5880fb-9c29-11b1-9dad-c379636f7270");
      not = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCacheByName(not);
      CycObjectFactory.addCycConstantCacheByGuid(not);
    }

    if (numericallyEqual == null) {
      guid = CycObjectFactory.makeGuid("bd589d90-9c29-11b1-9dad-c379636f7270");
      numericallyEqual = makeConstantWithGuidName(guid, 
                                                  (String) constantInfoDictionary.get(
                                                        guid));
      CycObjectFactory.addCycConstantCacheByName(numericallyEqual);
      CycObjectFactory.addCycConstantCacheByGuid(numericallyEqual);
    }

    if (plusFn == null) {
      guid = CycObjectFactory.makeGuid("bd5880ae-9c29-11b1-9dad-c379636f7270");
      plusFn = makeConstantWithGuidName(guid, 
                                        (String) constantInfoDictionary.get(
                                              guid));
      CycObjectFactory.addCycConstantCacheByName(plusFn);
      CycObjectFactory.addCycConstantCacheByGuid(plusFn);
    }

    if (different == null) {
      guid = CycObjectFactory.makeGuid("bd63f343-9c29-11b1-9dad-c379636f7270");
      different = makeConstantWithGuidName(guid, 
                                           (String) constantInfoDictionary.get(
                                                 guid));
      CycObjectFactory.addCycConstantCacheByName(different);
      CycObjectFactory.addCycConstantCacheByGuid(different);
    }

    if (thing == null) {
      guid = CycObjectFactory.makeGuid("bd5880f4-9c29-11b1-9dad-c379636f7270");
      thing = makeConstantWithGuidName(guid, 
                                       (String) constantInfoDictionary.get(
                                             guid));
      CycObjectFactory.addCycConstantCacheByName(thing);
      CycObjectFactory.addCycConstantCacheByGuid(thing);
    }

    if (inferencePSC == null) {
      guid = CycObjectFactory.makeGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
      inferencePSC = makeELMt(makeConstantWithGuidName(
                                    guid, 
                                    (String) constantInfoDictionary.get(
                                          guid)));
      CycObjectFactory.addCycConstantCacheByName((CycConstant) inferencePSC);
      CycObjectFactory.addCycConstantCacheByGuid((CycConstant) inferencePSC);
    }

    if ((!isLegacyMode) && (universalVocabularyMt == null)) {
      guid = CycObjectFactory.makeGuid("dff4a041-4da2-11d6-82c0-0002b34c7c9f");
      universalVocabularyMt = makeELMt(makeConstantWithGuidName(
                                             guid, 
                                             (String) constantInfoDictionary.get(
                                                   guid)));
      CycObjectFactory.addCycConstantCacheByName((CycConstant) universalVocabularyMt);
      CycObjectFactory.addCycConstantCacheByGuid((CycConstant) universalVocabularyMt);
    }

    if (bookkeepingMt == null) {
      guid = CycObjectFactory.makeGuid("beaed5bd-9c29-11b1-9dad-c379636f7270");
      bookkeepingMt = makeELMt(makeConstantWithGuidName(
                                     guid, 
                                     (String) constantInfoDictionary.get(
                                           guid)));
      CycObjectFactory.addCycConstantCacheByName((CycConstant) bookkeepingMt);
      CycObjectFactory.addCycConstantCacheByGuid((CycConstant) bookkeepingMt);
    }
  }
  
  private CycConstant makePrefetchedConstant(String guidStr, HashMap constantInfoDictionary) {
    Guid guid = CycObjectFactory.makeGuid(guidStr);
    CycConstant prefetchedConstant = makeConstantWithGuidName(guid, 
      (String)constantInfoDictionary.get(guid));
    CycObjectFactory.addCycConstantCacheByName(prefetchedConstant);
    CycObjectFactory.addCycConstantCacheByGuid(prefetchedConstant);
    return prefetchedConstant;
  }

  /**
   * Gets a known CycConstant by using its constant name.
   * 
   * @@param constantName the name of the constant to be instantiated
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant getKnownConstantByName(String constantName)
                                     throws IOException, UnknownHostException, CycApiException {
    CycConstant cycConstant = getConstantByName(constantName);

    if (cycConstant == null) {
      throw new CycApiException("Expected constant not found " + constantName);
    }

    return cycConstant;
  }

  /**
   * Gets a CycConstant by using its constant name.
   * 
   * @@param constantName the name of the constant to be instantiated
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise return null
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant getConstantByName(String constantName)
                                throws IOException, UnknownHostException, CycApiException {
    String name = constantName;

    if (constantName.startsWith("#$")) {
      name = name.substring(2);
    }

    CycConstant answer = CycObjectFactory.getCycConstantCacheByName(name);

    if (answer != null) {
      return answer;
    }

    answer = new CycConstant();
    answer.setName(name);

    Integer id = getConstantId(name);

    if (id == null) {
      return null;
    }

    answer.setId(id);
    answer.setGuid(getConstantGuid(name));
    CycObjectFactory.addCycConstantCacheByName(answer);
    CycObjectFactory.addCycConstantCacheById(answer);

    return answer;
  }

  /**
   * Gets the ID for the given CycConstant.
   * 
   * @@param cycConstant the <tt>CycConstant</tt> object for which the id is sought
   * 
   * @@return the ID for the given CycConstant, or null if the constant does not exist.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Integer getConstantId(CycConstant cycConstant)
                        throws IOException, UnknownHostException, CycApiException {
    return getConstantId(cycConstant.getName());
  }

  /**
   * Gets the ID for the given constant name.
   * 
   * @@param constantName the name of the constant object for which the id is sought
   * 
   * @@return the ID for the given constant name, or null if the constant does not exist.
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws CycApiException if the api request results in a cyc server error
   * @@throws RuntimeException if a NumberFormatException is thrown when parsing the constant id
   */
  public Integer getConstantId(String constantName)
                        throws IOException, UnknownHostException, CycApiException {
    String command = "(fif " + "  (cand (boolean (find-constant \"" + constantName + "\"))\n" + 
                     "        (valid-constant? (find-constant \"" + constantName + "\")))" + 
                     "  (constant-internal-id (find-constant \"" + constantName + "\"))" + 
                     "  nil)";
    Object obj = converseObject(command);

    if (!(obj instanceof Integer)) {
      return null;
    }

    try {
      return new Integer(converseInt(command));
    }
     catch (NumberFormatException e) {
      e.printStackTrace();
      throw new RuntimeException("NumberFormatException\n" + e.getMessage() + "\nConstantName: " + 
                                 constantName);
    }
  }

  /**
   * Gets the constant ID for the given constant guid.
   * 
   * @@param guid the name of the constant object for which the id is sought
   * 
   * @@return the ID for the given constant name, or null if the constant does not exist.
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws CycApiException if the api request results in a cyc server error
   * @@throws RuntimeException if a NumberFormatException is thrown when parsing the constant id
   */
  public Integer getConstantId(Guid guid)
                        throws IOException, UnknownHostException, CycApiException {
    String command = "(fif " + 
                     "  (cand (boolean (find-constant-by-external-id (string-to-guid \"" + 
                     guid.toString() + "\")))\n" + 
                     "        (valid-constant? (find-constant-by-external-id (string-to-guid \"" + 
                     guid.toString() + "\"))))" + 
                     "  (constant-internal-id (find-constant-by-external-id (string-to-guid \"" + 
                     guid.toString() + "\")))" + "  nil)";
    Object obj = converseObject(command);

    if (!(obj instanceof Integer)) {
      return null;
    }

    try {
      return new Integer(converseInt(command));
    }
     catch (NumberFormatException e) {
      e.printStackTrace();
      throw new RuntimeException("NumberFormatException\n" + e.getMessage() + "\nGUID: " + guid);
    }
  }

  /**
   * Gets the Guid for the given CycConstant, raising an exception if the constant does not exist.
   * 
   * @@param cycConstant the <tt>CycConstant</tt> object for which the id is sought
   * 
   * @@return the Guid for the given CycConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Guid getConstantGuid(CycConstant cycConstant)
                       throws IOException, UnknownHostException, CycApiException {
    return getConstantGuid(cycConstant.getName());
  }

  /**
   * Gets the Guid for the given constant name, raising an exception if the constant does not
   * exist.
   * 
   * @@param constantName the name of the constant object for which the Guid is sought
   * 
   * @@return the Guid for the given CycConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Guid getConstantGuid(String constantName)
                       throws IOException, UnknownHostException, CycApiException {
    String command = "(guid-to-string (constant-external-id (find-constant \"" + constantName + 
                     "\")))";

    return CycObjectFactory.makeGuid(converseString(command));
  }

  /**
   * Gets the Guid for the given constant id.
   * 
   * @@param id the id of the <tt>CycConstant</tt> whose guid is sought
   * 
   * @@return the Guid for the given CycConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Guid getConstantGuid(Integer id)
                       throws IOException, UnknownHostException, CycApiException {
    // Optimized for the binary api.
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("guid-to-string"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("constant-external-id"));

    CycList command2 = new CycList();
    command1.add(command2);
    command2.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
    command2.add(id);

    return CycObjectFactory.makeGuid(converseString(command));
  }

  /**
   * Gets a <tt>CycConstant</tt> by using its ID.
   * 
   * @@param id the id of the <tt>CycConstant</tt> sought
   * 
   * @@return the <tt>CycConstant</tt> if found or <tt>null</tt> if not found
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant getConstantById(Integer id)
                              throws IOException, UnknownHostException, CycApiException {
    // Optimized for the binary api.
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("boolean"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
    command1.add(id);

    boolean constantExists = converseBoolean(command);

    if (!constantExists) {
      return null;
    }

    CycConstant answer = new CycConstant();
    answer.setName(getConstantName(id));
    answer.setId(id);
    answer.setGuid(getConstantGuid(id));
    CycObjectFactory.addCycConstantCacheByName(answer);
    CycObjectFactory.addCycConstantCacheById(answer);

    return answer;
  }

  /**
   * Gets a <tt>CycAssertion</tt> by using its ID.
   * 
   * @@param id the id of the <tt>CycAssertion</tt> sought
   * 
   * @@return the <tt>CycAssertion</tt> if found or <tt>null</tt> if not found
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycAssertion getAssertionById(Integer id)
                              throws IOException, UnknownHostException, CycApiException {
    String command = "(find-assertion-by-id " + id + ")";
    Object obj = converseObject(command);

    if (obj.equals(new CycSymbol("NIL")))
      return null;
    else if (! (obj instanceof CycAssertion))
      throw new RuntimeException(obj + " is not a CycAssertion");
    else
      return (CycAssertion)obj;
  }

  /**
   * Gets the name for the given constant id.
   * 
   * @@param id the id of the constant object for which the name is sought
   * 
   * @@return the name for the given CycConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getConstantName(Integer id)
                         throws IOException, UnknownHostException, CycApiException {
    // Optimized for the binary api.
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-name"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
    command1.add(id);

    return converseString(command);
  }

  /**
   * Gets the name for the given constant guid.
   * 
   * @@param guid the guid of the constant object for which the name is sought
   * 
   * @@return the name for the given CycConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getConstantName(Guid guid)
                         throws IOException, UnknownHostException, CycApiException {
    // Optimized for the binary api.
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-name"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-external-id"));

    CycList command2 = new CycList();
    command1.add(command2);
    command2.add(CycObjectFactory.makeCycSymbol("string-to-guid"));
    command2.add(guid.toString());

    return converseString(command);
  }

  /**
   * Gets the name for the given variable id.
   * 
   * @@param id the id of the variable object for which the name is sought
   * 
   * @@return the name for the given CycVariable
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getVariableName(Integer id)
                         throws IOException, UnknownHostException, CycApiException {
    // Optimized for the binary api.
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("variable-name"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("find-variable-by-id"));
    command1.add(id);

    return converseString(command);
  }

  /**
   * Gets a known CycConstant by using its GUID string.
   * 
   * @@param guidString the globally unique ID string of the constant to be instantiated
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant getKnownConstantByGuid(String guidString)
                                     throws IOException, UnknownHostException, CycApiException {
    Guid guid = CycObjectFactory.makeGuid(guidString);

    return getKnownConstantByGuid(guid);
  }

  /**
   * Gets a known CycConstant by using its GUID.
   * 
   * @@param guid the globally unique ID of the constant to be instantiated
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant getKnownConstantByGuid(Guid guid)
                                     throws IOException, UnknownHostException, CycApiException {
    CycConstant cycConstant = getConstantByGuid(guid);

    if (cycConstant == null) {
      throw new CycApiException("Expected constant not found " + guid);
    }

    return cycConstant;
  }

  /**
   * Gets a CycConstant by using its GUID.
   * 
   * @@param guid the GUID from which to find the constant
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise return <tt>null</tt>
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant getConstantByGuid(Guid guid)
                                throws IOException, UnknownHostException, CycApiException {
    CycConstant answer = CycObjectFactory.getCycConstantCacheByGuid(
                               guid);

    if (answer != null) {
      return answer;
    }

    answer = new CycConstant();
    answer.setGuid(guid);

    String command = "(fif (boolean (find-constant-by-external-id " + 
                     "                (string-to-guid \"" + guid.toString() + "\")))" + 
                     "  (constant-name (find-constant-by-external-id (string-to-guid \"" + 
                     guid.toString() + "\")))" + "  nil)";
    Object nameObj = converseObject(command);

    if (!(nameObj instanceof String)) {
      return null;
    }

    answer.setName((String) nameObj);

    Integer id = getConstantId((String) nameObj);

    if (id == null) {
      return null;
    }

    answer.setId(id);
    CycObjectFactory.addCycConstantCacheByName(answer);
    CycObjectFactory.addCycConstantCacheById(answer);
    CycObjectFactory.addCycConstantCacheByGuid(answer);

    return answer;
  }

  /**
   * Makes a known CycConstant by using its GUID and name. This method does not access the Cyc
   * server.
   * 
   * @@param guidString the known GUID string from which to make the constant
   * @@param constantName the known name to associate with the constant
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise return <tt>null</tt>
   */
  public CycConstant makeConstantWithGuidName(String guidString, 
                                              String constantName) {
    return makeConstantWithGuidName(CycObjectFactory.makeGuid(
                                          guidString), 
                                    constantName);
  }

  /**
   * Makes a known CycConstant by using its GUID and name. This method does not access the Cyc
   * server.
   * 
   * @@param guid the known GUID from which to make the constant
   * @@param constantName the known name to associate with the constant
   * 
   * @@return the complete <tt>CycConstant</tt> if found, otherwise return <tt>null</tt>
   */
  public CycConstant makeConstantWithGuidName(Guid guid, 
                                              String constantName) {
    CycConstant answer = CycObjectFactory.getCycConstantCacheByGuid(
                               guid);

    if (answer != null) {
      if ((answer.safeGetName() == null) && (constantName != null)) { 
        answer.setName(constantName); 
        CycObjectFactory.addCycConstantCacheByName(answer);
      }
      return answer;
    }

    answer = new CycConstant();
    answer.setGuid(guid);
    answer.setName(constantName);
    CycObjectFactory.addCycConstantCacheByName(answer);
    CycObjectFactory.addCycConstantCacheByGuid(answer);

    return answer;
  }

  /**
   * Completes the instantiation of objects contained in the given <tt>CycList</tt>. The binary api
   * sends only constant ids, and the constant names and guids must be retrieved if the constant
   * is not cached.
   * 
   * @@param object the <tt>CycConstant</tt> to be completed, or the <tt>Object</tt> whose embedded
   *        constants are to be completed
   * 
   * @@return the completed object, or a reference to a cached instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Object completeObject(Object object)
                        throws IOException, UnknownHostException, CycApiException {
    if (object instanceof CycConstant) {
      return completeCycConstant((CycConstant) object);
    }
    else if (object instanceof CycList) {
      return completeCycList((CycList) object);
    }
    else if (object instanceof CycNart) {
      return completeCycNart((CycNart) object);
    }
    else {
      return object;
    }
  }

  /**
   * Completes the instantiation of <tt>CycConstant</tt> returned by the binary api. The binary api
   * sends only constant ids, and the constant names and guids must be retrieved if the constant
   * is not cached.
   * 
   * @@param cycConstant the <tt>CycConstant</tt> whose name and guid are to be completed
   * 
   * @@return the completed <tt>CycConstant</tt> object, or a reference to the previously cached
   *         instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant completeCycConstant(CycConstant cycConstant)
                                  throws IOException, UnknownHostException, CycApiException {
    cycConstant.setName(getConstantName(cycConstant.getId()));

    CycConstant cachedConstant = CycObjectFactory.getCycConstantCacheByName(
                                       cycConstant.getName());

    if (cachedConstant == null) {
      cycConstant.setGuid(getConstantGuid(cycConstant.getId()));
      CycObjectFactory.addCycConstantCacheByName(cycConstant);

      return cycConstant;
    }
    else {
      return cachedConstant;
    }
  }

  /**
   * Completes the instantiation of HL <tt>CycVariable</tt> returned by the binary api. The binary
   * api sends only HL variable ids, and the variable name must be retrieved if the variable is
   * not cached.  The variable id is not used when sending variables to the binary api, instead
   * the variable is output as a symbol.  In the case where an EL variable is returned by the
   * binary api, then then variable name is already present.
   * 
   * @@param cycVariable the <tt>CycVariable</tt> whose name is to be completed
   * 
   * @@return the completed <tt>CycVariable</tt> object, or a reference to the previously cached
   *         instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycVariable completeCycVariable(CycVariable cycVariable)
                                  throws IOException, UnknownHostException, CycApiException {
    if (cycVariable.name == null) {
      cycVariable.name = getVariableName(cycVariable.hlVariableId);
    }

    CycVariable cachedVariable = CycObjectFactory.getCycVariableCache(
                                       cycVariable.name);

    if (cachedVariable == null) {
      CycObjectFactory.addCycVariableCache(cycVariable);

      return cycVariable;
    }
    else {
      return cachedVariable;
    }
  }

  /**
   * Completes the instantiation of objects contained in the given <tt>CycList</tt>. The binary api
   * sends only constant ids, and the constant names and guids must be retrieved if the constant
   * is not cached.
   * 
   * @@param cycList the <tt>CycList</tt> whose constants are to be completed
   * 
   * @@return the given list with completed objects
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList completeCycList(CycList cycList)
                          throws IOException, UnknownHostException, CycApiException {
    for (int i = 0; i < cycList.size(); i++) {
      Object element = cycList.get(i);

      if (element instanceof CycList) {
        completeCycList((CycList) element);
      }
      else if (element instanceof CycConstant) {
        // Replace element with the completed constant, which might be previously cached.
        cycList.set(i, 
                    completeCycConstant((CycConstant) element));
      }
      else if (element instanceof CycNart) {
        // Replace element with the completed constant, which might be previously cached.
        cycList.set(i, 
                    completeCycNart((CycNart) element));
      }
      else if (element instanceof CycVariable) {
        // Replace element with the completed variable, which might be previously cached.
        cycList.set(i, 
                    completeCycVariable((CycVariable) element));
      }
      else {
        completeObject(element);
      }
    }

    return cycList;
  }

  /**
   * Completes the instantiation of a <tt>CycNart</tt> returned by the binary api. The binary api
   * sends only constant ids, and the constant names and guids must be retrieved if the constant
   * is not cached.  Also finds the id of the CycNart if the functor and arguments are
   * instantiated.
   * 
   * @@param cycNart the <tt>CycNart</tt> whose constants are to be completed
   * 
   * @@return the completely instantiated CycNart
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycNart completeCycNart(CycNart cycNart)
                          throws IOException, UnknownHostException, CycApiException {
    Integer id = cycNart.safeGetId();

    if ((id == null) && cycNart.hasFunctorAndArgs()) {
      id = findNartId(cycNart);

      if (id != null) {
        cycNart.setId(id);
      }
    }

    if (id == null) {
      throw new CycApiException("CycNart has no id " + cycNart.safeToString());
    }

    return getCycNartById(cycNart.getId());
  }

  /**
   * Finds the id of a CycNart given its formula.
   * 
   * @@param cycNart the CycNart object with functor and arguments instantiated
   * 
   * @@return the id of the nart if found in the KB, otherwise null
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Integer findNartId(CycNart cycNart)
                     throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("find-nart"));
    command.addQuoted(cycNart.toCycList());

    Object object = converseObject(command);

    if (object.equals(CycObjectFactory.nil)) {
      return null;
    }

    CycNart foundCycNart = null;

    if (object instanceof CycNart) {
      foundCycNart = (CycNart) object;
    }
    else {
      throw new CycApiException("findNart did not return an null or a nart " + object + " (" + 
                                object.getClass() + ")");
    }

    command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("nart-id"));
    command.add(foundCycNart);

    return new Integer(converseInt(command));
  }

  /**
   * Gets a CycNart by using its id.
   * 
   * @@param id the nart id (local to the KB)
   * 
   * @@return the CycNart
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycNart getCycNartById(Integer id)
                         throws IOException, UnknownHostException, CycApiException {
    CycNart cycNart = CycObjectFactory.getCycNartCache(
                            id);

    if (cycNart != null) {
      return cycNart;
    }
    else {
      cycNart = new CycNart();
      cycNart.setId(id);
    }

    CycObjectFactory.addCycNartCache(cycNart);

    CycList command = new CycList();

    if (communicationMode == CycConnection.BINARY_MODE) {
      command.add(CycObjectFactory.makeCycSymbol("nart-hl-formula"));

      CycList command1 = new CycList();
      command.add(command1);
      command1.add(CycObjectFactory.makeCycSymbol("find-nart-by-id"));
      command1.add(id);

      CycList formula = converseList(command);
      cycNart.setFunctor((CycFort) formula.first());
      cycNart.setArguments((CycList) formula.rest());
    }
    else {
      command.add(CycObjectFactory.makeCycSymbol("nart-el-formula"));

      CycList command1 = new CycList();
      command.add(command1);
      command1.add(CycObjectFactory.makeCycSymbol("find-nart-by-id"));
      command1.add(id);

      CycList formula = converseList(command);
      cycNart.setFunctor((CycFort) formula.first());
      cycNart.setArguments((CycList) formula.rest());

      List arguments = cycNart.getArguments();

      for (int i = 0; i < arguments.size(); i++) {
        Object argument = arguments.get(i);

        if (argument instanceof CycList) {
          arguments.set(i, 
                        new CycNart((CycList) argument));
        }
      }
    }

    return cycNart;
  }

  /**
   * Gets the CycNart object from a Cons object that lists the names of its functor and its
   * arguments.
   * 
   * @@param elCons the given list which names the functor and arguments
   * 
   * @@return a CycNart object from a Cons object that lists the names of its functor and its
   *         arguments
   */
  public CycNart getCycNartFromCons(CycList elCons) {
    return new CycNart(elCons);
  }

  /**
   * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
   * 
   * @@param binaryPredicate the predicate
   * @@param arg1 the first argument related by the predicate
   * @@param arg2 the second argument related by the predicate
   * 
   * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2 otherwise
   *         false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean predicateRelates(CycConstant binaryPredicate, 
                                  CycFort arg1, 
                                  CycFort arg2)
                           throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    String command = "(pred-u-v-holds-in-any-mt " + binaryPredicate.stringApiValue() + " " + 
                     arg1.stringApiValue() + " " + arg2.stringApiValue() + ")";
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (response[1] == null) {
        return false;
      }
      else if (response[1].toString().equals("T")) {
        return true;
      }
      else {
        return false;
      }
    }
    else {
      throw new CycApiException(response[1].toString());
    }
  }

  /**
   * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
   * 
   * @@param binaryPredicate the predicate
   * @@param arg1 the first argument related by the predicate
   * @@param arg2 the second argument related by the predicate
   * @@param mt the relevant mt
   * 
   * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2 otherwise
   *         false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean predicateRelates(CycConstant binaryPredicate, 
                                  CycFort arg1, 
                                  CycFort arg2, 
                                  CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    String command = "(pred-u-v-holds " + binaryPredicate.stringApiValue() + " " + 
                     arg1.stringApiValue() + " " + arg2.stringApiValue() + " " + 
                     makeELMt(mt).stringApiValue() + ")";
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      if (response[1] == null) {
        return false;
      }
      else if (response[1].toString().equals("T")) {
        return true;
      }
      else {
        return false;
      }
    }
    else {
      throw new CycApiException(response[1].toString());
    }
  }

  /**
   * Gets the imprecise plural generated phrase for a CycFort (intended for collections).
   * 
   * @@param cycFort the term for paraphrasing
   * 
   * @@return the imprecise plural generated phrase for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getImprecisePluralGeneratedPhrase(CycFort cycFort)
                                           throws IOException, UnknownHostException, 
                                                  CycApiException {
    return converseString("(with-precise-paraphrase-off (generate-phrase " + 
                          cycFort.stringApiValue() + " '(#$plural)))");
  }

  /**
   * Gets the plural generated phrase for a CycFort (intended for collections).
   * 
   * @@param cycObject the term for paraphrasing
   * 
   * @@return the plural generated phrase for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getPluralGeneratedPhrase(CycObject cycObject)
                                  throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseString("(with-precise-paraphrase-on (generate-phrase " + 
                          cycObject.stringApiValue() + " '(#$plural)))");
  }

  /**
   * Gets the imprecise singular generated phrase for a CycFort (intended for individuals).
   * 
   * @@param cycObject the term for paraphrasing
   * 
   * @@return the singular generated phrase for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getImpreciseSingularGeneratedPhrase(CycObject cycObject)
                                             throws IOException, UnknownHostException, 
                                                    CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseString("(with-precise-paraphrase-off (generate-phrase " + 
                          cycObject.stringApiValue() + " '(#$singular)))");
  }

  /**
   * Gets the singular generated phrase for a CycFort (intended for individuals).
   * 
   * @@param cycObject the term for paraphrasing
   * 
   * @@return the singular generated phrase for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getSingularGeneratedPhrase(CycObject cycObject)
                                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseString("(with-precise-paraphrase-on (generate-phrase " + 
                          cycObject.stringApiValue() + " '(#$singular)))");
  }

  /**
   * Gets the default generated phrase for a CycFort (intended for predicates).
   * 
   * @@param cycObject the predicate term for paraphrasing
   * 
   * @@return the default generated phrase for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getGeneratedPhrase(CycObject cycObject)
                            throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseString("(with-precise-paraphrase-on (generate-phrase " + 
                          cycObject.stringApiValue() + "))");
  }

  /**
   * Gets the paraphrase for a Cyc assertion.
   * 
   * @@param assertion the assertion formula
   * 
   * @@return the paraphrase for a Cyc assertion
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getParaphrase(CycList assertion)
                       throws IOException, UnknownHostException, CycApiException {
    return converseString("(with-precise-paraphrase-on (generate-phrase " + assertion.stringApiValue() + 
                          "))");
  }

  /**
   * Gets the imprecise paraphrase for a Cyc assertion.
   * 
   * @@param assertionString the assertion formula
   * 
   * @@return the imprecise paraphrase for a Cyc assertion
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getImpreciseParaphrase(String assertionString)
                                throws IOException, UnknownHostException, CycApiException {
    CycList assertion = this.makeCycList(assertionString);

    return converseString("(with-precise-paraphrase-off (generate-phrase " + 
                          assertion.stringApiValue() + "))");
  }

  /**
   * Gets the imprecise paraphrase for a Cyc assertion.
   * 
   * @@param assertion the assertion formula
   * 
   * @@return the imprecise paraphrase for a Cyc assertion
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getImpreciseParaphrase(CycList assertion)
                                throws IOException, UnknownHostException, CycApiException {
    return converseString("(with-precise-paraphrase-off (generate-phrase " + 
                          assertion.stringApiValue() + "))");
  }

  /**
   * Gets the comment for a CycFort.  Embedded quotes are replaced by spaces.
   * 
   * @@param cycObject the term for which the comment is sought
   * 
   * @@return the comment for the given CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getComment(CycObject cycObject)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    if (cycObject instanceof CycList)
      return null;
    String script = "(clet ((comment-string \n" + "         (with-all-mts (comment " + 
                    cycObject.stringApiValue() + ")))) \n" + "  (fif comment-string \n" + 
                    "       (string-substitute \" \" \"\\\"\" comment-string) \n" + 
                    "       \"\"))";

    return converseString(script);
  }

  /**
   * Gets the comment for a CycFort in the relevant mt. Embedded quotes are replaced by spaces.
   * 
   * @@param cycFort the term for which the comment is sought
   * @@param mt the relevant mt from which the comment is visible
   * 
   * @@return the comment for the given CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public String getComment(CycFort cycFort, 
                           CycObject mt)
                    throws IOException, UnknownHostException, CycApiException {
    String script = "(clet ((comment-string \n" + "         (comment " + 
                    cycFort.stringApiValue() + " " + makeELMt(
                                                           mt).stringApiValue() + "))) \n" + 
                    "  (fif comment-string \n" + 
                    "       (string-substitute \" \" \"\\\"\" comment-string) \n" + 
                    "       \"\"))";

    return converseString(script);
  }

  /**
   * Gets the list of the isas for the given CycFort.
   * 
   * @@param cycObject the term for which its isas are sought
   * 
   * @@return the list of the isas for the given CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getIsas(CycObject cycObject)
                  throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(remove-duplicates (with-all-mts (isa " + cycObject.stringApiValue() + 
                        ")))");
  }

  /**
   * Gets the list of the isas for the given CycFort.
   * 
   * @@param cycFort the term for which its isas are sought
   * @@param mt the relevant mt
   * 
   * @@return the list of the isas for the given CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getIsas(CycFort cycFort, 
                         CycObject mt)
                  throws IOException, UnknownHostException, CycApiException {
    return converseList("(isa " + cycFort.stringApiValue() + " " + makeELMt(
                                                                         mt).stringApiValue() + 
                        ")");
  }

  /**
   * Gets the list of the directly asserted true genls for the given CycFort collection.
   * 
   * @@param cycObject the given term
   * 
   * @@return the list of the directly asserted true genls for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenls(CycObject cycObject)
                   throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(remove-duplicates (with-all-mts (genls " + cycObject.stringApiValue() + 
                        ")))");
  }

  /**
   * Gets the list of the directly asserted true genls for the given CycFort collection.
   * 
   * @@param cycFort the given term
   * @@param mt the relevant mt
   * 
   * @@return the list of the directly asserted true genls for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenls(CycFort cycFort, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return converseList("(genls " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the minimum (most specific) genls for a CycFort collection.
   * 
   * @@param cycFort the given collection term
   * 
   * @@return a list of the minimum (most specific) genls for a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinGenls(CycFort cycFort)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (min-genls " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets a list of the minimum (most specific) genls for a CycFort collection.
   * 
   * @@param cycFort the collection
   * @@param mt the microtheory in which to look
   * 
   * @@return a list of the minimum (most specific) genls for a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinGenls(CycFort cycFort, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(min-genls " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the directly asserted true specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the directly asserted true specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSpecs(CycFort cycFort)
                   throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (specs " + cycFort.stringApiValue() + 
                        ")))");
  }

  /**
   * Gets the list of the directly asserted true specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the microtheory in which to look
   * 
   * @@return the list of the directly asserted true specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSpecs(CycFort cycFort, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return converseList("(specs " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the least specific specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the least specific specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMaxSpecs(CycFort cycFort)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (max-specs " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the least specific specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the microtheory in which to look
   * 
   * @@return the list of the least specific specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMaxSpecs(CycFort cycFort, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(max-specs " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the direct genls of the direct specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the direct genls of the direct specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenlSiblings(CycFort cycFort)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (genl-siblings " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the direct genls of the direct specs for the given CycFort collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the microtheory in which to look
   * 
   * @@return the list of the direct genls of the direct specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenlSiblings(CycFort cycFort, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(genl-siblings " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSiblings(CycFort cycFort)
                      throws IOException, UnknownHostException, CycApiException {
    return getSpecSiblings(cycFort);
  }

  /**
   * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the microtheory in which to look
   * 
   * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSiblings(CycFort cycFort, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return getSpecSiblings(cycFort, 
                           mt);
  }

  /**
   * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSpecSiblings(CycFort cycFort)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (spec-siblings " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the microtheory in which to look
   * 
   * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSpecSiblings(CycFort cycFort, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(spec-siblings " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of all of the direct and indirect genls for the given CycFort collection.
   * 
   * @@param cycFort the collection
   * 
   * @@return the list of all of the direct and indirect genls for a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenls(CycFort cycFort)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-genls-in-any-mt " + cycFort.stringApiValue() + ")");
  }

  /**
   * Gets the list of all of the direct and indirect genls for a CycFort collection given a
   * relevant microtheory.
   * 
   * @@param cycFort the collection
   * @@param mt the relevant mt
   * 
   * @@return the list of all of the direct and indirect genls for a CycFort collection given a
   *         relevant microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenls(CycFort cycFort, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-genls " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of all of the direct and indirect specs for a CycFort collection.
   * 
   * @@param cycFort the collection
   * 
   * @@return the list of all of the direct and indirect specs for the given collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecs(CycFort cycFort)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-specs " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the direct and indirect specs for the given collection in the given
   * microtheory.
   * 
   * @@param cycFort the collection
   * @@param mt the microtheory
   * 
   * @@return the list of all of the direct and indirect specs for the given collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecs(CycFort cycFort, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-specs " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a hashset of all of the direct and indirect specs for a CycFort collection.
   * 
   * @@param cycFort the collection
   * 
   * @@return the hashset of all of the direct and indirect specs for the given collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecsHashSet(CycFort cycFort)
                             throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecs(cycFort));
  }

  /**
   * Gets the hashset of all of the direct and indirect specs for the given collection in the given
   * microtheory.
   * 
   * @@param cycFort the collection
   * @@param mt the given microtheory
   * 
   * @@return the hashset of all of the direct and indirect specs for the given collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecsHashSet(CycFort cycFort, 
                                    CycObject mt)
                             throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecs(cycFort, 
                                   mt));
  }

  /**
   * Gets the list of all of the direct and indirect genls for a CycFort SPEC which are also specs
   * of CycFort GENL.
   * 
   * @@param spec the given collection
   * @@param genl the more general collection
   * 
   * @@return the list of all of the direct and indirect genls for a CycFort SPEC which are also
   *         specs of CycFort GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenlsWrt(CycFort spec, 
                                CycFort genl)
                         throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-genls-wrt " + 
                        spec.stringApiValue() + " " + genl.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the direct and indirect genls for a CycFort SPEC which are also specs
   * of CycFort GENL.
   * 
   * @@param spec the given collection
   * @@param genl the more general collection
   * @@param mt the relevant mt
   * 
   * @@return the list of all of the direct and indirect genls for a CycFort SPEC which are also
   *         specs of CycFort GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenlsWrt(CycFort spec, 
                                CycFort genl, 
                                CycObject mt)
                         throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-genls-wrt " + spec.stringApiValue() + " " + genl.stringApiValue() + 
                        " " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of all of the dependent specs for a CycFort collection.  Dependent specs are
   * those direct and indirect specs of the collection such that every path connecting the spec to
   * a genl of the collection passes through the collection.  In a typical taxomonmy it is
   * expected that all-dependent-specs gives the same result as all-specs.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of all of the dependent specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllDependentSpecs(CycFort cycFort)
                               throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-dependent-specs " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the dependent specs for a CycFort collection.  Dependent specs are
   * those direct and indirect specs of the collection such that every path connecting the spec to
   * a genl of the collection passes through the collection.  In a typical taxomonmy it is
   * expected that all-dependent-specs gives the same result as all-specs.
   * 
   * @@param cycFort the given collection
   * @@param mt the relevant mt
   * 
   * @@return the list of all of the dependent specs for the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllDependentSpecs(CycFort cycFort, 
                                      CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-dependent-specs " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list with the specified number of sample specs of the given CycFort collection.
   * Attempts to return leaves that are maximally differet with regard to their all-genls.
   * 
   * @@param cycFort the given collection
   * @@param numberOfSamples the maximum number of sample specs returned
   * 
   * @@return the list with the specified number of sample specs of the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSampleLeafSpecs(CycFort cycFort, 
                                    int numberOfSamples)
                             throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (sample-leaf-specs " + cycFort.stringApiValue() + " " + 
                        numberOfSamples + "))");
  }

  /**
   * Gets the list with the specified number of sample specs of the given CycFort collection.
   * Attempts to return leaves that are maximally differet with regard to their all-genls.
   * 
   * @@param cycFort the given collection
   * @@param numberOfSamples the maximum number of sample specs returned
   * @@param mt the relevant mt
   * 
   * @@return the list with the specified number of sample specs of the given CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getSampleLeafSpecs(CycFort cycFort, 
                                    int numberOfSamples, 
                                    CycObject mt)
                             throws IOException, UnknownHostException, CycApiException {
    return converseList("(sample-leaf-specs " + cycFort.stringApiValue() + " " + numberOfSamples + 
                        " " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns the single most specific collection from the given list of collectons.
   * 
   * @@param collections the given collections
   * 
   * @@return the single most specific collection from the given list of collectons
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycFort getMinCol(CycList collections)
                    throws IOException, UnknownHostException, CycApiException {
    return (CycFort) converseObject("(with-all-mts (min-col " + collections.stringApiValue() + 
                                    "))");
  }

  /**
   * Returns the most specific collections from the given list of collectons.
   * 
   * @@param collections the given collections
   * 
   * @@return the most specific collections from the given list of collectons
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinCols(final CycList collections)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert collections != null : "collections cannot be null";                  
                      
    return converseList("(with-all-mts (min-cols " + collections.stringApiValue() + 
                                    "))");
  }

  /**
   * Returns true if CycFort SPEC is a spec of CycFort GENL.
   * 
   * @@param spec the considered spec collection
   * @@param genl the considered genl collection
   * 
   * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isSpecOf(CycFort spec, 
                          CycFort genl)
                   throws IOException, UnknownHostException, CycApiException {
    return isGenlOf(genl, 
                    spec);
  }

  /**
   * Returns true if CycFort SPEC is a spec of CycFort GENL.
   * 
   * @@param spec the considered spec collection
   * @@param genl the considered genl collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isSpecOf(CycFort spec, 
                          CycFort genl, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return isGenlOf(genl, 
                    spec, 
                    mt);
  }

  /**
   * Returns true if CycFort GENL is a genl of CycFort SPEC.
   * 
   * @@param genl the collection for genl determination
   * @@param spec the collection for spec determination
   * 
   * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlOf(CycFort genl, 
                          CycFort spec)
                   throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl-in-any-mt? " + spec.stringApiValue() + " " + 
                           genl.stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort GENL is a genl of CycFort SPEC, implements a cache to avoid asking the
   * same question twice from the KB.
   * 
   * @@param genl the collection for genl determination
   * @@param spec the collection for spec determination
   * 
   * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlOf_Cached(CycFort genl, 
                                 CycFort spec)
                          throws IOException, UnknownHostException, CycApiException {
    boolean answer;
    List args = new ArrayList();
    args.add(genl);
    args.add(spec);

    Boolean isGenlOf = (Boolean) isGenlOfCache.getElement(
                             args);

    if (isGenlOf != null) {
      answer = isGenlOf.booleanValue();

      return answer;
    }

    answer = isGenlOf(genl, 
                      spec);
    isGenlOfCache.addElement(args, 
                             new Boolean(answer));

    return answer;
  }

  /**
   * Returns true if CycFort GENL is a genl of CycFort SPEC in MT.
   * 
   * @@param genl the collection for genl determination
   * @@param spec the collection for spec determination
   * @@param mt the microtheory for spec determination
   * 
   * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC in MT
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlOf(CycFort genl, 
                          CycFort spec, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl? " + spec.stringApiValue() + " " + genl.stringApiValue() + " " + 
                           makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in MT.
   * 
   * @@param genlPred the predicate for genl-pred determination
   * @@param specPred the predicate for spec-pred determination
   * @@param mt the microtheory for subsumption determination
   * 
   * @@return <tt>true</tt> if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in MT
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlPredOf(CycFort genlPred, 
                              CycFort specPred, 
                              CycObject mt)
                       throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl-predicate? " + specPred.stringApiValue() + " " + 
                           genlPred.stringApiValue() + " " + makeELMt(
                                                                   mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in any MT.
   * 
   * @@param genlPred the predicate for genl-pred determination
   * @@param specPred the predicate for spec-pred determination
   * 
   * @@return <tt>true</tt> if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in any MT
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlPredOf(CycFort genlPred, 
                              CycFort specPred)
                       throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (genl-predicate? " + specPred.stringApiValue() + " " + 
                           genlPred.stringApiValue() + "))");
  }

  /**
   * Returns true if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in MT.
   * 
   * @@param genlPred the predicate for genl-inverse determination
   * @@param specPred the predicate for spec-inverse determination
   * @@param mt the microtheory for inverse subsumption determination
   * 
   * @@return <tt>true</tt> if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in MT
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlInverseOf(CycFort genlPred, 
                                 CycFort specPred, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl-inverse? " + specPred.stringApiValue() + " " + 
                           genlPred.stringApiValue() + " " + makeELMt(
                                                                   mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in any MT.
   * 
   * @@param genlPred the predicate for genl-inverse determination
   * @@param specPred the predicate for spec-inverse determination
   * 
   * @@return <tt>true</tt> if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in any MT
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlInverseOf(CycFort genlPred, 
                                 CycFort specPred)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (genl-inverse? " + specPred.stringApiValue() + " " + 
                           genlPred.stringApiValue() + "))");
  }

  /**
   * Returns true if CycFort GENLMT is a genl-mt of CycFort SPECPRED in mt-mt (currently
   * #$UniversalVocabularyMt).
   * 
   * @@param genlMt the microtheory for genl-mt determination
   * @@param specMt the microtheory for spec-mt determination
   * 
   * @@return <tt>true</tt> if CycFort GENLMT is a genl-mt of CycFort SPECPRED in mt-mt (currently
   *         #$UniversalVocabularyMt)
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlMtOf(CycObject genlMt, 
                            CycObject specMt)
                     throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl-mt? " + makeELMt(specMt).stringApiValue() + " " + 
                           makeELMt(genlMt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional via
   * mutual genls of each other.
   * 
   * @@param collection1 the first given collection
   * @@param collection2 the second given collection
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional via
   *         mutual genls of each other, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areTacitCoextensional(CycFort collection1, 
                                       CycFort collection2)
                                throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (tacit-coextensional? " + collection1.stringApiValue() + 
                           " " + collection2.stringApiValue() + "))");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional via
   * mutual genls of each other.
   * 
   * @@param collection1 the first given collection
   * @@param collection2 the second given collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional via
   *         mutual genls of each other, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areTacitCoextensional(CycFort collection1, 
                                       CycFort collection2, 
                                       CycObject mt)
                                throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(tacit-coextensional? " + collection1.stringApiValue() + " " + 
                           collection2.stringApiValue() + " " + makeELMt(
                                                                      mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional
   *         otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areAssertedCoextensional(CycFort collection1, 
                                          CycFort collection2)
                                   throws IOException, UnknownHostException, CycApiException {
    CycConstant coExtensional = this.getKnownConstantByGuid(
                                      "bd59083a-9c29-11b1-9dad-c379636f7270");

    if (predicateRelates(coExtensional, 
                         collection1, 
                         collection2)) {
      return true;
    }
    else if (predicateRelates(coExtensional, 
                              collection2, 
                              collection1)) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional
   *         otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areAssertedCoextensional(CycFort collection1, 
                                          CycFort collection2, 
                                          CycObject mt)
                                   throws IOException, UnknownHostException, CycApiException {
    CycConstant coExtensional = this.getKnownConstantByGuid(
                                      "bd59083a-9c29-11b1-9dad-c379636f7270");

    if (predicateRelates(coExtensional, 
                         collection1, 
                         collection2, 
                         mt)) {
      return true;
    }
    else if (predicateRelates(coExtensional, 
                              collection2, 
                              collection1, 
                              mt)) {
      return true;
    }
    else {
      return false;
    }
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs
   *         otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areIntersecting(CycFort collection1, 
                                 CycFort collection2)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (collections-intersect? " + 
                           collection1.stringApiValue() + " " + collection2.stringApiValue() + 
                           "))");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs
   *         otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areIntersecting(CycFort collection1, 
                                 CycFort collection2, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(collections-intersect? " + collection1.stringApiValue() + " " + 
                           collection2.stringApiValue() + " " + makeELMt(
                                                                      mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areHierarchical(CycFort collection1, 
                                 CycFort collection2)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (hierarchical-collections? " + 
                           collection1.stringApiValue() + " " + collection2.stringApiValue() + 
                           "))");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areHierarchical(CycFort collection1, 
                                 CycFort collection2, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(hierarchical-collections? " + collection1.stringApiValue() + 
                           collection2.stringApiValue() + " " + makeELMt(
                                                                      mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
   * getWhyGenl("Dog", "Animal") --> "(((#$genls #$Dog #$CanineAnimal) :TRUE) (#$genls
   * #$CanineAnimal #$NonPersonAnimal) :TRUE) (#$genls #$NonPersonAnimal #$Animal) :TRUE))
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * 
   * @@return the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyGenl(CycFort spec, 
                            CycFort genl)
                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (why-genl? " + spec.stringApiValue() + " " + 
                        genl.stringApiValue() + "))");
  }

  /**
   * Gets the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
   * getWhyGenl("Dog", "Animal") --> "(((#$genls #$Dog #$CanineAnimal) :TRUE) (#$genls
   * #$CanineAnimal #$NonPersonAnimal) :TRUE) (#$genls #$NonPersonAnimal #$Animal) :TRUE))
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyGenl(CycFort spec, 
                            CycFort genl, 
                            CycObject mt)
                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(why-genl? " + spec.stringApiValue() + " " + genl.stringApiValue() + 
                        " " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort
   * GENL. getWhyGenlParaphrase("Dog", "Animal") --> "a dog is a kind of canine" "a canine is a
   * kind of non-human animal" "a non-human animal is a kind of animal"
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * 
   * @@return the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort
   *         GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyGenlParaphrase(CycFort spec, 
                                        CycFort genl)
                                 throws IOException, UnknownHostException, CycApiException {
    CycList listAnswer = converseList("(with-all-mts (why-genl? " + spec.stringApiValue() + " " + 
                                      genl.stringApiValue() + "))");
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    CycList iter = listAnswer;

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort
   * GENL. getWhyGenlParaphrase("Dog", "Animal") --> "a dog is a kind of canine" "a canine is a
   * kind of non-human animal" "a non-human animal is a kind of animal"
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * @@param mt the relevant mt
   * 
   * @@return the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort
   *         GENL
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyGenlParaphrase(CycFort spec, 
                                        CycFort genl, 
                                        CycObject mt)
                                 throws IOException, UnknownHostException, CycApiException {
    CycList listAnswer = converseList("(why-genl? " + spec.stringApiValue() + " " + 
                                      genl.stringApiValue() + " " + 
                                      makeELMt(mt).stringApiValue() + ")");
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    CycList iter = listAnswer;

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2
   * intersect. see getWhyGenl
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2
   *         intersect
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyCollectionsIntersect(CycFort collection1, 
                                            CycFort collection2)
                                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (why-collections-intersect? " + 
                        collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
  }

  /**
   * Gets the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2
   * intersect. see getWhyGenl
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2
   *         intersect
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyCollectionsIntersect(CycFort collection1, 
                                            CycFort collection2, 
                                            CycObject mt)
                                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(why-collections-intersect? " + collection1.stringApiValue() + " " + 
                        collection2.stringApiValue() + " " + makeELMt(
                                                                   mt).stringApiValue() + ")");
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
   * COLLECTION2 intersect. see getWhyGenlParaphrase
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
   *         COLLECTION2 intersect
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyCollectionsIntersectParaphrase(CycFort collection1, 
                                                        CycFort collection2)
                                                 throws IOException, UnknownHostException, 
                                                        CycApiException {
    CycList listAnswer = converseList("(with-all-mts (why-collections-intersect? " + 
                                      collection1.stringApiValue() + " " + 
                                      collection2.stringApiValue() + "))");
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    CycList iter = listAnswer;

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();


      //Log.current.println("assertion: " + assertion);
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
   * COLLECTION2 intersect. see getWhyGenlParaphrase
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
   *         COLLECTION2 intersect
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyCollectionsIntersectParaphrase(CycFort collection1, 
                                                        CycFort collection2, 
                                                        CycObject mt)
                                                 throws IOException, UnknownHostException, 
                                                        CycApiException {
    CycList listAnswer = converseList("(with-all-mts (why-collections-intersect? " + 
                                      collection1.stringApiValue() + " " + 
                                      collection2.stringApiValue() + " " + 
                                      makeELMt(mt).stringApiValue() + ")");
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    CycList iter = listAnswer;

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();


      //Log.current.println("assertion: " + assertion);
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the list of the collection leaves (most specific of the all-specs) for a CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the collection leaves (most specific of the all-specs) for a CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getCollectionLeaves(CycFort cycFort)
                              throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (collection-leaves " + cycFort.stringApiValue() + "))");
  }

  /**
   * Gets the list of the collection leaves (most specific of the all-specs) for a CycFort
   * collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the collection leaves (most specific of the all-specs) for a CycFort
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getCollectionLeaves(CycFort cycFort, 
                                     CycObject mt)
                              throws IOException, UnknownHostException, CycApiException {
    return converseList("(collection-leaves " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the collections asserted to be disjoint with a CycFort collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the collections asserted to be disjoint with a CycFort collection
   * 
   * @@throws IOException if a communication error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getLocalDisjointWith(CycFort cycFort)
                               throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (local-disjoint-with " + cycFort.stringApiValue() + "))");
  }

  /**
   * Gets the list of the collections asserted to be disjoint with a CycFort collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the collections asserted to be disjoint with a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getLocalDisjointWith(CycFort cycFort, 
                                      CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    return converseList("(local-disjoint-with " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areDisjoint(CycFort collection1, 
                             CycFort collection2)
                      throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (disjoint-with? " + collection1.stringApiValue() + " " + 
                           collection2.stringApiValue() + "))");
  }

  /**
   * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint.
   * 
   * @@param collection1 the first collection
   * @@param collection2 the second collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean areDisjoint(CycFort collection1, 
                             CycFort collection2, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(with-all-mts (disjoint-with? " + collection1.stringApiValue() + " " + 
                           collection2.stringApiValue() + " " + makeELMt(
                                                                      mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the most specific collections (having no subsets) which contain a CycFort
   * term.
   * 
   * @@param cycFort the given term
   * 
   * @@return the list of the most specific collections (having no subsets) which contain a CycFort
   *         term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinIsas(CycFort cycFort)
                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (min-isa " + cycFort.stringApiValue() + "))");
  }

  /**
   * Gets the list of the most specific collections (having no subsets) which contain a CycFort
   * term.
   * 
   * @@param cycFort the given term
   * @@param mt the relevant mt
   * 
   * @@return the list of the most specific collections (having no subsets) which contain a CycFort
   *         term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinIsas(CycFort cycFort, 
                            CycObject mt)
                     throws IOException, UnknownHostException, CycApiException {
    return converseList("(min-isa " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the instances (who are individuals) of a CycFort collection.
   * 
   * @@param cycFort the given collection
   * 
   * @@return the list of the instances (who are individuals) of a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInstances(CycFort cycFort)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (instances " + cycFort.stringApiValue() + "))");
  }

  /**
   * Gets the list of the instances (who are individuals) of a CycFort collection.
   * 
   * @@param cycFort the given collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the instances (who are individuals) of a CycFort collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInstances(CycFort cycFort, 
                              CycObject mt)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(instances " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the instance siblings of a CycFort, for all collections of which it is an
   * instance.
   * 
   * @@param cycFort the given term
   * 
   * @@return the list of the instance siblings of a CycFort, for all collections of which it is an
   *         instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInstanceSiblings(CycFort cycFort)
                              throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (instance-siblings " + cycFort.stringApiValue() + "))");
  }

  /**
   * Gets the list of the instance siblings of a CycFort, for all collections of which it is an
   * instance.
   * 
   * @@param cycFort the given term
   * @@param mt the relevant mt
   * 
   * @@return the list of the instance siblings of a CycFort, for all collections of which it is an
   *         instance
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if an error is returned by the Cyc server
   */
  public CycList getInstanceSiblings(CycFort cycFort, 
                                     CycObject mt)
                              throws IOException, UnknownHostException, CycApiException {
    return converseList("(instance-siblings " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the collections of which the CycFort is directly and indirectly an instance.
   * 
   * @@param cycFort the given term
   * 
   * @@return the list of the collections of which the CycFort is directly and indirectly an
   *         instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllIsa(CycFort cycFort)
                    throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-isa-in-any-mt " + cycFort.stringApiValue() + ")");
  }

  /**
   * Gets the list of the collections of which the CycFort is directly and indirectly an instance.
   * 
   * @@param cycFort the given term
   * @@param mt the relevant mt
   * 
   * @@return the list of the collections of which the CycFort is directly and indirectly an
   *         instance
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllIsa(CycFort cycFort, 
                           CycObject mt)
                    throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-isa " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of all the direct and indirect instances (individuals) for a CycFort collection.
   * 
   * @@param cycFort the collection for which all the direct and indirect instances (individuals)
   *        are sought
   * 
   * @@return the list of all the direct and indirect instances (individuals) for the given
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllInstances(CycFort cycFort)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-instances-in-all-mts " + cycFort.stringApiValue() + ")");
  }

  /**
   * Gets a list of all the direct and indirect instances for a CycFort collection in
   * the given microtheory.
   * 
   * @@param cycFort the collection for which all the direct and indirect instances are sought
   * @@param mt the relevant mt
   * 
   * @@return the list of all the direct and indirect instances for the
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error given collection
   */
  public CycList getAllInstances(CycFort cycFort, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-instances " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of all the direct and indirect quoted instances for a CycFort collection in
   * the given microtheory.
   * 
   * @@param cycFort the collection for which all the direct and indirect quoted instances are sought
   * @@param mt the relevant mt
   * 
   * @@return the list of all the direct and indirect quoted instances for the CycFort collection in
   * the given microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error given collection
   */
  public CycList getAllQuotedInstances(final CycFort cycFort, final CycObject mt) throws IOException, UnknownHostException, CycApiException {
    CycList results = null;
    final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?QUOTED-INSTANCE");
    final CycList query = new CycList();
    query.add(getKnownConstantByName("quotedIsa"));
    query.add(queryVariable);
    query.add(cycFort);
    return queryVariable(queryVariable, query, mt, null);
  }
  
  
  /**
   * Gets a hashset of all the direct and indirect instances (individuals) for a CycFort collection
   * in the given microtheory.
   * 
   * @@param cycFort the collection for which all the direct and indirect instances (individuals)
   *        are sought
   * @@param mt the microtheory in which the inference is performed
   * 
   * @@return the list of all the direct and indirect instances (individuals) for the given
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllInstancesHashSet(CycFort cycFort, 
                                        CycObject mt)
                                 throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllInstances(cycFort, 
                                       mt));
  }

  /**
   * Gets a hashset of all the direct and indirect instances (individuals) for a CycFort collection
   * in the given microtheory.
   * 
   * @@param cycFort the collection for which all the direct and indirect instances (individuals)
   *        are sought
   * 
   * @@return the list of all the direct and indirect instances (individuals) for the given
   *         collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllInstancesHashSet(CycFort cycFort)
                                 throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllInstances(cycFort));
  }

  /**
   * Returns true if CycFort TERM is a instance of CycFort COLLECTION, defaulting to all
   * microtheories.
   * 
   * @@param term the term
   * @@param collectionName the name of the collection
   * 
   * @@return <tt>true</tt> if CycFort TERM is a instance of the CycFort named by COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isa(CycFort term, 
                     String collectionName)
              throws IOException, UnknownHostException, CycApiException {
    return isa(term, 
               getKnownConstantByName(collectionName));
  }

  /**
   * Returns true if CycFort TERM is a instance of CycFort COLLECTION, defaulting to all
   * microtheories.
   * 
   * @@param term the term
   * @@param collection the collection
   * 
   * @@return <tt>true</tt> if CycFort TERM is a instance of CycFort COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isa(CycObject term, 
                     CycFort collection)
              throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(isa-in-any-mt? " + term.stringApiValue() + " " + 
                           collection.stringApiValue() + ")");
  }

  /**
   * Returns true if CycFort TERM is a instance of CycFort COLLECTION, using the given microtheory.
   * Method implementation optimised for the binary api.
   * 
   * @@param term the term
   * @@param collection the collection
   * @@param mt the microtheory in which the ask is performed
   * 
   * @@return <tt>true</tt> if CycFort TERM is a instance of CycFort COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isa(CycFort term, 
                     CycFort collection, 
                     CycObject mt)
              throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("isa?"));
    command.add(term.cycListApiValue());
    command.add(collection.cycListApiValue());
    command.add(makeELMt(mt).cycListApiValue());

    return converseBoolean(command);
  }

  /**
   * Returns true if the quoted CycFort TERM is a instance of CycFort COLLECTION, in any microtheory.
   * Method implementation optimised for the binary api.
   * 
   * @@param term the term
   * @@param collection the collection
   * 
   * @@return <tt>true</tt> if the quoted CycFort TERM is a instance of CycFort COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQuotedIsa(CycFort term, CycFort collection)
              throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(getKnownConstantByName("quotedIsa"));
    query.add(term);
    query.add(collection);
    return isQueryTrue(query, inferencePSC, null);
  }

  /**
   * Gets the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
   * getWhyIsa("Brazil", "Country") --> "(((#$isa #$Brazil #$IndependentCountry) :TRUE) (#$genls
   * #$IndependentCountry #$Country) :TRUE))
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * 
   * @@return the list of the justifications of why CycFort TERM is an instance of CycFort
   *         COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyIsa(CycFort spec, 
                           CycFort genl)
                    throws IOException, UnknownHostException, CycApiException {
    return converseList("(with-all-mts (why-isa? " + spec.stringApiValue() + " " + 
                        genl.stringApiValue() + "))");
  }

  /**
   * Gets the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
   * getWhyIsa("Brazil", "Country") --> "(((#$isa #$Brazil #$IndependentCountry) :TRUE) (#$genls
   * #$IndependentCountry #$Country) :TRUE))
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * @@param mt the relevant mt
   * 
   * @@return the list of the justifications of why CycFort TERM is an instance of CycFort
   *         COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getWhyIsa(CycFort spec, 
                           CycFort genl, 
                           CycObject mt)
                    throws IOException, UnknownHostException, CycApiException {
    return converseList("(why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort TERM is an instance of
   * CycFort COLLECTION. getWhyGenlParaphase("Brazil", "Country") --> "Brazil is an independent
   * country" "an  independent country is a kind of country"
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * 
   * @@return the English parapharse of the justifications of why CycFort TERM is an instance of
   *         CycFort COLLECTION
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyIsaParaphrase(CycFort spec, 
                                       CycFort genl)
                                throws IOException, CycApiException {
    String command = "(with-all-mts (why-isa? " + spec.stringApiValue() + " " + 
                     genl.stringApiValue() + "))";
    CycList listAnswer = converseList(command);
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the English parapharse of the justifications of why CycFort TERM is an instance of
   * CycFort COLLECTION. getWhyGenlParaphase("Brazil", "Country") --> "Brazil is an independent
   * country" "an  independent country is a kind of country"
   * 
   * @@param spec the specialized collection
   * @@param genl the more general collection
   * @@param mt the relevant mt
   * 
   * @@return the English parapharse of the justifications of why CycFort TERM is an instance of
   *         CycFort COLLECTION
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public List getWhyIsaParaphrase(CycFort spec, 
                                       CycFort genl, 
                                       CycObject mt)
                                throws IOException, CycApiException {
    String command = "(why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() + " " + 
                     makeELMt(mt).stringApiValue() + ")";
    CycList listAnswer = converseList(command);
    List answerPhrases = new ArrayList();

    if (listAnswer.size() == 0) {
      return answerPhrases;
    }

    for (int i = 0; i < listAnswer.size(); i++) {
      CycList assertion = (CycList) ((CycList) listAnswer.get(
                                           i)).first();
      answerPhrases.add(getParaphrase(assertion));
    }

    return answerPhrases;
  }

  /**
   * Gets the list of the genlPreds for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * 
   * @@return the list of the more general predicates for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenlPreds(CycFort predicate)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (genl-predicates " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the genlPreds for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * @@param mt the relevant mt
   * 
   * @@return the list of the more general predicates for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getGenlPreds(CycFort predicate, 
                              CycObject mt)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(genl-predicates " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of all of the genlPreds for a CycConstant predicate, using an upward closure.
   * 
   * @@param predicate the predicate for which all the genlPreds are obtained
   * 
   * @@return a list of all of the genlPreds for a CycConstant predicate, using an upward closure
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenlPreds(CycConstant predicate)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-genl-predicates " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the genlPreds for a CycConstant predicate, using an upward closure.
   * 
   * @@param predicate the predicate for which all the genlPreds are obtained
   * @@param mt the relevant mt
   * 
   * @@return a list of all of the genlPreds for a CycConstant predicate, using an upward closure
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllGenlPreds(CycConstant predicate, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-genl-predicates " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of all of the direct and indirect specs-preds for the given predicate in all
   * microtheories.
   * 
   * @@param cycFort the predicate
   * 
   * @@return the list of all of the direct and indirect spec-preds for the given predicate in all
   *         microtheories.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecPreds(CycFort cycFort)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-spec-predicates " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the direct and indirect specs-preds for the given predicate in the
   * given microtheory.
   * 
   * @@param cycFort the predicate
   * @@param mt the microtheory
   * 
   * @@return the list of all of the direct and indirect spec-preds for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecPreds(CycFort cycFort, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-spec-predicates " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the hashset of all of the direct and indirect specs-preds for the given predicate in all
   * microtheories.
   * 
   * @@param cycFort the predicate
   * 
   * @@return the hashset of all of the direct and indirect spec-preds for the given predicate in
   *         all microtheories.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecPredsHashSet(CycFort cycFort)
                                 throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecPreds(cycFort));
  }

  /**
   * Gets the hashset of all of the direct and indirect specs-preds for the given predicate in the
   * given microtheory.
   * 
   * @@param cycFort the predicate
   * @@param mt the microtheory
   * 
   * @@return the hashset of all of the direct and indirect spec-preds for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecPredsHashSet(CycFort cycFort, 
                                        CycObject mt)
                                 throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecPreds(cycFort, 
                                       mt));
  }

  /**
   * Gets the list of all of the direct and indirect specs-inverses for the given predicate in all
   * microtheories.
   * 
   * @@param cycFort the predicate
   * 
   * @@return the list of all of the direct and indirect spec-inverses for the given predicate in
   *         all microtheories.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecInverses(CycFort cycFort)
                             throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (all-spec-inverses " + 
                        cycFort.stringApiValue() + ")))");
  }

  /**
   * Gets the list of all of the direct and indirect specs-inverses for the given predicate in the
   * given microtheory.
   * 
   * @@param cycFort the predicate
   * @@param mt the microtheory
   * 
   * @@return the list of all of the direct and indirect spec-inverses for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecInverses(CycFort cycFort, 
                                    CycObject mt)
                             throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-spec-inverses " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the hashset of all of the direct and indirect specs-inverses for the given predicate in
   * all microtheories.
   * 
   * @@param cycFort the predicate
   * 
   * @@return the hashset of all of the direct and indirect spec-inverses for the given predicate in
   *         all microtheories.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecInversesHashSet(CycFort cycFort)
                                    throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecInverses(cycFort));
  }

  /**
   * Gets the list of all of the direct and indirect specs-mts for the given microtheory in mt-mt
   * (currently #$UniversalVocabularyMt).
   * 
   * @@param mt the microtheory
   * 
   * @@return the list of all of the direct and indirect specs-mts for the given microtheory in
   *         mt-mt (currently #$UniversalVocabularyMt)
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getAllSpecMts(CycObject mt)
                        throws IOException, UnknownHostException, CycApiException {
    return converseList("(all-spec-mts " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the hashset of all of the direct and indirect specs-inverses for the given predicate in
   * the given microtheory.
   * 
   * @@param cycFort the predicate
   * @@param mt the microtheory
   * 
   * @@return the hashset of all of the direct and indirect spec-inverses for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecInversesHashSet(CycFort cycFort, 
                                           CycObject mt)
                                    throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecInverses(cycFort, 
                                          mt));
  }

  /**
   * Gets the hashset of all of the direct and indirect specs-mts for the given microtheory in
   * mt-mt (currently #$UniversalVocabularyMt).
   * 
   * @@param mt the microtheory
   * 
   * @@return the hashset of all of the direct and indirect specs-mts for the given microtheory in
   *         mt-mt (currently #$UniversalVocabularyMt)
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public HashSet getAllSpecMtsHashSet(CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    return new HashSet(getAllSpecMts(mt));
  }

  /**
   * Gets a list of the arg1Isas for a CycConstant predicate.
   * 
   * @@param predicate the predicate for which argument 1 contraints are sought.
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg1Isas(CycObject predicate)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert predicate instanceof CycConstant || 
           predicate instanceof CycNart || 
           predicate instanceof CycList : predicate.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(remove-duplicates (with-all-mts (arg1-isa " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the arg1Isas for a CycConstant predicate given an mt.
   * 
   * @@param predicate the predicate for which argument 1 contraints are sought.
   * @@param mt the relevant microtheory
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate given an mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg1Isas(CycFort predicate, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg1-isa " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the arg2Isas for a CycConstant predicate.
   * 
   * @@param predicate the predicate for which argument 2 contraints are sought.
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg2Isas(CycObject predicate)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert predicate instanceof CycConstant || 
           predicate instanceof CycNart || 
           predicate instanceof CycList : predicate.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(remove-duplicates (with-all-mts (arg2-isa " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the arg2Isas for a CycConstant predicate given an mt.
   * 
   * @@param predicate the predicate for which argument 2 contraints are sought.
   * @@param mt the relevant microtheory
   * 
   * @@return the list of the arg2Isas for a CycConstant predicate given an mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg2Isas(CycFort predicate, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg2-isa " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the arg3Isas for a CycConstant predicate.
   * 
   * @@param predicate the predicate for which argument 3 contraints are sought.
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg3Isas(CycFort predicate)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (arg3-isa " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the arg3Isas for a CycConstant predicate given an mt.
   * 
   * @@param predicate the predicate for which argument 3 contraints are sought.
   * @@param mt the relevant microtheory
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate given an mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg3Isas(CycFort predicate, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg3-isa " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the arg4Isas for a CycConstant predicate.
   * 
   * @@param predicate the predicate for which argument 4 contraints are sought.
   * 
   * @@return the list of the arg4Isas for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg4Isas(CycFort predicate)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (arg4-isa " + 
                        predicate.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the arg4Isas for a CycConstant predicate given an mt.
   * 
   * @@param predicate the predicate for which argument 4 contraints are sought.
   * @@param mt the relevant microtheory
   * 
   * @@return the list of the arg4Isas for a CycConstant predicate given an mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg4Isas(CycFort predicate, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg4-isa " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the argNIsas for a CycConstant predicate.
   * 
   * @@param predicate the predicate for which argument N contraints are sought.
   * @@param argPosition the argument position of argument N
   * 
   * @@return the list of the argNIsas for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArgNIsas(CycFort predicate, 
                             int argPosition)
                      throws IOException, UnknownHostException, CycApiException {
    String command = "(remove-duplicates \n" + "  (with-all-mts \n" + "    (argn-isa " + 
                     predicate.stringApiValue() + " " + Integer.toString(
                                                              argPosition) + ")))";

    return converseList(command);
  }

  /**
   * Gets the list of the argNIsas for a CycConstant predicate given an mt.
   * 
   * @@param predicate the predicate for which argument contraints are sought.
   * @@param argPosition the argument position of argument N
   * @@param mt the relevant microtheory
   * 
   * @@return the list of the arg1Isas for a CycConstant predicate given an mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArgNIsas(CycFort predicate, 
                             int argPosition, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    String command = "(remove-duplicates \n" + "  (with-all-mts \n" + "    (argn-isa \n" + 
                     "      " + predicate.stringApiValue() + "      " + 
                     Integer.toString(argPosition) + "      " + makeELMt(
                                                                      mt).stringApiValue() + 
                     ")))";

    return converseList(command);
  }

  /**
   * Gets the list of the interArgIsa1-2 isa constraint pairs for the given predicate.  Each item
   * of the returned list is a pair (arg1-isa arg2-isa) which means that when (#$isa arg1
   * arg1-isa) holds, (#$isa arg2 arg2-isa) must also hold for (predicate arg1 arg2 ..) to be well
   * formed.
   * 
   * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
   * 
   * @@return the list of the interArgIsa1-2 isa constraint pairs for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInterArgIsa1_2s(CycFort predicate)
                             throws IOException, UnknownHostException, CycApiException {
    String command = "(remove-duplicates \n" + "  (with-all-mts \n" + "    (inter-arg-isa1-2 " + 
                     predicate.stringApiValue() + ")))";

    return converseList(command);
  }

  /**
   * Gets the list of the interArgIsa1-2 isa constraint pairs for the given predicate.  Each item
   * of the returned list is a pair (arg1-isa arg2-isa) which means that when (#$isa arg1
   * arg1-isa) holds, (#$isa arg2 arg2-isa) must also hold for (predicate arg1 arg2 ..) to be well
   * formed.
   * 
   * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of the interArgIsa1-2 isa constraint pairs for the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInterArgIsa1_2s(CycFort predicate, 
                                    CycObject mt)
                             throws IOException, UnknownHostException, CycApiException {
    String command = "(remove-duplicates \n" + "  (with-all-mts \n" + "    (inter-arg-isa1-2 " + 
                     "      " + predicate.stringApiValue() + "      " + 
                     makeELMt(mt).stringApiValue() + ")))";

    return converseList(command);
  }

  /**
   * Gets the list of the interArgIsa1-2 isa constraints for arg2, given the predicate and arg1.
   * 
   * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
   * @@param arg1 the argument in position 1
   * 
   * @@return the list of the interArgIsa1-2 isa constraints for arg2, given the predicate and arg1
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInterArgIsa1_2_forArg2(CycFort predicate, 
                                           CycFort arg1)
                                    throws IOException, UnknownHostException, CycApiException {
    CycList result = new CycList();
    ListIterator constraintPairs = getInterArgIsa1_2s(predicate).listIterator();

    while (constraintPairs.hasNext()) {
      CycList pair = (CycList) constraintPairs.next();

      if (pair.first().equals(arg1)) {
        result.add(pair.second());
      }
    }

    return result;
  }

  /**
   * Gets the list of the interArgIsa1-2 isa constraints for arg2, given the predicate and arg1.
   * 
   * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
   * @@param arg1 the argument in position 1
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of the interArgIsa1-2 isa constraints for arg2, given the predicate and arg1
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getInterArgIsa1_2_forArg2(CycFort predicate, 
                                           CycFort arg1, 
                                           CycObject mt)
                                    throws IOException, UnknownHostException, CycApiException {
    CycList result = new CycList();
    ListIterator constraintPairs = getInterArgIsa1_2s(predicate, 
                                                      mt).listIterator();

    while (constraintPairs.hasNext()) {
      CycList pair = (CycList) constraintPairs.next();

      if (pair.first().equals(arg1)) {
        result.add(pair.second());
      }
    }

    return result;
  }

  /**
   * Gets the list of the resultIsa for a CycConstant function.
   * 
   * @@param function the given function term
   * 
   * @@return the list of the resultIsa for a CycConstant function
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getResultIsas(CycFort function)
                        throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (result-isa " + 
                        function.stringApiValue() + ")))");
  }

  /**
   * Gets the list of the resultIsa for a CycConstant function.
   * 
   * @@param function the given function term
   * @@param mt the relevant mt
   * 
   * @@return the list of the resultIsa for a CycConstant function
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getResultIsas(CycFort function, 
                               CycObject mt)
                        throws IOException, UnknownHostException, CycApiException {
    return converseList("(result-isa " + function.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets the list of the argNGenls for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * @@param argPosition the argument position for which the genls argument constraints are sought
   *        (position 1 = first argument)
   * 
   * @@return the list of the argNGenls for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArgNGenls(CycFort predicate, 
                              int argPosition)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(remove-duplicates (with-all-mts (argn-genl " + 
                        predicate.stringApiValue() + " " + argPosition + ")))");
  }

  /**
   * Gets the list of the argNGenls for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * @@param argPosition the argument position for which the genls argument constraints are sought
   *        (position 1 = first argument)
   * @@param mt the relevant mt
   * 
   * @@return the list of the argNGenls for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArgNGenls(CycFort predicate, 
                              int argPosition, 
                              CycObject mt)
                       throws IOException, UnknownHostException, CycApiException {
    return converseList("(argn-genl " + predicate.stringApiValue() + " " + argPosition + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the arg1Formats for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * 
   * @@return a list of the arg1Formats for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg1Formats(CycObject predicate)
                         throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert predicate instanceof CycConstant || 
           predicate instanceof CycNart || 
           predicate instanceof CycList : predicate.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(with-all-mts (arg1-format " + predicate.stringApiValue() + "))");
  }

  /**
   * Gets a list of the arg1Formats for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * @@param mt the relevant mt
   * 
   * @@return a list of the arg1Formats for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg1Formats(CycFort predicate, 
                                CycObject mt)
                         throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg1-format " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the arg2Formats for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * 
   * @@return a list of the arg2Formats for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg2Formats(CycObject predicate)
                         throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert predicate instanceof CycConstant || 
           predicate instanceof CycNart || 
           predicate instanceof CycList : predicate.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(with-all-mts (arg2-format " + predicate.stringApiValue() + "))");
  }

  /**
   * Gets a list of the arg2Formats for a CycConstant predicate.
   * 
   * @@param predicate the given predicate term
   * @@param mt the relevant mt
   * 
   * @@return a list of the arg2Formats for a CycConstant predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg2Formats(CycFort predicate, 
                                CycObject mt)
                         throws IOException, UnknownHostException, CycApiException {
    return converseList("(arg2-format " + predicate.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the disjointWiths for a CycFort.
   * 
   * @@param cycObject the given collection term
   * 
   * @@return a list of the disjointWiths for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getDisjointWiths(CycObject cycObject)
                           throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseList("(remove-duplicates (with-all-mts (local-disjoint-with " + 
                        cycObject.stringApiValue() + ")))");
  }

  /**
   * Gets a list of the disjointWiths for a CycFort.
   * 
   * @@param cycFort the given collection term
   * @@param mt the relevant mt
   * 
   * @@return a list of the disjointWiths for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getDisjointWiths(CycFort cycFort, 
                                  CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    return converseList("(local-disjoint-with " + cycFort.stringApiValue() + " " + 
                        makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Gets a list of the coExtensionals for a CycFort.  Limited to 120 seconds.
   * 
   * @@param cycObject the given collection term
   * 
   * @@return a list of the coExtensionals for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getCoExtensionals(CycObject cycObject)
                            throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    CycList answer = null;
    try {
      answer = converseList("(ask-template '?X '(#$coExtensional " + cycObject.stringApiValue() + 
                            " ?X) #$EverythingPSC nil nil 120)");
    }
     catch (IOException e) {
      Log.current.println("getCoExtensionals - ignoring:\n" + e.getMessage());

      return new CycList();
    }

    answer.remove(cycObject);

    return canonicalizeList(answer);
  }

  /**
   * Gets a list of the coExtensionals for a CycFort.  Limited to 120 seconds.
   * 
   * @@param cycFort the given collection term
   * @@param mt the relevant mt for inference
   * 
   * @@return a list of the coExtensionals for a CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getCoExtensionals(CycFort cycFort, 
                                   CycObject mt)
                            throws IOException, UnknownHostException, CycApiException {
    CycList answer = null;

    try {
      answer = converseList("(ask-template '?X '(#$coExtensional " + cycFort.stringApiValue() + 
                            " ?X) " + makeELMt(mt).stringApiValue() + " nil nil 120)");
    }
     catch (IOException e) {
      Log.current.println("getCoExtensionals - ignoring:\n" + e.getMessage());

      return new CycList();
    }

    answer.remove(cycFort);

    return canonicalizeList(answer);
  }

  /**
   * Returns true if the given term is a microtheory.
   * 
   * @@param cycFort the constant for determination as a microtheory
   * 
   * @@return <tt>true</tt> iff cycConstant is a microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isMicrotheory(CycFort cycFort)
                        throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + " #$Microtheory)");
  }

  /**
   * Returns true if the given term is a Collection.
   * 
   * @@param cycObject the given term
   * 
   * @@return true if the given term is a Collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCollection(CycObject cycObject)
                       throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseBoolean("(isa-in-any-mt? " + cycObject.stringApiValue() + " #$Collection)");
  }

  public boolean isCollection(Object term)
                       throws IOException, UnknownHostException, CycApiException {
    if (term instanceof CycObject)
      return isCollection((CycObject)term);
    else
      return false;
  }

  /**
   * Returns true if the given term is a collection, implemented by a cache to avoid asking the same
   * question twice from the KB.
   * 
   * @@param cycObject the given term
   * 
   * @@return true if the given term is a collection
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCollection_Cached(CycObject cycObject)
                              throws IOException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    boolean answer;
    Boolean isCollection = (Boolean) isCollectionCache.getElement(
                                 cycObject);

    if (isCollection != null) {
      answer = isCollection.booleanValue();

      return answer;
    }

    answer = isCollection(cycObject);
    isCollectionCache.addElement(cycObject, 
                                 new Boolean(answer));

    return answer;
  }

  public boolean isCollection_Cached(Object term)
                              throws IOException, CycApiException {
    if (term instanceof CycObject)
      return isCollection_Cached((CycObject)term);
    else
      return false;
  }

  /**
   * Returns true if the given term is an Individual.
   * 
   * @@param cycObject the given term
   * 
   * @@return true if the given term is an Individual
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isIndividual(CycObject cycObject)
                       throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseBoolean("(isa-in-any-mt? " + cycObject.stringApiValue() + " #$Individual)");
  }

  /**
   * Returns true if the given is a Function.
   * 
   * @@param cycFort the given term
   * 
   * @@return true if the given is a Function
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isFunction(CycFort cycFort)
                     throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + 
                           " #$Function-Denotational)");
  }

  /**
   * Returns true if the given term is an evaluatable predicate.
   * 
   * @@param predicate the given term
   * 
   * @@return true if true if the given term is an evaluatable predicate, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isEvaluatablePredicate(CycFort predicate)
                                 throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("evaluatable-predicate?"));
    command1.add(predicate);

    return converseBoolean(command);
  }

  /**
   * Returns true if cycObject is a Predicate.
   * 
   * @@param cycObject the term for determination as a predicate
   * 
   * @@return true if cycObject is a Predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isPredicate(CycObject cycObject)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseBoolean("(isa-in-any-mt? " + cycObject.stringApiValue() + " #$Predicate)");
  }

  /**
   * Returns true if the given term is a UnaryPredicate.
   * 
   * @@param cycObject the given term
   * 
   * @@return true if true if the given term is a UnaryPredicate, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isUnaryPredicate(CycObject cycObject)
                           throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseBoolean("(isa-in-any-mt? " + cycObject.stringApiValue() + 
                           " #$UnaryPredicate)");
  }

  /**
   * Returns true if the cyc object is a BinaryPredicate.
   * 
   * @@param cycObject the given cyc object
   * 
   * @@return true if cycObject is a BinaryPredicate, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isBinaryPredicate(CycObject cycObject)
                            throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    return converseBoolean("(isa-in-any-mt? " + cycObject.stringApiValue() + 
                           " #$BinaryPredicate)");
  }

  /**
   * Returns true if the candidate name uses valid CycConstant characters.
   * 
   * @@param candidateName the candidate name
   * 
   * @@return true if the candidate name uses valid CycConstant characters
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isValidConstantName(String candidateName)
                              throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(new-constant-name-spec-p \"" + candidateName + "\")");
  }

  /**
   * Returns true if the candidate name is an available CycConstant name, case insensitive.
   * 
   * @@param candidateName the candidate name
   * 
   * @@return true if the candidate name uses valid CycConstant characters
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isConstantNameAvailable(String candidateName)
                                  throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(constant-name-available \"" + candidateName + "\")");
  }

  /**
   * Returns true if term is a quotedCollection, in any microtheory
   * 
   * @@param cycFort the given CycFort term
   * 
   * @@return true if term is a quotedCollection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQuotedCollection(CycFort cycFort)
                             throws IOException, UnknownHostException, CycApiException {
    return this.isQuotedCollection(cycFort, 
                                   inferencePSC);
  }

  /**
   * Returns true if term is a quotedCollection is a quotedCollection.
   * 
   * @@param cycFort the given CycFort term
   * @@param mt the microtheory in which the query is made
   * 
   * @@return true if term is a quotedCollection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQuotedCollection(CycFort cycFort, 
                                    CycObject mt)
                             throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(getKnownConstantByName("quotedCollection"));
    query.add(cycFort);

    return this.isQueryTrue(query, 
                            mt);
  }

  /**
   * Returns true if cycConstant is a PublicConstant.
   * 
   * @@param cycConstant the given constant
   * 
   * @@return true if cycConstant is a PublicConstant
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isPublicConstant(CycConstant cycConstant)
                           throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + 
                           " #$PublicConstant)");
  }

  /**
   * Gets a list of the public Cyc constants.
   * 
   * @@return a list of the public Cyc constants
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getPublicConstants()
                             throws IOException, UnknownHostException, CycApiException {
    // #$PublicConstant
    return getKbSubset(getKnownConstantByGuid("bd7abd90-9c29-11b1-9dad-c379636f7270"));
  }

  /**
   * Gets a list of the elements of the given CycKBSubsetCollection.
   * 
   * @@param cycKbSubsetCollection the given CycKBSubsetCollection
   * 
   * @@return a list of the elements of the given CycKBSubsetCollection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getKbSubset(CycFort cycKbSubsetCollection)
                      throws IOException, UnknownHostException, CycApiException {
    CycList answer = converseList("(ask-template '?X '(#$isa ?X " + 
                                  cycKbSubsetCollection.stringApiValue() + ") #$EverythingPSC)");

    return canonicalizeList(answer);
  }

  /**
   * Renames the given constant.
   * 
   * @@param cycConstant the constant term to be renamed
   * @@param newName the new constant name
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void rename(final CycConstant cycConstant, final String newName)
                         throws IOException, UnknownHostException, CycApiException {
    String command = wrapBookkeeping("(ke-rename-now " + cycConstant.stringApiValue() + "\"" + newName + "\")");
    Object result = converseObject(command);
    if (result.equals(CycObjectFactory.nil))
      throw new CycApiException(newName + " is an invalid new name for " + cycConstant.cyclify());
    CycObjectFactory.removeCaches(cycConstant);
    cycConstant.setName(newName);
    cycConstant.getGuid();
    CycObjectFactory.addCycConstantCacheByGuid(cycConstant);
    CycObjectFactory.addCycConstantCacheByName(cycConstant);
    CycObjectFactory.addCycConstantCacheById(cycConstant);
  }

  /**
   * Kills a Cyc constant.  If CYCCONSTANT is a microtheory, then all the contained assertions are
   * deleted from the KB, the Cyc Truth Maintenance System (TML) will automatically delete any
   * derived assertions whose sole support is the killed term(s).
   * 
   * @@param cycConstant the constant term to be removed from the KB
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void kill(CycConstant cycConstant)
                         throws IOException, UnknownHostException, CycApiException {
    String command = wrapBookkeeping("(ke-kill-now " + cycConstant.stringApiValue() + ")");
    converseBoolean(command);
    CycObjectFactory.removeCaches(cycConstant);
  }

  /**
   * Kills a Cyc constant without issuing a transcript operation. If CYCCONSTANT is a microtheory,
   * then all the contained assertions are deleted from the KB, the Cyc Truth Maintenance System
   * (TMS) will automatically delete any derived assertions whose sole support is the killed
   * term(s).
   * 
   * @@param cycConstant the constant term to be removed from the KB
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void killWithoutTranscript(CycConstant cycConstant)
                                          throws IOException, UnknownHostException, CycApiException {
    String command = wrapBookkeeping("(cyc-kill " + cycConstant.stringApiValue() + ")");
    converseBoolean(command);
    CycObjectFactory.removeCaches(cycConstant);
  }

  /**
   * Kills the given Cyc constants.  If CYCCONSTANT is a microtheory, then all the contained
   * assertions are deleted from the KB, the Cyc Truth Maintenance System (TMS) will automatically
   * delete any derived assertions whose sole support is the killed term(s).
   * 
   * @@param cycConstants the list of constant terms to be removed from the KB
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void kill(CycConstant[] cycConstants)
                         throws IOException, UnknownHostException, CycApiException {
    for (int i = 0; i < cycConstants.length; i++)
      kill(cycConstants[i]);
  }

  /**
   * Kills the given Cyc constants.  If CYCCONSTANT is a microtheory, then all the contained
   * assertions are deleted from the KB, the Cyc Truth Maintenance System (TMS) will automatically
   * delete any derived assertions whose sole support is the killed term(s).
   * 
   * @@param cycConstants the list of constant terms to be removed from the KB
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void kill(List cycConstants)
                         throws IOException, UnknownHostException, CycApiException {
    for (int i = 0; i < cycConstants.size(); i++)
      kill((CycConstant) cycConstants.get(i));
  }

  /**
   * Kills a Cyc NART (Non Atomic Reified Term).  If CYCFORT is a microtheory, then all the
   * contained assertions are deleted from the KB, the Cyc Truth Maintenance System (TMS) will
   * automatically delete any derived assertions whose sole support is the killed term(s).
   * 
   * @@param cycFort the NART term to be removed from the KB
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public synchronized void kill(CycFort cycFort)
                         throws IOException, UnknownHostException, CycApiException {
    if (cycFort instanceof CycConstant) {
      kill((CycConstant) cycFort);
    }
    else {
      String command = wrapBookkeeping("(ke-kill-now " + cycFort.stringApiValue() + ")");
      converseBoolean(command);
    }
  }

  /**
   * Returns the value of the Cyclist.
   * 
   * @@return the value of the Cyclist
   */
  public CycFort getCyclist() {
    return cyclist;
  }

  /**
   * Sets the value of the Cyclist, whose identity will be attached via #$myCreator bookkeeping
   * assertions to new KB entities created in this session.
   * 
   * @@param cyclistName the name of the cyclist term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void setCyclist(String cyclistName)
                  throws IOException, UnknownHostException, CycApiException {
    if (!(cyclistName.startsWith("#$"))) {
      cyclistName = "#$" + cyclistName;
    }

    setCyclist((CycFort) getELCycTerm(cyclistName));
  }

  /**
   * Sets the value of the Cyclist, whose identity will be attached via #$myCreator bookkeeping
   * assertions to new KB entities created in this session.
   * 
   * @@param cyclist the cyclist term
   */
  public void setCyclist(CycFort cyclist) {
    this.cyclist = cyclist;
  }

  /**
   * Returns the value of the project (KE purpose).
   * 
   * @@return he value of the project (KE purpose)
   */
  public CycFort getKePurpose() {
    return project;
  }

  /**
   * Sets the value of the KE purpose, whose project name will be attached via #$myCreationPurpose
   * bookkeeping assertions to new KB entities created in this session.
   * 
   * @@param projectName the string name of the KE Purpose term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void setKePurpose(String projectName)
                    throws IOException, UnknownHostException, CycApiException {
    if (!(projectName.startsWith("#$"))) {
      projectName = "#$" + projectName;
    }

    setKePurpose((CycFort) getELCycTerm(projectName));
  }

  /**
   * Sets the value of the KE purpose, whose project name will be attached via #$myCreationPurpose
   * bookkeeping assertions to new KB entities created in this session.
   * 
   * @@param project the KE Purpose term
   */
  public void setKePurpose(CycFort project) {
    this.project = project;
  }

  /**
   * Asserts the given sentence, and then places it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithTranscript(CycList sentence, 
                                   CycObject mt)
                            throws IOException, UnknownHostException, CycApiException {
    assertWithTranscript(sentence.stringApiValue(), mt);
  }

  /**
   * Asserts the given sentence, and then places it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithTranscript(String sentence, 
                                   CycObject mt)
                            throws IOException, UnknownHostException, CycApiException {
    String projectName = "nil";

    if (project != null) {
      projectName = project.stringApiValue();
    }

    String cyclistName = "nil";

    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }

    String command = "(clet ((*the-cyclist* " + cyclistName + ")\n" + 
                     "       (*ke-purpose* " + projectName + "))\n" + 
                     "  (ke-assert-now\n" + 
                     "    " + sentence + "\n" + 
                     "    " + makeELMt(mt).stringApiValue() + "))";
    boolean statusOk = converseBoolean(command);
    if (! statusOk)
      throw new CycApiException("Assertion failed in mt: " + makeELMt(mt).cyclify() + "\n" + sentence);
  }

  /**
   * Asserts the given sentence with bookkeeping, and then places it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithTranscriptAndBookkeeping(String sentence, CycObject mt)
                                          throws IOException, UnknownHostException, CycApiException {
    assertWithTranscriptAndBookkeeping(makeCycList(sentence), mt);
  }

  /**
   * Asserts the given sentence with bookkeeping, and then places it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithTranscriptAndBookkeeping(CycList sentence, CycObject mt)
      throws IOException, UnknownHostException, CycApiException {
    String projectName = "nil";
    if (project != null) {
      projectName = project.stringApiValue();
    }
    String cyclistName = "nil";
    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }
    String command = "(with-bookkeeping-info \n" + "  (new-bookkeeping-info " + cyclistName + 
                     " (the-date) " + projectName + "(the-second))\n" + 
                     "  (clet ((*the-cyclist* " + cyclistName + ")\n" + 
                     "         (*ke-purpose* " + projectName + "))\n" + 
                     "    (ke-assert-now\n" + 
                     "      " + sentence.stringApiValue() + "\n" + 
                     "      " + makeELMt(mt).stringApiValue() + ")))";
    boolean statusOk = converseBoolean(command);
    if (! statusOk)
      throw new CycApiException("Assertion failed in mt: " + makeELMt(mt).cyclify() + "\n" + sentence + "\n" + command);
  }

  /**
   * Asserts the given sentence with bookkeeping and without placing it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithBookkeepingAndWithoutTranscript(CycList sentence, CycObject mt)
    throws IOException, UnknownHostException, CycApiException {
    assertWithBookkeepingAndWithoutTranscript(sentence.stringApiValue(), mt);
  }

  /**
   * Asserts the given sentence with bookkeeping and without placing it on the transcript queue.
   * 
   * @@param sentence the given sentence for assertion
   * @@param mt the microtheory in which the assertion is placed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertWithBookkeepingAndWithoutTranscript(String sentence, CycObject mt)
                                                 throws IOException, UnknownHostException, 
                                                        CycApiException {
    String projectName = "nil";

    if (project != null) {
      projectName = project.stringApiValue();
    }

    String cyclistName = "nil";

    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }

    String command = "(with-bookkeeping-info \n" + "  (new-bookkeeping-info " + cyclistName + 
                     " (the-date) " + projectName + "(the-second))\n" + 
                     "  (clet ((*the-cyclist* " + cyclistName + ")\n" + 
                     "         (*ke-purpose* " + projectName + "))\n" + 
                     "    (cyc-assert\n" + 
                     "      " + sentence + "\n" + 
                     "      " + makeELMt(mt).stringApiValue() + ")))";
    boolean statusOk = converseBoolean(command);
    if (! statusOk)
      throw new CycApiException("Assertion failed in mt: " + makeELMt(mt).cyclify() + "\n" + sentence);
  }

  /**
   * Unasserts the given sentence with bookkeeping and without placing it on the transcript queue.
   * 
   * @@param sentence the given sentence for unassertion
   * @@param mt the microtheory from which the assertion is removed
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void unassertWithBookkeepingAndWithoutTranscript(CycList sentence, 
                                                          CycObject mt)
                                                   throws IOException, UnknownHostException, 
                                                          CycApiException {
    String command = wrapBookkeeping("(cyc-unassert " + sentence.stringApiValue() + 
                                     makeELMt(mt).stringApiValue() + ")");
    boolean unassertOk = converseBoolean(command);

    if (!unassertOk) {
      throw new CycApiException("Could not unassert from mt: " + makeELMt(
                                                                       mt) + "\n  " + 
                                sentence.cyclify());
    }
  }

  /**
   * Returns a with-bookkeeping-info macro expresssion.
   * 
   * @@return a with-bookkeeping-info macro expresssion
   */
  protected String withBookkeepingInfo() {
    String projectName = "nil";

    if (project != null) {
      projectName = project.stringApiValue();
    }

    String cyclistName = "nil";

    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }

    return "(with-bookkeeping-info (new-bookkeeping-info " + cyclistName + " (the-date) " + 
           projectName + "(the-second)) ";
  }

  /**
   * Finds a Cyc constant in the KB with the specified name
   * 
   * @@param constantName the name of the new constant
   * 
   * @@return the constant term or null if the argument name is null or if the term is not found
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant find(String constantName)
                   throws IOException, UnknownHostException, CycApiException {
    if (constantName == null) {
      return null;
    }

    return getConstantByName(constantName);
  }

  /**
   * Finds or creates a Cyc constant in the KB with the specified name.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param constantName the name of the new constant
   * 
   * @@return the new constant term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant findOrCreate(String constantName)
                           throws IOException, UnknownHostException, CycApiException {
    return makeCycConstant(constantName);
  }

  /**
   * Creates a new permanent Cyc constant in the KB with the specified name.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param constantName the name of the new constant
   * 
   * @@return the new constant term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant createNewPermanent(String constantName)
                                 throws IOException, UnknownHostException, CycApiException {
    return makeCycConstant(constantName);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycFort predicate, 
                        CycFort arg1, 
                        CycFort arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <CycFort>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate, which is a string
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycFort predicate, 
                        CycFort arg1, 
                        String arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <String>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate, which is a CycList
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycConstant predicate, 
                        CycFort arg1, 
                        CycList arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <List>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate, which is an int
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycConstant predicate, 
                        CycFort arg1, 
                        int arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <int>)
    assertGaf(mt, 
              predicate, 
              arg1, 
              new Integer(arg2));
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate, which is an Integer
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycFort predicate, 
                        CycFort arg1, 
                        Integer arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <int>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the binary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate, which is a Double
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycFort predicate, 
                        CycFort arg1, 
                        Double arg2)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <int>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT. The operation and its
   * bookkeeping info will be added to the KB transcript for replication and archive.
   * 
   * @@param mt the microtheory in which the assertion is made
   * @@param predicate the ternary predicate of the assertion
   * @@param arg1 the first argument of the predicate
   * @@param arg2 the second argument of the predicate
   * @@param arg3 the third argument of the predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycObject mt, 
                        CycConstant predicate, 
                        CycFort arg1, 
                        CycFort arg2, 
                        CycFort arg3)
                 throws IOException, UnknownHostException, CycApiException {
    // (predicate <CycFort> <CycFort> <CycFort>)
    CycList sentence = new CycList();
    sentence.add(predicate);
    sentence.add(arg1);
    sentence.add(arg2);
    sentence.add(arg3);
    assertWithTranscriptAndBookkeeping(sentence, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param gaf the gaf in the form of a CycList
   * @@param mt the microtheory in which the assertion is made
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGaf(CycList gaf, 
                        CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    assertWithTranscriptAndBookkeeping(gaf, 
                                       mt);
  }

  /**
   * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation is performed at the HL level
   * and does not perform wff-checking, nor forward inference, nor bookkeeping assertions, nor transcript recording.  The advantage of
   * this method is that it is fast.
   * 
   * @@param gaf the gaf in the form of a CycList
   * @@param mt the microtheory in which the assertion is made
   * @@param strength the assertion strength (e.g. :default or :monotonic)
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertHLGaf(final CycList gaf, 
                         final CycObject mt,
                         final CycSymbol strength)
                 throws IOException, UnknownHostException, CycApiException {
    // (HL-ADD-ARGUMENT '(:ASSERTED-ARGUMENT <strength>) '(NIL ((<gaf>)) <mt> :FORWARD NIL)
    final CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("hl-add-argument"));
    final CycList command1 = new CycList();
    command1.add(CycObjectFactory.makeCycSymbol(":asserted-argument"));
    command1.add(strength);
    command.addQuoted(command1);
    final CycList command2 = new CycList();
    command2.add(CycObjectFactory.nil);
    final CycList command3 = new CycList();
    final CycList canonicalGaf = new CycList();
    final int gaf_size = gaf.size();
    for (int i = 0; i < gaf_size; i++) {
      final Object obj = gaf.get(i);
      if (obj instanceof CycNart)
        canonicalGaf.add(makeCycList(((CycNart) obj).stringApiValue()));
      else
        canonicalGaf.add(obj);
    }
    command3.add(canonicalGaf);
    command2.add(command3);
    command.addQuoted(command2);
    command.add(mt);
    command.add(CycObjectFactory.makeCycSymbol(":forward"));
    command.add(CycObjectFactory.nil);
    converseCycObject(command);
  }

  /**
   * Unasserts the given ground atomic formula (gaf) in the specified microtheory MT.
   * 
   * @@param gaf the gaf in the form of a CycList
   * @@param mt the microtheory in which the assertion is made
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void unassertGaf(CycList gaf, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    String command = wrapBookkeeping("(ke-unassert-now " + gaf.stringApiValue() + 
                                     makeELMt(mt).stringApiValue() + ")");
    converseVoid(command);
  }

  /**
   * Assert a nameString for the specified CycConstant in the specified lexical microtheory. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycConstantName the name of the given term
   * @@param nameString the given name string for the term
   * @@param mtName the name of the microtheory in which the name string is asserted
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertNameString(String cycConstantName, 
                               String nameString, 
                               String mtName)
                        throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(getKnownConstantByName(mtName)), 
              getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"), 
              getKnownConstantByName(cycConstantName), 
              nameString);
  }

  /**
   * Assert a comment for the specified CycConstant in the specified microtheory MT.  The operation
   * will be added to the KB transcript for replication and archive.
   * 
   * @@param cycConstantName the name of the given term
   * @@param comment the comment string
   * @@param mtName the name of the microtheory in which the comment is asserted
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertComment(String cycConstantName, 
                            String comment, 
                            String mtName)
                     throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(getKnownConstantByName(mtName)), 
              CycAccess.comment, 
              getKnownConstantByName(cycConstantName), 
              comment);
  }

  /**
   * Assert a comment for the specified CycFort in the specified microtheory. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given term
   * @@param comment the comment string
   * @@param mt the comment assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertComment(CycFort cycFort, 
                            String comment, 
                            CycObject mt)
                     throws IOException, UnknownHostException, CycApiException {
    ELMt elmt = makeELMt(mt);
    assertGaf(elmt, 
              CycAccess.comment, 
              cycFort, 
              comment);
  }

  /**
   * Assert a name string for the specified CycFort in the specified microtheory. The operation
   * will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given term
   * @@param nameString the name string
   * @@param mt the name string assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertNameString(CycFort cycFort, 
                               String nameString, 
                               CycObject mt)
                        throws IOException, UnknownHostException, CycApiException {
    ELMt elmt = makeELMt(mt);
    assertGaf(elmt, 
              this.getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"), 
              cycFort, 
              nameString);
  }

  /**
   * Assert a paraphrase format for the specified CycFort in the #$EnglishParaphraseMt. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param relation the given term
   * @@param genFormatString the genFormat string
   * @@param genFormatList the genFormat argument substitution sequence
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenFormat(CycFort relation, 
                              String genFormatString, 
                              CycList genFormatList)
                       throws IOException, UnknownHostException, CycApiException {
    // (#$genFormat <relation> <genFormatString> <genFormatList>)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("beed06de-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(genFormatString);

    if (genFormatList.size() == 0) {
      sentence.add(CycObjectFactory.nil);
    }
    else {
      sentence.add(genFormatList);
    }

    assertGaf(sentence, 
              
    // #$EnglishParaphraseMt
    makeELMt(getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270")));
  }

  /**
   * Create a microtheory MT, with a comment, isa MT-TYPE and CycFort genlMts. An existing
   * microtheory with the same name is killed first, if it exists.
   * 
   * @@param mtName the name of the microtheory term
   * @@param comment the comment for the new microtheory
   * @@param isaMt the type of the new microtheory
   * @@param genlMts the list of more general microtheories
   * 
   * @@return the new microtheory term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant createMicrotheory(String mtName, 
                                       String comment, 
                                       CycFort isaMt, 
                                       List genlMts)
                                throws IOException, UnknownHostException, CycApiException {
    CycConstant mt = getConstantByName(mtName);

    if (mt != null) {
      kill(mt);
    }

    mt = createNewPermanent(mtName);
    assertComment(mt, 
                  comment, 
                  baseKB);
    assertGaf(universalVocabularyMt, 
              isa, 
              mt, 
              isaMt);

    Iterator iterator = genlMts.iterator();

    while (true) {
      if (!iterator.hasNext()) {
        break;
      }

      CycFort aGenlMt = (CycFort) iterator.next();
      assertGaf(universalVocabularyMt, 
                genlMt, 
                mt, 
                aGenlMt);
    }

    return mt;
  }

  /**
   * Create a microtheory MT, with a comment, isa MT-TYPE and CycFort genlMts.
   * 
   * @@param mt the microtheory term
   * @@param comment the comment for the new microtheory
   * @@param isaMt the type of the new microtheory
   * @@param genlMts the list of more general microtheories
   * 
   * @@return the new microtheory term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void createMicrotheory(CycFort mt, 
                                String comment, 
                                CycFort isaMt, 
                                List genlMts)
                                throws IOException, UnknownHostException, CycApiException {
    assertComment(mt, 
                  comment, 
                  baseKB);
    assertGaf(universalVocabularyMt, 
              isa, 
              mt, 
              isaMt);
    Iterator iterator = genlMts.iterator();
    while (true) {
      if (!iterator.hasNext()) {
        break;
      }
      final CycList gaf = new CycList(3);
      gaf.add(genlMt);
      gaf.add(mt);
      gaf.add(iterator.next());
      assertGaf(gaf, universalVocabularyMt);
    }
  }

  /**
   * Create a microtheory MT, with a comment, isa MT-TYPE and CycFort genlMts. An existing
   * microtheory with the same name is killed first, if it exists.
   * 
   * @@param mtName the name of the microtheory term
   * @@param comment the comment for the new microtheory
   * @@param isaMtName the type (as a string) of the new microtheory
   * @@param genlMts the list of more general microtheories (as strings)
   * 
   * @@return the new microtheory term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant createMicrotheory(String mtName, 
                                       String comment, 
                                       String isaMtName, 
                                       List genlMts)
                                throws IOException, UnknownHostException, CycApiException {
    CycConstant mt = getConstantByName(mtName);

    if (mt != null) {
      kill(mt);
    }

    mt = createNewPermanent(mtName);
    assertComment(mt, 
                  comment, 
                  baseKB);
    assertIsa(mtName, 
              isaMtName);

    Iterator iterator = genlMts.iterator();

    while (true) {
      if (!iterator.hasNext()) {
        break;
      }

      String genlMtName = (String) iterator.next();
      assertGenlMt(mtName, 
                   genlMtName);
    }

    return mt;
  }

  /**
   * Create a microtheory system for a new mt.  Given a root mt name, create a theory ROOTMt,
   * create a vocabulary ROOTVocabMt, and a data ROOTDataMt.  Establish genlMt links for the
   * theory mt and data mt.  Assert that the theory mt is a genlMt of the
   * WorldLikeOursCollectorMt. Assert that the data mt is a genlMt of the collector
   * CurrentWorldDataMt.
   * 
   * @@param mtRootName the root name of the microtheory system
   * @@param comment the root comment of the microtheory system
   * @@param genlMts the list of more general microtheories
   * 
   * @@return an array of three elements consisting of the theory mt, vocabulary mt, and the data mt
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant[] createMicrotheorySystem(String mtRootName, 
                                               String comment, 
                                               List genlMts)
                                        throws IOException, UnknownHostException, CycApiException {
    //traceOn();
    CycConstant[] mts = { null, null, null };
    String theoryMtName = mtRootName + "Mt";
    String vocabMtName = mtRootName + "VocabMt";
    String vocabMtComment = "The #$VocabularyMicrotheory for #$" + theoryMtName;
    String dataMtName = mtRootName + "DataMt";
    String dataMtComment = "The #$DataMicrotheory for #$" + theoryMtName;
    CycConstant worldLikeOursMt = getKnownConstantByGuid(
                                        "bf4c781d-9c29-11b1-9dad-c379636f7270");
    CycConstant currentWorldDataMt = getKnownConstantByGuid(
                                           "bf192b1e-9c29-11b1-9dad-c379636f7270");
    CycConstant genlMt_Vocabulary = getKnownConstantByGuid(
                                          "c054a49e-9c29-11b1-9dad-c379636f7270");

    CycConstant theoryMicrotheory = getKnownConstantByGuid(
                                          "be5275a8-9c29-11b1-9dad-c379636f7270");
    CycConstant theoryMt = createMicrotheory(theoryMtName, 
                                             comment, 
                                             theoryMicrotheory, 
                                             genlMts);
    CycConstant vocabularyMicrotheory = getKnownConstantByGuid(
                                              "bda19dfd-9c29-11b1-9dad-c379636f7270");
    CycConstant vocabMt = createMicrotheory(vocabMtName, 
                                            vocabMtComment, 
                                            vocabularyMicrotheory, 
                                            new ArrayList());
    CycConstant dataMicrotheory = getKnownConstantByGuid(
                                        "be5275a8-9c29-11b1-9dad-c379636f7270");
    CycConstant dataMt = createMicrotheory(dataMtName, 
                                           dataMtComment, 
                                           dataMicrotheory, 
                                           new ArrayList());
    assertGaf(baseKB, 
              genlMt_Vocabulary, 
              theoryMt, 
              vocabMt);
    assertGaf(baseKB, 
              genlMt, 
              dataMt, 
              theoryMt);
    assertGaf(baseKB, 
              genlMt, 
              worldLikeOursMt, 
              theoryMt);
    assertGaf(baseKB, 
              genlMt, 
              currentWorldDataMt, 
              dataMt);
    mts[0] = theoryMt;
    mts[1] = vocabMt;
    mts[2] = dataMt;

    //traceOff();
    return mts;
  }

  /**
   * Assert that the specified CycConstant is a collection in the UniversalVocabularyMt. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given collection term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsaCollection(CycFort cycFort)
                           throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              isa, 
              cycFort, 
              collection);
  }

  /**
   * Assert that the specified CycConstant is a collection in the specified defining microtheory
   * MT. The operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given collection term
   * @@param mt the assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsaCollection(CycFort cycFort, 
                                  CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    ELMt elmt = makeELMt(mt);
    assertGaf(elmt, 
              isa, 
              cycFort, 
              collection);
  }

  /**
   * Assert that the genlsCollection is a genls of specCollection, in the specified defining
   * microtheory MT. The operation will be added to the KB transcript for replication and archive.
   * 
   * @@param specCollectionName the name of the more specialized collection
   * @@param genlsCollectionName the name of the more generalized collection
   * @@param mtName the assertion microtheory name
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenls(String specCollectionName, 
                          String genlsCollectionName, 
                          String mtName)
                   throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(getKnownConstantByName(mtName)), 
              genls, 
              getKnownConstantByName(specCollectionName), 
              getKnownConstantByName(genlsCollectionName));
  }

  /**
   * Assert that the genlsCollection is a genls of specCollection, in the UniversalVocabularyMt The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param specCollectionName the name of the more specialized collection
   * @@param genlsCollectionName the name of the more generalized collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenls(String specCollectionName, 
                          String genlsCollectionName)
                   throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              genls, 
              getKnownConstantByName(specCollectionName), 
              getKnownConstantByName(genlsCollectionName));
  }

  /**
   * Assert that the genlsCollection is a genls of specCollection, in the UniveralVocabularyMt. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param specCollection the more specialized collection
   * @@param genlsCollection the more generalized collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenls(CycFort specCollection, 
                          CycFort genlsCollection)
                   throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              genls, 
              specCollection, 
              genlsCollection);
  }

  /**
   * Assert that the genlsCollection is a genls of specCollection, in the specified defining
   * microtheory MT. The operation will be added to the KB transcript for replication and archive.
   * 
   * @@param specCollection the more specialized collection
   * @@param genlsCollection the more generalized collection
   * @@param mt the assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenls(CycFort specCollection, 
                          CycFort genlsCollection, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    ELMt elmt = makeELMt(mt);
    assertGaf(elmt, 
              genls, 
              specCollection, 
              genlsCollection);
  }

  /**
   * Assert that the more general predicate is a genlPreds of the more specialized predicate,
   * asserted in the UniversalVocabularyMt The operation will be added to the KB transcript for
   * replication and archive.
   * 
   * @@param specPredName the name of the more specialized predicate
   * @@param genlPredName the name of the more generalized predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenlPreds(String specPredName, 
                              String genlPredName)
                       throws IOException, UnknownHostException, CycApiException {
    CycConstant genlPreds = getKnownConstantByGuid("bd5b4951-9c29-11b1-9dad-c379636f7270");
    assertGaf(universalVocabularyMt, 
              genlPreds, 
              getKnownConstantByName(specPredName), 
              getKnownConstantByName(genlPredName));
  }

  /**
   * Assert that the more general predicate is a genlPreds of the more specialized predicate,
   * asserted in the UniversalVocabularyMt The operation will be added to the KB transcript for
   * replication and archive.
   * 
   * @@param specPred the more specialized predicate
   * @@param genlPred the more generalized predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenlPreds(CycFort specPred, 
                              CycFort genlPred)
                       throws IOException, UnknownHostException, CycApiException {
    CycConstant genlPreds = getKnownConstantByGuid("bd5b4951-9c29-11b1-9dad-c379636f7270");
    assertGaf(universalVocabularyMt, 
              genlPreds, 
              specPred, 
              genlPred);
  }

  /**
   * Assert that term1 is conceptually related to term2 in the specified microtheory. The operation
   * will be added to the KB transcript for replication and archive.
   * 
   * @@param term1 the first symbol
   * @@param term2 the second symbol
   * @@param mt the microtheory in which the assertion is made
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertConceptuallyRelated(CycFort term1, 
                                        CycFort term2, 
                                        CycObject mt)
                                 throws IOException, UnknownHostException, CycApiException {
    CycConstant conceptuallyRelated = getKnownConstantByGuid(
                                            "bd58803e-9c29-11b1-9dad-c379636f7270");
    assertGaf(makeELMt(mt), 
              conceptuallyRelated, 
              term1, 
              term2);
  }

  /**
   * Assert that the more general micortheory is a genlMt of the more specialized microtheory,
   * asserted in the UniversalVocabularyMt The operation will be added to the KB transcript for
   * replication and archive.
   * 
   * @@param specMtName the name of the more specialized microtheory
   * @@param genlsMtName the name of the more generalized microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenlMt(String specMtName, 
                           String genlsMtName)
                    throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              genlMt, 
              getKnownConstantByName(specMtName), 
              getKnownConstantByName(genlsMtName));
  }

  /**
   * Assert that the more general micortheory is a genlMt of the more specialized microtheory,
   * asserted in the UniversalVocabularyMt The operation will be added to the KB transcript for
   * replication and archive.
   * 
   * @@param specMt the more specialized microtheory
   * @@param genlsMt the more generalized microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertGenlMt(CycFort specMt, 
                           CycFort genlsMt)
                    throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              this.genlMt, 
              specMt, 
              genlsMt);
  }

  /**
   * Assert that the cycFort is a collection in the UniversalVocabularyMt. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param cycFortName the collection element name
   * @@param collectionName the collection name
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsa(String cycFortName, 
                        String collectionName)
                 throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              isa, 
              getKnownConstantByName(cycFortName), 
              getKnownConstantByName(collectionName));
  }

  /**
   * Assert that the cycFort is a collection, in the specified defining microtheory MT. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFortName the collection element name
   * @@param collectionName the collection name
   * @@param mtName the assertion microtheory name
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsa(String cycFortName, 
                        String collectionName, 
                        String mtName)
                 throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(getKnownConstantByName(mtName)), 
              isa, 
              getKnownConstantByName(cycFortName), 
              getKnownConstantByName(collectionName));
  }

  /**
   * Assert that the cycFort is a collection, in the specified defining microtheory MT. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the collection element
   * @@param aCollection the collection
   * @@param mt the assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsa(CycFort cycFort, 
                        CycFort aCollection, 
                        CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(mt), 
              isa, 
              cycFort, 
              aCollection);
  }

  /**
   * Assert that the cycFort term itself is a collection, in the given mt. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the collection element
   * @@param aCollection the collection
   * @@param mt the assertion microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertQuotedIsa(CycFort cycFort, CycFort aCollection, CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    assertGaf(makeELMt(mt), 
              getKnownConstantByGuid("055544a2-4371-11d6-8000-00a0c9da2002"), 
              cycFort, 
              aCollection);
  }

  /**
   * Assert that the cycFort is a collection, in the UniversalVocabularyMt. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the collection element
   * @@param aCollection the collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsa(CycFort cycFort, 
                        CycFort aCollection)
                 throws IOException, UnknownHostException, CycApiException {
    assertGaf(universalVocabularyMt, 
              isa, 
              cycFort, 
              aCollection);
  }

  /**
   * Assert that the specified CycConstant is a #$BinaryPredicate in the specified defining
   * microtheory. The operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given term
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsaBinaryPredicate(CycFort cycFort)
                                throws IOException, UnknownHostException, CycApiException {
    assertIsa(cycFort, 
              binaryPredicate, 
              universalVocabularyMt);
  }

  /**
   * Assert that the specified CycConstant is a #$BinaryPredicate in the specified defining
   * microtheory. The operation will be added to the KB transcript for replication and archive.
   * 
   * @@param cycFort the given term
   * @@param mt the defining microtheory
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertIsaBinaryPredicate(CycFort cycFort, 
                                       CycObject mt)
                                throws IOException, UnknownHostException, CycApiException {
    assertIsa(cycFort, 
              binaryPredicate, 
              makeELMt(mt));
  }

  /**
   * Constructs a new CycList object by parsing a string.
   * 
   * @@param string the string in CycL external (EL). For example: (#$isa #$Dog #$TameAnimal)
   * 
   * @@return the new CycList object from parsing the given string
   * 
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList makeCycList(String string)
                      throws CycApiException {
    return (new CycListParser(this)).read(string);
  }

  /**
   * Constructs a new ELMt object by the given CycObject.
   * 
   * @@param cycObject the given CycObject from which the ELMt is derived
   * 
   * @@return the new ELMt object by the given CycObject
   * 
   * @@throws IOException if a communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   * @@throws IllegalArgumentException if the cycObject is not the correct type of thing for
   * making into an ELMt
   */
  public ELMt makeELMt(CycObject cycObject)
                throws IOException, CycApiException {
    ELMt result = null;

    if (cycObject instanceof ELMt) {
      result = (ELMt) cycObject;

      return result;
    }

    if (cycObject instanceof CycList) {
      // if NAUT, then cycObject remains a CycList, but if NART then
      // cycObject becomes a CycNart
      cycObject = canonicalizeHLMT((CycList) cycObject);
    }

    if (cycObject instanceof CycFort) {
      result = makeELMt( (CycFort)cycObject);
    }
    if (cycObject instanceof CycList) {
      // NAUT mts are represented by CycList objects
      result = ELMtCycList.makeELMtCycList((CycList) cycObject);
    }
    

    return result;
  }

  public ELMt makeELMt(CycFort cycObject) {
    ELMt result = null;
    if(cycObject instanceof CycConstant)
      result = ELMtConstant.makeELMtConstant((CycConstant)cycObject);
    else if(cycObject instanceof CycNart)
      result = ELMtNart.makeELMtNart((CycNart) cycObject);
    else {
      throw new IllegalArgumentException("CycObject: " + cycObject.cyclify() + 
                                         "is not a valid ELMt.");
    }
    return result;
  }
  
  /**
   * Constructs a new ELMt object by the given String.
   * 
   * @@param elmtString the given CycObject from which the ELMt is derived
   * 
   * @@return the new ELMt object by the given CycObject
   * 
   * @@throws IOException if a communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public ELMt makeELMt(String elmtString)
                throws IOException, CycApiException {
    ELMt elmt = null;
    elmtString = elmtString.trim();

    if (elmtString.startsWith("(")) {
      CycList elmtCycList = makeCycList(elmtString);
      return makeELMt(canonicalizeHLMT(elmtCycList));
    }
    else {
      return makeELMt(getKnownConstantByName(elmtString));
    }
  }

  /**
   * Returns the canonical Heuristic Level Microtheory (HLMT) given a list  representation, which
   * can be either a Non Atomic Reified Term (NART), or a Non Atomic Un-reified Term (NAUT).  In
   * the case of NART, a CycNart object is returned, otherwise a CycList is returned.
   * 
   * @@param cycList the given CycList NART/NAUT representation
   * 
   * @@return the canonical Heuristic Level Microtheory (HLMT) given a list  representation, which
   *         can be either a Non Atomic Reified Term (NART), or a Non Atomic Un-reified Term
   *         (NAUT)
   * 
   * @@throws IOException if a communication error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycObject canonicalizeHLMT(CycList cycList)
                             throws IOException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("canonicalize-hlmt"));
    command.addQuoted(cycList);

    return converseCycObject(command);
  }

  /**
   * Wraps the given api command string with the binding environment for bookkeeping assertions.
   * 
   * @@param command the given command string
   * 
   * @@return the given api command string with the binding environment for bookkeeping assertions
   */
  public String wrapBookkeeping(String command) {
    String projectName = "nil";

    if (project != null) {
      projectName = project.stringApiValue();
    }

    String cyclistName = "nil";

    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }

    String wrappedCommand = "(with-bookkeeping-info (new-bookkeeping-info " + cyclistName + 
                            " (the-date) " + projectName + " (the-second))\n" + 
                            "  (clet ((*require-case-insensitive-name-uniqueness* nil)\n" + 
                            "         (*the-cyclist* " + cyclistName + ")\n" + 
                            "         (*ke-purpose* " + projectName + "))\n" + "    " + command + 
                            "))";

    return wrappedCommand;
  }

  /**
   * Returns a new <tt>CycConstant</tt> object using the constant name, recording bookkeeping
   * information and archiving to the Cyc transcript.
   * 
   * @@param name Name of the constant. If prefixed with "#$", then the prefix is removed for
   *        canonical representation.
   * 
   * @@return a new <tt>CycConstant</tt> object using the constant name, recording bookkeeping
   *         information and archiving to the Cyc transcript
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant makeCycConstant(String name)
                              throws UnknownHostException, IOException, CycApiException {
    String constantName = name;

    if (constantName.startsWith("#$")) {
      constantName = constantName.substring(2);
    }

    CycConstant cycConstant = this.getConstantByName(name);

    if (cycConstant != null) {
      return cycConstant;
    }

    String command = wrapBookkeeping("(ke-create-now \"" + constantName + "\")");
    Object object = converseObject(command);

    if (object instanceof CycConstant) {
      cycConstant = (CycConstant) object;
    }
    else {
      throw new CycApiException("Cannot create new constant for " + name);
    }

    cycConstant.getName();
    cycConstant.getGuid();
    CycObjectFactory.addCycConstantCacheByGuid(cycConstant);
    CycObjectFactory.addCycConstantCacheByName(cycConstant);
    CycObjectFactory.addCycConstantCacheById(cycConstant);

    return cycConstant;
  }

  /**
   * Returns a new unique <tt>CycConstant</tt> object using the constant start name prefixed by
   * TMP-, recording bookkeeping information and but without archiving to the Cyc transcript.  If
   * the start name begins with #$ that portion of the start name is ignored.
   * 
   * @@param startName the starting name of the constant which will be made unique using a suffix.
   * 
   * @@return a new <tt>CycConstant</tt> object using the constant starting name, recording
   *         bookkeeping information and archiving to the Cyc transcript
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant makeUniqueCycConstant(final String startName)
                                    throws UnknownHostException, IOException, CycApiException {
    String constantName = startName;

    if (constantName.startsWith("#$"))
      constantName = constantName.substring(2);
    String suffix = "";
    int suffixNum = 0;
    while (true ) {
      String command = "(constant-name-available \"" + startName + suffix + "\")";
      if (converseBoolean(command))
        break;
      if (suffix.length() == 0)
        suffixNum = ((int) (9 * Math.random())) + 1;
      else
        suffixNum = (suffixNum * 10) + ((int) (10 * Math.random()));
      suffix = String.valueOf(suffixNum);
    }
    return makeCycConstant(startName + suffix);
  }

  /**
   * Returns a new unique <tt>CycConstant</tt> object using the constant start name and prefix,
   * recording bookkeeping information and but without archiving to the Cyc transcript. If the
   * start name begins with #$ that portion of the start name is ignored.
   * 
   * @@param startName the starting name of the constant which will be made unique using a suffix.
   * @@param prefix the prefix
   * 
   * @@return a new <tt>CycConstant</tt> object using the constant starting name, recording
   *         bookkeeping information and archiving to the Cyc transcript
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant makeUniqueCycConstant(String startName, 
                                           String prefix)
                                    throws UnknownHostException, IOException, CycApiException {
    String constantName = startName;

    if (constantName.startsWith("#$")) {
      constantName = constantName.substring(2);
    }

    String command = wrapBookkeeping("(gentemp-constant \"" + constantName + "\" \"" + prefix + 
                                     "\")");
    CycConstant cycConstant = (CycConstant) converseObject(
                                    command);
    cycConstant.getName();
    cycConstant.getGuid();
    CycObjectFactory.addCycConstantCacheByGuid(cycConstant);
    CycObjectFactory.addCycConstantCacheByName(cycConstant);
    CycObjectFactory.addCycConstantCacheById(cycConstant);

    return cycConstant;
  }

  /**
   * Asks a Cyc query (new inference parameters) and returns the binding list.
   * 
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList askNewCycQuery(CycList query, 
                             CycObject mt, 
                             HashMap queryProperties)
                      throws IOException, UnknownHostException, CycApiException {
    String queryPropertiesString = "";
    if (queryProperties != null) {
      CycList parameterList = new CycList();
      Iterator iter = queryProperties.entrySet().iterator();

      if (iter.hasNext()) {
        while (iter.hasNext()) {
          Entry mapEntry = (Entry) iter.next();
          CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
          parameterList.add(queryParameterKeyword);

          Object queryParameterValue = mapEntry.getValue();
          parameterList.add(queryParameterValue);
        }
        queryPropertiesString = parameterList.stringApiValue();
      }
    }
    final String script =
      "(new-cyc-query "+ query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesString + ")";
    return converseList(script);
  }

  /**
   * Returns true if the  Cyc query (new inference parameters) is proven true.
   * 
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values
   * 
   * @@return true if the  Cyc query (new inference parameters) is proven true.
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public boolean isQueryTrue(CycList query, 
                             CycObject mt, 
                             HashMap queryProperties)
                      throws IOException, UnknownHostException, CycApiException {
    String queryPropertiesString = "";
    if (queryProperties != null) {
      CycList parameterList = new CycList();
      Iterator iter = queryProperties.entrySet().iterator();

      if (iter.hasNext()) {
        while (iter.hasNext()) {
          Entry mapEntry = (Entry) iter.next();
          CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
          parameterList.add(queryParameterKeyword);

          Object queryParameterValue = mapEntry.getValue();
          parameterList.add(queryParameterValue);
        }
        queryPropertiesString = parameterList.stringApiValue();
      }
    }
    final String script =
      "(new-cyc-query "+ query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesString + ")";
    return ! converseObject(script).equals(CycObjectFactory.nil);
  }

  /**
   * Asks a Cyc query (new inference parameters) and returns the binding list for the given variable.
   * 
   * @@param variable the unbound variable for which bindings are sought
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList queryVariable(final CycVariable queryVariable,
                               final CycList query, 
                               final CycObject mt, 
                               final HashMap queryProperties)
                      throws IOException, UnknownHostException, CycApiException {
    String queryPropertiesString = "";
    if (queryProperties != null) {
      CycList parameterList = new CycList();
      Iterator iter = queryProperties.entrySet().iterator();

      if (iter.hasNext()) {
        while (iter.hasNext()) {
          Entry mapEntry = (Entry) iter.next();
          CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
          parameterList.add(queryParameterKeyword);

          Object queryParameterValue = mapEntry.getValue();
          parameterList.add(queryParameterValue);
        }
        queryPropertiesString = parameterList.stringApiValue();
      }
    }
    final String script =
      "(query-variable "+ queryVariable.stringApiValue() + " " +
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesString + ")";
    
    return converseList(script);
  }

  /**
   * Asks a Cyc query (new inference parameters) and returns the binding list for the given variable list.
   * 
   * @@param variables the list of unbound variables for which bindings are sought
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList queryVariables(final CycList queryVariables,
                                final CycList query, 
                                final CycObject mt, 
                                final HashMap queryProperties)
                      throws IOException, UnknownHostException, CycApiException {
    String queryPropertiesString = "";
    if (queryProperties != null) {
      CycList parameterList = new CycList();
      Iterator iter = queryProperties.entrySet().iterator();

      if (iter.hasNext()) {
        while (iter.hasNext()) {
          Entry mapEntry = (Entry) iter.next();
          CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
          parameterList.add(queryParameterKeyword);

          Object queryParameterValue = mapEntry.getValue();
          parameterList.add(queryParameterValue);
        }
        queryPropertiesString = parameterList.stringApiValue();
      }
    }
    final String script =
      "(query-template "+ queryVariables.stringApiValue() + " " +
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesString + ")";
    
    return converseList(script);
  }

  /**
   * Asks a Cyc query and returns the binding list. Properties:
   * @@deprecated use askNewCycQuery
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param maxTransformationDepth the Integer maximum transformation depth or nil for no limit
   * @@param maxNumber the Integer maximum number of returned bindings or nil for no limit
   * @@param maxTimeSeconds the Integer maximum number of seconds inference duration or nil for no
   *        limit
   * @@param maxProofDepth the Integer maximum number of levels in the proof tree or nil for no
   *        limit
   * 
   * @@return the binding list of answers for the given query and inference property settings
   * 
   * @@throws IOException if a communication error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList askCycQuery(CycList query, 
                             CycObject mt, 
                             Object maxTransformationDepth, 
                             Object maxNumber, 
                             Object maxTimeSeconds, 
                             Object maxProofDepth)
                      throws IOException, UnknownHostException, CycApiException {
    HashMap queryProperties = new HashMap();
    queryProperties.put(CycObjectFactory.makeCycSymbol(
                              ":max-transformation-depth"), 
                        maxTransformationDepth);
    queryProperties.put(CycObjectFactory.makeCycSymbol(
                              ":max-number"), 
                        maxNumber);
    queryProperties.put(CycObjectFactory.makeCycSymbol(
                              ":max-time"), 
                        maxTimeSeconds);
    queryProperties.put(CycObjectFactory.makeCycSymbol(
                              ":max-proof-depth"), 
                        maxProofDepth);
    queryProperties.put(CycObjectFactory.makeCycSymbol(
                              ":forget-extra-results?"), 
                        CycObjectFactory.t);

    return askCycQuery(query, 
                       mt, 
                       queryProperties);
  }

  /**
   * Asks a Cyc query and returns the binding list.
   * @@deprecated
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList askCycQuery(CycList query, 
                             CycObject mt, 
                             HashMap queryProperties)
                      throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("cyc-query"));
    command.addQuoted(query);
    command.add(makeELMt(mt));

    CycList parameterList = new CycList();
    Iterator iter = queryProperties.entrySet().iterator();

    if (iter.hasNext()) {
      while (iter.hasNext()) {
        Entry mapEntry = (Entry) iter.next();
        CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
        parameterList.add(queryParameterKeyword);

        Object queryParameterValue = mapEntry.getValue();
        parameterList.add(queryParameterValue);
      }

      command.addQuoted(parameterList);
    }

    return converseList(command);
  }

  /**
   * Returns a list of bindings for a query with a single unbound variable.
   * 
   * @@deprecated
   * @@param query the query to be asked in the knowledge base
   * @@param variable the single unbound variable in the query for which bindings are sought
   * @@param mt the microtheory in which the query is asked
   * 
   * @@return a list of bindings for the query
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList queryVariable(final CycList query, 
                               final CycVariable variable, 
                               final CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    StringBuffer queryBuffer = new StringBuffer();
    queryBuffer.append("(clet ((*cache-inference-results* nil) ");
    queryBuffer.append("       (*compute-inference-results* nil) ");
    queryBuffer.append("       (*unique-inference-result-bindings* t) ");
    queryBuffer.append("       (*generate-readable-fi-results* nil)) ");
    queryBuffer.append("  (without-wff-semantics ");
    queryBuffer.append("    (ask-template " + variable.stringApiValue() + " ");
    queryBuffer.append("                  " + query.stringApiValue() + " ");
    queryBuffer.append("                  " + makeELMt(
                                                    mt).stringApiValue() + " ");
    queryBuffer.append("                  0 nil nil nil)))");

    CycList answer = converseList(queryBuffer.toString());

    return canonicalizeList(answer);
  }

  /**
   * Returns a list of bindings for a query with a single unbound variable.
   * 
   * @@deprecated use queryVariable
   * @@param query the query to be asked in the knowledge base
   * @@param variable the single unbound variable in the query for which bindings are sought
   * @@param mt the microtheory in which the query is asked
   * 
   * @@return a list of bindings for the query
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList askWithVariable(CycList query, 
                                 CycVariable variable, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    StringBuffer queryBuffer = new StringBuffer();
    queryBuffer.append("(clet ((*cache-inference-results* nil) ");
    queryBuffer.append("       (*compute-inference-results* nil) ");
    queryBuffer.append("       (*unique-inference-result-bindings* t) ");
    queryBuffer.append("       (*generate-readable-fi-results* nil)) ");
    queryBuffer.append("  (without-wff-semantics ");
    queryBuffer.append("    (ask-template " + variable.stringApiValue() + " ");
    queryBuffer.append("                  " + query.stringApiValue() + " ");
    queryBuffer.append("                  " + makeELMt(
                                                    mt).stringApiValue() + " ");
    queryBuffer.append("                  0 nil nil nil)))");

    CycList answer = converseList(queryBuffer.toString());

    return canonicalizeList(answer);
  }

  /**
   * Returns a list of bindings for a query with unbound variables.  The bindings each consist of a
   * list in the order of the unbound variables list parameter, in which each bound term is the
   * binding for the corresponding variable.
   * 
   * @@deprecated use queryVariables
   * @@param query the query to be asked in the knowledge base
   * @@param variables the list of unbound variables in the query for which bindings are sought
   * @@param mt the microtheory in which the query is asked
   * 
   * @@return a list of bindings for the query
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList askWithVariables(CycList query, 
                                  List variables, 
                                  CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    StringBuffer queryBuffer = new StringBuffer();
    queryBuffer.append("(clet ((*cache-inference-results* nil) ");
    queryBuffer.append("       (*compute-inference-results* nil) ");
    queryBuffer.append("       (*unique-inference-result-bindings* t) ");
    queryBuffer.append("       (*generate-readable-fi-results* nil)) ");
    queryBuffer.append("  (without-wff-semantics ");
    queryBuffer.append("    (ask-template " + (new CycList(variables)).stringApiValue() + " ");
    queryBuffer.append("                  " + query.stringApiValue() + " ");
    queryBuffer.append("                  " + mt.stringApiValue() + " ");
    queryBuffer.append("                  0 nil nil nil)))");

    CycList bindings = converseList(queryBuffer.toString());
    CycList canonicalBindings = new CycList();
    Iterator iter = bindings.iterator();

    while (iter.hasNext())
      canonicalBindings.add(this.canonicalizeList((CycList) iter.next()));

    return canonicalBindings;
  }

  /**
   * Returns <tt>true</tt> iff the query is true in the knowledge base.
   * 
   * @@deprecated
   * @@param query the query to be asked in the knowledge base
   * @@param mt the microtheory in which the query is asked
   * 
   * @@return <tt>true</tt> iff the query is true in the knowledge base
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQueryTrue(CycList query, 
                             CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("cyc-query"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.quote);
    command1.add(canonicalizeList(query));
    command.add(makeELMt(mt));

    CycList response = converseList(command);

    return response.size() > 0;
  }

  /**
   * Returns <tt>true</tt> iff the query is true in the knowledge base, implements a cache to avoid
   * asking the same question twice from the KB.
   * 
   * @@deprecated
   * @@param query the query to be asked in the knowledge base
   * @@param mt the microtheory in which the query is asked
   * 
   * @@return <tt>true</tt> iff the query is true in the knowledge base
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQueryTrue_Cached(CycList query, 
                                    CycObject mt)
                             throws IOException, CycApiException {
    boolean answer;
    Boolean isQueryTrue = (Boolean) askCache.getElement(
                                query);

    if (isQueryTrue != null) {
      answer = isQueryTrue.booleanValue();

      return answer;
    }

    answer = isQueryTrue(query, 
                         makeELMt(mt));
    askCache.addElement(query, 
                        new Boolean(answer));

    return answer;
  }

  /**
   * Returns the count of the instances of the given collection.
   * 
   * @@param collection the collection whose instances are counted
   * @@param mt microtheory (including its genlMts) in which the count is determined
   * 
   * @@return the count of the instances of the given collection
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int countAllInstances(CycFort collection, 
                               CycObject mt)
                        throws IOException, CycApiException {
    return this.converseInt("(count-all-instances " + collection.stringApiValue() + " " + 
                            makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns the count of the instances of the given collection, implements a cache to avoid asking
   * the same question twice from the KB.
   * 
   * @@param collection the collection whose instances are counted
   * @@param mt microtheory (including its genlMts) in which the count is determined
   * 
   * @@return the count of the instances of the given collection
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int countAllInstances_Cached(CycFort collection, 
                                      CycObject mt)
                               throws IOException, CycApiException {
    int answer;
    Integer countAllInstances = (Integer) countAllInstancesCache.getElement(
                                      collection);

    if (countAllInstances != null) {
      answer = countAllInstances.intValue();

      return answer;
    }

    answer = countAllInstances(collection, 
                               makeELMt(mt));
    countAllInstancesCache.addElement(collection, 
                                      new Integer(answer));

    return answer;
  }

  /**
   * Gets a list of the backchaining implication rules which might apply to the given rule.
   * 
   * @@param predicate the predicate for which backward chaining implication rules are sought
   * @@param formula the literal for which backward chaining implication rules are sought
   * @@param mt the microtheory (and its genlMts) in which the search for backchaining implication
   *        rules takes place
   * 
   * @@return a list of the backchaining implication rules which might apply to the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getBackchainImplicationRules(CycConstant predicate, 
                                              CycList formula, 
                                              CycObject mt)
                                       throws IOException, UnknownHostException, CycApiException {
    StringBuffer command = new StringBuffer();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.append("(clet (backchain-rules formula) ");
      command.append("  (with-all-mts ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + 
                     " :pos nil :backward) ");
      command.append("       (csetq formula (assertion-el-formula rule)) ");
      command.append("       (pwhen (cand (eq (first formula) #$implies) ");
      command.append("                    (unify-el-possible " + formula.stringApiValue() + " ");
      command.append("                                          (third formula))) ");
      command.append("         (cpush formula backchain-rules)))) ");
      command.append("   backchain-rules)");
    }
    else {
      command.append("(clet (backchain-rules formula) ");
      command.append("  (with-mt " + makeELMt(mt).stringApiValue() + " ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + 
                     " :pos nil :backward) ");
      command.append("       (csetq formula (assertion-el-formula rule)) ");
      command.append("       (pwhen (cand (eq (first formula) #$implies) ");
      command.append("                    (unify-el-possible " + formula.stringApiValue() + " ");
      command.append("                                          (third formula))) ");
      command.append("         (cpush formula backchain-rules)))) ");
      command.append("   backchain-rules)");
    }

    //this.traceOn();
    return converseList(command.toString());
  }

  /**
   * Gets a list of the forward chaining implication rules which might apply to the given rule.
   * 
   * @@param predicate the predicate for which forward chaining implication rules are sought
   * @@param formula the literal for which forward chaining implication rules are sought
   * @@param mt the microtheory (and its genlMts) in which the search for forward chaining rules
   *        takes place
   * 
   * @@return a list of the forward chaining implication rules which might apply to the given
   *         predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getForwardChainRules(CycConstant predicate, 
                                      CycList formula, 
                                      CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    StringBuffer command = new StringBuffer();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.append("(clet (backchain-rules formula) ");
      command.append("  (with-all-mts ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + 
                     " :pos nil :forward) ");
      command.append("       (csetq formula (assertion-el-formula rule)) ");
      command.append("       (pwhen (cand (eq (first formula) #$implies) ");
      command.append("                    (unify-el-possible " + formula.stringApiValue() + " ");
      command.append("                                          (third formula))) ");
      command.append("         (cpush formula backchain-rules)))) ");
      command.append("   backchain-rules)");
    }
    else {
      command.append("(clet (backchain-rules formula) ");
      command.append("  (with-mt " + makeELMt(mt).stringApiValue() + " ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + 
                     " :pos nil :forward) ");
      command.append("       (csetq formula (assertion-el-formula rule)) ");
      command.append("       (pwhen (cand (eq (first formula) #$implies) ");
      command.append("                    (unify-el-possible " + formula.stringApiValue() + " ");
      command.append("                                          (third formula))) ");
      command.append("         (cpush formula backchain-rules)))) ");
      command.append("   backchain-rules)");
    }

    return converseList(command.toString());
  }

  /**
   * Gets a list of the backchaining implication rules which might apply to the given predicate.
   * 
   * @@param predicate the predicate for which backchaining rules are sought
   * @@param mt the microtheory (and its genlMts) in which the search for backchaining rules takes
   *        place
   * 
   * @@return a list of the backchaining implication rules which might apply to the given predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getBackchainRules(CycConstant predicate, 
                                   CycObject mt)
                            throws IOException, UnknownHostException, CycApiException {
    StringBuffer command = new StringBuffer();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.append("(clet (backchain-rules) ");
      command.append("  (with-all-mts ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
      command.append("                                :sense :pos ");
      command.append("                                :done nil ");
      command.append("                                :direction :backward) ");
      command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
      command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
      command.append("   backchain-rules)");
    }
    else {
      command.append("(clet (backchain-rules) ");
      command.append("  (with-mt " + makeELMt(mt).stringApiValue() + " ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
      command.append("                                :sense :pos ");
      command.append("                                :done nil ");
      command.append("                                :direction :backward) ");
      command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
      command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
      command.append("   backchain-rules)");
    }

    //this.traceOn();
    return converseList(command.toString());
  }

  /**
   * Gets a list of the forward chaining implication rules which might apply to the given
   * predicate.
   * 
   * @@param predicate the predicate for which forward chaining rules are sought
   * @@param mt the microtheory (and its genlMts) in which the search for forward chaining rules
   *        takes place
   * 
   * @@return a list of the forward chaining implication rules which might apply to the given
   *         predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getForwardChainRules(CycConstant predicate, 
                                      CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    StringBuffer command = new StringBuffer();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.append("(clet (backchain-rules) ");
      command.append("  (with-all-mts ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
      command.append("                                :sense :pos ");
      command.append("                                :done nil ");
      command.append("                                :direction :forward) ");
      command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
      command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
      command.append("   backchain-rules)");
    }
    else {
      command.append("(clet (backchain-rules) ");
      command.append("  (with-mt " + makeELMt(mt).stringApiValue() + " ");
      command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
      command.append("                                :sense :pos ");
      command.append("                                :done nil ");
      command.append("                                :direction :forward) ");
      command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
      command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
      command.append("   backchain-rules)");
    }

    return converseList(command.toString());
  }

  /**
   * Gets the value of a given KB symbol.  This is intended mainly for test case setup.
   * 
   * @@param cycSymbol the KB symbol which will have a value bound
   * 
   * @@return the value assigned to the symbol
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Object getSymbolValue(CycSymbol cycSymbol)
                        throws IOException, UnknownHostException, CycApiException {
    return converseObject("(symbol-value " + cycSymbol.stringApiValue() + ")");
  }

  /**
   * Sets a KB symbol to have the specified value.  This is intended mainly for test case setup. If
   * the symbol does not exist at the KB, then it will be created and assigned the value.
   * 
   * @@param cycSymbol the KB symbol which will have a value bound
   * @@param value the value assigned to the symbol
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void setSymbolValue(CycSymbol cycSymbol, 
                             Object value)
                      throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("csetq"));
    command.add(cycSymbol);
    command.add(value);
    converseVoid(command);
  }

  /**
   * Returns <tt>true</tt> iff <tt>CycList</tt> represents a well formed formula.
   * 
   * @@param cycList the candidate well-formed-formula
   * 
   * @@return true iff cycList represents a well formed formula
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isWellFormedFormula(CycList cycList)
                              throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("el-wff?"));

    CycList command2 = new CycList();
    command1.add(command2);
    command2.add(CycObjectFactory.quote);
    command2.add(cycList);

    return converseBoolean(command);
  }

  /**
   * Returns <tt>true</tt> iff backchain inference on the given predicate is required.
   * 
   * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining required status is
   *        sought
   * @@param mt microtheory (including its genlMts) in which the backchaining required status is
   *        sought
   * 
   * @@return <tt>true</tt> iff backchain inference on the given predicate is required
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isBackchainRequired(CycConstant predicate, 
                                     CycObject mt)
                              throws IOException, CycApiException {
    CycConstant backchainRequired = getKnownConstantByGuid(
                                          "beaa3d29-9c29-11b1-9dad-c379636f7270");

    return hasSomePredicateUsingTerm(backchainRequired, 
                                     predicate, 
                                     new Integer(1), 
                                     makeELMt(mt));
  }

  /**
   * Returns <tt>true</tt> iff backchain inference on the given predicate is encouraged.
   * 
   * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining encouraged status
   *        is sought
   * @@param mt microtheory (including its genlMts) in which the backchaining encouraged status is
   *        sought
   * 
   * @@return <tt>true</tt> iff backchain inference on the given predicate is encouraged
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isBackchainEncouraged(CycConstant predicate, 
                                       CycObject mt)
                                throws IOException, CycApiException {
    CycConstant backchainEncouraged = getKnownConstantByGuid(
                                            "c09d1cea-9c29-11b1-9dad-c379636f7270");

    return hasSomePredicateUsingTerm(backchainEncouraged, 
                                     predicate, 
                                     new Integer(1), 
                                     makeELMt(mt));
  }

  /**
   * Returns <tt>true</tt> iff backchain inference on the given predicate is discouraged.
   * 
   * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining discouraged status
   *        is sought
   * @@param mt microtheory (including its genlMts) in which the backchaining discouraged status is
   *        sought
   * 
   * @@return <tt>true</tt> iff backchain inference on the given predicate is discouraged
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isBackchainDiscouraged(CycConstant predicate, 
                                        CycObject mt)
                                 throws IOException, CycApiException {
    CycConstant backchainDiscouraged = getKnownConstantByGuid(
                                             "bfcbce14-9c29-11b1-9dad-c379636f7270");

    return hasSomePredicateUsingTerm(backchainDiscouraged, 
                                     predicate, 
                                     new Integer(1), 
                                     makeELMt(mt));
  }

  /**
   * Returns <tt>true</tt> iff backchain inference on the given predicate is forbidden.
   * 
   * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining forbidden status is
   *        sought
   * @@param mt microtheory (including its genlMts) in which the backchaining forbidden status is
   *        sought
   * 
   * @@return <tt>true</tt> iff backchain inference on the given predicate is forbidden
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isBackchainForbidden(CycConstant predicate, 
                                      CycObject mt)
                               throws IOException, CycApiException {
    CycConstant backchainForbidden = getKnownConstantByGuid(
                                           "bfa4e9d2-9c29-11b1-9dad-c379636f7270");

    return hasSomePredicateUsingTerm(backchainForbidden, 
                                     predicate, 
                                     new Integer(1), 
                                     makeELMt(mt));
  }

  /**
   * Returns <tt>true</tt> iff the predicate has the irreflexive property: (#$isa ?PRED
   * #$IrreflexsiveBinaryPredicate).
   * 
   * @@param predicate the <tt>CycConstant</tt> predicate for which irreflexive status is sought
   * @@param mt microtheory (including its genlMts) in which the irreflexive status is sought
   * 
   * @@return <tt>true</tt> iff the predicate has the irreflexive property: (#$isa ?PRED
   *         #$IrreflexsiveBinaryPredicate)
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isIrreflexivePredicate(CycConstant predicate, 
                                        CycObject mt)
                                 throws IOException, CycApiException {
    CycConstant irreflexiveBinaryPredicate = getKnownConstantByGuid(
                                                   "bd654be7-9c29-11b1-9dad-c379636f7270");

    return this.isa(predicate, 
                    irreflexiveBinaryPredicate, 
                    makeELMt(mt));
  }

  /**
   * Returns <tt>true</tt> iff any ground formula instances exist having the given predicate, and
   * the given term in the given argument position.
   * 
   * @@param term the term present at the given argument position
   * @@param predicate the <tt>CycConstant</tt> predicate for the formula
   * @@param argumentPosition the argument position of the given term in the ground formula
   * @@param mt microtheory (including its genlMts) in which the existence is sought
   * 
   * @@return <tt>true</tt> iff any ground formula instances exist having the given predicate, and
   *         the given term in the given argument position
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean hasSomePredicateUsingTerm(CycConstant predicate, 
                                           CycFort term, 
                                           Integer argumentPosition, 
                                           CycObject mt)
                                    throws IOException, CycApiException {
    CycList command = new CycList();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.add(CycObjectFactory.makeCycSymbol("some-pred-value-in-any-mt"));
      command.add(term.cycListApiValue());
      command.add(predicate.cycListApiValue());
    }
    else {
      command.add(CycObjectFactory.makeCycSymbol("some-pred-value-in-relevant-mts"));
      command.add(term.cycListApiValue());
      command.add(predicate.cycListApiValue());
      command.add(makeELMt(mt).cycListApiValue());
    }

    command.add(argumentPosition);

    //this.traceOn();
    return converseBoolean(command);
  }

  /**
   * Returns the count of the assertions indexed according to the given pattern, using the best
   * index (from among the predicate and argument indices).  The formula can contain variables.
   * 
   * @@param formula the formula whose indexed instances are counted
   * @@param mt microtheory (including its genlMts) in which the count is determined
   * 
   * @@return the count of the assertions indexed according to the given pattern, using the best
   *         index (from among the predicate and argument indices)
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int countUsingBestIndex(CycList formula, 
                                 CycObject mt)
                          throws IOException, CycApiException {
    CycList command = new CycList();
    ELMt inferencePsc = makeELMt(getKnownConstantByGuid(
                                       "bd58915a-9c29-11b1-9dad-c379636f7270"));
    ELMt everythingPsc = makeELMt(getKnownConstantByGuid(
                                        "be7f041b-9c29-11b1-9dad-c379636f7270"));

    if (makeELMt(mt).equals(inferencePsc) || makeELMt(mt).equals(
                                                   everythingPsc)) {
      command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));
    }
    else {
      command.add(CycObjectFactory.makeCycSymbol("with-mt"));
      command.add(makeELMt(mt).cycListApiValue());
    }

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("best-index-count"));

    CycList command2 = new CycList();
    command1.add(command2);
    command2.add(CycObjectFactory.quote);
    command2.add(formula.cycListApiValue());
    command1.add(CycObjectFactory.t);
    command1.add(CycObjectFactory.t);

    //this.traceOn();
    return converseInt(command);
  }

  /**
   * Imports a MUC (Message Understanding Conference) formatted symbolic expression into cyc via
   * the function which parses the expression and creates assertions for the contained concepts
   * and relations between them.
   * 
   * @@param mucExpression the MUC (Message Understanding Conference) formatted symbolic expression
   * @@param mtName the name of the microtheory in which the imported assertions will be made
   * 
   * @@return the number of assertions imported from the input MUC expression
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int importMucExpression(CycList mucExpression, 
                                 String mtName)
                          throws IOException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("convert-netowl-sexpr-to-cycl-assertions"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.quote);
    command1.add(mucExpression.cycListApiValue());
    command.add(mtName);

    //this.traceOn();
    return converseInt(command);
  }

  /**
   * Returns a list of parsing expressions, each consisting of a parsing span expression, and a
   * list of parsed terms.
   * <pre>
   * (RKF-PHRASE-READER "penguins" #$RKFEnglishLexicalMicrotheoryPSC #$InferencePSC)
   * ==>
   * (((0) (#$Penguin #$PittsburghPenguins)))
   * </pre>
   * 
   * @@param text the phrase to be parsed
   * @@param parsingMt the microtheory in which lexical info is asked
   * @@param domainMt the microtherory in which the info about candidate terms is asked
   * 
   * @@return a parsing expression consisting of a parsing span expression, and a list of parsed
   *         terms
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList rkfPhraseReader(String text, 
                                 String parsingMt, 
                                 String domainMt)
                          throws IOException, CycApiException {
    return rkfPhraseReader(text, 
                           getKnownConstantByName(parsingMt), 
                           getKnownConstantByName(domainMt));
  }

  /**
   * Returns a list of parsing expressions, each consisting of a parsing span expression, and a
   * list of parsed terms.
   * <pre>
   * (RKF-PHRASE-READER "penguins" #$RKFEnglishLexicalMicrotheoryPSC #$InferencePSC)
   * ==>
   * (((0) (#$Penguin #$PittsburghPenguins)))
   * </pre>
   * 
   * @@param text the phrase to be parsed
   * @@param parsingMt the microtheory in which lexical info is asked
   * @@param domainMt the microtherory in which the info about candidate terms is asked
   * 
   * @@return a parsing expression consisting of a parsing span expression, and a list of parsed
   *         terms
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList rkfPhraseReader(String text, 
                                 CycFort parsingMt, 
                                 CycFort domainMt)
                          throws IOException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("rkf-phrase-reader"));
    command.add(text);
    command.add(parsingMt);
    command.add(domainMt);

    return converseList(command);
  }

  /**
   * Returns a list of disambiguation expressions, corresponding to each of the terms in the given
   * list of objects.
   * <pre>
   * (GENERATE-DISAMBIGUATION-PHRASES-AND-TYPES (QUOTE (#$Penguin #$PittsburghPenguins)))
   * ==>
   * ((#$Penguin "penguin" #$Bird "bird")
   *  (#$PittsburghPenguins "the Pittsburgh Penguins" #$IceHockeyTeam "ice hockey team"))
   * </pre>
   * 
   * @@param objects the list of terms to be disambiguated
   * 
   * @@return a list of disambiguation expressions, corresponding to each of the terms in the given
   *         list of objects
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList generateDisambiguationPhraseAndTypes(CycList objects)
                                               throws IOException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("generate-disambiguation-phrases-and-types"));
    command.addQuoted(objects);

    return converseList(command);
  }

  /**
   * Returns the arity of the given predicate.
   * 
   * @@param predicate the given predicate whose number of arguments is sought
   * 
   * @@return the arity of the given predicate, or zero if the argument is not a predicate
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public int getArity(CycFort predicate)
               throws IOException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));

    CycList command1 = new CycList();
    command.add(command1);
    command1.add(CycObjectFactory.makeCycSymbol("arity"));
    command1.add(predicate);

    Object object = this.converseObject(command);

    if (object instanceof Integer) {
      return ((Integer) object).intValue();
    }
    else {
      return 0;
    }
  }

  /**
   * Returns the list of arg2 values of binary gafs, given the predicate and arg1, looking in all
   * microtheories.
   * 
   * @@param predicate the given predicate for the gaf pattern
   * @@param arg1 the given first argument of the gaf
   * 
   * @@return the list of arg2 values of the binary gafs
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getArg2s(CycFort predicate, 
                          Object arg1)
                   throws IOException, CycApiException {
    CycList query = new CycList();
    query.add(predicate);
    query.add(arg1);

    CycVariable variable = CycObjectFactory.makeCycVariable(
                                 "?arg2");
    query.add(variable);

    return (CycList) askWithVariable(query, 
                                     variable, 
                                     inferencePSC);
  }

  /**
   * Returns the single (first) arg2 value of a binary gaf, given the predicate and arg0, looking
   * in all microtheories.  Return null if none found.
   * 
   * @@param predicate the given predicate for the gaf pattern
   * @@param arg1 the given first argument of the gaf
   * 
   * @@return the single (first) arg2 value of the binary gaf(s)
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public Object getArg2(CycFort predicate, 
                        Object arg1)
                 throws IOException, CycApiException {
    CycList arg2s = getArg2s(predicate, 
                             arg1);

    if (arg2s.isEmpty()) {
      return null;
    }
    else {
      return arg2s.first();
    }
  }

  /**
   * Returns true if formula is well-formed in the relevant mt.
   * 
   * @@param formula the given EL formula
   * @@param mt the relevant mt
   * 
   * @@return true if formula is well-formed in the relevant mt, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isFormulaWellFormed(CycList formula, 
                                     CycObject mt)
                              throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(el-formula-ok? " + formula.stringApiValue() + " " + 
                           makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns true if formula is well-formed Non Atomic Reifable Term.
   * 
   * @@param formula the given EL formula
   * 
   * @@return true if formula is well-formed Non Atomic Reifable Term, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCycLNonAtomicReifableTerm(CycList formula)
                                      throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(cycl-nart-p " + formula.stringApiValue() + ")");
  }

  /**
   * Returns true if formula is well-formed Non Atomic Un-reifable Term.
   * 
   * @@param formula the given EL formula
   * 
   * @@return true if formula is well-formed Non Atomic Un-reifable Term, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCycLNonAtomicUnreifableTerm(CycList formula)
                                        throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(cycl-naut-p " + formula.stringApiValue() + ")");
  }

  /**
   * Creates a new Collector microtheory and links it more general mts.
   * 
   * @@param mtName the name of the new collector microtheory
   * @@param comment the comment for the new collector microtheory
   * @@param genlMts the list of more general microtheories
   * 
   * @@return the new microtheory
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createCollectorMt(String mtName, 
                                       String comment, 
                                       List genlMts)
                                throws IOException, CycApiException {
    CycConstant collectorMt = getKnownConstantByName("CollectorMicrotheory");

    return createMicrotheory(mtName, 
                             comment, 
                             collectorMt, 
                             genlMts);
  }

  /**
   * Asserts each of the given list of forts to be instances of the given collection in the
   * UniversalVocabularyMt
   * 
   * @@param fortNames the list of forts
   * @@param collectionName
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertIsas(List fortNames, 
                         String collectionName)
                  throws IOException, CycApiException {
    List forts = new ArrayList();

    for (int i = 0; i < forts.size(); i++) {
      Object fort = forts.get(i);

      if (fort instanceof String) {
        forts.add(getKnownConstantByName((String) fort));
      }
      else if (fort instanceof CycFort) {
        forts.add(fort);
      }
      else {
        throw new CycApiException(fort + " is neither String nor CycFort");
      }

      assertIsas(forts, 
                 getKnownConstantByName(collectionName));
    }
  }

  /**
   * Asserts each of the given list of forts to be instances of the given collection in the
   * UniversalVocabularyMt
   * 
   * @@param forts the list of forts
   * @@param collection
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertIsas(List forts, 
                         CycFort collection)
                  throws IOException, CycApiException {
    for (int i = 0; i < forts.size(); i++) {
      assertIsa((CycFort) forts.get(i), 
                collection);
    }
  }

  /**
   * Creates a new spindle microtheory in the given spindle system.
   * 
   * @@param spindleMtName the name of the new spindle microtheory
   * @@param comment the comment for the new spindle microtheory
   * @@param spindleHeadMtName the name of the spindle head microtheory
   * @@param spindleCollectorMtName the name of the spindle head microtheory
   * 
   * @@return the new spindle microtheory in the given spindle system
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createSpindleMt(String spindleMtName, 
                                     String comment, 
                                     String spindleHeadMtName, 
                                     String spindleCollectorMtName)
                              throws IOException, CycApiException {
    return createSpindleMt(spindleMtName, 
                           comment, 
                           getKnownConstantByName(spindleHeadMtName), 
                           getKnownConstantByName(spindleCollectorMtName));
  }

  /**
   * Creates a new spindle microtheory in the given spindle system.
   * 
   * @@param spindleMtName the name of the new spindle microtheory
   * @@param comment the comment for the new spindle microtheory
   * @@param spindleHeadMt the spindle head microtheory
   * @@param spindleCollectorMt the spindle head microtheory
   * 
   * @@return the new spindle microtheory in the given spindle system
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createSpindleMt(String spindleMtName, 
                                     String comment, 
                                     CycFort spindleHeadMt, 
                                     CycFort spindleCollectorMt)
                              throws IOException, CycApiException {
    CycConstant spindleMt = getKnownConstantByName("SpindleMicrotheory");
    List genlMts = new ArrayList();
    genlMts.add(spindleHeadMt);

    CycConstant mt = this.createMicrotheory(spindleMtName, 
                                            comment, 
                                            spindleMt, 
                                            genlMts);
    assertGaf(universalVocabularyMt, 
              genlMt, 
              spindleCollectorMt, 
              mt);

    return mt;
  }

  /**
   * Creates a new binary predicate term.
   * 
   * @@param predicateName the name of the new binary predicate
   * @@param predicateTypeName the type of binary predicate, for example
   *        #$TransitiveBinaryPredicate, which when null defaults to #$BinaryPredicate
   * @@param comment the comment for the new binary predicate, or null
   * @@param arg1IsaName the argument position one type constraint, or null
   * @@param arg2IsaName the argument position two type constraint, or null
   * @@param arg1FormatName the argument position one format constraint, or null
   * @@param arg2FormatName the argument position two format constraint, or null
   * @@param genlPredsName the more general binary predicate of which this new predicate is a
   *        specialization, that when null defaults to #$conceptuallyRelated
   * @@param genFormatList the paraphrase generation list string, or null
   * @@param genFormatString the paraphrase generation string, or null
   * 
   * @@return the new binary predicate term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createBinaryPredicate(String predicateName, 
                                           String predicateTypeName, 
                                           String comment, 
                                           String arg1IsaName, 
                                           String arg2IsaName, 
                                           String arg1FormatName, 
                                           String arg2FormatName, 
                                           String genlPredsName, 
                                           String genFormatString, 
                                           String genFormatList)
                                    throws IOException, CycApiException {
    return createBinaryPredicate(predicateName, 
                                 find(predicateTypeName), 
                                 comment, 
                                 find(arg1IsaName), 
                                 find(arg2IsaName), 
                                 find(arg1FormatName), 
                                 find(arg2FormatName), 
                                 find(genlPredsName), 
                                 genFormatString, 
                                 makeCycList(genFormatList));
  }

  /**
   * Creates a new binary predicate term.
   * 
   * @@param predicateName the name of the new binary predicate
   * @@param predicateType the type of binary predicate, for example #$TransitiveBinaryPredicate,
   *        which when null defaults to #$BinaryPredicate
   * @@param comment the comment for the new binary predicate, or null
   * @@param arg1Isa the argument position one type constraint, or null
   * @@param arg2Isa the argument position two type constraint, or null
   * @@param arg1Format the argument position one format constraint, or null
   * @@param arg2Format the argument position two format constraint, or null
   * @@param genlPreds the more general binary predicate of which this new predicate is a
   *        specialization, that when null defaults to #$conceptuallyRelated
   * @@param genFormatList the paraphrase generation list string, or null
   * @@param genFormatString the paraphrase generation string, or null
   * 
   * @@return the new binary predicate term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createBinaryPredicate(String predicateName, 
                                           CycFort predicateType, 
                                           String comment, 
                                           CycFort arg1Isa, 
                                           CycFort arg2Isa, 
                                           CycFort arg1Format, 
                                           CycFort arg2Format, 
                                           CycFort genlPreds, 
                                           String genFormatString, 
                                           CycList genFormatList)
                                    throws IOException, CycApiException {
    CycConstant predicate = findOrCreate(predicateName);

    if (predicateType == null) {
      assertIsa(predicate, 
                binaryPredicate);
    }
    else {
      assertIsa(predicate, 
                predicateType);
    }

    if (comment != null) {
      assertComment(predicate, 
                    comment, 
                    baseKB);
    }

    if (arg1Isa != null) {
      assertArgIsa(predicate, 
                   1, 
                   arg1Isa);
    }

    if (arg2Isa != null) {
      assertArgIsa(predicate, 
                   2, 
                   arg2Isa);
    }

    if (arg1Format != null) {
      assertArgFormat(predicate, 
                      1, 
                      arg1Format);
    }

    if (arg2Format != null) {
      assertArgFormat(predicate, 
                      2, 
                      arg2Format);
    }

    if (genlPreds == null) {
      assertGenlPreds(predicate, 
                      
      // #$conceptuallyRelated
      getKnownConstantByGuid("bd58803e-9c29-11b1-9dad-c379636f7270"));
    }
    else {
      assertGenlPreds(predicate, 
                      genlPreds);
    }

    if ((genFormatString != null) && (genFormatList != null)) {
      assertGenFormat(predicate, 
                      genFormatString, 
                      genFormatList);
    }

    return predicate;
  }

  /**
   * Creates a new KB subset collection term.
   * 
   * @@param constantName the name of the new KB subset collection
   * @@param comment the comment for the new KB subset collection
   * 
   * @@return the new KB subset collection term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createKbSubsetCollection(String constantName, 
                                              String comment)
                                       throws IOException, CycApiException {
    CycConstant kbSubsetCollection = getKnownConstantByName(
                                           "KBSubsetCollection");
    CycConstant cycConstant = getConstantByName(constantName);

    if (cycConstant == null) {
      cycConstant = createNewPermanent(constantName);
    }

    assertIsa(cycConstant, 
              kbSubsetCollection);
    assertComment(cycConstant, 
                  comment, 
                  baseKB);
    assertGenls(cycConstant, 
                thing);

    CycFort variableOrderCollection = getKnownConstantByGuid(
                                            "36cf85d0-20a1-11d6-8000-0050dab92c2f");
    assertIsa(cycConstant, 
              variableOrderCollection, 
              baseKB);

    return cycConstant;
  }

  /**
   * Creates a new collection term.
   * 
   * @@param collectionName the name of the new collection
   * @@param comment the comment for the collection
   * @@param commentMtName the name of the microtheory in which the comment is asserted
   * @@param isaName the name of the collection of which the new collection is an instance
   * @@param genlsName the name of the collection of which the new collection is a subset
   * 
   * @@return the new collection term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant createCollection(String collectionName, 
                                      String comment, 
                                      String commentMtName, 
                                      String isaName, 
                                      String genlsName)
                               throws IOException, CycApiException {
    CycConstant collection = findOrCreate(collectionName);
    assertComment(collection, 
                  comment, 
                  getKnownConstantByName(commentMtName));
    assertIsa(collection, 
              getKnownConstantByName(isaName));
    assertGenls(collection, 
                getKnownConstantByName(genlsName));

    return collection;
  }

  /**
   * Creates a new collection term.
   * 
   * @@param collectionName the name of the new collection
   * @@param comment the comment for the collection
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param isa the collection of which the new collection is an instance
   * @@param genls the collection of which the new collection is a subset
   * 
   * @@return the new collection term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollection(String collectionName, 
                                  String comment, 
                                  CycFort commentMt, 
                                  CycFort isa, 
                                  CycFort genls)
                           throws IOException, CycApiException {
    return createCollection(findOrCreate(collectionName), 
                            comment, 
                            commentMt, 
                            isa, 
                            genls);
  }

  /**
   * Creates a new collection term.
   * 
   * @@param collection the new collection
   * @@param comment the comment for the collection
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param isa the collection of which the new collection is an instance
   * @@param genls the collection of which the new collection is a subset
   * 
   * @@return the new collection term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollection(CycFort collection, 
                                  String comment, 
                                  CycFort commentMt, 
                                  CycFort isa, 
                                  CycFort genls)
                           throws IOException, CycApiException {
    assertComment(collection, 
                  comment, 
                  commentMt);
    assertIsa(collection, 
              isa);
    assertGenls(collection, 
                genls);

    return collection;
  }

  /**
   * Creates a new individual term.
   * 
   * @@param IndividualName the name of the new individual term
   * @@param comment the comment for the individual
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param isa the collection of which the new individual is an instance
   * 
   * @@return the new individual term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createIndividual(String IndividualName, 
                                  String comment, 
                                  String commentMt, 
                                  String isa)
                           throws IOException, CycApiException {
    return createIndividual(IndividualName, 
                            comment, 
                            getKnownConstantByName(commentMt), 
                            getKnownConstantByName(isa));
  }

  /**
   * Creates a new individual term.
   * 
   * @@param IndividualName the name of the new individual term
   * @@param comment the comment for the individual
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param isa the collection of which the new individual is an instance
   * 
   * @@return the new individual term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createIndividual(String IndividualName, 
                                  String comment, 
                                  CycFort commentMt, 
                                  CycFort isa)
                           throws IOException, CycApiException {
    CycFort individual = findOrCreate(IndividualName);
    assertComment(individual, 
                  comment, 
                  commentMt);
    assertIsa(individual, 
              isa);

    return individual;
  }

  /**
   * Creates a new individual-denoting reifiable unary function term.
   * 
   * @@param unaryFunction the new collection
   * @@param comment the comment for the unary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1Isa the kind of objects this unary function takes as its argument
   * @@param resultIsa the kind of object represented by this reified term
   * 
   * @@return the new individual-denoting reifiable unary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createIndivDenotingUnaryFunction(String unaryFunction, 
                                                  String comment, 
                                                  String commentMt, 
                                                  String arg1Isa, 
                                                  String resultIsa)
                                           throws IOException, CycApiException {
    return createIndivDenotingUnaryFunction(findOrCreate(
                                                  unaryFunction), 
                                            comment, 
                                            getKnownConstantByName(
                                                  commentMt), 
                                            getKnownConstantByName(
                                                  arg1Isa), 
                                            getKnownConstantByName(
                                                  resultIsa));
  }

  /**
   * Creates a new individual-denoting reifiable unary function term.
   * 
   * @@param unaryFunction the new collection
   * @@param comment the comment for the unary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1Isa the kind of objects this unary function takes as its argument
   * @@param resultIsa the kind of object represented by this reified term
   * 
   * @@return the new individual-denoting reifiable unary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createIndivDenotingUnaryFunction(CycFort unaryFunction, 
                                                  String comment, 
                                                  CycFort commentMt, 
                                                  CycFort arg1Isa, 
                                                  CycFort resultIsa)
                                           throws IOException, CycApiException {
    assertComment(unaryFunction, 
                  comment, 
                  commentMt);


    // (#$isa unaryFunction #$UnaryFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd58af89-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$ReifiableFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$IndividualDenotingFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd58fad9-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$Function-Denotational)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));
    assertArgIsa(unaryFunction, 
                 1, 
                 arg1Isa);
    assertResultIsa(unaryFunction, 
                    resultIsa);

    return unaryFunction;
  }

  /**
   * Creates a new collection-denoting reifiable unary function term.
   * 
   * @@param unaryFunction the new collection
   * @@param comment the comment for the unary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1Isa the isa type constraint for the argument
   * @@param arg1GenlName the genls type constraint for the argument if it is a collection
   * @@param resultIsa the isa object represented by this reified term
   * @@param resultGenlName the genls object represented by this reified term
   * 
   * @@return the new collection-denoting reifiable unary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollectionDenotingUnaryFunction(String unaryFunction, 
                                                       String comment, 
                                                       String commentMt, 
                                                       String arg1Isa, 
                                                       String arg1GenlName, 
                                                       String resultIsa, 
                                                       String resultGenlName)
                                                throws IOException, CycApiException {
    CycFort arg1Genl;

    if (arg1GenlName != null) {
      arg1Genl = getKnownConstantByName(arg1GenlName);
    }
    else {
      arg1Genl = null;
    }

    CycFort resultGenl;

    if (resultGenlName != null) {
      resultGenl = getKnownConstantByName(resultGenlName);
    }
    else {
      resultGenl = null;
    }

    return createCollectionDenotingUnaryFunction(findOrCreate(
                                                       unaryFunction), 
                                                 comment, 
                                                 getKnownConstantByName(
                                                       commentMt), 
                                                 getKnownConstantByName(
                                                       arg1Isa), 
                                                 arg1Genl, 
                                                 getKnownConstantByName(
                                                       resultIsa), 
                                                 resultGenl);
  }

  /**
   * Creates a new collection-denoting reifiable unary function term.
   * 
   * @@param unaryFunction the new collection
   * @@param comment the comment for the unary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1Isa the isa type constraint for the argument
   * @@param arg1Genl the genls type constraint for the argument if it is a collection
   * @@param resultIsa the isa object represented by this reified term
   * @@param resultGenl the genls object represented by this reified term
   * 
   * @@return the new collection-denoting reifiable unary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollectionDenotingUnaryFunction(CycFort unaryFunction, 
                                                       String comment, 
                                                       CycFort commentMt, 
                                                       CycFort arg1Isa, 
                                                       CycFort arg1Genl, 
                                                       CycFort resultIsa, 
                                                       CycFort resultGenl)
                                                throws IOException, CycApiException {
    assertComment(unaryFunction, 
                  comment, 
                  commentMt);


    // (#$isa unaryFunction #$UnaryFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd58af89-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$ReifiableFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$CollectionDenotingFunction)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd58806a-9c29-11b1-9dad-c379636f7270"));


    // (#$isa unaryFunction #$Function-Denotational)
    assertIsa(unaryFunction, 
              getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));
    assertArgIsa(unaryFunction, 
                 1, 
                 arg1Isa);

    if (arg1Genl != null) {
      assertArg1Genl(unaryFunction, 
                     arg1Genl);
    }

    assertResultIsa(unaryFunction, 
                    resultIsa);

    if (resultGenl != null) {
      assertResultGenl(unaryFunction, 
                       resultGenl);
    }

    return unaryFunction;
  }

  /**
   * Creates a new collection-denoting reifiable binary function term.
   * 
   * @@param binaryFunction the new collection
   * @@param comment the comment for the binary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1IsaName the collection of which the new binary function is an instance
   * @@param arg2GenlsName the kind of objects this binary function takes as its first argument, or
   *        null
   * @@param arg2IsaName the kind of objects this binary function takes as its second argument, or
   *        null
   * @@param arg1GenlsName the general collections this binary function takes as its first argument,
   *        or null
   * @@param resultIsa the kind of object represented by this reified term
   * 
   * @@return the new collection-denoting reifiable binary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollectionDenotingBinaryFunction(String binaryFunction, 
                                                        String comment, 
                                                        String commentMt, 
                                                        String arg1IsaName, 
                                                        String arg2IsaName, 
                                                        String arg1GenlsName, 
                                                        String arg2GenlsName, 
                                                        String resultIsa)
                                                 throws IOException, CycApiException {
    CycFort arg1Isa = null;
    CycFort arg2Isa = null;
    CycFort arg1Genls = null;
    CycFort arg2Genls = null;

    if (arg1IsaName != null) {
      arg1Isa = getKnownConstantByName(arg1IsaName);
    }

    if (arg2IsaName != null) {
      arg1Isa = getKnownConstantByName(arg2IsaName);
    }

    if (arg1GenlsName != null) {
      arg1Genls = getKnownConstantByName(arg1GenlsName);
    }

    if (arg2GenlsName != null) {
      arg2Genls = getKnownConstantByName(arg2GenlsName);
    }

    return createCollectionDenotingBinaryFunction(findOrCreate(
                                                        binaryFunction), 
                                                  comment, 
                                                  getKnownConstantByName(
                                                        commentMt), 
                                                  arg1Isa, 
                                                  arg2Isa, 
                                                  arg1Genls, 
                                                  arg2Genls, 
                                                  getKnownConstantByName(
                                                        resultIsa));
  }

  /**
   * Creates a new collection-denoting reifiable binary function term.
   * 
   * @@param binaryFunction the new collection
   * @@param comment the comment for the binary function
   * @@param commentMt the microtheory in which the comment is asserted
   * @@param arg1Isa the kind of objects this binary function takes as its first argument, or null
   * @@param arg2Isa the kind of objects this binary function takes as its first argument, or null
   * @@param arg1Genls the general collections this binary function takes as its first argument, or
   *        null
   * @@param arg2Genls the general collections this binary function takes as its second argument, or
   *        null
   * @@param resultIsa the kind of object represented by this reified term
   * 
   * @@return the new collection-denoting reifiable binary function term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycFort createCollectionDenotingBinaryFunction(CycFort binaryFunction, 
                                                        String comment, 
                                                        CycFort commentMt, 
                                                        CycFort arg1Isa, 
                                                        CycFort arg2Isa, 
                                                        CycFort arg1Genls, 
                                                        CycFort arg2Genls, 
                                                        CycFort resultIsa)
                                                 throws IOException, CycApiException {
    assertComment(binaryFunction, 
                  comment, 
                  commentMt);


    // (#$isa binaryFunction #$BinaryFunction)
    assertIsa(binaryFunction, 
              getKnownConstantByGuid("c0e7247c-9c29-11b1-9dad-c379636f7270"));


    // (#$isa binaryFunction #$ReifiableFunction)
    assertIsa(binaryFunction, 
              getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));


    // (#$isa binaryFunction #$CollectionDenotingFunction)
    assertIsa(binaryFunction, 
              getKnownConstantByGuid("bd58806a-9c29-11b1-9dad-c379636f7270"));


    // (#$isa binaryFunction #$Function-Denotational)
    assertIsa(binaryFunction, 
              getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));

    if (arg1Isa != null) {
      assertArgIsa(binaryFunction, 
                   1, 
                   arg1Isa);
    }

    if (arg2Isa != null) {
      assertArgIsa(binaryFunction, 
                   2, 
                   arg2Isa);
    }

    if (arg1Genls != null) {
      assertArg1Genl(binaryFunction, 
                     arg1Genls);
    }

    if (arg2Genls != null) {
      assertArg2Genl(binaryFunction, 
                     arg2Genls);
    }

    assertResultIsa(binaryFunction, 
                    resultIsa);

    return binaryFunction;
  }

  /**
   * Assert an argument isa contraint for the given relation and argument position. The operation
   * will be added to the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * @@param argPosition the given argument position
   * @@param argNIsa the argument constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArgIsa(CycFort relation, 
                           int argPosition, 
                           CycFort argNIsa)
                    throws IOException, UnknownHostException, CycApiException {
    // (#$argIsa relation argPosition argNIsa)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("bee22d3d-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(new Integer(argPosition));
    sentence.add(argNIsa);
    assertGaf(sentence, 
              universalVocabularyMt);
  }

  /**
   * Assert an argument one genls contraint for the given relation. The operation will be added to
   * the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * @@param argGenl the argument constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArg1Genl(CycFort relation, 
                             CycFort argGenl)
                      throws IOException, UnknownHostException, CycApiException {
    // (#$arg1Genl relation argGenl)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("bd588b1d-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(argGenl);
    assertGaf(sentence, 
              universalVocabularyMt);
  }

  /**
   * Assert an argument two genls contraint for the given relation. The operation will be added to
   * the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * @@param argGenl the argument constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArg2Genl(CycFort relation, 
                             CycFort argGenl)
                      throws IOException, UnknownHostException, CycApiException {
    // (#$arg2Genl relation argGenl)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("bd58dcda-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(argGenl);
    assertGaf(sentence, 
              universalVocabularyMt);
  }

  /**
   * Assert an argument three genls contraint for the given relation. The operation will be added
   * to the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * @@param argGenl the argument constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArg3Genl(CycFort relation, 
                             CycFort argGenl)
                      throws IOException, UnknownHostException, CycApiException {
    // (#$arg3Genl relation argGenl)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("bd58b8c3-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(argGenl);
    assertGaf(sentence, 
              universalVocabularyMt);
  }

  /**
   * Assert the isa result contraint for the given denotational function. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param denotationalFunction the given denotational function
   * @@param resultIsa the function's isa result constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertResultIsa(CycFort denotationalFunction, 
                              CycFort resultIsa)
                       throws IOException, UnknownHostException, CycApiException {
    // (#$resultIsa denotationalFunction resultIsa)
    assertGaf(universalVocabularyMt, 
              getKnownConstantByGuid("bd5880f1-9c29-11b1-9dad-c379636f7270"), 
              denotationalFunction, 
              resultIsa);
  }

  /**
   * Assert the genls result contraint for the given denotational function. The operation will be
   * added to the KB transcript for replication and archive.
   * 
   * @@param denotationalFunction the given denotational function
   * @@param resultGenl the function's genls result constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertResultGenl(CycFort denotationalFunction, 
                               CycFort resultGenl)
                        throws IOException, UnknownHostException, CycApiException {
    // (#$resultGenl denotationalFunction resultGenls)
    assertGaf(universalVocabularyMt, 
              getKnownConstantByGuid("bd58d6ab-9c29-11b1-9dad-c379636f7270"), 
              denotationalFunction, 
              resultGenl);
  }

  /**
   * Returns true if this KB is OpenCyc.
   * 
   * @@return true if this KB is OpenCyc, otherwise false
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   */
  public boolean isOpenCyc()
                    throws IOException, UnknownHostException {
    boolean answer;

    try {
      answer = converseBoolean("(cyc-opencyc-feature)");
    }
     catch (CycApiException e) {
      answer = false;
    }

    return answer;
  }

  /**
   * Returns a constant whose name differs from the given name only by case. Used because Cyc by
   * default requires constant names to be unique by case.
   * 
   * @@param name the name used to lookup an existing constant
   * 
   * @@return a constant whose name differs from the given name only by case, otherwise null if none
   *         exists
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycConstant constantNameCaseCollision(String name)
                                        throws IOException, UnknownHostException, CycApiException {
    Object object = converseObject("(constant-name-case-collision \"" + name + "\")");

    if (object instanceof CycConstant) {
      return (CycConstant) object;
    }
    else {
      return null;
    }
  }

  /**
   * Returns the list of applicable binary predicates which are elements of any of the given list
   * of KBSubsetCollections.
   * 
   * @@param kbSubsetCollections the list of KBSubsetCollections
   * 
   * @@return the list of applicable binary predicates which are elements of any of the given list
   *         of KBSubsetCollections
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getApplicableBinaryPredicates(CycList kbSubsetCollections)
                                        throws IOException, UnknownHostException, CycApiException {
    CycList result = new CycList();

    for (int i = 0; i < kbSubsetCollections.size(); i++) {
      CycFort kbSubsetCollection = (CycFort) kbSubsetCollections.get(
                                         i);
      String query = "(#$and \n" + "  (#$isa ?binary-predicate " + kbSubsetCollection.stringApiValue() + 
                     ") \n" + "  (#$isa ?binary-predicate #$BinaryPredicate))";
      result.addAllNew(askWithVariable(makeCycList(query), 
                                       CycObjectFactory.makeCycVariable("?binary-predicate"), 
                                       inferencePSC));
    }

    return result;
  }

  /**
   * Returns the list of gafs in which the predicate is a element of the given list of predicates
   * and in which the given term appears in the first argument position.
   * 
   * @@param cycFort the given term
   * @@param predicates the given list of predicates
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of gafs in which the predicate is a element of the given list of predicates
   *         and in which the given term appears in the first argument position
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getGafs(CycFort cycFort, 
                         CycList predicates, 
                         CycObject mt)
                  throws IOException, UnknownHostException, CycApiException {
    CycList result = new CycList();

    for (int i = 0; i < predicates.size(); i++) {
      result.addAllNew(getGafs(cycFort, 
                               (CycFort) predicates.get(
                                     i), 
                               makeELMt(mt)));
    }

    return result;
  }

  /**
   * Returns the list of gafs in which the predicate is the given predicate and in which the given
   * term appears in the first argument position.
   * 
   * @@param cycFort the given term
   * @@param predicate the given predicate
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of gafs in which the predicate is a element of the given list of predicates
   *         and in which the given term appears in the first argument position
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getGafs(CycFort cycFort, 
                         CycFort predicate, 
                         CycObject mt)
                  throws IOException, UnknownHostException, CycApiException {
    CycList gafs = new CycList();
    String command = "(with-mt " + makeELMt(mt).stringApiValue() + "\n" + 
                     "  (pred-values-in-relevant-mts " + cycFort.stringApiValue() + " " + 
                     predicate.stringApiValue() + "))";
    CycList values = converseList(command);

    for (int i = 0; i < values.size(); i++) {
      CycList gaf = new CycList();
      gaf.add(predicate);
      gaf.add(cycFort);
      gaf.add(values.get(i));
      gafs.add(gaf);
    }

    return gafs;
  }

  /**
   * Returns the list of gafs in which the predicate is a element of the given list of predicates
   * and in which the given term appears in the first argument position.
   * 
   * @@param cycObject the given term
   * @@param predicates the given list of predicates
   * 
   * @@return the list of gafs in which the predicate is a element of the given list of predicates
   *         and in which the given term appears in the first argument position
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getGafs(CycObject cycObject, 
                         CycList predicates)
                  throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
            
    CycList result = new CycList();
    for (int i = 0; i < predicates.size(); i++) {
      result.addAllNew(getGafs(cycObject, (CycObject) predicates.get(i)));
    }

    return result;
  }

  /**
   * Returns the list of gafs in which the predicate is the given predicate and in which the given
   * term appears in the first argument position.
   * 
   * @@param cycObject the given term
   * @@param predicate the given predicate
   * 
   * @@return the list of gafs in which the predicate is a element of the given list of predicates
   *         and in which the given term appears in the first argument position
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getGafs(CycObject cycObject, 
                         CycObject predicate)
                  throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList : cycObject.cyclify() + " must be a CycConstant, CycNart or CycList";
    if (cycObject instanceof CycList)
      return getGafsForNaut((CycList) cycObject, predicate);
    CycList gafs = new CycList();
    String command = "(with-all-mts \n" + "  (pred-values-in-relevant-mts (canonicalize-term " + 
                     cycObject.stringApiValue() + ") " + "(canonicalize-term " + 
                     predicate.stringApiValue() + ")))";
    CycList values = converseList(command);

    for (int i = 0; i < values.size(); i++) {
      CycList gaf = new CycList();
      gaf.add(predicate);
      gaf.add(cycObject);
      gaf.add(values.get(i));
      gafs.add(gaf);
    }

    return gafs;
  }

  /**
   * Returns the list of gafs in which the predicate is the given predicate and in which the given
   * term appears in the first argument position.
   * 
   * @@param cycObject the given term
   * @@param predicate the given predicate
   * 
   * @@return the list of gafs in which the predicate is a element of the given list of predicates
   *         and in which the given term appears in the first argument position
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getGafsForNaut(CycList naut, 
                         CycObject predicate)
                  throws IOException, UnknownHostException, CycApiException {
    final String command = 
      "(clet (assertions) " +
      "  (do-gaf-arg-index-naut (assertion " + naut.stringApiValue() + ")" +
      "    (pwhen (equal (formula-arg1 assertion) " + predicate.stringApiValue() + ")" +
      "      (cpush assertion assertions))) " +
      "  assertions)";
    final CycList gafs = converseList(command);

    //// Postconditions
    assert gafs != null : "gafs cannot be null";
    
    return gafs;
  }

  /**
   * Returns the list of tuples gathered from assertions in given microtheory in which the
   * predicate is the given predicate, in which the given term appears in the indexArg position
   * and in which the list of gatherArgs determines the assertion arguments returned as each
   * tuple.
   * 
   * @@param term the term in the index argument position
   * @@param predicate the given predicate
   * @@param indexArg the argument position in which the given term appears
   * @@param gatherArgs the list of argument Integer positions which indicate the assertion
   *        arguments to be returned as each tuple
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of tuples gathered from assertions in given microtheory in which the
   *         predicate is the given predicate, in which the given term appears in the indexArg
   *         position and in which the list of gatherArgs determines the assertion arguments
   *         returned as each tuple
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getPredicateValueTuplesInMt(CycFort term, 
                                             CycFort predicate, 
                                             int indexArg, 
                                             CycList gatherArgs, 
                                             CycObject mt)
                                      throws IOException, UnknownHostException, CycApiException {
    CycList tuples = new CycList();
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("pred-value-tuples-in-mt"));
    command.add(term);
    command.add(predicate);
    command.add(new Integer(indexArg));
    command.addQuoted(gatherArgs);
    command.add(makeELMt(mt));

    return converseList(command);
  }

  /**
   * Assert an argument contraint for the given relation and argument position. The operation will
   * be added to the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArg1FormatSingleEntry(CycFort relation)
                                   throws IOException, UnknownHostException, CycApiException {
    // (#$arg1Format relation SingleEntry)
    assertArgFormat(relation, 
                    1, 
                    getKnownConstantByGuid("bd5880eb-9c29-11b1-9dad-c379636f7270"));
  }

  /**
   * Assert an argument format contraint for the given relation and argument position. The
   * operation will be added to the KB transcript for replication and archive.
   * 
   * @@param relation the given relation
   * @@param argPosition the given argument position
   * @@param argNFormat the argument format constraint
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public void assertArgFormat(CycFort relation, 
                              int argPosition, 
                              CycFort argNFormat)
                       throws IOException, UnknownHostException, CycApiException {
    // (#$argFormat relation argPosition argNFormat)
    CycList sentence = new CycList();
    sentence.add(getKnownConstantByGuid("bd8a36e1-9c29-11b1-9dad-c379636f7270"));
    sentence.add(relation);
    sentence.add(new Integer(argPosition));
    sentence.add(argNFormat);
    assertGaf(sentence, 
              baseKB);
  }

  /**
   * Asserts that the given DAML imported term is mapped to the given Cyc term.
   * 
   * @@param cycTerm the mapped Cyc term
   * @@param informationSource the external indexed information source
   * @@param externalConcept the external concept within the information source
   * @@param mt the assertion microtheory
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertSynonymousExternalConcept(String cycTerm, 
                                              String informationSource, 
                                              String externalConcept, 
                                              String mt)
                                       throws IOException, UnknownHostException, CycApiException {
    assertSynonymousExternalConcept(getKnownConstantByName(
                                          cycTerm), 
                                    getKnownConstantByName(
                                          informationSource), 
                                    externalConcept, 
                                    getKnownConstantByName(
                                          mt));
  }

  /**
   * Asserts that the given DAML imported term is mapped to the given Cyc term.
   * 
   * @@param cycTerm the mapped Cyc term
   * @@param informationSource the external indexed information source
   * @@param externalConcept the external concept within the information source
   * @@param mt the assertion microtheory
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertSynonymousExternalConcept(CycFort cycTerm, 
                                              CycFort informationSource, 
                                              String externalConcept, 
                                              CycObject mt)
                                       throws IOException, UnknownHostException, CycApiException {
    CycList gaf = new CycList();


    // #$synonymousExternalConcept
    gaf.add(getKnownConstantByGuid("c0e2af4e-9c29-11b1-9dad-c379636f7270"));
    gaf.add(cycTerm);
    gaf.add(informationSource);
    gaf.add(externalConcept);
    assertGaf(gaf, 
              makeELMt(mt));
  }

  /**
   * Gets the list of mappings from the specified information source given the inference
   * microtheory.  Each returned list item is the pair consisting of external concept string and
   * synonymous Cyc term.
   * 
   * @@param informationSource the external indexed information source
   * @@param mt the assertion microtheory
   * 
   * @@return list of mappings from the specified information source given the inference
   * microtheory
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getSynonymousExternalConcepts(String informationSource, 
                                               String mt)
                                        throws IOException, UnknownHostException, CycApiException {
    return getSynonymousExternalConcepts(getKnownConstantByName(
                                               informationSource), 
                                         getKnownConstantByName(
                                               mt));
  }

  /**
   * Gets the list of mappings from the specified information source given the inference
   * microtheory.  Each returned list item is the pair consisting of external concept string and
   * synonymous Cyc term.
   * 
   * @@param informationSource the external indexed information source
   * @@param mt the assertion microtheory
   * 
   * @@return the list of mappings from the specified information source given the inference
   * microtheory
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getSynonymousExternalConcepts(CycFort informationSource, 
                                               CycObject mt)
                                        throws IOException, UnknownHostException, CycApiException {
    CycList variables = new CycList();
    CycVariable cycTermVar = CycObjectFactory.makeCycVariable(
                                   "?cyc-term");
    variables.add(cycTermVar);

    CycVariable externalConceptVar = CycObjectFactory.makeCycVariable(
                                           "?externalConcept");
    variables.add(externalConceptVar);

    CycList query = new CycList();


    // #$synonymousExternalConcept
    query.add(getKnownConstantByGuid("c0e2af4e-9c29-11b1-9dad-c379636f7270"));
    query.add(cycTermVar);
    query.add(informationSource);
    query.add(externalConceptVar);

    return askWithVariables(query, 
                            variables, 
                            makeELMt(mt));
  }

  /**
   * Asserts a preferred name string for the given term using lexical singular count noun
   * assumptions.
   * 
   * @@param cycTerm the Cyc term
   * @@param phrase the preferred phrase for this term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertGenPhraseCountNounSingular(CycFort cycTerm, 
                                               String phrase)
                                        throws IOException, UnknownHostException, CycApiException {
    CycList gaf = new CycList();


    // (#$genPhrase <term> #$CountNoun #$singular <phrase>) in
    // #$EnglishParaphaseMt
    gaf.add(getKnownConstantByGuid("bd5fb28e-9c29-11b1-9dad-c379636f7270"));
    gaf.add(cycTerm);
    gaf.add(getKnownConstantByGuid("bd588078-9c29-11b1-9dad-c379636f7270"));
    gaf.add(getKnownConstantByGuid("bd6757b8-9c29-11b1-9dad-c379636f7270"));
    gaf.add(phrase);

    ELMt elmt = makeELMt(getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270"));
    assertGaf(gaf, 
              elmt);
  }

  /**
   * Asserts a preferred name string for the given term using lexical singular count noun
   * assumptions.
   * 
   * @@param cycTerm the Cyc term
   * @@param phrase the preferred phrase for this term
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void assertGenPhraseCountNounPlural(CycFort cycTerm, 
                                             String phrase)
                                      throws IOException, UnknownHostException, CycApiException {
    CycList gaf = new CycList();


    // (#$genPhrase <term> #$CountNoun #$plural <phrase>) in
    // #$EnglishParaphaseMt
    gaf.add(getKnownConstantByGuid("bd5fb28e-9c29-11b1-9dad-c379636f7270"));
    gaf.add(cycTerm);
    gaf.add(getKnownConstantByGuid("bd588078-9c29-11b1-9dad-c379636f7270"));
    gaf.add(getKnownConstantByGuid("bd5a6853-9c29-11b1-9dad-c379636f7270"));
    gaf.add(phrase);

    ELMt elmt = makeELMt(getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270"));
    assertGaf(gaf, 
              elmt);
  }

  /**
   * Gets the list of name strings for the given CycFort.
   * 
   * @@param cycFort the given FORT
   * @@param mt the relevant inference microtheory
   * 
   * @@return the list of name strings for the given CycFort
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getNameStrings(CycFort cycFort, 
                                CycObject mt)
                         throws IOException, UnknownHostException, CycApiException {
    // (#$nameString <cycFort> ?name-string)
    CycList query = new CycList();
    query.add(getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"));
    query.add(cycFort);

    CycVariable variable = CycObjectFactory.makeCycVariable(
                                 "?name-string");
    query.add(variable);

    return askWithVariable(query, 
                           variable, 
                           makeELMt(mt));
  }

  /**
   * Ensures that the given term meets the given isa and genl wff constraints in the
   * UniversalVocabularyMt.
   * 
   * @@param cycFort the given term
   * @@param isaConstraintName the given isa type constraint, or null
   * @@param genlsConstraintName the given genls type constraint, or null
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void ensureWffConstraints(String cycFort, 
                                   String isaConstraintName, 
                                   String genlsConstraintName)
                            throws IOException, UnknownHostException, CycApiException {
    CycConstant cycConstant = find(cycFort);
    CycConstant isaConstraint = null;
    CycConstant genlsConstraint = null;

    if (isaConstraintName != null) {
      isaConstraint = find(isaConstraintName);
    }

    if (genlsConstraintName != null) {
      genlsConstraint = find(genlsConstraintName);
    }

    ensureWffConstraints(cycConstant, 
                         isaConstraint, 
                         genlsConstraint);
  }

  /**
   * Ensures that the given term meets the given isa and genl wff constraints in the
   * UniversalVocabularyMt.
   * 
   * @@param cycFort the given term
   * @@param isaConstraint the given isa type constraint, or null
   * @@param genlsConstraint the given genls type constraint, or null
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void ensureWffConstraints(CycFort cycFort, 
                                   CycFort isaConstraint, 
                                   CycFort genlsConstraint)
                            throws IOException, UnknownHostException, CycApiException {
    if ((isaConstraint != null) && 
            (!isa(cycFort, 
                  isaConstraint, 
                  universalVocabularyMt))) {
      assertIsa(cycFort, 
                isaConstraint);
    }

    if ((genlsConstraint != null) && 
            (!isSpecOf(cycFort, 
                       genlsConstraint, 
                       universalVocabularyMt))) {
      assertGenls(cycFort, 
                  genlsConstraint);
    }
  }

  /**
   * Returns the list of arg2 terms from binary gafs having the specified predicate and arg1
   * values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the list of arg2 terms from gafs having the specified predicate and arg1 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getArg2s(String predicate, 
                          String arg1, 
                          String mt)
                   throws IOException, UnknownHostException, CycApiException {
    return getArg2s(getKnownConstantByName(predicate), 
                    getKnownConstantByName(arg1), 
                    getKnownConstantByName(mt));
  }

  /**
   * Returns the list of arg2 terms from binary gafs having the specified predicate and arg1
   * values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the list of arg2 terms from gafs having the specified predicate and arg1 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getArg2s(String predicate, 
                          CycFort arg1, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return getArg2s(getKnownConstantByName(predicate), 
                    arg1, 
                    makeELMt(mt));
  }

  /**
   * Returns the list of arg2 terms from binary gafs having the specified predicate and arg1
   * values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the list of arg2 terms from gafs having the specified predicate and arg1 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getArg2s(CycFort predicate, 
                          CycFort arg1, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(predicate);
    query.add(arg1);

    CycVariable variable = CycObjectFactory.makeCycVariable(
                                 "?arg2");
    query.add(variable);

    return askWithVariable(query, 
                           variable, 
                           makeELMt(mt));
  }

  /**
   * Returns the first arg2 term from binary gafs having the specified predicate and arg1 values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg2 term from gafs having the specified predicate and arg1 values or null
   *         if none
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getArg2(String predicate, 
                        String arg1, 
                        String mt)
                 throws IOException, UnknownHostException, CycApiException {
    return getArg2(getKnownConstantByName(predicate), 
                   getKnownConstantByName(arg1), 
                   getKnownConstantByName(mt));
  }

  /**
   * Returns the first arg2 term from binary gafs having the specified predicate and arg1 values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg2 term from gafs having the specified predicate and arg1 values or null
   *         if none
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getArg2(String predicate, 
                        CycFort arg1, 
                        CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    return getArg2(getKnownConstantByName(predicate), 
                   arg1, 
                   makeELMt(mt));
  }

  /**
   * Returns the first arg2 term from binary gafs having the specified predicate and arg1 values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg2 term from gafs having the specified predicate and arg1 values or null
   *         if none
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getArg2(CycFort predicate, 
                        CycFort arg1, 
                        CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(predicate);
    query.add(arg1);

    CycVariable variable = CycObjectFactory.makeCycVariable(
                                 "?arg2");
    query.add(variable);

    CycList answer = askWithVariable(query, 
                                     variable, 
                                     makeELMt(mt));

    if (answer.size() > 0) {
      return answer.get(0);
    }
    else {
      return null;
    }
  }

  /**
   * Returns the first arg2 ground or non-term from assertions having the specified predicate and
   * arg1 values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg2 ground or non-term from assertions having the specified predicate and
   *         arg1 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getAssertionArg2(String predicate, 
                                 String arg1, 
                                 String mt)
                          throws IOException, UnknownHostException, CycApiException {
    return getAssertionArg2(getKnownConstantByName(predicate), 
                            getKnownConstantByName(arg1), 
                            getKnownConstantByName(mt));
  }

  /**
   * Returns the first arg2 ground or non-term from assertions having the specified predicate and
   * arg1 values.
   * 
   * @@param predicate the given predicate
   * @@param arg1 the given arg1 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg2 ground or non-term from assertions having the specified predicate and
   *         arg1 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getAssertionArg2(CycFort predicate, 
                                 CycFort arg1, 
                                 CycObject mt)
                          throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("fpred-value-in-mt"));
    command.add(arg1);
    command.add(predicate);
    command.add(makeELMt(mt));

    return this.converseObject(command);
  }

  /**
   * Returns the first arg1 term from gafs having the specified predicate and arg2 values.
   * 
   * @@param predicate the given predicate
   * @@param arg2 the given arg2 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg1 term from gafs having the specified predicate and arg2 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getArg1(String predicate, 
                        String arg2, 
                        String mt)
                 throws IOException, UnknownHostException, CycApiException {
    return getArg1(getKnownConstantByName(predicate), 
                   getKnownConstantByName(arg2), 
                   getKnownConstantByName(mt));
  }

  /**
   * Returns the first arg1 term from gafs having the specified predicate and arg2 values.
   * 
   * @@param predicate the given predicate
   * @@param arg2 the given arg2 term
   * @@param mt the inference microtheory
   * 
   * @@return the first arg1 term from gafs having the specified predicate and arg2 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getArg1(CycFort predicate, 
                        CycFort arg2, 
                        CycObject mt)
                 throws IOException, UnknownHostException, CycApiException {
    CycList answer = getArg1s(predicate, 
                              arg2, 
                              makeELMt(mt));

    if (answer.size() > 0) {
      return answer.get(0);
    }
    else {
      return null;
    }
  }

  /**
   * Returns the list of arg1 terms from gafs having the specified predicate and arg2 values.
   * 
   * @@param predicate the given predicate
   * @@param arg2 the given arg2 term
   * @@param mt the inference microtheory
   * 
   * @@return the list of arg1 terms from gafs having the specified predicate and arg2 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getArg1s(String predicate, 
                          String arg2, 
                          String mt)
                   throws IOException, UnknownHostException, CycApiException {
    return getArg1s(getKnownConstantByName(predicate), 
                    getKnownConstantByName(arg2), 
                    getKnownConstantByName(mt));
  }

  /**
   * Returns the list of arg1 terms from gafs having the specified predicate and arg2 values.
   * 
   * @@param predicate the given predicate
   * @@param arg2 the given arg2 term
   * @@param mt the inference microtheory
   * 
   * @@return the list of arg1 terms from gafs having the specified predicate and arg2 values
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getArg1s(CycFort predicate, 
                          CycFort arg2, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(predicate);

    CycVariable variable = CycObjectFactory.makeCycVariable(
                                 "?arg1");
    query.add(variable);
    query.add(arg2);

    return askWithVariable(query, 
                           variable, 
                           makeELMt(mt));
  }

  /**
   * Returns the Cyc image ID.
   * 
   * @@return the Cyc image ID string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public String getCycImageID()
                       throws IOException, UnknownHostException, CycApiException {
    CycList query = new CycList();
    query.add(CycObjectFactory.makeCycSymbol("cyc-image-id"));

    return converseString(query);
  }

  /**
   * Returns the list of assertions contained in the given mt.
   * 
   * @@param mt the given microtheory
   * 
   * @@return the list of assertions contained in the given mt
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getAllAssertionsInMt(CycObject mt)
                               throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("gather-mt-index"));
    command.add(makeELMt(mt));

    return converseList(command);
  }

  /**
   * Unasserts all assertions from the given mt, with a transcript record of the unassert
   * operation.
   * 
   * @@param mt the microtheory from which to delete all its assertions
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void unassertMtContentsWithTranscript(CycObject mt)
                                        throws IOException, UnknownHostException, CycApiException {
    CycList assertions = getAllAssertionsInMt(mt);
    Iterator iter = assertions.iterator();

    while (iter.hasNext()) {
      CycAssertion assertion = (CycAssertion) iter.next();
      String command = wrapBookkeeping("(ke-unassert-now " + assertion.stringApiValue() + 
                                       makeELMt(mt).stringApiValue() + ")");
      converseVoid(command);
    }
  }

  /**
   * Unasserts all assertions from the given mt, without a transcript record of the unassert
   * operation.
   * 
   * @@param mt the microtheory from which to delete all its assertions
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void unassertMtContentsWithoutTranscript(CycObject mt)
                                           throws IOException, UnknownHostException, 
                                                  CycApiException {
    CycList assertions = getAllAssertionsInMt(mt);
    Iterator iter = assertions.iterator();

    while (iter.hasNext()) {
      CycAssertion assertion = (CycAssertion) iter.next();
      String command = "(cyc-unassert " + assertion.stringApiValue() + 
                       makeELMt(mt).stringApiValue() + "))";
      converseVoid(command);
    }
  }

  /**
   * Unasserts all assertions from the given mt having the given predicate and arg1, without a
   * transcript record of the unassert operation.
   * 
   * @@param predicate the given predicate or null to match all predicates
   * @@param arg1 the given arg1
   * @@param mt the microtheory from which to delete the matched assertions
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public void unassertMatchingAssertionsWithoutTranscript(CycFort predicate, 
                                                          Object arg1, 
                                                          CycObject mt)
                                                   throws IOException, UnknownHostException, 
                                                          CycApiException {
    CycList assertions = getAllAssertionsInMt(mt);
    Iterator iter = assertions.iterator();

    while (iter.hasNext()) {
      CycAssertion assertion = (CycAssertion) iter.next();
      CycList sentence = assertion.getFormula();

      if (sentence.size() < 2) {
        continue;
      }

      if (!(arg1.equals(sentence.second()))) {
        continue;
      }

      if ((predicate != null) && (!(predicate.equals(sentence.first())))) {
        continue;
      }

      String command = "(cyc-unassert " + assertion.stringApiValue() + 
                       makeELMt(mt).stringApiValue() + "))";
      converseVoid(command);
    }
  }

  /**
   * Returns the list of Cyc terms whose denotation matches the given English string.
   * 
   * @@param denotationString the given English denotation string
   * 
   * @@return the list of Cyc terms whose denotation matches the given English string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getDenotsOfString(String denotationString)
                            throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("denots-of-string"));
    command.add(denotationString);

    return converseList(command);
  }

  /**
   * Returns the list of Cyc terms whose denotation matches the given English string and which are
   * instances of any of the given collections.
   * 
   * @@param denotationString the given English denotation string
   * @@param collections the given list of collections
   * 
   * @@return the list of Cyc terms whose denotation matches the given English string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getDenotsOfString(String denotationString, 
                                   CycList collections)
                            throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("denots-of-string"));
    command.add(denotationString);

    CycList terms = converseList(command);
    CycList result = new CycList();
    Iterator collectionsIterator = collections.iterator();

    while (collectionsIterator.hasNext()) {
      CycFort collection = (CycFort) collectionsIterator.next();
      Iterator termsIter = terms.iterator();

      while (termsIter.hasNext()) {
        CycFort term = (CycFort) termsIter.next();

        if (this.isa(term, 
                     collection)) {
          result.add(term);
        }
      }
    }

    return result;
  }

  /**
   * Returns the list of Cyc terms whose denotation matches the given English multi-word string.
   * 
   * @@param multiWordDenotationString the given English denotation multi-word string
   * 
   * @@return the list of Cyc terms whose denotation matches the given English multi-word string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getMWSDenotsOfString(CycList multiWordDenotationString)
                               throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("mws-denots-of-string"));
    command.addQuoted(multiWordDenotationString);

    return converseList(command);
  }

  /**
   * Returns the list of Cyc terms whose denotation matches the given English multi-word string and
   * which are instances of any of the given collections.
   * 
   * @@param multiWordDenotationString the given English denotation string
   * @@param collections the given list of collections
   * 
   * @@return the list of Cyc terms whose denotation matches the given English multi-word string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList getMWSDenotsOfString(CycList multiWordDenotationString, 
                                      CycList collections)
                               throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("mws-denots-of-string"));
    command.addQuoted(multiWordDenotationString);

    CycList terms = converseList(command);
    CycList result = new CycList();
    Iterator collectionsIterator = collections.iterator();

    while (collectionsIterator.hasNext()) {
      CycFort collection = (CycFort) collectionsIterator.next();
      Iterator termsIter = terms.iterator();

      while (termsIter.hasNext()) {
        CycFort term = (CycFort) termsIter.next();

        if (this.isa(term, 
                     collection)) {
          result.add(term);
        }
      }
    }

    return result;
  }

  /**
   * Returns true if the given symbol is defined as an api function.
   * 
   * @@param symbolName the candidate api function symbol name
   * 
   * @@return true if the given symbol is defined as an api function
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isFunctionBound(String symbolName)
                          throws IOException, UnknownHostException, CycApiException {
    CycSymbol cycSymbol = CycObjectFactory.makeCycSymbol(
                                symbolName);

    return isFunctionBound(cycSymbol);
  }

  /**
   * Returns true if the given symbol is defined as an api function.
   * 
   * @@param cycSymbol the candidate api function symbol
   * 
   * @@return rue if the given symbol is defined as an api function
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isFunctionBound(CycSymbol cycSymbol)
                          throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("boolean"));

    CycList command1 = new CycList();
    command1.add(CycObjectFactory.makeCycSymbol("fboundp"));
    command1.addQuoted(cycSymbol);
    command.add(command1);

    return converseBoolean(command);
  }

  /**
   * Returns the Heuristic Level (HL) object represented by the given string.
   * 
   * @@param string the string which represents a number, quoted string, constant, naut or nart
   * 
   * @@return the Heuristic Level (HL) object represented by the given string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getHLCycTerm(String string)
                      throws IOException, UnknownHostException, CycApiException {
    return converseObject("(canonicalize-term '" + string + ")");
  }

  /**
   * Returns the Epistimological Level (EL) object represented by the given string.
   * 
   * @@param string the string which represents a number, quoted string, constant, naut or nart
   * 
   * @@return the Epistimological Level (EL)object represented by the given string
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public Object getELCycTerm(String string)
                      throws IOException, UnknownHostException, CycApiException {
    return converseObject("(identity '" + string + ")");
  }

  /**
   * Returns a random constant.
   * 
   * @@return a random constant
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycConstant getRandomConstant()
                                throws IOException, UnknownHostException, CycApiException {
    return (CycConstant) converseObject("(random-constant)");
  }

  /**
   * Returns a random nart (Non-Atomic Reified Term).
   * 
   * @@return a random nart (Non-Atomic Reified Term)
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycNart getRandomNart()
                        throws IOException, UnknownHostException, CycApiException {
    return (CycNart) converseObject("(random-nart)");
  }

  /**
   * Returns a random assertion.
   * 
   * @@return a random assertion
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycAssertion getRandomAssertion()
                        throws IOException, UnknownHostException, CycApiException {
    return (CycAssertion) converseObject("(random-assertion)");
  }

  /**
   * Returns the given list with EL NARTS transformed to CycNart objects.
   * 
   * @@param cycList the given list
   * 
   * @@return the given list with EL NARTS transformed to CycNart objects
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList canonicalizeList(CycList cycList)
                           throws IOException, UnknownHostException, CycApiException {
    CycList canonicalList = new CycList();
    Iterator iter = cycList.iterator();

    while (iter.hasNext()) {
      Object obj = iter.next();

      if (obj instanceof CycList)
        canonicalList.add(getHLCycTerm(((CycList) obj).cyclify()));
      else if (obj instanceof CycNart)
        canonicalList.add(getHLCycTerm(((CycNart) obj).cyclify()));
      else
        canonicalList.add(obj);
    }

    return canonicalList;
  }
  
  /**
   * Gets the assertion date for the given assertion, or zero if the date is not available.
   *
   * @@return the assertion date for the given assertion
   */
  public Long getAssertionDate(CycAssertion cycAssertion)
                        throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("asserted-when"));
    command.addQuoted(cycAssertion);
    Object date = converseObject(command);
    if (date instanceof Integer)
      return new Long(((Integer) date).longValue());
    if (date instanceof Long)
      return (Long) date;
    if (date.equals(CycObjectFactory.nil))
      return new Long(0);
    else
      throw new CycApiException("unexpected type of date returned " + date.toString());
  }
  
  /**
   * Returns true if the given HL formula and microtheory correspond to a valid
   * assertion in that microtheory.
   * 
   * @@param hlFormula the given HL formula
   * @@param mt the candidate assertion microtheory
   */
  public boolean isAssertionValid(CycList hlFormula, CycFort mt) 
                        throws IOException, UnknownHostException, CycApiException {
    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("find-assertion"));
    command.addQuoted(hlFormula);
    command.add(mt);
    Object response = converseObject(command);
    return ! response.equals(CycObjectFactory.nil);
  }
  
  /** Asserts that the given term is dependent upon the given independent term.  If the latter is
   * killed, then the truth maintenance kills the dependent term.
   *
   * @@param dependentTerm the dependent term
   * @@param independentTerm the independent term
   * @@param mt the assertion microtheory
   */
  public void assertTermDependsOn(final CycFort dependentTerm, final CycFort independentTerm, final CycFort mt)  throws IOException, CycApiException {
    // assert (#$termDependsOn <dependentTerm> <independentTerm>) in #$UniversalVocabularyMt
    assertGaf(mt, getKnownConstantByGuid("bdf02d74-9c29-11b1-9dad-c379636f7270"), dependentTerm, independentTerm);
  }
  
  /** Asserts that the given term is defined in the given mt.  If the mt is
   * subsequently killed, then the truth maintenance kills the dependent term.
   *
   * @@param dependentTerm the dependent term
   * @@param mt the defining microtheory
   */
  public void assertDefiningMt(final CycFort dependentTerm, final CycFort mt)  throws IOException, CycApiException {
    // assert (#$definingMt <dependentTerm> <mt>) in #$BaseKB
    assertGaf(baseKB, getKnownConstantByGuid("bde5ec9c-9c29-11b1-9dad-c379636f7270"), dependentTerm, mt);
  }
  
  /** Returns the XML datetime string corresponding to the given CycL date
   *
   * @@param date the date naut
   * @@return the XML datetime string corresponding to the given CycL date
   */
  public String xmlDatetimeString(final CycList date)  throws IOException, CycApiException {
    //// Preconditions
    assert date != null : "date cannot be null";
    assert isa(date, getKnownConstantByName("Date")) : date.cyclify() + " must be a Date";
    
    final CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("cyc-date-encode-string"));
    command.add("XML-datetime");
    command.addQuoted(date);
    String xmlDateString = converseString(command);
    if (xmlDateString.endsWith("TNIL:NIL:NILZ"))
      return xmlDateString.substring(0, xmlDateString.length() - 13);
    else
      return xmlDateString;
  }
  
  /** Initializes the query properties. */
  public void initializeQueryProperties() throws IOException, CycApiException {
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allowed-rules"), CycObjectFactory.makeCycSymbol(":all"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":result-uniqueness"), CycObjectFactory.makeCycSymbol(":bindings"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allow-hl-predicate-transformation?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allow-unbound-predicate-transformation?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allow-evaluatable-predicate-transformation?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":intermediate-step-validation-level"), CycObjectFactory.makeCycSymbol(":all"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":negation-by-failure?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allow-indeterminate-results?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allow-abnormality-checking?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":disjunction-free-el-vars-policy"), CycObjectFactory.makeCycSymbol(":compute-intersection"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":allowed-modules"), CycObjectFactory.makeCycSymbol(":all"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":completeness-minimization-allowed?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":direction"), CycObjectFactory.makeCycSymbol(":backward"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":equality-reasoning-method"), CycObjectFactory.makeCycSymbol(":czer-equal"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":equality-reasoning-domain"), CycObjectFactory.makeCycSymbol(":all"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-problem-count"), new Long(100000));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":transformation-allowed?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":add-restriction-layer-of-indirection?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":evaluate-subl-allowed?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":rewrite-allowed?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":abduction-allowed?"), CycObjectFactory.nil);
    // dynamic query properties
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-number"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-time"), new Integer(30));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-transformation-depth"), new Integer(0));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":block?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-proof-depth"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":cache-inference-results?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":answer-language"), CycObjectFactory.makeCycSymbol(":el"));
    queryProperties.put(CycObjectFactory.makeCycSymbol(":continuable?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":browsable?"), CycObjectFactory.t);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":productivity-limit"), new Long(2000000));
    
    final Object[] queryPropertySymbols = queryProperties.keySet().toArray();
    final int queryPropertySymbols_length = queryPropertySymbols.length;
    for (int i = 0; i < queryPropertySymbols_length; i++) {
      final CycSymbol queryPropertySymbol = (CycSymbol) queryPropertySymbols[i];
      final CycList command = new CycList();
      command.add(CycObjectFactory.makeCycSymbol("query-property-p"));
      command.addQuoted(queryPropertySymbol);
      if (! converseBoolean(command))
        throw new CycApiException(queryPropertySymbol.toString() + " is not a query-property-p");
    }
  }
  
  /** Returns the default HL query propoerties.
   *
   * @@return the default HL query propoerties
   */
  public HashMap getHLQueryProperties() {
    return queryProperties;
  }
  
}
@


1.122
log
@This is the Additional Content to Create OpenCyc-1.0.1
@
text
@a3 1
import java.io.*;
a9 1
import java.util.LinkedList;
a11 1
import java.util.logging.*;
d14 1
a14 1
import org.opencyc.util.StringUtils;
a30 2
import org.opencyc.inference.DefaultInferenceParameterDescriptions;
import org.opencyc.soap.SOAPBinaryCycConnection;
d41 1
a41 1
 * @@version $Id: CycAccess.java,v 1.103.4.1 2006/07/12 22:00:51 karen Exp $
a44 2
  //// Constructors
  
d46 2
a47 5
   * Constructs a new CycAccess object.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d49 2
a50 6
  public CycAccess()
            throws IOException, UnknownHostException, CycApiException {
    this(CycConnection.DEFAULT_HOSTNAME, 
         CycConnection.DEFAULT_BASE_PORT);
  }
  
d52 3
a54 6
   * Constructs a new CycAccess object.
   * 
   * @@param conn the Cyc connection object (in persistent, binary mode)
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d56 1
a56 8
  public CycAccess(CycConnectionInterface conn)
            throws IOException, CycApiException {
    hostName = conn.getHostName();
    port = conn.getBasePort();
    persistentConnection = PERSISTENT_CONNECTION;
    cycConnection = conn;
    commonInitialization();
  }
d59 2
a60 8
   * Constructs a new CycAccess object for a SOAP connection.
   * 
   * @@param endpointURL the SOAP XML endpoint URL which indicates the Cyc API web services host
   * @@param hostName the name of the computer hosting the Cyc server
   * @@param basePort the Cyc server base listening port
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d62 1
a62 11
  public CycAccess(URL endpointURL, 
                   String hostName, 
                   int basePort)
            throws IOException, CycApiException {
    this.hostName = hostName;
    this.port = basePort;
    isSOAPConnection = true;
    this.persistentConnection = PERSISTENT_CONNECTION;
    cycConnection = new SOAPBinaryCycConnection(endpointURL, hostName, basePort, this);
    commonInitialization();
  }
d65 7
a71 8
   * Constructs a new CycAccess object given a host name, port, communication mode, and messaging mode
   * 
   * @@param hostName the host name
   * @@param basePort the base (HTML serving) TCP socket port number
   *
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d73 1
a73 14
  public CycAccess(String hostName, 
                   int basePort)
            throws IOException, UnknownHostException, CycApiException {
    this.hostName = hostName;
    this.port = basePort;
    this.persistentConnection = PERSISTENT_CONNECTION;

    cycConnection = new CycConnection(hostName, 
                                      port, 
                                      this);
    commonInitialization();
  }

  //// Public Area
d76 1
a76 2
   * Dictionary of CycAccess instances, indexed by thread so that the application does not have to
   * keep passing around a CycAccess object reference.
d78 2
a79 2
  public static HashMap cycAccessInstances = new HashMap();

d81 2
a82 3
   * Shared CycAccess instance when thread synchronization is entirely handled by the application.
   * Use of the CycAccess.current() method returns this reference if the lookup by process thread
   * fails.
d84 4
a87 1
  public static CycAccess sharedCycAccessInstance = null;
d96 12
d112 7
a118 1
  public int persistentConnection = PERSISTENT_CONNECTION;
d123 19
a141 5
  /** the indicator that API request forms should be logged to a file api-requests.lisp in the working directory */
  public boolean areAPIRequestsLoggedToFile = false;
  
  public FileWriter apiRequestLog = null;
  
d216 3
d237 8
a244 8
  /**
   * Returns a string representation of this object.
   * 
   * @@return a string representation of this object
   */
  public String toString() {
    return cycConnection.connectionInfo();
  }
d246 3
a248 9
  /**
   * Returns the <tt>CycAccess</tt> object for this thread.
   * 
   * @@return the <tt>CycAccess</tt> object for this thread
   * @@throws RuntimeException when there is no CycAcess object for this thread
   * @@deprecated
   */
  public static CycAccess current() {
    CycAccess cycAccess = (CycAccess) cycAccessInstances.get(Thread.currentThread());
d250 2
a251 8
    if (cycAccess == null) {
      if (sharedCycAccessInstance != null) {
        return sharedCycAccessInstance;
      }
      else {
        throw new RuntimeException("No CycAccess object for this thread");
      }
    }
d253 2
a254 2
    return cycAccess;
  }
d257 2
a258 3
   * Returns true if there is a CycAccess object for this thread.
   * 
   * @@return true if there is a CycAccess object for this thread.
d260 5
a264 14
  public static boolean hasCurrent() {
    CycAccess cycAccess = (CycAccess) cycAccessInstances.get(Thread.currentThread());

    if (cycAccess == null) {
      if (sharedCycAccessInstance != null) {
        return true;
      }
      else {
        return false;
      }
    }
    return true;
  }

d266 1
a266 1
   * Sets the shared <tt>CycAccess</tt> instance.
d268 3
a270 1
   * @@param sharedCycAccessInstance shared<tt>CycAccess</tt> instance
d272 6
a277 2
  public static void setSharedCycAccessInstance(CycAccess sharedCycAccessInstance) {
    CycAccess.sharedCycAccessInstance = sharedCycAccessInstance;
d280 12
a291 6
  /** Returns the Cyc api services lease manager.
   *
   *@@return the Cyc api services lease manager
   */
  public CycLeaseManager getCycLeaseManager() {
    return cycLeaseManager;
d295 8
a302 1
   * Turns on the diagnostic trace of socket messages.
d304 5
a308 3
  public void traceOn() {
    cycConnection.traceOn();
    trace = CycConnection.API_TRACE_MESSAGES;
d312 7
a318 1
   * Turns on the detailed diagnostic trace of socket messages.
d320 5
a324 6
  public void traceOnDetailed() {
    if (cycConnection != null) {
      cycConnection.traceOnDetailed();
    }

    trace = CycConnection.API_TRACE_DETAILED;
d328 8
a335 1
   * Turns off the diagnostic trace of socket messages.
d337 5
a341 3
  public void traceOff() {
    cycConnection.traceOff();
    trace = CycConnection.API_TRACE_NONE;
d345 8
a352 1
   * gets the hostname of the connection
d354 3
a356 1
   * @@return the hostname of the connection
d358 6
a363 2
  public String getHostName() {
    return cycConnection.getHostName();
d367 8
a374 1
   * gets the baseport of the connection
d376 3
a378 1
   * @@return the baseport of the connection
d380 8
a387 2
  public int getBasePort() {
    return cycConnection.getBasePort();
d391 9
a399 1
   * Returns the CycConnection object.
d401 3
a403 1
   * @@return the CycConnection object
d405 18
a422 3
  public CycConnectionInterface getCycConnection() {
    return cycConnection;
  }
d424 1
a424 8
  /** Indicates whether the connection is closed */
  private volatile boolean isClosed = false;
  
  /** Returns whether the connection is closed 
   * @@return whether the connection is closed
   */
  public boolean isClosed() {
    return isClosed;
d428 13
a440 2
   * Closes the CycConnection object. Modified by APB to be able to handle multiple calls to
   * close() safely.
d442 13
a454 7
  public synchronized void close() {
    if (isClosed) { return; }
    isClosed = true;
    if (cycLeaseManager != null)
      cycLeaseManager.interrupt();
    if (cycConnection != null) {
      cycConnection.close();
a455 7
    if (areAPIRequestsLoggedToFile) 
      try {
        apiRequestLog.close();
      }
      catch (IOException e) {
        System.err.println("error when closing apiRequestLog: " + e.getMessage());
      }
d457 10
a466 7
    cycAccessInstances.remove(Thread.currentThread());
    if (sharedCycAccessInstance == null || sharedCycAccessInstance.equals(this)) {
      final Iterator iter = cycAccessInstances.values().iterator();
      if (iter.hasNext())
        sharedCycAccessInstance = (CycAccess) iter.next();
      else
        sharedCycAccessInstance = null;
d468 2
d473 1
a473 5
   * Converses with Cyc to perform an API command whose result is returned as an object.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
a474 1
   * @@throws UnknownHostException if cyc server host not found on the network
d478 4
a481 7
  public Object converseObject(Object command)
                        throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);

    if (response[0].equals(Boolean.TRUE)) {
      return response[1];
a482 2
    else {
      String request;
d484 2
a485 6
      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }
d487 2
a488 1
      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
d490 2
d495 1
a495 2
   * Converses with Cyc to perform an API command whose result is returned as a list.  The symbol
   * nil is returned as the empty list.
d497 8
a504 1
   * @@param command the command string or CycList
d506 1
a506 1
   * @@return the result of processing the API command
d508 1
a508 3
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d510 2
a511 4
  public CycList converseList(Object command)
                       throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);
d513 3
a515 3
    if (response[0].equals(Boolean.TRUE)) {
      if (response[1].equals(CycObjectFactory.nil)) {
        return new CycList();
d518 1
a518 2
        if (response[1] instanceof CycList)
          return (CycList) response[1];
d521 2
a522 6
    String request;
    if (command instanceof CycList)
      request = ((CycList) command).cyclify();
    else
      request = (String) command;
    throw new CycApiException(response[1].toString() + "\nrequest: " + request);
d526 1
a526 1
   * Converses with Cyc to perform an API command whose result is returned as a CycObject.
d528 1
a528 7
   * @@param command the command string or CycList
   * 
   * @@return the result of processing the API command
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
d530 2
a531 4
  public CycObject converseCycObject(Object command)
                              throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);
d533 3
a535 3
    if (response[0].equals(Boolean.TRUE)) {
      if (response[1].equals(CycObjectFactory.nil)) {
        return new CycList();
d538 1
a538 1
        return (CycObject) response[1];
d541 11
a551 2
    else {
      String request;
d553 7
a559 6
      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
      }
      else {
        request = (String) command;
      }
d561 6
a566 1
      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
d568 26
d597 1
a597 1
   * Converses with Cyc to perform an API command whose result is returned as a String.
d599 10
a608 1
   * @@param command the command string or CycList
d610 10
a619 1
   * @@return the result of processing the API command
d621 1
a621 4
   * @@throws IOException if a data communication error occurs
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws CycApiException if the api request results in a cyc server error
   * @@throws RuntimeException if the return from Cyc is not a string
d623 3
a625 4
  public String converseString(Object command)
                        throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    response = converse(command);
d627 2
a628 5
    if (response[0].equals(Boolean.TRUE)) {
      if (!(response[1] instanceof String)) {
        throw new RuntimeException("Expected String but received (" + response[1].getClass() + 
                                   ") " + response[1] + "\n in response to command " + command);
      }
d630 7
a636 1
      return (String) response[1];
a637 2
    else {
      String request;
d639 15
a653 2
      if (command instanceof CycList) {
        request = ((CycList) command).cyclify();
d655 3
a657 2
      else {
        request = (String) command;
d660 1
a660 1
      throw new CycApiException(response[1].toString() + "\nrequest: " + request);
d662 11
d676 27
a702 1
   * Converses with Cyc to perform an API command whose result is returned as a boolean.
d706 335
a1040 1
   * @@return the result of processing the API command
d1115 1
a1115 1
  public void converseVoid(final Object command)
d1147 274
a1420 1
   * Gets a known CycConstant by using its constant name.
a1439 37
  
  public List findConstantsForNames(List constantNames) 
  throws IOException, UnknownHostException, CycApiException {
    if ((constantNames == null) || (constantNames.size() <= 0)) {
      return null;
    }
    StringBuffer command = new StringBuffer("(MAPCAR (QUOTE FIND-CONSTANT) (LIST");
    for (Iterator iter = constantNames.iterator(); iter.hasNext(); ) {
      command.append(" \"");
      String curConstName = StringUtils.escapeDoubleQuotes("" + iter.next());
      command.append(curConstName);
      command.append("\"");
    }
    command.append("))");
    final Object result = converseCycObject("" + command);
    if (!(result instanceof CycList)) { return null; }
    return (CycList)result;
  }
  
  public List findConstantsForGuids(List constantGuids) 
  throws IOException, UnknownHostException, CycApiException {
    if ((constantGuids == null) || (constantGuids.size() <= 0)) {
      return null;
    }
    List result = new ArrayList();
    // @@ToDo this is very inefficient...we need to find a way to do this
    // with a single round trip to Cyc. --Tony
    for (Iterator iter = constantGuids.iterator(); iter.hasNext(); ) {
      CycConstant item = (CycConstant)iter.next();
      try {
        result.add(getConstantByGuid(item.getGuid()));
      } catch (Exception e) {
        result.add(CycObjectFactory.nil);
      }
    }
    return result;
  }
d1452 1
a1452 1
  public CycConstant getConstantByName(final String constantName)
d1455 2
a1456 1
    if (constantName.startsWith("#$"))
d1458 2
a1460 2
    if (answer != null)
      return answer;
d1462 1
a1462 7
    final CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("find-constant"));
    command.add(name);
    final Object answerObject = converseObject(command);
    if (answerObject instanceof CycConstant) {
      answer = (CycConstant) answerObject;
      CycObjectFactory.addCycConstantCache(answer);
d1465 119
a1583 2
    return null;
  }
d1606 67
d1697 25
d1751 25
d1830 2
a1831 1
    if (answer != null)
d1833 16
d1850 4
a1853 6
    final String command = "(find-constant-by-external-id (string-to-guid \"" + guid.toString() + "\"))";
    final Object answerObject = converseObject(command);
    if (answerObject instanceof CycConstant) {
      answer = (CycConstant) answerObject;
      CycObjectFactory.addCycConstantCache(answer);
      return answer;
d1855 7
a1861 1
    return null;
d1865 2
a1866 1
   * Makes a known CycConstant by using its GUID and name, adding it to the cache. 
d1881 2
a1882 1
   * Makes a known CycConstant by using its GUID and name, adding it to the cache.
d1891 8
a1898 2
    CycConstant answer = CycObjectFactory.getCycConstantCacheByGuid(guid);
    if (answer != null)
d1900 1
d1902 5
a1906 2
    answer = new CycConstant(constantName, guid);
    CycObjectFactory.addCycConstantCache(answer);
d1912 6
a1917 2
   * Gets the CycNart object from a Cons object that lists the names of its functor and its
   * arguments.
d1919 1
a1919 1
   * @@param elCons the given list which names the functor and arguments
d1921 3
a1923 2
   * @@return a CycNart object from a Cons object that lists the names of its functor and its
   *         arguments
d1925 14
a1938 2
  public CycNart getCycNartFromCons(CycList elCons) {
    return new CycNart(elCons);
d1942 3
a1944 1
   * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
d1946 1
a1946 3
   * @@param binaryPredicate the predicate
   * @@param arg1 the first argument related by the predicate
   * @@param arg2 the second argument related by the predicate
d1948 2
a1949 2
   * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2 otherwise
   *         false
d1955 10
a1964 8
  public boolean predicateRelates(CycConstant binaryPredicate, 
                                  CycFort arg1, 
                                  CycFort arg2)
                           throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    String command = "(pred-u-v-holds-in-any-mt " + binaryPredicate.stringApiValue() + " " + 
                     arg1.stringApiValue() + " " + arg2.stringApiValue() + ")";
    response = converse(command);
d1966 1
a1966 10
    if (response[0].equals(Boolean.TRUE)) {
      if (response[1] == null) {
        return false;
      }
      else if (response[1].toString().equals("T")) {
        return true;
      }
      else {
        return false;
      }
d1969 1
a1969 1
      throw new CycApiException(response[1].toString());
d1974 5
a1978 1
   * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
d1980 1
a1980 4
   * @@param binaryPredicate the predicate
   * @@param arg1 the first argument related by the predicate
   * @@param arg2 the second argument related by the predicate
   * @@param mt the relevant mt
d1982 2
a1983 2
   * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2 otherwise
   *         false
d1989 11
a1999 10
  public boolean predicateRelates(CycConstant binaryPredicate, 
                                  CycFort arg1, 
                                  CycFort arg2, 
                                  CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };
    String command = "(pred-u-v-holds " + binaryPredicate.stringApiValue() + " " + 
                     arg1.stringApiValue() + " " + arg2.stringApiValue() + " " + 
                     makeELMt(mt).stringApiValue() + ")";
    response = converse(command);
d2001 1
a2001 10
    if (response[0].equals(Boolean.TRUE)) {
      if (response[1] == null) {
        return false;
      }
      else if (response[1].toString().equals("T")) {
        return true;
      }
      else {
        return false;
      }
d2004 1
a2004 1
      throw new CycApiException(response[1].toString());
d2009 3
a2011 1
   * Gets the imprecise plural generated phrase for a CycFort (intended for collections).
d2013 277
a2289 1
   * @@param cycFort the term for paraphrasing
d2318 1
a2318 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2320 1
a2320 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2341 1
a2341 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2343 1
a2343 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2363 1
a2363 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2365 1
a2365 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2385 1
a2385 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2387 1
a2387 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2460 1
a2460 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2462 1
a2462 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2486 2
a2487 2
  public String getComment(final CycObject cycObject, 
                           final CycObject mt)
d2489 6
a2494 12
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
    
    String script = 
      "(clet ((comment-string \n" + 
      "         (comment " + cycObject.stringApiValue() + " " + makeELMt(mt).stringApiValue() + "))) \n" + 
      "  (fif comment-string \n" + 
      "       (string-substitute \" \" \"\\\"\" comment-string) \n" + 
      "       \"\"))";
d2513 1
a2513 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2515 1
a2515 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2524 1
a2524 1
   * @@param cycObject the term for which its isas are sought
d2533 1
a2533 1
  public CycList getIsas(final CycObject cycObject, 
d2536 2
a2537 13
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
                    
    return converseList("(isa " + cycObject.stringApiValue() + 
                        " " + makeELMt(mt).stringApiValue() + 
d2555 1
a2555 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d2557 1
a2557 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d2566 1
a2566 1
   * @@param cycObject the given term
d2575 2
a2576 2
  public CycList getGenls(final CycObject cycObject, 
                          final CycObject mt)
d2578 1
a2578 11
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
           
    return converseList("(genls " + cycObject.stringApiValue() + " " + 
d2825 1
a2825 1
   * @@param cycObject the collection
d2835 1
a2835 1
  public CycList getAllGenls(CycObject cycObject, 
d2838 1
a2838 11
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
           
    return converseList("(all-genls " + cycObject.stringApiValue() + " " + 
d3054 1
a3054 1
  public CycFort getMinCol(final CycList collections)
d3061 1
a3061 1
   * Returns the single most specific collection from the given list of collectons.
a3063 1
   * @@param mt the relevant mt
d3065 1
a3065 1
   * @@return the single most specific collection from the given list of collectons
d3071 1
a3071 1
  public CycFort getMinCol(final CycList collections, final CycObject mt)
d3074 4
a3077 7
    if (collections == null)
      throw new NullPointerException("collections must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
    
    return (CycFort) converseObject("(with-mt " + makeELMt(mt).stringApiValue() + 
                                    " (min-col " + collections.stringApiValue() + "))");
d3081 1
a3081 1
   * Returns the most general collections from the given list of collectons.
d3083 2
a3084 1
   * @@param collections the given collections
d3086 1
a3086 1
   * @@return the most general collections from the given list of collectons
d3092 5
a3096 7
  public CycList getMaxCols(final CycList collections)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert collections != null : "collections cannot be null";                  
                      
    return converseList("(with-all-mts (max-cols " + collections.stringApiValue() + 
                                    "))");
d3100 1
a3100 1
   * Returns the most general collections from the given list of collectons.
d3102 3
a3104 2
   * @@param collections the given collections
   * @@param mt the inference microtheory
d3106 1
a3106 1
   * @@return the most general collections from the given list of collectons
d3112 7
a3118 10
  public CycList getMaxCols(final CycList collections, final CycObject mt)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (collections == null)
      throw new NullPointerException("collections must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
                      
    return converseList("(with-mt " + makeELMt(mt).stringApiValue() + " (max-cols " + collections.stringApiValue() + 
                                    "))");
d3122 1
a3122 1
   * Returns the most specific collections from the given list of collectons.
d3124 2
a3125 1
   * @@param collections the given collections
d3127 1
a3127 1
   * @@return the most specific collections from the given list of collectons
d3133 7
a3139 93
  public CycList getMinCols(final CycList collections)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    assert collections != null : "collections cannot be null";                  
                      
    return converseList("(with-all-mts (min-cols " + collections.stringApiValue() + 
                                    "))");
  }

  /**
   * Returns the most specific collections from the given list of collectons.
   * 
   * @@param collections the given collections
   * @@param mt the inference microtheory
   * 
   * @@return the most specific collections from the given list of collectons
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public CycList getMinCols(final CycList collections, final CycObject mt)
                    throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (collections == null)
      throw new NullPointerException("collections must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
                      
    return converseList("(with-mt " + makeELMt(mt).stringApiValue() + 
                        " (min-cols " + collections.stringApiValue() +  "))");
  }

  /**
   * Returns true if CycFort SPEC is a spec of CycFort GENL.
   * 
   * @@param spec the considered spec collection
   * @@param genl the considered genl collection
   * 
   * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isSpecOf(CycObject spec, 
                          CycObject genl)
                   throws IOException, UnknownHostException, CycApiException {
    return isGenlOf(genl, 
                    spec);
  }

  /**
   * Returns true if CycFort SPEC is a spec of CycFort GENL.
   * 
   * @@param spec the considered spec collection
   * @@param genl the considered genl collection
   * @@param mt the relevant mt
   * 
   * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isSpecOf(CycObject spec, 
                          CycObject genl, 
                          CycObject mt)
                   throws IOException, UnknownHostException, CycApiException {
    return isGenlOf(genl, 
                    spec, 
                    mt);
  }

  /**
   * Returns true if CycFort GENL is a genl of CycFort SPEC.
   * 
   * @@param genl the collection for genl determination
   * @@param spec the collection for spec determination
   * 
   * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isGenlOf(CycObject genl, 
                          CycObject spec)
                   throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(genl-in-any-mt? " + spec.stringApiValue() + " " + 
                           genl.stringApiValue() + ")");
  }

d3153 2
a3154 2
  public boolean isGenlOf_Cached(CycObject genl, 
                                 CycObject spec)
d3191 2
a3192 2
  public boolean isGenlOf(CycObject genl, 
                          CycObject spec, 
d3806 1
a3806 1
  public CycList getLocalDisjointWith(CycObject cycFort)
d3823 1
a3823 1
  public CycList getLocalDisjointWith(CycObject cycFort, 
d3842 2
a3843 2
  public boolean areDisjoint(CycObject collection1, 
                             CycObject collection2)
d3862 2
a3863 2
  public boolean areDisjoint(CycObject collection1, 
                             CycObject collection2, 
d3884 1
a3884 1
  public CycList getMinIsas(CycObject cycFort)
d3903 1
a3903 1
  public CycList getMinIsas(CycObject cycFort, 
d3911 1
a3911 1
   * Gets the list of the asserted instances of a CycFort collection.
d3921 1
a3921 1
  public CycList getInstances(CycObject cycFort)
d3923 1
a3923 2
    CycList result = converseList("(with-all-mts (instances " + cycFort.stringApiValue() + "))");
    return result;
d3927 1
a3927 1
   * Gets the list of the asserted instances of a CycFort collection.
d3938 1
a3938 1
  public CycList getInstances(CycObject cycFort, 
d3958 1
a3958 1
  public CycList getInstanceSiblings(CycObject cycFort)
d3977 1
a3977 1
  public CycList getInstanceSiblings(CycObject cycFort, 
d3996 1
a3996 1
  public CycList getAllIsa(CycObject cycFort)
d3998 1
a3998 3
    String command = "(all-isa-in-any-mt " + cycFort.stringApiValue() + ")";
    CycList result = converseList(command);
    return result;
d4014 1
a4014 1
  public CycList getAllIsa(CycObject cycFort, 
d4034 1
a4034 1
  public CycList getAllInstances(CycObject cycFort)
d4052 1
a4052 1
  public CycList getAllInstances(CycObject cycFort, 
d4073 1
a4073 1
  public CycList getAllQuotedInstances(final CycObject cycFort, final CycObject mt) throws IOException, UnknownHostException, CycApiException {
d4099 1
a4099 1
  public HashSet getAllInstancesHashSet(CycObject cycFort, 
d4120 1
a4120 1
  public HashSet getAllInstancesHashSet(CycObject cycFort)
d4138 1
a4138 1
  public boolean isa(CycObject term, 
d4179 2
a4180 2
  public boolean isa(CycObject term, 
                     CycObject collection, 
d4205 1
a4205 1
  public boolean isQuotedIsa(final CycObject term, final CycObject collection)
a4206 6
    //// Preconditions
    if (term == null)
      throw new NullPointerException("term must not be null");
    if (collection == null)
      throw new NullPointerException("collection must not be null");
                      
a4214 31
   * Returns true if the quoted CycFort TERM is a instance of CycFort COLLECTION, 
   * in the given inference microtheory.
   * 
   * @@param term the term
   * @@param collection the collection
   * @@param mt the inference microtheory
   * 
   * @@return <tt>true</tt> if the quoted CycFort TERM is a instance of CycFort COLLECTION
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isQuotedIsa(final CycObject term, final CycObject collection, final CycObject mt)
              throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (term == null)
      throw new NullPointerException("term must not be null");
    if (collection == null)
      throw new NullPointerException("collection must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
                      
    CycList query = new CycList();
    query.add(getKnownConstantByName("quotedIsa"));
    query.add(term);
    query.add(collection);
    return isQueryTrue(query, mt, null);
  }

  /**
d4229 2
a4230 2
  public CycList getWhyIsa(CycObject spec, 
                           CycObject genl)
d4252 2
a4253 2
  public CycList getWhyIsa(CycObject spec, 
                           CycObject genl, 
d4274 2
a4275 2
  public List getWhyIsaParaphrase(CycObject spec, 
                                  CycObject genl)
d4343 1
a4343 1
  public CycList getGenlPreds(final CycObject predicate)
d4345 2
a4346 11
    if (predicate instanceof CycList) {
      final String script = 
        "(clet ((canonicalized-predicate (canonicalize-term " + predicate.stringApiValue() + ")))" +
        "  (pif (fort-p canonicalized-predicate)" +
        "    (remove-duplicates (with-all-mts (genl-predicates canonicalized-predicate)))" +
        "    nil))";
      return converseList(script);
    }
    else
      return converseList("(remove-duplicates (with-all-mts (genl-predicates " + 
                          predicate.stringApiValue() + ")))");
d4361 2
a4362 2
  public CycList getGenlPreds(final CycObject predicate, 
                              final CycObject mt)
d4364 2
a4365 10
    if (predicate instanceof CycList) {
      final String script = 
        "(clet ((canonicalized-predicate (canonicalize-term " + predicate.stringApiValue() + ")))" +
        "  (pif (fort-p canonicalized-predicate)" +
        "    (remove-duplicates (with-all-mts (genl-predicates canonicalized-predicate "  + makeELMt(mt).stringApiValue() + ")))" +
        "    nil))";
      return converseList(script);
    }
    else
      return converseList("(genl-predicates " + predicate.stringApiValue() + " " + makeELMt(mt).stringApiValue() + ")");
d4597 1
a4597 1
   * @@param cycObject the predicate for which argument 1 contraints are sought.
d4605 1
a4605 1
  public CycList getArg1Isas(CycObject cycObject)
d4608 3
a4610 6
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d4613 1
a4613 1
                        cycObject.stringApiValue() + ")))");
d4628 2
a4629 2
  public CycList getArg1Isas(final CycObject cycObject, 
                             final CycObject mt)
d4631 1
a4631 7
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
    
    return converseList("(arg1-isa " + cycObject.stringApiValue() + " " + 
d4638 1
a4638 1
   * @@param cycObject the predicate for which argument 2 contraints are sought.
d4646 1
a4646 1
  public CycList getArg2Isas(CycObject cycObject)
d4649 3
a4651 6
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d4654 1
a4654 1
                        cycObject.stringApiValue() + ")))");
d4660 1
a4660 1
   * @@param cycObject the predicate for which argument 2 contraints are sought.
d4669 1
a4669 1
  public CycList getArg2Isas(CycObject cycObject, 
d4672 1
a4672 11
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseList("(arg2-isa " + cycObject.stringApiValue() + " " + 
d4985 1
a4985 1
   * @@param cycObject the given predicate term
d4993 1
a4993 1
  public CycList getArg1Formats(CycObject cycObject)
d4996 3
a4998 6
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5000 1
a5000 1
    return converseList("(with-all-mts (arg1-format " + cycObject.stringApiValue() + "))");
d5006 1
a5006 1
   * @@param cycObject the given predicate term
d5015 1
a5015 1
  public CycList getArg1Formats(CycObject cycObject, 
d5018 1
a5018 11
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");

    return converseList("(arg1-format " + cycObject.stringApiValue() + " " + 
d5025 1
a5025 1
   * @@param cycObject the given predicate term
d5033 1
a5033 1
  public CycList getArg2Formats(final CycObject cycObject)
d5036 3
a5038 6
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5040 1
a5040 1
    return converseList("(with-all-mts (arg2-format " + cycObject.stringApiValue() + "))");
d5046 1
a5046 1
   * @@param cycObject the given predicate term
d5055 2
a5056 2
  public CycList getArg2Formats(final CycObject cycObject, 
                                final CycObject mt)
d5058 1
a5058 11
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");

    return converseList("(arg2-format " + cycObject.stringApiValue() + " " + 
d5076 1
a5076 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5078 1
a5078 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5117 1
a5117 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5119 16
a5134 4
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    
    return getCoExtensionals(cycObject, inferencePSC);
d5149 1
a5149 1
  public CycList getCoExtensionals(CycObject cycObject, 
a5151 8
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
            
d5153 1
d5155 2
a5156 8
      final String queryString = 
        "(#$and" + 
        "  (#$different  " + cycObject.cyclify() + " ?X) " + 
        "  (#$or (#$coExtensional " + cycObject.cyclify() + " ?X) " +
        "    (#$coextensionalSetOrCollections " + cycObject.cyclify() + " ?X)))";
      final CycList query = makeCycList(queryString);
      final CycVariable queryVariable = CycObjectFactory.makeCycVariable("?X");
      answer = queryVariable(queryVariable, query, makeELMt(mt), null);
d5160 1
d5164 2
d5196 1
a5196 1
  public boolean isCollection(final CycObject cycObject)
d5199 1
a5199 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5201 1
a5201 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5206 1
a5206 13
  /**
   * Returns true if the given term is a Collection.
   * 
   * @@param cycObject the given term
   * @@param mt the inference microtheory
   * 
   * @@return true if the given term is a Collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCollection(final CycObject cycObject, final CycObject mt)
d5208 2
a5209 32
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseBoolean("(isa? " + cycObject.stringApiValue() + " #$Collection " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns true if the given object is a Collection.
   * 
   * @@param term the given term
   * 
   * @@return true if the given term is a Collection
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isCollection(final Object obj)
                       throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (obj == null)
      throw new NullPointerException("term must not be null");
    
    if (obj instanceof CycObject)
      return isCollection((CycObject) obj);
d5228 1
a5228 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5230 1
a5230 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5268 1
a5268 1
  public boolean isIndividual(final CycObject cycObject)
d5271 1
a5271 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5273 1
a5273 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
a5278 27
   * Returns true if the given term is an Individual.
   * 
   * @@param cycObject the given term
   * @@param mt the inference microtheory
   * 
   * @@return true if the given term is an Individual
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isIndividual(final CycObject cycObject, final CycObject mt)
                       throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseBoolean("(isa? " + cycObject.stringApiValue() + " #$Individual " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
d5333 1
a5333 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5335 1
a5335 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
a5340 27
   * Returns true if cycObject is a Predicate.
   * 
   * @@param cycObject the term for determination as a predicate
   * @@param mt the inference microtheory
   * 
   * @@return true if cycObject is a Predicate
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isPredicate(final CycObject cycObject, final CycObject mt)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseBoolean("(isa? " + cycObject.stringApiValue() + " #$Predicate " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
d5354 1
a5354 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5356 1
a5356 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
a5362 28
   * Returns true if the given term is a UnaryPredicate.
   * 
   * @@param cycObject the given term
   * @@param mt the inference microtheory
   * 
   * @@return true if true if the given term is a UnaryPredicate, otherwise false
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isUnaryPredicate(CycObject cycObject, final CycObject mt)
                           throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseBoolean("(isa? " + cycObject.stringApiValue() + 
                           " #$UnaryPredicate " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
d5373 1
a5373 1
  public boolean isBinaryPredicate(final CycObject cycObject)
d5376 1
a5376 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d5378 1
a5378 2
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
d5385 1
a5385 1
   * Returns true if the cyc object is a BinaryPredicate.
d5387 1
a5387 2
   * @@param cycObject the given cyc object
   * @@param mt the inference microtheory
d5389 1
a5389 1
   * @@return true if cycObject is a BinaryPredicate, otherwise false
d5395 5
a5399 32
  public boolean isBinaryPredicate(final CycObject cycObject, final CycObject mt)
                            throws IOException, UnknownHostException, CycApiException {
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (mt == null)
      throw new NullPointerException("mt must not be null");
            
    return converseBoolean("(isa? " + cycObject.stringApiValue() + 
                           " #$BinaryPredicate " + makeELMt(mt).stringApiValue() + ")");
  }

  /**
   * Returns true if the candidate name uses valid CycConstant characters.
   * 
   * @@param candidateName the candidate name
   * 
   * @@return true if the candidate name uses valid CycConstant characters
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  public boolean isValidConstantName(String candidateName)
                              throws IOException, UnknownHostException, CycApiException {
    return converseBoolean("(new-constant-name-spec-p \"" + candidateName + "\")");
  }

a5425 1
   * @@deprecated
d5429 2
a5430 1
    throw new CycApiException("quotedCollection is no longer supported, see Quote");
a5443 1
   * @@deprecated
d5448 6
a5453 1
    throw new CycApiException("quotedCollection is no longer supported, see Quote");
d5525 4
a5528 1
    CycObjectFactory.addCycConstantCache(cycConstant);
d5645 5
a5649 1
    setCyclist((CycFort) getHLCycTerm(cyclistName));
d5683 5
a5687 1
    setKePurpose((CycFort) getHLCycTerm(projectName));
d5876 22
d7021 1
a7021 1
      return makeELMt(elmtCycList);
d7103 1
a7103 1
    CycConstant cycConstant = getConstantByName(name);
d7118 6
a7123 1
    CycObjectFactory.addCycConstantCache(cycConstant);
d7130 1
a7130 1
   * TMP-, recording bookkeeping information and archiving to the Cyc transcript.  If
d7191 5
a7195 1
    CycObjectFactory.addCycConstantCache(cycConstant);
d7213 3
a7215 3
  public CycList askNewCycQuery(final CycList query, 
                                final CycObject mt, 
                                final HashMap queryProperties)
d7217 17
d7235 1
a7235 1
      "(new-cyc-query "+ query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(queryProperties) + ")";
d7240 2
a7241 3
   * Asks a Cyc query (new inference parameters) and returns an XML stream according
   * to the specifications in the CycList xmlSpec.
   *
a7244 25
   * @@param xmlSpec the specification of elements, attributes, sort order and bindings for the XML that the method returns
   *
   * @@return the binding list from the query in the XML format specified by xmlSpec
   *
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public String queryResultsToXMLString(CycList query,
                                        CycObject mt,
                                        HashMap queryProperties,
                                        CycList xmlSpec)
                      throws IOException, UnknownHostException, CycApiException {
    String xmlSpecString = (xmlSpec == null) ? ":default" : xmlSpec.stringApiValue();
    final String script =
      "(query-results-to-xml-string "+ query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(queryProperties) + " " + xmlSpecString + ")";
    return converseString(script);
  }

  /**
   * Returns true if the  Cyc query (with inference parameters) is proven true.
   * 
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values, or null if the defaults are to used
d7256 17
a7272 2
    final HashMap tempQueryProperties = (queryProperties == null) ? (HashMap) this.queryProperties.clone() : queryProperties;
    tempQueryProperties.put(CycObjectFactory.makeCycSymbol(":max-number"), new Integer(1));
d7274 1
a7274 1
      "(new-cyc-query "+ query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(tempQueryProperties) + ")";
d7284 1
a7284 1
   * @@param queryProperties queryProperties the list of query property keywords and values, or null if the defaults are to used
d7297 17
d7316 1
a7316 1
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(queryProperties) + ")";
a7321 44
   * Asks a Cyc query (new inference parameters) and returns the binding list for the given variable.
   * 
   * @@param variable the unbound variable for which bindings are sought
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values, or null if the defaults are to used
   * @@param inferenceProblemStoreName the problem store name
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList queryVariable(final CycVariable queryVariable,
                               final CycList query, 
                               final CycObject mt, 
                               final HashMap queryProperties,
                               final String inferenceProblemStoreName)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions                    
    if (queryVariable == null)
      throw new NullPointerException("queryVariables must not be null");
    if (query == null)
      throw new NullPointerException("query must not be null");
    if (query.isEmpty())
      throw new IllegalArgumentException("query must not be empty");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
    if (inferenceProblemStoreName == null)
      throw new NullPointerException("inferenceProblemStoreName must not be null");
    if (inferenceProblemStoreName.length() == 0)
      throw new IllegalArgumentException("inferenceProblemStoreName must not be an empty list");
                        
    final HashMap tempQueryProperties = (queryProperties == null) ? (HashMap) this.queryProperties.clone() : queryProperties;
    tempQueryProperties.put(CycObjectFactory.makeCycSymbol(":problem-store"), CycObjectFactory.makeCycSymbol("problem-store", false));
    final String script =
      "(clet ((problem-store (find-problem-store-by-name \"" + inferenceProblemStoreName + "\")))" +
      "  (query-variable "+ queryVariable.stringApiValue() + " " +
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(tempQueryProperties) + "))";
    return converseList(script);
  }

  /**
d7327 1
a7327 1
   * @@param queryProperties queryProperties the list of query property keywords and values, or null if the defaults are to be used
d7340 17
d7359 1
a7359 48
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(queryProperties) + ")";
    
    return converseList(script);
  }

  /**
   * Asks a Cyc query (new inference parameters) and returns the binding list for the given variable list.
   * 
   * @@param variables the list of unbound variables for which bindings are sought
   * @@param query the query expression
   * @@param mt the inference microtheory
   * @@param queryProperties queryProperties the list of query property keywords and values, or null if the defaults are to be used
   * @@param inferenceProblemStoreName the problem store name
   * 
   * @@return the binding list resulting from the given query
   * 
   * @@throws IOException if a communications error occurs
   * @@throws UnknownHostException if the Cyc server cannot be found
   * @@throws CycApiException if the Cyc server returns an error
   */
  public CycList queryVariables(final CycList queryVariables,
                                final CycList query, 
                                final CycObject mt, 
                                final HashMap queryProperties,
                                final String inferenceProblemStoreName)
                      throws IOException, UnknownHostException, CycApiException {
    //// Preconditions                    
    if (queryVariables == null)
      throw new NullPointerException("queryVariables must not be null");
    if (queryVariables.isEmpty())
      throw new IllegalArgumentException("queryVariables must not be empty");
    if (query == null)
      throw new NullPointerException("query must not be null");
    if (query.isEmpty())
      throw new IllegalArgumentException("query must not be empty");
    if (mt == null)
      throw new NullPointerException("mt must not be null");
    if (inferenceProblemStoreName == null)
      throw new NullPointerException("inferenceProblemStoreName must not be null");
    if (inferenceProblemStoreName.length() == 0)
      throw new IllegalArgumentException("inferenceProblemStoreName must not be an empty list");
                        
    final HashMap tempQueryProperties = (queryProperties == null) ? (HashMap) this.queryProperties.clone() : queryProperties;
    tempQueryProperties.put(CycObjectFactory.makeCycSymbol(":problem-store"), CycObjectFactory.makeCycSymbol("problem-store", false));
    final String script =
      "(clet ((problem-store (find-problem-store-by-name \"" + inferenceProblemStoreName + "\")))" +
      "  (query-template "+ queryVariables.stringApiValue() + " " +
      query.stringApiValue() + " " + makeELMt(mt).stringApiValue() + " " + queryPropertiesToString(tempQueryProperties) + "))";
d9436 1
a9436 1
   * @@param cycObject the given term
d9447 3
a9449 3
  public CycList getGafsForPredicates(final CycObject cycObject, 
                                      final List predicates, 
                                      final CycObject mt)
d9451 1
a9451 13
    //// Preconditions
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
           cycObject instanceof CycNart || 
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (predicates == null)
      throw new NullPointerException("predicates must not be null");
    if (predicates == null)
      throw new NullPointerException("predicates must not be null");

    final CycList result = new CycList();
d9454 1
a9454 1
      result.addAllNew(getGafs(cycObject, 
d9478 3
a9480 3
  public CycList getGafs(final CycObject cycFort, 
                         final CycObject predicate, 
                         final CycObject mt)
d9482 5
a9486 14
    if (cycFort == null)
      throw new NullPointerException("cycFort must not be null");
    if (predicate == null)
      throw new NullPointerException("predicate must not be null");
    if (mt == null)
      throw new NullPointerException("mt must not be null");    
    // TODO handle the case where the cycObject is a NAUT, 
    //getGafsForNaut
    
    final CycList gafs = new CycList();
    final String command = "(with-mt " + makeELMt(mt).stringApiValue() + "\n" + 
                           "  (pred-values-in-relevant-mts " + cycFort.stringApiValue() + " " + 
                           predicate.stringApiValue() + "))";
    final CycList values = converseList(command);
d9489 1
a9489 1
      final CycList gaf = new CycList();
d9513 2
a9514 2
  public CycList getGafsForPredicates(final CycObject cycObject, 
                                      final List predicates)
d9517 1
a9517 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d9519 1
a9519 4
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    if (predicates == null)
      throw new NullPointerException("predicates must not be null");
d9521 1
a9521 1
    final CycList result = new CycList();
d9543 2
a9544 2
  public CycList getGafs(final CycObject cycObject, 
                         final CycObject predicate)
d9547 1
a9547 3
    if (cycObject == null)
      throw new NullPointerException("cycObject must not be null");
    if (! (cycObject instanceof CycConstant || 
d9549 1
a9549 3
           cycObject instanceof CycList))
      throw new IllegalArgumentException("cycObject must be a CycConstant, CycNart or CycList " + cycObject.cyclify());
    
d9552 5
a9556 7
    final CycList gafs = new CycList();
    // TODO handle the case where the cycObject is a NAUT, 
    //getGafsForNaut
    final String command = "(with-all-mts \n" + "  (pred-values-in-relevant-mts (canonicalize-term " + 
                           cycObject.stringApiValue() + ") " + "(canonicalize-term " + 
                           predicate.stringApiValue() + ")))";
    final CycList values = converseList(command);
d9559 1
a9559 1
      final CycList gaf = new CycList();
d9583 2
a9584 2
  public CycList getGafsForNaut(final CycList naut, 
                                final CycObject predicate)
d10579 1
a10579 1
    return converseObject("(canonicalize-term  '" + string + ")");
a10597 10
  /** Returns the external ID for the given Cyc object.
   *
   * @@param cycObject the Cyc object (Constant, NART or NAUT)
   * @@return the external ID string
   */
  public String getExternalIDString(final CycObject cycObject)
                      throws IOException, UnknownHostException, CycApiException {
    return converseString("(hl-external-id-string (canonicalize-term '" + cycObject.cyclify() + "))");
  }
  
d10726 1
a10726 1
  public void assertDefiningMt(final CycFort dependentTerm, final CycFort mt) throws IOException, CycApiException {
a10751 8
  /**
   * Returns whether or not we have a valid lease with the Cyc server.
   * @@return whether or not we have a valid lease with the Cyc server
   */
  public boolean hasValidLease() {
    return (cycLeaseManager == null) ? true : cycLeaseManager.hasValidLease();
  }
  
d10753 1
a10753 1
  public void initializeQueryProperties() {
d10770 1
a10770 1
    queryProperties.put(CycObjectFactory.makeCycSymbol(":transformation-allowed?"), CycObjectFactory.nil);
a10774 1
    queryProperties.put(CycObjectFactory.makeCycSymbol(":removal-backtracking-productivity-limit"), new Long(2000000));
d10777 1
a10777 1
    queryProperties.put(CycObjectFactory.makeCycSymbol(":max-time"), new Integer(120));
d10783 2
a10784 2
    queryProperties.put(CycObjectFactory.makeCycSymbol(":continuable?"), CycObjectFactory.nil);
    queryProperties.put(CycObjectFactory.makeCycSymbol(":browsable?"), CycObjectFactory.nil);
d10794 2
a10795 7
      try {
        if (! converseBoolean(command))
          System.err.println(queryPropertySymbol.toString() + " is not a query-property-p");
      } 
      catch (Exception e) {
        System.err.println(e.getMessage());
      }
d10799 1
a10799 1
  /** Returns a clone of the default HL query propoerties.
d10804 1
a10804 64
    return (HashMap) queryProperties.clone();
  }
  
  /** Returns a query properties string for the given query properties if present, otherwise
   * returns a query properties string for the default query properties.
   *
   * @@param queryProperties the given query properties or null if the defaults are to be used
   *
   * @@return a query properties string for the given query properties if present, otherwise
   * returns a query properties string for the default query properties
   */
  public String queryPropertiesToString(final HashMap queryProperties) {
    final HashMap tempQueryProperties = (queryProperties == null) ? (HashMap) this.queryProperties.clone() : queryProperties;
    final CycList parameterList = new CycList();
    final Iterator iter = tempQueryProperties.entrySet().iterator();
    String queryPropertiesString = "nil";
    if (iter.hasNext()) {
      while (iter.hasNext()) {
        Entry mapEntry = (Entry) iter.next();
        CycSymbol queryParameterKeyword = (CycSymbol) mapEntry.getKey();
        parameterList.add(queryParameterKeyword);

        Object queryParameterValue = mapEntry.getValue();
        parameterList.add(queryParameterValue);
      }
      queryPropertiesString = parameterList.stringApiValue();
    }
    return queryPropertiesString;
  }
  
  /** Initializes a named inference problem store.
   *
   * @@param name the unique problem store name
   * @@param queryProperties the given query properties or null if the defaults are to be used
   */
  public void initializeNamedInferenceProblemStore(final String name, final HashMap queryProperties) throws IOException, CycApiException {
    //// Preconditions
    if (name == null)
      throw new NullPointerException("name must not be null");
    if (name.length() == 0)
      throw new IllegalArgumentException("name must not be an empty string");
      
    final HashMap tempQueryProperties = (queryProperties == null) ? getHLQueryProperties() : queryProperties;
    final String command = 
      "(progn " +
      "  (find-or-create-problem-store-by-name \"" + name + "\" (filter-plist " + queryPropertiesToString(tempQueryProperties) + "'problem-store-property-p)) " +
      "  nil)";
    converseVoid(command);
  }
  
  /** Destroys the named problem store.
   *
   * @@param name the unique problem store name
   */
  public void destroyInferenceProblemStoreByName(final String name) throws IOException, CycApiException {
    //// Preconditions
    if (name == null)
      throw new NullPointerException("name must not be null");
    if (name.length() == 0)
      throw new IllegalArgumentException("name must not be an empty string");
    
    final String command = 
      "(destroy-problem-store-by-name \"" + name + "\")";
    converseVoid(command);
a10806 458
  //// Protected Area
  
  /**
   * Provides common local and remote CycAccess object initialization.
   * 
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  protected void commonInitialization()
                               throws IOException, CycApiException {
    if (Log.current == null) {
      Log.makeLog("cyc-api.log");
    }

    if (areAPIRequestsLoggedToFile) 
      apiRequestLog = new FileWriter("api-requests.lisp");
    
    cycAccessInstances.put(Thread.currentThread(), this);

    if (sharedCycAccessInstance == null) {
      sharedCycAccessInstance = this;
    }
    cycImageID = getCycImageID();
    cycLeaseManager = new CycLeaseManager(this);
    try {
      // wait for the sockets to initialize
      Thread.sleep(500);
    }
    catch (java.lang.InterruptedException e) {
    }
    if (! isSOAPConnection)
      // if the communication mode is SOAP, then there is a lease manager, but it is never started
      cycLeaseManager.start();
    initializeConstants();
    initializeQueryProperties();
    if (! isOpenCyc()) {
      try {
        DefaultInferenceParameterDescriptions.
          loadInferenceParameterDescriptions(this, 0);
      } catch (Exception e) {
        Logger logger = Logger.getLogger("org.opencyc.api.CycAccess");
        logger.warning("Could not load inference parameter descriptions.\n" + 
          e.getMessage());
      }
    }
  }

  /**
   * Converses with Cyc to perform an API command.  Creates a new connection for this command if
   * the connection is not persistent.
   * 
   * @@param command the command string or CycList
   * 
   * @@return the result as an object array of two objects
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  protected Object[] converse(Object command)
                       throws IOException, UnknownHostException, CycApiException {
    Object[] response = { null, null };

    if (trace > CycConnection.API_TRACE_NONE || areAPIRequestsLoggedToFile) {
      final CycList commandCycList = (command instanceof CycList) ? (CycList) command : makeCycList((String) command);
      final String prettyCommandCycList = commandCycList.toPrettyCyclifiedString("");
      final String escapedCommandCycList = commandCycList.toPrettyEscapedCyclifiedString("");
      if (areAPIRequestsLoggedToFile) {
        apiRequestLog.write(escapedCommandCycList);
        apiRequestLog.write('\n');
      }
      if (trace > CycConnection.API_TRACE_NONE)
        Log.current.println(prettyCommandCycList + "\n--> cyc");
    }
    
    if (! isSOAPConnection) {
//      if ((previousAccessedMilliseconds + MAX_UNACCESSED_MILLIS) < System.currentTimeMillis()) {
//        Log.current.println("Re-establishing a stale Cyc connection.");
//        reEstablishCycConnection();
//      }
//      else 
      if (! ((CycConnection) getCycConnection()).isValidBinaryConnection()) {
        Log.current.println("Re-establishing an invalid Cyc connection.");
        reEstablishCycConnection();
      }
    }
    response = cycConnection.converse(command);
    previousAccessedMilliseconds = System.currentTimeMillis();

    if (trace > CycConnection.API_TRACE_NONE) {
      String responseString;

      if (response[1] instanceof CycList) {
        responseString = ((CycList) response[1]).toPrettyString("");
      }
      else if (response[1] instanceof CycFort) {
        responseString = ((CycFort) response[1]).cyclify();
      }
      else {
        responseString = response[1].toString();
      }
      Log.current.println("cyc --> " + responseString);
    }

    return response;
  }

 /** Re-estabishes a stale binary CycConnection. */
 protected void reEstablishCycConnection()  throws IOException, UnknownHostException, CycApiException {
    previousAccessedMilliseconds = System.currentTimeMillis();   
    cycConnection.close();
    cycConnection = new CycConnection(hostName, 
                                      port, 
                                      this);      
    if (! (cycImageID.equals(getCycImageID()))) {
      Log.current.println("New Cyc image detected, resetting caches.");
      CycObjectFactory.resetCaches();
    }
 }
  
  /**
   * Returns a with-bookkeeping-info macro expresssion.
   * 
   * @@return a with-bookkeeping-info macro expresssion
   */
  protected String withBookkeepingInfo() {
    String projectName = "nil";

    if (project != null) {
      projectName = project.stringApiValue();
    }

    String cyclistName = "nil";

    if (cyclist != null) {
      cyclistName = cyclist.stringApiValue();
    }

    return "(with-bookkeeping-info (new-bookkeeping-info " + cyclistName + " (the-date) " + 
           projectName + "(the-second)) ";
  }

  //// Private Area
  
  private CycConstant makePrefetchedConstant(String guidStr, HashMap constantInfoDictionary) {
    Guid guid = CycObjectFactory.makeGuid(guidStr);
    CycConstant prefetchedConstant = makeConstantWithGuidName(guid, 
      (String)constantInfoDictionary.get(guid));
    CycObjectFactory.addCycConstantCache(prefetchedConstant);
    return prefetchedConstant;
  }

  /**
   * Initializes common cyc constants.
   * 
   * @@throws UnknownHostException if cyc server host not found on the network
   * @@throws IOException if a data communication error occurs
   * @@throws CycApiException if the api request results in a cyc server error
   */
  private void initializeConstants()
                            throws IOException, UnknownHostException, CycApiException {
    CycList guidStrings = new CycList();
    guidStrings.add("bd588111-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588104-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd58810e-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880e5-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588109-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880cc-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd588102-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("c0659a2b-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880f9-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880fa-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880fb-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd589d90-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880ae-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd63f343-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880f4-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd58915a-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("dff4a041-4da2-11d6-82c0-0002b34c7c9f");
    guidStrings.add("beaed5bd-9c29-11b1-9dad-c379636f7270");
    guidStrings.add("bd5880d9-9c29-11b1-9dad-c379636f7270"); // true
    guidStrings.add("bd5880d8-9c29-11b1-9dad-c379636f7270"); // false
    guidStrings.add("bde7f9f2-9c29-11b1-9dad-c379636f7270"); // xor
    guidStrings.add("bda887b6-9c29-11b1-9dad-c379636f7270"); // equiv
    guidStrings.add("bd5880f8-9c29-11b1-9dad-c379636f7270"); // implies
    guidStrings.add("bd5880f7-9c29-11b1-9dad-c379636f7270"); // forAll
    guidStrings.add("bd5880f6-9c29-11b1-9dad-c379636f7270"); // thereExists
    guidStrings.add("c10ae7b8-9c29-11b1-9dad-c379636f7270"); // thereExistExactly
    guidStrings.add("c10af932-9c29-11b1-9dad-c379636f7270"); // thereExistAtMost
    guidStrings.add("c10af5e7-9c29-11b1-9dad-c379636f7270"); // thereExistAtLeast
    guidStrings.add("94f07021-8b0d-11d7-8701-0002b3a8515d"); // SubLQuoteFn
    guidStrings.add("c0b2bc13-9c29-11b1-9dad-c379636f7270"); // ExpandSubLFn

    CycList command = new CycList();
    command.add(CycObjectFactory.makeCycSymbol("constant-info-from-guid-strings"));
    command.addQuoted(guidStrings);

    CycList constantInfos = converseList(command);
    Iterator iter = constantInfos.iterator();
    HashMap constantInfoDictionary = new HashMap();

    while (iter.hasNext()) {
      Object constantInfoObject = iter.next();

      if (constantInfoObject instanceof CycList) {
        CycList constantInfo = (CycList) constantInfoObject;
        Guid guid = CycObjectFactory.makeGuid((String) constantInfo.first());
        String name = (String) constantInfo.second();
        constantInfoDictionary.put(guid, name);
      }
    }

    Guid guid = null;
    
    if (this.trueConst == null) { 
      trueConst = makePrefetchedConstant("bd5880d9-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.falseConst == null) { 
      falseConst = makePrefetchedConstant("bd5880d8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.xorConst == null) { 
      xorConst = makePrefetchedConstant("bde7f9f2-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.equivConst == null) { 
      equivConst = makePrefetchedConstant("bda887b6-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.impliesConst == null) { 
      impliesConst = makePrefetchedConstant("bd5880f8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.forAllConst == null) { 
      forAllConst = makePrefetchedConstant("bd5880f7-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistsConst == null) { 
      thereExistsConst = makePrefetchedConstant("bd5880f6-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistExactlyConst == null) { 
      thereExistExactlyConst = makePrefetchedConstant("c10ae7b8-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistAtMostConst == null) { 
      thereExistAtMostConst = makePrefetchedConstant("c10af932-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.thereExistAtLeastConst == null) { 
      thereExistAtLeastConst = makePrefetchedConstant("c10af5e7-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    if (this.sublQuoteFnConst == null) { 
      sublQuoteFnConst = makePrefetchedConstant("94f07021-8b0d-11d7-8701-0002b3a8515d", constantInfoDictionary);
    }
    if (this.expandSubLFnConst == null) { 
      expandSubLFnConst = makePrefetchedConstant("c0b2bc13-9c29-11b1-9dad-c379636f7270", constantInfoDictionary);
    }
    
    if (baseKB == null) {
      guid = CycObjectFactory.makeGuid("bd588111-9c29-11b1-9dad-c379636f7270");
      baseKB = makeELMt(makeConstantWithGuidName(guid, 
                                                 (String) constantInfoDictionary.get(guid)));
      CycObjectFactory.addCycConstantCache((CycConstant) baseKB);
    }

    if (isa == null) {
      guid = CycObjectFactory.makeGuid("bd588104-9c29-11b1-9dad-c379636f7270");
      isa = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCache(isa);
    }

    if (genls == null) {
      guid = CycObjectFactory.makeGuid("bd58810e-9c29-11b1-9dad-c379636f7270");
      genls = makeConstantWithGuidName(guid, 
                                       (String) constantInfoDictionary.get(
                                             guid));
      CycObjectFactory.addCycConstantCache(genls);
    }

    if (genlMt == null) {
      guid = CycObjectFactory.makeGuid("bd5880e5-9c29-11b1-9dad-c379636f7270");
      genlMt = makeConstantWithGuidName(guid, 
                                        (String) constantInfoDictionary.get(
                                              guid));
      CycObjectFactory.addCycConstantCache(genlMt);
    }

    if (comment == null) {
      guid = CycObjectFactory.makeGuid("bd588109-9c29-11b1-9dad-c379636f7270");
      comment = makeConstantWithGuidName(guid, 
                                         (String) constantInfoDictionary.get(
                                               guid));
      CycObjectFactory.addCycConstantCache(comment);
    }

    if (collection == null) {
      guid = CycObjectFactory.makeGuid("bd5880cc-9c29-11b1-9dad-c379636f7270");
      collection = makeConstantWithGuidName(guid, 
                                            (String) constantInfoDictionary.get(
                                                  guid));
      CycObjectFactory.addCycConstantCache(collection);
    }

    if (binaryPredicate == null) {
      guid = CycObjectFactory.makeGuid("bd588102-9c29-11b1-9dad-c379636f7270");
      binaryPredicate = makeConstantWithGuidName(guid, 
                                                 (String) constantInfoDictionary.get(
                                                       guid));
      CycObjectFactory.addCycConstantCache(binaryPredicate);
    }

    if (elementOf == null) {
      guid = CycObjectFactory.makeGuid("c0659a2b-9c29-11b1-9dad-c379636f7270");
      elementOf = makeConstantWithGuidName(guid, 
                                           (String) constantInfoDictionary.get(
                                                 guid));
      CycObjectFactory.addCycConstantCache(elementOf);
    }

    if (and == null) {
      guid = CycObjectFactory.makeGuid("bd5880f9-9c29-11b1-9dad-c379636f7270");
      and = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCache(and);
    }

    if (or == null) {
      guid = CycObjectFactory.makeGuid("bd5880fa-9c29-11b1-9dad-c379636f7270");
      or = makeConstantWithGuidName(guid, 
                                    (String) constantInfoDictionary.get(
                                          guid));
      CycObjectFactory.addCycConstantCache(or);
    }

    if (not == null) {
      guid = CycObjectFactory.makeGuid("bd5880fb-9c29-11b1-9dad-c379636f7270");
      not = makeConstantWithGuidName(guid, 
                                     (String) constantInfoDictionary.get(
                                           guid));
      CycObjectFactory.addCycConstantCache(not);
    }

    if (numericallyEqual == null) {
      guid = CycObjectFactory.makeGuid("bd589d90-9c29-11b1-9dad-c379636f7270");
      numericallyEqual = makeConstantWithGuidName(guid, 
                                                  (String) constantInfoDictionary.get(
                                                        guid));
      CycObjectFactory.addCycConstantCache(numericallyEqual);
    }

    if (plusFn == null) {
      guid = CycObjectFactory.makeGuid("bd5880ae-9c29-11b1-9dad-c379636f7270");
      plusFn = makeConstantWithGuidName(guid, 
                                        (String) constantInfoDictionary.get(
                                              guid));
      CycObjectFactory.addCycConstantCache(plusFn);
    }

    if (different == null) {
      guid = CycObjectFactory.makeGuid("bd63f343-9c29-11b1-9dad-c379636f7270");
      different = makeConstantWithGuidName(guid, 
                                           (String) constantInfoDictionary.get(
                                                 guid));
      CycObjectFactory.addCycConstantCache(different);
     }

    if (thing == null) {
      guid = CycObjectFactory.makeGuid("bd5880f4-9c29-11b1-9dad-c379636f7270");
      thing = makeConstantWithGuidName(guid, 
                                       (String) constantInfoDictionary.get(
                                             guid));
      CycObjectFactory.addCycConstantCache(thing);
    }

    if (inferencePSC == null) {
      guid = CycObjectFactory.makeGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
      inferencePSC = makeELMt(makeConstantWithGuidName(
                                    guid, 
                                    (String) constantInfoDictionary.get(
                                          guid)));
      CycObjectFactory.addCycConstantCache((CycConstant) inferencePSC);
    }

    if (universalVocabularyMt == null) {
      guid = CycObjectFactory.makeGuid("dff4a041-4da2-11d6-82c0-0002b34c7c9f");
      universalVocabularyMt = makeELMt(makeConstantWithGuidName(
                                             guid, 
                                             (String) constantInfoDictionary.get(
                                                   guid)));
      CycObjectFactory.addCycConstantCache((CycConstant) universalVocabularyMt);
    }

    if (bookkeepingMt == null) {
      guid = CycObjectFactory.makeGuid("beaed5bd-9c29-11b1-9dad-c379636f7270");
      bookkeepingMt = makeELMt(makeConstantWithGuidName(
                                     guid, 
                                     (String) constantInfoDictionary.get(
                                           guid)));
      CycObjectFactory.addCycConstantCache((CycConstant) bookkeepingMt);
    }
  }
  
  //// Internal Rep
  
  /** the Cyc server host name */
  protected String hostName;

  /** the Cyc server host tcp port number */
  protected int port;

  /** the Cyc server OK response code */
  protected static final Integer OK_RESPONSE_CODE = new Integer(200);

  /** the parameter that, when true, causes a trace of the messages to and from the server */
  protected int trace = CycConnection.API_TRACE_NONE;
  //protected int trace = CycConnection.API_TRACE_MESSAGES;
  //protected int trace = CycConnection.API_TRACE_DETAILED;

  /** the current Cyc Cyclist (user) */
  private CycFort cyclist = null;

  /** the current Cyc project */
  private CycFort project = null;

  /** Least Recently Used Cache of ask results. */
  protected Cache askCache = new CacheLRU(500);

  /** Least Recently Used Cache of countAllInstances results. */
  protected Cache countAllInstancesCache = new CacheLRU(500);

  /** Least Recently Used Cache of isCollection results. */
  protected Cache isCollectionCache = new CacheLRU(500);

  /** Least Recently Used Cache of isGenlOf results. */
  protected Cache isGenlOfCache = new CacheLRU(500);

  /**
   * Reference to <tt>CycConnection</tt> object which manages the api connection to the OpenCyc
   * server.
   */
  protected CycConnectionInterface cycConnection;
  
  /** the query properties */
  private final HashMap queryProperties = new HashMap();
  
  /** the timestamp for the previous access to Cyc, used to re-establish too-long unused connections */
  private long previousAccessedMilliseconds = System.currentTimeMillis();
  
  /** the maximum time that the CycAccess connection is allowed to be unused before
   * estabishing a fresh connection (ten hours)
   */
  protected static final long MAX_UNACCESSED_MILLIS = 36000000;
  
  /** the Cyc image ID used for detecting new Cyc images that cause the constants cache to be reset */
  private String cycImageID;
  
  /** the Cyc lease manager that acquires Cyc api service leases */
  private CycLeaseManager cycLeaseManager;
  
  /** The indicator that this CycAccess object is using a SOAP connection to communicate with Cyc */
  private boolean isSOAPConnection = false;
    
@


1.121
log
@This is a checkin of OpenCyc 1.0.1 Java  OPENCYC_1_0_1
@
text
@@


1.120
log
@Added Epistemlogical Layer Microtheory definition to better
represent microtheories in the OpenCyc API.
@
text
@d3 1
a3 2
import java.util.*;
import java.net.*;
d5 33
a37 4
import org.apache.oro.util.*;
import org.opencyc.util.*;
import org.opencyc.cycobject.*;
import org.opencyc.cycagent.*;
d40 3
a42 2
 * Provides wrappers for the OpenCyc API.<p>
 *
d44 4
a47 21
 *
 * @@version $Id: CycAccess.java,v 1.27 2003/04/22 19:49:36 reed Exp $
 * @@author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d50 2427
a2476 474

    /**
     * Dictionary of CycAccess instances, indexed by thread so that the application does not
     * have to keep passing around a CycAccess object reference.
     */
    public static HashMap cycAccessInstances = new HashMap();

    /**
     * Shared CycAccess instance when thread synchronization is entirely handled by the application. Use of
     * the CycAccess.current() method returns this reference if the lookup by process thread fails.
     */
    public static CycAccess sharedCycAccessInstance = null;

    /**
     * When true performs tracing of binary mode messages with constant names displayed,
     * which involves recursive api requests.
     */
    public boolean traceWithNames = false;
    //public boolean traceWithNames = true;

    /**
     * Stack to prevent tracing of recursive api calls whose sole purpose is to obtain
     * names for traceWithNames.
     */
    protected Stack traceWithNamesStack = new Stack();

    /**
     * Value indicating that the OpenCyc api socket is created and then closed for each api call.
     */
    public static final boolean TRANSIENT_CONNECTION = false;

    /**
     * Value indicating that the OpenCyc api should use one TCP socket for the entire session.
     */
    public static final boolean PERSISTENT_CONNECTION = true;

    /**
     * Default value indicating that the OpenCyc api should use one TCP socket for the entire session.
     */
    public static final boolean DEFAULT_CONNECTION = PERSISTENT_CONNECTION;

    /**
     * Parameter indicating whether the OpenCyc binary api defers the completion of CycConstant attributes
     * until used for the first time.
     */
    public boolean deferObjectCompletion = true;

    /**
     * Parameter indicating whether the OpenCyc api should use one TCP socket for the entire
     * session, or if the socket is created and then closed for each api call.
     */
    public boolean persistentConnection;

    /**
     * Parameter indicating the serial or concurrent messaging mode to the OpenCyc server.
     */
    public int messagingMode = CycConnection.DEFAULT_MESSAGING_MODE;

    /**
     * Parameter indicating that compatibility with older versions of the OpenCyc api is desired.
     */
    protected boolean isLegacyMode = false;

    /**
     * Default value for isLegacyMode is no compatibility with older versions of the OpenCyc api.
     */
    public static final boolean DEFAULT_IS_LEGACY_MODE = false;


    protected String hostName;
    protected int port;
    protected int communicationMode;
    protected static final Integer OK_RESPONSE_CODE = new Integer(200);

    /**
     * Parameter that, when true, causes a trace of the messages to and from the server. This
     * variable preserves the value of the CycConnection trace between instantiations when the
     * connection is transient.
     */
    protected int saveTrace = CycConnection.API_TRACE_NONE;

    /**
     * Convenient reference to #$BaseKb.
     */
    public static CycConstant baseKB = null;

    /**
     * Convenient reference to #$isa.
     */
    public static CycConstant isa = null;

    /**
     * Convenient reference to #$genls.
     */
    public static CycConstant genls = null;

    /**
     * Convenient reference to #$genlMt.
     */
    public static CycConstant genlMt = null;

    /**
     * Convenient reference to #$comment.
     */
    public static CycConstant comment = null;

    /**
     * Convenient reference to #$Collection.
     */
    public static CycConstant collection = null;

    /**
     * Convenient reference to #$binaryPredicate.
     */
    public static CycConstant binaryPredicate = null;

    /**
     * Convenient reference to #$elementOf.
     */
    public static CycConstant elementOf = null;

    /**
     * Convenient reference to #$and.
     */
    public static CycConstant and = null;

    /**
     * Convenient reference to #$or.
     */
    public static CycConstant or = null;

    /**
     * Convenient reference to #$not.
     */
    public static CycConstant not = null;

    /**
     * Convenient reference to #$numericallyEqual.
     */
    public static CycConstant numericallyEqual = null;

    /**
     * Convenient reference to #$PlusFn.
     */
    public static CycConstant plusFn = null;

    /**
     * Convenient reference to #$different.
     */
    public static CycConstant different = null;

    /**
     * Convenient reference to #$Thing.
     */
    public static CycConstant thing = null;

    /**
     * Convenient reference to #$InferencePSC.
     */
    public static CycConstant inferencePSC = null;

    /**
     * Convenient reference to #$UniversalVocabularyMt.
     */
    public static CycConstant universalVocabularyMt = null;

    /**
     * Convenient reference to #$bookkeepingMt.
     */
    public static CycConstant bookkeepingMt = null;

    private CycConstant cyclist = null;
    private CycConstant project = null;

    /**
     * Least Recently Used Cache of ask results.
     */
    protected Cache askCache = new CacheLRU(500);

    /**
     * Least Recently Used Cache of countAllInstances results.
     */
    protected Cache countAllInstancesCache = new CacheLRU(500);

    /**
     * Least Recently Used Cache of isCollection results.
     */
    protected Cache isCollectionCache = new CacheLRU(500);

    /**
     * Least Recently Used Cache of isGenlOf results.
     */
    protected Cache isGenlOfCache = new CacheLRU(500);

    /**
     * Reference to <tt>CycConnection</tt> object which manages the api connection to the OpenCyc server.
     */
    protected CycConnectionInterface cycConnection;

    /**
     * Constructs a new CycAccess object.
     *
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess() throws IOException, UnknownHostException, CycApiException {
        this(CycConnection.DEFAULT_HOSTNAME,
             CycConnection.DEFAULT_BASE_PORT,
             CycConnection.DEFAULT_COMMUNICATION_MODE,
             CycAccess.DEFAULT_CONNECTION,
             CycAccess.DEFAULT_IS_LEGACY_MODE);
    }

    /**
     * Constructs a new CycAccess object to the given CycProxyAgent in the given
     * agent community.
     *
     * @@param myAgentName the name of the local agent
     * @@param cycProxyAgentName the name of the cyc proxy agent
     * @@param agentCommunity the agent community to which the cyc proxy agent belongs
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess (String myAgentName,
                      String cycProxyAgentName,
                      int agentCommunity) throws IOException, CycApiException  {
        communicationMode = CycConnection.BINARY_MODE;
        persistentConnection = PERSISTENT_CONNECTION;
        cycConnection = new RemoteCycConnection(myAgentName, cycProxyAgentName, agentCommunity);
        commonInitialization();
    }

    /**
     * Constructs a new CycAccess object to the given CycProxyAgent in the given
     * agent community.
     *
     * @@param endpointURL the SOAP XML endpoint URL which indicates the Cyc API web services host
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess (URL endpointURL) throws IOException, CycApiException  {
        communicationMode = CycConnection.ASCII_MODE;
        persistentConnection = PERSISTENT_CONNECTION;
        cycConnection = new SOAPCycConnection(endpointURL, this);
        commonInitialization();
    }

    /**
     * Constructs a new CycAccess object given a host name.
     *
     * @@param hostName the host name
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess(String hostName)
        throws IOException, UnknownHostException, CycApiException {
        this(hostName,
             CycConnection.DEFAULT_BASE_PORT,
             CycConnection.DEFAULT_COMMUNICATION_MODE,
             CycAccess.DEFAULT_CONNECTION,
             false);
    }

    /**
     * Constructs a new CycAccess object given a host name, port,
     * communication mode, persistence indicator and legacy mode.
     *
     * @@param hostName the host name
     * @@param basePort the base (HTML serving) TCP socket port number
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess(String hostName,
                     int basePort,
                     int communicationMode,
                     boolean persistentConnection)
        throws IOException, UnknownHostException, CycApiException {
        this(hostName,
             basePort,
             communicationMode,
             persistentConnection,
             false);
    }

    /**
     * Constructs a new CycAccess object given a host name, port,
     * communication mode, persistence indicator and legacy mode.
     *
     * @@param hostName the host name
     * @@param basePort the base (HTML serving) TCP socket port number
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     * @@param isLegacyMode indicates if legacy OpenCyc server compatibility is desired
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess(String hostName,
                     int basePort,
                     int communicationMode,
                     boolean persistentConnection,
                     boolean isLegacyMode)
        throws IOException, UnknownHostException, CycApiException {
        this.hostName = hostName;
        this.port = basePort;
        this.communicationMode = communicationMode;
        this.persistentConnection = persistentConnection;
        this.isLegacyMode = isLegacyMode;
        if (persistentConnection)
            cycConnection = new CycConnection(hostName, port, communicationMode, this);
        commonInitialization();
    }

    /**
     * Constructs a new CycAccess object given a host name, port, communication mode,
     * persistence indicator, and messaging mode
     *
     * @@param hostName the host name
     * @@param basePort the base (HTML serving) TCP socket port number
     * @@param communicationMode either ASCII_MODE or BINARY_MODE
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     * @@param messagingMode either SERIAL_MESSAGING_MODE or CONCURRENT_MESSAGING_MODE
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAccess(String hostName,
                     int basePort,
                     int communicationMode,
                     boolean persistentConnection,
                     int messagingMode)
        throws IOException, UnknownHostException, CycApiException {
        this.hostName = hostName;
        this.port = basePort;
        if (messagingMode == CycConnection.CONCURRENT_MESSAGING_MODE)
            if (persistentConnection != PERSISTENT_CONNECTION)
                throw new CycApiException("Concurrent Messaging requires Persistent Connections");
        this.communicationMode = communicationMode;
        this.persistentConnection = persistentConnection;
        this.messagingMode = messagingMode;
        if (persistentConnection)
            cycConnection = new CycConnection(hostName,
                                              port,
                                              communicationMode,
                                              messagingMode,
                                              this);
        commonInitialization();
    }

    /**
     * Provides common local and remote CycAccess object initialization.
     *
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    protected  void commonInitialization() throws IOException, CycApiException {
        if (Log.current == null)
            Log.makeLog("cyc-api.log");
        cycAccessInstances.put(Thread.currentThread(), this);
        if (sharedCycAccessInstance == null)
            sharedCycAccessInstance = this;
        initializeConstants();
    }

    /**
     * Returns a string representation of this object.
     *
     * @@return a string representation of this object
     */
    public String toString() {
        return cycConnection.connectionInfo();
    }

    /**
     * Returns the <tt>CycAccess</tt> object for this thread.
     *
     * @@return the <tt>CycAccess</tt> object for this thread
     */
    public static CycAccess current() {
        CycAccess cycAccess = (CycAccess) cycAccessInstances.get(Thread.currentThread());
        if (cycAccess == null) {
            if (sharedCycAccessInstance != null)
                return sharedCycAccessInstance;
            else
                throw new RuntimeException("No CycAccess object for this thread");
            }
        return cycAccess;
    }

    /**
     * Sets the shared <tt>CycAccess</tt> instance.
     *
     * @@param the shared <tt>CycAccess</tt> instance
     */
    public static void setSharedCycAccessInstance (CycAccess sharedCycAccessInstance) {
        CycAccess.sharedCycAccessInstance = sharedCycAccessInstance;
    }

    /**
     * Turns on the diagnostic trace of socket messages.
     */
    public void traceOn() {
        cycConnection.traceOn();
        saveTrace = CycConnection.API_TRACE_MESSAGES;
    }

    /**
     * Turns on the detailed diagnostic trace of socket messages.
     */
    public void traceOnDetailed() {
        if (cycConnection != null)
            cycConnection.traceOnDetailed();
        saveTrace = CycConnection.API_TRACE_DETAILED;
    }

    /**
     * Turns off the diagnostic trace of socket messages.
     */
    public void traceOff() {
        cycConnection.traceOff();
        saveTrace = CycConnection.API_TRACE_NONE;
    }

    /**
     * Turns on the diagnostic trace of messages with constant names
     * looked up via recursive api request.
     */
    public void traceNamesOn()  {
        traceWithNames = true;
    }

    /**
     * Turns on the diagnostic trace of messages with constant names
     * looked up via recursive api request.
     */
    public void traceNamesOff() {
        traceWithNames = false;
    }

    /**
     * Returns the CycConnection object.
     *
     * @@return the CycConnection object
     */
    public CycConnectionInterface getCycConnection() {
        return cycConnection;
    }

    /**
     * Closes the CycConnection object.
     */
    public void close() {
        if (cycConnection != null) {
            if (cycConnection instanceof RemoteCycConnection)
                try {
                    this.converseVoid(CycObjectFactory.END_CYC_CONNECTION);
                }
                catch (UnknownHostException e) {
                }
                catch (IOException e) {
                }
                catch (CycApiException e) {
                }
            cycConnection.close();
        }
        cycAccessInstances.remove(Thread.currentThread());
d2479 2
a2480 12
    /**
     * Returns the communication mode.
     *
     * @@return the communication mode
     */
    public int getCommunicationMode() {
        return communicationMode;
    }

    protected class TraceWithNamesInfo {
        public boolean traceWithNames;
        public boolean bypassConstantNameRequest;
d2482 35
a2516 2
        public TraceWithNamesInfo() {
        }
d2519 2
d2522 77
a2598 33
    /**
     * Converses with Cyc to perform an API command.  Creates a new connection for this command
     * if the connection is not persistent.
     *
     * @@param command the command string or CycList
     * @@return the result as an object array of two objects
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    protected Object [] converse(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};

        // stack discipline is required to prevent tracing of recursive
        // name-seeking api requests.
        TraceWithNamesInfo traceWithNamesInfo = new TraceWithNamesInfo();
        boolean bypassConstantNameRequest = false;
        if (traceWithNames) {
            traceWithNamesInfo.traceWithNames = true;
            CycList commandCyclist;
            if (command instanceof String)
                commandCyclist = this.makeCycList((String) command);
            else
                commandCyclist = (CycList) command;

            if (commandCyclist.first().equals(CycObjectFactory.makeCycSymbol("constant-name")))
                traceWithNamesInfo.bypassConstantNameRequest = true;
            else
                Log.current.println(commandCyclist.cyclify() + " --> cyc");
            traceWithNames = false;
        }
        traceWithNamesStack.push(traceWithNamesInfo);
a2599 28
        if (! persistentConnection) {
            cycConnection = new CycConnection(hostName,
                                              port,
                                              communicationMode,
                                              messagingMode,
                                              this);
            cycConnection.setTrace(saveTrace);
        }
        response = cycConnection.converse(command);
        if (! persistentConnection) {
            saveTrace = cycConnection.getTrace();
            cycConnection.close();
        }
        traceWithNamesInfo = (TraceWithNamesInfo) traceWithNamesStack.pop();
        traceWithNames = traceWithNamesInfo.traceWithNames;
        bypassConstantNameRequest = traceWithNamesInfo.bypassConstantNameRequest;
        if (traceWithNames && ! bypassConstantNameRequest) {
            String responseString;
            if (response[1] instanceof CycList)
                responseString = ((CycList) response[1]).cyclify();
            else if (response[1] instanceof CycFort)
                responseString = ((CycFort) response[1]).cyclify();
            else
                responseString = response[1].toString();
            Log.current.println("cyc --> " + responseString);
        }
        return response;
    }
d2601 2
a2602 24
    /**
     * Converses with Cyc to perform an API command whose result is returned as an object.
     *
     * @@param command the command string or CycList
     * @@return the result of processing the API command
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Object converseObject(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.TRUE))
            return response[1];
        else {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
d2605 2
a2606 29
    /**
     * Converses with Cyc to perform an API command whose result is returned as a list.  The symbol
     * nil is returned as the empty list.
     *
     * @@param command the command string or CycList
     * @@return the result of processing the API command
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList converseList(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.TRUE))
            if (response[1].equals(CycObjectFactory.nil))
                return new CycList();
            else
                return (CycList) response[1];
        else {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
    }
d2608 35
a2642 29
    /**
     * Converses with Cyc to perform an API command whose result is returned as a String.
     *
     * @@param command the command string or CycList
     * @@return the result of processing the API command
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String converseString(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            if (! (response[1] instanceof String))
                throw new RuntimeException("Expected String but received (" + response[1].getClass() + ") " +
                                           response[1] + "\n in response to command " + command);
            return (String) response[1];
        }
        else {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
    }
a2643 29
    /**
     * Converses with Cyc to perform an API command whose result is returned as a boolean.
     *
     * @@param command the command string or CycList
     * @@return the result of processing the API command
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean converseBoolean(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            if (response[1].toString().equals("T"))
                return true;
            else
                return false;
        }
        else {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
    }
d2645 2
a2646 25
    /**
     * Converses with Cyc to perform an API command whose result is returned as an int.
     *
     * @@param command the command string or CycList
     * @@return the result of processing the API command
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int converseInt(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            return (new Integer(response[1].toString())).intValue();
        }
        else {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
d2649 2
a2650 22
    /**
     * Converses with Cyc to perform an API command whose result is void.
     *
     * @@param command the command string or CycList
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void converseVoid(Object command)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        response = converse(command);
        if (response[0].equals(Boolean.FALSE)) {
            String request;
            if (command instanceof CycList)
                request = ((CycList) command).cyclify();
            else
                request = (String) command;
            throw new CycApiException(response[1].toString() +
                                      "\nrequest: " + request);
        }
    }
d2652 574
a3225 151
    /**
     * Sets the *print-readable-narts* feature on.
     *
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void setReadableNarts ()
        throws IOException, UnknownHostException, CycApiException {
        converseVoid("(csetq *print-readable-narts t)");
    }

    /**
     * Initializes common cyc constants.
     *
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    private void initializeConstants()
        throws IOException, UnknownHostException, CycApiException {
        if (baseKB == null)
            baseKB = getKnownConstantByGuid("bd588111-9c29-11b1-9dad-c379636f7270");
        if (isa == null)
            isa = getKnownConstantByGuid("bd588104-9c29-11b1-9dad-c379636f7270");
        if (genls == null)
            genls = getKnownConstantByGuid("bd58810e-9c29-11b1-9dad-c379636f7270");
        if (genlMt == null)
            genlMt = getKnownConstantByGuid("bd5880e5-9c29-11b1-9dad-c379636f7270");
        if (comment == null)
            comment = getKnownConstantByGuid("bd588109-9c29-11b1-9dad-c379636f7270");
        if (collection == null)
            collection = getKnownConstantByGuid("bd5880cc-9c29-11b1-9dad-c379636f7270");
        if (binaryPredicate == null)
            binaryPredicate = getKnownConstantByGuid("bd588102-9c29-11b1-9dad-c379636f7270");
        if (elementOf == null)
            elementOf = getKnownConstantByGuid("c0659a2b-9c29-11b1-9dad-c379636f7270");
        if (and == null)
            and = getKnownConstantByGuid("bd5880f9-9c29-11b1-9dad-c379636f7270");
        if (or == null)
            or = getKnownConstantByGuid("bd5880fa-9c29-11b1-9dad-c379636f7270");
        if (not == null)
            not = getKnownConstantByGuid("bd5880fb-9c29-11b1-9dad-c379636f7270");
        if (numericallyEqual == null)
            //numericallyEqual = getKnownConstantByGuid("bd589d90-9c29-11b1-9dad-c379636f7270");
            numericallyEqual = getConstantByGuid(new Guid("bd589d90-9c29-11b1-9dad-c379636f7270"));
        if (plusFn == null)
            plusFn = getKnownConstantByGuid("bd5880ae-9c29-11b1-9dad-c379636f7270");
        if (different == null)
            different = getKnownConstantByGuid("bd63f343-9c29-11b1-9dad-c379636f7270");
        if (thing == null)
            thing = getKnownConstantByGuid("bd5880f4-9c29-11b1-9dad-c379636f7270");
        if (inferencePSC == null)
            inferencePSC = getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        if ((! isLegacyMode) && (universalVocabularyMt == null))
            universalVocabularyMt = getKnownConstantByGuid("dff4a041-4da2-11d6-82c0-0002b34c7c9f");
        if (bookkeepingMt == null)
            bookkeepingMt = getKnownConstantByGuid("beaed5bd-9c29-11b1-9dad-c379636f7270");
    }

    /**
     * Gets a known CycConstant by using its constant name.
     *
     * @@param constantName the name of the constant to be instantiated
     * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
     */
    public CycConstant getKnownConstantByName (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant cycConstant = getConstantByName(constantName);
        if (cycConstant == null)
            throw new CycApiException("Expected constant not found " + constantName);
        return cycConstant;
    }

    /**
     * Gets a CycConstant by using its constant name.
     *
     * @@param constantName the name of the constant to be instantiated
     * @@return the complete <tt>CycConstant</tt> if found, otherwise return null
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant getConstantByName (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        String name = constantName;
        if (constantName.startsWith("#$"))
            name = name.substring(2);
        CycConstant answer = CycObjectFactory.getCycConstantCacheByName(name);
        if (answer != null)
            return answer;
        answer = new CycConstant();
        answer.setName(name);
        Integer id = getConstantId(name);
        if (id == null)
            return null;
        answer.setId(id);
        answer.setGuid(getConstantGuid(name));
        CycObjectFactory.addCycConstantCacheByName(answer);
        CycObjectFactory.addCycConstantCacheById(answer);
        return answer;
    }

    /**
     * Gets the ID for the given CycConstant.
     *
     * @@param cycConstant the <tt>CycConstant</tt> object for which the id is sought
     * @@return the ID for the given CycConstant, or null if the constant does not exist.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Integer getConstantId (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return getConstantId(cycConstant.getName());
    }

    /**
     * Gets the ID for the given constant name.
     *
     * @@param constantName the name of the constant object for which the id is sought
     * @@return the ID for the given constant name, or null if the constant does not exist.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Integer getConstantId (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        String command;
        if (isLegacyMode)
            command = "(boolean (find-constant \"" + constantName + "\"))";
        else
            command = "(cand (boolean (find-constant \"" + constantName + "\"))\n" +
            "      (valid-constant (find-constant \"" + constantName + "\")))";
        boolean constantExists = converseBoolean(command);
        if (constantExists) {
            command = "(constant-internal-id (find-constant \"" + constantName + "\"))";
            try {
                return new Integer(converseInt(command));
            }
            catch (NumberFormatException e) {
                e.printStackTrace();
                throw new RuntimeException("NumberFormatException\n" + e.getMessage() +
                                           "\nConstantName: " + constantName);
            }
        }
        else
            return null;
d3228 2
a3229 409
    /**
     * Gets the Guid for the given CycConstant, raising an exception if the constant does not
     * exist.
     *
     * @@param cycConstant the <tt>CycConstant</tt> object for which the id is sought
     * @@return the Guid for the given CycConstant
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Guid getConstantGuid (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return getConstantGuid(cycConstant.getName());
    }

    /**
     * Gets the Guid for the given constant name, raising an exception if the constant does not
     * exist.
     *
     * @@param constantName the name of the constant object for which the Guid is sought
     * @@return the Guid for the given CycConstant
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Guid getConstantGuid (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        String command = "(guid-to-string (constant-external-id (find-constant \"" +
                         constantName + "\")))";
        return CycObjectFactory.makeGuid(converseString(command));
    }

    /**
     * Gets the Guid for the given constant id.
     *
     * @@param id the id of the <tt>CycConstant</tt> whose guid is sought
     * @@return the Guid for the given CycConstant
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Guid getConstantGuid (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        // Optimized for the binary api.
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("guid-to-string"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("constant-external-id"));
        CycList command2 = new CycList();
        command1.add(command2);
        command2.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
        command2.add(id);
        return CycObjectFactory.makeGuid(converseString(command));
    }

    /**
     * Gets a <tt>CycConstant</tt> by using its ID.
     *
     * @@param id the id of the <tt>CycConstant</tt> sought
     * @@return the <tt>CycConstant</tt> if found or <tt>null</tt> if not found
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant getConstantById (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        // Optimized for the binary api.
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("boolean"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
        command1.add(id);
        boolean constantExists = converseBoolean(command);
        if (! constantExists)
            return null;
        CycConstant answer = new CycConstant();
        answer.setName(getConstantName(id));
        answer.setId(id);
        answer.setGuid(getConstantGuid(id));
        CycObjectFactory.addCycConstantCacheByName(answer);
        CycObjectFactory.addCycConstantCacheById(answer);
        return answer;
    }

    /**
     * Gets the name for the given constant id.
     *
     * @@param id the id of the constant object for which the name is sought
     * @@return the name for the given CycConstant
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getConstantName (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        // Optimized for the binary api.
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("constant-name"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-internal-id"));
        command1.add(id);
        return converseString(command);
    }

    /**
     * Gets the name for the given variable id.
     *
     * @@param id the id of the variable object for which the name is sought
     * @@return the name for the given CycVariable
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getVariableName (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        // Optimized for the binary api.
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("variable-name"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("find-variable-by-id"));
        command1.add(id);
        return converseString(command);
    }

    /**
     * Gets a known CycConstant by using its GUID string.
     *
     * @@param guid the globally unique ID string of the constant to be instantiated
     * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant getKnownConstantByGuid (String guidString)
        throws IOException, UnknownHostException, CycApiException {
        Guid guid = CycObjectFactory.makeGuid(guidString);
        return getKnownConstantByGuid(guid);
    }

    /**
     * Gets a known CycConstant by using its GUID.
     *
     * @@param guid the globally unique ID of the constant to be instantiated
     * @@return the complete <tt>CycConstant</tt> if found, otherwise throw an exception
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant getKnownConstantByGuid (Guid guid)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant cycConstant = getConstantByGuid(guid);
        if (cycConstant == null)
            throw new CycApiException("Expected constant not found " + guid);
        return cycConstant;
    }

    /**
     * Gets a CycConstant by using its GUID.
     *
     * @@param guid the GUID from which to find the constant
     * @@return the complete <tt>CycConstant</tt> if found, otherwise return <tt>null</tt>
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant getConstantByGuid (Guid guid)
        throws IOException, UnknownHostException, CycApiException {
        String command = "(boolean (find-constant-by-external-id (string-to-guid \"" + guid + "\")))";
        boolean constantExists = converseBoolean(command);
        if (! constantExists)
            return null;
        command = "(constant-name (find-constant-by-external-id (string-to-guid \"" + guid + "\")))";
        String constantName = this.converseString(command);
        return getConstantByName(constantName);
    }

    /**
     * Completes the instantiation of objects contained in the given <tt>CycList</tt>. The
     * binary api sends only constant ids, and the constant names and guids must be retrieved if the constant is
     * not cached.
     *
     * @@param object the <tt>CycConstant</tt> to be completed, or the <tt>Object</tt> whose
     * embedded constants are to be completed
     * @@return the completed object, or a reference to a cached instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Object completeObject (Object object)
        throws IOException, UnknownHostException, CycApiException {
        if (object instanceof CycConstant)
            return completeCycConstant((CycConstant) object);
        else if (object instanceof CycList)
            return completeCycList((CycList) object);
        else if (object instanceof CycNart)
            return completeCycNart((CycNart) object);
        else if (object instanceof CycAssertion)
            return completeCycAssertion((CycAssertion) object);
        else
            return object;
    }

    /**
     * Completes the instantiation of <tt>CycConstant</tt> returned by the binary api. The
     * binary api sends only constant ids, and the constant names and guids must be retrieved
     * if the constant is not cached.
     *
     * @@param cycConstant the <tt>CycConstant</tt> whose name and guid are to be completed
     * @@return the completed <tt>CycConstant</tt> object, or a reference to the previously cached instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant completeCycConstant (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        cycConstant.setName(getConstantName(cycConstant.getId()));
        CycConstant cachedConstant = CycObjectFactory.getCycConstantCacheByName(cycConstant.getName());
        if (cachedConstant == null) {
            cycConstant.setGuid(getConstantGuid(cycConstant.getId()));
            CycObjectFactory.addCycConstantCacheByName(cycConstant);
            return cycConstant;
        }
        else
            return cachedConstant;
    }

    /**
     * Completes the instantiation of HL <tt>CycVariable</tt> returned by the binary api. The
     * binary api sends only HL variable ids, and the variable name must be retrieved
     * if the variable is not cached.  The variable id is not used when sending variables to
     * the binary api, instead the variable is output as a symbol.  In the case where an EL
     * variable is returned by the binary api, then then variable name is already present.
     *
     * @@param cycVariable the <tt>CycVariable</tt> whose name is to be completed
     * @@return the completed <tt>CycVariable</tt> object, or a reference to the previously
     * cached instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycVariable completeCycVariable (CycVariable cycVariable)
        throws IOException, UnknownHostException, CycApiException {
        if (cycVariable.name == null)
            cycVariable.name = getVariableName(cycVariable.id);
        CycVariable cachedVariable = CycObjectFactory.getCycVariableCache(cycVariable.name);
        if (cachedVariable == null) {
            CycObjectFactory.addCycVariableCache(cycVariable);
            return cycVariable;
        }
        else
            return cachedVariable;
    }

    /**
     * Completes the instantiation of objects contained in the given <tt>CycList</tt>. The
     * binary api sends only constant ids, and the constant names and guids must be retrieved if the constant is
     * not cached.
     *
     * @@param cycList the <tt>CycList</tt> whose constants are to be completed
     * @@param the completed <tt>CycList</tt> object
     * @@return the given list with completed objects
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList completeCycList (CycList cycList)
        throws IOException, UnknownHostException, CycApiException {
        for (int i = 0; i < cycList.size(); i++) {
            Object element = cycList.get(i);
            if (element instanceof CycList)
                completeCycList((CycList) element);
            else if (element instanceof CycConstant)
                // Replace element with the completed constant, which might be previously cached.
                cycList.set(i, completeCycConstant((CycConstant) element));
            else if (element instanceof CycNart)
                // Replace element with the completed constant, which might be previously cached.
                cycList.set(i, completeCycNart((CycNart) element));
            else if (element instanceof CycVariable)
                // Replace element with the completed variable, which might be previously cached.
                cycList.set(i, completeCycVariable((CycVariable) element));
            else
                completeObject(element);
        }
        return cycList;
    }

    /**
     * Completes the instantiation of a <tt>CycNart</tt> returned by the binary api. The
     * binary api sends only constant ids, and the constant names and guids must be retrieved
     * if the constant is not cached.  Also finds the id of the CycNart if the functor
     * and arguments are instantiated.
     *
     * @@param cycNart the <tt>CycNart</tt> whose constants are to be completed
     * @@param the completed <tt>CycNart</tt> object
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycNart completeCycNart (CycNart cycNart)
        throws IOException, UnknownHostException, CycApiException {
        Integer id = cycNart.getId();
        if (id == null && cycNart.hasFunctorAndArgs()) {
            id = findNartId(cycNart);
            if (id != null)
                cycNart.setId(id);
        }
        if (id == null)
            throw new CycApiException("CycNart has no id " + cycNart.safeToString());
        return getCycNartById(cycNart.getId());
    }

    /**
     * Completes the instantiation of a <tt>CycAssertion</tt> returned by the binary api. The
     * binary api sends only constant ids, and the constant names and guids must be retrieved
     * if the constant is not cached.
     *
     * @@param cycAssertion the <tt>CycAssertion</tt> whose constants are to be completed
     * @@param the completed <tt>CycAssertion</tt> object
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAssertion completeCycAssertion (CycAssertion cycAssertion)
        throws IOException, UnknownHostException, CycApiException {
        return getAssertionById(cycAssertion.getId());
    }

    /**
     * Finds the id of a CycNart given its formula.
     *
     * @@param cycNart the CycNart object with functor and arguments instantiated
     * @@return the id of the nart if found in the KB, otherwise null
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Integer findNartId (CycNart cycNart)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("find-nart"));
        command.addQuoted(cycNart.toCycList());
        Object object = converseObject(command);
        if (object.equals(CycObjectFactory.nil))
            return null;
        CycNart foundCycNart = null;
        if (object instanceof CycNart)
            foundCycNart = (CycNart) object;
        else
            throw new CycApiException("findNart did not return an null or a nart " + object +
                                      " (" + object.getClass() + ")");
        command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("nart-id"));
        command.add(foundCycNart);
        return new Integer(converseInt(command));
    }

    /**
     * Gets a CycNart by using its id.
     *
     * @@param id the nart id (local to the KB)
     * @@return the CycNart
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycNart getCycNartById (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        CycNart cycNart = CycObjectFactory.getCycNartCache(id);
        if (cycNart != null) {
            return cycNart;
        }
        else {
            cycNart = new CycNart();
            cycNart.setId(id);
        }
        CycObjectFactory.addCycNartCache(cycNart);
        CycList command = new CycList();
        if (communicationMode == CycConnection.BINARY_MODE) {
            command.add(CycObjectFactory.makeCycSymbol("nart-hl-formula"));
            CycList command1 = new CycList();
            command.add(command1);
            command1.add(CycObjectFactory.makeCycSymbol("find-nart-by-id"));
            command1.add(id);
            CycList formula = converseList(command);
            cycNart.setFunctor((CycFort) formula.first());
            cycNart.setArguments((CycList) formula.rest());
        }
        else {
            command.add(CycObjectFactory.makeCycSymbol("nart-el-formula"));
            CycList command1 = new CycList();
            command.add(command1);
            command1.add(CycObjectFactory.makeCycSymbol("find-nart-by-id"));
            command1.add(id);
            CycList formula = converseList(command);
            cycNart.setFunctor((CycFort) formula.first());
            cycNart.setArguments((CycList) formula.rest());
            List arguments = cycNart.getArguments();
            for (int i = 0; i < arguments.size(); i++) {
                Object argument = arguments.get(i);
                if (argument instanceof CycList)
                    arguments.set(i, new CycNart((CycList) argument));
            }
        }
        return cycNart;
    }
d3231 32
a3262 73
    /**
     * Gets a CycAssertion by using its id.
     *
     * @@param id the assertion id (which is local to the given KB).
     * @@return the assertion
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycAssertion getAssertionById (Integer id)
        throws IOException, UnknownHostException, CycApiException {
        CycAssertion cycAssertion = CycObjectFactory.getAssertionCache(id);
        if (cycAssertion != null) {
            if (cycAssertion.getFormula() != null)
                return cycAssertion;
        }
        else
            cycAssertion = new CycAssertion(id);
        CycObjectFactory.addAssertionCache(cycAssertion);
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("assertion-el-formula"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("find-assertion-by-id"));
        command1.add(id);
        cycAssertion.setFormula(converseList(command));
        return cycAssertion;
    }

    /**
     * Gets the CycNart object from a Cons object that lists the names of
     * its functor and its arguments.
     *
     * @@param elCons the given list which names the functor and arguments
     * @@return a CycNart object from a Cons object that lists the names of
     * its functor and its arguments
     */
    public CycNart getCycNartFromCons(CycList elCons) {
        return new CycNart(elCons);
    }

    /**
     * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
     *
     * @@param binaryPredicate the predicate
     * @@param arg1 the first argument related by the predicate
     * @@param arg2 the second argument related by the predicate
     * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean predicateRelates (CycConstant binaryPredicate,
                                     CycFort arg1,
                                     CycFort arg2)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        String command = "(pred-u-v-holds-in-any-mt " +
            binaryPredicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
            arg2.stringApiValue() + ")";
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            if (response[1] == null)
                return false;
            else if (response[1].toString().equals("T"))
                return true;
            else
                return false;
        }
        else
            throw new CycApiException(response[1].toString());
a3264 1045
    /**
     * Returns true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2.
     *
     * @@param binaryPredicate the predicate
     * @@param arg1 the first argument related by the predicate
     * @@param arg2 the second argument related by the predicate
     * @@param mt the relevant mt
     * @@return true if CycConstant BINARYPREDICATE relates CycFort ARG1 and CycFort ARG2
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean predicateRelates (CycConstant binaryPredicate,
                                     CycFort arg1,
                                     CycFort arg2,
                                     ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        Object [] response = {null, null};
        String command = "(pred-u-v-holds " +
            binaryPredicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
            arg2.stringApiValue() + " " +
            mt.stringApiValue() + ")";
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            if (response[1] == null)
                return false;
            else if (response[1].toString().equals("T"))
                return true;
            else
                return false;
        }
        else
            throw new CycApiException(response[1].toString());
    }

    /**
     * Gets the imprecise plural generated phrase for a CycFort (intended for collections).
     *
     * @@param cycFort the term for paraphrasing
     * @@return the imprecise plural generated phrase for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getImprecisePluralGeneratedPhrase (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-off (generate-phrase " + cycFort.stringApiValue() + " '(#$plural)))");
    }

    /**
     * Gets the plural generated phrase for a CycFort (intended for collections).
     *
     * @@param cycFort the term for paraphrasing
     * @@return the plural generated phrase for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getPluralGeneratedPhrase (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycFort.stringApiValue() + " '(#$plural)))");
    }

    /**
     * Gets the imprecise singular generated phrase for a CycFort (intended for individuals).
     *
     * @@param cycFort the term for paraphrasing
     * @@return the singular generated phrase for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getImpreciseSingularGeneratedPhrase (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-off (generate-phrase " + cycFort.stringApiValue() + " '(#$singular)))");
    }

    /**
     * Gets the singular generated phrase for a CycFort (intended for individuals).
     *
     * @@param cycFort the term for paraphrasing
     * @@return the singular generated phrase for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getSingularGeneratedPhrase (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycFort.stringApiValue() + " '(#$singular)))");
    }

    /**
     * Gets the default generated phrase for a CycFort (intended for predicates).
     *
     * @@param cycFort the predicate term for paraphrasing
     * @@return the default generated phrase for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getGeneratedPhrase (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the paraphrase for a Cyc assertion.
     *
     * @@param assertion the assertion formula
     * @@return the paraphrase for a Cyc assertion
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getParaphrase (CycList assertion)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-on (generate-phrase '" + assertion.cyclify() + "))");
    }

    /**
     * Gets the imprecise paraphrase for a Cyc assertion.
     *
     * @@param assertionString the assertion formula
     * @@return the imprecise paraphrase for a Cyc assertion
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getImpreciseParaphrase (String assertionString)
        throws IOException, UnknownHostException, CycApiException {
        CycList assertion = this.makeCycList(assertionString);
        return converseString("(with-precise-paraphrase-off (generate-phrase '" + assertion.cyclify() + "))");
    }

    /**
     * Gets the imprecise paraphrase for a Cyc assertion.
     *
     * @@param assertion the assertion formula
     * @@return the imprecise paraphrase for a Cyc assertion
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getImpreciseParaphrase (CycList assertion)
        throws IOException, UnknownHostException, CycApiException {
        return converseString("(with-precise-paraphrase-off (generate-phrase '" + assertion.cyclify() + "))");
    }

    /**
     * Gets the comment for a CycFort.  Embedded quotes are replaced by spaces.
     *
     * @@param cycFort the term for which the comment is sought
     * @@return the comment for the given CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getComment (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        String script =
            "(clet ((comment-string \n" +
            "         (with-all-mts (comment " + cycFort.stringApiValue() + ")))) \n" +
            "  (fif comment-string \n" +
            "       (string-substitute \" \" \"\\\"\" comment-string) \n" +
            "       \"\"))";
        return converseString(script);
    }

    /**
     * Gets the comment for a CycFort in the relevant mt.
     * Embedded quotes are replaced by spaces.
     *
     * @@param cycFort the term for which the comment is sought
     * @@param mt the relevant mt from which the comment is visible
     * @@return the comment for the given CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public String getComment (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String script =
            "(clet ((comment-string \n" +
            "         (comment " + cycFort.stringApiValue() + " " + mt.stringApiValue() + "))) \n" +
            "  (fif comment-string \n" +
            "       (string-substitute \" \" \"\\\"\" comment-string) \n" +
            "       \"\"))";
        return converseString(script);
    }

    /**
     * Gets the list of the isas for the given CycFort.
     *
     * @@param cycFort the term for which its isas are sought
     * @@return the list of the isas for the given CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getIsas (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (isa " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the isas for the given CycFort.
     *
     * @@param cycFort the term for which its isas are sought
     * @@param mt the relevant mt
     * @@return the list of the isas for the given CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getIsas (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(isa " + cycFort.stringApiValue() +
                              " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the directly asserted true genls for the given CycFort collection.
     *
     * @@param cycFort the given term
     * @@return the list of the directly asserted true genls for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenls (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (genls " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the directly asserted true genls for the given CycFort collection.
     *
     * @@param cycFort the given term
     * @@param mt the relevant mt
     * @@return the list of the directly asserted true genls for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenls (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(genls " + cycFort.stringApiValue() +
                              " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the minimum (most specific) genls for a CycFort collection.
     *
     * @@param cycFort the given collection term
     * @@return a list of the minimum (most specific) genls for a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMinGenls (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (min-genls " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets a list of the minimum (most specific) genls for a CycFort collection.
     *
     * @@param cycFort the collection
     * @@param mt the microtheory in which to look
     * @@return a list of the minimum (most specific) genls for a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMinGenls (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(min-genls " + cycFort.stringApiValue() +
                              " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the directly asserted true specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the directly asserted true specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSpecs (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (specs " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the directly asserted true specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the microtheory in which to look
     * @@return the list of the directly asserted true specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSpecs (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(specs " + cycFort.stringApiValue() +
                              " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the least specific specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the least specific specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMaxSpecs (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (max-specs " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the least specific specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the microtheory in which to look
     * @@return the list of the least specific specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMaxSpecs (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(max-specs " + cycFort.stringApiValue() +
                              " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the direct genls of the direct specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the direct genls of the direct specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenlSiblings (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (genl-siblings " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the direct genls of the direct specs for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the microtheory in which to look
     * @@return the list of the direct genls of the direct specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenlSiblings (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(genl-siblings " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSiblings (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return getSpecSiblings(cycFort);
    }

    /**
     * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the microtheory in which to look
     * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSiblings (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return getSpecSiblings(cycFort, mt);
    }

    /**
     * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSpecSiblings (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (spec-siblings " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the siblings (direct specs of the direct genls) for the given CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the microtheory in which to look
     * @@return the list of the siblings (direct specs of the direct genls) for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSpecSiblings (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(spec-siblings " + cycFort.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of all of the direct and indirect genls for the given CycFort collection.
     *
     * @@param cycFort the collection
     * @@return the list of all of the direct and indirect genls for a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenls (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-genls-in-any-mt " + cycFort.stringApiValue() + ")");
    }

    /**
     * Gets the list of all of the direct and indirect genls for a CycFort collection
     * given a relevant microtheory.
     *
     * @@param cycFort the collection
     * @@param mt the relevant mt
     * @@return the list of all of the direct and indirect genls for a CycFort collection
     * given a relevant microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenls (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-genls " + cycFort.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of all of the direct and indirect specs for a CycFort collection.
     *
     * @@param cycFort the collection
     * @@return the list of all of the direct and indirect specs for the given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecs (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-specs " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the direct and indirect specs for the given collection
     * in the given microtheory.
     *
     * @@param cycFort the collection
     * @@return the list of all of the direct and indirect specs for the given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecs (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-specs " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a hashset of all of the direct and indirect specs for a CycFort collection.
     *
     * @@param cycFort the collection
     * @@return the hashset of all of the direct and indirect specs for the given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecsHashSet (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecs(cycFort));
    }

    /**
     * Gets the hashset of all of the direct and indirect specs for the given collection
     * in the given microtheory.
     *
     * @@param cycFort the collection
     * @@return the hashset of all of the direct and indirect specs for the given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecsHashSet (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecs(cycFort, mt));
    }

    /**
     * Gets the list of all of the direct and indirect genls for a CycFort SPEC which are also specs of
     * CycFort GENL.
     *
     * @@param spec the given collection
     * @@param genl the more general collection
     * @@return the list of all of the direct and indirect genls for a CycFort SPEC which are also specs of
     * CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenlsWrt (CycFort spec, CycFort genl)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-genls-wrt " + spec.stringApiValue() + " " + genl.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the direct and indirect genls for a CycFort SPEC which are also specs of
     * CycFort GENL.
     *
     * @@param spec the given collection
     * @@param genl the more general collection
     * @@param mt the relevant mt
     * @@return the list of all of the direct and indirect genls for a CycFort SPEC which are also specs of
     * CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenlsWrt (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-genls-wrt " + spec.stringApiValue() + " " + genl.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of all of the dependent specs for a CycFort collection.  Dependent specs are those direct and
     * indirect specs of the collection such that every path connecting the spec to a genl of the collection passes
     * through the collection.  In a typical taxomonmy it is expected that all-dependent-specs gives the same
     * result as all-specs.
     *
     * @@param cycFort the given collection
     * @@return the list of all of the dependent specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllDependentSpecs (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-dependent-specs " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the dependent specs for a CycFort collection.  Dependent specs are those direct and
     * indirect specs of the collection such that every path connecting the spec to a genl of the collection passes
     * through the collection.  In a typical taxomonmy it is expected that all-dependent-specs gives the same
     * result as all-specs.
     *
     * @@param cycFort the given collection
     * @@param mt the relevant mt
     * @@return the list of all of the dependent specs for the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllDependentSpecs (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-dependent-specs " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list with the specified number of sample specs of the given CycFort collection.
     * Attempts to return leaves that are maximally differet with regard to their all-genls.
     *
     * @@param cycFort the given collection
     * @@param numberOfSamples the maximum number of sample specs returned
     * @@return the list with the specified number of sample specs of the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSampleLeafSpecs (CycFort cycFort, int numberOfSamples)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (sample-leaf-specs " + cycFort.stringApiValue() + " " + numberOfSamples + "))");
    }

    /**
     * Gets the list with the specified number of sample specs of the given CycFort collection.
     * Attempts to return leaves that are maximally differet with regard to their all-genls.
     *
     * @@param cycFort the given collection
     * @@param numberOfSamples the maximum number of sample specs returned
     * @@param mt the relevant mt
     * @@return the list with the specified number of sample specs of the given CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getSampleLeafSpecs (CycFort cycFort, int numberOfSamples, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(sample-leaf-specs " + cycFort.stringApiValue() + " " + numberOfSamples +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns the single most specific collection from the given list of collectons.
     *
     * @@param collections the given collections
     * @@return the single most specific collection from the given list of collectons
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycFort getMinCol (CycList collections)
        throws IOException, UnknownHostException, CycApiException {
        return (CycFort) converseObject("(with-all-mts (min-col '" +
                                        collections.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort SPEC is a spec of CycFort GENL.
     *
     * @@param spec the considered spec collection
     * @@param genl the considered genl collection
     * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isSpecOf (CycFort spec, CycFort genl)
        throws IOException, UnknownHostException, CycApiException {
        return isGenlOf(genl, spec);
    }

    /**
     * Returns true if CycFort SPEC is a spec of CycFort GENL.
     *
     * @@param spec the considered spec collection
     * @@param genl the considered genl collection
     * @@param mt the relevant mt
     * @@return true if CycFort SPEC is a spec of CycFort GENL, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isSpecOf (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return isGenlOf(genl, spec, mt);
    }

    /**
     * Returns true if CycFort GENL is a genl of CycFort SPEC.
     *
     * @@param genl the collection for genl determination
     * @@param spec the collection for spec determination
     * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlOf (CycFort genl, CycFort spec)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(genl-in-any-mt? " + spec.stringApiValue() + " " + genl.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort GENL is a genl of CycFort SPEC, implements a cache
     * to avoid asking the same question twice from the KB.
     *
     * @@param genl the collection for genl determination
     * @@param spec the collection for spec determination
     * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlOf_Cached (CycFort genl, CycFort spec)
        throws IOException,  UnknownHostException, CycApiException {
        boolean answer;
        ArrayList args = new ArrayList();
        args.add(genl);
        args.add(spec);
        Boolean isGenlOf = (Boolean) isGenlOfCache.getElement(args);
        if (isGenlOf != null) {
            answer = isGenlOf.booleanValue();
            return answer;
        }
        answer = isGenlOf(genl, spec);
        isGenlOfCache.addElement(args, new Boolean(answer));
        return answer;
    }

    /**
     * Returns true if CycFort GENL is a genl of CycFort SPEC in MT.
     *
     * @@param genl the collection for genl determination
     * @@param spec the collection for spec determination
     * @@param mt the microtheory for spec determination
     * @@return <tt>true</tt> if CycFort GENL is a genl of CycFort SPEC in MT
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlOf (CycFort genl, CycFort spec, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(genl? " + spec.stringApiValue() +
                               " " + genl.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in MT.
     *
     * @@param genlPred the predicate for genl-pred determination
     * @@param specPred the predicate for spec-pred determination
     * @@param mt the microtheory for subsumption determination
     * @@return <tt>true</tt> if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in MT
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlPredOf (CycFort genlPred, CycFort specPred, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(genl-predicate? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort GENLPRED is a genl-pred of CycFort SPECPRED in any MT.
     *
     * @@param genlPred the predicate for genl-pred determination
     * @@param specPred the predicate for spec-pred determination
     * @@return <tt>true</tt> if CycFort GENLPRED is a genl-pred of CycFort SPECPRED
     * in any MT
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlPredOf (CycFort genlPred, CycFort specPred)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (genl-predicate? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in MT.
     *
     * @@param genlPred the predicate for genl-inverse determination
     * @@param specPred the predicate for spec-inverse determination
     * @@param mt the microtheory for inverse subsumption determination
     * @@return <tt>true</tt> if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in MT
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlInverseOf (CycFort genlPred, CycFort specPred, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(genl-inverse? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED in any MT.
     *
     * @@param genlPred the predicate for genl-inverse determination
     * @@param specPred the predicate for spec-inverse determination
     * @@return <tt>true</tt> if CycFort GENLPRED is a genl-inverse of CycFort SPECPRED
     * in any MT
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlInverseOf (CycFort genlPred, CycFort specPred)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (genl-inverse? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort GENLMT is a genl-mt of CycFort SPECPRED in *mt-mt*
     * (currently #$UniversalVocabularyMt).
     *
     * @@param genlMt the microtheory for genl-mt determination
     * @@param specMt the microtheory for spec-mt determination
     * @@return <tt>true</tt> if CycFort GENLMT is a genl-mt of CycFort SPECPRED in *mt-mt*
     * (currently #$UniversalVocabularyMt)
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isGenlMtOf (CycFort genlMt, CycFort specMt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(genl-mt? " + specMt.stringApiValue() +
                               " " + genlMt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional
     * via mutual genls of each other.
     *
     * @@param collection1 the first given collection
     * @@param collection2 the second given collection
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional
     * via mutual genls of each other, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areTacitCoextensional (CycFort collection1, CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (tacit-coextensional? " + collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional
     * via mutual genls of each other.
     *
     * @@param collection1 the first given collection
     * @@param collection2 the second given collection
     * @@param mt the relevant mt
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional
     * via mutual genls of each other, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areTacitCoextensional (CycFort collection1, CycFort collection2, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(tacit-coextensional? " + collection1.stringApiValue() +
                               " " + collection2.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areAssertedCoextensional (CycFort collection1, CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant coExtensional = this.getKnownConstantByGuid("bd59083a-9c29-11b1-9dad-c379636f7270");
        if (predicateRelates(coExtensional, collection1, collection2))
            return true;
        else if (predicateRelates(coExtensional, collection2, collection1))
            return true;
        else
            return false;
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are asserted coextensional
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areAssertedCoextensional (CycFort collection1,
                                             CycFort collection2,
                                             ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant coExtensional = this.getKnownConstantByGuid("bd59083a-9c29-11b1-9dad-c379636f7270");
        if (predicateRelates(coExtensional, collection1, collection2, mt))
            return true;
        else if (predicateRelates(coExtensional, collection2, collection1, mt))
            return true;
        else
            return false;
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areIntersecting (CycFort collection1, CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (collections-intersect? " + collection1.stringApiValue() + " " +
                               collection2.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 intersect with regard to all-specs
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areIntersecting (CycFort collection1, CycFort collection2, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(collections-intersect? " + collection1.stringApiValue() + " " +
                               collection2.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy,
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areHierarchical (CycFort collection1, CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (hierarchical-collections? " + collection1.stringApiValue() +
                               " " + collection2.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are in a hierarchy,
     * otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areHierarchical (CycFort collection1, CycFort collection2, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(hierarchical-collections? " + collection1.stringApiValue() +
                               collection2.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
     * getWhyGenl("Dog", "Animal") -->
     * "(((#$genls #$Dog #$CanineAnimal) :TRUE)
     *    (#$genls #$CanineAnimal #$NonPersonAnimal) :TRUE)
     *    (#$genls #$NonPersonAnimal #$Animal) :TRUE))
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@result the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyGenl (CycFort spec, CycFort genl)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (why-genl? " + spec.stringApiValue() + " " + genl.stringApiValue() + "))");
    }

    /**
     * Gets the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
     * getWhyGenl("Dog", "Animal") -->
     * "(((#$genls #$Dog #$CanineAnimal) :TRUE)
     *    (#$genls #$CanineAnimal #$NonPersonAnimal) :TRUE)
     *    (#$genls #$NonPersonAnimal #$Animal) :TRUE))
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@param mt the relevant mt
     * @@result the list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyGenl (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(why-genl? " + spec.stringApiValue() + " " + genl.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
     * getWhyGenlParaphrase("Dog", "Animal") -->
     * "a dog is a kind of canine"
     * "a canine is a kind of non-human animal"
     * "a non-human animal is a kind of animal"
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@return the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyGenlParaphrase (CycFort spec, CycFort genl)
        throws IOException, UnknownHostException, CycApiException {
        CycList listAnswer =
            converseList("(with-all-mts (why-genl? " +
                         spec.stringApiValue() + " " + genl.stringApiValue() + "))");
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        CycList iter = listAnswer;

        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            answerPhrases.add(getParaphrase(assertion));
        }

d3266 1
a3266 1
    }
d3268 862
a4129 30
    /**
     * Gets the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
     * getWhyGenlParaphrase("Dog", "Animal") -->
     * "a dog is a kind of canine"
     * "a canine is a kind of non-human animal"
     * "a non-human animal is a kind of animal"
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@param mt the relevant mt
     * @@return the English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort GENL
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyGenlParaphrase (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList listAnswer =
            converseList("(why-genl? " +
                         spec.stringApiValue() + " " + genl.stringApiValue() +
                         " " + mt.stringApiValue() + ")");
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        CycList iter = listAnswer;

        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            answerPhrases.add(getParaphrase(assertion));
        }
d4131 1400
a5530 1
    return answerPhrases;
d5533 2
a5534 67
    /**
     * Gets the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect.
     * see getWhyGenl
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyCollectionsIntersect (CycFort collection1,
                                               CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (why-collections-intersect? " +
                            collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
    }

    /**
     * Gets the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect.
     * see getWhyGenl
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return the list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyCollectionsIntersect (CycFort collection1,
                                               CycFort collection2,
                                               ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(why-collections-intersect? " +
                            collection1.stringApiValue() + " " + collection2.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
     * COLLECTION2 intersect.
     * see getWhyGenlParaphrase
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
     * COLLECTION2 intersect
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyCollectionsIntersectParaphrase (CycFort collection1,
                                                           CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        CycList listAnswer = converseList("(with-all-mts (why-collections-intersect? " +
                                          collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        CycList iter = listAnswer;

        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            //Log.current.println("assertion: " + assertion);
            answerPhrases.add(getParaphrase(assertion));
        }
d5536 71
a5606 2
    return answerPhrases;
    }
d5608 1
a5608 32
    /**
     * Gets the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
     * COLLECTION2 intersect.
     * see getWhyGenlParaphrase
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return the English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort
     * COLLECTION2 intersect
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyCollectionsIntersectParaphrase (CycFort collection1,
                                                           CycFort collection2,
                                                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList listAnswer = converseList("(with-all-mts (why-collections-intersect? " +
                                          collection1.stringApiValue() + " " +
                                          collection2.stringApiValue() +
                                          " " + mt.stringApiValue() + ")");
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        CycList iter = listAnswer;

        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            //Log.current.println("assertion: " + assertion);
            answerPhrases.add(getParaphrase(assertion));
        }
d5610 8
a5617 1
    return answerPhrases;
d5620 2
a5621 398
    /**
     * Gets the list of the collection leaves (most specific of the all-specs) for a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the collection leaves (most specific of the all-specs) for a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getCollectionLeaves (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (collection-leaves " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the list of the collection leaves (most specific of the all-specs) for a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the relevant mt
     * @@return the list of the collection leaves (most specific of the all-specs) for a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getCollectionLeaves (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(collection-leaves " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the collections asserted to be disjoint with a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the collections asserted to be disjoint with a CycFort collection
     */
    public CycList getLocalDisjointWith (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (local-disjoint-with " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the list of the collections asserted to be disjoint with a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the relevant mt
     * @@return the list of the collections asserted to be disjoint with a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getLocalDisjointWith (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(local-disjoint-with " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areDisjoint (CycFort collection1, CycFort collection2)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (disjoint-with? " + collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
    }

    /**
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint.
     *
     * @@param collection1 the first collection
     * @@param collection2 the second collection
     * @@param mt the relevant mt
     * @@return true if CycFort COLLECION1 and CycFort COLLECTION2 are disjoint, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean areDisjoint (CycFort collection1, CycFort collection2, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(with-all-mts (disjoint-with? " + collection1.stringApiValue() +
                               " " + collection2.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the most specific collections (having no subsets) which contain a CycFort term.
     *
     * @@param cycFort the given term
     * @@return the list of the most specific collections (having no subsets) which contain a CycFort term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMinIsas (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (min-isa " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the list of the most specific collections (having no subsets) which contain a CycFort term.
     *
     * @@param cycFort the given term
     * @@param mt the relevant mt
     * @@return the list of the most specific collections (having no subsets) which contain a CycFort term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getMinIsas (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(min-isa " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the instances (who are individuals) of a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@return the list of the instances (who are individuals) of a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInstances (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (instances " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the list of the instances (who are individuals) of a CycFort collection.
     *
     * @@param cycFort the given collection
     * @@param mt the relevant mt
     * @@return the list of the instances (who are individuals) of a CycFort collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInstances (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(instances " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the instance siblings of a CycFort, for all collections of which
     * it is an instance.
     *
     * @@param cycFort the given term
     * @@return the list of the instance siblings of a CycFort, for all collections of which
     * it is an instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInstanceSiblings (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (instance-siblings " + cycFort.stringApiValue() + "))");
    }

    /**
     * Gets the list of the instance siblings of a CycFort, for all collections of which
     * it is an instance.
     *
     * @@param cycFort the given term
     * @@param mt the relevant mt
     * @@return the list of the instance siblings of a CycFort, for all collections of which
     * it is an instance
     */
    public CycList getInstanceSiblings (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(instance-siblings " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the collections of which the CycFort is directly and indirectly an instance.
     *
     * @@param cycFort the given term
     * @@return the list of the collections of which the CycFort is directly and indirectly an instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllIsa (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-isa-in-any-mt " + cycFort.stringApiValue() + ")");
    }

    /**
     * Gets the list of the collections of which the CycFort is directly and indirectly an instance.
     *
     * @@param cycFort the given term
     * @@param mt the relevant mt
     * @@return the list of the collections of which the CycFort is directly and indirectly an instance
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllIsa (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-isa " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of all the direct and indirect instances (individuals) for a CycFort
     * collection.
     *
     * @@param cycFort the collection for which all the direct and indirect instances
     * (individuals) are sought
     * @@return the list of all the direct and indirect instances (individuals) for the
     * given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllInstances (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-instances-in-all-mts " + cycFort.stringApiValue() + ")");
    }

    /**
     * Gets a list of all the direct and indirect instances (individuals) for a CycFort
     * collection in the given microtheory.
     *
     * @@param cycFort the collection for which all the direct and indirect instances
     * (individuals) are sought
     * @@param mt the relevant mt
     * @@return the list of all the direct and indirect instances (individuals) for the
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     * given collection
    */
    public CycList getAllInstances (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-instances " + cycFort.stringApiValue()
                            + " " + mt.stringApiValue()+ ")");
    }

    /**
     * Gets a hashset of all the direct and indirect instances (individuals) for a CycFort
     * collection in the given microtheory.
     *
     * @@param cycFort the collection for which all the direct and indirect instances
     * (individuals) are sought
     * @@param mt the microtheory in which the inference is performed
     * @@return the list of all the direct and indirect instances (individuals) for the
     * given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
    */
    public HashSet getAllInstancesHashSet (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllInstances(cycFort, mt));
    }

    /**
     * Gets a hashset of all the direct and indirect instances (individuals) for a CycFort
     * collection in the given microtheory.
     *
     * @@param cycFort the collection for which all the direct and indirect instances
     * (individuals) are sought
     * @@return the list of all the direct and indirect instances (individuals) for the
     * given collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
    */
    public HashSet getAllInstancesHashSet (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllInstances(cycFort));
    }

    /**
     * Returns true if CycFort TERM is a instance of CycFort COLLECTION, defaulting to all microtheories.
     *
     * @@param term the term
     * @@param collectionName the name of the collection
     * @@return <tt>true</tt> if CycFort TERM is a instance of the CycFort named by COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isa (CycFort term, String collectionName)
        throws IOException, UnknownHostException, CycApiException {
        return isa(term,
                   getKnownConstantByName(collectionName));
    }

    /**
     * Returns true if CycFort TERM is a instance of CycFort COLLECTION, defaulting to all microtheories.
     *
     * @@param term the term
     * @@param collection the collection
     * @@return <tt>true</tt> if CycFort TERM is a instance of CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isa (CycFort term, CycFort collection)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + term.stringApiValue() + " " + collection.stringApiValue() + ")");
    }

    /**
     * Returns true if CycFort TERM is a instance of CycFort COLLECTION, using the given microtheory.
     * Method implementation optimised for the binary api.
     *
     * @@param term the term
     * @@param collection the collection
     * @@param mt the microtheory in which the ask is performed
     * @@return <tt>true</tt> if CycFort TERM is a instance of CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isa (CycFort term, CycFort collection, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("isa?"));
        command.add(term.cycListApiValue());
        command.add(collection.cycListApiValue());
        command.add(mt.cycListApiValue());
        return converseBoolean(command);
    }

    /**
     * Gets the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
     * getWhyIsa("Brazil", "Country") -->
     * "(((#$isa #$Brazil #$IndependentCountry) :TRUE)
     *    (#$genls #$IndependentCountry #$Country) :TRUE))
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@return the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyIsa (CycFort spec, CycFort genl)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() + "))");
    }

    /**
     * Gets the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
     * getWhyIsa("Brazil", "Country") -->
     * "(((#$isa #$Brazil #$IndependentCountry) :TRUE)
     *    (#$genls #$IndependentCountry #$Country) :TRUE))
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@param mt the relevant mt
     * @@return the list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getWhyIsa (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() +
                            " " + mt.stringApiValue()+ ")");
    }

    /**
     * Gets the English parapharse of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
     * getWhyGenlParaphase("Brazil", "Country") -->
     * "Brazil is an independent country"
     * "an  independent country is a kind of country"
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@result the English parapharse of the justifications of why CycFort TERM is an instance of
     * CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyIsaParaphrase (CycFort spec, CycFort genl)
        throws IOException, CycApiException {
        String command = "(with-all-mts (why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() + "))";
        CycList listAnswer = converseList(command);
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            answerPhrases.add(getParaphrase(assertion));
        }
d5623 499
a6121 1
    return answerPhrases;
d6123 1
d6125 2
a6126 27
    /**
     * Gets the English parapharse of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
     * getWhyGenlParaphase("Brazil", "Country") -->
     * "Brazil is an independent country"
     * "an  independent country is a kind of country"
     *
     * @@param spec the specialized collection
     * @@param genl the more general collection
     * @@param mt the relevant mt
     * @@result the English parapharse of the justifications of why CycFort TERM is an instance of
     * CycFort COLLECTION
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public ArrayList getWhyIsaParaphrase (CycFort spec, CycFort genl, ELMT mt)
        throws IOException, CycApiException {
        String command = "(why-isa? " + spec.stringApiValue() + " " + genl.stringApiValue() +
                         " " + mt.stringApiValue()+ ")";
        CycList listAnswer = converseList(command);
        ArrayList answerPhrases = new ArrayList();
        if (listAnswer.size() == 0)
            return answerPhrases;
        for (int i = 0; i < listAnswer.size(); i++) {
            CycList assertion = (CycList) ((CycList) listAnswer.get(i)).first();
            answerPhrases.add(getParaphrase(assertion));
        }
d6128 297
a6424 2
    return answerPhrases;
    }
d6426 69
a6494 456
    /**
     * Gets the list of the genlPreds for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@result the list of the more general predicates for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenlPreds (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (genl-predicates " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the genlPreds for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@param mt the relevant mt
     * @@result the list of the more general predicates for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getGenlPreds (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(genl-predicates " + predicate.stringApiValue() +
                            " " + mt.stringApiValue()+ ")");
    }

    /**
     * Gets the list of all of the genlPreds for a CycConstant predicate, using an upward closure.
     *
     * @@parameter predicate the predicate for which all the genlPreds are obtained
     * @@return a list of all of the genlPreds for a CycConstant predicate, using an upward closure
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenlPreds (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-genl-predicates " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the genlPreds for a CycConstant predicate, using an upward closure.
     *
     * @@parameter predicate the predicate for which all the genlPreds are obtained
     * @@param mt the relevant mt
     * @@return a list of all of the genlPreds for a CycConstant predicate, using an upward closure
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllGenlPreds (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-genl-predicates " + predicate.stringApiValue() +
                            " " + mt.stringApiValue()+ ")");
    }

    /**
     * Gets the list of all of the direct and indirect specs-preds for the given predicate
     * in all microtheories.
     *
     * @@param cycFort the predicate
     * @@return the list of all of the direct and indirect spec-preds for the given predicate
     * in all microtheories.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecPreds (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-spec-predicates " +
                            cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the direct and indirect specs-preds for the given predicate
     * in the given microtheory.
     *
     * @@param cycFort the predicate
     * @@param mt the microtheory
     * @@return the list of all of the direct and indirect spec-preds for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecPreds (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-spec-predicates " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the hashset of all of the direct and indirect specs-preds for the given predicate
     * in all microtheories.
     *
     * @@param cycFort the predicate
     * @@return the hashset of all of the direct and indirect spec-preds for the given predicate
     * in all microtheories.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecPredsHashSet (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecPreds(cycFort));
    }

    /**
     * Gets the hashset of all of the direct and indirect specs-preds for the given predicate
     * in the given microtheory.
     *
     * @@param cycFort the predicate
     * @@param mt the microtheory
     * @@return the hashset of all of the direct and indirect spec-preds for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecPredsHashSet (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecPreds(cycFort, mt));
    }

    /**
     * Gets the list of all of the direct and indirect specs-inverses for the given predicate
     * in all microtheories.
     *
     * @@param cycFort the predicate
     * @@return the list of all of the direct and indirect spec-inverses for the given predicate
     * in all microtheories.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecInverses (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (all-spec-inverses " +
                            cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets the list of all of the direct and indirect specs-inverses for the given predicate
     * in the given microtheory.
     *
     * @@param cycFort the predicate
     * @@param mt the microtheory
     * @@return the list of all of the direct and indirect spec-inverses for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecInverses (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-spec-inverses " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the hashset of all of the direct and indirect specs-inverses for the given predicate
     * in all microtheories.
     *
     * @@param cycFort the predicate
     * @@return the hashset of all of the direct and indirect spec-inverses for the given predicate
     * in all microtheories.
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecInversesHashSet (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecInverses(cycFort));
    }

    /**
     * Gets the list of all of the direct and indirect specs-mts for the given microtheory
     * in *mt-mt* (currently #$UniversalVocabularyMt).
     *
     * @@param mt the microtheory
     * @@return the list of all of the direct and indirect specs-mts for the given microtheory
     * in *mt-mt* (currently #$UniversalVocabularyMt)
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getAllSpecMts (ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(all-spec-mts " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the hashset of all of the direct and indirect specs-inverses for the given predicate
     * in the given microtheory.
     *
     * @@param cycFort the predicate
     * @@param mt the microtheory
     * @@return the hashset of all of the direct and indirect spec-inverses for the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecInversesHashSet (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecInverses(cycFort, mt));
    }

    /**
     * Gets the hashset of all of the direct and indirect specs-mts for the given microtheory
     * in *mt-mt* (currently #$UniversalVocabularyMt).
     *
     * @@param mt the microtheory
     * @@return the hashset of all of the direct and indirect specs-mts for the given microtheory
     * in *mt-mt* (currently #$UniversalVocabularyMt)
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public HashSet getAllSpecMtsHashSet (ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return new HashSet(getAllSpecMts(mt));
    }

    /**
     * Gets a list of the arg1Isas for a CycConstant predicate.
     *
     * @@param predicate the predicate for which argument 1 contraints are sought.
     * @@return the list of the arg1Isas for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg1Isas (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (arg1-isa " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the arg1Isas for a CycConstant predicate given an mt.
     *
     * @@param predicate the predicate for which argument 1 contraints are sought.
     * @@param mt the relevant microtheory
     * @@return the list of the arg1Isas for a CycConstant predicate given an mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg1Isas (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg1-isa " + predicate.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the arg2Isas for a CycConstant predicate.
     *
     * @@param predicate the predicate for which argument 2 contraints are sought.
     * @@return the list of the arg1Isas for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg2Isas (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (arg2-isa " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the arg2Isas for a CycConstant predicate given an mt.
     *
     * @@param predicate the predicate for which argument 2 contraints are sought.
     * @@param mt the relevant microtheory
     * @@return the list of the arg2Isas for a CycConstant predicate given an mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg2Isas (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg2-isa " + predicate.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the arg3Isas for a CycConstant predicate.
     *
     * @@param predicate the predicate for which argument 3 contraints are sought.
     * @@return the list of the arg1Isas for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg3Isas (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (arg3-isa " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the arg3Isas for a CycConstant predicate given an mt.
     *
     * @@param predicate the predicate for which argument 3 contraints are sought.
     * @@param mt the relevant microtheory
     * @@return the list of the arg1Isas for a CycConstant predicate given an mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg3Isas (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg3-isa " + predicate.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the arg4Isas for a CycConstant predicate.
     *
     * @@param predicate the predicate for which argument 4 contraints are sought.
     * @@return the list of the arg4Isas for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg4Isas (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (arg4-isa " + predicate.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the arg4Isas for a CycConstant predicate given an mt.
     *
     * @@param predicate the predicate for which argument 4 contraints are sought.
     * @@param mt the relevant microtheory
     * @@return the list of the arg4Isas for a CycConstant predicate given an mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg4Isas (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg4-isa " + predicate.stringApiValue() + " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the argNIsas for a CycConstant predicate.
     *
     * @@param predicate the predicate for which argument N contraints are sought.
     * @@param argPosition the argument position of argument N
     * @@return the list of the argNIsas for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArgNIsas (CycConstant predicate, int argPosition)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            "(remove-duplicates \n" +
            "  (with-all-mts \n" +
            "    (argn-isa " + predicate.stringApiValue() + " " + Integer.toString(argPosition) + ")))";
        return converseList(command);
    }

    /**
     * Gets the list of the argNIsas for a CycConstant predicate given an mt.
     *
     * @@param predicate the predicate for which argument contraints are sought.
     * @@param argPosition the argument position of argument N
     * @@param mt the relevant microtheory
     * @@return the list of the arg1Isas for a CycConstant predicate given an mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArgNIsas (CycConstant predicate,
                                int argPosition,
                                ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            "(remove-duplicates \n" +
            "  (with-all-mts \n" +
            "    (argn-isa \n" +
            "      " + predicate.stringApiValue() +
            "      " + Integer.toString(argPosition) +
            "      " + mt.stringApiValue() + ")))";
        return converseList(command);
    }

    /**
     * Gets the list of the interArgIsa1-2 isa constraint pairs for
     * the given predicate.  Each item of the returned list is a pair
     * (arg1-isa arg2-isa) which means that when (#$isa arg1 arg1-isa) holds,
     * (#$isa arg2 arg2-isa) must also hold for (predicate arg1 arg2 ..) to
     * be well formed.
     *
     * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
     * @@return the list of the interArgIsa1-2 isa constraint pairs for
     * the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInterArgIsa1_2s (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            "(remove-duplicates \n" +
            "  (with-all-mts \n" +
            "    (inter-arg-isa1-2 " + predicate.stringApiValue() + ")))";
        return converseList(command);
    }

    /**
     * Gets the list of the interArgIsa1-2 isa constraint pairs for
     * the given predicate.  Each item of the returned list is a pair
     * (arg1-isa arg2-isa) which means that when (#$isa arg1 arg1-isa) holds,
     * (#$isa arg2 arg2-isa) must also hold for (predicate arg1 arg2 ..) to
     * be well formed.
     *
     * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
     * @@param mt the relevant inference microtheory
     * @@return the list of the interArgIsa1-2 isa constraint pairs for
     * the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInterArgIsa1_2s (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            "(remove-duplicates \n" +
            "  (with-all-mts \n" +
            "    (inter-arg-isa1-2 " +
            "      " + predicate.stringApiValue() +
            "      " + mt.stringApiValue() + ")))";
        return converseList(command);
    }

    /**
     * Gets the list of the interArgIsa1-2 isa constraints for arg2,
     * given the predicate and arg1.
     *
     * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
     * @@param arg1 the argument in position 1
     * @@return the list of the interArgIsa1-2 isa constraints for arg2,
     * given the predicate and arg1
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInterArgIsa1_2_forArg2 (CycConstant predicate, CycFort arg1)
        throws IOException, UnknownHostException, CycApiException {
        CycList result = new CycList();
        ListIterator constraintPairs = getInterArgIsa1_2s(predicate).listIterator();
        while (constraintPairs.hasNext()) {
            CycList pair = (CycList) constraintPairs.next();
            if (pair.first().equals(arg1))
                result.add(pair.second());
        }
        return result;
    }
d6496 46
a6541 26
    /**
     * Gets the list of the interArgIsa1-2 isa constraints for arg2,
     * given the predicate and arg1.
     *
     * @@param predicate the predicate for interArgIsa1-2 contraints are sought.
     * @@param arg1 the argument in position 1
     * @@param mt the relevant inference microtheory
     * @@return the list of the interArgIsa1-2 isa constraints for arg2,
     * given the predicate and arg1
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getInterArgIsa1_2_forArg2 (CycConstant predicate,
                                              CycFort arg1,
                                              ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList result = new CycList();
        ListIterator constraintPairs = getInterArgIsa1_2s(predicate, mt).listIterator();
        while (constraintPairs.hasNext()) {
            CycList pair = (CycList) constraintPairs.next();
            if (pair.first().equals(arg1))
                result.add(pair.second());
        }
        return result;
    }
d6543 1184
a7726 179
    /**
     * Gets the list of the resultIsa for a CycConstant function.
     *
     * @@param function the given function term
     * @@return the list of the resultIsa for a CycConstant function
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getResultIsas (CycConstant function)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (result-isa " + function.stringApiValue() + ")))");
    }

    /**
     * Gets the list of the resultIsa for a CycConstant function.
     *
     * @@param function the given function term
     * @@param mt the relevant mt
     * @@return the list of the resultIsa for a CycConstant function
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getResultIsas (CycConstant function, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(result-isa " + function.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets the list of the argNGenls for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@param argPosition the argument position for which the genls argument
     * constraints are sought (position 1 = first argument)
     * @@return the list of the argNGenls for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArgNGenls (CycConstant predicate, int argPosition)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (argn-genl " + predicate.stringApiValue() +
                            " " + argPosition + ")))");
    }

    /**
     * Gets the list of the argNGenls for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@param argPosition the argument position for which the genls argument
     * constraints are sought (position 1 = first argument)
     * @@param mt the relevant mt
     * @@return the list of the argNGenls for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArgNGenls (CycConstant predicate, int argPosition, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(argn-genl " + predicate.stringApiValue() +
                            " " + argPosition +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the arg1Formats for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@return a list of the arg1Formats for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg1Formats (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (arg1-format " + predicate.stringApiValue() + "))");
    }

    /**
     * Gets a list of the arg1Formats for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@param mt the relevant mt
     * @@return a list of the arg1Formats for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg1Formats (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg1-format " + predicate.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the arg2Formats for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@return a list of the arg2Formats for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg2Formats (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(with-all-mts (arg2-format " + predicate.stringApiValue() + "))");
    }

    /**
     * Gets a list of the arg2Formats for a CycConstant predicate.
     *
     * @@param predicate the given predicate term
     * @@param mt the relevant mt
     * @@return a list of the arg2Formats for a CycConstant predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg2Formats (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(arg2-format " + predicate.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the disjointWiths for a CycFort.
     *
     * @@param cycFort the given collection term
     * @@return a list of the disjointWiths for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getDisjointWiths (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(remove-duplicates (with-all-mts (local-disjoint-with " + cycFort.stringApiValue() + ")))");
    }

    /**
     * Gets a list of the disjointWiths for a CycFort.
     *
     * @@param cycFort the given collection term
     * @@param mt the relevant mt
     * @@return a list of the disjointWiths for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getDisjointWiths (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(local-disjoint-with " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
    }

    /**
     * Gets a list of the coExtensionals for a CycFort.  Limited to 120 seconds.
     *
     * @@param cycFort the given collection term
     * @@return a list of the coExtensionals for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getCoExtensionals (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        CycList answer = null;
        try {
            answer = converseList("(ask-template '?X '(#$coExtensional " +
                                  cycFort.stringApiValue() + " ?X) #$EverythingPSC nil nil 120)");
        }
        catch (IOException e) {
            Log.current.println("getCoExtensionals - ignoring:\n" + e.getMessage());
            return new CycList();
        }
        answer.remove(cycFort);
        return answer;
    }
d7728 2
a7729 26
    /**
     * Gets a list of the coExtensionals for a CycFort.  Limited to 120 seconds.
     *
     * @@param cycFort the given collection term
     * @@param mt the relevant mt for inference
     * @@return a list of the coExtensionals for a CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getCoExtensionals (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList answer = null;
        try {
            answer = converseList("(ask-template '?X '(#$coExtensional " +
                                  cycFort.stringApiValue() + " ?X) " +
                                  mt.stringApiValue() +
                                  " nil nil 120)");
        }
        catch (IOException e) {
            Log.current.println("getCoExtensionals - ignoring:\n" + e.getMessage());
            return new CycList();
        }
        answer.remove(cycFort);
        return answer;
    }
d7731 166
a7896 344
    /**
     * Returns true if cycConstant is a microtheory.
     *
     * @@param cycConstant the constant for determination as a microtheory
     * @@return <tt>true</tt> iff cycConstant is a microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isMicrotheory (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + " #$Microtheory)");
    }

    /**
     * Returns true if cycConstant is a Collection.
     *
     * @@param cycConstant the constant for determination as a Collection
     * @@return <tt>true</tt> iff cycConstant is a Collection,
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isCollection (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + " #$Collection)");
    }

    /**
     * Returns true if cycConstant is a Collection, implements a cache
     * to avoid asking the same question twice from the KB.
     *
     * @@param cycConstant the constant for determination as a Collection
     * @@return <tt>true</tt> iff cycConstant is a Collection,
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isCollection_Cached(CycFort cycFort)  throws IOException, CycApiException {
        boolean answer;
        Boolean isCollection = (Boolean) isCollectionCache.getElement(cycFort);
        if (isCollection != null) {
            answer = isCollection.booleanValue();
            return answer;
        }
        answer = isCollection(cycFort);
        isCollectionCache.addElement(cycFort, new Boolean(answer));
        return answer;
    }

    /**
     * Returns true if cycConstant is an Individual.
     *
     * @@param cycFort the given term
     * @@return true if cycConstant is an Individual
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isIndividual (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + " #$Individual)");
    }

    /**
     * Returns true if cycConstant is a Function.
     *
     * @@param cycConstant the given term
     * @@return true if cycConstant is a Function, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isFunction (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + " #$Function-Denotational)");
    }

    /**
     * Returns true if cycConstant is an evaluatable predicate.
     *
     * @@param predicate the given term
     * @@return true if cycConstant is an evaluatable predicate, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isEvaluatablePredicate (CycConstant predicate)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("evaluatable-predicate?"));
        command1.add(predicate);
        return converseBoolean(command);
    }

    /**
     * Returns true if cycFort is a Predicate.
     *
     * @@param cycFort the term for determination as a predicate
     * @@return true if cycFort is a Predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isPredicate (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        if (cycFort instanceof CycNart)
            return false;
        else
            return converseBoolean("(isa-in-any-mt? " + cycFort.stringApiValue() + " #$Predicate)");
    }

    /**
     * Returns true if cycConstant is a UnaryPredicate.
     *
     * @@param cycConstant the given term
     * @@return true if cycConstant is a UnaryPredicate, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isUnaryPredicate (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + " #$UnaryPredicate)");
    }

    /**
     * Returns true if cycConstant is a BinaryPredicate.
     *
     * @@param cycConstant the given term
     * @@return true if cycConstant is a BinaryPredicate, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isBinaryPredicate (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + " #$BinaryPredicate)");
    }

    /**
     * Returns true if the candidate name uses valid CycConstant characters.
     *
     * @@param candidateName the candidate name
     * @@return true if the candidate name uses valid CycConstant characters
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isValidConstantName (String candidateName)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(new-constant-name-spec-p \"" + candidateName + "\")");
    }

    /**
     * Returns true if the candidate name is an available CycConstant name, case insensitive.
     *
     * @@param candidateName the candidate name
     * @@return true if the candidate name uses valid CycConstant characters
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isConstantNameAvailable (String candidateName)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(constant-name-available \"" + candidateName + "\")");
    }

    /**
     * Returns true if term is a quotedCollection, in any microtheory
     *
     * @@param cycFort the given CycFort term
     * @@return true if term is a quotedCollection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isQuotedCollection (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant inferencePSC = getKnownConstantByName("InferencePSC");
        return this.isQuotedCollection(cycFort, inferencePSC);
    }

    /**
     * Returns true if term is a quotedCollection is a quotedCollection.
     *
     * @@param cycFort the given CycFort term
     * @@param mt the microtheory in which the query is made
     * @@return true if term is a quotedCollection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isQuotedCollection (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList query = new CycList();
        query.add(getKnownConstantByName("quotedCollection"));
        query.add(cycFort);
        return this.isQueryTrue(query, mt);
    }

    /**
     * Returns true if cycConstant is a PublicConstant.
     *
     * @@param cycConstant the given constant
     * @@return true if cycConstant is a PublicConstant
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isPublicConstant (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + " #$PublicConstant)");
    }

    /**
     * Gets a list of the public Cyc constants.
     *
     * @@return a list of the public Cyc constants
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getPublicConstants ()
        throws IOException, UnknownHostException, CycApiException {
        // #$PublicConstant
        return getKbSubset(getKnownConstantByGuid("bd7abd90-9c29-11b1-9dad-c379636f7270"));
    }

    /**
     * Gets a list of the elements of the given CycKBSubsetCollection.
     *
     * @@param cycKbSubsetCollection the given CycKBSubsetCollection
     * @@return a list of the elements of the given CycKBSubsetCollection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getKbSubset (CycFort cycKbSubsetCollection)
        throws IOException, UnknownHostException, CycApiException {
        return converseList("(ask-template '?X '(#$isa ?X " +
                            cycKbSubsetCollection.stringApiValue() +
                            ") #$EverythingPSC)");
    }

    /**
     * Kills a Cyc constant.  If CYCCONSTANT is a microtheory, then
     * all the contained assertions are deleted from the KB, the Cyc Truth Maintenance System
     * (TML) will automatically delete any derived assertions whose sole support is the killed
     * term(s).
     *
     * @@param cycConstant the constant term to be removed from the KB
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public synchronized void kill (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            withBookkeepingInfo() +
            "(ke-kill-now " + cycConstant.stringApiValue() + "))";
        converseBoolean(command);
        CycObjectFactory.removeCaches(cycConstant);
    }

    /**
     * Kills a Cyc constant without issuing a transcript operation.
     * If CYCCONSTANT is a microtheory, then all the contained assertions are deleted from
     * the KB, the Cyc Truth Maintenance System (TMS) will automatically delete any derived
     * assertions whose sole support is the killed term(s).
     *
     * @@param cycConstant the constant term to be removed from the KB
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public synchronized void killWithoutTranscript (CycConstant cycConstant)
        throws IOException, UnknownHostException, CycApiException {
        String command =
            withBookkeepingInfo() +
            "(cyc-kill " + cycConstant.stringApiValue() + "))";
        converseBoolean(command);
        CycObjectFactory.removeCaches(cycConstant);
    }

    /**
     * Kills the given Cyc constants.  If CYCCONSTANT is a microtheory, then
     * all the contained assertions are deleted from the KB, the Cyc Truth Maintenance System
     * (TMS) will automatically delete any derived assertions whose sole support is the killed
     * term(s).
     *
     * @@param cycConstants the list of constant terms to be removed from the KB
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public synchronized void kill (CycConstant[] cycConstants)
        throws IOException, UnknownHostException, CycApiException {
        for (int i = 0; i < cycConstants.length; i++)
            kill(cycConstants[i]);
    }

    /**
     * Kills the given Cyc constants.  If CYCCONSTANT is a microtheory, then
     * all the contained assertions are deleted from the KB, the Cyc Truth Maintenance System
     * (TMS) will automatically delete any derived assertions whose sole support is the killed
     * term(s).
     *
     * @@param cycConstants the list of constant terms to be removed from the KB
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public synchronized void kill (ArrayList cycConstants)
        throws IOException, UnknownHostException, CycApiException {
        for (int i = 0; i < cycConstants.size(); i++)
            kill((CycConstant) cycConstants.get(i));
    }

    /**
     * Kills a Cyc NART (Non Atomic Reified Term).  If CYCFORT is a microtheory, then
     * all the contained assertions are deleted from the KB, the Cyc Truth Maintenance System
     * (TMS) will automatically delete any derived assertions whose sole support is the killed
     * term(s).
     *
     * @@param cycFort the NART term to be removed from the KB
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public synchronized  void kill (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        if (cycFort instanceof CycConstant)
            kill((CycConstant) cycFort);
        else {
            String command =
                withBookkeepingInfo() +
                "(ke-kill-now '" + cycFort.stringApiValue() + "))";
            converseBoolean(command);
        }
    }
d7898 906
a8803 628
    /**
     * Sets the value of the Cyclist, whose identity will be attached
     * via #$myCreator bookkeeping assertions to new KB entities created
     * in this session.
     *
     * @@param cyclistName the name of the cyclist term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void setCyclist (String cyclistName)
        throws IOException, UnknownHostException, CycApiException {
        setCyclist(getConstantByName(cyclistName));
    }

    /**
     * Sets the value of the Cyclist, whose identity will be attached
     * via #$myCreator bookkeeping assertions to new KB entities created
     * in this session.
     *
     * @@param cyclis the cyclist term
     */
    public void setCyclist (CycConstant cyclist) {
        this.cyclist = cyclist;
    }

    /**
     * Sets the value of the KE purpose, whose project name will be attached
     * via #$myCreationPurpose bookkeeping assertions to new KB entities
     * created in this session.
     *
     * @@param projectName the string name of the KE Purpose term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void setKePurpose (String projectName)
        throws IOException, UnknownHostException, CycApiException {
        setKePurpose(getConstantByName(projectName));
    }

    /**
     * Sets the value of the KE purpose, whose project name will be attached
     * via #$myCreationPurpose bookkeeping assertions to new KB entities
     * created in this session.
     *
     * @@param project the KE Purpose term
     */
    public void setKePurpose (CycConstant project) {
        this.project = project;
    }

    /**
     * Asserts the given sentence, and then places it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithTranscript (CycList sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertWithTranscript(sentence.cyclify(), mt);
    }

    /**
     * Asserts the given sentence, and then places it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithTranscript (String sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            "(clet ((*the-cyclist* " + cyclistName + ")\n" +
            "       (*ke-purpose* " + projectName + "))\n" +
            "  (ke-assert-now\n" +
            "    '" + sentence + "\n" +
            "    " + mt.cyclify() + "))";
        converseVoid(command);
    }

    /**
     * Asserts the given sentence with bookkeeping, and then places it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithTranscriptAndBookkeeping (CycList sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertWithTranscriptAndBookkeeping(sentence.cyclify(), mt);
    }

    /**
     * Asserts the given sentence with bookkeeping, and then places it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithTranscriptAndBookkeeping (String sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            "(with-bookkeeping-info \n" +
            "  (new-bookkeeping-info " + cyclistName + " (the-date) " + projectName + "(the-second))\n" +
            "  (clet ((*the-cyclist* " + cyclistName + ")\n" +
            "         (*ke-purpose* " + projectName + "))\n" +
            "    (ke-assert-now\n" +
            "      '" + sentence + "\n" +
            "      " + mt.cyclify() + ")))";
        converseVoid(command);
    }

    /**
     * Asserts the given sentence with bookkeeping and without placing it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithBookkeepingAndWithoutTranscript (CycList sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertWithBookkeepingAndWithoutTranscript (sentence.cyclify(), mt);
    }

    /**
     * Asserts the given sentence with bookkeeping and without placing it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for assertion
     * @@param mt the microtheory in which the assertion is placed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertWithBookkeepingAndWithoutTranscript (String sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            "(with-bookkeeping-info \n" +
            "  (new-bookkeeping-info " + cyclistName + " (the-date) " + projectName + "(the-second))\n" +
            "  (clet ((*the-cyclist* " + cyclistName + ")\n" +
            "         (*ke-purpose* " + projectName + "))\n" +
            "    (cyc-assert\n" +
            "      '" + sentence + "\n" +
            "      " + mt.cyclify() + ")))";
        boolean statusOk = converseBoolean(command);
        if (! statusOk)
            throw new CycApiException("Assertion failed in mt: " + mt.cyclify() +
                                      "\n" + sentence);
    }


    /**
     * Unasserts the given sentence with bookkeeping and without placing it on
     * the transcript queue.
     *
     * @@param sentence the given sentence for unassertion
     * @@param mt the microtheory from which the assertion is removed
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void unassertWithBookkeepingAndWithoutTranscript (CycList sentence, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String command = withBookkeepingInfo() +
            "(cyc-unassert '" +
            sentence.stringApiValue() +
            mt.stringApiValue() + "))";
        boolean unassertOk = converseBoolean(command);
        if (! unassertOk)
            throw new CycApiException("Could not unassert from mt: " + mt +
                                      "\n  " + sentence.cyclify());
    }

    /**
     * Returns a with-bookkeeping-info macro expresssion.
     *
     * @@return a with-bookkeeping-info macro expresssion
     */
    protected String withBookkeepingInfo () {
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        return "(with-bookkeeping-info (new-bookkeeping-info " +
            cyclistName + " (the-date) " +
            projectName + "(the-second)) ";
    }

    /**
     * Finds a Cyc constant in the KB with the specified name
     *
     * @@param constantName the name of the new constant
     * @@return the constant term or null if the argument name is null or if the
     * term is not found
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant find (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        if (constantName == null)
            return null;
        return getConstantByName(constantName);
    }

    /**
     * Finds or creates a Cyc constant in the KB with the specified name.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param constantName the name of the new constant
     * @@return the new constant term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant findOrCreate (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        return makeCycConstant(constantName);
    }

    /**
     * Creates a new permanent Cyc constant in the KB with the specified name.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param constantName the name of the new constant
     * @@return the new constant term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant createNewPermanent (String constantName)
        throws IOException, UnknownHostException, CycApiException {
        return makeCycConstant(constantName);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycFort predicate,
                           CycFort arg1,
                           CycFort arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <CycFort>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " " +
            arg2.cyclify() + ")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate, which is a string
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycFort predicate,
                           CycFort arg1,
                           String arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <String>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " \"" +
            arg2 + "\")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate, which is a CycList
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycConstant predicate,
                           CycFort arg1,
                           CycList arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <List>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " " +
            arg2.cyclify() + ")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate, which is an int
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycConstant predicate,
                           CycFort arg1,
                           int arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <int>)
        assertGaf(mt, predicate, arg1, new Integer(arg2));
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate, which is an Integer
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycFort predicate,
                           CycFort arg1,
                           Integer arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <int>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " " +
            arg2.toString() + ")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the binary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate, which is a Double
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycFort predicate,
                           CycFort arg1,
                           Double arg2)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <int>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " " +
            arg2.toString() + ")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }

    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.
     * The operation and its bookkeeping info will be added to the KB transcript
     * for replication and archive.
     *
     * @@param mt the microtheory in which the assertion is made
     * @@param predicate the ternary predicate of the assertion
     * @@param arg1 the first argument of the predicate
     * @@param arg2 the second argument of the predicate
     * @@param arg3 the third argument of the predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (ELMT mt,
                           CycConstant predicate,
                           CycFort arg1,
                           CycFort arg2,
                           CycFort arg3)
        throws IOException, UnknownHostException, CycApiException {
        // (predicate <CycFort> <CycFort> <CycFort>)
        String sentence =
            "(" + predicate.cyclify() + " " +
            arg1.cyclify() + " " +
            arg2.cyclify() + " " +
            arg3.cyclify() + ")";
        assertWithTranscriptAndBookkeeping(sentence, mt);
    }


    /**
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param gaf the gaf in the form of a CycList
     * @@param mt the microtheory in which the assertion is made
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGaf (CycList gaf,
                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertWithTranscriptAndBookkeeping(gaf, mt);
    }

    /**
     * Unasserts the given ground atomic formula (gaf) in the specified microtheory MT.
     *
     * @@param gaf the gaf in the form of a CycList
     * @@param mt the microtheory in which the assertion is made
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void unassertGaf (CycList gaf,
                            ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        String command = withBookkeepingInfo() +
            "(ke-unassert-now '" +
            gaf.stringApiValue() +
            mt.stringApiValue() + "))";
        converseVoid(command);
    }

    /**
     * Assert a nameString for the specified CycConstant in the specified lexical microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycConstantName the name of the given term
     * @@param nameString the given name string for the term
     * @@param mtName the name of the microtheory in which the name string is asserted
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertNameString (String cycConstantName,
                                  String nameString,
                                  String mtName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(getKnownConstantByName(mtName),
                  getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"),
                  getKnownConstantByName(cycConstantName),
                  nameString);
    }

   /**
     * Assert a comment for the specified CycConstant in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
     *
     * @@param cycConstantName the name of the given term
     * @@param comment the comment string
     * @@param mtName the name of the microtheory in which the comment is asserted
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertComment (String cycConstantName,
                               String comment,
                               String mtName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(getKnownConstantByName(mtName),
                  CycAccess.comment,
                  getKnownConstantByName(cycConstantName),
                  comment);
    }

    /**
     * Assert a comment for the specified CycFort in the specified microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given term
     * @@param comment the comment string
     * @@param mt the comment assertion microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertComment (CycFort cycFort,
                               String comment,
                               ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt, CycAccess.comment, cycFort, comment);
    }

    /**
     * Assert a name string for the specified CycFort in the specified microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given term
     * @@param nameString the name string
     * @@param mt the name string assertion microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertNameString (CycFort cycFort,
                                  String nameString,
                                  ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt,
                  this.getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"),
                  cycFort,
                  nameString);
    }

    /**
     * Assert a paraphrase format for the specified CycFort in the #$EnglishParaphraseMt.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given term
     * @@param genFormatString the genFormat string
     * @@param genFormatList the genFormat argument substitution sequence
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenFormat (CycFort relation,
                                 String genFormatString,
                                 CycList genFormatList)
        throws IOException, UnknownHostException, CycApiException {
        // (#$genFormat <relation> <genFormatString> <genFormatList>)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("beed06de-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(genFormatString);
        if (genFormatList.size() == 0)
            sentence.add(CycObjectFactory.nil);
        else
            sentence.add(genFormatList);
        assertGaf(sentence,
                  // #$EnglishParaphraseMt
                  getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270"));
    }

    /**
     * Create a microtheory MT, with a comment, isa <mt type> and CycFort genlMts.
     * An existing microtheory with
     * the same name is killed first, if it exists.
     *
     * @@param mtName the name of the microtheory term
     * @@param comment the comment for the new microtheory
     * @@param isMt the type of the new microtheory
     * @@param genlMts the list of more general microtheories
     * @@return the new microtheory term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant createMicrotheory (String mtName,
                                          String comment,
                                          CycFort isaMt,
                                          ArrayList genlMts)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant mt = getConstantByName(mtName);
        if (mt != null) {
            kill(mt);
        }
        mt = createNewPermanent(mtName);
        assertComment(mt, comment, baseKB);
        assertGaf(universalVocabularyMt, isa, mt, isaMt);
        Iterator iterator = genlMts.iterator();
        while (true) {
            if (! iterator.hasNext())
                break;
            CycFort aGenlMt = (CycFort) iterator.next();
            assertGaf(universalVocabularyMt, genlMt, mt, aGenlMt);
        }
    return mt;
    }
d8805 5
a8809 35
    /**
     * Create a microtheory MT, with a comment, isa <mt type> and CycFort genlMts.
     * An existing microtheory with
     * the same name is killed first, if it exists.
     *
     * @@param mtName the name of the microtheory term
     * @@param comment the comment for the new microtheory
     * @@param isMt the type (as a string) of the new microtheory
     * @@param genlMts the list of more general microtheories (as strings)
     * @@return the new microtheory term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant createMicrotheory (String mtName,
                                          String comment,
                                          String isaMtName,
                                          ArrayList genlMts)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant mt = getConstantByName(mtName);
        if (mt != null) {
            kill(mt);
        }
        mt = createNewPermanent(mtName);
        assertComment(mt, comment, baseKB);
        assertIsa(mtName, isaMtName);
        Iterator iterator = genlMts.iterator();
        while (true) {
            if (! iterator.hasNext())
                break;
            String genlMtName = (String) iterator.next();
            assertGenlMt(mtName, genlMtName);
        }
    return mt;
    }
d8811 1306
a10116 699
    /**
     * Create a microtheory system for a new mt.  Given a root mt name, create a theory <Root>Mt,
     * create a vocabulary <Root>VocabMt, and a data <Root>DataMt.  Establish genlMt links for the
     * theory mt and data mt.  Assert that the theory mt is a genlMt of the WorldLikeOursCollectorMt.
     * Assert that the data mt is a genlMt of the collector CurrentWorldDataMt.
     *
     * @@param mtRootName the root name of the microtheory system
     * @@param comment the root comment of the microtheory system
     * @@param genlMts the list of more general microtheories
     * @@return an array of three elements consisting of the theory mt, vocabulary mt,
     * and the data mt
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant[] createMicrotheorySystem (String mtRootName,
                                                  String comment,
                                                  ArrayList genlMts)
        throws IOException, UnknownHostException, CycApiException {
        //traceOn();
        CycConstant[] mts = {null, null, null};
        String theoryMtName = mtRootName + "Mt";
        String vocabMtName = mtRootName + "VocabMt";
        String vocabMtComment = "The #$VocabularyMicrotheory for #$"+ theoryMtName;
        String dataMtName = mtRootName + "DataMt";
        String dataMtComment = "The #$DataMicrotheory for #$"+ theoryMtName;
        CycConstant worldLikeOursMt = getKnownConstantByGuid("bf4c781d-9c29-11b1-9dad-c379636f7270");
        CycConstant currentWorldDataMt = getKnownConstantByGuid("bf192b1e-9c29-11b1-9dad-c379636f7270");
        CycConstant genlMt_Vocabulary = getKnownConstantByGuid("c054a49e-9c29-11b1-9dad-c379636f7270");

        CycConstant theoryMicrotheory = getKnownConstantByGuid("be5275a8-9c29-11b1-9dad-c379636f7270");
        CycConstant theoryMt = createMicrotheory(theoryMtName,
                                                 comment,
                                                 theoryMicrotheory,
                                                 genlMts);
        CycConstant vocabularyMicrotheory =
            getKnownConstantByGuid("bda19dfd-9c29-11b1-9dad-c379636f7270");
        CycConstant vocabMt = createMicrotheory(vocabMtName,
                                                vocabMtComment,
                                                vocabularyMicrotheory,
                                                new ArrayList());
        CycConstant dataMicrotheory = getKnownConstantByGuid("be5275a8-9c29-11b1-9dad-c379636f7270");
        CycConstant dataMt = createMicrotheory(dataMtName,
                                               dataMtComment,
                                               dataMicrotheory,
                                               new ArrayList());
        assertGaf(baseKB, genlMt_Vocabulary, theoryMt, vocabMt);
        assertGaf(baseKB, genlMt, dataMt, theoryMt);
        assertGaf(baseKB, genlMt, worldLikeOursMt, theoryMt);
        assertGaf(baseKB, genlMt, currentWorldDataMt, dataMt);
        mts[0] = theoryMt;
        mts[1] = vocabMt;
        mts[2] = dataMt;
        //traceOff();
        return mts;
    }

    /**
     * Assert that the specified CycConstant is a collection in the UniversalVocabularyMt.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given collection term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsaCollection (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt, isa, cycFort, collection);
    }

    /**
     * Assert that the specified CycConstant is a collection in the specified defining microtheory MT.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given collection term
     * @@param mt the assertion microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsaCollection (CycFort cycFort,
                                     ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt, isa, cycFort, collection);
    }

    /**
     * Assert that the genlsCollection is a genls of specCollection,
     * in the specified defining microtheory MT.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specCollectionName the name of the more specialized collection
     * @@param genlsCollectionName the name of the more generalized collection
     * @@param mtName the assertion microtheory name
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenls (String specCollectionName,
                             String genlsCollectionName,
                             String mtName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(getKnownConstantByName(mtName),
                  genls,
                  getKnownConstantByName(specCollectionName),
                  getKnownConstantByName(genlsCollectionName));
    }

    /**
     * Assert that the genlsCollection is a genls of specCollection,
     * in the UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specCollectionName the name of the more specialized collection
     * @@param genlsCollectionName the name of the more generalized collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenls (String specCollectionName,
                             String genlsCollectionName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt,
                  genls,
                  getKnownConstantByName(specCollectionName),
                  getKnownConstantByName(genlsCollectionName));
    }

    /**
     * Assert that the genlsCollection is a genls of specCollection,
     * in the UniveralVocabularyMt.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specCollection the more specialized collection
     * @@param genlsCollection the more generalized collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenls (CycFort specCollection,
                             CycFort genlsCollection)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt, genls, specCollection, genlsCollection);
    }

    /**
     * Assert that the genlsCollection is a genls of specCollection,
     * in the specified defining microtheory MT.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specCollection the more specialized collection
     * @@param genlsCollection the more generalized collection
     * @@param mt the assertion microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenls (CycFort specCollection,
                             CycFort genlsCollection,
                             ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt, genls, specCollection, genlsCollection);
    }

    /**
     * Assert that the more general predicate is a genlPreds of the more specialized
     * predicate, asserted in the UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specPredName the name of the more specialized predicate
     * @@param genlPredName the name of the more generalized predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenlPreds (String specPredName,
                                 String genlPredName)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant genlPreds =
            getKnownConstantByGuid("bd5b4951-9c29-11b1-9dad-c379636f7270");
        assertGaf(universalVocabularyMt,
                  genlPreds,
                  getKnownConstantByName(specPredName),
                  getKnownConstantByName(genlPredName));
    }

    /**
     * Assert that the more general predicate is a genlPreds of the more specialized
     * predicate, asserted in the UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specPred the more specialized predicate
     * @@param genlsPred the more generalized predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenlPreds (CycFort specPred,
                                 CycFort genlPred)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant genlPreds =
            getKnownConstantByGuid("bd5b4951-9c29-11b1-9dad-c379636f7270");
        assertGaf(universalVocabularyMt,
                  genlPreds,
                  specPred,
                  genlPred);
    }

    /**
     * Assert that term1 is conceptually related to term2 in the specified microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param term1 the first symbol
     * @@param term2 the second symbol
     * @@param mt the microtheory in which the assertion is made
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertConceptuallyRelated (CycFort term1,
                                           CycFort term2,
                                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant conceptuallyRelated =
            getKnownConstantByGuid("bd58803e-9c29-11b1-9dad-c379636f7270");
        assertGaf(mt,
                  conceptuallyRelated,
                  term1,
                  term2);
    }

    /**
     * Assert that the more general micortheory is a genlMt of the more specialized
     * microtheory, asserted in the UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specMtName the name of the more specialized microtheory
     * @@param genlMtName the name of the more generalized microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenlMt (String specMtName,
                              String genlsMtName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt,
                  genlMt,
                  getKnownConstantByName(specMtName),
                  getKnownConstantByName(genlsMtName));
    }

    /**
     * Assert that the more general micortheory is a genlMt of the more specialized
     * microtheory, asserted in the UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param specMtName the more specialized microtheory
     * @@param genlMtName the more generalized microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertGenlMt (CycFort specMt,
                              CycFort genlsMt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt,
                  this.genlMt,
                  specMt,
                  genlsMt);
    }

    /**
     * Assert that the cycFort is a collection in the UniversalVocabularyMt.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFortName the collection element name
     * @@param collectionName the collection name
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsa (String cycFortName,
                           String collectionName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt,
                  isa,
                  getKnownConstantByName(cycFortName),
                  getKnownConstantByName(collectionName));
    }

    /**
     * Assert that the cycFort is a collection,
     * in the specified defining microtheory MT.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFortName the collection element name
     * @@param collectionName the collection name
     * @@param mtName the assertion microtheory name
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsa (String cycFortName,
                           String collectionName,
                           String mtName)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(getKnownConstantByName(mtName),
                  isa,
                  getKnownConstantByName(cycFortName),
                  getKnownConstantByName(collectionName));
    }

    /**
     * Assert that the cycFort is a collection,
     * in the specified defining microtheory MT.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the collection element
     * @@param aCollecton the collection
     * @@param mt the assertion microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsa (CycFort cycFort,
                           CycFort aCollection,
                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt, isa, cycFort, aCollection);
    }

    /**
     * Assert that the cycFort is a collection,
     * in the UniversalVocabularyMt.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the collection element
     * @@param aCollecton the collection
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsa (CycFort cycFort,
                           CycFort aCollection)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(universalVocabularyMt, isa, cycFort, aCollection);
    }

    /**
     * Assert that the specified CycConstant is a #$BinaryPredicate in the specified defining
     * microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given term
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsaBinaryPredicate (CycFort cycFort)
        throws IOException, UnknownHostException, CycApiException {
        assertIsa(cycFort, binaryPredicate, universalVocabularyMt);
    }

    /**
     * Assert that the specified CycConstant is a #$BinaryPredicate in the specified defining
     * microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given term
     * @@param mt the defining microtheory
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertIsaBinaryPredicate (CycFort cycFort,
                                          ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        assertIsa(cycFort, binaryPredicate, mt);
    }

    /**
     * Constructs a new <tt>CycList<tt> object by parsing a string.
     *
     * @@param string the string in CycL external (EL). For example:<BR>
     * <code>(#$isa #$Dog #$TameAnimal)</code>
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList makeCycList(String string) throws CycApiException {
        return (new CycListParser(this)).read(string);
    }

    /**
     * Returns a new <tt>CycConstant</tt> object using the constant name,
     * recording bookkeeping information and archiving to the Cyc transcript.
     *
     * @@param name Name of the constant. If prefixed with "#$", then the prefix is
     * removed for canonical representation.
     * @@return a new <tt>CycConstant</tt> object using the constant name,
     * recording bookkeeping information and archiving to the Cyc transcript
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant makeCycConstant(String name)
        throws UnknownHostException, IOException, CycApiException {
        String constantName = name;
        if (constantName.startsWith("#$"))
            constantName = constantName.substring(2);
        CycConstant cycConstant = this.getConstantByName(name);
        if (cycConstant != null)
            return cycConstant;
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            withBookkeepingInfo() +
            "(clet ((*require-case-insensitive-name-uniqueness* nil)\n" +
            "       (*the-cyclist* " + cyclistName + ")\n" +
            "       (*ke-purpose* " + projectName + "))\n" +
            "  (ke-create-now \"" + constantName + "\")))";
        Object object = converseObject(command);
        if (object instanceof CycConstant)
            cycConstant = (CycConstant) object;
        else
            throw new CycApiException("Cannot create new constant for " + name);
        cycConstant.getName();
        cycConstant.getGuid();
        CycObjectFactory.addCycConstantCacheByName(cycConstant);
        CycObjectFactory.addCycConstantCacheById(cycConstant);
        return cycConstant;
    }

    /**
     * Returns a new unique <tt>CycConstant</tt> object using the constant start name prefixed
     * by TMP-, recording bookkeeping information and but without archiving to the Cyc transcript. 
     * If the start name begins with #$ that portion of the start name is ignored.
     *
     * @@param startName the starting name of the constant which will be made unique
     * using a suffix.
     * @@return a new <tt>CycConstant</tt> object using the constant starting name,
     * recording bookkeeping information and archiving to the Cyc transcript
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant makeUniqueCycConstant(String startName)
        throws UnknownHostException, IOException, CycApiException {
        String constantName = startName;
        if (constantName.startsWith("#$"))
            constantName = constantName.substring(2);
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            withBookkeepingInfo() +
            "(clet ((*require-case-insensitive-name-uniqueness* nil)\n" +
            "       (*the-cyclist* " + cyclistName + ")\n" +
            "       (*ke-purpose* " + projectName + "))\n" +
            "  (gentemp-constant \"" + constantName + "\")))";
        CycConstant cycConstant = (CycConstant) converseObject(command);
        cycConstant.getName();
        cycConstant.getGuid();
        CycObjectFactory.addCycConstantCacheByName(cycConstant);
        CycObjectFactory.addCycConstantCacheById(cycConstant);
        return cycConstant;
    }

    /**
     * Returns a new unique <tt>CycConstant</tt> object using the constant start name and prefix,
     * recording bookkeeping information and but without archiving to the Cyc transcript. If the
     * start name begins with #$ that portion of the start name is ignored.
     *
     * @@param startName the starting name of the constant which will be made unique
     * using a suffix.
     * @@param prefix the prefix
     * @@return a new <tt>CycConstant</tt> object using the constant starting name,
     * recording bookkeeping information and archiving to the Cyc transcript
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant makeUniqueCycConstant(String startName, String prefix)
        throws UnknownHostException, IOException, CycApiException {
        String constantName = startName;
        if (constantName.startsWith("#$"))
            constantName = constantName.substring(2);
        String projectName = "nil";
        if (project != null)
            projectName = project.stringApiValue();
        String cyclistName = "nil";
        if (cyclist != null)
            cyclistName = cyclist.stringApiValue();
        String command =
            withBookkeepingInfo() +
            "(clet ((*require-case-insensitive-name-uniqueness* nil)\n" +
            "       (*the-cyclist* " + cyclistName + ")\n" +
            "       (*ke-purpose* " + projectName + "))\n" +
            "  (gentemp-constant \"" + constantName + "\" \"" + prefix + "\")))";
        CycConstant cycConstant = (CycConstant) converseObject(command);
        cycConstant.getName();
        cycConstant.getGuid();
        CycObjectFactory.addCycConstantCacheByName(cycConstant);
        CycObjectFactory.addCycConstantCacheById(cycConstant);
        return cycConstant;
    }

    /**
     * Returns a list of bindings for a query with a single unbound variable.
     *
     * @@param query the query to be asked in the knowledge base
     * @@param variable the single unbound variable in the query for which bindings are sought
     * @@param mt the microtheory in which the query is asked
     * @@return a list of bindings for the query
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList askWithVariable (CycList query,
                                    CycVariable variable,
                                    ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer queryBuffer = new StringBuffer();
        queryBuffer.append("(clet ((*cache-inference-results* nil) ");
        queryBuffer.append("       (*compute-inference-results* nil) ");
        queryBuffer.append("       (*unique-inference-result-bindings* t) ");
        queryBuffer.append("       (*generate-readable-fi-results* nil)) ");
        queryBuffer.append("  (without-wff-semantics ");
        queryBuffer.append("    (ask-template '" + variable.stringApiValue() + " ");
        queryBuffer.append("                  '" + query.stringApiValue() + " ");
        queryBuffer.append("                  " + mt.stringApiValue() + " ");
        queryBuffer.append("                  0 nil nil nil)))");
        return converseList(queryBuffer.toString());
    }

    /**
     * Returns a list of bindings for a query with unbound variables.  The bindings each consist
     * of a list in the order of the unbound variables list parameter, in which each bound term
     * is the binding for the corresponding variable.
     *
     * @@param query the query to be asked in the knowledge base
     * @@param variables the list of unbound variables in the query for which bindings are sought
     * @@param mt the microtheory in which the query is asked
     * @@return a list of bindings for the query
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList askWithVariables (CycList query,
                                     ArrayList variables,
                                     ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer queryBuffer = new StringBuffer();
        queryBuffer.append("(clet ((*cache-inference-results* nil) ");
        queryBuffer.append("       (*compute-inference-results* nil) ");
        queryBuffer.append("       (*unique-inference-result-bindings* t) ");
        queryBuffer.append("       (*generate-readable-fi-results* nil)) ");
        queryBuffer.append("  (without-wff-semantics ");
        queryBuffer.append("    (ask-template '" + (new CycList(variables)).stringApiValue() + " ");
        queryBuffer.append("                  '" + query.stringApiValue() + " ");
        queryBuffer.append("                  " + mt.stringApiValue() + " ");
        queryBuffer.append("                  0 nil nil nil)))");
        return converseList(queryBuffer.toString());
    }

    /**
     * Returns <tt>true</tt> iff the query is true in the knowledge base.
     *
     * @@param query the query to be asked in the knowledge base
     * @@param mt the microtheory in which the query is asked
     * @@return <tt>true</tt> iff the query is true in the knowledge base
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isQueryTrue (CycList query,
                                ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("cyc-query"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.quote);
        command1.add(query);
        command.add(mt);
        CycList response = converseList(command);
        return response.size() > 0;
    }

    /**
     * Returns <tt>true</tt> iff the query is true in the knowledge base, implements a cache
     * to avoid asking the same question twice from the KB.
     *
     * @@param query the query to be asked in the knowledge base
     * @@param mt the microtheory in which the query is asked
     * @@return <tt>true</tt> iff the query is true in the knowledge base
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isQueryTrue_Cached (CycList query,
                                          ELMT mt)
        throws IOException, CycApiException {
        boolean answer;
        Boolean isQueryTrue = (Boolean) askCache.getElement(query);
        if (isQueryTrue != null) {
            answer = isQueryTrue.booleanValue();
            return answer;
        }
        answer = isQueryTrue(query, mt);
        askCache.addElement(query, new Boolean(answer));
        return answer;
    }

    /**
     * Returns the count of the instances of the given collection.
     *
     * @@param collection the collection whose instances are counted
     * @@param mt microtheory (including its genlMts) in which the count is determined
     * @@return the count of the instances of the given collection
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int countAllInstances(CycFort collection, ELMT mt) throws IOException, CycApiException {
        return this.converseInt("(count-all-instances " +
                                collection.stringApiValue() + " " +
                                mt.stringApiValue() + ")");
    }

    /**
     * Returns the count of the instances of the given collection, implements a cache
     * to avoid asking the same question twice from the KB.
     *
     * @@param collection the collection whose instances are counted
     * @@param mt microtheory (including its genlMts) in which the count is determined
     * @@return the count of the instances of the given collection
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int countAllInstances_Cached(CycFort collection,
                                        ELMT mt)
        throws IOException, CycApiException {
        int answer;
        Integer countAllInstances = (Integer) countAllInstancesCache.getElement(collection);
        if (countAllInstances != null) {
            answer = countAllInstances.intValue();
            return answer;
        }
        answer = countAllInstances(collection, mt);
        countAllInstancesCache.addElement(collection, new Integer(answer));
        return answer;
    }

    /**
     * Gets a list of the backchaining implication rules which might apply to the given rule.
     *
     * @@param predicate the predicate for which backward chaining implication rules are sought
     * @@param formula the literal for which backward chaining implication rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for backchaining implication rules takes place
     * @@return a list of the backchaining implication rules which might apply to the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getBackchainImplicationRules (CycConstant predicate, CycList formula, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer command = new StringBuffer();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.append("(clet (backchain-rules formula) ");
            command.append("  (with-all-mts ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + formula.stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        else {
            command.append("(clet (backchain-rules formula) ");
            command.append("  (with-mt " + mt.stringApiValue() + " ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + formula.stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        //this.traceOn();
        return converseList(command.toString());
d10119 4
a10122 41
    /**
     * Gets a list of the forward chaining implication rules which might apply to the given rule.
     *
     * @@param predicate the predicate for which forward chaining implication rules are sought
     * @@param formula the literal for which forward chaining implication rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for forward chaining rules takes place
     * @@return a list of the forward chaining implication rules which might apply to the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getForwardChainRules (CycConstant predicate, CycList formula, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer command = new StringBuffer();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.append("(clet (backchain-rules formula) ");
            command.append("  (with-all-mts ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + formula.stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        else {
            command.append("(clet (backchain-rules formula) ");
            command.append("  (with-mt " + mt.stringApiValue() + " ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + formula.stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        return converseList(command.toString());
    }
d10124 2
a10125 40
    /**
     * Gets a list of the backchaining implication rules which might apply to the given predicate.
     *
     * @@param predicate the predicate for which backchaining rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for backchaining rules takes place
     * @@return a list of the backchaining implication rules which might apply to the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getBackchainRules (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer command = new StringBuffer();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.append("(clet (backchain-rules) ");
            command.append("  (with-all-mts ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
            command.append("                                :sense :pos ");
            command.append("                                :done nil ");
            command.append("                                :direction :backward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        else {
            command.append("(clet (backchain-rules) ");
            command.append("  (with-mt " + mt.stringApiValue() + " ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
            command.append("                                :sense :pos ");
            command.append("                                :done nil ");
            command.append("                                :direction :backward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        //this.traceOn();
        return converseList(command.toString());
d10127 51
a10177 40

    /**
     * Gets a list of the forward chaining implication rules which might apply to the given predicate.
     *
     * @@param predicate the predicate for which forward chaining rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for forward chaining rules takes place
     * @@return a list of the forward chaining implication rules which might apply to the given predicate
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getForwardChainRules (CycConstant predicate, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        StringBuffer command = new StringBuffer();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.append("(clet (backchain-rules) ");
            command.append("  (with-all-mts ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
            command.append("                                :sense :pos ");
            command.append("                                :done nil ");
            command.append("                                :direction :forward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        else {
            command.append("(clet (backchain-rules) ");
            command.append("  (with-mt " + mt.stringApiValue() + " ");
            command.append("    (do-predicate-rule-index (rule " + predicate.stringApiValue() + " ");
            command.append("                                :sense :pos ");
            command.append("                                :done nil ");
            command.append("                                :direction :forward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
            command.append("   backchain-rules)");
        }
        return converseList(command.toString());
d10179 136
a10314 471

    /**
     * Gets the value of a given KB symbol.  This is intended mainly for test case setup.
     *
     * @@param symbol the KB symbol which will have a value bound
     * @@return the value assigned to the symbol
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Object getSymbolValue (CycSymbol cycSymbol)
        throws IOException, UnknownHostException, CycApiException {
        return converseObject("(symbol-value '" + cycSymbol + ")");
    }

    /**
     * Sets a KB symbol to have the specified value.  This is intended mainly for test case setup.  If the symbol does
     * not exist at the KB, then it will be created and assigned the value.
     *
     * @@param symbol the KB symbol which will have a value bound
     * @@param value the value assigned to the symbol
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void setSymbolValue (CycSymbol cycSymbol, Object value)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("csetq"));
        command.add(cycSymbol);
        command.add(value);
        converseVoid(command);
    }

    /**
     * Returns <tt>true</tt> iff <tt>CycList</tt> represents a well formed formula.
     *
     * @@param cycList the candidate well-formed-formula
     * @@return true iff cycList represents a well formed formula
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isWellFormedFormula (CycList cycList)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("el-wff?"));
        CycList command2 = new CycList();
        command1.add(command2);
        command2.add(CycObjectFactory.quote);
        command2.add(cycList);
        return converseBoolean(command);
    }

    /**
     * Returns <tt>true</tt> iff backchain inference on the given predicate is required.
     *
     * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining required status is sought
     * @@param mt microtheory (including its genlMts) in which the backchaining required status is sought
     * @@return <tt>true</tt> iff backchain inference on the given predicate is required
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isBackchainRequired(CycConstant predicate, ELMT mt)
        throws IOException, CycApiException {
        CycConstant backchainRequired =
            getKnownConstantByGuid("beaa3d29-9c29-11b1-9dad-c379636f7270");
        return hasSomePredicateUsingTerm(backchainRequired,
                                         predicate,
                                         new Integer(1),
                                         mt);
    }

    /**
     * Returns <tt>true</tt> iff backchain inference on the given predicate is encouraged.
     *
     * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining encouraged status is sought
     * @@param mt microtheory (including its genlMts) in which the backchaining encouraged status is sought
     * @@return <tt>true</tt> iff backchain inference on the given predicate is encouraged
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isBackchainEncouraged(CycConstant predicate, ELMT mt)
        throws IOException, CycApiException {
        CycConstant backchainEncouraged =
            getKnownConstantByGuid("c09d1cea-9c29-11b1-9dad-c379636f7270");
        return hasSomePredicateUsingTerm(backchainEncouraged,
                                         predicate,
                                         new Integer(1),
                                         mt);
    }

    /**
     * Returns <tt>true</tt> iff backchain inference on the given predicate is discouraged.
     *
     * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining discouraged status is sought
     * @@param mt microtheory (including its genlMts) in which the backchaining discouraged status is sought
     * @@return <tt>true</tt> iff backchain inference on the given predicate is discouraged
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isBackchainDiscouraged(CycConstant predicate, ELMT mt)
        throws IOException, CycApiException {
        CycConstant backchainDiscouraged =
            getKnownConstantByGuid("bfcbce14-9c29-11b1-9dad-c379636f7270");
        return hasSomePredicateUsingTerm(backchainDiscouraged,
                                         predicate,
                                         new Integer(1),
                                         mt);
    }

    /**
     * Returns <tt>true</tt> iff backchain inference on the given predicate is forbidden.
     *
     * @@param predicate the <tt>CycConstant</tt> predicate for which backchaining forbidden status is sought
     * @@param mt microtheory (including its genlMts) in which the backchaining forbidden status is sought
     * @@return <tt>true</tt> iff backchain inference on the given predicate is forbidden
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isBackchainForbidden(CycConstant predicate, ELMT mt)
        throws IOException, CycApiException {
        CycConstant backchainForbidden =
            getKnownConstantByGuid("bfa4e9d2-9c29-11b1-9dad-c379636f7270");
        return hasSomePredicateUsingTerm(backchainForbidden,
                                         predicate,
                                         new Integer(1),
                                         mt);
    }

    /**
     * Returns <tt>true</tt> iff the predicate has the irreflexive property:
     * (#$isa ?PRED #$IrreflexsiveBinaryPredicate).
     *
     * @@param predicate the <tt>CycConstant</tt> predicate for which irreflexive status is sought
     * @@param mt microtheory (including its genlMts) in which the irreflexive status is sought
     * @@return <tt>true</tt> iff the predicate has the irreflexive property:
     * (#$isa ?PRED #$IrreflexsiveBinaryPredicate)
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isIrreflexivePredicate(CycConstant predicate, ELMT mt)
        throws IOException, CycApiException {
        CycConstant irreflexiveBinaryPredicate =
            getKnownConstantByGuid("bd654be7-9c29-11b1-9dad-c379636f7270");
        return this.isa(predicate, irreflexiveBinaryPredicate, mt);
    }

    /**
     * Returns <tt>true</tt> iff any ground formula instances exist having the given predicate,
     * and the given term in the given argument position.
     *
     * @@param term the term present at the given argument position
     * @@param predicate the <tt>CycConstant</tt> predicate for the formula
     * @@param argumentPosition the argument position of the given term in the ground formula
     * @@param mt microtheory (including its genlMts) in which the existence is sought
     * @@return <tt>true</tt> iff any ground formula instances exist having the given predicate,
     * and the given term in the given argument position
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean hasSomePredicateUsingTerm(CycConstant predicate,
                                             CycFort term,
                                             Integer argumentPosition,
                                             ELMT mt) throws IOException, CycApiException {
        CycList command = new CycList();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.add(CycObjectFactory.makeCycSymbol("some-pred-value-in-any-mt"));
            command.add(term.cycListApiValue());
            command.add(predicate.cycListApiValue());
        }
        else {
            command.add(CycObjectFactory.makeCycSymbol("some-pred-value-in-relevant-mts"));
            command.add(term.cycListApiValue());
            command.add(predicate.cycListApiValue());
            command.add(mt.cycListApiValue());
        }
        command.add(argumentPosition);
        //this.traceOn();
        return converseBoolean(command);
    }

    /**
     * Returns the count of the assertions indexed according to the given pattern,
     * using the best index (from among the predicate and argument indices).  The formula
     * can contain variables.
     *
     * @@param formula the formula whose indexed instances are counted
     * @@param mt microtheory (including its genlMts) in which the count is determined
     * @@return the count of the assertions indexed according to the given pattern,
     * using the best index (from among the predicate and argument indices)
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int countUsingBestIndex(CycList formula, ELMT mt) throws IOException, CycApiException {
        CycList command = new CycList();
        CycConstant inferencePsc = this.getKnownConstantByGuid("bd58915a-9c29-11b1-9dad-c379636f7270");
        CycConstant everythingPsc = this.getKnownConstantByGuid("be7f041b-9c29-11b1-9dad-c379636f7270");
        if (mt.equals(inferencePsc) ||
            mt.equals(everythingPsc)) {
            command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));
        }
        else {
            command.add(CycObjectFactory.makeCycSymbol("with-mt"));
            command.add(mt.cycListApiValue());
        }
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("best-index-count"));
        CycList command2 = new CycList();
        command1.add(command2);
        command2.add(CycObjectFactory.quote);
        command2.add(formula.cycListApiValue());
        command1.add(CycObjectFactory.t);
        command1.add(CycObjectFactory.t);
        //this.traceOn();
        return converseInt(command);
    }

    /**
     * Imports a MUC (Message Understanding Conference) formatted symbolic expression into
     * cyc via the function which parses the expression and creates assertions for the
     * contained concepts and relations between them.
     *
     * @@param mucExpression the MUC (Message Understanding Conference) formatted symbolic
     * expression
     * @@param mtName the name of the microtheory in which the imported assertions will be made
     * @@return the number of assertions imported from the input MUC expression
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int importMucExpression(CycList mucExpression,
                                   String mtName) throws IOException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("convert-netowl-sexpr-to-cycl-assertions"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.quote);
        command1.add(mucExpression.cycListApiValue());
        command.add(mtName);
        //this.traceOn();
        return converseInt(command);
    }

    /**
     * Returns a list of parsing expressions, each consisting of a parsing span expression,
     * and a list of parsed terms.
     * <pre>
     * (RKF-PHRASE-READER "penguins" #$RKFEnglishLexicalMicrotheoryPSC #$InferencePSC)
     * ==>
     * (((0) (#$Penguin #$PittsburghPenguins)))
     * </pre>
     *
     * @@param text the phrase to be parsed
     * @@param parsingMt the microtheory in which lexical info is asked
     * @@param domainMt the microtherory in which the info about candidate terms is asked
     * @@return a parsing expression consisting of a parsing span expression, and a list
     * of parsed terms
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList rkfPhraseReader (String text, String parsingMt, String domainMt)
        throws IOException, CycApiException {
        return rkfPhraseReader(text,
                               getKnownConstantByName(parsingMt),
                               getKnownConstantByName(domainMt));
    }

    /**
     * Returns a list of parsing expressions, each consisting of a parsing span expression,
     * and a list of parsed terms.
     * <pre>
     * (RKF-PHRASE-READER "penguins" #$RKFEnglishLexicalMicrotheoryPSC #$InferencePSC)
     * ==>
     * (((0) (#$Penguin #$PittsburghPenguins)))
     * </pre>
     *
     * @@param text the phrase to be parsed
     * @@param parsingMt the microtheory in which lexical info is asked
     * @@param domainMt the microtherory in which the info about candidate terms is asked
     * @@return a parsing expression consisting of a parsing span expression, and a list
     * of parsed terms
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList rkfPhraseReader (String text, CycFort parsingMt, CycFort domainMt)
        throws IOException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("rkf-phrase-reader"));
        command.add(text);
        command.add(parsingMt);
        command.add(domainMt);
        return converseList(command);
    }

    /**
     * Returns a list of disambiguation expressions, corresponding to each of the terms
     * in the given list of objects.
     *
     * <pre>
     * (GENERATE-DISAMBIGUATION-PHRASES-AND-TYPES (QUOTE (#$Penguin #$PittsburghPenguins)))
     * ==>
     * ((#$Penguin "penguin" #$Bird "bird")
     *  (#$PittsburghPenguins "the Pittsburgh Penguins" #$IceHockeyTeam "ice hockey team"))
     * </pre>
     *
     * @@param objects the list of terms to be disambiguated
     * @@return a list of disambiguation expressions, corresponding to each of the terms
     * in the given list of objects
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList generateDisambiguationPhraseAndTypes (CycList objects)
        throws IOException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("generate-disambiguation-phrases-and-types"));
        command.addQuoted(objects);
        return converseList(command);
    }

    /**
     * Returns the arity of the given predicate.
     *
     * @@param predicate the given predicate whose number of arguments is sought
     * @@return the arity of the given predicate, or zero if the argument is not
     * a predicate
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public int getArity (CycFort predicate)
        throws IOException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("with-all-mts"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("arity"));
        command1.add(predicate);
        Object object = this.converseObject(command);
        if (object instanceof Integer)
            return ((Integer) object).intValue();
        else
            return 0;
    }

    /**
     * Returns the list of arg2 values of binary gafs, given the predicate
     * and arg1, looking in all microtheories.
     *
     * @@param predicate the given predicate for the gaf pattern
     * @@param arg1 the given first argument of the gaf
     * @@return the list of arg2 values of the binary gafs
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getArg2s (CycFort predicate, Object arg1)
        throws IOException, CycApiException {
        CycList query = new CycList();
        query.add(predicate);
        query.add(arg1);
        CycVariable variable = CycObjectFactory.makeCycVariable("?arg2");
        query.add(variable);
        return (CycList) askWithVariable(query, variable, inferencePSC);
    }

    /**
     * Returns the single (first) arg2 value of a binary gaf, given the predicate
     * and arg0, looking in all microtheories.  Return null if none found.
     *
     * @@param predicate the given predicate for the gaf pattern
     * @@param arg1 the given first argument of the gaf
     * @@return the single (first) arg2 value of the binary gaf(s)
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public Object getArg2 (CycFort predicate, Object arg1)
        throws IOException, CycApiException {
        CycList arg2s = getArg2s(predicate, arg1);
        if (arg2s.isEmpty())
            return null;
        else
            return arg2s.first();
    }

    /**
     * Returns true if formula is well-formed in the relevant mt.
     *
     * @@param formula the given EL formula
     * @@param mt the relevant mt
     * @@return true if formula is well-formed in the relevant mt, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isFormulaWellFormed (CycList formula, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(el-formula-ok? '" + formula.stringApiValue() +
                               " " + mt.stringApiValue() + ")");
    }

    /**
     * Returns true if formula is well-formed Non Atomic Reifable Term.
     *
     * @@param formula the given EL formula
     * @@return true if formula is well-formed Non Atomic Reifable Term, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isCycLNonAtomicReifableTerm (CycList formula)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(cycl-nart-p '" + formula.stringApiValue() + ")");
    }

    /**
     * Returns true if formula is well-formed Non Atomic Un-reifable Term.
     *
     * @@param formula the given EL formula
     * @@return true if formula is well-formed Non Atomic Un-reifable Term, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isCycLNonAtomicUnreifableTerm (CycList formula)
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(cycl-naut-p '" + formula.stringApiValue() + ")");
    }

    /**
     * Creates a new Collector microtheory and links it more general mts.
     *
     * @@param mtName the name of the new collector microtheory
     * @@param comment the comment for the new collector microtheory
     * @@param genlMts the list of more general microtheories
     * @@return the new microtheory
     */
    public CycConstant createCollectorMt (String mtName,
                                          String comment,
                                          ArrayList genlMts)
        throws IOException, CycApiException {
        CycConstant collectorMt = getKnownConstantByName("CollectorMicrotheory");
        return createMicrotheory(mtName, comment, collectorMt, genlMts);
        }

    /**
     * Asserts each of the given list of forts to be instances of
     * the given collection in the UniversalVocabularyMt
     *
     * @@param fortNames the list of forts
     * @@param collectionName
     */
    public void assertIsas (ArrayList fortNames,
                            String collectionName)
        throws IOException, CycApiException {
        ArrayList forts = new ArrayList();
        for (int i = 0; i < forts.size(); i++) {
            Object fort = forts.get(i);
            if (fort instanceof String)
                forts.add(getKnownConstantByName((String) fort));
            else if (fort instanceof CycFort)
                forts.add(fort);
            else
                throw new CycApiException(fort + " is neither String nor CycFort");
            assertIsas(forts,
                       getKnownConstantByName(collectionName));
        }
d10317 4
a10320 13
    /**
     * Asserts each of the given list of forts to be instances of
     * the given collection in the UniversalVocabularyMt
     *
     * @@param forts the list of forts
     * @@param collection
     */
    public void assertIsas (ArrayList forts,
                            CycFort collection)
        throws IOException, CycApiException {
        for (int i = 0; i < forts.size(); i++) {
            assertIsa((CycFort) forts.get(i), collection);
        }
d10322 2
a10323 666

    /**
     * Creates a new spindle microtheory in the given spindle system.
     *
     * @@param spindleMtName the name of the new spindle microtheory
     * @@param comment the comment for the new spindle microtheory
     * @@param spindleHeadMtName the name of the spindle head microtheory
     * @@param spindleCollectorMtName the name of the spindle head microtheory
     * @@return the new spindle microtheory in the given spindle system
     */
    public CycConstant createSpindleMt (String spindleMtName,
                                        String comment,
                                        String spindleHeadMtName,
                                        String spindleCollectorMtName)
        throws IOException, CycApiException {
        return createSpindleMt(spindleMtName,
                               comment,
                               getKnownConstantByName(spindleHeadMtName),
                               getKnownConstantByName(spindleCollectorMtName));
    }

    /**
     * Creates a new spindle microtheory in the given spindle system.
     *
     * @@param spindleMtName the name of the new spindle microtheory
     * @@param comment the comment for the new spindle microtheory
     * @@param spindleHeadMt the spindle head microtheory
     * @@param spindleCollectorMt the spindle head microtheory
     * @@return the new spindle microtheory in the given spindle system
     */
    public CycConstant createSpindleMt (String spindleMtName,
                                        String comment,
                                        CycFort spindleHeadMt,
                                        CycFort spindleCollectorMt)
        throws IOException, CycApiException {
        CycConstant spindleMt = getKnownConstantByName("SpindleMicrotheory");
        ArrayList genlMts = new ArrayList();
        genlMts.add(spindleHeadMt);
        CycConstant mt = this.createMicrotheory(spindleMtName,
                                                comment,
                                                spindleMt,
                                                genlMts);
        assertGaf(universalVocabularyMt,
                  genlMt,
                  spindleCollectorMt,
                  mt);
        return mt;
        }

    /**
     * Creates a new binary predicate term.
     *
     * @@param predicateName the name of the new binary predicate
     * @@param predicateType the type of binary predicate, for example
     * #$TransitiveBinaryPredicate, which when null defaults to #$BinaryPredicate
     * @@param comment the comment for the new binary predicate, or null
     * @@param arg1Isa the argument position one type constraint, or null
     * @@param ar2Isa the argument position two type constraint, or null
     * @@param arg1Format the argument position one format constraint, or null
     * @@param arg2Format the argument position two format constraint, or null
     * @@param genlsPreds the more general binary predicate of which this new
     * predicate is a specialization, that when null defaults to
     * #$conceptuallyRelated
     * @@param genFormat the paraphrase generation string, or null
     * @@return the new binary predicate term
     */
    public CycConstant createBinaryPredicate (String predicateName,
                                              String predicateTypeName,
                                              String comment,
                                              String arg1IsaName,
                                              String arg2IsaName,
                                              String arg1FormatName,
                                              String arg2FormatName,
                                              String genlPredsName,
                                              String genFormatString,
                                              String genFormatList)
        throws IOException, CycApiException {
        return createBinaryPredicate(predicateName,
                                     find(predicateTypeName),
                                     comment,
                                     find(arg1IsaName),
                                     find(arg2IsaName),
                                     find(arg1FormatName),
                                     find(arg2FormatName),
                                     find(genlPredsName),
                                     genFormatString,
                                     makeCycList(genFormatList));
        }

    /**
     * Creates a new binary predicate term.
     *
     * @@param predicateName the name of the new binary predicate
     * @@param predicateType the type of binary predicate, for example
     * #$TransitiveBinaryPredicate, which when null defaults to #$BinaryPredicate
     * @@param comment the comment for the new binary predicate, or null
     * @@param arg1Isa the argument position one type constraint, or null
     * @@param ar2Isa the argument position two type constraint, or null
     * @@param arg1Format the argument position one format constraint, or null
     * @@param arg2Format the argument position two format constraint, or null
     * @@param genlsPreds the more general binary predicate of which this new
     * predicate is a specialization, that when null defaults to
     * #$conceptuallyRelated
     * @@param genFormat the paraphrase generation string, or null
     * @@return the new binary predicate term
     */
    public CycConstant createBinaryPredicate (String predicateName,
                                              CycFort predicateType,
                                              String comment,
                                              CycFort arg1Isa,
                                              CycFort arg2Isa,
                                              CycFort arg1Format,
                                              CycFort arg2Format,
                                              CycFort genlPreds,
                                              String genFormatString,
                                              CycList genFormatList)
        throws IOException, CycApiException {
        CycConstant predicate = findOrCreate(predicateName);
        if (predicateType == null)
            assertIsa(predicate, binaryPredicate);
        else
            assertIsa(predicate, predicateType);
        if (comment != null)
            assertComment(predicate, comment, baseKB);
        if (arg1Isa != null)
            assertArgIsa(predicate, 1, arg1Isa);
        if (arg2Isa != null)
            assertArgIsa(predicate, 2, arg2Isa);
        if (arg1Format != null)
            assertArgFormat(predicate, 1, arg1Format);
        if (arg2Format != null)
            assertArgFormat(predicate, 2, arg2Format);
        if (genlPreds == null)
            assertGenlPreds(predicate,
                            // #$conceptuallyRelated
                            getKnownConstantByGuid("bd58803e-9c29-11b1-9dad-c379636f7270"));
        else
            assertGenlPreds(predicate, genlPreds);
        if (genFormatString != null && genFormatList != null)
            assertGenFormat(predicate, genFormatString, genFormatList);
        return predicate;
        }

    /**
     * Creates a new KB subset collection term.
     *
     * @@param constantName the name of the new KB subset collection
     * @@param comment the comment for the new KB subset collection
     * @@return the new KB subset collection term
     */
    public CycConstant createKbSubsetCollection (String constantName,
                                                 String comment)
        throws IOException, CycApiException {
        CycConstant kbSubsetCollection = getKnownConstantByName("KBSubsetCollection");
        CycConstant cycConstant = getConstantByName(constantName);
        if (cycConstant == null)
            cycConstant = createNewPermanent(constantName);
        assertIsa(cycConstant, kbSubsetCollection);
        assertComment(cycConstant, comment, baseKB);
        assertGenls(cycConstant, thing);
        CycFort variableOrderCollection =
            getKnownConstantByGuid("36cf85d0-20a1-11d6-8000-0050dab92c2f");
        assertIsa(cycConstant,
                  variableOrderCollection,
                  baseKB);
        return cycConstant;
        }

    /**
     * Creates a new collection term.
     *
     * @@param collectionName the name of the new collection
     * @@param comment the comment for the collection
     * @@param commentMtName the name of the microtheory in which the comment is asserted
     * @@param isaName the name of the collection of which the new collection is an instance
     * @@param genlsName the name of the collection of which the new collection is a subset
     * @@return the new collection term
     */
    public CycConstant createCollection (String collectionName,
                                         String comment,
                                         String commentMtName,
                                         String isaName,
                                         String genlsName)
        throws IOException, CycApiException {
        CycConstant collection = findOrCreate(collectionName);
        assertComment(collection, comment, getKnownConstantByName(commentMtName));
        assertIsa(collection, getKnownConstantByName(isaName));
        assertGenls(collection, getKnownConstantByName(genlsName));
        return collection;
        }

    /**
     * Creates a new collection term.
     *
     * @@param collection the name of the new collection
     * @@param comment the comment for the collection
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new collection is an instance
     * @@param genls the collection of which the new collection is a subset
     * @@return the new collection term
     */
    public CycFort createCollection (String collectionName,
                                     String comment,
                                     CycFort commentMt,
                                     CycFort isa,
                                     CycFort genls)
        throws IOException, CycApiException {
        return createCollection(findOrCreate(collectionName),
                                comment,
                                commentMt,
                                isa,
                                genls);
        }

    /**
     * Creates a new collection term.
     *
     * @@param collection the new collection
     * @@param comment the comment for the collection
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new collection is an instance
     * @@param genls the collection of which the new collection is a subset
     * @@return the new collection term
     */
    public CycFort createCollection (CycFort collection,
                                     String comment,
                                     CycFort commentMt,
                                     CycFort isa,
                                     CycFort genls)
        throws IOException, CycApiException {
        assertComment(collection, comment, commentMt);
        assertIsa(collection, isa);
        assertGenls(collection, genls);
        return collection;
    }

    /**
     * Creates a new individual term.
     *
     * @@param individual the name of the new individual term
     * @@param comment the comment for the individual
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new individual is an instance
     * @@return the new individual term
     */
    public CycFort createIndividual (String IndividualName,
                                     String comment,
                                     String commentMt,
                                     String isa)
        throws IOException, CycApiException {
        return createIndividual (IndividualName,
                                 comment,
                                 getKnownConstantByName(commentMt),
                                 getKnownConstantByName(isa));
    }

    /**
     * Creates a new individual term.
     *
     * @@param individual the name of the new individual term
     * @@param comment the comment for the individual
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new individual is an instance
     * @@return the new individual term
     */
    public CycFort createIndividual (String IndividualName,
                                     String comment,
                                     CycFort commentMt,
                                     CycFort isa)
        throws IOException, CycApiException {
        CycFort individual = findOrCreate(IndividualName);
        assertComment(individual, comment, commentMt);
        assertIsa(individual, isa);
        return individual;
    }

    /**
     * Creates a new individual-denoting reifiable unary function term.
     *
     * @@param unaryFunction the new collection
     * @@param comment the comment for the unary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new unary function is an instance
     * @@param arg1Isa the kind of objects this unary function takes as its argument
     * @@param resultIsa the kind of object represented by this reified term
     * @@return the new individual-denoting reifiable unary function term
     */
    public CycFort createIndivDenotingUnaryFunction (String unaryFunction,
                                                     String comment,
                                                     String commentMt,
                                                     String arg1Isa,
                                                     String resultIsa)
        throws IOException, CycApiException {
        return createIndivDenotingUnaryFunction (
            findOrCreate(unaryFunction),
            comment,
            getKnownConstantByName(commentMt),
            getKnownConstantByName(arg1Isa),
            getKnownConstantByName(resultIsa));
        }

    /**
     * Creates a new individual-denoting reifiable unary function term.
     *
     * @@param unaryFunction the new collection
     * @@param comment the comment for the unary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new unary function is an instance
     * @@param arg1Isa the kind of objects this unary function takes as its argument
     * @@param resultIsa the kind of object represented by this reified term
     * @@return the new individual-denoting reifiable unary function term
     */
    public CycFort createIndivDenotingUnaryFunction (CycFort unaryFunction,
                                                     String comment,
                                                     CycFort commentMt,
                                                     CycFort arg1Isa,
                                                     CycFort resultIsa)
        throws IOException, CycApiException {
        assertComment(unaryFunction, comment, commentMt);
        // (#$isa unaryFunction #$UnaryFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd58af89-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$ReifiableFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$IndividualDenotingFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd58fad9-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$Function-Denotational)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));
        assertArgIsa(unaryFunction, 1, arg1Isa);
        assertResultIsa(unaryFunction, resultIsa);
        return unaryFunction;
        }

    /**
     * Creates a new collection-denoting reifiable unary function term.
     *
     * @@param unaryFunction the new collection
     * @@param comment the comment for the unary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new unary function is an instance
     * @@param arg1Isa the isa type constraint for the argument
     * @@param arg1GenlName the genls type constraint for the argument if it is a collection
     * @@param resultIsa the isa object represented by this reified term
     * @@param resultGenlName the genls object represented by this reified term
     * @@return the new collection-denoting reifiable unary function term
     */
    public CycFort createCollectionDenotingUnaryFunction (String unaryFunction,
                                                          String comment,
                                                          String commentMt,
                                                          String arg1Isa,
                                                          String arg1GenlName,
                                                          String resultIsa,
                                                          String resultGenlName)
        throws IOException, CycApiException {
        CycFort arg1Genl;
        if (arg1GenlName != null)
            arg1Genl = getKnownConstantByName(arg1GenlName);
        else
            arg1Genl = null;
        CycFort resultGenl;
        if (resultGenlName != null)
            resultGenl = getKnownConstantByName(resultGenlName);
        else
            resultGenl = null;
        return createCollectionDenotingUnaryFunction (
            findOrCreate(unaryFunction),
            comment,
            getKnownConstantByName(commentMt),
            getKnownConstantByName(arg1Isa),
            arg1Genl,
            getKnownConstantByName(resultIsa),
            resultGenl);
        }

    /**
     * Creates a new collection-denoting reifiable unary function term.
     *
     * @@param unaryFunction the new collection
     * @@param comment the comment for the unary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param arg1Isa the isa type constraint for the argument
     * @@param arg1Genl the genls type constraint for the argument if it is a collection
     * @@param resultIsa the isa object represented by this reified term
     * @@param resultGenl the genls object represented by this reified term
     * @@return the new collection-denoting reifiable unary function term
     */
    public CycFort createCollectionDenotingUnaryFunction (CycFort unaryFunction,
                                                          String comment,
                                                          CycFort commentMt,
                                                          CycFort arg1Isa,
                                                          CycFort arg1Genl,
                                                          CycFort resultIsa,
                                                          CycFort resultGenl)
        throws IOException, CycApiException {
        assertComment(unaryFunction, comment, commentMt);
        // (#$isa unaryFunction #$UnaryFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd58af89-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$ReifiableFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$CollectionDenotingFunction)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd58806a-9c29-11b1-9dad-c379636f7270"));
        // (#$isa unaryFunction #$Function-Denotational)
        assertIsa(unaryFunction,
                  getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));
        assertArgIsa(unaryFunction, 1, arg1Isa);
        if (arg1Genl != null)
            assertArg1Genl(unaryFunction, arg1Genl);
        assertResultIsa(unaryFunction, resultIsa);
        if (resultGenl != null)
            assertResultGenl(unaryFunction, resultGenl);
        return unaryFunction;
        }

    /**
     * Creates a new collection-denoting reifiable binary function term.
     *
     * @@param binaryFunction the new collection
     * @@param comment the comment for the binary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new binary function is an instance
     * @@param arg1Isa the kind of objects this binary function takes as its first
     * argument, or null
     * @@param arg2Isa the kind of objects this binary function takes as its second
     * argument, or null
     * @@param arg1Genls the general collections this binary function takes as its first
     * argument, or null
     * @@param arg2Genls the general collections this binary function takes as its second
     * argument, or null
     * @@param resultIsa the kind of object represented by this reified term
     * @@return the new collection-denoting reifiable binary function term
     */
    public CycFort createCollectionDenotingBinaryFunction (String binaryFunction,
                                                           String comment,
                                                           String commentMt,
                                                           String arg1IsaName,
                                                           String arg2IsaName,
                                                           String arg1GenlsName,
                                                           String arg2GenlsName,
                                                           String resultIsa)
        throws IOException, CycApiException {
        CycFort arg1Isa = null;
        CycFort arg2Isa = null;
        CycFort arg1Genls = null;
        CycFort arg2Genls = null;
        if (arg1IsaName != null)
            arg1Isa = getKnownConstantByName(arg1IsaName);
        if (arg2IsaName != null)
            arg1Isa = getKnownConstantByName(arg2IsaName);
        if (arg1GenlsName != null)
            arg1Genls = getKnownConstantByName(arg1GenlsName);
        if (arg2GenlsName != null)
            arg2Genls = getKnownConstantByName(arg2GenlsName);
        return createCollectionDenotingBinaryFunction(
            findOrCreate(binaryFunction),
            comment,
            getKnownConstantByName(commentMt),
            arg1Isa,
            arg2Isa,
            arg1Genls,
            arg2Genls,
            getKnownConstantByName(resultIsa));
        }

    /**
     * Creates a new collection-denoting reifiable binary function term.
     *
     * @@param binaryFunction the new collection
     * @@param comment the comment for the binary function
     * @@param commentMt the microtheory in which the comment is asserted
     * @@param isa the collection of which the new binary function is an instance
     * @@param arg1Isa the kind of objects this binary function takes as its first
     * argument, or null
     * @@param arg2Isa the kind of objects this binary function takes as its first
     * argument, or null
     * @@param arg1Genls the general collections this binary function takes as its first
     * argument, or null
     * @@param arg2Genls the general collections this binary function takes as its second
     * argument, or null
     * @@param resultIsa the kind of object represented by this reified term
     * @@return the new collection-denoting reifiable binary function term
     */
    public CycFort createCollectionDenotingBinaryFunction (CycFort binaryFunction,
                                                           String comment,
                                                           CycFort commentMt,
                                                           CycFort arg1Isa,
                                                           CycFort arg2Isa,
                                                           CycFort arg1Genls,
                                                           CycFort arg2Genls,
                                                           CycFort resultIsa)
        throws IOException, CycApiException {
        assertComment(binaryFunction, comment, commentMt);
        // (#$isa binaryFunction #$BinaryFunction)
        assertIsa(binaryFunction,
                  getKnownConstantByGuid("c0e7247c-9c29-11b1-9dad-c379636f7270"));
        // (#$isa binaryFunction #$ReifiableFunction)
        assertIsa(binaryFunction,
                  getKnownConstantByGuid("bd588002-9c29-11b1-9dad-c379636f7270"));
        // (#$isa binaryFunction #$CollectionDenotingFunction)
        assertIsa(binaryFunction,
                  getKnownConstantByGuid("bd58806a-9c29-11b1-9dad-c379636f7270"));
        // (#$isa binaryFunction #$Function-Denotational)
        assertIsa(binaryFunction,
                  getKnownConstantByGuid("bd5c40b0-9c29-11b1-9dad-c379636f7270"));
        if (arg1Isa != null)
            assertArgIsa(binaryFunction, 1, arg1Isa);
        if (arg2Isa != null)
            assertArgIsa(binaryFunction, 2, arg2Isa);
        if (arg1Genls != null)
            assertArg1Genl(binaryFunction, arg1Genls);
        if (arg2Genls != null)
            assertArg2Genl(binaryFunction, arg2Genls);
        assertResultIsa(binaryFunction, resultIsa);
        return binaryFunction;
        }

    /**
     * Assert an argument isa contraint for the given relation and argument position.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argPosition the given argument position
     * @@param argNIsa the argument constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArgIsa (CycFort relation,
                              int argPosition,
                              CycFort argNIsa)
        throws IOException, UnknownHostException, CycApiException {
        // (#$argIsa relation argPosition argNIsa)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("bee22d3d-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(new Integer(argPosition));
        sentence.add(argNIsa);
        assertGaf(sentence, universalVocabularyMt);
    }

    /**
     * Assert an argument one genls contraint for the given relation.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argGenl the argument constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArg1Genl (CycFort relation,
                                CycFort argGenl)
        throws IOException, UnknownHostException, CycApiException {
        // (#$arg1Genl relation argGenl)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("bd588b1d-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(argGenl);
        assertGaf(sentence, universalVocabularyMt);
    }

    /**
     * Assert an argument two genls contraint for the given relation.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argGenl the argument constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArg2Genl (CycFort relation,
                                CycFort argGenl)
        throws IOException, UnknownHostException, CycApiException {
        // (#$arg2Genl relation argGenl)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("bd58dcda-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(argGenl);
        assertGaf(sentence, universalVocabularyMt);
    }

    /**
     * Assert an argument three genls contraint for the given relation.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argGenl the argument constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArg3Genl (CycFort relation,
                                CycFort argGenl)
        throws IOException, UnknownHostException, CycApiException {
        // (#$arg3Genl relation argGenl)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("bd58b8c3-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(argGenl);
        assertGaf(sentence, universalVocabularyMt);
    }

    /**
     * Assert the isa result contraint for the given denotational function.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param denotationalFunction the given denotational function
     * @@param resultIsa the function's isa result constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertResultIsa (CycFort denotationalFunction,
                                 CycFort resultIsa)
        throws IOException, UnknownHostException, CycApiException {
        // (#$resultIsa denotationalFunction resultIsa)
        assertGaf(universalVocabularyMt,
                  getKnownConstantByGuid("bd5880f1-9c29-11b1-9dad-c379636f7270"),
                  denotationalFunction,
                  resultIsa);
    }

    /**
     * Assert the genls result contraint for the given denotational function.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param denotationalFunction the given denotational function
     * @@param resultGenl the function's genls result constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertResultGenl (CycFort denotationalFunction,
                                  CycFort resultGenl)
        throws IOException, UnknownHostException, CycApiException {
        // (#$resultGenl denotationalFunction resultGenls)
        assertGaf(universalVocabularyMt,
                  getKnownConstantByGuid("bd58d6ab-9c29-11b1-9dad-c379636f7270"),
                  denotationalFunction,
                  resultGenl);
    }

    /**
     * Returns true if this KB is OpenCyc.
     *
     * @@return true if this KB is OpenCyc, otherwise false
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public boolean isOpenCyc ()
        throws IOException, UnknownHostException {
        boolean answer;
        try {
            answer = converseBoolean("(cyc-opencyc-feature)");
        }
        catch (CycApiException e) {
            answer = false;
        }
        return answer;
d10325 2
a10326 43

    /**
     * Returns a constant whose name differs from the given name only by case.
     * Used because Cyc by default requires constant names to be unique by case.
     *
     * @@param name the name used to lookup an existing constant
     * @@return a constant whose name differs from the given name only by case,
     * otherwise null if none exists
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycConstant constantNameCaseCollision (String name)
        throws IOException, UnknownHostException, CycApiException {
        Object object = converseObject("(constant-name-case-collision \"" + name + "\")");
        if (object instanceof CycConstant)
            return (CycConstant) object;
        else
            return null;
    }

    /**
     * Returns the list of applicable binary predicates which are elements of any
     * of the given list of KBSubsetCollections.
     *
     * @@param kbSubSetCollections the list of KBSubsetCollections
     * @@return the list of applicable binary predicates which are elements of any
     * of the given list of KBSubsetCollections
     */
    public CycList getApplicableBinaryPredicates (CycList kbSubsetCollections)
        throws IOException, UnknownHostException, CycApiException {
        CycList result = new CycList();
        for (int i = 0; i < kbSubsetCollections.size(); i++) {
            CycFort kbSubsetCollection = (CycFort) kbSubsetCollections.get(i);
            String query =
                "(#$and \n" +
                "  (#$isa ?binary-predicate " + kbSubsetCollection.cyclify() + ") \n" +
                "  (#$isa ?binary-predicate #$BinaryPredicate))";
            result.addAllNew(askWithVariable(makeCycList(query),
                                             CycObjectFactory.makeCycVariable("?binary-predicate"),
                                             inferencePSC));
        }
        return result;
d10328 2
a10329 24

    /**
     * Returns the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position.
     *
     * @@param cycFort the given term
     * @@param predicates the given list of predicates
     * @@param mt the relevant inference microtheory
     * @@return the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position
     */
    public CycList getGafs (CycFort cycFort,
                            CycList predicates,
                            ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList result = new CycList();
        for (int i = 0; i < predicates.size(); i++) {
            result.addAllNew(getGafs(cycFort,
                                     (CycFort) predicates.get(i),
                                     mt));
        }
        return result;
d10331 2
a10332 33


    /**
     * Returns the list of gafs in which the predicate is the
     * given predicate and in which the given term appears in the first
     * argument position.
     *
     * @@param cycFort the given term
     * @@param predicate the given predicate
     * @@param mt the relevant inference microtheory
     * @@return the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position
     */
    public CycList getGafs (CycFort cycFort,
                            CycFort predicate,
                            ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList gafs = new CycList();
        String command =
            "(with-mt " + mt.cyclify() + "\n" +
            "  (pred-values-in-relevant-mts " +
            cycFort.cyclify() + " " +
            predicate.cyclify() + "))";
        CycList values = converseList(command);
        for (int i = 0; i < values.size(); i++) {
            CycList gaf = new CycList();
            gaf.add(predicate);
            gaf.add(cycFort);
            gaf.add(values.get(i));
            gafs.add(gaf);
        }
        return gafs;
d10334 2
a10335 21

    /**
     * Returns the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position.
     *
     * @@param cycFort the given term
     * @@param predicates the given list of predicates
     * @@return the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position
     */
    public CycList getGafs (CycFort cycFort,
                            CycList predicates)
        throws IOException, UnknownHostException, CycApiException {
        CycList result = new CycList();
        for (int i = 0; i < predicates.size(); i++) {
            result.addAllNew(getGafs(cycFort,
                                     (CycFort) predicates.get(i)));
        }
        return result;
d10337 2
a10338 31


    /**
     * Returns the list of gafs in which the predicate is the
     * given predicate and in which the given term appears in the first
     * argument position.
     *
     * @@param cycFort the given term
     * @@param predicate the given predicate
     * @@return the list of gafs in which the predicate is a element of the
     * given list of predicates and in which the given term appears in the first
     * argument position
     */
    public CycList getGafs (CycFort cycFort,
                            CycFort predicate)
        throws IOException, UnknownHostException, CycApiException {
        CycList gafs = new CycList();
        String command =
            "(with-all-mts \n" +
            "  (pred-values-in-relevant-mts " +
            cycFort.cyclify() + " " +
            predicate.cyclify() + "))";
        CycList values = converseList(command);
        for (int i = 0; i < values.size(); i++) {
            CycList gaf = new CycList();
            gaf.add(predicate);
            gaf.add(cycFort);
            gaf.add(values.get(i));
            gafs.add(gaf);
        }
        return gafs;
d10340 2
a10341 439

    /**
     * Returns the list of tuples gathered from assertions in given microtheory
     * in which the predicate is the given predicate, in which the given term appears in
     * the indexArg position and in which the list of gatherArgs determines the
     * assertion arguments returned as each tuple.
     *
     * @@param term the term in the index argument position
     * @@param predicate the given predicate
     * @@param indexArg the argument position in which the given term appears
     * @@param gatherArgs the list of argument Integer positions which indicate the assertion
     * arguments to be returned as each tuple
     * @@param mt the relevant inference microtheory
     * @@return the list of tuples gathered from assertions in given microtheory
     * in which the predicate is the given predicate, in which the given term appears in
     * the indexArg position and in which the list of gatherArgs determines the
     * assertion arguments returned as each tuple
     */
    public CycList getPredicateValueTuplesInMt (CycFort term,
                                                CycFort predicate,
                                                int indexArg,
                                                CycList gatherArgs,
                                                ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList tuples = new CycList();
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("pred-value-tuples-in-mt"));
        command.add(term);
        command.add(predicate);
        command.add(new Integer(indexArg));
        command.addQuoted(gatherArgs);
        command.add(mt);
        return converseList(command);
    }

    /**
     * Assert an argument contraint for the given relation and argument position.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argPosition the given argument position
     * @@param argNIsa the argument constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArg1FormatSingleEntry (CycFort relation)
        throws IOException, UnknownHostException, CycApiException {
        // (#$arg1Format relation SingleEntry)
        assertArgFormat(relation,
                        1,
                        getKnownConstantByGuid("bd5880eb-9c29-11b1-9dad-c379636f7270"));
    }

    /**
     * Assert an argument format contraint for the given relation and argument position.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param relation the given relation
     * @@param argPosition the given argument position
     * @@param argNFormat the argument format constraint
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertArgFormat (CycFort relation,
                                 int argPosition,
                                 CycFort argNFormat)
        throws IOException, UnknownHostException, CycApiException {
        // (#$argFormat relation argPosition argNFormat)
        CycList sentence = new CycList();
        sentence.add(getKnownConstantByGuid("bd8a36e1-9c29-11b1-9dad-c379636f7270"));
        sentence.add(relation);
        sentence.add(new Integer(argPosition));
        sentence.add(argNFormat);
        assertGaf(sentence, baseKB);
    }

    /**
     * Asserts that the given DAML imported term is mapped to the
     * given Cyc term.
     *
     * @@param cycTerm the mapped Cyc term
     * @@param informationSource the external indexed information source
     * @@param externalConcept the external concept within the information source
     * @@param mt the assertion microtheory
     */
    public void assertSynonymousExternalConcept (String cycTerm,
                                                    String informationSource,
                                                    String externalConcept,
                                                    String mt)
        throws IOException, UnknownHostException, CycApiException {
        assertSynonymousExternalConcept (getKnownConstantByName(cycTerm),
                                         getKnownConstantByName(informationSource),
                                         externalConcept,
                                         getKnownConstantByName(mt));
    }

    /**
     * Asserts that the given DAML imported term is mapped to the
     * given Cyc term.
     *
     * @@param cycTerm the mapped Cyc term
     * @@param informationSource the external indexed information source
     * @@param externalConcept the external concept within the information source
     * @@param mt the assertion microtheory
     */
    public void assertSynonymousExternalConcept (CycFort cycTerm,
                                                 CycFort informationSource,
                                                 String externalConcept,
                                                 ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList gaf = new CycList();
        // #$synonymousExternalConcept
        gaf.add(getKnownConstantByGuid("c0e2af4e-9c29-11b1-9dad-c379636f7270"));
        gaf.add(cycTerm);
        gaf.add(informationSource);
        gaf.add(externalConcept);
        assertGaf(gaf, mt);
    }

    /**
     * Gets the list of mappings from the specified information source given the
     * inference microtheory.  Each returned list item is the pair consisting of
     * external concept string and synonymous Cyc term.
     *
     * @@param informationSource the external indexed information source
     * @@param mt the assertion microtheory
     */
    public CycList getSynonymousExternalConcepts (String informationSource,
                                                  String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getSynonymousExternalConcepts (getKnownConstantByName(informationSource),
                                              getKnownConstantByName(mt));
    }

    /**
     * Gets the list of mappings from the specified information source given the
     * inference microtheory.  Each returned list item is the pair consisting of
     * external concept string and synonymous Cyc term.
     *
     * @@param informationSource the external indexed information source
     * @@param mt the assertion microtheory
     */
    public CycList getSynonymousExternalConcepts (CycFort informationSource,
                                                  ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList variables = new CycList();
        CycVariable cycTermVar = CycObjectFactory.makeCycVariable("?cyc-term");
        variables.add(cycTermVar);
        CycVariable externalConceptVar = CycObjectFactory.makeCycVariable("?externalConcept");
        variables.add(externalConceptVar);
        CycList query = new CycList();
        // #$synonymousExternalConcept
        query.add(getKnownConstantByGuid("c0e2af4e-9c29-11b1-9dad-c379636f7270"));
        query.add(cycTermVar);
        query.add(informationSource);
        query.add(externalConceptVar);
        return askWithVariables(query, variables, mt);
    }

    /**
     * Asserts a preferred name string for the given term using lexical singular count noun
     * assumptions.
     *
     * @@param cycTerm the Cyc term
     * @@param phrase the preferred phrase for this term
     */
    public void assertGenPhraseCountNounSingular (CycFort cycTerm, String phrase)
        throws IOException, UnknownHostException, CycApiException {
        CycList gaf = new CycList();
        // (#$genPhrase <term> #$CountNoun #$singular <phrase>) in
        // #$EnglishParaphaseMt
        gaf.add(getKnownConstantByGuid("bd5fb28e-9c29-11b1-9dad-c379636f7270"));
        gaf.add(cycTerm);
        gaf.add(getKnownConstantByGuid("bd588078-9c29-11b1-9dad-c379636f7270"));
        gaf.add(getKnownConstantByGuid("bd6757b8-9c29-11b1-9dad-c379636f7270"));
        gaf.add(phrase);
        ELMT mt = getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270");
        assertGaf(gaf, mt);
    }

    /**
     * Asserts a preferred name string for the given term using lexical singular count noun
     * assumptions.
     *
     * @@param cycTerm the Cyc term
     * @@param phrase the preferred phrase for this term
     */
    public void assertGenPhraseCountNounPlural (CycFort cycTerm, String phrase)
        throws IOException, UnknownHostException, CycApiException {
        CycList gaf = new CycList();
        // (#$genPhrase <term> #$CountNoun #$plural <phrase>) in
        // #$EnglishParaphaseMt
        gaf.add(getKnownConstantByGuid("bd5fb28e-9c29-11b1-9dad-c379636f7270"));
        gaf.add(cycTerm);
        gaf.add(getKnownConstantByGuid("bd588078-9c29-11b1-9dad-c379636f7270"));
        gaf.add(getKnownConstantByGuid("bd5a6853-9c29-11b1-9dad-c379636f7270"));
        gaf.add(phrase);
        ELMT mt = getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270");
        assertGaf(gaf, mt);
    }

    /**
     * Gets the list of name strings for the given CycFort.
     *
     * @@param cycFort the given FORT
     * @@param mt the relevant inference microtheory
     * @@return the list of name strings for the given CycFort
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public CycList getNameStrings (CycFort cycFort, ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        // (#$nameString <cycFort> ?name-string)
        CycList query = new CycList();
        query.add(getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"));
        query.add(cycFort);
        CycVariable variable = CycObjectFactory.makeCycVariable("?name-string");
        query.add(variable);

        return askWithVariable (query,
                                variable,
                                mt);
    }

    /**
     * Ensures that the given term meets the given isa and genl wff constraints
     * in the UniversalVocabularyMt.
     *
     * @@param cycFort the given term
     * @@param isaConstraintName the given isa type constraint, or null
     * @@param genlsConstraintName the given genls type constraint, or null
     */
    public void ensureWffConstraints (String cycFort,
                                      String isaConstraintName,
                                      String genlsConstraintName)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant cycConstant = find(cycFort);
        CycConstant isaConstraint = null;
        CycConstant genlsConstraint = null;
        if (isaConstraintName != null)
            isaConstraint = find(isaConstraintName);
        if (genlsConstraintName != null)
            genlsConstraint = find(genlsConstraintName);
        ensureWffConstraints (cycConstant,
                              isaConstraint,
                              genlsConstraint);
    }

    /**
     * Ensures that the given term meets the given isa and genl wff constraints
     * in the UniversalVocabularyMt.
     *
     * @@param cycFort the given term
     * @@param isaConstraint the given isa type constraint, or null
     * @@param genlsConstraint the given genls type constraint, or null
     */
    public void ensureWffConstraints (CycFort cycFort,
                                      CycFort isaConstraint,
                                      CycFort genlsConstraint)
        throws IOException, UnknownHostException, CycApiException {
        if (isaConstraint != null &&
            (! isa(cycFort, isaConstraint, universalVocabularyMt)))
            assertIsa(cycFort, isaConstraint);
        if (genlsConstraint != null &&
            (! isSpecOf(cycFort, genlsConstraint, universalVocabularyMt)))
            assertGenls(cycFort, genlsConstraint);
    }

    /**
     * Returns the list of arg2 terms from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the list of arg2 terms from gafs having the specified
     * predicate and arg1 values
     */
    public CycList getArg2s (String predicate,
                             String arg1,
                             String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg2s(getKnownConstantByName(predicate),
                        getKnownConstantByName(arg1),
                        getKnownConstantByName(mt));
    }

    /**
     * Returns the list of arg2 terms from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the list of arg2 terms from gafs having the specified
     * predicate and arg1 values
     */
    public CycList getArg2s (String predicate,
                             CycFort arg1,
                             ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg2s(getKnownConstantByName(predicate),
                        arg1,
                        mt);
    }

    /**
     * Returns the list of arg2 terms from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the list of arg2 terms from gafs having the specified
     * predicate and arg1 values
     */
    public CycList getArg2s (CycFort predicate,
                             CycFort arg1,
                             ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList query = new CycList();
        query.add(predicate);
        query.add(arg1);
        CycVariable variable = CycObjectFactory.makeCycVariable("?arg2");
        query.add(variable);
        return askWithVariable(query, variable, mt);
    }

    /**
     * Returns the first arg2 term from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the first arg2 term from gafs having the specified
     * predicate and arg1 values or null if none
     */
    public Object getArg2 (String predicate,
                           String arg1,
                           String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg2(getKnownConstantByName(predicate),
                                  getKnownConstantByName(arg1),
                                  getKnownConstantByName(mt));
    }

    /**
     * Returns the first arg2 term from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the first arg2 term from gafs having the specified
     * predicate and arg1 values or null if none
     */
    public Object getArg2 (String predicate,
                           CycFort arg1,
                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg2(getKnownConstantByName(predicate), arg1, mt);
    }

    /**
     * Returns the first arg2 term from binary gafs having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the first arg2 term from gafs having the specified
     * predicate and arg1 values or null if none
     */
    public Object getArg2 (CycFort predicate,
                           CycFort arg1,
                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList query = new CycList();
        query.add(predicate);
        query.add(arg1);
        CycVariable variable = CycObjectFactory.makeCycVariable("?arg2");
        query.add(variable);
        CycList answer = askWithVariable(query, variable, mt);
        if (answer.size() > 0)
            return answer.get(0);
        else
            return null;
    }


    /**
     * Returns the first arg2 ground or non-term from assertions having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the first arg2 ground or non-term from assertions having the specified
     * predicate and arg1 values
     */
    public Object getAssertionArg2 (String predicate,
                                    String arg1,
                                    String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getAssertionArg2(getKnownConstantByName(predicate),
                                getKnownConstantByName(arg1),
                                getKnownConstantByName(mt));
    }


    /**
     * Returns the first arg2 ground or non-term from assertions having the specified
     * predicate and arg1 values.
     *
     * @@param predicate the given predicate
     * @@param arg1 the given arg1 term
     * @@param mt the inference microtheory
     * @@return the first arg2 ground or non-term from assertions having the specified
     * predicate and arg1 values
     */
    public Object getAssertionArg2 (CycFort predicate,
                                    CycFort arg1,
                                    ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList assertions = getAllAssertionsInMt(mt);
        Iterator iter = assertions.iterator();
        while (iter.hasNext()) {
            CycAssertion assertion = (CycAssertion) iter.next();
            CycList formula = assertion.getFormula();
            if ((formula.size() > 2) &&
                (formula.first().equals(predicate)) &&
                (formula.second().equals(arg1)))
                return formula.third();
        }
        return null;
d10343 2
a10344 129


    /**
     * Returns the first arg1 term from gafs having the specified
     * predicate and arg2 values.
     *
     * @@param predicate the given predicate
     * @@param arg2 the given arg2 term
     * @@param mt the inference microtheory
     * @@return the first arg1 term from gafs having the specified
     * predicate and arg2 values
     */
    public Object getArg1 (String predicate,
                           String arg2,
                           String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg1(getKnownConstantByName(predicate),
                       getKnownConstantByName(arg2),
                       getKnownConstantByName(mt));
    }


    /**
     * Returns the first arg1 term from gafs having the specified
     * predicate and arg2 values.
     *
     * @@param predicate the given predicate
     * @@param arg2 the given arg2 term
     * @@param mt the inference microtheory
     * @@return the first arg1 term from gafs having the specified
     * predicate and arg2 values
     */
    public Object getArg1 (CycFort predicate,
                           CycFort arg2,
                           ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList answer = getArg1s(predicate, arg2, mt);
        if (answer.size() > 0)
            return answer.get(0);
        else
            return null;
    }

    /**
     * Returns the list of arg1 terms from gafs having the specified
     * predicate and arg2 values.
     *
     * @@param predicate the given predicate
     * @@param arg2 the given arg2 term
     * @@param mt the inference microtheory
     * @@return the list of arg1 terms from gafs having the specified
     * predicate and arg2 values
     */
    public CycList getArg1s (String predicate,
                             String arg2,
                             String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg1s(getKnownConstantByName(predicate),
                        getKnownConstantByName(arg2),
                        getKnownConstantByName(mt));
    }

    /**
     * Returns the list of arg1 terms from gafs having the specified
     * predicate and arg2 values.
     *
     * @@param predicate the given predicate
     * @@param arg2 the given arg2 term
     * @@param mt the inference microtheory
     * @@return the list of arg1 terms from gafs having the specified
     * predicate and arg2 values
     */
    public CycList getArg1s (CycFort predicate,
                             CycFort arg2,
                             ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList query = new CycList();
        query.add(predicate);
        CycVariable variable = CycObjectFactory.makeCycVariable("?arg1");
        query.add(variable);
        query.add(arg2);
        return askWithVariable(query, variable, mt);
    }


    /**
     * Returns the Cyc image ID.
     *
     * @@return the Cyc image ID string
     */
    public String getCycImageID ()
        throws IOException, UnknownHostException, CycApiException {
        CycList query = new CycList();
        query.add(CycObjectFactory.makeCycSymbol("cyc-image-id"));
        return converseString(query);
    }

    /**
     * Returns the list of assertions contained in the given mt.
     *
     * @@param mt the given microtheory
     * @@return  the list of assertions contained in the given mt
     */
    public CycList getAllAssertionsInMt (ELMT mt)
        throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("gather-mt-index"));
        command.add(mt);
        return converseList(command);
    }

    /**
     * Unasserts all assertions from the given mt, with a transcript record of
     * the unassert operation.
     *
     * @@param mt the microtheory from which to delete all its assertions
     */
    public void unassertMtContentsWithTranscript (ELMT mt)
            throws IOException, UnknownHostException, CycApiException {
        CycList assertions = getAllAssertionsInMt(mt);
        Iterator iter = assertions.iterator();
        while (iter.hasNext()) {
            CycAssertion assertion = (CycAssertion) iter.next();
            String command = withBookkeepingInfo() +
                "(ke-unassert-now '" +
                assertion.stringApiValue() +
                mt.stringApiValue() + "))";
            converseVoid(command);
        }
d10346 2
a10347 19

    /**
     * Unasserts all assertions from the given mt, without a transcript record of
     * the unassert operation.
     *
     * @@param mt the microtheory from which to delete all its assertions
     */
    public void unassertMtContentsWithoutTranscript (ELMT mt)
            throws IOException, UnknownHostException, CycApiException {
        CycList assertions = getAllAssertionsInMt(mt);
        Iterator iter = assertions.iterator();
        while (iter.hasNext()) {
            CycAssertion assertion = (CycAssertion) iter.next();
            String command =
                "(cyc-unassert '" +
                assertion.stringApiValue() +
                mt.stringApiValue() + "))";
            converseVoid(command);
        }
d10349 2
a10350 32

    /**
     * Unasserts all assertions from the given mt having the given predicate and arg1,
     * without a transcript record of the unassert operation.
     *
     * @@param predicate the given predicate or null to match all predicates
     * @@param arg1 the given arg1
     * @@param mt the microtheory from which to delete the matched assertions
     */
    public void unassertMatchingAssertionsWithoutTranscript (CycFort predicate,
                                                             Object arg1,
                                                             ELMT mt)
            throws IOException, UnknownHostException, CycApiException {
        CycList assertions = getAllAssertionsInMt(mt);
        Iterator iter = assertions.iterator();
        while (iter.hasNext()) {
            CycAssertion assertion = (CycAssertion) iter.next();
            CycList sentence = assertion.getFormula();
            if (sentence.size() < 2)
                continue;
            if (! (arg1.equals(sentence.second())))
                continue;

            if ((predicate != null) &&
                (! (predicate.equals(sentence.first()))))
                continue;
            String command =
                "(cyc-unassert '" +
                assertion.stringApiValue() +
                mt.stringApiValue() + "))";
            converseVoid(command);
        }
d10352 2
a10353 15

    /**
     * Returns the list of Cyc terms whose denotation matches the given English
     * string.
     *
     * @@param denotationString the given English denotation string
     * @@return the list of Cyc terms whose denotation matches the given English
     * string
     */
    public CycList getDenotsOfString (String denotationString)
            throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("denots-of-string"));
        command.add(denotationString);
        return converseList(command);
d10356 206
a10561 44
    /**
     * Returns the list of Cyc terms whose denotation matches the given English
     * string and which are instances of any of the given collections.
     *
     * @@param denotationString the given English denotation string
     * @@param collections the given list of collections
     * @@return the list of Cyc terms whose denotation matches the given English
     * string
     */
    public CycList getDenotsOfString (String denotationString, CycList collections)
            throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("denots-of-string"));
        command.add(denotationString);
        CycList terms = converseList(command);
        CycList result = new CycList();
        Iterator collectionsIterator = collections.iterator();
        while (collectionsIterator.hasNext()) {
            CycFort collection = (CycFort) collectionsIterator.next();
            Iterator termsIter = terms.iterator();
            while (termsIter.hasNext()) {
                CycFort term = (CycFort) termsIter.next();
                if (this.isa(term, collection))
                    result.add(term);
            }
        }
        return result;
    }

    /**
     * Returns the list of Cyc terms whose denotation matches the given English
     * multi-word string.
     *
     * @@param denotationString the given English denotation multi-word string
     * @@return the list of Cyc terms whose denotation matches the given English
     * multi-word string
     */
    public CycList getMWSDenotsOfString (CycList multiWordDenotationString)
            throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("mws-denots-of-string"));
        command.addQuoted(multiWordDenotationString);
        return converseList(command);
    }
a10562 29
    /**
     * Returns the list of Cyc terms whose denotation matches the given English
     * multi-word string and which are instances of any of the given collections.
     *
     * @@param denotationString the given English denotation string
     * @@param collections the given list of collections
     * @@return the list of Cyc terms whose denotation matches the given English
     * multi-word string
     */
    public CycList getMWSDenotsOfString (CycList multiWordDenotationString, CycList collections)
            throws IOException, UnknownHostException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("mws-denots-of-string"));
        command.addQuoted(multiWordDenotationString);
        CycList terms = converseList(command);
        CycList result = new CycList();
        Iterator collectionsIterator = collections.iterator();
        while (collectionsIterator.hasNext()) {
            CycFort collection = (CycFort) collectionsIterator.next();
            Iterator termsIter = terms.iterator();
            while (termsIter.hasNext()) {
                CycFort term = (CycFort) termsIter.next();
                if (this.isa(term, collection))
                    result.add(term);
            }
        }
        return result;
    }

@


1.119
log
@Added XML SOAP web service support
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.26 2003/04/03 20:28:12 reed Exp $
d1415 1
a1415 1
                                     CycFort mt)
d1580 1
a1580 1
    public String getComment (CycFort cycFort, CycFort mt)
d1615 1
a1615 1
    public CycList getIsas (CycFort cycFort, CycFort mt)
d1645 1
a1645 1
    public CycList getGenls (CycFort cycFort, CycFort mt)
d1675 1
a1675 1
    public CycList getMinGenls (CycFort cycFort, CycFort mt)
d1705 1
a1705 1
    public CycList getSpecs (CycFort cycFort, CycFort mt)
d1735 1
a1735 1
    public CycList getMaxSpecs (CycFort cycFort, CycFort mt)
d1765 1
a1765 1
    public CycList getGenlSiblings (CycFort cycFort, CycFort mt)
d1795 1
a1795 1
    public CycList getSiblings (CycFort cycFort, CycFort mt)
d1824 1
a1824 1
    public CycList getSpecSiblings (CycFort cycFort, CycFort mt)
d1855 1
a1855 1
    public CycList getAllGenls (CycFort cycFort, CycFort mt)
d1884 1
a1884 1
    public CycList getAllSpecs (CycFort cycFort, CycFort mt)
d1914 1
a1914 1
    public HashSet getAllSpecsHashSet (CycFort cycFort, CycFort mt)
d1949 1
a1949 1
    public CycList getAllGenlsWrt (CycFort spec, CycFort genl, CycFort mt)
d1985 1
a1985 1
    public CycList getAllDependentSpecs (CycFort cycFort, CycFort mt)
d2019 1
a2019 1
    public CycList getSampleLeafSpecs (CycFort cycFort, int numberOfSamples, CycFort mt)
d2066 1
a2066 1
    public boolean isSpecOf (CycFort spec, CycFort genl, CycFort mt)
d2124 1
a2124 1
    public boolean isGenlOf (CycFort genl, CycFort spec, CycFort mt)
d2142 1
a2142 1
    public boolean isGenlPredOf (CycFort genlPred, CycFort specPred, CycFort mt)
d2177 1
a2177 1
    public boolean isGenlInverseOf (CycFort genlPred, CycFort specPred, CycFort mt)
d2249 1
a2249 1
    public boolean areTacitCoextensional (CycFort collection1, CycFort collection2, CycFort mt)
d2292 1
a2292 1
                                             CycFort mt)
d2332 1
a2332 1
    public boolean areIntersecting (CycFort collection1, CycFort collection2, CycFort mt)
d2368 1
a2368 1
    public boolean areHierarchical (CycFort collection1, CycFort collection2, CycFort mt)
d2409 1
a2409 1
    public CycList getWhyGenl (CycFort spec, CycFort genl, CycFort mt)
d2462 1
a2462 1
    public ArrayList getWhyGenlParaphrase (CycFort spec, CycFort genl, CycFort mt)
d2513 1
a2513 1
                                               CycFort mt)
d2568 1
a2568 1
                                                           CycFort mt)
d2612 1
a2612 1
    public CycList getCollectionLeaves (CycFort cycFort, CycFort mt)
d2639 1
a2639 1
    public CycList getLocalDisjointWith (CycFort cycFort, CycFort mt)
d2671 1
a2671 1
    public boolean areDisjoint (CycFort collection1, CycFort collection2, CycFort mt)
d2702 1
a2702 1
    public CycList getMinIsas (CycFort cycFort, CycFort mt)
d2732 1
a2732 1
    public CycList getInstances (CycFort cycFort, CycFort mt)
d2763 1
a2763 1
    public CycList getInstanceSiblings (CycFort cycFort, CycFort mt)
d2793 1
a2793 1
    public CycList getAllIsa (CycFort cycFort, CycFort mt)
d2829 1
a2829 1
    public CycList getAllInstances (CycFort cycFort, CycFort mt)
d2848 1
a2848 1
    public HashSet getAllInstancesHashSet (CycFort cycFort, CycFort mt)
d2913 1
a2913 1
    public boolean isa (CycFort term, CycFort collection, CycFort mt)
d2955 1
a2955 1
    public CycList getWhyIsa (CycFort spec, CycFort genl, CycFort mt)
d3005 1
a3005 1
    public ArrayList getWhyIsaParaphrase (CycFort spec, CycFort genl, CycFort mt)
d3045 1
a3045 1
    public CycList getGenlPreds (CycConstant predicate, CycFort mt)
d3075 1
a3075 1
    public CycList getAllGenlPreds (CycConstant predicate, CycFort mt)
d3109 1
a3109 1
    public CycList getAllSpecPreds (CycFort cycFort, CycFort mt)
d3142 1
a3142 1
    public HashSet getAllSpecPredsHashSet (CycFort cycFort, CycFort mt)
d3175 1
a3175 1
    public CycList getAllSpecInverses (CycFort cycFort, CycFort mt)
d3208 1
a3208 1
    public CycList getAllSpecMts (CycFort mt)
d3224 1
a3224 1
    public HashSet getAllSpecInversesHashSet (CycFort cycFort, CycFort mt)
d3240 1
a3240 1
    public HashSet getAllSpecMtsHashSet (CycFort mt)
d3269 1
a3269 1
    public CycList getArg1Isas (CycConstant predicate, CycFort mt)
d3298 1
a3298 1
    public CycList getArg2Isas (CycConstant predicate, CycFort mt)
d3327 1
a3327 1
    public CycList getArg3Isas (CycConstant predicate, CycFort mt)
d3356 1
a3356 1
    public CycList getArg4Isas (CycConstant predicate, CycFort mt)
d3393 1
a3393 1
                                CycFort mt)
d3443 1
a3443 1
    public CycList getInterArgIsa1_2s (CycConstant predicate, CycFort mt)
d3493 1
a3493 1
                                              CycFort mt)
d3529 1
a3529 1
    public CycList getResultIsas (CycConstant function, CycFort mt)
d3564 1
a3564 1
    public CycList getArgNGenls (CycConstant predicate, int argPosition, CycFort mt)
d3595 1
a3595 1
    public CycList getArg1Formats (CycConstant predicate, CycFort mt)
d3625 1
a3625 1
    public CycList getArg2Formats (CycConstant predicate, CycFort mt)
d3655 1
a3655 1
    public CycList getDisjointWiths (CycFort cycFort, CycFort mt)
d3695 1
a3695 1
    public CycList getCoExtensionals (CycFort cycFort, CycFort mt)
d3908 1
a3908 1
    public boolean isQuotedCollection (CycFort cycFort, CycFort mt)
d4119 1
a4119 1
    public void assertWithTranscript (CycList sentence, CycFort mt)
d4134 1
a4134 1
    public void assertWithTranscript (String sentence, CycFort mt)
d4161 1
a4161 1
    public void assertWithTranscriptAndBookkeeping (CycList sentence, CycFort mt)
d4176 1
a4176 1
    public void assertWithTranscriptAndBookkeeping (String sentence, CycFort mt)
d4205 1
a4205 1
    public void assertWithBookkeepingAndWithoutTranscript (CycList sentence, CycFort mt)
d4220 1
a4220 1
    public void assertWithBookkeepingAndWithoutTranscript (String sentence, CycFort mt)
d4253 1
a4253 1
    public void unassertWithBookkeepingAndWithoutTranscript (CycList sentence, CycFort mt)
d4341 1
a4341 1
    public void assertGaf (CycFort mt,
d4366 1
a4366 1
    public void assertGaf (CycFort mt,
d4391 1
a4391 1
    public void assertGaf (CycFort mt,
d4416 1
a4416 1
    public void assertGaf (CycFort mt,
d4437 1
a4437 1
    public void assertGaf (CycFort mt,
d4462 1
a4462 1
    public void assertGaf (CycFort mt,
d4489 1
a4489 1
    public void assertGaf (CycFort mt,
d4516 1
a4516 1
                           CycFort mt)
d4531 1
a4531 1
                            CycFort mt)
d4595 1
a4595 1
                               CycFort mt)
d4613 1
a4613 1
                                  CycFort mt)
d4804 1
a4804 1
                                     CycFort mt)
d4882 1
a4882 1
                             CycFort mt)
d4944 1
a4944 1
                                           CycFort mt)
d5049 1
a5049 1
                           CycFort mt)
d5098 1
a5098 1
                                          CycFort mt)
d5248 1
a5248 1
                                    CycFort mt)
d5278 1
a5278 1
                                     CycFort mt)
d5304 1
a5304 1
                                CycFort mt)
d5328 1
a5328 1
                                          CycFort mt)
d5350 1
a5350 1
    public int countAllInstances(CycFort collection, CycFort mt) throws IOException, CycApiException {
d5367 1
a5367 1
                                        CycFort mt)
d5391 1
a5391 1
    public CycList getBackchainImplicationRules (CycConstant predicate, CycList formula, CycFort mt)
d5434 1
a5434 1
    public CycList getForwardChainRules (CycConstant predicate, CycList formula, CycFort mt)
d5475 1
a5475 1
    public CycList getBackchainRules (CycConstant predicate, CycFort mt)
d5517 1
a5517 1
    public CycList getForwardChainRules (CycConstant predicate, CycFort mt)
d5613 1
a5613 1
    public boolean isBackchainRequired(CycConstant predicate, CycFort mt)
d5632 1
a5632 1
    public boolean isBackchainEncouraged(CycConstant predicate, CycFort mt)
d5651 1
a5651 1
    public boolean isBackchainDiscouraged(CycConstant predicate, CycFort mt)
d5670 1
a5670 1
    public boolean isBackchainForbidden(CycConstant predicate, CycFort mt)
d5691 1
a5691 1
    public boolean isIrreflexivePredicate(CycConstant predicate, CycFort mt)
d5714 1
a5714 1
                                             CycFort mt) throws IOException, CycApiException {
d5747 1
a5747 1
    public int countUsingBestIndex(CycList formula, CycFort mt) throws IOException, CycApiException {
d5946 1
a5946 1
    public boolean isFormulaWellFormed (CycList formula, CycFort mt)
d6760 1
a6760 1
                            CycFort mt)
d6786 1
a6786 1
                            CycFort mt)
d6880 1
a6880 1
                                                CycFort mt)
d6968 1
a6968 1
                                                 CycFort mt)
d7003 1
a7003 1
                                                  CycFort mt)
d7036 1
a7036 1
        CycFort mt = getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270");
d7057 1
a7057 1
        CycFort mt = getKnownConstantByGuid("bda16220-9c29-11b1-9dad-c379636f7270");
d7071 1
a7071 1
    public CycList getNameStrings (CycFort cycFort, CycFort mt)
d7160 1
a7160 1
                             CycFort mt)
d7179 1
a7179 1
                             CycFort mt)
d7220 1
a7220 1
                           CycFort mt)
d7237 1
a7237 1
                           CycFort mt)
d7284 1
a7284 1
                                    CycFort mt)
d7332 1
a7332 1
                           CycFort mt)
d7372 1
a7372 1
                             CycFort mt)
d7401 1
a7401 1
    public CycList getAllAssertionsInMt (CycFort mt)
d7415 1
a7415 1
    public void unassertMtContentsWithTranscript (CycFort mt)
d7435 1
a7435 1
    public void unassertMtContentsWithoutTranscript (CycFort mt)
d7459 1
a7459 1
                                                             CycFort mt)
@


1.118
log
@Passing unit tests for State Machine Interpretation
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.117 2003/02/07 21:06:14 stephenreed Exp $
d272 15
d5159 39
a5197 1
     * Returns a new unique <tt>CycConstant</tt> object using the constant start name,
d5203 1
d5210 1
a5210 1
    public CycConstant makeUniqueCycConstant(String startName)
d5226 1
a5226 1
            "  (gentemp-constant \"" + constantName + "\")))";
d5264 3
a5266 1
     * Returns a list of bindings for a query with unbound variables.
d7130 1
a7130 1
     * Returns the list of arg2 terms from gafs having the specified
d7149 1
a7149 1
     * Returns the list of arg2 terms from gafs having the specified
d7168 1
a7168 1
     * Returns the list of arg2 terms from gafs having the specified
d7190 1
a7190 1
     * Returns the first arg2 term from gafs having the specified
d7209 1
a7209 1
     * Returns the first arg2 term from gafs having the specified
d7226 1
a7226 1
     * Returns the first arg2 term from gafs having the specified
d7482 89
@


1.117
log
@Fixed compilation errors in the latest refactoring.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.116 2003/01/29 00:18:03 stephenreed Exp $
d4148 1
a4148 1
        assertWithTranscript(sentence.cyclify(), mt);
@


1.116
log
@Mostly completed the code for UML state machine interpretation.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.115 2003/01/27 22:49:17 stephenreed Exp $
d7090 19
@


1.115
log
@Adding code to the state machine interpreter.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.114 2003/01/23 23:15:35 stephenreed Exp $
d4221 4
a4224 1
        converseVoid(command);
d4241 1
a4241 1
            "(ke-unassert-now '" +
d4244 4
a4247 1
        converseVoid(command);
d7378 1
a7378 1
     * @@param predicate the given predicate
d7393 5
a7397 2
            if ((! (predicate.equals(sentence.first()))) ||
                (! (arg1.equals(sentence.second()))))
a7405 11











@


1.114
log
@added code to the procedure interpreter
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.113 2003/01/13 23:57:58 stephenreed Exp $
d3966 20
d3988 1
a3988 1
     * (TML) will automatically delete any derived assertions whose sole support is the killed
d4005 1
a4005 1
     * (TML) will automatically delete any derived assertions whose sole support is the killed
d4022 1
a4022 1
     * (TML) will automatically delete any derived assertions whose sole support is the killed
d4224 20
d5138 38
d6798 34
d7360 30
@


1.113
log
@added more code to the state machine interpreter
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.112 2003/01/10 22:31:21 stephenreed Exp $
d7106 41
@


1.112
log
@Added more code to the state machine interpreter
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.111 2003/01/09 21:51:51 stephenreed Exp $
d5154 1
a5154 1
     * Returns <tt>true</tt> iff the ground query is true in the knowledge base.
d5167 1
a5167 1
        command.add(CycObjectFactory.makeCycSymbol("removal-ask"));
@


1.111
log
@Added code to state machine expression evaluator
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.110 2002/12/24 16:58:50 stephenreed Exp $
d7056 48
@


1.110
log
@Fixing bugs in the constraint solver.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.109 2002/12/06 00:12:16 stephenreed Exp $
d4117 1
a4117 1
     * Asserts the given sentence, and then places it on
d4132 1
a4132 1
     * Asserts the given sentence, and then places it on
d4161 44
d7113 13
d7127 19
d7147 19
a7165 1

@


1.109
log
@Added more code to the chat parser
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.108 2002/11/27 14:08:32 stephenreed Exp $
d7054 13
@


1.108
log
@ChatterBot unit tests
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.107 2002/11/26 00:15:18 stephenreed Exp $
d96 11
d248 2
a249 1
             CycAccess.DEFAULT_CONNECTION);
d284 2
a285 1
             CycAccess.DEFAULT_CONNECTION);
d289 2
a290 1
     * Constructs a new CycAccess object given a host name, port, communication mode and persistence indicator.
d306 27
d337 1
d800 1
a800 1
        if (universalVocabularyMt == null)
d877 6
a882 2
        String command = "(cand (boolean (find-constant \"" + constantName + "\"))\n" +
                         "      (valid-constant (find-constant \"" + constantName + "\")))";
@


1.107
log
@Begin unit test of ChatterBot state machine
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.106 2002/11/14 22:05:44 stephenreed Exp $
d5565 24
@


1.106
log
@Completed first set of unit tests for UML State Machine extraction from Cyc.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.105 2002/11/14 00:35:36 stephenreed Exp $
d1457 15
@


1.105
log
@Adding code to CycExtractor to extract the test state machine from Cyc
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.104 2002/10/29 23:29:56 stephenreed Exp $
d2798 16
d6884 17
@


1.104
log
@Added getter and setter methods.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.103 2002/10/21 18:31:36 stephenreed Exp $
d6820 7
a6826 7
    public CycList getArg2sForPredArg1 (String predicate,
                                        String arg1,
                                        String mt)
        throws IOException, UnknownHostException, CycApiException {
        return getArg2sForPredArg1(getKnownConstantByName(predicate),
                                   getKnownConstantByName(arg1),
                                   getKnownConstantByName(mt));
d6839 3
a6841 3
    public CycList getArg2sForPredArg1 (CycFort predicate,
                                        CycFort arg1,
                                        CycFort mt)
d6861 3
a6863 3
    public Object getArg2ForPredArg1 (String predicate,
                                      String arg1,
                                      String mt)
d6865 1
a6865 1
        return getArg2ForPredArg1(getKnownConstantByName(predicate),
d6880 3
a6882 3
    public Object getArg2ForPredArg1 (CycFort predicate,
                                      CycFort arg1,
                                      CycFort mt)
d6896 41
@


1.103
log
@Log file supressed when lacking permission to write local log file.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.102 2002/10/09 21:28:27 stephenreed Exp $
d4963 1
a4963 1
            "  (ke-create-now \"" + name + "\")))";
@


1.102
log
@Fix bug with NARTS and traceWithNames
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.101 2002/10/09 19:35:38 stephenreed Exp $
d6810 85
@


1.101
log
@Improving SONAT DAML import after refactoring.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.100 2002/10/09 15:17:21 stephenreed Exp $
d530 1
a530 1
                responseString = ((CycList) response[1]).cyclify();
@


1.100
log
@Added well formed formula constraint ensuring method
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.99 2002/10/09 04:01:48 stephenreed Exp $
d6771 24
d6806 2
a6807 2
            (! isSpecOf(cycFort, isaConstraint, universalVocabularyMt)))
            assertGenls(cycFort, isaConstraint);
@


1.99
log
@Improved SONAT import after refactoring.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.98 2002/10/09 01:36:14 stephenreed Exp $
d6093 3
a6095 2
     * @@param arg1Genl the genls type constraint for the argument if it is a collection
     * @@param resultIsa the kind of object represented by this reified term
d6103 2
a6104 1
                                                          String resultIsa)
d6111 5
d6122 2
a6123 1
            getKnownConstantByName(resultIsa));
d6134 2
a6135 1
     * @@param resultIsa the kind of object represented by this reified term
d6143 2
a6144 1
                                                          CycFort resultIsa)
d6163 2
d6358 1
a6358 1
     * Assert the result contraint for the given denotational function.
d6362 1
a6362 1
     * @@param resultIsa the function's result constraint
d6378 20
d6647 3
a6649 3
                                                    CycFort informationSource,
                                                    String externalConcept,
                                                    CycFort mt)
d6764 20
@


1.98
log
@Log improvements
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.19 2002/10/04 18:33:30 reed Exp $
d6092 2
a6093 1
     * @@param arg1Isa the kind of objects this unary function takes as its argument
d6101 1
d6104 5
d6114 1
d6124 2
a6125 2
     * @@param isa the collection of which the new unary function is an instance
     * @@param arg1Isa the kind of objects this unary function takes as its argument
d6133 1
d6150 2
d6374 9
a6382 2
        throws IOException, UnknownHostException, CycApiException {
        return converseBoolean("(cyc-opencyc-feature)");
@


1.97
log
@Added Log class to the api package classes.
@
text
@d55 2
a56 2
    //public boolean traceWithNames = false;
    public boolean traceWithNames = true;
d502 1
a502 1
                bypassConstantNameRequest = true;
@


1.96
log
@Experiments with UTF-8 character encoding scheme
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.95 2002/10/01 15:21:11 stephenreed Exp $
d52 13
d345 2
d413 16
d466 9
d488 21
d522 13
d2469 1
a2469 1
            //System.out.println("assertion: " + assertion);
d2505 1
a2505 1
            //System.out.println("assertion: " + assertion);
d3586 1
a3586 1
            System.out.println("getCoExtensionals - ignoring:\n" + e.getMessage());
d3613 1
a3613 1
            System.out.println("getCoExtensionals - ignoring:\n" + e.getMessage());
@


1.95
log
@Improved handling of lexical entries for imported DAML terms.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.94 2002/09/30 14:33:28 stephenreed Exp $
d6618 23
@


1.94
log
@Refactored DAML import classes to permit specialization for
the Open Directory DAML import.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.93 2002/09/26 16:06:36 stephenreed Exp $
d3950 6
d3957 2
a3958 2
            "(clet ((*the-cyclist* " + cyclist.cyclify() + ")\n" +
            "       (*ke-purpose* " + project.cyclify() + "))\n" +
d6574 42
@


1.93
log
@Added more SONAT DAML infrastructure ontology mappings.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.92 2002/09/25 15:10:09 stephenreed Exp $
d6023 1
a6023 1
            getKnownConstantByName(unaryFunction),
@


1.92
log
@Added more definitional information to the mapped DAML terms.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.91 2002/09/24 21:36:16 stephenreed Exp $
d6066 103
a6168 1
     * Assert an argument contraint for the given relation and argument position.
d6188 63
@


1.91
log
@Added synonymousExternalConcept mappings and xmlNameSpace assertions.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.90 2002/09/23 15:45:45 stephenreed Exp $
a4666 40
    }

    /**
     * Assert that symbol1 denotes the same concept as symbol2, asserted in the
     * UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param symbolName1 the name of the first symbol
     * @@param symbolName2 the name of the second symbol
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertEqualSymbols (String symbolName1,
                                    String symbolName2)
        throws IOException, UnknownHostException, CycApiException {
        assertEqualSymbols(getKnownConstantByName(symbolName1),
                           getKnownConstantByName(symbolName2));
    }

    /**
     * Assert that symbol1 denotes the same concept as symbol2, asserted in the
     * UniversalVocabularyMt
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param symbol1 the first symbol
     * @@param symbol2 the second symbol
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertEqualSymbols (CycConstant symbol1,
                                    CycConstant symbol2)
        throws IOException, UnknownHostException, CycApiException {
        CycConstant equalSymbols =
            getKnownConstantByGuid("c05e110e-9c29-11b1-9dad-c379636f7270");
        assertGaf(universalVocabularyMt,
                  equalSymbols,
                  symbol1,
                  symbol2);
@


1.90
log
@Fixed initialization of CycAccess.bookkeepingMt
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.89 2002/09/22 20:32:03 stephenreed Exp $
d5943 41
a5983 1
        }
d6360 83
@


1.89
log
@Added #$damlOntology assertions.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.88 2002/09/20 22:38:47 stephenreed Exp $
d686 2
@


1.88
log
@Improved mapping of xml schema primitive datatypes
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.87 2002/09/20 14:01:27 stephenreed Exp $
d4019 17
d4358 29
d5757 94
d6291 21
d6313 1
a6313 1
        sentence.add(getKnownConstantByGuid("bd61886b-9c29-11b1-9dad-c379636f7270"));
d6315 3
a6317 2
        sentence.add(getKnownConstantByGuid("bd5880eb-9c29-11b1-9dad-c379636f7270"));
        assertGaf(sentence, universalVocabularyMt);
@


1.87
log
@Added the assertion of forward arg constraints.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.86 2002/09/19 19:54:07 stephenreed Exp $
d4141 21
d4165 26
a4190 1
            Integer.toString(arg2) + ")";
d6135 21
@


1.86
log
@Improvements to bookkeeping and transcript handling when
creating constants.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.85 2002/09/19 00:09:47 stephenreed Exp $
d3197 1
d3205 5
a3209 2
        return converseList("(remove-duplicates (with-all-mts (argn-isa " + predicate.stringApiValue() +
                            " " + argPosition + ")))");
d3215 2
a3216 1
     * @@param predicate the predicate for which argument 1 contraints are sought.
d3223 29
a3251 1
    public CycList getArgNIsas (CycConstant predicate, CycFort mt)
d3253 82
a3334 1
        return converseList("(argn-isa " + predicate.stringApiValue() + " " + mt.stringApiValue() + ")");
@


1.85
log
@Changes to ImportSonatDaml for trial daml imports.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.84 2002/09/18 14:39:13 stephenreed Exp $
d3691 4
a3694 1
        converseBoolean("(cyc-kill " + cycConstant.stringApiValue() + ")");
d3745 8
a3752 1
        converseBoolean("(cyc-kill '" + cycFort.toString() + ")");
d3808 1
a3808 1
     * Asserts the given sentence and bookkeeping info, and then places it on
d3819 15
d3838 1
a3838 1
            "    '" + sentence.cyclify() + "\n" +
d3844 44
d3931 1
a3931 10
        CycConstant cycConstant = getConstantByName(constantName);
        if (cycConstant != null)
            return cycConstant;
        String name = constantName;
        if (name.startsWith("#$"))
            name = name.substring(2);
        String command = withBookkeepingInfo() +
            "(cyc-create-new-permanent \"" + name + "\"))";
        converseVoid(command);
        return getConstantByName(name);
d3952 5
a3956 7
        String command = withBookkeepingInfo() +
            "(cyc-assert '(" +
            gafApiValue(predicate) + " " +
            gafApiValue(arg1) + " " +
            gafApiValue(arg2) + ")" +
            gafApiValue(mt) + "))";
        converseVoid(command);
d3977 5
a3981 7
        String command = withBookkeepingInfo() +
            "(cyc-assert '(" +
            gafApiValue(predicate) + " " +
            gafApiValue(arg1) + " " +
            "\"" + arg2 + "\")" +
            gafApiValue(mt) + "))";
        converseVoid(command);
d4002 5
a4006 7
        String command = withBookkeepingInfo() +
            "(cyc-assert '(" +
            gafApiValue(predicate) + " " +
            gafApiValue(arg1) + " " +
            arg2.cyclify() + ")" +
            gafApiValue(mt) + "))";
        converseVoid(command);
d4027 5
a4031 7
        String command = withBookkeepingInfo() +
            "(cyc-assert '(" +
            gafApiValue(predicate) + " " +
            gafApiValue(arg1) + " " +
            arg2 + ")" +
            gafApiValue(mt) + "))";
        converseVoid(command);
a4033 10



    // TODO assertGaf does *not* write to the transcript.
    // figure out a way to encapsulate the choices whether to use
    // bookkeeping and the transcript.  Maybe just CycAccess booleans.




d4035 3
a4037 2
     * Asserts a ground atomic formula (gaf) in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
d4055 6
a4060 25
        String command = withBookkeepingInfo() +
            "(cyc-assert '(" +
            gafApiValue(predicate) + " " +
            gafApiValue(arg1) + " " +
            gafApiValue(arg2) + " " +
            gafApiValue(arg3) + ")" +
            gafApiValue(mt) + "))";
        converseVoid(command);
    }


    /**
     * Returns a string form of the given term that is used in gaf assertions.
     *
     * @@param cycFort the given term used in a gaf assertion
     * @@return the string form of the given term that is used in gaf assertions
     */
    protected String gafApiValue (CycFort cycFort) {
        return cycFort.cyclify();
        /*
        if (cycFort instanceof CycConstant)
            return cycFort.cyclify();
        else
            return cycFort.toString();
            */
d4077 1
a4077 5
        String command = withBookkeepingInfo() +
            "(cyc-assert '" +
            gaf.stringApiValue() +
            mt.stringApiValue() + "))";
        converseVoid(command);
d4093 1
a4093 1
            "(cyc-unassert '" +
d4685 2
a4686 1
     * Constructs a new <tt>CycConstant</tt> object using the constant name.
d4690 2
d4698 3
d4702 23
a4724 15
        if (cycConstant == null) {
            String command =
                withBookkeepingInfo() +
                "(clet ((*require-case-insensitive-name-uniqueness* nil)) \n" +
                "  (cyc-create \"" + name + "\" nil)))";
            Object object = converseObject(command);
            if (object instanceof CycConstant)
                cycConstant = (CycConstant) object;
            else
                throw new CycApiException("Cannot create new constant for " + name);
            cycConstant.getName();
            cycConstant.getGuid();
            CycObjectFactory.addCycConstantCacheByName(cycConstant);
            CycObjectFactory.addCycConstantCacheById(cycConstant);
        }
d5779 6
a5784 4
        assertGaf(universalVocabularyMt,
                  getKnownConstantByGuid("bee22d3d-9c29-11b1-9dad-c379636f7270"),
                  relation,
                  argNIsa);
@


1.84
log
@More fixes to SONAT DAML import.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.83 2002/09/18 01:18:55 stephenreed Exp $
d3798 2
a3799 2
     * Asserts the given sentence and also places it on the transcript queue
     * with default strength and direction.
d3810 2
a3811 1
            "(clet ((*the-cyclist* " + cyclist.cyclify() + "))\n" +
d3981 10
@


1.83
log
@DAML Export improvements
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.82 2002/09/17 16:11:27 stephenreed Exp $
d4019 2
d4025 1
d4487 1
a4487 1
        assertGaf(universalVocabularyMt,
@


1.82
log
@Refactor ExportDaml.java
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.81 2002/09/17 15:18:02 stephenreed Exp $
d479 9
a487 2
        else
            throw new CycApiException(response[1].toString());
d509 9
a517 2
        else
            throw new CycApiException(response[1].toString());
d539 9
a547 2
        else
            throw new CycApiException(response[1].toString());
d569 9
a577 2
        else
            throw new CycApiException(response[1].toString());
d596 9
a604 2
        else
            throw new CycApiException(response[1].toString());
d619 9
a627 2
        if (response[0].equals(Boolean.FALSE))
            throw new CycApiException(response[1].toString());
d1874 15
d5804 1
a5804 1
                "(and \n" +
d5813 132
@


1.81
log
@Improved handling of DAML imported terms whose name
differs only in case from existing terms.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.80 2002/09/16 22:21:25 stephenreed Exp $
d5731 24
@


1.80
log
@Modified api strings used in asserted gafs.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.79 2002/09/16 08:52:31 stephenreed Exp $
d3789 1
a3789 1
        return createNewPermanent(constantName);
d4606 8
a4613 2
            cycConstant = this.createNewPermanent(name);
            if (cycConstant == null)
d4615 2
d5710 21
a5730 1
        return converseBoolean("(cnot (find-constant \"SteveReed\"))");
@


1.79
log
@Further fixes to import DAML SONAT ontologies.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.78 2002/09/15 23:58:49 stephenreed Exp $
d3836 4
a3839 4
            predicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
            arg2.stringApiValue() + ")" +
            mt.stringApiValue() + "))";
d3842 1
d3863 2
a3864 2
            predicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
d3866 1
a3866 1
            mt.stringApiValue() + "))";
d3869 1
d3890 4
a3893 4
            predicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
            arg2.stringApiValue() + ")" +
            mt.stringApiValue() + "))";
d3896 1
d3917 2
a3918 2
            predicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
d3920 1
a3920 1
            mt.stringApiValue() + "))";
d3946 5
a3950 5
            predicate.stringApiValue() + " " +
            arg1.stringApiValue() + " " +
            arg2.stringApiValue() + " " +
            arg3.stringApiValue() + ")" +
            mt.stringApiValue() + "))";
d3954 15
d3999 1
a3999 1
                           CycFort mt)
@


1.78
log
@Fixes after unit testing SONAT DAML import
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.77 2002/09/13 22:55:45 stephenreed Exp $
d3829 1
a3829 1
                           CycConstant predicate,
d3855 1
a3855 1
                           CycConstant predicate,
d4201 14
d4353 63
d4533 17
a4549 1
     * Assert that the specified CycConstant is a #$BinaryPredicate in the specified defining microtheory MT.
d4552 2
a4553 1
     * @@param cycConstant the given term
d4558 1
a4558 1
    public void assertIsaBinaryPredicate (CycConstant cycConstant,
d4561 1
a4561 1
        assertIsa(cycConstant, binaryPredicate, mt);
@


1.77
log
@Began importing some DAML
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.76 2002/09/12 23:41:10 stephenreed Exp $
d247 16
a4010 21
    /**
     * Assert a nameString for the specified CycConstant in the specified lexical microtheory.
     * The operation will be added to the KB transcript for replication and archive.
     *
     * @@param cycFort the given term
     * @@param nameString the given name string for the term
     * @@param mt the microtheory in which the name string is asserted
     * @@throws UnknownHostException if cyc server host not found on the network
     * @@throws IOException if a data communication error occurs
     * @@throws CycApiException if the api request results in a cyc server error
     */
    public void assertNameString (CycFort cycFort,
                                  String nameString,
                                  CycFort mt)
        throws IOException, UnknownHostException, CycApiException {
        assertGaf(mt,
                  getKnownConstantByGuid("c0fdf7e8-9c29-11b1-9dad-c379636f7270"),
                  cycFort,
                  nameString);
    }

d4033 2
a4034 2
     * Assert a comment for the specified CycConstant in the specified microtheory MT.  The operation
     * will be added to the KB transcript for replication and archive.
d4036 1
a4036 1
     * @@param cycConstant the givent term
d4043 1
a4043 1
    public void assertComment (CycConstant cycConstant,
d4047 22
a4068 1
        assertGaf(mt, CycAccess.comment, cycConstant, comment);
d4295 44
d4373 1
a4373 1
                  genlMt,
d5228 1
d5235 1
a5235 1
        return this.createMicrotheory(mtName, comment, collectorMt, genlMts);
d5284 1
d5304 1
d5330 1
d5349 243
@


1.76
log
@Initializing Cyc terms.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.75 2002/09/12 15:03:19 stephenreed Exp $
d3762 15
d4092 36
d4276 59
@


1.75
log
@Refactored ImportDaml into two classes.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.74 2002/09/12 03:22:09 stephenreed Exp $
d626 2
d4173 37
d5167 6
@


1.74
log
@Added more helper functions to CycAccess in preparation
to mass entry of DAML import terms.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.73 2002/09/10 21:14:02 stephenreed Exp $
d3958 63
d4152 22
d4193 22
d5032 24
d5062 1
a5062 1
        for (int i = 0; i < forts.size(); i++)
d5064 20
d5091 2
a5092 2
     * @@param spindleHeadMt the name of the spindle head microtheory
     * @@param spindleCollectorMt the name of the spindle head microtheory
@


1.73
log
@Added nickname handling for namspaces.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.72 2002/09/08 02:43:02 stephenreed Exp $
d175 10
d3996 1
a3996 1
            this.kill(mt);
d3998 1
a3998 1
        mt = this.createNewPermanent(mtName);
d4000 1
a4000 1
        assertGaf(baseKB, isa, mt, isaMt);
d4006 1
a4006 1
            assertGaf(baseKB, genlMt, mt, aGenlMt);
d4072 1
a4072 1
     * @@param cycConstant the given collection term
d4078 1
a4078 1
    public void assertIsaCollection (CycConstant cycConstant,
d4081 1
a4081 1
        assertGaf(mt, isa, cycConstant, collection);
d4116 2
a4117 2
                             CycFort aCollection,
                             CycFort mt)
d4123 17
d4905 74
@


1.72
log
@Concurrent api calls
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.71 2002/08/30 22:52:12 stephenreed Exp $
d606 2
a607 1
            numericallyEqual = getKnownConstantByGuid("bd589d90-9c29-11b1-9dad-c379636f7270");
@


1.71
log
@Added concurrent processing for ascii communications mode.
Next will add it for binary mode.  Concurrent processing will be supported by
OpenCyc release 0.7.0.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.70 2002/08/29 21:59:19 stephenreed Exp $
d78 5
d248 4
a251 1
    public CycAccess(String hostName, int basePort, int communicationMode, boolean persistentConnection)
d284 3
d289 1
d423 5
a427 1
            cycConnection = new CycConnection(hostName, port, communicationMode, this);
@


1.70
log
@Added more api calls to CycAccess
Added naut and nart tests to CycList
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.69 2002/08/29 03:01:30 stephenreed Exp $
d251 33
@


1.69
log
@Added mt parameter to several api methods.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.68 2002/08/29 02:13:54 stephenreed Exp $
d43 1
a43 1
    static HashMap cycAccessInstances = new HashMap();
d49 1
a49 1
    static CycAccess sharedCycAccessInstance = null;
d78 2
a79 2
    private String hostName;
    private int port;
d81 1
a81 1
    private static final Integer OK_RESPONSE_CODE = new Integer(200);
d200 4
d219 2
d239 3
d256 3
d369 4
d394 3
d414 3
d436 3
d459 3
d482 3
d501 3
d515 4
d520 1
a520 1
    public void setReadableNarts (String guid)
d527 4
d587 6
d619 3
d633 3
d663 3
d678 3
d694 3
d718 3
d748 3
d769 3
d790 3
d805 3
d822 3
a824 1
     *
d845 3
d870 3
d897 3
d921 4
d955 3
d979 3
d993 3
d1019 6
d1069 6
d1097 1
a1097 1
     * Gets a CycNart object from a Cons object that lists the names of
d1099 4
d1116 3
d1151 3
d1181 6
d1195 6
d1209 6
d1223 6
d1237 6
d1251 6
d1265 6
d1282 3
d1304 3
d1324 3
d1339 3
d1354 3
d1369 3
d1381 6
d1399 3
d1414 3
d1429 3
d1444 3
d1459 3
d1474 3
d1489 3
d1504 3
d1519 3
d1533 3
d1548 3
d1562 3
d1579 3
d1593 3
d1608 3
d1623 3
d1638 3
d1655 3
d1673 3
d1691 3
d1709 3
d1726 3
d1743 3
d1759 3
d1775 3
d1790 3
d1806 3
d1833 3
d1851 3
d1869 3
d1886 3
d1904 3
d1922 3
d1940 3
d1958 3
d1976 3
d1999 3
d2023 3
d2041 3
d2048 2
a2049 1
                               collection2.stringApiValue() + ")");
d2054 8
d2065 2
a2066 1
        return converseBoolean("(with-all-mts (hierarchical-collections? " + collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
d2070 20
a2089 1
     * Gets a list of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
d2095 6
d2108 22
a2129 1
     * Gets an English parapharse of the justifications of why CycFort SPEC is a SPEC of CycFort GENL.
d2135 6
d2161 35
a2195 1
     * Gets a list of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect.
d2197 7
d2213 23
a2235 1
     * Gets an English parapharse of the justifications of why CycFort COLLECTION1 and a CycFort COLLECTION2 intersect.
d2237 8
d2266 43
a2308 1
     * Gets a list of the collection leaves (most specific of the all-specs) for a CycFort collection.
d2316 20
a2335 1
     * Gets a list of the collections asserted to be disjoint with a CycFort collection.
d2343 16
d2360 7
d2374 25
a2398 1
     * Gets a list of the most specific collections (having no subsets) which contain a CycFort term.
d2406 23
a2428 1
     * Gets a list of the instances (who are individuals) of a CycFort collection.
d2436 25
a2460 1
     * Gets a list of the instance siblings of a CycFort, for all collections of which it is an instance.
d2468 22
a2489 1
     * Gets a list of the collections of which the CycFort is directly and indirectly an instance.
d2497 16
d2520 3
d2535 1
d2537 3
d2557 3
d2574 3
d2589 3
d2606 3
d2621 1
a2621 1
     * Gets a list of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
d2626 6
d2639 21
a2659 1
     * Gets an English parapharse of the justifications of why CycFort TERM is an instance of CycFort COLLECTION.
d2664 7
d2688 38
a2725 1
     * Gets a list of the genlPreds for a CycConstant predicate.
d2733 17
a2749 1
     * Gets a list of all of the genlPreds for a CycConstant predicate, using an upward closure.
d2753 3
d2763 1
a2763 2
     * Gets the list of all of the direct and indirect specs-preds for the given predicate
     * in the given microtheory.
d2765 6
a2770 3
     * @@param cycFort the predicate
     * @@param mt the microtheory
     * @@return the list of all of the direct and indirect spec-preds for the given predicate
d2772 1
a2772 1
    public CycList getAllSpecPreds (CycFort cycFort, CycFort mt)
d2774 2
a2775 2
        return converseList("(all-spec-predicates " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
d2785 3
d2796 1
a2796 1
     * Gets the hashset of all of the direct and indirect specs-preds for the given predicate
d2801 4
a2804 1
     * @@return the hashset of all of the direct and indirect spec-preds for the given predicate
d2806 1
a2806 1
    public HashSet getAllSpecPredsHashSet (CycFort cycFort, CycFort mt)
d2808 2
a2809 1
        return new HashSet(getAllSpecPreds(cycFort, mt));
d2819 3
d2829 1
a2829 1
     * Gets the list of all of the direct and indirect specs-inverses for the given predicate
d2834 4
a2837 1
     * @@return the list of all of the direct and indirect spec-inverses for the given predicate
d2839 1
a2839 1
    public CycList getAllSpecInverses (CycFort cycFort, CycFort mt)
d2841 1
a2841 2
        return converseList("(all-spec-inverses " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + ")");
d2851 3
d2862 1
a2862 1
     * Gets the hashset of all of the direct and indirect specs-inverses for the given predicate
d2867 4
a2870 1
     * @@return the hashset of all of the direct and indirect spec-inverses for the given predicate
d2872 1
a2872 1
    public HashSet getAllSpecInversesHashSet (CycFort cycFort, CycFort mt)
d2874 2
a2875 1
        return new HashSet(getAllSpecInverses(cycFort, mt));
d2885 3
d2901 3
d2911 16
d2933 3
d2947 3
d2962 3
d2976 3
d2991 3
d3005 3
d3020 3
d3034 3
d3049 3
d3063 3
d3079 3
d3089 7
a3095 1
     * Gets a list of the resultIsa for a CycConstant function.
d3103 25
a3127 1
     * Gets a list of the argNGenls for a CycConstant predicate.
d3136 19
d3156 6
d3169 16
d3186 6
d3199 16
d3216 6
d3229 16
d3246 6
d3269 27
d3300 3
d3314 3
d3329 3
d3347 6
d3361 6
d3375 6
d3398 3
d3412 6
d3426 6
d3443 3
d3457 3
d3471 3
d3487 3
d3504 3
d3515 5
d3529 6
d3548 5
d3560 11
d3577 11
d3599 5
d3614 5
d3624 8
d3640 5
d3650 8
d3668 3
d3684 2
d3687 1
a3687 1
    private String withBookkeepingInfo () {
d3702 6
d3731 3
d3757 3
d3783 3
d3809 3
d3837 3
d3862 1
a3862 1
     * gaf the gaf in the form of a CycList
d3864 3
d3881 1
a3881 1
     * gaf the gaf in the form of a CycList
d3883 3
d3900 7
d3919 9
d3956 9
d4011 6
d4025 1
a4025 1
     * Assert that the CycConstant GENLS is a genls of CycFort SPEC,
d4028 7
d4044 1
a4044 1
     * Assert that the CycFort GENLS isa CycFort ACOLLECTION,
d4047 7
d4065 5
d4082 1
d4093 3
d4117 3
d4145 3
d4172 3
d4197 2
d4220 2
d4236 2
d4260 3
d4303 3
d4344 3
d4386 3
d4426 3
d4441 3
d4456 6
d4483 2
d4502 2
d4521 2
d4540 2
d4561 2
d4581 2
d4617 2
d4654 2
d4684 2
d4711 2
d4728 2
d4753 2
d4773 2
d4783 44
@


1.68
log
@Added microtheory param to API calls
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.67 2002/08/27 20:44:58 stephenreed Exp $
d992 6
d1022 34
d1676 5
d1694 22
d1717 5
d1725 17
a1741 1
        return converseBoolean("(with-all-mts (collections-intersect? " + collection1.stringApiValue() + " " + collection2.stringApiValue() + "))");
@


1.67
log
@Added requested API functions to CycAccess
Fixed bug in ExportDaml for EELD project.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.66 2002/07/23 20:17:19 stephenreed Exp $
d1072 4
a1075 1
     * Gets the comment for a CycConstant.  Embedded quotes are replaced by spaces.
d1077 1
a1077 1
    public String getComment (CycConstant cycConstant)
d1081 1
a1081 1
            "         (with-all-mts (comment " + cycConstant.stringApiValue() + ")))) \n" +
d1089 23
a1111 1
     * Gets a list of the isas for a CycFort.
d1119 17
a1135 1
     * Gets a list of the directly asserted true genls for a CycFort collection.
d1143 21
d1172 2
a1173 2
        return converseList("(remove-duplicates (min-genls " + cycFort.stringApiValue() +
                            " " + mt.stringApiValue() + "))");
d1177 4
a1180 1
     * Gets a list of the minimum (most specific) genls for a CycFort collection.
d1182 1
a1182 1
    public CycList getMinGenls (CycFort cycFort)
d1184 1
a1184 1
        return converseList("(remove-duplicates (with-all-mts (min-genls " + cycFort.stringApiValue() + ")))");
d1188 5
a1192 1
     * Gets a list of the directly asserted true specs for a CycFort collection.
d1194 1
a1194 1
    public CycList getSpecs (CycFort cycFort)
d1196 2
a1197 1
        return converseList("(remove-duplicates (with-all-mts (specs " + cycFort.stringApiValue() + ")))");
d1201 4
a1204 1
     * Gets a list of the least specific specs for a CycFort collection.
d1212 17
a1228 1
     * Gets a list of the direct genls of the direct specs for a CycFort collection.
d1236 17
a1252 1
     * Gets a list of the siblings (direct specs of the direct genls) for a CycFort collection.
d1260 16
a1275 1
     * Gets a list of the siblings (direct specs of the direct genls) for a CycFort collection.
d1283 13
a1295 1
     * Gets a list of all of the direct and indirect genls for a CycFort collection.
d1367 1
a1367 1
     * Gets a list of all of the direct and indirect genls for a CycFort SPEC which are also specs of
d1369 5
d1381 17
a1397 1
     * Gets a list of all of the dependent specs for a CycFort collection.  Dependent specs are those direct and
d1401 3
d1411 22
a1432 2
     * Gets a list with the specified number of sample specs of a CycFort collection.  Attempts to return
     * leaves that are maximally differet with regard to their all-genls.
d1440 15
d1456 4
d1467 13
d1604 7
a1610 1
     * Returns true if CycFort COLLECION1 and CycFort COLLECTION2 are tacitly coextensional via mutual genls of each other.
d1615 17
@


1.66
log
@Handled embedded quotes within strings sent to Cyc.  This patch makes the ascii
and cfasl (binary) api commands behave the same.  Added unit test cases.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.65 2002/07/17 21:27:04 stephenreed Exp $
d1164 3
d1174 14
d1840 3
d1850 12
d1863 3
d1873 12
d1886 3
d1896 12
d1909 3
d1919 12
d1932 3
d1940 12
@


1.65
log
@Adapted regression test to work with recent alpha version of OpenCyc.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.64 2002/05/30 22:15:16 stephenreed Exp $
d585 2
a586 1
        String command = "(boolean (find-constant \"" + constantName + "\"))";
d590 8
a597 1
            return new Integer(converseInt(command));
@


1.64
log
@Added unit test cases for SBHL api calls.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.63 2002/05/30 14:18:37 stephenreed Exp $
d1307 1
a1307 1
        return converseBoolean("(genl-pred? " + specPred.stringApiValue() +
d1322 1
a1322 1
        return converseBoolean("(with-all-mts (genl-pred? " + specPred.stringApiValue() +
d1689 1
a1689 1
        return converseList("(all-spec-preds " + cycFort.stringApiValue() +
d1703 1
a1703 1
        return converseList("(remove-duplicates (with-all-mts (all-spec-preds " +
@


1.63
log
@Added more SBHL function wrappers
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.62 2002/05/13 17:39:05 stephenreed Exp $
d1322 2
a1323 2
        return converseBoolean("(genl-pred-in-any-mt? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() + ")");
d1351 2
a1352 2
        return converseBoolean("(genl-inverse-in-any-mt? " + specPred.stringApiValue() +
                               " " + genlPred.stringApiValue() + ")");
@


1.62
log
@Enhanced HTML vocabulary export for the EELD project.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.61 2002/04/23 02:59:01 stephenreed Exp $
d1164 3
d1174 36
d1283 88
d1538 7
a1544 1
     * Gets a list of all the direct and indirect instances (individuals) for a CycFort collection.
d1552 44
d1670 1
d1677 134
@


1.61
log
@Fixed bug in CycList.rest() method where it did not return the
dotted element in a dotted pair list.  Wide impact because the
function signature changed from CycList to Object.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.60 2002/03/27 19:51:19 stephenreed Exp $
d1518 16
d1543 8
d1703 4
a1706 1
     * Returns true if the candidate name is a valid CycConstant name.
d1711 11
@


1.60
log
@Prepared ApiDemo class as first in a series for the programming tutorial.  Other modules
updated in preparation for public beta release.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.59 2002/02/28 06:02:22 stephenreed Exp $
d930 1
a930 1
            cycNart.setArguments(formula.rest());
d940 1
a940 1
            cycNart.setArguments(formula.rest());
@


1.59
log
@Refactored use of sub conversations
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.58 2002/02/25 21:08:11 stephenreed Exp $
d165 5
d522 2
d1056 8
a1072 1
            "       ;; else \n" +
d1095 13
d1578 11
d1590 3
d1730 1
a1730 1
        return getKbSubset(this.getKnownConstantByGuid("bd7abd90-9c29-11b1-9dad-c379636f7270"));
d1805 17
d1856 6
a1861 2
     * will be added to the KB transcript for replication and archive.  Alternative method
     * signatures accomodate various arities, and argument datatypes.
d1877 9
d1900 9
d1923 9
d1946 11
d1975 33
d2717 57
@


1.58
log
@Updating for OpenCyc.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.57 2002/02/21 22:18:29 stephenreed Exp $
d1001 8
d1014 8
@


1.57
log
@Added space between words in parseTermString(ArrayList words)
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.56 2002/02/20 22:44:57 stephenreed Exp $
d609 1
a609 1
        String command = "(guid-to-string (constant-guid (find-constant \"" +
d627 1
a627 1
        command1.add(CycObjectFactory.makeCycSymbol("constant-guid"));
@


1.56
log
@Adding RKF lexicon accessors to CycAccess. Added titles to the HTML export category pages.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.55 2002/02/04 21:15:30 stephenreed Exp $
d733 1
a733 1
        String command = "(boolean (find-constant-by-guid (string-to-guid \"" + guid + "\")))";
d737 1
a737 1
        command = "(constant-name (find-constant-by-guid (string-to-guid \"" + guid + "\")))";
d739 1
a739 1
        return this.getConstantByName(constantName);
@


1.55
log
@Fine tuning the HTML export
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.54 2002/02/04 17:02:57 stephenreed Exp $
d2519 49
a2567 1
        return this.converseInt(command);
@


1.54
log
@Fix api handling of CycNarts. Refined HTML export.
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.53 2002/02/03 18:07:21 stephenreed Exp $
d1630 27
d1658 3
@


1.53
log
@More JXTA interface code and fixing CycNart api bug
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.52 2002/01/08 20:03:43 stephenreed Exp $
d915 26
a940 8
        command.add(CycObjectFactory.makeCycSymbol("nart-el-formula"));
        CycList command1 = new CycList();
        command.add(command1);
        command1.add(CycObjectFactory.makeCycSymbol("find-nart-by-id"));
        command1.add(id);
        CycList formula = converseList(command);
        cycNart.setFunctor((CycFort) formula.first());
        cycNart.setArguments(formula.rest());
@


1.52
log
@Added quote to muc import sexpr argument
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.51 2002/01/08 18:38:48 stephenreed Exp $
d141 5
d507 2
d842 2
a843 1
     * if the constant is not cached.
d850 8
d872 26
@


1.51
log
@Added toString method for CycAccess
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.50 2002/01/08 15:02:30 stephenreed Exp $
d2423 4
a2426 1
        command.add(mucExpression.cycListApiValue());
@


1.50
log
@Added SRA/NetOwl import function
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.49 2001/12/04 05:35:39 stephenreed Exp $
d246 9
a2406 18
    }

    /**
     * Imports a MUC (Message Understanding Conference) formatted symbolic expression into
     * cyc via the function which parses the expression and creates assertions for the
     * contained concepts and relations between them, using a default new microtheory
     * created by Cyc's import function.
     *
     * @@param mucExpression the MUC (Message Understanding Conference) formatted symbolic
     * expression
     * @@return the number of assertions imported from the input MUC expression
     */
    public int importMucExpression(CycList mucExpression) throws IOException, CycApiException {
        CycList command = new CycList();
        command.add(CycObjectFactory.makeCycSymbol("convert-netowl-sexpr-to-cycl-assertions"));
        command.add(mucExpression.cycListApiValue());
        //this.traceOn();
        return this.converseInt(command);
@


1.49
log
@Output HTML cyc KB subset
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.48 2001/11/17 00:32:47 stephenreed Exp $
d2329 1
d2398 38
@


1.48
log
@CoAbs agent tests
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.47 2001/11/15 21:37:34 stephenreed Exp $
d1523 4
a1526 1
     * Returns true if cycConstant is a Predicate.
d1528 1
a1528 1
    public boolean isPredicate (CycConstant cycConstant)
d1530 4
a1533 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.stringApiValue() + " #$Predicate)");
@


1.47
log
@Unit testing CoABS
@
text
@d9 1
d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.46 2001/11/13 02:16:51 stephenreed Exp $
d80 1
a80 1
    private int communicationMode;
d282 2
a283 1
        cycConnection.traceOnDetailed();
d311 1
a311 1
                    this.converseVoid("(end-cyc-access)");
d325 9
a2391 1

@


1.46
log
@Continued testing
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.45 2001/11/12 03:56:48 stephenreed Exp $
d306 11
a316 1
        if (cycConnection != null)
d318 1
@


1.45
log
@Added methods to agent communication classes
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.44 2001/11/09 02:50:59 stephenreed Exp $
d208 2
@


1.44
log
@Initial check in
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.43 2001/11/05 22:34:36 stephenreed Exp $
d198 15
a222 1
        cycAccessInstances.put(Thread.currentThread(), this);
d229 10
@


1.43
log
@Added more CoABS test code
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.42 2001/10/31 00:00:52 stephenreed Exp $
d185 1
a185 1
    protected CycConnection cycConnection;
d196 1
d272 1
a272 1
    public CycConnection getCycConnection() {
d296 1
a296 1
            cycConnection.trace = saveTrace;
d300 1
a300 1
            saveTrace = cycConnection.trace;
@


1.42
log
@Added support for cyclops benchmark
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.41 2001/10/24 17:00:29 stephenreed Exp $
d290 1
a290 1
    private Object [] converse(Object command)
@


1.41
log
@Modifications to support jini agent interface to OpenCyc
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.40 2001/10/17 23:44:18 stephenreed Exp $
d63 1
a63 1
    public static final boolean DEFAULT_PERSISTENT_CONNECTION = PERSISTENT_CONNECTION;
d194 1
a194 1
             CycAccess.DEFAULT_PERSISTENT_CONNECTION);
d200 1
a200 1
     * @@param port the TCP socket port number
d205 1
a205 1
    public CycAccess(String hostName, int port, int communicationMode, boolean persistentConnection)
d209 1
a209 1
        this.port = port;
@


1.40
log
@Added CycApiException, and replaced throws to IOException with it.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.39 2001/10/15 22:34:00 stephenreed Exp $
d246 2
a247 2
        cycConnection.trace = CycConnection.API_TRACE_MESSAGES;
        saveTrace = cycConnection.trace;
d254 2
a255 2
        cycConnection.trace = CycConnection.API_TRACE_DETAILED;
        saveTrace = cycConnection.trace;
d262 2
a263 2
        cycConnection.trace = CycConnection.API_TRACE_NONE;
        saveTrace = cycConnection.trace;
@


1.39
log
@Added boundp to OpenCyc api.
Added upward closure option to DAML export.
Added addNew(Object) and addAllNew(Collection) methods to CycList class
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.38 2001/10/10 18:02:49 stephenreed Exp $
d190 1
a190 1
    public CycAccess() throws IOException, UnknownHostException {
d206 1
a206 1
        throws IOException, UnknownHostException {
d290 2
a291 1
    private Object [] converse(Object command)  throws IOException, UnknownHostException {
d311 2
a312 1
    public Object converseObject(Object command)  throws IOException, UnknownHostException {
d318 1
a318 1
            throw new IOException(response[1].toString());
d328 2
a329 1
    public CycList converseList(Object command)  throws IOException, UnknownHostException {
d338 1
a338 1
            throw new IOException(response[1].toString());
d347 2
a348 1
    public String converseString(Object command)  throws IOException, UnknownHostException {
d358 1
a358 1
            throw new IOException(response[1].toString());
d367 2
a368 1
    public boolean converseBoolean(Object command)  throws IOException, UnknownHostException {
d378 1
a378 1
            throw new IOException(response[1].toString());
d387 2
a388 1
    public int converseInt(Object command)  throws IOException, UnknownHostException {
d395 1
a395 1
            throw new IOException(response[1].toString());
d403 2
a404 1
    public void converseVoid(Object command)  throws IOException, UnknownHostException {
d408 1
a408 1
            throw new IOException(response[1].toString());
d414 2
a415 1
    public void setReadableNarts (String guid)  throws IOException, UnknownHostException {
d422 2
a423 1
    private void initializeConstants()    throws IOException, UnknownHostException {
d461 1
a461 1
        throws IOException, UnknownHostException {
d464 1
a464 1
            throw new RuntimeException("Expected constant not found " + constantName);
d475 1
a475 1
        throws IOException, UnknownHostException {
d500 2
a501 1
    public Integer getConstantId (CycConstant cycConstant)  throws IOException, UnknownHostException {
d511 2
a512 1
    public Integer getConstantId (String constantName)  throws IOException, UnknownHostException {
d531 1
a531 1
        throws IOException, UnknownHostException {
d543 1
a543 1
        throws IOException, UnknownHostException {
d556 1
a556 1
        throws IOException, UnknownHostException {
d576 2
a577 1
    public CycConstant getConstantById (Integer id)  throws IOException, UnknownHostException {
d604 1
a604 1
        throws IOException, UnknownHostException {
d622 1
a622 1
        throws IOException, UnknownHostException {
d640 1
a640 1
        throws IOException, UnknownHostException {
d652 1
a652 1
        throws IOException, UnknownHostException {
d655 1
a655 1
            throw new RuntimeException("Expected constant not found " + guid);
d666 2
a667 1
    public CycConstant getConstantByGuid (Guid guid)  throws IOException, UnknownHostException {
d686 2
a687 1
    public Object completeObject (Object object) throws IOException, UnknownHostException {
d708 2
a709 1
    public CycConstant completeCycConstant (CycConstant cycConstant) throws IOException, UnknownHostException {
d733 1
a733 1
        throws IOException, UnknownHostException {
d753 2
a754 1
    public CycList completeCycList (CycList cycList) throws IOException, UnknownHostException {
d782 2
a783 1
    public CycNart completeCycNart (CycNart cycNart) throws IOException, UnknownHostException {
d795 2
a796 1
    public CycAssertion completeCycAssertion (CycAssertion cycAssertion) throws IOException, UnknownHostException {
d803 2
a804 1
    public CycNart getCycNartById (Integer id)  throws IOException, UnknownHostException {
d829 2
a830 1
    public CycAssertion getAssertionById (Integer id)  throws IOException, UnknownHostException {
d862 2
a863 1
                                     CycFort arg2)  throws IOException, UnknownHostException {
d879 1
a879 1
            throw new IOException(response[1].toString());
d885 2
a886 1
    public String getPluralGeneratedPhrase (CycFort cycFort)  throws IOException, UnknownHostException {
d893 2
a894 1
    public String getSingularGeneratedPhrase (CycFort cycFort)  throws IOException, UnknownHostException {
d901 2
a902 1
    public String getGeneratedPhrase (CycFort cycFort)  throws IOException, UnknownHostException {
d909 2
a910 1
    public String getParaphrase (CycList assertion)  throws IOException, UnknownHostException {
d917 2
a918 1
    public String getComment (CycConstant cycConstant)  throws IOException, UnknownHostException {
d932 2
a933 1
    public CycList getIsas (CycFort cycFort)  throws IOException, UnknownHostException {
d940 2
a941 1
    public CycList getGenls (CycFort cycFort)  throws IOException, UnknownHostException {
d948 2
a949 1
    public CycList getMinGenls (CycFort cycFort)  throws IOException, UnknownHostException {
d956 2
a957 1
    public CycList getSpecs (CycFort cycFort)  throws IOException, UnknownHostException {
d964 2
a965 1
    public CycList getMaxSpecs (CycFort cycFort)  throws IOException, UnknownHostException {
d972 2
a973 1
    public CycList getGenlSiblings (CycFort cycFort)  throws IOException, UnknownHostException {
d980 2
a981 1
    public CycList getSiblings (CycFort cycFort)  throws IOException, UnknownHostException {
d988 2
a989 1
    public CycList getSpecSiblings (CycFort cycFort)  throws IOException, UnknownHostException {
d996 2
a997 1
    public CycList getAllGenls (CycFort cycFort)  throws IOException, UnknownHostException {
d1004 2
a1005 1
    public CycList getAllSpecs (CycFort cycFort)  throws IOException, UnknownHostException {
d1013 2
a1014 1
    public CycList getAllGenlsWrt (CycFort spec, CycFort genl )  throws IOException, UnknownHostException {
d1024 2
a1025 1
    public CycList getAllDependentSpecs (CycFort cycFort)  throws IOException, UnknownHostException {
d1033 2
a1034 1
    public CycList getSampleLeafSpecs (CycFort cycFort, int numberOfSamples)  throws IOException, UnknownHostException {
d1041 2
a1042 1
    public boolean isSpecOf (CycFort spec, CycFort genl)  throws IOException, UnknownHostException {
d1053 2
a1054 2
    public boolean isGenlOf (CycFort genl, CycFort spec)  throws IOException,
                                                                         UnknownHostException {
d1067 1
a1067 1
        throws IOException,  UnknownHostException {
d1085 2
a1086 1
    public boolean areTacitCoextensional (CycFort collection1, CycFort collection2)  throws IOException, UnknownHostException {
d1093 2
a1094 1
    public boolean areAssertedCoextensional (CycFort collection1, CycFort collection2)  throws IOException, UnknownHostException {
d1107 2
a1108 1
    public boolean areIntersecting (CycFort collection1, CycFort collection2)  throws IOException, UnknownHostException {
d1115 2
a1116 1
    public boolean areHierarchical (CycFort collection1, CycFort collection2)  throws IOException, UnknownHostException {
d1128 2
a1129 1
    public CycList getWhyGenl (CycFort spec, CycFort genl)  throws IOException, UnknownHostException {
d1142 1
a1142 1
        throws IOException, UnknownHostException {
d1164 2
a1165 1
                                                         CycFort collection2)  throws IOException, UnknownHostException {
d1176 1
a1176 1
        throws IOException, UnknownHostException {
d1196 2
a1197 1
    public CycList getCollectionLeaves (CycFort cycFort)  throws IOException, UnknownHostException {
d1204 2
a1205 1
    public CycList getLocalDisjointWith (CycFort cycFort)  throws IOException, UnknownHostException {
d1212 2
a1213 1
    public boolean areDisjoint (CycFort collection1, CycFort collection2)  throws IOException, UnknownHostException {
d1220 2
a1221 1
    public CycList getMinIsas (CycFort cycFort)  throws IOException, UnknownHostException {
d1228 2
a1229 1
    public CycList getInstances (CycFort cycFort)  throws IOException, UnknownHostException {
d1236 2
a1237 1
    public CycList getInstanceSiblings (CycFort cycFort)  throws IOException, UnknownHostException {
d1244 2
a1245 1
    public CycList getAllIsa (CycFort cycFort)  throws IOException, UnknownHostException {
d1252 2
a1253 1
    public CycList getAllInstances (CycFort cycFort)  throws IOException, UnknownHostException {
d1264 2
a1265 1
    public boolean isa (CycFort term, CycFort collection)  throws IOException, UnknownHostException {
d1279 1
a1279 1
        throws IOException, UnknownHostException {
d1295 2
a1296 1
    public CycList getWhyIsa (CycFort spec, CycFort genl)  throws IOException, UnknownHostException {
d1307 2
a1308 1
    public ArrayList getWhyIsaParaphrase (CycFort spec, CycFort genl)  throws IOException {
d1325 2
a1326 1
    public CycList getGenlPreds (CycConstant predicate)  throws IOException, UnknownHostException {
d1335 2
a1336 1
    public CycList getAllGenlPreds (CycConstant predicate)  throws IOException, UnknownHostException {
d1343 2
a1344 1
    public CycList getArg1Isas (CycConstant predicate)  throws IOException, UnknownHostException {
d1351 3
a1353 2
    public CycList getArg2Isas (CycConstant predicate)  throws IOException, UnknownHostException {
       return converseList("(remove-duplicates (with-all-mts (arg2-isa " + predicate.stringApiValue() + ")))");
d1359 2
a1360 1
    public CycList getArgNIsas (CycConstant predicate, int argPosition)  throws IOException, UnknownHostException {
d1368 2
a1369 1
    public CycList getArgNGenls (CycConstant predicate, int argPosition)  throws IOException, UnknownHostException {
d1377 2
a1378 1
    public CycList getArg1Formats (CycConstant predicate)  throws IOException, UnknownHostException {
d1385 2
a1386 1
    public CycList getArg2Formats (CycConstant predicate)  throws IOException, UnknownHostException {
d1393 2
a1394 1
    public CycList getDisjointWiths (CycFort cycFort)  throws IOException, UnknownHostException {
d1401 2
a1402 1
    public CycList getCoExtensionals (CycFort cycFort)  throws IOException, UnknownHostException {
d1419 2
a1420 1
    public boolean isCollection (CycFort cycFort)  throws IOException, UnknownHostException {
d1431 1
a1431 1
    public boolean isCollection_Cached(CycFort cycFort)  throws IOException {
d1446 2
a1447 1
    public boolean isIndividual (CycFort cycFort)  throws IOException, UnknownHostException {
d1454 2
a1455 1
    public boolean isFunction (CycConstant cycConstant)  throws IOException, UnknownHostException {
d1462 2
a1463 1
    public boolean isEvaluatablePredicate (CycConstant predicate)  throws IOException, UnknownHostException {
d1476 2
a1477 1
    public boolean isPredicate (CycConstant cycConstant)  throws IOException, UnknownHostException {
d1484 2
a1485 1
    public boolean isUnaryPredicate (CycConstant cycConstant)  throws IOException, UnknownHostException {
d1492 2
a1493 1
    public boolean isBinaryPredicate (CycConstant cycConstant)  throws IOException, UnknownHostException {
d1500 2
a1501 1
    public boolean isValidConstantName (String candidateName)  throws IOException, UnknownHostException {
d1508 2
a1509 1
    public boolean isPublicConstant (CycConstant cycConstant)  throws IOException, UnknownHostException {
d1516 2
a1517 1
    public CycList getPublicConstants ()  throws IOException, UnknownHostException {
d1525 2
a1526 1
    public CycList getKbSubset (CycFort cycKbSubsetCollection)  throws IOException, UnknownHostException {
d1538 2
a1539 1
    public synchronized void kill (CycConstant cycConstant)   throws IOException, UnknownHostException {
d1544 2
a1545 1
    public synchronized void kill (CycConstant[] cycConstants)   throws IOException, UnknownHostException {
d1550 2
a1551 1
    public synchronized void kill (ArrayList cycConstants)   throws IOException, UnknownHostException {
d1562 2
a1563 1
    public synchronized  void kill (CycFort cycFort)   throws IOException, UnknownHostException {
d1572 2
a1573 1
    public void setCyclist (String cyclistName)   throws IOException, UnknownHostException {
d1585 2
a1586 1
    public void setKePurpose (String projectName)   throws IOException, UnknownHostException {
d1612 2
a1613 1
    public CycConstant createNewPermanent (String constantName)   throws IOException, UnknownHostException {
d1634 2
a1635 1
                           CycFort arg2)   throws IOException, UnknownHostException {
d1648 2
a1649 1
                           String arg2)   throws IOException, UnknownHostException {
d1662 2
a1663 1
                           CycList arg2)   throws IOException, UnknownHostException {
d1676 2
a1677 1
                           int arg2)   throws IOException, UnknownHostException {
d1691 2
a1692 1
                           CycFort arg3)   throws IOException, UnknownHostException {
d1710 2
a1711 1
                               CycFort mt)   throws IOException, UnknownHostException {
d1723 2
a1724 1
                                          ArrayList genlMts)   throws IOException, UnknownHostException {
d1750 2
a1751 1
                                                  ArrayList genlMts) throws IOException, UnknownHostException {
d1795 2
a1796 1
                                     CycFort mt)   throws IOException, UnknownHostException {
d1807 2
a1808 1
                             CycFort mt)   throws IOException, UnknownHostException {
d1819 2
a1820 1
                             CycFort mt)   throws IOException, UnknownHostException {
d1829 2
a1830 1
                                          CycFort mt)   throws IOException, UnknownHostException {
d1840 1
a1840 1
    public CycList makeCycList(String string) {
d1851 1
a1851 1
        throws UnknownHostException, IOException {
d1856 1
a1856 1
                throw new RuntimeException("Cannot create new constant for " + name);
d1873 2
a1874 1
                                    CycFort mt)  throws IOException, UnknownHostException {
d1898 2
a1899 1
                                     CycFort mt)  throws IOException, UnknownHostException {
d1921 2
a1922 1
                                CycFort mt)  throws IOException, UnknownHostException {
d1943 2
a1944 1
                                          CycFort mt) throws IOException {
d1963 1
a1963 1
    public int countAllInstances(CycFort collection, CycFort mt) throws IOException {
d1978 2
a1979 1
                                        CycFort mt) throws IOException {
d2000 1
a2000 1
        throws IOException, UnknownHostException {
d2040 1
a2040 1
        throws IOException, UnknownHostException {
d2078 1
a2078 1
        throws IOException, UnknownHostException {
d2117 1
a2117 1
        throws IOException, UnknownHostException {
d2154 1
a2154 1
        throws IOException, UnknownHostException {
d2166 1
a2166 1
        throws IOException, UnknownHostException {
d2177 2
a2178 1
    public boolean isWellFormedFormula (CycList cycList)  throws IOException, UnknownHostException {
d2198 2
a2199 1
    public boolean isBackchainRequired(CycConstant predicate, CycFort mt) throws IOException {
d2215 2
a2216 1
    public boolean isBackchainEncouraged(CycConstant predicate, CycFort mt) throws IOException {
d2232 2
a2233 1
    public boolean isBackchainDiscouraged(CycConstant predicate, CycFort mt) throws IOException {
d2249 2
a2250 1
    public boolean isBackchainForbidden(CycConstant predicate, CycFort mt) throws IOException {
d2268 2
a2269 1
    public boolean isIrreflexivePredicate(CycConstant predicate, CycFort mt) throws IOException {
d2288 1
a2288 1
                                             CycFort mt) throws IOException {
d2319 1
a2319 1
    public int countUsingBestIndex(CycList formula, CycFort mt) throws IOException {
@


1.38
log
@Changed to reflect new version of constant-id function name.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.37 2001/10/07 12:36:34 stephenreed Exp $
d1270 9
@


1.37
log
@Added method for KB subset export, used it in ExportDaml.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.36 2001/10/06 23:06:22 stephenreed Exp $
d505 1
a505 1
            command = "(constant-id (find-constant \"" + constantName + "\"))";
d554 1
a554 1
        command2.add(CycObjectFactory.makeCycSymbol("find-constant-by-id"));
d571 1
a571 1
        command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-id"));
d598 1
a598 1
        command1.add(CycObjectFactory.makeCycSymbol("find-constant-by-id"));
@


1.36
log
@Fixed getComment to handle no comment for term
Added diagnostic displays to ExportDaml
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.35 2001/10/04 22:24:01 stephenreed Exp $
d1432 11
a1442 1
        return converseList("(ask-template '?X '(#$isa ?X #$PublicConstant) #$EverythingPSC)");
@


1.35
log
@Added more server side SubL scripting tests
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.34 2001/09/18 18:08:47 stephenreed Exp $
d893 8
a900 1
        return converseString("(string-substitute \" \" \"\\\"\" (with-all-mts (comment " + cycConstant.stringApiValue() + ")))");
d1327 9
a1335 1
        CycList answer = converseList("(ask-template '?X '(#$coExtensional " + cycFort.stringApiValue() + " ?X) #$EverythingPSC nil nil 120)");
@


1.34
log
@Added shared instance to class current() method.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.32 2001/09/14 22:14:55 stephenreed Exp $
d278 1
a278 1
    public void close() throws IOException {
@


1.33
log
@Added shared CycAccess instance to the class for convenience in multithreading situations
where the application controls sharing.
@
text
@a241 1

@


1.32
log
@Created new CycObjectFactory class to contain all cyc object caches
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.31 2001/09/14 19:58:53 stephenreed Exp $
d45 6
d83 7
d224 6
a229 2
        if (cycAccess == null)
            throw new RuntimeException("No CycAccess object for this thread");
d233 9
d248 1
d256 1
d264 1
d293 1
a293 1
        if (! persistentConnection)
d295 2
d298 2
a299 1
        if (! persistentConnection)
d301 1
d1873 1
a1873 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
d1884 1
a1884 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
d1913 1
a1913 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
d1924 1
a1924 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
d1951 4
a1954 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
d1962 4
a1965 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
d1990 4
a1993 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
d2001 4
a2004 1
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
@


1.31
log
@Replaced getConstantByName with getConstantByGuid
Replaced getKnownConstantByName with getKnownConstantByGuid
to reflect the stability of guids and the lesser stability of constant names.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.30 2001/09/10 18:47:09 stephenreed Exp $
d298 1
a298 1
            if (response[1].equals(CycSymbol.nil))
d438 1
a438 1
        CycConstant answer = CycConstant.getCacheByName(name);
d448 2
a449 2
        CycConstant.addCacheByName(answer);
        CycConstant.addCacheById(answer);
d503 1
a503 1
        return Guid.makeGuid(converseString(command));
d516 1
a516 1
        command.add(CycSymbol.makeCycSymbol("guid-to-string"));
d519 1
a519 1
        command1.add(CycSymbol.makeCycSymbol("constant-guid"));
d522 1
a522 1
        command2.add(CycSymbol.makeCycSymbol("find-constant-by-id"));
d524 1
a524 1
        return Guid.makeGuid(converseString(command));
d536 1
a536 1
        command.add(CycSymbol.makeCycSymbol("boolean"));
d539 1
a539 1
        command1.add(CycSymbol.makeCycSymbol("find-constant-by-id"));
d548 2
a549 2
        CycConstant.addCacheByName(answer);
        CycConstant.addCacheById(answer);
d563 1
a563 1
        command.add(CycSymbol.makeCycSymbol("constant-name"));
d566 1
a566 1
        command1.add(CycSymbol.makeCycSymbol("find-constant-by-id"));
d581 1
a581 1
        command.add(CycSymbol.makeCycSymbol("variable-name"));
d584 1
a584 1
        command1.add(CycSymbol.makeCycSymbol("find-variable-by-id"));
d597 1
a597 1
        Guid guid = Guid.makeGuid(guidString);
d664 1
a664 1
        CycConstant cachedConstant = CycConstant.getCacheByName(cycConstant.getName());
d667 1
a667 1
            CycConstant.addCacheByName(cycConstant);
d689 1
a689 1
        CycVariable cachedVariable = CycVariable.getCache(cycVariable.name);
d691 1
a691 1
            CycVariable.addCache(cycVariable);
d754 1
a754 1
        CycNart cycNart = CycNart.getCache(id);
d762 1
d764 1
a764 1
        command.add(CycSymbol.makeCycSymbol("nart-el-formula"));
d767 1
a767 1
        command1.add(CycSymbol.makeCycSymbol("find-nart-by-id"));
d779 1
a779 1
        CycAssertion cycAssertion = CycAssertion.getCache(id);
d786 1
d788 1
a788 1
        command.add(CycSymbol.makeCycSymbol("assertion-el-formula"));
d791 1
a791 1
        command1.add(CycSymbol.makeCycSymbol("find-assertion-by-id"));
d1187 1
a1187 1
        command.add(CycSymbol.makeCycSymbol("isa?"));
d1338 1
a1338 1
        command.add(CycSymbol.makeCycSymbol("with-all-mts"));
d1341 1
a1341 1
        command1.add(CycSymbol.makeCycSymbol("evaluatable-predicate?"));
d1396 1
a1396 1
        CycConstant.removeCaches(cycConstant);
d1694 2
a1695 2
            CycConstant.addCacheByName(cycConstant);
            CycConstant.addCacheById(cycConstant);
d1758 1
a1758 1
        command.add(CycSymbol.makeCycSymbol("removal-ask"));
d1761 1
a1761 1
        command1.add(CycSymbol.quote);
d1988 1
a1988 1
        command.add(CycSymbol.makeCycSymbol("csetq"));
d1999 1
a1999 1
        command.add(CycSymbol.makeCycSymbol("with-all-mts"));
d2002 1
a2002 1
        command1.add(CycSymbol.makeCycSymbol("el-wff?"));
d2005 1
a2005 1
        command2.add(CycSymbol.quote);
d2108 1
a2108 1
            command.add(CycSymbol.makeCycSymbol("some-pred-value-in-any-mt"));
d2113 1
a2113 1
            command.add(CycSymbol.makeCycSymbol("some-pred-value-in-relevant-mts"));
d2139 1
a2139 1
            command.add(CycSymbol.makeCycSymbol("with-all-mts"));
d2142 1
a2142 1
            command.add(CycSymbol.makeCycSymbol("with-mt"));
d2147 1
a2147 1
        command1.add(CycSymbol.makeCycSymbol("best-index-count"));
d2150 1
a2150 1
        command2.add(CycSymbol.quote);
d2152 2
a2153 2
        command1.add(CycSymbol.t);
        command1.add(CycSymbol.t);
@


1.30
log
@Cosmetic changes
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.29 2001/09/07 23:43:03 stephenreed Exp $
d384 1
a384 1
            baseKB = getKnownConstantByName("BaseKB");
d386 1
a386 1
            isa = getKnownConstantByName("isa");
d388 1
a388 1
            genls = getKnownConstantByName("genls");
d390 1
a390 1
            genlMt = getKnownConstantByName("genlMt");
d392 1
a392 1
            comment = getKnownConstantByName("comment");
d394 1
a394 1
            collection = getKnownConstantByName("Collection");
d396 1
a396 1
            binaryPredicate = getKnownConstantByName("BinaryPredicate");
d398 1
a398 1
            elementOf = getKnownConstantByName("elementOf");
d400 1
a400 1
            and = getKnownConstantByName("and");
d402 1
a402 1
            or = getKnownConstantByName("or");
d404 1
a404 1
            numericallyEqual = getKnownConstantByName("numericallyEqual");
d406 1
a406 1
            plusFn = getKnownConstantByName("PlusFn");
d408 1
a408 1
            different = getKnownConstantByName("different");
d410 1
a410 1
            thing = getKnownConstantByName("Thing");
d590 26
d617 4
d1012 2
a1013 1
        if (predicateRelates(getKnownConstantByName("coExtensional"), collection1, collection2))
d1015 1
a1015 1
        else if (predicateRelates(getKnownConstantByName("coExtensional"), collection2, collection1))
d1553 1
a1553 1
        assertGaf(mt, getKnownConstantByName("comment"), cycConstant, comment);
d1598 3
a1600 3
        CycConstant worldLikeOursMt = this.getKnownConstantByName("WorldLikeOursCollectorMt");
        CycConstant currentWorldDataMt = this.getKnownConstantByName("CurrentWorldDataCollectorMt");
        CycConstant genlMt_Vocabulary = this.getKnownConstantByName("genlMt-Vocabulary");
d1602 1
d1605 1
a1605 1
                                                 getKnownConstantByName("TheoryMicrotheory"),
d1607 2
d1611 1
a1611 1
                                                getKnownConstantByName("VocabularyMicrotheory"),
d1613 1
d1616 1
a1616 1
                                               getKnownConstantByName("DataMicrotheory"),
d1832 4
a1835 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
d1872 4
a1875 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
d1910 4
a1913 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
d1943 4
a1946 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
d2016 3
a2018 1
        return hasSomePredicateUsingTerm(getKnownConstantByName("backchainRequired"),
d2032 3
a2034 1
        return hasSomePredicateUsingTerm(getKnownConstantByName("backchainEncouraged"),
d2048 3
a2050 1
        return hasSomePredicateUsingTerm(getKnownConstantByName("backchainDiscouraged"),
d2064 3
a2066 3
        if (predicate.equals(getKnownConstantByName("objectFoundInLocation")))
            return false;
        return hasSomePredicateUsingTerm(getKnownConstantByName("backchainForbidden"),
d2082 3
a2084 1
        return this.isa(predicate, getKnownConstantByName("IrreflexiveBinaryPredicate"), mt);
d2102 4
a2105 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
d2133 4
a2136 2
        if (mt.equals(this.getKnownConstantByName("InferencePSC")) ||
            mt.equals(this.getKnownConstantByName("EverythingPSC"))) {
@


1.29
log
@Added defered completion of CycForts in the binary api. Continued with HashJoiner.
@
text
@d7 1
a8 3
import org.opencyc.constraintsolver.*;
import org.opencyc.inferencesupport.*;
import org.opencyc.util.*;
d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.28 2001/09/06 21:43:25 stephenreed Exp $
d1789 2
a1790 1
     * @@param literal the literal for which backchaining rules are sought
d1794 1
a1794 1
    public CycList getBackchainImplicationRules (Literal literal, CycFort mt)
d1801 1
a1801 1
            command.append("    (do-rule-index (rule " + literal.getPredicate().stringApiValue() + " :pos nil :backward) ");
d1804 1
a1804 1
            command.append("                    (unify-el-possible '" + literal.getFormula().stringApiValue() + " ");
d1812 1
a1812 1
            command.append("    (do-rule-index (rule " + literal.getPredicate().stringApiValue() + " :pos nil :backward) ");
d1815 1
a1815 1
            command.append("                    (unify-el-possible '" + literal.getFormula().stringApiValue() + " ");
d1827 2
a1828 1
     * @@param literal the literal for which forward chaining implication rules are sought
d1832 1
a1832 1
    public CycList getForwardChainRules (Literal literal, CycFort mt)
d1839 1
a1839 1
            command.append("    (do-rule-index (rule " + literal.getPredicate().stringApiValue() + " :pos nil :forward) ");
d1842 1
a1842 1
            command.append("                    (unify-el-possible '" + literal.getFormula().stringApiValue() + " ");
d1850 1
a1850 1
            command.append("    (do-rule-index (rule " + literal.getPredicate().stringApiValue() + " :pos nil :forward) ");
d1853 1
a1853 1
            command.append("                    (unify-el-possible '" + literal.getFormula().stringApiValue() + " ");
@


1.28
log
@Completed renaming of Rule to ConstraintRule class
@
text
@d17 1
a17 1
 * @@version $Id: CycAccess.java,v 1.27 2001/09/06 15:30:52 stephenreed Exp $
d62 6
d440 1
a440 1
        CycConstant answer = CycConstant.getCache(name);
d444 1
a444 1
        answer.name = name;
d448 4
a451 3
        answer.id = id;
        answer.guid = getConstantGuid(name);
        CycConstant.addCache(answer);
d462 1
a462 1
        return getConstantId(cycConstant.name);
d491 1
a491 1
        return getConstantGuid(cycConstant.name);
d547 5
a551 4
        answer.name = getConstantName(id);
        answer.id = id;
        answer.guid = getConstantGuid(id);
        CycConstant.addCache(answer);
d635 2
a636 2
        cycConstant.name = getConstantName(cycConstant.id);
        CycConstant cachedConstant = CycConstant.getCache(cycConstant.name);
d638 2
a639 2
            cycConstant.guid = getConstantGuid(cycConstant.id);
            CycConstant.addCache(cycConstant);
d707 1
a707 1
        return getCycNartById(cycNart.id);
d732 1
a732 1
            cycNart.id = id;
d1365 1
a1365 1
        CycConstant.removeCache(cycConstant);
d1659 2
a1660 1
            CycConstant.addCache(cycConstant);
@


1.27
log
@Added Literal abstract class parent to ConstraintRule and QueryLiteral classes.
@
text
@d17 1
a17 1
 * @@version $Id: CycAccess.java,v 1.26 2001/09/05 22:58:59 stephenreed Exp $
d1780 1
a1780 1
     * Gets a list of the backchaining rules which might apply to the given rule.
d1782 3
a1784 3
     * @@param rule the rule for which backchaining rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for backchaining rules takes place
     * @@return a list of the backchaining rules which might apply to the given predicate
d1786 1
a1786 1
    public CycList getBackchainRules (ConstraintRule rule, CycFort mt)
d1793 1
a1793 1
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :backward) ");
d1796 1
a1796 1
            command.append("                    (unify-el-possible '" + rule.getFormula().stringApiValue() + " ");
d1804 1
a1804 1
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :backward) ");
d1807 1
a1807 1
            command.append("                    (unify-el-possible '" + rule.getFormula().stringApiValue() + " ");
d1817 1
a1817 1
     * Gets a list of the forward chaining rules which might apply to the given rule.
d1819 1
a1819 1
     * @@param rule the rule for which backchaining rules are sought
d1821 1
a1821 1
     * @@return a list of the forward chaining rules which might apply to the given predicate
d1823 1
a1823 1
    public CycList getForwardChainRules (ConstraintRule rule, CycFort mt)
d1830 1
a1830 1
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :forward) ");
d1833 1
a1833 1
            command.append("                    (unify-el-possible '" + rule.getFormula().stringApiValue() + " ");
d1841 1
a1841 1
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :forward) ");
d1844 1
a1844 1
            command.append("                    (unify-el-possible '" + rule.getFormula().stringApiValue() + " ");
d1853 1
a1853 1
     * Gets a list of the backchaining rules which might apply to the given predicate.
d1857 1
a1857 1
     * @@return a list of the backchaining rules which might apply to the given predicate
d1884 1
a1884 1
     * Gets a list of the forward chaining rules which might apply to the given predicate.
d1888 1
a1888 1
     * @@return a list of the forward chaining rules which might apply to the given predicate
@


1.26
log
@Reworking population of high cardinality domains
@
text
@d9 1
d17 1
a17 1
 * @@version $Id: CycAccess.java,v 1.25 2001/09/03 22:30:50 stephenreed Exp $
d1786 1
a1786 1
    public CycList getBackchainRules (Rule rule, CycFort mt)
d1823 1
a1823 1
    public CycList getForwardChainRules (Rule rule, CycFort mt)
@


1.25
log
@Reworking ProblemParser to handle high cardinality domains better
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.24 2001/08/31 23:30:33 stephenreed Exp $
d1680 25
a1704 1
     * Returns <tt>true</tt> iff the query is true in the knowledge base.
@


1.24
log
@Continued backchain test cases
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.23 2001/08/31 15:45:42 stephenreed Exp $
a65 1
    private boolean trace = false;
d216 8
a223 1
        cycConnection.trace = true;
d230 1
a230 1
        cycConnection.trace = false;
d2033 34
@


1.23
log
@Renamed rule instance variable to formula, continued backchain test cases
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.22 2001/08/30 23:35:11 stephenreed Exp $
d1933 4
a1936 6
        CycList command = new CycList();
        command.add(CycSymbol.makeCycSymbol("some-pred-value-in-relevant-mts"));
        command.add(predicate);
        command.add(this.getKnownConstantByName("backchainRequired"));
        command.add(mt.cycListApiValue());
        return this.converseBoolean(command);
d1947 4
a1950 6
        CycList command = new CycList();
        command.add(CycSymbol.makeCycSymbol("some-pred-value-in-relevant-mts"));
        command.add(predicate);
        command.add(this.getKnownConstantByName("backchainEncouraged"));
        command.add(mt.cycListApiValue());
        return this.converseBoolean(command);
d1961 4
a1964 6
        CycList command = new CycList();
        command.add(CycSymbol.makeCycSymbol("some-pred-value-in-relevant-mts"));
        command.add(predicate);
        command.add(this.getKnownConstantByName("backchainDiscouraged"));
        command.add(mt.cycListApiValue());
        return this.converseBoolean(command);
d1975 6
a1980 6
        CycList command = new CycList();
        command.add(CycSymbol.makeCycSymbol("some-pred-value-in-relevant-mts"));
        command.add(predicate);
        command.add(this.getKnownConstantByName("backchainForbidden"));
        command.add(mt.cycListApiValue());
        return this.converseBoolean(command);
d1994 32
@


1.22
log
@Improved backchain rule filtering
@
text
@d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.21 2001/08/30 00:06:54 stephenreed Exp $
d1765 1
a1765 1
            command.append("                    (unify-el-possible '" + rule.getRule().stringApiValue() + " ");
d1776 1
a1776 1
            command.append("                    (unify-el-possible '" + rule.getRule().stringApiValue() + " ");
d1786 1
a1786 1
     * Gets a list of the backchaining rules which might apply to the given predicate.
d1788 3
a1790 3
     * @@param predicate the predicate for which backchaining rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for backchaining rules takes place
     * @@return a list of the backchaining rules which might apply to the given predicate
d1792 1
a1792 1
    public CycList getBackchainRules (CycConstant predicate, CycFort mt)
d1797 1
a1797 1
            command.append("(clet (backchain-rules) ");
d1799 6
a1804 3
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
d1808 1
a1808 1
            command.append("(clet (backchain-rules) ");
d1810 6
a1815 3
            command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
            command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
            command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
a1817 1
        this.traceOn();
d1822 1
a1822 1
     * Gets a list of the forward chaining rules which might apply to the given predicate.
d1824 3
a1826 3
     * @@param rule the rule for which backchaining rules are sought
     * @@param mt the microtheory (and its genlMts) in which the search for forward chaining rules takes place
     * @@return a list of the forward chaining rules which might apply to the given predicate
d1828 1
a1828 1
    public CycList getForwardChainRules (Rule rule, CycFort mt)
d1833 1
a1833 1
            command.append("(clet (backchain-rules formula) ");
d1835 3
a1837 6
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :forward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + rule.getRule().stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
d1841 1
a1841 1
            command.append("(clet (backchain-rules formula) ");
d1843 3
a1845 6
            command.append("    (do-rule-index (rule " + rule.getPredicate().stringApiValue() + " :pos nil :forward) ");
            command.append("       (csetq formula (assertion-el-formula rule)) ");
            command.append("       (pwhen (cand (eq (first formula) #$implies) ");
            command.append("                    (unify-el-possible '" + rule.getRule().stringApiValue() + " ");
            command.append("                                          (third formula))) ");
            command.append("         (cpush formula backchain-rules)))) ");
d1848 1
@


1.21
log
@Changed CycAccess parameters from CycConstants to CycForts, more backchaining tests
@
text
@d8 1
d16 1
a16 1
 * @@version $Id: CycAccess.java,v 1.20 2001/08/28 23:52:15 stephenreed Exp $
d1119 5
a1123 1
     * Returns true if CycFort TERM is a instance of CycFort COLLECTION.
d1130 19
d1288 13
d1749 37
d1795 54
a1848 7
        command.append("(clet (backchain-rules) ");
        command.append("  (with-mt " + mt.stringApiValue() + " ");
        command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :backward) ");
        command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
        command.append("         (cpush (assertion-el-formula rule) backchain-rules)))) ");
        command.append("   backchain-rules)");
        //this.traceOn();
d1862 17
a1878 6
        command.append("(clet (forward-chain-rules) ");
        command.append("  (with-mt " + mt.stringApiValue() + " ");
        command.append("    (do-rule-index (rule " + predicate.stringApiValue() + " :pos nil :forward) ");
        command.append("       (pwhen (eq (first (assertion-el-formula rule)) #$implies) ");
        command.append("         (cpush (assertion-el-formula rule) forward-chain-rules)))) ");
        command.append("   forward-chain-rules)");
d1988 14
@


1.20
log
@Added more backchain support - testing with one level of backchaining
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.19 2001/08/28 10:05:25 stephenreed Exp $
d372 1
a372 1
            baseKB = getConstantByName("BaseKB");
d374 1
a374 1
            isa = getConstantByName("isa");
d376 1
a376 1
            genls = getConstantByName("genls");
d378 1
a378 1
            genlMt = getConstantByName("genlMt");
d380 1
a380 1
            comment = getConstantByName("comment");
d382 1
a382 1
            collection = getConstantByName("Collection");
d384 1
a384 1
            binaryPredicate = getConstantByName("BinaryPredicate");
d386 1
a386 1
            elementOf = getConstantByName("elementOf");
d388 1
a388 1
            and = getConstantByName("and");
d390 1
a390 1
            or = getConstantByName("or");
d392 1
a392 1
            numericallyEqual = getConstantByName("numericallyEqual");
d394 1
a394 1
            plusFn = getConstantByName("PlusFn");
d396 1
a396 1
            different = getConstantByName("different");
d398 15
a412 1
            thing = getConstantByName("Thing");
d760 1
a760 1
     * Returns true if CycConstant BINARYPREDICATE relates CycConstant ARG1 and CycConstant ARG2.
d763 2
a764 2
                                     CycConstant arg1,
                                     CycConstant arg2)  throws IOException, UnknownHostException {
d767 3
a769 3
            binaryPredicate.cycName() + " " +
            arg1.cycName() + " " +
            arg2.cycName() + ")";
d784 1
a784 1
     * Gets the plural generated phrase for a CycConstant (intended for collections).
d786 2
a787 2
    public String getPluralGeneratedPhrase (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycConstant.cycName() + " '(#$plural)))");
d791 1
a791 1
     * Gets the singular generated phrase for a CycConstant (intended for individuals).
d793 2
a794 2
    public String getSingularGeneratedPhrase (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycConstant.cycName() + " '(#$singular)))");
d798 1
a798 1
     * Gets the default generated phrase for a CycConstant (intended for predicates).
d800 2
a801 2
    public String getGeneratedPhrase (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseString("(with-precise-paraphrase-on (generate-phrase " + cycConstant.cycName() + "))");
d815 1
a815 1
        return converseString("(string-substitute \" \" \"\\\"\" (with-all-mts (comment " + cycConstant.cycName() + ")))");
d819 1
a819 1
     * Gets a list of the isas for a CycConstant.
d821 2
a822 2
    public CycList getIsas (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (isa " + cycConstant.cycName() + ")))");
d826 1
a826 1
     * Gets a list of the directly asserted true genls for a CycConstant collection.
d828 2
a829 2
    public CycList getGenls (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (genls " + cycConstant.cycName() + ")))");
d833 1
a833 1
     * Gets a list of the minimum (most specific) genls for a CycConstant collection.
d835 2
a836 2
    public CycList getMinGenls (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (min-genls " + cycConstant.cycName() + ")))");
d840 1
a840 1
     * Gets a list of the directly asserted true specs for a CycConstant collection.
d842 2
a843 2
    public CycList getSpecs (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (specs " + cycConstant.cycName() + ")))");
d847 1
a847 1
     * Gets a list of the least specific specs for a CycConstant collection.
d849 2
a850 2
    public CycList getMaxSpecs (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (max-specs " + cycConstant.cycName() + ")))");
d854 1
a854 1
     * Gets a list of the direct genls of the direct specs for a CycConstant collection.
d856 2
a857 2
    public CycList getGenlSiblings (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (genl-siblings " + cycConstant.cycName() + ")))");
d861 1
a861 1
     * Gets a list of the siblings (direct specs of the direct genls) for a CycConstant collection.
d863 2
a864 2
    public CycList getSiblings (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return getSpecSiblings(cycConstant);
d868 1
a868 1
     * Gets a list of the siblings (direct specs of the direct genls) for a CycConstant collection.
d870 2
a871 2
    public CycList getSpecSiblings (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (spec-siblings " + cycConstant.cycName() + ")))");
d875 1
a875 1
     * Gets a list of all of the direct and indirect genls for a CycConstant collection.
d877 2
a878 2
    public CycList getAllGenls (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(all-genls-in-any-mt " + cycConstant.cycName() + ")");
d882 1
a882 1
     * Gets a list of all of the direct and indirect specs for a CycConstant collection.
d884 2
a885 2
    public CycList getAllSpecs (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (all-specs " + cycConstant.cycName() + ")))");
d889 2
a890 2
     * Gets a list of all of the direct and indirect genls for a CycConstant SPEC which are also specs of
     * CycConstant GENL.
d892 2
a893 2
    public CycList getAllGenlsWrt (CycConstant spec, CycConstant genl )  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (all-genls-wrt " + spec.cycName() + " " + genl.cycName() + ")))");
d897 1
a897 1
     * Gets a list of all of the dependent specs for a CycConstant collection.  Dependent specs are those direct and
d902 2
a903 2
    public CycList getAllDependentSpecs (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (all-dependent-specs " + cycConstant.cycName() + ")))");
d907 1
a907 1
     * Gets a list with the specified number of sample specs of a CycConstant collection.  Attempts to return
d910 2
a911 2
    public CycList getSampleLeafSpecs (CycConstant cycConstant, int numberOfSamples)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (sample-leaf-specs " + cycConstant.cycName() + " " + numberOfSamples + "))");
d915 1
a915 1
     * Returns true if CycConstant SPEC is a spec of CycConstant GENL.
d917 1
a917 1
    public boolean isSpecOf (CycConstant spec, CycConstant genl)  throws IOException, UnknownHostException {
d922 1
a922 1
     * Returns true if CycConstant GENL is a genl of CycConstant SPEC.
d926 1
a926 1
     * @@return <tt>true</tt> if CycConstant GENL is a genl of CycConstant SPEC
d928 1
a928 1
    public boolean isGenlOf (CycConstant genl, CycConstant spec)  throws IOException,
d930 1
a930 1
        return converseBoolean("(genl-in-any-mt? " + spec.cycName() + " " + genl.cycName() + ")");
d934 1
a934 1
     * Returns true if CycConstant GENL is a genl of CycConstant SPEC, implements a cache
d939 1
a939 1
     * @@return <tt>true</tt> if CycConstant GENL is a genl of CycConstant SPEC
d941 1
a941 1
    public boolean isGenlOf_Cached (CycConstant genl, CycConstant spec)
d958 1
a958 1
     * Returns true if CycConstant COLLECION1 and CycConstant COLLECTION2 are tacitly coextensional via mutual genls of each other.
d960 2
a961 2
    public boolean areTacitCoextensional (CycConstant collection1, CycConstant collection2)  throws IOException, UnknownHostException {
        return converseBoolean("(with-all-mts (tacit-coextensional? " + collection1.cycName() + " " + collection2.cycName() + "))");
d965 1
a965 1
     * Returns true if CycConstant COLLECION1 and CycConstant COLLECTION2 are asserted coextensional.
d967 2
a968 2
    public boolean areAssertedCoextensional (CycConstant collection1, CycConstant collection2)  throws IOException, UnknownHostException {
        if (predicateRelates(getConstantByName("coExtensional"), collection1, collection2))
d970 1
a970 1
        else if (predicateRelates(getConstantByName("coExtensional"), collection2, collection1))
d977 1
a977 1
     * Returns true if CycConstant COLLECION1 and CycConstant COLLECTION2 intersect with regard to all-specs.
d979 2
a980 2
    public boolean areIntersecting (CycConstant collection1, CycConstant collection2)  throws IOException, UnknownHostException {
        return converseBoolean("(with-all-mts (collections-intersect? " + collection1.cycName() + " " + collection2.cycName() + "))");
d984 1
a984 1
     * Returns true if CycConstant COLLECION1 and CycConstant COLLECTION2 are in a hierarchy.
d986 2
a987 2
    public boolean areHierarchical (CycConstant collection1, CycConstant collection2)  throws IOException, UnknownHostException {
        return converseBoolean("(with-all-mts (hierarchical-collections? " + collection1.cycName() + " " + collection2.cycName() + "))");
d991 1
a991 1
     * Gets a list of the justifications of why CycConstant SPEC is a SPEC of CycConstant GENL.
d998 2
a999 2
    public CycList getWhyGenl (CycConstant spec, CycConstant genl)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (why-genl? " + spec.cycName() + " " + genl.cycName() + "))");
d1003 1
a1003 1
     * Gets an English parapharse of the justifications of why CycConstant SPEC is a SPEC of CycConstant GENL.
d1010 1
a1010 1
    public ArrayList getWhyGenlParaphrase (CycConstant spec, CycConstant genl)
d1014 1
a1014 1
                         spec.cycName() + " " + genl.cycName() + "))");
d1029 1
a1029 1
     * Gets a list of the justifications of why CycConstant COLLECTION1 and a CycConstant COLLECTION2 intersect.
d1032 2
a1033 2
    public CycList getWhyCollectionsIntersect (CycConstant collection1,
                                                         CycConstant collection2)  throws IOException, UnknownHostException {
d1035 1
a1035 1
                            collection1.cycName() + " " + collection2.cycName() + "))");
d1039 1
a1039 1
     * Gets an English parapharse of the justifications of why CycConstant COLLECTION1 and a CycConstant COLLECTION2 intersect.
d1042 2
a1043 2
    public ArrayList getWhyCollectionsIntersectParaphrase (CycConstant collection1,
                                                           CycConstant collection2)
d1046 1
a1046 1
                                          collection1.cycName() + " " + collection2.cycName() + "))");
d1062 1
a1062 1
     * Gets a list of the collection leaves (most specific of the all-specs) for a CycConstant collection.
d1064 2
a1065 2
    public CycList getCollectionLeaves (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (collection-leaves " + cycConstant.cycName() + "))");
d1069 1
a1069 1
     * Gets a list of the collections asserted to be disjoint with a CycConstant collection.
d1071 2
a1072 2
    public CycList getLocalDisjointWith (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (local-disjoint-with " + cycConstant.cycName() + "))");
d1076 1
a1076 1
     * Returns true if CycConstant COLLECION1 and CycConstant COLLECTION2 are disjoint.
d1078 2
a1079 2
    public boolean areDisjoint (CycConstant collection1, CycConstant collection2)  throws IOException, UnknownHostException {
        return converseBoolean("(with-all-mts (disjoint-with? " + collection1.cycName() + " " + collection2.cycName() + "))");
d1083 1
a1083 1
     * Gets a list of the most specific collections (having no subsets) which contain a CycConstant term.
d1085 2
a1086 2
    public CycList getMinIsas (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (min-isa " + cycConstant.cycName() + "))");
d1090 1
a1090 1
     * Gets a list of the instances (who are individuals) of a CycConstant collection.
d1092 2
a1093 2
    public CycList getInstances (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (instances " + cycConstant.cycName() + "))");
d1097 1
a1097 1
     * Gets a list of the instance siblings of a CycConstant, for all collections of which it is an instance.
d1099 2
a1100 2
    public CycList getInstanceSiblings (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (instance-siblings " + cycConstant.cycName() + "))");
d1104 1
a1104 1
     * Gets a list of the collections of which the CycConstant is directly and indirectly an instance.
d1106 2
a1107 2
    public CycList getAllIsa (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(all-isa-in-any-mt " + cycConstant.cycName() + ")");
d1111 1
a1111 1
     * Gets a list of all the direct and indirect instances (individuals) for a CycConstant collection.
d1113 2
a1114 2
    public CycList getAllInstances (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(all-instances-in-all-mts " + cycConstant.cycName() + ")");
d1118 1
a1118 1
     * Returns true if CycConstant TERM is a instance of CycConstant COLLECTION.
d1120 2
a1121 2
    public boolean isa (CycConstant term, CycConstant collection)  throws IOException, UnknownHostException {
        return converseBoolean("(isa-in-any-mt? " + term.cycName() + " " + collection.cycName() + ")");
d1125 1
a1125 1
     * Gets a list of the justifications of why CycConstant TERM is an instance of CycConstant COLLECTION.
d1131 2
a1132 2
    public CycList getWhyIsa (CycConstant spec, CycConstant genl)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (why-isa? " + spec.cycName() + " " + genl.cycName() + "))");
d1136 1
a1136 1
     * Gets an English parapharse of the justifications of why CycConstant TERM is an instance of CycConstant COLLECTION.
d1142 2
a1143 2
    public ArrayList getWhyIsaParaphrase (CycConstant spec, CycConstant genl)  throws IOException {
        String command = "(with-all-mts (why-isa? " + spec.cycName() + " " + genl.cycName() + "))";
d1160 1
a1160 1
        return converseList("(remove-duplicates (with-all-mts (genl-predicates " + predicate.cycName() + ")))");
d1167 1
a1167 1
        return converseList("(remove-duplicates (with-all-mts (arg1-isa " + predicate.cycName() + ")))");
d1174 1
a1174 1
       return converseList("(remove-duplicates (with-all-mts (arg2-isa " + predicate.cycName() + ")))");
d1181 1
a1181 1
        return converseList("(remove-duplicates (with-all-mts (argn-isa " + predicate.cycName() +
d1189 1
a1189 1
        return converseList("(remove-duplicates (with-all-mts (argn-genl " + predicate.cycName() +
d1197 1
a1197 1
        return converseList("(with-all-mts (arg1-format " + predicate.cycName() + "))");
d1204 1
a1204 1
        return converseList("(with-all-mts (arg2-format " + predicate.cycName() + "))");
d1208 1
a1208 1
     * Gets a list of the disjointWiths for a CycConstant.
d1210 2
a1211 2
    public CycList getDisjointWiths (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (local-disjoint-with " + cycConstant.cycName() + ")))");
d1215 1
a1215 1
     * Gets a list of the coExtensionals for a CycConstant.  Limited to 120 seconds.
d1217 3
a1219 3
    public CycList getCoExtensionals (CycConstant cycConstant)  throws IOException, UnknownHostException {
        CycList answer = converseList("(ask-template '?X '(#$coExtensional " + cycConstant.cycName() + " ?X) #$EverythingPSC nil nil 120)");
        answer.remove(cycConstant);
d1226 2
a1227 2
    public boolean isCollection (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$Collection)");
d1237 1
a1237 1
    public boolean isCollection_Cached(CycConstant cycConstant)  throws IOException {
d1239 1
a1239 1
        Boolean isCollection = (Boolean) isCollectionCache.getElement(cycConstant);
d1244 2
a1245 2
        answer = isCollection(cycConstant);
        isCollectionCache.addElement(cycConstant, new Boolean(answer));
d1252 2
a1253 2
    public boolean isIndividual (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$Individual)");
d1260 1
a1260 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$Function-Denotational)");
d1267 1
a1267 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$Predicate)");
d1274 1
a1274 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$UnaryPredicate)");
d1281 1
a1281 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$BinaryPredicate)");
d1295 1
a1295 1
        return converseBoolean("(isa-in-any-mt? " + cycConstant.cycName() + " #$PublicConstant)");
d1312 1
a1312 1
        converseBoolean("(cyc-kill " + cycConstant.cycName() + ")");
d1366 1
a1366 1
            projectName = project.cycName();
d1369 1
a1369 1
            cyclistName = cyclist.cycName();
d1397 1
a1397 1
    public void assertGaf (CycConstant mt,
d1399 3
a1401 3
                           CycConstant arg1,
                           CycConstant arg2)   throws IOException, UnknownHostException {
        // (predicate <CycConstant> <CycConstant>)
d1404 4
a1407 4
            predicate.cycName() + " " +
            arg1.cycName() + " " +
            arg2.cycName() + ")" +
            mt.cycName() + "))";
d1410 1
a1410 1
    public void assertGaf (CycConstant mt,
d1412 1
a1412 1
                           CycConstant arg1,
d1414 1
a1414 1
        // (predicate <CycConstant> <String>)
d1417 2
a1418 2
            predicate.cycName() + " " +
            arg1.cycName() + " " +
d1420 1
a1420 1
            mt.cycName() + "))";
d1423 1
a1423 1
    public void assertGaf (CycConstant mt,
d1425 1
a1425 1
                           CycConstant arg1,
d1427 1
a1427 1
        // (predicate <CycConstant> <List>)
d1430 4
a1433 4
            predicate.cycName() + " " +
            arg1.cycName() + " " +
            arg2.cyclify() + ")" +
            mt.cycName() + "))";
d1436 1
a1436 1
    public void assertGaf (CycConstant mt,
d1438 1
a1438 1
                           CycConstant arg1,
d1440 1
a1440 1
        // (predicate <CycConstant> <int>)
d1443 2
a1444 2
            predicate.cycName() + " " +
            arg1.cycName() + " " +
d1446 1
a1446 1
            mt.cycName() + "))";
d1449 1
a1449 1
    public void assertGaf (CycConstant mt,
d1451 4
a1454 4
                           CycConstant arg1,
                           CycConstant arg2,
                           CycConstant arg3)   throws IOException, UnknownHostException {
        // (predicate <CycConstant> <CycConstant> <CycConstant>)
d1457 5
a1461 5
            predicate.cycName() + " " +
            arg1.cycName() + " " +
            arg2.cycName() + " " +
            arg3.cycName() + ")" +
            mt.cycName() + "))";
d1471 2
a1472 2
                               CycConstant mt)   throws IOException, UnknownHostException {
        assertGaf(mt, getConstantByName("comment"), cycConstant, comment);
d1476 1
a1476 1
     * Create a microtheory MT, with a comment, isa <mt type> and CycConstant genlMts.
d1482 1
a1482 1
                                          CycConstant isaMt,
d1495 1
a1495 1
            CycConstant aGenlMt = (CycConstant) iterator.next();
d1517 3
a1519 3
        CycConstant worldLikeOursMt = this.getConstantByName("WorldLikeOursCollectorMt");
        CycConstant currentWorldDataMt = this.getConstantByName("CurrentWorldDataCollectorMt");
        CycConstant genlMt_Vocabulary = this.getConstantByName("genlMt-Vocabulary");
d1523 1
a1523 1
                                                 getConstantByName("TheoryMicrotheory"),
d1527 1
a1527 1
                                                getConstantByName("VocabularyMicrotheory"),
d1531 1
a1531 1
                                               getConstantByName("DataMicrotheory"),
d1549 1
a1549 1
                                     CycConstant mt)   throws IOException, UnknownHostException {
d1554 1
a1554 1
     * Assert that the CycConstant GENLS is a genls of CycConstant SPEC,
d1558 3
a1560 3
    public void assertGenls (CycConstant specCollection,
                             CycConstant genlsCollection,
                             CycConstant mt)   throws IOException, UnknownHostException {
d1565 1
a1565 1
     * Assert that the CycConstant GENLS isa CycConstant ACOLLECTION,
d1569 4
a1572 4
    public void assertIsa (CycConstant cycConstant,
                             CycConstant aCollection,
                             CycConstant mt)   throws IOException, UnknownHostException {
        assertGaf(mt, isa, cycConstant, aCollection);
d1580 1
a1580 1
                                          CycConstant mt)   throws IOException, UnknownHostException {
d1605 2
d1622 1
a1622 1
                                    CycConstant mt)  throws IOException, UnknownHostException {
d1629 3
a1631 3
        queryBuffer.append("    (ask-template '" + variable.cyclify() + " ");
        queryBuffer.append("                  '" + query.cyclify() + " ");
        queryBuffer.append("                  " + mt.cyclify() + " ");
d1644 1
a1644 1
                                CycConstant mt)  throws IOException, UnknownHostException {
d1665 1
a1665 1
                                          CycConstant mt) throws IOException {
d1684 1
a1684 1
    public int countAllInstances(CycConstant collection, CycConstant mt) throws IOException {
d1686 2
a1687 2
                                collection.cyclify() + " " +
                                mt.cyclify() + ")");
d1698 2
a1699 2
    public int countAllInstances_Cached(CycConstant collection,
                                        CycConstant mt) throws IOException {
d1718 1
a1718 1
    public CycList getBackchainRules (CycConstant predicate, CycConstant mt)
d1722 4
a1725 3
        command.append("  (with-mt " + mt.cyclify() + " ");
        command.append("    (do-rule-index (rule " + predicate.cyclify() + " :pos nil :backward) ");
        command.append("       (cpush (assertion-el-formula rule) backchain-rules))) ");
d1738 1
a1738 1
    public CycList getForwardChainRules (CycConstant predicate, CycConstant mt)
d1742 4
a1745 3
        command.append("  (with-mt " + mt.cyclify() + " ");
        command.append("    (do-rule-index (rule " + predicate.cyclify() + " :pos nil :forward) ");
        command.append("       (cpush (assertion-el-formula rule) forward-chain-rules))) ");
d1793 15
d1809 47
@


1.19
log
@Refactored binary api support to pass all unit tests
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.18 2001/08/27 22:30:44 stephenreed Exp $
d617 2
a618 2
     * Completes the instantiation of <tt>CycVariable</tt> returned by the binary api. The
     * binary api sends only variable ids, and the variable name must be retrieved
d620 2
a621 1
     * the binary api, instead the variable is output as a symbol.
d629 2
a630 1
        cycVariable.name = getVariableName(cycVariable.id);
d728 1
a728 1
        command.add(CycSymbol.makeCycSymbol("assertion-formula"));
d1708 1
a1708 1
        command.append("       (cpush (assertion-formula rule) backchain-rules))) ");
d1727 1
a1727 1
        command.append("       (cpush (assertion-formula rule) forward-chain-rules))) ");
d1757 16
@


1.18
log
@Additional api test cases
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.17 2001/08/27 14:39:27 stephenreed Exp $
d269 2
a270 27
        if (response[0].equals(Boolean.TRUE)) {
            if (cycConnection.communicationMode == CycConnection.BINARY_MODE) {
                // The binary api correctly determines object types.
                if (response[1] == null)
                    // Do not coerce empty lists to the symbol nil, instead return a list of size zero.
                    return new CycList();
                else
                    return response[1];
            }
            else {
                // The ascii api returns strings which need further parsing because in this method the
                // expected return object type is unknown.
                String string = (String) response[1];
                if (StringUtils.isNumeric(string))
                    response[1] = new Long(string);
                else if (CycSymbol.isValidSymbolName(string))
                    response[1] = CycSymbol.makeCycSymbol(string);
                else if (string.startsWith("#$"))
                    response[1] = getConstantByName(string);
                else if ((string.length() > 2) &&
                         (string.charAt(0) == '"') &&
                         (string.charAt(string.length() - 1) == '"'))
                    // Strip off the delimiting quotes and return a java string object.
                    response[1] = string.substring(1, string.length() - 1);
                return response[1];
            }
        }
d276 2
a277 1
     * Converses with Cyc to perform an API command whose result is returned as a list.
d285 2
a286 3
        if (response[0].equals(Boolean.TRUE)) {
            if (response[1] == null)
                // Do not coerce empty lists to the symbol nil, instead return a list of size zero.
a289 1
        }
d323 1
a323 4
            if (response[1] == null)
                // Do not conflate null with the symbol NIL.
                return false;
            else if (response[1].toString().equals("T"))
d654 3
@


1.17
log
@Added id to CycVariable, completed binary api test cases.
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.16 2001/08/27 02:30:53 stephenreed Exp $
d261 40
d1734 1
a1734 1
        this.traceOn();
d1754 27
@


1.16
log
@Unit test cases for binary api connnection
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.15 2001/08/24 22:39:27 stephenreed Exp $
d518 1
a518 1
     * @@return the Guid for the given CycConstant
d533 18
d606 22
d643 3
@


1.15
log
@Continued binary api test cases
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.14 2001/08/23 22:14:25 stephenreed Exp $
d1651 1
@


1.14
log
@Continuing unit test cases for binary api
@
text
@d15 1
a15 1
 * @@version $Id: CycAccess.java,v 1.13 2001/08/23 09:33:13 stephenreed Exp $
d290 3
d546 44
a589 2
     * Completes the instantiation of <tt>CycConstant</tt> object contained in the given <tt>CycList</tt>. The
     * binary api sends only constant ids, and the constant names and guids must be retreived if the constant is
d593 1
d595 1
a595 1
    public void completeCycList (CycList cycList) throws IOException, UnknownHostException {
d600 5
a604 11
            else if (element instanceof CycConstant) {
                CycConstant cycConstant = (CycConstant) element;
                cycConstant.name = getConstantName(cycConstant.id);
                CycConstant cachedConstant = CycConstant.getCache(cycConstant.name);
                if (cachedConstant == null) {
                    cycConstant.guid = getConstantGuid(cycConstant.id);
                    CycConstant.addCache(cycConstant);
                }
                else
                    cycList.set(i, cachedConstant);
            }
d606 25
d637 3
a639 3
        CycNart answer = CycNart.getCache(id);
        if (answer != null) {
            return answer;
d642 2
a643 2
            answer = new CycNart();
            answer.id = id;
d645 10
a654 5
            /*
        String command = "(assertion-formula (find-assertion-by-id " + id + "))";
        answer.setFormula(converseList(command));
        */
        return answer;
d661 4
a664 4
        CycAssertion answer = CycAssertion.getCache(id);
        if (answer != null) {
            if (answer.getFormula() != null)
                return answer;
d667 9
a675 4
            answer = new CycAssertion(id);
        String command = "(assertion-formula (find-assertion-by-id " + id + "))";
        answer.setFormula(converseList(command));
        return answer;
a681 1

a685 67
    /*
        throws java.net.UnknownHostException, java.io.IOException, java.lang.IllegalArgumentException {
        LinkedList arguments = new LinkedList();
        ListIterator iterator = elCons.toLinkedList().listIterator();
        Object functorObject = iterator.next();
        CycFort functor = null;
    String functorString = null;
    if (functorObject instanceof java.lang.String) {
      functorString = (String)functorObject;
    }
    else if (functorObject instanceof com.cyc.util.Atom) {
      functorString = functorObject.toString();
    }
        if (functorString instanceof java.lang.String) {
      try {
            functor = getConstantByName(functorString);
      }
      catch (IOException e) {
        System.err.println(functorString + " is not a constant!");
      }
    }
        else if (functorObject instanceof CycList) {
            functor = getCycNartFromCons((Cons)functorObject);
    }
        while (iterator.hasNext()) {
            Object argObject = iterator.next();
        String argString = null;
        if (argObject instanceof java.lang.String) {
          argString = (String)argObject;
        }
        else if (argObject instanceof com.cyc.util.Atom) {
          argString = argObject.toString();
        }
        Object preArg = null;
        Object arg = null;
        if (argString instanceof java.lang.String && argString.startsWith("#$")) {
          try {
        preArg = getConstantByName(argString);
          }
          catch (IOException e) {
        System.err.println(argString + " is not a constant!");
          }
        }
        if (preArg instanceof com.cyc.util.CycConstant) {
          arg = preArg;
        }
        else if (argString instanceof java.lang.String) {
          System.err.println("Warning: String argument: " + argString);
          arg = argString;
        }
        else if (argObject instanceof CycList) {
          arg = getCycNartFromCons((Cons)argObject);
        }
        if (arg != null) {
          arguments.add(arg);
        }
        else {
          throw new IllegalArgumentException("Could not construct FORT argument from " + argObject);
        }
        }
    if (functor == null || arguments.isEmpty()) {
      throw new IllegalArgumentException(elCons.toString());
    }
    return new CycNart(functor, arguments);
    }
    */

d701 1
a701 1
            else if (response[1].equals("T"))
d1315 1
a1315 1
        converseString(command);
d1570 8
a1577 2
        CycList response = converseList("(removal-ask '" + query.cyclify() + " " + mt.cyclify() +
                                        ")");
@


1.13
log
@Continued unit testing binary api
@
text
@d13 3
a15 1
 * @@version $Id: CycAccess.java,v 1.12 2001/08/23 00:47:46 stephenreed Exp $
d270 5
a274 4

            //TODO make sure constants are complete

            return (CycList) response[1];
d306 4
a309 1
            if (response[1].toString().equals("T"))
d466 21
d493 7
a499 1
        String command = "(boolean (find-constant-by-id " + id + "))";
d503 24
a526 3
        command = "(constant-name (find-constant-by-id " + id + "))";
        String constantName = this.converseString(command);
        return this.getConstantByName(constantName);
d543 26
d692 3
a694 1
            if (response[1].equals("T"))
@


1.12
log
@Continuing integration of legacy binary api
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.11 2001/08/21 23:28:16 stephenreed Exp $
d193 1
a193 1
            cycConnection = new CycConnection(hostName, port, communicationMode);
d251 1
a251 1
            cycConnection = new CycConnection(hostName, port, communicationMode);
d268 3
d303 1
a303 1
            if (response[1].equals("T"))
d382 4
a385 1
     * Gets a CycConstant by using its GUID.
d387 6
a392 2
    public CycConstant getConstantByGuid (Guid guid)  throws IOException, UnknownHostException {
        CycConstant answer = CycConstant.getCache(guid);
d395 33
a427 6
        Object [] response = {null, null};
        String command = "(find-constant-by-guid (string-to-guid \"" + guid + "\"))";
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            String constantName = (String) response[1];
            return CycConstant.makeCycConstant(guid, constantName);
d430 13
a442 1
            throw new IOException(response[1].toString());
d446 2
a447 1
     * Gets a CycConstant by using its constant name.
d449 2
a450 1
     * @@return the complete <tt>CycConstant</tt> if found, otherwise return null
d452 1
a452 1
    public CycConstant getConstantByName (String constantName)
d454 15
a468 8
        Object [] response = {null, null};
        CycList command = new CycList();
        command.add(CycSymbol.makeCycSymbol("find-constant"));
        command.add(constantName);
        response = converse(command);
        if (response[0].equals(Boolean.FALSE))
            throw new IOException(response[1].toString());
        if (response[1].equals(CycSymbol.nil))
d470 4
a473 1
        /*
d475 7
a481 9
         {
            String guid = ((String) response[1]).substring(3, 39);
            return CycConstant.makeCycConstant(guid, constantName);
        }
        else if (((String) response[1]).indexOf("is not an existing constant") > -1)
            return null;
        else
            throw new IOException(response[1].toString());
            */
d483 3
d489 1
a489 1
     * Gets a CycConstant by using its ID.
d491 8
a498 7
    public CycConstant getConstantById (int id)  throws IOException, UnknownHostException {
        Object [] response = {null, null};
        String command = "(find-constant-by-id " + id + ")";
        response = converse(command);
        if (response[0].equals(Boolean.TRUE)) {
            String constantName = (String) response[1];
            return getConstantByName(constantName);
d500 5
a504 2
        else
            throw new IOException(response[1].toString());
d1151 1
a1151 1
        CycConstant.removeCache(cycConstant.guid);
d1221 3
d1225 1
a1225 1
            "(cyc-create-new-permanent \"" + constantName + "\"))";
d1227 1
a1227 1
        return getConstantByName(constantName);
@


1.11
log
@Added new binary api connection classes
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.10 2001/08/20 23:16:59 stephenreed Exp $
d43 1
a43 1
     * Response code returned by the OpenCyc api.
d45 11
a55 1
    public Integer responseCode = null;
d61 1
a61 1
    public boolean persistentConnection = true;
d64 3
a66 2
    private String hostName = CycConnection.DEFAULT_HOSTNAME;
    private int port = CycConnection.DEFAULT_BASE_PORT;
a67 1
    private CycConnection cycConnection;
d163 1
a163 12
     * Constructs a new CycAccess object.
     */
    public CycAccess() throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        if (persistentConnection)
            cycConnection = new CycConnection();
        initializeConstants();
    }
    /**
     * Constructs a new CycAccess object given a host name.
     *
     * @@param hostName the host name
d165 1
a165 7
    public CycAccess(String hostName) throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.hostName = hostName;
        if (persistentConnection)
            cycConnection = new CycConnection(hostName);
        initializeConstants();
    }
d168 1
a168 3
     * Constructs a new CycAccess object given a port.
     *
     * @@param port the TCP socket port number
d170 5
a174 35
    public CycAccess(int port) throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.port = port;
        if (persistentConnection)
            cycConnection = new CycConnection(port);
        initializeConstants();
    }

    /**
     * Constructs a new CycAccess object given a host name and port.
     *
     * @@param hostName the host name
     * @@param port the TCP socket port number
     */
    public CycAccess(String hostName, int port) throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.hostName = hostName;
        this.port = port;
        if (persistentConnection)
            cycConnection = new CycConnection(port);
        initializeConstants();
    }

    /**
     * Constructs a new CycAccess object given an indicator for a persistent socket connection.
     *
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     */
    public CycAccess(boolean persistentConnection) throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.persistentConnection = persistentConnection;
        if (persistentConnection)
            cycConnection = new CycConnection();
        initializeConstants();
a175 1

d177 1
a177 1
     * Constructs a new CycAccess object given a host name.
a179 15
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     */
    public CycAccess(String hostName, boolean persistentConnection) throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.hostName = hostName;
        this.persistentConnection = persistentConnection;
        if (persistentConnection)
            cycConnection = new CycConnection(hostName);
        initializeConstants();
    }

    /**
     * Constructs a new CycAccess object given a port.
     *
d181 1
d185 1
a185 19
    public CycAccess(int port, boolean persistentConnection)
        throws IOException, UnknownHostException {
        cycAccessInstances.put(Thread.currentThread(), this);
        this.port = port;
        this.persistentConnection = persistentConnection;
        if (persistentConnection)
            cycConnection = new CycConnection(port);
        initializeConstants();
    }

    /**
     * Constructs a new CycAccess object given a host name and port.
     *
     * @@param hostName the host name
     * @@param port the TCP socket port number
     * @@param persistentConnection when <tt>true</tt> keep a persistent socket connection with
     * the OpenCyc server
     */
    public CycAccess(String hostName, int port, boolean persistentConnection)
d190 1
d193 1
a193 1
            cycConnection = new CycConnection(port);
d246 1
a246 1
     * @@param command the command string
d248 2
a249 2
    private Object [] converse(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d251 1
a251 1
            cycConnection = new CycConnection(hostName, port);
d261 1
a261 1
     * @@param command the command string
d264 2
a265 2
    public CycList converseList(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d267 1
a267 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d277 1
a277 1
     * @@param command the command string
d280 2
a281 2
    public String converseString(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d283 1
a283 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d293 1
a293 1
     * @@param command the command string
d296 2
a297 2
    public boolean converseBoolean(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d299 1
a299 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d312 1
a312 1
     * @@param command the command string
d315 2
a316 2
    public int converseInt(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d318 1
a318 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d328 1
a328 1
     * @@param command the command string
d330 2
a331 2
    public void converseVoid(String command)  throws IOException, UnknownHostException {
        Object [] response = {new Integer(0), ""};
d333 1
a333 2
        responseCode = (Integer) response[0];
        if (! responseCode.equals(OK_RESPONSE_CODE))
d385 1
a385 1
        Object [] response = {new Integer(0), ""};
d388 1
a388 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d398 2
d403 4
a406 6
        Object [] response = {new Integer(0), ""};
        String command;
        if (constantName.startsWith("#$"))
           command = "(constant-guid " + constantName + ")";
        else
           command = "(constant-guid #$" + constantName + ")";
d408 7
a414 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d422 2
d430 1
a430 1
        Object [] response = {new Integer(0), ""};
d433 1
a433 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
d539 1
a539 1
        Object [] response = {new Integer(0), ""};
d545 1
a545 2
        responseCode = (Integer) response[0];
        if (responseCode.equals(OK_RESPONSE_CODE)) {
@


1.10
log
@Added method to gather possibly applicable backchaining rules from the KB
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.9 2001/08/20 21:26:24 stephenreed Exp $
d55 1
a55 1
    private int port = CycConnection.DEFAULT_PORT;
d458 3
a477 3
        CycConstant answer = CycConstant.getCache(constantName);
        if (answer != null)
            return answer;
d488 1
a488 2
            answer = CycConstant.makeCycConstant(guid, constantName);
            return answer;
d497 32
d1157 1
a1157 1
        CycConstant.removeCache(cycConstant);
d1443 1
a1443 1
        CycConstant cycConstant = CycConstant.getCache(name);
d1445 1
a1445 3
            cycConstant = this.getConstantByName(name);
            if (cycConstant == null)
                cycConstant = this.createNewPermanent(name);
@


1.9
log
@Unit tests for argument type constraint augmentation now work.
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.8 2001/08/20 14:00:06 stephenreed Exp $
d1513 36
@


1.8
log
@Geting unit tests working for ProblemParser and arg constraints gathering.
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.7 2001/08/17 13:57:21 stephenreed Exp $
d124 5
d450 2
@


1.7
log
@Added more methods to argument type constraints class
@
text
@d6 1
d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.6 2001/08/16 23:04:57 stephenreed Exp $
d42 9
d52 1
a53 1
    public Integer responseCode = null;
d59 64
a122 8
    // Common constants.
    public CycConstant baseKB = null;
    public CycConstant isa = null;
    public CycConstant genls = null;
    public CycConstant genlMt = null;
    public CycConstant comment = null;
    public CycConstant collection = null;
    public CycConstant binaryPredicate = null;
d128 20
a155 1

d419 26
a444 7
        baseKB = getConstantByName("BaseKB");
        isa = getConstantByName("isa");
        genls = getConstantByName("genls");
        genlMt = getConstantByName("genlMt");
        comment = getConstantByName("comment");
        collection = getConstantByName("Collection");
        binaryPredicate = getConstantByName("BinaryPredicate");
d729 4
d734 2
a735 1
    public boolean isGenlOf (CycConstant genl, CycConstant spec)  throws IOException, UnknownHostException {
d740 24
d1037 19
d1448 2
a1449 1
        CycList response = converseList("(removal-ask '" + query.cyclify() + " " + mt.cyclify() + ")");
d1454 22
a1475 1
     * Return the count of the instances of the given collection.
d1486 22
@


1.6
log
@Added argument type constraint rule augmentation.
@
text
@d12 1
a12 1
 * @@version $Id: CycAccess.java,v 1.5 2001/08/16 14:25:26 stephenreed Exp $
d855 8
@


1.5
log
@Changed toString method of CycVariable to include "?" prefix.
Continued with unit test of the European Cathedrals constraint use case with OpenCyc connection.
@
text
@a5 1
import java.lang.IllegalArgumentException;
d12 1
a12 1
 * @@version $Id: CycAccess.java,v 1.4 2001/08/15 23:49:55 stephenreed Exp $
d815 1
a815 1
    public ArrayList getWhyIsaParaphrase (CycConstant spec, CycConstant genl)  throws IOException, UnknownHostException {
d830 1
a830 1
     * Gets a list of the genlPreds for a CycConstant.
d832 2
a833 2
    public CycList getGenlPreds (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (genl-predicates " + cycConstant.cycName() + ")))");
d837 1
a837 1
     * Gets a list of the arg1Isas for a CycConstant.
d839 2
a840 2
    public CycList getArg1Isas (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(remove-duplicates (with-all-mts (arg1-isa " + cycConstant.cycName() + ")))");
d844 1
a844 1
     * Gets a list of the arg2Isas for a CycConstant.
d846 2
a847 2
    public CycList getArg2Isas (CycConstant cycConstant)  throws IOException, UnknownHostException {
       return converseList("(remove-duplicates (with-all-mts (arg2-isa " + cycConstant.cycName() + ")))");
d851 1
a851 1
     * Gets a list of the arg1Formats for a CycConstant.
d853 3
a855 2
    public CycList getArg1Formats (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (arg1-format " + cycConstant.cycName() + "))");
d859 1
a859 1
     * Gets a list of the arg2Formats for a CycConstant.
d861 9
a869 2
    public CycList getArg2Formats (CycConstant cycConstant)  throws IOException, UnknownHostException {
        return converseList("(with-all-mts (arg2-format " + cycConstant.cycName() + "))");
@


1.4
log
@Cached CycAccess instances by thread and introduced European Cathedrals
constraint problem that evaluates its rules in OpenCyc.
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.3 2001/08/15 18:00:34 stephenreed Exp $
d295 17
d1285 12
a1296 1

@


1.3
log
@Fixed backchainer to pass unit tests with OpenCyc connection
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.2 2001/08/15 14:50:45 stephenreed Exp $
d36 6
d66 1
d68 1
a68 1
            cycConnection = new CycConnection(this);
d78 1
d81 1
a81 1
            cycConnection = new CycConnection(hostName, this);
d91 1
d94 1
a94 1
            cycConnection = new CycConnection(port, this);
d105 1
d109 1
a109 1
            cycConnection = new CycConnection(port, this);
d120 1
d123 1
a123 1
            cycConnection = new CycConnection(this);
d135 1
d139 1
a139 1
            cycConnection = new CycConnection(hostName, this);
d152 1
d156 1
a156 1
            cycConnection = new CycConnection(port, this);
d170 1
d175 1
a175 1
            cycConnection = new CycConnection(port, this);
d180 13
d221 1
d233 1
a233 1
            cycConnection = new CycConnection(hostName, port, this);
d1229 37
@


1.2
log
@Made CycAccess the factory object for CycLists
@
text
@d13 1
a13 1
 * @@version $Id: CycAccess.java,v 1.1 2001/08/14 23:49:56 stephenreed Exp $
a54 1

@


1.1
log
@Added OpenCyc server connection classes
@
text
@d13 1
a13 1
 * @@version $Id: UnitTest.java,v 1.3 2001/08/13 16:14:44 stephenreed Exp $
d62 1
a62 1
            cycConnection = new CycConnection();
d74 1
a74 1
            cycConnection = new CycConnection(hostName);
d86 1
a86 1
            cycConnection = new CycConnection(port);
d100 1
a100 1
            cycConnection = new CycConnection(port);
d113 1
a113 1
            cycConnection = new CycConnection();
d128 1
a128 1
            cycConnection = new CycConnection(hostName);
d144 1
a144 1
            cycConnection = new CycConnection(port);
d162 1
a162 1
            cycConnection = new CycConnection(port);
d206 1
a206 1
            cycConnection = new CycConnection(hostName, port);
d303 1
a303 1
    public CycConstant getConstantByGuid (String guid)  throws IOException, UnknownHostException {
d467 1
a467 1
        return converseString("(with-precise-paraphrase-on (generate-phrase '" + assertion.toString() + "))");
d682 2
a683 2
        for (int i = 0; i < answerPhrases.size(); i++) {
            CycList assertion = (CycList) ((CycList) answerPhrases.get(i)).first();
d1174 28
@

