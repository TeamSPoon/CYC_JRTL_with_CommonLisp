head	1.9;
access;
symbols
	OPENCYC_1_0_1:1.9
	PRE_1_0:1.9;
locks; strict;
comment	@# @;


1.9
date	2002.06.27.14.13.20;	author dmiles;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.18.23.55.11;	author dmiles;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.06.15.43.15;	author dmiles;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.06.08.04.44;	author dmiles;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.05.13.48.08;	author dmiles;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.05.13.23.16;	author dmiles;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.05.12.55.01;	author dmiles;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.05.08.55.10;	author dmiles;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.05.04.25.05;	author dmiles;	state Exp;
branches;
next	;


desc
@@


1.9
log
@OpenCyc api server now handles Strings in Cyclification.. effected all files
@
text
@% ===================================================================
% File 'interface.pl'
% Purpose: Lower-level connection based utilities for interfacing to OpenCyc from SWI-Prolog
% Maintainer: Douglas Miles
% Contact: $Author: dmiles $@@users.sourceforge.net ;
% Version: 'interface.pl' 1.0.0
% Revision:  $Revision: 1.8 $
% Revised At:   $Date: 2002/06/18 23:55:11 $
% ===================================================================

:-module(opencyc,[
	 cycInit/0,
	 getCycConnection/3,
	 finishCycConnection/3,
	 invokeSubL/1,
	 invokeSubL/2,
	 invokeSubLRaw/2,
	 cycStats/0,
	 printSubL/2,
	 formatCyc/3,
	 toCycApiExpression/2,
	 toCycApiExpression/3,
	 cycQuery/1,
	 cycQuery/2,
	 cycAssert/1,
	 cycAssert/2,
	 cycRetract/1,
	 cycRetract/2,
	 cycRetractAll/1,
	 cycRetractAll/2,
	 isDebug/0,
	 makeConstant/1,
	 ensureMt/1,
	 cyclify/2,
	 cyclifyNew/2,
	 defaultMt/1,
	 mtForPred/2,
	 isRegisterCycPred/3,
	 registerCycPred/1,
	 registerCycPred/2,
	 registerCycPred/3,
	 assertThrough/1,
	 assertThrough/2,
	 retractAllThrough/1,
	 retractAllThrough/2,
	 testOpenCyc/0]).

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).

% ===================================================================
% Connecter to Cyc TCP Server
% ===================================================================
:-dynamic(cycConnection/3).
:-dynamic(cycConnectionUsed/3).
:-dynamic(cycMutex/2).
:-dynamic(cycChatMode/1).

getCycConnection(SocketId,OutStream,InStream):-
      retract(opencyc:cycConnection(SocketId,OutStream,InStream)),
      assertz(opencyc:cycConnectionUsed(SocketId,OutStream,InStream)),!.

getCycConnection(SocketId,OutStream,InStream):-
      tcp_socket(SocketId),
      tcp_connect(SocketId,'127.0.0.1':3601),
      tcp_open_socket(SocketId, InStream, OutStream),!,
      isDebug((format(user_error,'Connected to Cyc TCP Server {~w,~w}\n',[InStream,OutStream]),flush_output(user_error))),
      assertz(opencyc:cycConnectionUsed(SocketId,OutStream,InStream)),!.

finishCycConnection(SocketId,OutStream,InStream):-
      ignore(system:retractall(opencyc:cycConnectionUsed(SocketId,OutStream,InStream))),
      asserta(opencyc:cycConnection(SocketId,OutStream,InStream)),!.
      
cycStats:- % will add more 
   listing(cycConnection),
   listing(cycConnectionUsed).

cycInit.

% ===================================================================
% Invoke SubL
% invokeSubLRaw(-Send[,+Receive]).
% 
% ?- invokeSubLRaw('(find-constant "Dog")').
% #$Dog
%
% ===================================================================

invokeSubL(Send):-
      invokeSubLRaw(Send,Receive),
      isDebug(format('~s',[Receive])).

invokeSubL(Send,Receive):-
      invokeSubLRaw(Send,ReceiveCodes),
      atom_codes(Receive,ReceiveCodes).

invokeSubLRaw(Send,Receive):-
      getCycConnection(SocketId,OutStream,InStream),
      printSubL(InStream,OutStream,Send),
      readSubL(InStream,Get),!,
      finishCycConnection(SocketId,OutStream,InStream),!,
      checkSubLError(Send,Get,Receive),!.

checkSubLError(Send,[53,48,48,_|Info],Info):-!, %Error "500 "
      atom_codes(ErrorMsg,Info),
      throw(cyc_error(ErrorMsg,Send)).
checkSubLError(_,[_,_,_,_|Info],Info):-!.
checkSubLError(Send,Info,Info).

% ===================================================================
% Lowlevel printng
% ===================================================================

printSubL(InStream,OutStream,Send):-
      popRead(InStream),
      printSubL(OutStream,Send).

printSubL(OutStream,Send):-     
      (var(Send) ->
	 throw(cyc_error('Unbound SubL message',Send));
         is_list(Send) ->
	    formatCyc(OutStream,'~s~n',[Send]);
	       atom(Send) -> formatCyc(OutStream,'~w~n',[Send]);
	       compound(Send) ->
      	       (toCycApiExpression(Send,[],STerm),formatCyc(OutStream,'~w~n',[STerm]));
%	       throw(cyc_error('SubL message type not supported',Send)),
	       	       formatCyc(OutStream,'~w~n',[Send])),!.


formatCyc(OutStream,Format,Args):-
      format(OutStream,Format,Args),
      isDebug(format(user_error,Format,Args)),
      flush_output(OutStream),!.

readSubL(InStream,[G,E,T,Space|Response]):-
      get_code(InStream,G),
      get_code(InStream,E),
      get_code(InStream,T),
      get_code(InStream,Space),
      readCycLTermChars(InStream,Response),!.

% ===================================================================
% Lowlevel readCycLTermChars
% ===================================================================
readCycLTermChars(InStream,Response):-
   readCycLTermChars(InStream,Response,_).
   

readCycLTermChars(InStream,[Start|Response],Type):-
   peek_code(InStream,Start),
   readCycLTermCharsUntil(Start,InStream,Response,Type),
   isDebug(format('cyc>~s (~w)~n',[Response,Type])).

readCycLTermCharsUntil(34,InStream,Response,string):-!,
   get_code(InStream,_),
   readUntil(34,InStream,Response),
   popRead(InStream).

readCycLTermCharsUntil(35,InStream,[35|Response],term):-!,
   get_code(InStream,_),
   readUntil(10,InStream,Response),
   popRead(InStream).

readCycLTermCharsUntil(84,InStream,"T",true):-!,
   popRead(InStream).

readCycLTermCharsUntil(78,InStream,"N",nill):-!,
   popRead(InStream).

readCycLTermCharsUntil(40,InStream,Trim,cons):-!,
   readCycL(InStream,Trim),
   popRead(InStream).

popRead(InStream) :- once(wait_for_input([InStream], Inputs,0.01)),Inputs=[],!.
popRead(InStream) :-get_code(InStream, _),popRead(InStream).

readUntil(Char,InStream,Response):-
      get_code(InStream,C),
      readUntil(Char,C,InStream,Response).
      
readUntil(Char,Char,InStream,[]):-!.
readUntil(Char,C,InStream,[C|Out]):-get_code(InStream,Next),
   readUntil(Char,Next,InStream,Out).


      
% ===================================================================
%  conversion toCycApiExpression
% ===================================================================

toCycApiExpression(Prolog,CycLStr):-toCycApiExpression(Prolog,[],CycLStr).

toCycApiExpression(Prolog,Vars,Chars):-var(Prolog),!,toCycVar(Prolog,Vars,Chars).
toCycApiExpression(Prolog,Vars,Prolog):-(atom(Prolog);number(Prolog)),!.
toCycApiExpression(Prolog,Vars,Chars):-is_string(Prolog),!,sformat(Chars,'"~s"',[Prolog]).
toCycApiExpression(nv(List),Vars,Chars):-toCycApiExpression_l(List,Vars,Chars),!.
toCycApiExpression([nv|List],Vars,Chars):-toCycApiExpression_l(List,Vars,Chars),!.
   
toCycApiExpression([P|List],Vars,Chars):-
			toCycApiExpression_l([P|List],Vars,Term),
			sformat(Chars,'\'(~w)',[Term]).
toCycApiExpression(quote(List),Vars,Chars):-
			toCycApiExpression(List,Vars,Term),
			sformat(Chars,'\'~w',[Term]).
toCycApiExpression(Prolog,Vars,Chars):-compound(Prolog),!,
			Prolog=..[P|List],
			toCycApiExpression_l(List,Vars,Term),
			(P = holds ->
			   sformat(Chars,'(~w)',[Term]);
			   sformat(Chars,'(~w ~w)',[P,Term])).

toCycApiExpression_l([],Vars,''):-!.
toCycApiExpression_l([A],Vars,Chars):-toCycApiExpression(A,Vars,Chars),!.
toCycApiExpression_l([A|Rest],Vars,Chars):-
      toCycApiExpression(A,Vars,Chars1),
      toCycApiExpression_l(Rest,Vars,Chars2),
      sformat(Chars,'~w ~w',[Chars1,Chars2]),!.

toCycVar(Var,[VV|_],NameQ):-nonvar(VV),VV=..[_,Name,VarRef],
   Var==VarRef,!,sformat(NameQ,'?~w',[Name]).
toCycVar(Var,[_|Rest],Name):-nonvar(Rest),toCycVar(Var,Rest,Name).
toCycVar(VAR,_,VarName):-
      term_to_atom(VAR,AVAR),
      atom_codes(AVAR,[95|CODES]),!,
      catch(sformat(VarName,'?HYP-~s',[CODES]),_,VarName='?HYP-VAR').

is_string([A,B|_]):-integer(A),integer(B).


% ===================================================================
%  Debugging Cyc 
% ===================================================================
     
:-dynamic(isDebug).

% Uncomment this next line to see Cyc debug messages

% isDebug.

isDebug(Call):- isDebug -> ignore(once(Call)) ; true.


% ===================================================================
%  Cyc Query Cache Control
% ===================================================================


:-dynamic(cachable_query/1).
:-dynamic(cached_query/2).

cachable_query(isa(_,_)).

% ===================================================================
%  Cyc Assert
% ===================================================================

cycAssert(Mt:CycL):-!,
   cycAssert(CycL,Mt).
cycAssert(CycL):-
   mtForPred(CycL,Mt),
   cycAssert(CycL,Mt).

cycAssert(CycL,Mt):-
      system:retractall(opencyc:cached_query(_,_)),
      cyclifyNew(CycL,CycLGood),
      cyclify(Mt,MtGood),
      defaultAssertOptions(DefaultOptions), 
      toCycApiExpression('CYC-ASSERT'(quote(CycLGood),MtGood,DefaultOptions),API),
      invokeSubL(API),!.

:-dynamic(defaultAssertOptions/1).

defaultAssertOptions([':FORWARD',':MONOTONIC']).

      
% ===================================================================
%  Cyc Unassert/Retract
% ===================================================================
cycRetract(CycL,Mt):-cycRetractAll(CycL,Mt).
cycRetract(CycL):-cycRetractAll(CycL).

cycRetractAll(CycL):-
      mtForPred(CycL,Mt),
      cycUnassert(CycL,Mt).

cycRetractAll(CycL,Mt):-cycUnassert(CycL,Mt).
cycUnassert(CycL,Mt):-
      system:retractall(opencyc:cached_query(_,_)),
      cyclifyNew(CycL,CycLGood),
      cyclify(Mt,MtGood),
      invokeSubL('CYC-UNASSERT'(quote(CycLGood),MtGood)).


% ===================================================================
%  Cyc Query
% ===================================================================

cycQuery(CycL):-cycQuery(CycL,'#$EverythingPSC',Result).
cycQuery(CycL,Mt):-cycQuery(CycL,Mt,Result).

cycQuery(CycL,Mt,Result):-
      copy_term(CycL,Copy),
      numbervars(Copy,'$VAR',0,_),!,
      cycQuery(Copy,CycL,Mt,Result).

cycQuery(Copy,CycL,Mt,Result):-cached_query(Copy,Results),!,
      member(CycL,Results).
cycQuery(Copy,CycL,Mt,Result):-cachable_query(Copy),!,
      findall(CycL,cycQueryReal(CycL,Mt,Result),Save),
      (Save=[] -> true ; asserta(cached_query(CycL,Save))),!,
      member(CycL,Save).
cycQuery(Copy,CycL,Mt,Result):-
      cycQueryReal(CycL,Mt,Result).

cycQueryReal(CycL,Mt,Result):-
      getCycConnection(SocketId,OutStream,InStream),
      popRead(InStream),
      cyclify(CycL,CycLGood),
      cyclify(Mt,MtGood),
      printSubL(OutStream,'CYC-QUERY'(quote(CycLGood),MtGood)),
      get_code(InStream,A),
      get_code(InStream,B),
      get_code(InStream,C),
      get_code(InStream,D),
      free_variables(CycLGood,Vars),
      get_code(InStream,E),!,% Takes the first paren
      repeat,
      (peek_code(InStream,PCode), 
      isDebug(format('PCODE (~q)~n',[PCode])),
      ((member(PCode,[35,73]),finishCycConnection(SocketId,OutStream,InStream),!,fail);true), % 35 is No
      ((PCode=78,finishCycConnection(SocketId,OutStream,InStream),!);(    % 78 is Yes
      readCycL(InStream,Trim),
      peek_code(InStream,Code), 
      isDebug(format('"~s" (~q)~n',[Trim,Code])),
      ((Code\=32,!,finishCycConnection(SocketId,OutStream,InStream));(true)),
      getSurfaceFromChars(Trim,IResult,_),
      IResult=[Result],
      syncCycLVars(Result,Vars)))).

syncCycLVars(_,[]).
syncCycLVars([[_, '.', Binding]|T],[Binding|VV]):-syncCycLVars(T,VV),!.
syncCycLVars([[_|Binding]|T],[Binding|VV]):-syncCycLVars(T,VV),!.

% ===================================================================
%  Cyclification
%
%    cyclify(Before,After)
%     Makes sure that atoms in Statement are prefixed witbh '#$' when comunicationg with Cyc
%
%    cyclifyNew(Before,After)
%     same as cyclify/2 but adds the constant names with (CREATE-CONSTANT "~w")
%
% ===================================================================

cyclify(Same,Same):-var(Same);number(Same).
cyclify([],[]).
cyclify([H|T],Term):-integer(H) -> Term=[H|T]; cyclify_l([H|T],Term).
cyclify(Before,After):-atom(Before),
      sub_atom(Before,0,1,_,F),!,
      cyclify(F,Before,After).
cyclify(Before,After):-
      Before=..[B|BL],
      cyclify(B,A),
      cyclify_l(BL,AL),
      After=..[A|AL].

cyclify('#',Before,Before).
cyclify('?',Before,Before).
cyclify(':',Before,Before).
cyclify('!',Before,After):-atom_concat('!',After,Before).
cyclify('"',Before,Before).
cyclify(_,Before,After):-atom_concat('#$',Before,After).
      
cyclify_l([B],[A]):-cyclify(B,A),!.
cyclify_l([],[]).
cyclify_l([B|BL],[A|AL]):-
      cyclify(B,A),
      cyclify_l(BL,AL).


cyclifyNew(Same,Same):-var(Same);number(Same).
cyclifyNew([],[]).
cyclifyNew([H|T],Term):-integer(H) -> Term=[H|T]; cyclifyNew_l([H|T],Term).
cyclifyNew(Before,After):-atom(Before),
      sub_atom(Before,0,1,_,F),!,
      cyclifyNew(F,Before,After).
cyclifyNew(Before,After):-
      Before=..[B|BL],
      cyclifyNew(B,A),
      cyclifyNew_l(BL,AL),
      After=..[A|AL].

cyclifyNew('#',Before,Before).
cyclifyNew('?',Before,Before).
cyclifyNew(':',Before,Before).
cyclifyNew('!',Before,After):-atom_concat('!',After,Before).
cyclifyNew('"',Before,Before).
cyclifyNew(_,Before,After):-atom_concat('#$',Before,After),makeConstant(Before).
      
cyclifyNew_l([B],[A]):-cyclifyNew(B,A),!.
cyclifyNew_l([],[]).
cyclifyNew_l([B|BL],[A|AL]):-
      cyclifyNew(B,A),
      cyclifyNew_l(BL,AL).


% ============================================
% Make new CycConstant
% ============================================

:-dynamic(cycConstantMade/1).

makeConstant(Const):-
   (cycConstantMade(Const)->true;
   (sformat(String,'(CREATE-CONSTANT "~w")',[Const]),
   catch(invokeSubL(String),_,true),
   asserta(cycConstantMade(Const)))),!.

% ============================================
% Make new Microtheory
% ============================================

ensureMt(Const):-
   cycAssert('#$isa'(Const,'#$Microtheory'),'#$BaseKB').

% ============================================
% dynamic Default Microtheory
% ============================================

:-dynamic(defaultMt/1).

defaultMt('PrologDataMt').

:-defaultMt(Mt),!,ensureMt(Mt),cycAssert('#$BaseKB':'#$genlMt'(Mt,'#$InferencePSC')). % Puts the defaultMt/1 into Cyc 

% ===================================================================
%  Predicates need and Assertion Mt
% ===================================================================

mtForPred(CycL,Mt):-
   functor(CycL,Pred,_),
   isRegisterCycPred(Mt,Pred,_),!.

mtForPred(CycL,Mt):-defaultMt(Mt).

% ============================================
% Prolog to Cyc Predicate Mapping
%
%  the following will all do the same things:
%
% ?- registerCycPred('BaseKB':isa/2). 
% ?- registerCycPred('BaseKB':isa(_,_)). 
% ?- registerCycPred(isa(_,_),'BaseKB'). 
% ?- registerCycPred('BaseKB',isa,2). 
%
%  Will make calls 
% ?- isa(X,Y)
%  Query into #$BaseKB for (#$isa ?X ?Y) 
%
% ============================================
:-dynamic(isRegisterCycPred/3).

% ?- registerCycPred('BaseKB':isa/2). 
registerCycPred(Mt:Pred/Arity):-!,
   registerCycPred(Mt,Pred,Arity).
% ?- registerCycPred('BaseKB':isa(_,_)). 
registerCycPred(Mt:Term):-
   functor(Term,Pred,Arity),
   registerCycPred(Mt,Pred,Arity).
% ?- registerCycPred(isa(_,_),'BaseKB'). 
registerCycPred(Term,Mt):-
   functor(Term,Pred,Arity),
   registerCycPred(Mt,Pred,Arity).
   
% ?- registerCycPred('BaseKB',isa,2). 
registerCycPred(Mt,Pred,0):-!,registerCycPred(Mt,Pred,2).
registerCycPred(Mt,Pred,Arity):-isRegisterCycPred(Mt,Pred,Arity),!.
registerCycPred(Mt,Pred,Arity):-
      functor(Term,Pred,Arity),
      asserta(( Term :- cycQuery(Term,Mt))),
      assertz(isRegisterCycPred(Mt,Pred,Arity)),!.

% ============================================
% Assert Side Effect Prolog to Cyc Predicate Mapping
%
% ?- assert(isa('Fido','Dog')).
% Will assert (#$isa #$Fido #$Dog) into #$BaseKB
%
% ?- assert('DogsMt':isa('Fido','Dog')).
% Will assert (#$isa #$Fido #$Dog) into #$DogsMt
% ============================================
:-redefine_system_predicate(assert(_)).
assert(Term):-assertThrough(Term).

assertThrough(Mt:CycL):-
      assertThrough(Mt,CycL).

assertThrough(CycL):-
      assertThrough(Mt,CycL).

assertThrough(ToMt,CycL):-
      functor(CycL,Pred,Arity),
      isRegisterCycPred(Mt,Pred,Arity),!,
      ignore(ToMt=Mt),
      cycAssert(CycL,ToMt),!.

assertThrough(ToMt,CycL):-
      ignore(ToMt=user),
      assertz(ToMt:CycL),!.

% ============================================
% Retract (All) Side Effect Prolog to Cyc Predicate Mapping
%
% ?- retractall(isa('Fido','Dog')).
% Will retract (#$isa #$Fido #$Dog) from #$BaseKB
%
% ?- retractall('DogsMt':isa('Fido','Dog')).
% Will retract (#$isa #$Fido #$Dog) from #$DogsMt
% ============================================
:-redefine_system_predicate(retractall(_)).
retractall(Term):-retractAllThrough(Term).

retractAllThrough(Mt:CycL):-
      retractAllThrough(Mt,CycL).

retractAllThrough(CycL):-
      retractAllThrough(Mt,CycL).

retractAllThrough(ToMt,CycL):-
      functor(CycL,Pred,Arity),
      isRegisterCycPred(Mt,Pred,Arity),!,
      ignore(ToMt=Mt),
      cycRetract(CycL,ToMt),!.

retractAllThrough(ToMt,CycL):-
      ignore(ToMt=user),
      system:retractall(ToMt:CycL),!.
            
% ============================================
% Register isa/genls (more for testing :)
% ============================================

% examples
:-registerCycPred('#$BaseKB',isa,2).
:-registerCycPred('#$BaseKB',genls,2).
:-registerCycPred('#$BaseKB',genlMt,2).


% ============================================
% Testing 
% ============================================
      
testOpenCyc:-halt.


@


1.8
log
@Adding the tested opencyc.pl
@
text
@d7 2
a8 2
% Revision:  $Revision: 1.7 $
% Revised At:   $Date: 2002/06/06 15:43:15 $
d198 3
@


1.7
log
@Fixed the SubL socket to work more inteligently to look for Number+Term (instead of timeout wait check)
@
text
@d7 2
a8 2
% Revision:  $Revision: 1.6 $
% Revised At:   $Date: 2002/06/06 08:04:44 $
d200 1
a200 1
			sformat(Chars,'\(~w)',[Term]).
d239 1
a239 1
isDebug(Call):- isDebug -> Call ; true.
d266 2
a267 1
      toCycApiExpression('CYC-ASSERT'(quote(CycLGood),MtGood),API),
d270 4
d368 2
d394 2
@


1.6
log
@Modulized library(opencyc) properly and debugged a few problems
@
text
@d7 2
a8 2
% Revision:  $Revision: 1.5 $
% Revised At:   $Date: 2002/06/05 13:48:08 $
d12 1
d18 1
a18 1
	 listCycStats/0,
d62 2
a63 2
      retract(cycConnection(SocketId,OutStream,InStream)),
      assertz(cycConnectionUsed(SocketId,OutStream,InStream)),!.
d70 1
a70 1
      assertz(cycConnectionUsed(SocketId,OutStream,InStream)),!.
d73 2
a74 3
      (at_end_of_stream(InStream);readLineNl(InStream, Receive)),
      retractall(cycConnectionUsed(SocketId,OutStream,InStream)),
      asserta(cycConnection(SocketId,OutStream,InStream)),!.
d76 1
a76 1
listCycStats:- % will add more 
d80 2
d101 2
a102 2
      printSubL(OutStream,Send),
      readSubL(InStream,[A,B,C,D|Receive]),!,
d104 1
a104 1
      checkSubLError(Send,[A,B,C,D|Receive]).
d106 1
a106 1
checkSubLError(Send,[53,48,48,32|Info]):- %Error "500 "
d109 2
a110 1
checkSubLError(_,_).
d116 6
a121 2
printSubL(OutStream,Send):-
      var(Send) ->
d129 1
a129 1
	       	       formatCyc(OutStream,'~w~n',[Send]).
d137 6
a142 2
readSubL(InStream,Receive):-
	 readLineNl(InStream, Receive),!.
d145 1
a145 1
% Lowlevel readline
d147 39
a186 12
% readLineNl(-Stream,+Codes).
readLineNl(SocketId, Receive):- readLineNl(SocketId, Receive, []).
readLineNl(Fd, Codes, Tail) :-
        get_code(Fd, C0),
        readLineNl(C0, Fd, Codes, Tail).
readLineNl(end_of_file, _, Tail, Tail) :- !.
readLineNl(-1, _, Tail, Tail) :- !.
readLineNl(10, _, [10|Tail], Tail) :- !.
readLineNl(13, _, [10|Tail], Tail) :- !.
readLineNl(C, Fd, [C|T], Tail) :-
        get_code(Fd, C2),
        readLineNl(C2, Fd, T, Tail).
d188 1
d228 24
d263 1
a263 1
      retractall(cached_query(_,_)),
d266 2
a267 1
      invokeSubL('CYC-ASSERT'(quote(CycLGood),MtGood)).
d282 1
a282 1
      retractall(cached_query(_,_)),
a286 23
% ===================================================================
%  Debugging Cyc 
% ===================================================================
     
:-dynamic(isDebug).

% Uncomment this next line to see Cyc debug messages

% isDebug.

isDebug(Call):- isDebug -> Call ; true.


% ===================================================================
%  Cyc Query Cache Control
% ===================================================================


:-dynamic(cachable_query/1).
:-dynamic(cached_query/2).

cachable_query(isa(_,_)).

d304 1
a304 1
      asserta(cached_query(CycL,Save)),!,
d311 1
d401 2
d404 4
a407 2
   sformat(String,'(CREATE-CONSTANT "~w")',[Const]),
   catch( invokeSubL(String),_,true).
d414 1
a414 1
   cycAssert(isa(Const,'Microtheory'),'BaseKB').
d424 1
a424 2
:-defaultMt(Mt),
   ensureMt(Mt). % Puts the defaultMt/1 into Cyc 
d470 1
a470 1
      asserta((Term:-cycQuery(Term,Mt))),
d534 3
a536 2
:-registerCycPred('BaseKB',isa,2).
:-registerCycPred('BaseKB',genls,2).
@


1.5
log
@Added utilities.pl and updated interface.pl accordingly
@
text
@d7 2
a8 2
% Revision:  $Revision: 1.4 $
% Revised At:   $Date: 2002/06/05 13:23:16 $
d10 37
d68 2
a69 3
      format(user_error,'Connected to Cyc TCP Server {~w,~w}\n',[InStream,OutStream]),
      assertz(cycConnectionUsed(SocketId,OutStream,InStream)),!,
      flush_output(user_error).
d72 1
a72 1
      (at_end_of_stream(InStream);read_line_with_nl(InStream, Receive)),
d76 1
a76 3
      

cc:-
a79 1

d91 1
a91 1
      format('~s',[Receive]).
d95 1
a95 2
      receiveCodes(ReceiveCodes,Receive).
      
a99 1
      trace,
d109 4
d131 1
a131 1
	 read_line_with_nl(InStream, Receive),!.
d133 3
d137 3
a139 6
:-dynamic(isDebug).
isDebug(Call):- isDebug -> Call ; true.

% read_line_with_nl(-Stream,+Codes).
read_line_with_nl(SocketId, Receive):- read_line_with_nl(SocketId, Receive, []).
read_line_with_nl(Fd, Codes, Tail) :-
d141 6
a146 6
        read_line_with_nl(C0, Fd, Codes, Tail).
read_line_with_nl(end_of_file, _, Tail, Tail) :- !.
read_line_with_nl(-1, _, Tail, Tail) :- !.
read_line_with_nl(10, _, [10|Tail], Tail) :- !.
read_line_with_nl(13, _, [10|Tail], Tail) :- !.
read_line_with_nl(C, Fd, [C|T], Tail) :-
d148 1
a148 1
        read_line_with_nl(C2, Fd, T, Tail).
d150 3
a152 2
      
is_string([A,B|_]):-integer(A),integer(B).
d154 1
a154 1
receiveCodes(ReceiveCodes,Receive):-atom_codes(Receive,ReceiveCodes).
d187 1
a187 3

cycReset:-discontinueConnection.
   
d193 6
d205 1
d209 6
d216 1
a216 1
cycRetract(CycL,Mt):-cycUnassert(CycL,Mt).
d224 24
a249 2
     
isDebug.
a258 5
:-dynamic(cachable_query/1).
:-dynamic(cached_query/2).

cachable_query(isa(_,_)).

d296 10
a305 5
   

      
      
      
a346 5

makeConstant(Const):-
   sformat(String,'(CREATE-CONSTANT "~w")',[Const]),
   catch( invokeSubL(String),_,true).

d354 142
d497 3
@


1.4
log
@Added cycRetract(CycL,Mt)
@
text
@d7 2
a8 3
% Revision:  $Revision: 1.3 $
% Revised At:   $Date: 2002/06/05 12:55:01 $

a290 452
% ===================================================================
% ===================================================================
sendNote(To,From,Subj,Msg):-
   format('~q ~q ~q ~q ~n',[To,From,Subj,Msg]).
      
% ===================================================================
% ===================================================================
% ===================================================================


isSlot(Var):-var(Var).
isSlot('$VAR'(Var)):-number(Var).


:-dynamic reading_in_comment/0.
:-dynamic reading_in_string/0.
:-dynamic read_in_atom/0.
:-dynamic prev_char/1.

% ===================================================================
% CycL Term Reader
% ===================================================================
readCycL(CHARS):-readCycL(user_input,CHARS).


readCycL(Stream,[])  :-at_end_of_stream(Stream).     
readCycL(Stream,Trim)  :-
		flag('bracket_depth',_,0),
		retractall(reading_in_comment),
		retractall(reading_in_string),!,
		readCycLChars_p0(Stream,CHARS),!,trim(CHARS,Trim).

readCycLChars_p0(Stream,[]):-at_end_of_stream(Stream),!.
readCycLChars_p0(Stream,[Char|Chars]):-
        get_code(Stream,C),
	%put(user_error,C),flush_output(user_error),
	cyclReadStateChange(C),readCycLChars_p1(C,Char,Stream,Chars),!.
	
readCycLChars_p1(C,Char,Stream,[]):- at_end_of_stream(Stream),!.
readCycLChars_p1(C,Char,Stream,[]):-isCycLTerminationStateChar(C,Char),!.
readCycLChars_p1(C,Char,Stream,Chars):-cyclAsciiRemap(C,Char),readCycLChars_p0(Stream,Chars),!.

isCycLTerminationStateChar(10,32):-reading_in_comment,!.
isCycLTerminationStateChar(13,32):-reading_in_comment,!.
isCycLTerminationStateChar(41,41):-flag('bracket_depth',X,X),(X<1),!.

cyclReadStateChange(_):- reading_in_comment,!.
cyclReadStateChange(34):- (retract(reading_in_string) ; assert(reading_in_string)),!.
cyclReadStateChange(_):- reading_in_string,!.
cyclReadStateChange(59):- assert(reading_in_comment),!.
cyclReadStateChange(40):-!,flag('bracket_depth',N,N + 1).
cyclReadStateChange(41):-!,flag('bracket_depth',N,N - 1).
cyclReadStateChange(_).

skipCycLChar(Stream):- get_char(Stream,_),!.

cyclAsciiRemap(N,32):-not(number(N)),!.
cyclAsciiRemap(X,32):-X<32,!.
cyclAsciiRemap(X,32):-X>128,!.
cyclAsciiRemap(X,X):-!.


% ===================================================================
% CycL Term Parser
% ===================================================================
/*===================================================================
% getSurfaceFromChars/3 is does less consistantsy checking then conv_to_sterm

Always a S-Expression: 'WFFOut' placing variables in 'VARSOut'

|?-getSurfaceFromChars("(isa a b)",Clause,Vars).
Clause = [isa,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(isa a (b))",Clause,Vars).
Clause = [isa,a,[b]]
Vars = _h70

|?-getSurfaceFromChars("(list a b )",Clause,Vars)
Clause = [list,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(genlMt A ?B)",Clause,Vars).
Clause = [genlMt,'A',_h998]
Vars = [=('B',_h998)|_h1101]

| ?- getSurfaceFromChars("(goals Iran  (not   (exists   (?CITIZEN)   (and    (citizens Iran ?CITIZEN)    (relationExistsInstance maleficiary ViolentAction ?CITIZEN
)))))",Clause,Vars).

Clause = [goals,Iran,[not,[exists,[_h2866],[and,[citizens,Iran,_h2866],[relationExistsInstance,maleficiary,ViolentAction,_h2866]]]]]
Vars = [=(CITIZEN,_h2866)|_h3347]

====================================================================*/

getSurfaceFromChars([],[end_of_file],_):-!.
getSurfaceFromChars([41],[end_of_file],_):-!.

getSurfaceFromChars([CH|ARSIn],TERM,VARS):-!, 
         %getCleanCharsWhitespaceProper(CHARSIn,NoWhiteCHARS),!,  
         (trim([CH|ARSIn],CHARS)),!,
              CHARS=[FC|REST],!,
          (( 
            (FC=59,TERM=[comment,REST], VARS= _ ) ;   % ";" Comment Char found in Line
            (CHARS=[],TERM=nil,VARS=_,! 	  )    %String came empty
            ;
            (FC=40,getSurfaceFromCharBalanced(CHARS,TERM,VARS) ,! )    %Use vanila CycL parser
            ;
            ( TERM=[comment,[FC|REST]],VARS= _,! )     %All above methods of parsing failed.. Convert to comment
            )).
	    
getSurfaceFromChars(C,TERM,VARS):-string_to_list(C,List),!,getSurfaceFromChars(List,TERM,VARS),!.


getSurfaceFromCharBalanced(Chars,WFFOut,VARSOut):- 
    retractall(var_counter(_)),retractall(numbered_var(_,_,_)),asserta(var_counter(0)), 
               getCycLTokens(Chars,Tokens), 
               clean_sexpression(Tokens,WFFClean),!,
               phrase(cycL(WFF),WFFClean),
               collect_temp_vars(VARS),!,
               ( 
                     (VARS=[],VARSOut=_,WFFOut=WFF)
               ;
                     (
                     unnumbervars(VARS,LIST),
                     cyclVarNums(LIST,WFF,WFFOut,VARSOut2) ,
                     list_to_set(VARSOut2,VARSOut1),
                     open_list(VARSOut1,VARSOut)
                     ) 
               ),!.

/*===================================================================
% clean_sexpression(Tokens,CleanTokens)

Removes out STANDARD tokens

====================================================================*/

clean_sexpression([],[]).
clean_sexpression(['#$'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression(['#'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression(['$'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression([E|WFF],[E|WFFClean]):-clean_sexpression(WFF,WFFClean).


%isCharCodelist([]):-!.
%isCharCodelist([H|T]):-!,integer(H),isCharCodelist(T).

/*===================================================================
% S-Expression Version of ISO-Prolog chars_to_tem/3
====================================================================*/
chars_to_term_s(CHARS,TERM,VARS):-
             once(chars_to_term(CHARS,PTERM,VARS)),
             once(pterm_to_sterm(PTERM,TERM)).


/*===================================================================
% Safe Entry Call Into ISO-Prolog tokenize_chars/2
====================================================================*/

getCycLTokens(X,Z):-is_list(X),!,  tokenize_chars(X,Y),convert_the_atoms(Y,Z).

convert_the_atoms([],[]):-!.
convert_the_atoms([H|T],[HH|TT]):-!,  
                convert_the_atom(H,HH),
                convert_the_atoms(T,TT).

%convert_the_atom(H,HH):-atom_codes(H,[34|Rest]),reverse(Rest,[_|AtomCharsR]),reverse(AtomCharsR,AtomChars),atom_codes(HH,AtomChars).
%convert_the_atom(H,HH):-atom_codes(H,[39|Rest]),reverse(Rest,[_|AtomCharsR]),reverse(AtomCharsR,AtomChars),atom_codes(HH,AtomChars).
convert_the_atom(H,H):-!.


getCycLTokens(X,[X]). 

/*===================================================================
% Removes Leading whitespaces and not ANSI charset
====================================================================*/
trim(X,Y):-ltrim(X,R),reverse(R,Rv),ltrim(Rv,RY),reverse(RY,Y).

ltrim([],[]):-!.
ltrim([32,32,32,32,32,32,32|String],Out) :-!, trim(String,Out),!.
ltrim([32,32,32,32,32|String],Out) :- !,trim(String,Out),!.
ltrim([32,32,32|String],Out) :-!, trim(String,Out),!.
ltrim([32,32|String],Out) :- !,trim(String,Out),!.
ltrim([32,32],[]) :- !.
ltrim([P|X],Y):-P<33,trim(X,Y),!.
ltrim([P|X],Y):-P>128,trim(X,Y),!.
ltrim(T,T).

/*===================================================================
%  CycL String to DCG Converter
% Converts up to 13 forms
%     13 Terms long
%  
% =169 Parens Pairs at the First 2 levels  
% 
====================================================================*/


cycL([A]) --> expr(A).
cycL([and,A|L]) --> expr(A) , cycL(L).

   %%expr(RF) --> reifiableFN(RF),!.
expr([]) -->  ['(',')'],!.
expr([Head]) -->  ['('],opr(Head),[')'],!.
expr([Head|LIST]) -->  ['('],opr(Head),many_slots(LIST),[')'].

many_slots([A]) --> slot(A).
many_slots([A|L]) --> slot(A) , many_slots(L).

opr(Head) --> simple(Head) .
opr(Head) --> expr(Head).

%slot(Name) --> simple(Name),['AssignmentFn'], { nonvar(Name), ! }.
slot(SKFName) --> ['SKF'],simple(Name), { nonvar(Name), ! , skf_name(Name,SKFName) }.
slot(WFF) -->  simple(WFF), { nonvar(WFF), ! }.
%slot(['AssignmentFn',Name,List]) -->  reifiableFN(['AssignmentFn',Name,List]).
slot(WFF) -->  expr(WFF), { nonvar(WFF), ! }.


expr(WFF) -->  variable(WFF), { nonvar(WFF) ,!}.
%expr(WFF) -->  reifiableFN(WFF), { nonvar(WFF),! }.   %slot(WFF) -->  literal_list(WFF), { nonvar(WFF) }.


variables_list([list,A]) --> qual_var(A).
variables_list([list,A]) -->  ['('],qual_var(A),[')'],!.
variables_list([list,A,B]) -->  ['('],qual_var(A),qual_var(B),[')'],! .
variables_list([list,A|QV]) -->  ['('],qual_var(A),many_qual_var(QV),[')'],!.
many_qual_var([A]) -->  qual_var(A).
many_qual_var([A|T]) -->  qual_var(A),many_qual_var(T).

% Var/Quality pairs that Sowa's ACE examples use

qual_var(VN) --> ['('],variable(VN),[')'].
qual_var(VN) --> variable(VN).
qual_var(VN) --> ['('],variable(VN),qual(_Quality),[')'].

qual(Q) --> constant(Q), { nonvar(Q) }. % , 'surface-instance'(_,Q,_) }.

number(Number) -->  [Number] , {  nonvar(Number), number(Number),! } .

quantity(Number) --> number(Number).

simple(WFF) -->  quantity(WFF), { nonvar(WFF), ! }.
simple(WFF) -->  variable(WFF), { nonvar(WFF), ! }.
simple(WFF) -->  constant(WFF), { nonvar(WFF), ! }.
%simple(['AssignmentFn',Name,[]]) --> ['SKF'],constant(Name).
%simple(['AssignmentFn',Name,[]]) --> ['SKF'],simple(Name),{ nonvar(Name) , nonvar(List), ! } .
%simple(['AssignmentFn',Name,[]]) --> ['AssignmentFn'],simple(Name), { nonvar(Name) , nonvar(List), ! } .

%reifiableFN(['AssignmentFn',SKFName,[]]) --> ['(','SKF'],simple(Name),[')'], { nonvar(Name) ,! , skf_name(Name,SKFName),sendNote('(skf)') } .
%reifiableFN(['AssignmentFn',SKFName,List]) --> ['(','SKF'],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List), ! , skf_name(Name,SKFName),sendNote('(skf)') } .
%reifiableFN(['AssignmentFn',Name,List]) --> ['(','AssignmentFn'],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List), ! } .
%%reifiableFN(['AssignmentFn',Name,_]) --> ['SKF'],simple(Name).
%reifiableFN(['AssignmentFn',Name,List]) --> ['('],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List),'surface-instance'(Name,'Function',_) ,! } .

skf_name(Num,SKFName):-!,number(Num), number_codes(Num,Codes),atom_codes(SKFName,[115,107|Codes]).

% Construct arbitrary list of args
          
arbitrary([]) -->  [].
arbitrary(VN)-->  ['?',A], { var_number(A,VN)   } . 
arbitrary([Head]) -->  slot(Head).
arbitrary([A|L]) --> slot(A) , many_slots(L).


variable(VN)-->  ['?',A], { var_number(A,VN)   } . 
variable(VN)-->  ['??'], { var_gen(A),var_number(A,VN)   } .     %Anonymous
variable(VN)-->  ['?'], { var_gen(A),var_number(A,VN)   } . 

% Makes up sequencial Variable names for anonymous cycl getPrologVars
var_gen(Atom):-idGen(Number),number_codes(Number,Codes),atom_codes(Atom,[86,65,82|Codes]). % "VAR"

constant(Number) --> number(Number) .
   
constant(Unquoted) -->  [Unquoted] , {  nonvar(Unquoted), not((Unquoted='?';Unquoted='(';Unquoted=')')),! } .
     
var_number(A,'$VAR'(VN)):-numbered_var(A,'$VAR'(VN),_),!.
var_number(A,'$VAR'(VN)):-get_next_num(VN),assert(numbered_var(A,'$VAR'(VN),_)),!.

:-dynamic(numbered_var/3).

:-assert(var_counter(0)).

% This creates ISO Prolog getPrologVars w/in a CycL/STANDARD expression to be reconstrated as after parsing is complete 

get_next_num(VN):-!,retract(var_counter(VN)),NVN is VN +1,asserta(var_counter(NVN)).

cyclVarNums(LIST,'$VAR'(NUM),VAR,[=(SYM,VAR)]):-numbered_var(SYM,'$VAR'(NUM),_VAR),
               member(=(SYM,VAR),LIST).

cyclVarNums(_,Atom,Atom,[]):-atomic(Atom).
cyclVarNums(LIST,Term,NewTerm,VARLIST):-Term=..[F|ARGS],cyclVarNums_list(LIST,ARGS,VARARGS,VARLIST),NewTerm=..[F|VARARGS].

cyclVarNums_list(_LIST,[],[],[]).
cyclVarNums_list(LIST,[A|RGS],[V|ARARGS],VARLIST):-
            cyclVarNums(LIST,A,V,VARS1),
            cyclVarNums_list(LIST,RGS,ARARGS,VARS2),
            append(VARS1,VARS2,VARLIST).


unnumbervars(X,Y):-term_to_atom(X,A),atom_to_term(A,Y,_).

open_list(V,V):-var(V).
open_list(A,B):-append(A,_,B).

unnumbervars_nil(X,Y):-!,unnumbervars(X,Y).

collect_temp_vars(VARS):-!,(setof(=(Name,Number),numbered_var(Name,Number,_),VARS);VARS=[]).

%================================================================
% ISO-Prolog STRING TOKENIZATION                            
%================================================================
:-assert(show_this_hide(tokenize,2)).

%tokenize_chars(M,['(',surf,')']):-nonvar(M),member(34,M),!.
tokenize_chars(X,Y):-once( tokenize3(X,Y) ).

tokenize3([],[]).
tokenize3([32|T],O):-!,tokenize3(T,O),!.
tokenize3(CharList,[Token|TList])  :- 
  append(_,[C|List],CharList), C \= 32,!,
  get_token([C|List],Token,Rest),!,
  tokenize3(Rest,TList),!.

get_token(List,Token,Rest)  :- 
  get_chars_type(List,Lchars,Rest,Type),!,
  type_codes(Type,Lchars,Token),!.

type_codes(num,CODES,Num):-catch(number_codes(Num,CODES),_,fail),!.
type_codes(_,[34|Lchars],string(S)):-!,atom_codes(S,[34|Lchars]).
type_codes(_,Lchars,Token):-!,atom_codes(Token,Lchars).

get_chars_type(L,S,L1,sep)  :-  separator(L,S,L1),!.
get_chars_type([C|L],[C|Lc],L1,S)  :- 
  check_start(S,C),
  get_word_chars(S,L,Lc,L1).

get_word_chars(S,L,Lc,L1)  :- 
  check_end(S,L,Lc,L1).
get_word_chars(S,[C|L],[C|Lc],L1)  :- 
  legal_char(S,C),
  get_word_chars(S,L,Lc,L1).

legal_char(num,C)    :-  digit(C).
legal_char(quote,C)  :-  not(bracket(_,C,_)).
legal_char(symb,C)   :-  valid_char(C).

check_start(Name,S):-bracket(Name,S,_E).
check_start(num, C)   :-  start_digit(C).
check_start(symb,C)   :- valid_char(C). %, 'not'(digit(C)).

check_end(_,[],[],[])  :-  !.
check_end(num, [C|L],[],[C|L])  :-  'not'(digit(C)),!.
check_end(Name,[E|L],[E],L)  :-  bracket(Name,S,E),!.
%check_end(symb,[C1,C2|L],[],[C1,C2|L])  :-  member([C1,C2],["Fn"]),!.
check_end(symb,[C|L],[],[C|L])  :-  'not'(valid_char(C)).

separator([C,D,E,F|L],[C,D,E],L)  :-member([C,D,E,F],["SKF-"]),!.
separator([C,D,E|L],[C,D,E],L)  :-member([C,D,E],["<=>","=:=","=\=","\==","@@=<","@@>=","=..","-->","SKF"]),!.
separator([C,D|L],[C,D],L)  :-member([C,D],["=>",":-","\+","->","\=","==","@@<","@@>","=<",">=","#$","//","??"]),!. %,"Fn"
separator([C|L],[C],L)  :- member(C,"*,():[];= < >^{}?%$#/"),!.

valid_char(C)  :-  letter(C); digit(C); C = 95 ; C=45 ; C=39.
letter(C)  :-   C=45 ; (97 =< C, C =< 122) ; (65 =< C, C =< 90) ; C = 95 .
start_digit(C)   :- member(C,"-01234567890").
digit(C)   :- member(C,"-.01234567890+eE").

%get_word([C|T],C,T)  :-  member(C,":,.?&%"),!. % ( : , . ?)
get_word([C|T],[C],T)  :- member(C,"=&"),!. % (=)
get_word([C,C1|T],[C,C1],T)  :- member([C,C1],["??"]),!. %"Fn",
get_word([C|T],[C|W],T2)  :-  bracket(_,C,C1),!,get_chars(0,C1,T,W,T2).
get_word([C|T],[C|W],T2)  :-  valid_start(C),!, get_chars(1,32,T,W,T2).

get_chars(K,C1,[C|T],[C|W],T2)  :-  valid_char(K,C,C1),!,get_chars(K,C1,T,W,T2).
get_chars(0,C,[C|T],[],T)  :- bracket(_,C,_), !.
get_chars(0,C,[C|T],[C],T)  :-  (C = 41; C = 93),!. % ) or ]
get_chars(1,_C1,[C|T],[],[C|T])  :-  member(C, [10,13|"=:,?"]).
%get_chars(2,_C1,[C,C2|T],[],[C,C2|T])  :-  member([C,C2], ["Fn"]).

valid_start(C)  :-  valid(C). %; C = 37.  % (%)
valid_char(K,C,C1)  :-  K = 0,!, C \= C1; K = 1, valid(C).

%bracket(quote,39,39).  % single quotes
bracket(quote,34,34).  % double quotes
%bracket(list,91,93).  % square brackets []
%bracket(quote,37,37).  % Literal Percent %%
%bracket(quote,35,35).  % Literal Percent ##

quote_found(0,B,B)  :-  member(B,[34]),!.
quote_found(Q,Q,0).

var_found(0,B,C)  :-  'not'(valid(B)),var_start(C).

var_start(C)  :-  (65 =< C,C =< 90);C = 95;C = 39.
valid(C)  :-   (65 =< C, C =< 90);    % A - Z
             (97 =< C, C =< 122);   % a - z
             (48 =< C, C =< 57);    % 0 - 9
             C = 95; C = 39;C = 45.  % underscore; hyphen



/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm([a,b],Pterm).
Pterm = a(b)

| ?- sterm_to_pterm([a,[b]],Pterm).    %Note:  This is a special Case
Pterm = a(b)

| ?- sterm_to_pterm([holds,X,Y,Z],Pterm).    %This allows Hilog terms to be Converted
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm([X,Y,Z],Pterm).   %But still works in normal places
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm(['AssignmentFn',X,[Y,Z]],Pterm).                                
Pterm = 'AssignmentFn'(_h84,[_h102,_h116])
====================================================================*/

sterm_to_pterm(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm([X],Y):-!,nonvar(X),sterm_to_pterm(X,Y).

sterm_to_pterm([S|TERM],PTERM):-isSlot(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-number(S),!,
            sterm_to_pterm_list([S|TERM],PTERM).            
	    
sterm_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-!,  atomic(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm(VAR,VAR):-!.

sterm_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_list([],[]):-!.
sterm_to_pterm_list([S|STERM],[P|PTERM]):-!,
              sterm_to_pterm(S,P),
              sterm_to_pterm_list(STERM,PTERM).
sterm_to_pterm_list(VAR,[VAR]).
                                                                
@


1.3
log
@Improved performance of reader and took away Stack overflow that happens in large queries
cycQuery('#$isa'(X,'#$Dog')).
@
text
@d7 2
a8 2
% Revision:  $Revision: 1.2 $
% Revised At:   $Date: 2002/06/05 08:55:10 $
d167 11
d219 1
a219 1
      ((PCode=35,finishCycConnection(SocketId,OutStream,InStream),!,fail);true), % 35 is No
@


1.2
log
@Socket server now working..

try running
?- cycQuery(isa(X,'Dog')).
@
text
@d5 1
a5 1
% Contact: $Author$@@users.sourceforge.net ;
d7 2
a8 2
% Revision:  $Revision: 1.6 $
% Revised At:   $Date: 2002/03/29 22:43:17 $
d19 2
a20 1
:-dynamic(cycConnection/4).
d24 3
a26 3
cycConnection(SocketId,OutStream,InStream):-
      thread_self(Self),
      cycConnection(Self,SocketId,OutStream,InStream),!.
d28 1
a28 8

establishConnection:-cycConnection(_,_,_),!.
establishConnection:-
      thread_self(Self),
      cycConnection(SomeOne,SocketId,_,_),
      not(cycMutex(SomeOne,SocketId)),!.

establishConnection:-
d32 10
a41 4
      thread_self(Self),
      %format(user_error,'Connected to Cyc TCP Server {~w,~w}\n',[InStream,OutStream]),
      flush_output(user_error),
      assert(cycConnection(Self,SocketId,OutStream,InStream)),!.
d43 3
a46 5
discontinueConnection:-
      thread_self(Self),
      retract(cycConnection(Self,SocketId,OutStream,InStream)),
      tcp_close_socket(SocketId),!.
discontinueConnection:-!.
d67 5
a71 2
      printSubL(Send),
      readSubL([A,B,C,D|Receive]),!,
d79 1
a79 4


printSubL(Send):-
      establishConnection,
d83 2
a84 2
	    formatCyc('~s~n',[Send]);
            atom(Send) -> formatCyc('~w~n',[Send]);
d86 3
a88 2
      	       (toCycApiExpression(Send,[],STerm),formatCyc('~w~n',[STerm]));
	       throw(cyc_error('SubL message type not supported',Send)).
d90 2
a91 2
formatCyc(Format,Args):-
      cycConnection(_SocketId,OutStream,_InStream),!,
d96 2
a97 3
readSubL(Receive):-
      cycConnection(SocketId,OutStream,InStream),!,
      read_line_with_nl(InStream, Receive),!.
d111 1
d124 3
a135 3
toCycApiExpression([P|List],Vars,Chars):-
			toCycApiExpression_l([P|List],Vars,Term),
			sformat(Chars,'\'(~w)',[Term]).
d161 2
a162 1
      cyclify(CycL,CycLGood),
d170 1
d176 20
a195 1
      cycReset,
d198 5
a202 2
      printSubL('CYC-QUERY'(quote(CycLGood),MtGood)),
      cycConnection(SocketId,OutStream,InStream),!,
d204 13
a216 2
      iterateResult(InStream,Result),
      syncCycLVars(Result,Vars).
d220 1
a221 3
iterateResult(InStream,Result):-
      getResult(InStream,RS,OVars),
      member(Result,RS).
a223 7
getResult(InStream,RS,Vars):-
      read_line_with_nl(InStream, [A,B,C,D|Result]),!,
      getCleanCharsWhitespaceProper3(Result,ResultO),
      %writeq(ResultO),nl,
      getSurfaceFromChars(ResultO,Out,Vars),!,
      Out=[RS],!.

d230 1
a230 1
cyclify([H|T],Term):-integer(H) -> Term=[H|T];cyclify_l([H|T],Term).
d251 29
a290 15





logOnFailure(assert(X,Y)):- catch(assert(X,Y),_,Y=0),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
%logOnFailure(X):-catch(X,E,true),!.
logOnFailure(X):-catch(X,E,(writeFailureLog(E,X),!,catch((true,X),_,fail))),!.
logOnFailure(X):- writeFailureLog('Predicate Failed',X),!.

% TODO make reader more robust


d300 4
a303 2
readCycL(CHARS)  :-       !,
         readCycL(user_input,CHARS).
d307 2
a308 2
readCycL(Stream,CHARS)  :-
		cyclReadStatePopParens,!,
d311 1
a311 93
		once(readCycLChars_p0(Stream,CHARS)),!.

readCycL_priv(Stream,[])  :-at_end_of_stream(Stream).     
readCycL_priv(Stream,CHARS)  :-  
		cyclReadStatePopParens,!,
		unset_g(reading_in_comment),
		unset_g(reading_in_string),!, %true,
		call_with_depth_limit(readCycLChars_p0_priv(Stream,CHARS),40000,_),!.

readCycLChars_p0_priv(Stream,[]):-at_end_of_stream(Stream),!.
readCycLChars_p0_priv(Stream,[Char|Chars]):- !,
        logOnFailure(peekCycLCharCode(Stream,C)),!,
	logOnFailure(term_to_atom(C,CS)),
	logOnFailure(cyclUpdateReadState(CS)),!,
	(readCycLChars_next(C,Char,Stream,Chars)),!.
	
%peekCycLCharCode(Stream,10):-at_end_of_stream(Stream),!,dw('[at_end_of_stream]').
peekCycLCharCode(Stream,10):-peek_byte(Stream,13),!,skipCycLChar(Stream),dw('[ln]'),!.
peekCycLCharCode(Stream,10):-peek_byte(Stream,10),!,skipCycLChar(Stream),dw('[ln]'),!.
peekCycLCharCode(Stream,46):-peek_byte(Stream,46),!,skipCycLChar(Stream),dw('[dot]'),!.
peekCycLCharCode(Stream,32):-peek_byte(Stream,C),C < 32,!,skipCycLChar(Stream),dw('[ctl]'),!.
peekCycLCharCode(Stream,C):-peek_byte(Stream,38),!,skipCycLChar(Stream),dw('[skipping]'),peekCycLCharCode(Stream,C),!.
peekCycLCharCode(Stream,C):-peek_byte(Stream,46),!,skipCycLChar(Stream),dw('[skip-dot]'),peekCycLCharCode(Stream,C),!.
peekCycLCharCode(Stream,C):-peek_byte(Stream,37),!,skipCycLChar(Stream),dw('[skipping]'),peekCycLCharCode(Stream,C),!.
peekCycLCharCode(Stream,C):-peek_byte(Stream,C),skipCycLChar(Stream),!. %,put(C),!.
peekCycLCharCode(Stream,C):-peek_byte(Stream,C),flush,dw('[peekCycLCharCode]'),sleep(2),!,peekCycLCharCode(Stream,C),!.

readCycLChars_next(C,C,Stream,Chars):-if_g(reading_in_string),readCycLChars_p0_priv(Stream,Chars),!.
readCycLChars_next(10,10,Stream,[]):-if_g(reading_in_comment),!.
readCycLChars_next(13,10,Stream,[]):-if_g(reading_in_comment),!.
readCycLChars_next(C,C,Stream,Chars):-if_g(reading_in_comment),readCycLChars_p0_priv(Stream,Chars),!.
readCycLChars_next(41,41,Stream,[]):-flag('bracket_depth',X,X),(X=0),!.
readCycLChars_next(C,Char,Stream,Chars):-once(cyclAsciiRemap(C,Char)),!,readCycLChars_p0_priv(Stream,Chars),!.
readCycLChars_next(C,Char,Stream,Chars):-dw(errror).

set_g(F):-!,flag(F,_,2),!.
unset_g(F):-!,flag(F,_,1),!.
if_g(F):-!,flag(F,X,X),not(X=1),!.

%end_char(41,41)  :-   moo_console_bracket_depth(D),D<1,!. 

cyclUpdateReadState('46'):-dw('[dotp]'),!.
cyclUpdateReadState('32'):-!.
cyclUpdateReadState(_):- if_g(reading_in_comment),dw('[;]'),!.
cyclUpdateReadState('34'):-!,
		(if_g(reading_in_string) -> (dw('[strout]'),unset_g(reading_in_string));(set_g(reading_in_string),!,dw('[strin]'))),!.
cyclUpdateReadState('46'):-if_g(reading_in_string),dw('='),!.
cyclUpdateReadState(_):-if_g(reading_in_string),dw('='),!.
cyclUpdateReadState('59'):- set_g(reading_in_comment),dw('[commentStart]'),!.

cyclUpdateReadState('40'):-!,logOnFailure(flag('bracket_depth',N,N)),dw(n(N)),logOnFailure(flag('bracket_depth',N,N + 1)),logOnFailure((V is N +1)),logOnFailure(dw([brackin:V])),!.
cyclUpdateReadState('41'):-!,flag('bracket_depth',N,N - 1),dw([brackout:N]),!.
cyclUpdateReadState(_):-!. %dw('-'),!.

:-dynamic(bd/1).

%bdInc:-

dw(W):-flush_output,!. %write(W),flush. %,flush(user_error).

cyclReadStatePopParens:-flag('bracket_depth',_,0),!,dw(newbd).

skipCycLChar(Stream):- at_end_of_stream(Stream),!.
skipCycLChar(Stream):- logOnFailure(get_char(Stream,_)),!.
/*
		stream_property(Stream,position('$stream_position'(PCharIndex, PLineNo, PLinePos))),
		NCharIndex is PCharIndex +1,
		seek(Stream,NCharIndex, bof, CharIndex),
		ignore(check_same(NCharIndex,CharIndex)).
*/

check_same(NCharIndex,CharIndex):-NCharIndex == CharIndex,!.
check_same(NCharIndex,CharIndex):-dw('!@@#$%@@#!@@'),dw((NCharIndex,CharIndex)).


getSurfaceFromChars_d(Chars,WFFOut,VARSOut):- 
    retractall(var_counter(_)),retractall(numbered_var(_,_,_)),asserta(var_counter(0)), 
               (getCycLTokens(Chars,Tokens) -> true ; (sendNote(user,cyclParser,'Syntax Error (or I need more work)',Chars),sleep(2),fail)),
               logOnFailure(clean_sexpression(Tokens,WFFClean)),
               logOnFailure(phrase(expr(WFF),WFFClean)),
               collect_temp_vars(VARS),
              !, ( 
                     (VARS=[],VARSOut=_,WFFOut=WFF)
               ;
                     (
                     unnumbervars(VARS,LIST),
                     cyclVarNums(LIST,WFF,WFFOut,VARSOut2) ,
                     list_to_set(VARSOut2,VARSOut1),
                     open_list(VARSOut1,VARSOut)
                     ) 
               ).

            
d315 3
a317 2
        get_code(Stream,C),!,
	cyclReadStateChange(C),!,readCycLChars_p1(C,Char,Stream,Chars),!.
d319 1
d321 1
a321 8
readCycLChars_p1(C,Char,Stream,Chars):-once(cyclAsciiRemap(C,Char)),!,readCycLChars_p0(Stream,Chars),!.



isCycLTerminationStateChar(10,32)  :-reading_in_comment,!.
isCycLTerminationStateChar(13,32)  :-reading_in_comment,!.
isCycLTerminationStateChar(41,41)   :-  flag('bracket_depth',X,X),!,(X=0),!.
%isCycLTerminationStateChar(41,41)  :-   moo_console_bracket_depth(D),D<1,!. 
d323 3
d328 2
a329 3
cyclReadStateChange(34):-retract(reading_in_string),!.
cyclReadStateChange(34):-assert(reading_in_string),!.
cyclReadStateChange(_):-reading_in_string,!.
a330 1

d335 1
a335 3
%cyclAsciiRemap(X,Y):-(catch(cyclAsciiRemap0(X,Y),_,fail)),!.

cyclAsciiRemap(X,X).
d337 1
a337 1
cyclAsciiRemap(N,32):-not(number(N)).
a342 85
isCodesWhite([]).
isCodesWhite([T|W]):-member(T,[32,10,13]),isCodesWhite(W).


% :-include('moo_header.pl').

% TODO Need support for
/*
Predicate AFTER

% 3037 (pnx_nf (FORWARD (arg1Isa hasMembers Organization)) GlobalContext T-3015) 
surface(DynStat,'clause-form'(arg1Isa(hasMembers,'Organization')),'BaseIContext','GlobalContext','T-3015',_h75135). 
clf(arg1Isa(hasMembers,'Organization'),true,'BaseIContext','GlobalContext','T-3015',3110).

)
% ===================================================================
% EXPORTS
% ===================================================================
 */
 
ssleep(_).       
                  
source_from_stream(Stream,[],surf,Vars):-at_end_of_stream(Stream),!.
source_from_stream(Stream,Trimed,Surface,Vars):-
		logOnFailure(once(readCycL_priv(Stream,RRAW))), %writeFmt('~s\n',[RRAW]),
		once(after_readCycL(Stream,RRAW,Trimed,Surface,Vars)),!.
source_from_stream(Stream,Trimed,Surface,Vars):-line_count(Stream,Line),writeFmt(user_error,'\nLine ~w  Unreadable CycL (source_from_stream) \n',[Line]),ssleep(2),!.

after_readCycL(Stream,RRAW,L_trimmed,Surface,Vars):-
			logOnFailure(getCleanCharsWhitespaceProper(RRAW,Trimed)),
			(once(ltrim(Trimed,L_trimmed))),
			source_from_clean_chars(Stream,L_trimmed,Surface,Vars).

after_readCycL(Stream,RRAW,Trimed,surf,Vars):- line_count(Stream,Line),writeFmt('\nLine ~w  Unreadable CycL: ~s (after_readCycL) \n',[Trimed,RRAW]),ssleep(2),!.

source_from_chars(RRAW,Surface,Vars):-
			source_from_chars(user_input,RRAW,Surface,Vars).

source_from_chars(Stream,RRAW,Surface,Vars):-
			logOnFailure(once(getCleanCharsWhitespaceProper(RRAW,Trimed))),
			logOnFailure(once(ltrim(Trimed,L_trimmed))),
			source_from_clean_chars(Stream,L_trimmed,Surface,Vars).
       
source_from_clean_chars(Stream,"var in stream",surf,Vars):-!,line_count(Stream,Line),writeFmt('\nLine ~w  Var in Stream CycL " \n',[Line]),ssleep(2),!.
source_from_clean_chars(Stream,[40|REST],Surface,Vars):-
				once(getSurfaceFromChars([40|REST],CycLSTERM,Vars)),
				once(source_from_sterm(Stream,CycLSTERM,Surface,Vars)),!.

source_from_clean_chars(Stream,[59|REST],file_comment(Atom),Vars):-!,string_to_atom([59|REST],Atom).% ignore(catch(fmtString(CMT,'~s',[59|REST]),_,fmtString(CMT,'~w',[59|REST]))).

source_from_clean_chars(Stream,[],surf,Vars).
source_from_clean_chars(Stream,[10],surf,Vars).
source_from_clean_chars(Stream,[13],surf,Vars).
source_from_clean_chars(Stream,Trimed,file_comment(nil),Vars):-!,line_count(Stream,Line),ignore(catch(writeFmt('\nLine ~w  Unreadable CycL "~s"\n',[Line,Trimed]),_,true)),ssleep(2),!.


source_from_sterm(Stream,CycLSTERM,Surface,Vars):-
			getMooTermFromSurface(CycLSTERM,Surface).

source_from_sterm(Stream,CycLSTERM,Surface,Vars):-(line_count(Stream,Line),writeFmt('\nLine ~w  Uninterpretable "~q" (~q)\n',[Line,CycLSTERM,cycl])),ssleep(2).

/*

Purpose:                                                         
  
Transliterator to get CycL-like KR turned into a more expressive ground form sometimes using only syntax rules

Used by moo_server

% These predicates are used by moo_useragent.P and moo_operation.P

:-export 
      pterm_to_sterm/2, 
      sterm_to_pterm/2,
      conv_to_sterm/3,
      conv_to_pterm/3,
      conv_full_trans_request/3,
      conv_full_trans_generic/3,
      conv_full_trans_assert/3,
      getSurfaceFromChars/3.

  In ISO modules cannot use DCGs
*/

                           
d344 1
a344 1
% EXPORTS
a345 473
                         
/*

:-export readCycL/1.
:-export readCycL/2.

:-export conv_readS/3.
:-export conv_readP/3.
:-export conv_readS/4.
:-export conv_readP/4.
:-export e_o_f/1.
:-export conv_file_line_format/6.

  */                         
                           
% ===================================================================
% IMPORTS
% ===================================================================

                                                         
:-assert(re_entry(conv_kr_rule_assert)).

cycl_to_xml(CycL,ML):-
         tell_retract_parse_chars(CycL,X,V),
         toMarkUp(leml,X,V,ML).


% =====================================================================================
%  tell_retract_parse_chars(Chars,FORM,Vars) and  ask_parse_chars(Chars,FORM,Vars)
%  Both Return FORM='nil' if not well formed
% =====================================================================================

tell_retract_parse_chars(Chars,FORM,Vars):-
         logOnFailure(getCleanCharsWhitespaceProper(Chars,Show)),!,
         once(getSurfaceFromChars(Show,STERM,Vars)),!,
         getMooTermFromSurface(STERM,NEWFORM),!,  
              once(( 
                    NEWFORM=browser_only(browser_only(comment(end_of_file))) -> 
                           ((
                             catch(fmtString(What,'~s',[Show]),_,What='Unreadable'),!,
                             sendNote(user,cyclParser,'Assertion/Retraction Syntax error: Unmatched parentheses',['"',What,'"',nl,helplink('Syntactical Well Formedness','syntax.html')]),
                             FORM=nil 
                             ))
                                 ;
                           (!,FORM=NEWFORM)
                     )).


ask_parse_chars(Chars,FORM,Vars):-
         logOnFailure(getCleanCharsWhitespaceProper(Chars,Show)),!,
         once(getSurfaceFromChars(Show,STERM,Vars)),!,
         getMooTermFromSurface(STERM,NEWFORM),!,
              once(( 
                    NEWFORM=browser_only(browser_only(comment(end_of_file))) -> 
                           ((
                             catch(fmtString(What,'~s',[Show]),_,What='Unreadable'),!,
                             sendNote(user,cyclParser,'Request Syntax error: Unmatched parentheses',['"',What,'"',nl,helplink('Syntactical Well Formedness','syntax.html')]),
                             FORM=nil 
                             ))
                                 ;
                           (!,FORM=NEWFORM)
                     )).


/*===================================================================
Convert Prolog Term to S-Expression

Recursively Applies the Univ Op to create an easier to compile prolog writeFmt
                                                 
Examples:

| ?- pterm_to_sterm((G(X,Y):-A(X,Y)),Sterm).
Sterm = [:-,[_h76,_h90,_h104],[_h122,_h90,_h104]]

| ?- pterm_to_sterm(t,Sterm).
Sterm = [t]

| ?- pterm_to_sterm(t(a),Sterm).
Sterm = [t,[a]]

| ?- pterm_to_sterm(and(a,b),Sterm).
Sterm = [and,[a],[b]]

====================================================================*/
%pterm_to_sterm(X,X):-!,writeq(pterm_to_sterm(X,X)).


pterm_to_sterm(VAR,VAR):-isSlot(VAR),!.
pterm_to_sterm([],['AssignmentFn','Set',[]]):-!.
pterm_to_sterm(ATOM,[ATOM]):-atomic(ATOM),!.
pterm_to_sterm(PTERM,STERM):-compound(PTERM),
            PTERM=..[holds,P|PARGS],         !,
            pterm_to_sterm_list(PARGS,SARGS),
            STERM=[P|SARGS].
pterm_to_sterm(PTERM,STERM):-compound(PTERM),!,
            PTERM=..[P|PARGS],
            pterm_to_sterm_list(PARGS,SARGS),
            STERM=[P|SARGS].

pterm_to_sterm_list([],[]):-!.
pterm_to_sterm_list([P|PTERM],[S|STERM]):-!,
              pterm_to_sterm(P,S),
              pterm_to_sterm_list(PTERM,STERM).

/*===================================================================
Convert Prolog Term to S-Expression

Recursively Applies the Univ Op to create an easier to compile prolog writeFmt
                                                 
Examples:

| ?- pterm_to_sterm_native((G(X,Y):-A(X,Y)),Sterm_native).
Sterm_native = [:-,[holds,_h76,_h90,_h104],[holds,_h122,_h90,_h104]]

| ?- pterm_to_sterm_native(t,Sterm_native).
Sterm_native = [t]

| ?- pterm_to_sterm_native(t(a),Sterm_native).
Sterm_native = [t,[a]]

| ?- pterm_to_sterm_native(and(a,b),Sterm_native).
Sterm_native = [and,[a],[b]]

====================================================================*/
%pterm_to_sterm_native(X,X):-!,writeq(pterm_to_sterm_native(X,X)).


pterm_to_sterm_native(VAR,VAR):-isSlot(VAR),!.
pterm_to_sterm_native([],['AssignmentFn','Set',[]]):-!.
pterm_to_sterm_native(ATOM,[ATOM]):-atomic(ATOM),!.
pterm_to_sterm_native(PTERM,STERM_NATIVE):-compound(PTERM),!,
            PTERM=..[P|PARGS],
            pterm_to_sterm_native_list(PARGS,SARGS),
            STERM_NATIVE=[P|SARGS].

pterm_to_sterm_native_list([],[]):-!.
pterm_to_sterm_native_list([P|PTERM],[S|STERM_NATIVE]):-!,
              pterm_to_sterm_native(P,S),
              pterm_to_sterm_native_list(PTERM,STERM_NATIVE).

/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm([a,b],Pterm).
Pterm = a(b)

| ?- sterm_to_pterm([a,[b]],Pterm).    %Note:  This is a special Case
Pterm = a(b)

| ?- sterm_to_pterm([holds,X,Y,Z],Pterm).    %This allows Hilog terms to be Converted
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm([X,Y,Z],Pterm).   %But still works in normal places
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm(['AssignmentFn',X,[Y,Z]],Pterm).                                
Pterm = 'AssignmentFn'(_h84,[_h102,_h116])
====================================================================*/

sterm_to_pterm(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm([X],Y):-!,nonvar(X),sterm_to_pterm(X,Y).

sterm_to_pterm([S|TERM],PTERM):-isSlot(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-number(S),!,
            sterm_to_pterm_list([S|TERM],PTERM).            
	    
sterm_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-!,  atomic(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm(VAR,VAR):-!.

sterm_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_list([],[]):-!.
sterm_to_pterm_list([S|STERM],[P|PTERM]):-!,
              sterm_to_pterm(S,P),
              sterm_to_pterm_list(STERM,PTERM).
sterm_to_pterm_list(VAR,[VAR]).

/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm_native([a,b],Pterm_native).
Pterm_native = a(b)

| ?- sterm_to_pterm_native([a,[b]],Pterm_native).    %Note:  This is a special Case
Pterm_native = a(b)

| ?- sterm_to_pterm_native([holds,X,Y,Z],Pterm_native).    %This allows Hilog terms to be Converted
Pterm_native = _h76(_h90,_h104)                    

| ?- sterm_to_pterm_native([X,Y,Z],Pterm_native).   %But still works in normal places
Pterm_native = _h76(_h90,_h104)                    

| ?- sterm_to_pterm_native(['AssignmentFn',X,[Y,Z]],Pterm_native).                                
Pterm_native = 'AssignmentFn'(_h84,[_h102,_h116])
====================================================================*/

sterm_to_pterm_native(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_native([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm_native([X],Y):-!,nonvar(X),sterm_to_pterm_native(X,Y).
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-isSlot(S),
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[holds,S|PLIST].
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-number(S),!,
            sterm_to_pterm_native_list([S|TERM],PTERM_NATIVE).            
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-nonvar(S),atomic(S),!,
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[S|PLIST].
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-!,  atomic(S),
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[holds,S|PLIST].
sterm_to_pterm_native(VAR,VAR):-!.

sterm_to_pterm_native_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_native_list([],[]):-!.
sterm_to_pterm_native_list([S|STERM],[P|PTERM_NATIVE]):-!,
              sterm_to_pterm_native(S,P),
              sterm_to_pterm_native_list(STERM,PTERM_NATIVE).
sterm_to_pterm_native_list(VAR,[VAR]).

% [and,A,B]                           lc(pos,and(A,B))                     A equal B
% [not,[and,A,B]]                   lc(neg,and(A,B))                  ~ A equal B
% [or,A,B]                             lc(pos,or(A,B))                        A v B
% ['relation-const',V,B]            lc(pos,pc(pos,'relation-const',[V,B]))          relation-const(V,B)
% [thereExists,V,['relation-const',V,B]]        lc(pos,exists(1,V,pc(pos,'relation-const',[V,B])))          ex V:  r(V,B)
% [forall,V,[not,['relation-const',V,B]]]          lc(pos,univ(forall,V,pc(neg,'relation-const',[V,B])))               ex V:  ~r(V,B)
% ['AssignmentFn',A,[B]]                         'AssignmentFn'(A,[B])
% Fido   ->                            'AssignmentFn'(_,['Fido'])
% [+,1,1] ->                          comp(+(1,1))
% [list,1,2] ->                        varparams([1,2])


% lc -> or clause
% lc -> and clause
% lc -> predicate constant clause
% lc -> exists clause
% lc -> univ clause
% lc -> => clause
% lc -> <=> clause
                                        
         
% ========================================================
%          Atom Transliteration
% ========================================================




% Prolog Declarations
'surface-instance'((':-'),'ImplicationConnective',_).
'surface-instance'((','),'ConjunctionalConnective',_).
'surface-instance'((';'),'DisjunctionalConnective',_).
'surface-instance'((':-'),'Connective',_).
'surface-instance'((','),'Connective',_).
'surface-instance'((';'),'Connective',_).
'surface-instance'(('=>'),'ImplicationConnective',_).
'surface-instance'(('and'),'ConjunctionalConnective',_).
'surface-instance'(('or'),'DisjunctionalConnective',_).
'surface-instance'(('=>'),'Connective',_).
'surface-instance'(('and'),'Connective',_).
'surface-instance'(('or'),'Connective',_).

% Brought in from moo_language.[CycL|P]
'surface-instance'(A,B,_):-'surface-instance'(A,B).
'surface-instance'(A,C,_):-'surface-instance'(A,B),'surface-genls'(B,C).
'surface-instance'(A,D,_):-'surface-instance'(A,B),'surface-genls'(B,C),'surface-genls'(C,D).
'surface-instance'(A,E,_):-'surface-instance'(A,B),'surface-genls'(B,C),'surface-genls'(C,D),'surface-genls'(D,E).


% Brought in from moo_language.[CycL|P]
'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C):-'surface-multiple-arity'(Arity2Pred).
'surface-instance'(Arity1Pred,'ArityOnePredicate',_C):-'surface-single-arity'(Arity1Pred).
'surface-instance'(AE,'Quantifier',_):-'surface-quantifier'(AE).
'surface-instance'(findall,'Quantifier',_).


'surface-instance'(and,'ArityTwoPredicate',_C).
'surface-instance'(or,'ArityTwoPredicate',_C).
'surface-instance'('<=>','ArityTwoPredicate',_C).
'surface-instance'('=>','ArityTwoPredicate',_C).
         
% ========================================================
%           Generic Transliteration
% ========================================================

conv_kr_rule_generic(V,V):- isSlot(V),!.


conv_kr_rule_generic(IN,Out):- conv_pred(IN,Out),!.
conv_kr_rule_generic(G,G).

conv_kr_re_entry(IN,Out):-conv_pred(IN,Out),!.

% ========================================================
%           Common Transliteration  Expects S-Expression
% ========================================================

conv_pred(V,V):- isSlot(V),!.
conv_pred([],[]).
conv_pred([V],[V]):- isSlot(V),!.
conv_pred( Before, After) :- atom(Before),'surface-word'( Before, After),!.

% Variable in the 1st Position
conv_pred([Op|A],[Op|List]):-isSlot(Op),!,conv_pred_list(A,List).


conv_pred([V,A|R],New):- copy_term([V,A|R],Process),	
		       'surface-macro'(Process,_),
		       once((getPrologVars([V,A|R],BV,_,_), 
		       getPrologVars(Process,PV,_,_))),
		       length(PV,X),length(BV,X),!,
		       'surface-macro'([V,A|R],NewTerm),!,
		       conv_kr_re_entry(NewTerm,New).


% Arity2Predicates that have only More then 2 Arguments
conv_pred([Arity2Pred,A,B,C|M],List):-   
                              'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C),!,
                                conv_functsymbol_two([Arity2Pred,A,B,C|M],MID),!,
                                conv_kr_re_entry(MID,List).

	conv_functsymbol_two([],[]).
	conv_functsymbol_two([Pred,A,B,C|More],List):-!,
		    conv_functsymbol_two([Pred,B,C|More],SEMORE),
		    conv_functsymbol_two([Pred,A,SEMORE],List).
	conv_functsymbol_two([_Pred,_A,_B],[_Pred,_A,_B]):-!.
	conv_functsymbol_two([_Pred,_A],_A):-!.


% Arity2Predicates that have only one Argument (Are squashed)
conv_pred([Arity2Pred,MID],List):-   
                              'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C),!,
                                conv_kr_re_entry(MID,List).

% multiple arity not/not
conv_pred([Arity1Pred,A,B|More],List):-  
	    'surface-instance'(Arity1Pred,'ArityOnePredicate',_C),!,
            conv_kr_re_entry([Arity1Pred,B|More],BEMORE),
            conv_kr_re_entry([and,[Arity1Pred,A],BEMORE],List).

% Arity1Predicates that are logical connectives
conv_pred([Arity1Pred,A],[Arity1Pred,List]):- 'surface-instance'(Arity1Pred,'Connective',_C),!,
              conv_kr_re_entry(A,List).


% ========================================================
% Agregation Predicates
% ========================================================
%conv_kr_re_entry([Agregation,Entity,[=>,Ant,Con]],Formula):-nonvar(Agregation),member(Agregation,[forall,forall,for_all,forall]),conv_kr_re_entry([=>,[and,exists(Entity),Ant],Con],Formula).

% Single Entity Exists  %[exists,[list],tr]                                           
conv_pred([AE,[Entity,Collection],FormulaA],Result):- ('surface-instance'(AE,'ExistentualQuantifier',_)),
	conv_kr_re_entry(AE,AO),
            isSlot(Entity),nonvar(Collection),!,conv_kr_re_entry(FormulaA,FormulaAO),
            conv_kr_re_entry(['and',[instance,Entity,Collection],FormulaAO],FormulaB),
            conv_kr_re_entry([AO,Entity,FormulaB],Result).

conv_pred([AE,[Entity,Collection],FormulaA],Result):- ('surface-instance'(AE,'UniversalQuantifier',_)),
            isSlot(Entity),nonvar(Collection),!,conv_kr_re_entry(FormulaA,FormulaAO),
            conv_kr_re_entry(['=>',[instance,Entity,Collection],FormulaAO],Result).

conv_pred([AE,Entity,FormulaA],[AO,Entity,FormulaB]):- ('surface-instance'(AE,'Quantifier',_)),
	conv_kr_re_entry(AE,AO),
            isSlot(Entity),!,
            conv_kr_re_entry(FormulaA,FormulaB).

conv_pred([AE,[],FormulaA],FormulaB):- ('surface-instance'(AE,'Quantifier',_)),!,
            conv_kr_re_entry(FormulaA,FormulaB).

conv_pred([AE,[Struct|More],FormulaA],Result):- ('surface-instance'(AE,'Quantifier',_)),
            !,   conv_kr_re_entry(FormulaA,FormulaAO),  %%%% AO
	conv_kr_re_entry(AE,AO),
            conv_kr_re_entry([AO,Struct,FormulaAO],ResultFormulaA),
            conv_kr_re_entry([AO,More,ResultFormulaA],Result).

%conv_pred([Pred|ARGS],[browser_only,[Pred|ARGS]]):-'browser-only'(Pred),!.

conv_pred([Class,Pred], ['instance',Pred,Class]):-nonvar(Pred),'surface-class'(Class),!.               

conv_pred([A|T],[AO|TO]):-!,conv_pred_list([A|T],[AO|TO]).

conv_pred(A,A):-!.

conv_pred_list(Var,Var):-isSlot(Var),!.
conv_pred_list([],[]):-!.
conv_pred_list([H|T],[HH|TT]):-!,
         conv_kr_re_entry(H,HH),
         conv_pred_list(T,TT).


% ========================================================
% Mine Out Formulas Durring Transliteration
% ========================================================

reduce_arg_nth(_C,_,_,[],[]):-!.
reduce_arg_nth(_C,Pred,N,[ArgS|ArgSS],[ArgSO|ArgSOS]):-!,
            conv_kr_re_entry(ArgS,ArgSO),
            reduce_arg_nth(_C,Pred,NN,ArgSS,ArgSOS).

% Need to be moved to CycL File
cycl_to_pterm_nv_fn([FN,ID,LITS],LITP):-nonvar(ID),ID='Set',cycl_to_pterm_list(LITS,LITP),!.
cycl_to_pterm_nv_fn([FN,ID,LITS],'AssignmentFn'(ID,LITP)):-cycl_to_pterm_list(LITS,LITP),!.
cycl_to_pterm_nv_fn([FN,ID|LITS],LITP):-nonvar(ID),ID='Set',cycl_to_pterm_list(LITS,LITP),!.
cycl_to_pterm_nv_fn([FN,ID|LITS],'AssignmentFn'(ID,LITP)):-cycl_to_pterm_list(LITS,LITP),!.


cycl_to_pterm(VAR,VAR):-isSlot(VAR),!.
cycl_to_pterm([CycL],P):-!,cycl_to_pterm(CycL,P).
cycl_to_pterm('zzskFn'(X),'zzskFn'(X)):-!.
cycl_to_pterm([AS,X,Y],'surface-macro'(X,Y)):-nonvar(AS),AS='surface-macro',!.
%cycl_to_pterm([Fn, Fn, [X|LIST]],'AssignmentFn'(X,PLIST)):-nonvar(Fn),Fn='AssignmentFn',!,cycl_to_pterm_list(LIST,PLIST).
%%cycl_to_pterm([ID,FN|LITS],OUT):-nonvar(FN),FN='AssignmentFn',cycl_to_pterm([FN,ID|LITS],OUT),!.
%cycl_to_pterm([FN,ID|LITS],OUT):-nonvar(FN),FN='AssignmentFn',cycl_to_pterm_nv_fn([FN,ID|LITS],OUT),!.
cycl_to_pterm([X],Y):-!,nonvar(X),cycl_to_pterm(X,Y).
cycl_to_pterm(ATOM,ATOM):-atomic(ATOM),!.

cycl_to_pterm([S|TERM],PTERM):-isSlot(S),
            cycl_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

cycl_to_pterm([holds|TERM],PTERM):-!,
            cycl_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds|PLIST].
	    	    
cycl_to_pterm([S|TERM],PLIST):-nonvar(S),number(S),!,
            cycl_to_pterm_list([S|TERM],PLIST).    
	            
cycl_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            cycl_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].
	    
cycl_to_pterm(VAR,VAR):-!.

cycl_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
cycl_to_pterm_list([],[]):-!.
cycl_to_pterm_list([S|STERM],[P|PTERM]):-!,
              cycl_to_pterm(S,P),
              cycl_to_pterm_list(STERM,PTERM).
	      
cycl_to_pterm_list(VAR,[VAR]).


'surface-argIsa'(salientAssertions,2,'Formula',_Cxt).
'surface-argIsa'(ist,2,'Formula',_Cxt).

'surface-argIsa'(P,1,'Formula',_Cxt):-nonvar(P),'surface-instance'(P,'Connective',_).
'surface-argIsa'(P,2,'Formula',_Cxt):-nonvar(P),'surface-instance'(P,'Connective',_).
'surface-argIsa'(P,N,T,_):-'argIsa'(P,N,T,_Cxt).
'surface-argIsa'(P,N,T,_):-'argIsa'(P,N,T2,_Cxt),'genls'(T,T2,_Cxt).

:-dynamic('argIsa'/4).
:-dynamic('genls'/3).




d376 1
d380 1
a380 1
         logOnFailure(ltrim([CH|ARSIn],CHARS)),!,
d383 1
a383 1
            ([FC]=";",TERM=[comment,end_of_file], VARS= _ ) ;   %Comment Char found in Line
d386 1
a386 1
            (FC=40,getSurfaceFromChars_2(CHARS,TERM,VARS) ,! )    %Use vanila CycL parser
d388 1
a388 1
            ( TERM=[comment,end_of_file],VARS= _,! )     %All above methods of parsing failed.. Convert to comment
d394 1
a394 1
getSurfaceFromChars_2(Chars,WFFOut,VARSOut):- 
d396 5
a400 5
               once(getCycLTokens(Chars,Tokens)), 
               once((clean_sexpression(Tokens,WFFClean))),
               phrase(moo(WFF),WFFClean),
               collect_temp_vars(VARS),
              !, ( 
d409 1
a409 3
               ).

    
d457 1
d460 8
a467 25
ltrim([P|X],Y):-P<33,ltrim(X,Y),!.
ltrim([P|X],Y):-P>128,ltrim(X,Y),!.
ltrim(X,X):-!.

/*===================================================================
%   Open-CycL String to SXpression
% Converts up to 6 Open-CycL Flags into set(Name,Val) pairs
====================================================================*/

termcycl((ISO_Prolog))--> ['(',':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),cycl_flag(_),cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
termcycl((ISO_Prolog))--> ['('],cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),cycl_flag(_),[':','OpenCycL'],moo(ISO_Prolog),[')'].
  
termcycl(ISO_Prolog)--> moo(ISO_Prolog).

flag_list((A,B)) --> cycl_flag(A),flag_list(B).
flag_list(A) --> cycl_flag(A).
flag_list(true) --> [].

cycl_flag('set'(A,V)) -->  [(':'),A,V], { atomical(V) }.
cycl_flag('set'(A,true)) -->  [(':'),A], { atomical(A) }.
d479 2
a480 2
moo([A]) --> expr(A).
moo([and,A|L]) --> expr(A) , moo(L).
a585 35
getCleanCharsWhitespaceProper([],[]):-!.
getCleanCharsWhitespaceProper(X,Z) :- !,logOnFailure(ascii_clean(X,Y)),!,logOnFailure(getCleanCharsWhitespaceProper3(Y,Z)),!.

% Converts not ANSI Chars to whitespace 
ascii_clean([],[]):-!.
ascii_clean([X|String],[Y|Out]) :- transpose_char(X,Y),!,ascii_clean(String,Out).


string_clean(X,X).

transpose_char(10,32).
%transpose_char(32,32).
%transpose_char(X,32):-not(integer(X)),!.
%transpose_char(X,32):-X<33,!.
transpose_char( X , X).
   
% Blocks of Spaces are removed from a Charlist 
getCleanCharsWhitespaceProper3([],[]).
getCleanCharsWhitespaceProper3([10,13],[]).
getCleanCharsWhitespaceProper3([13,10],[]).
getCleanCharsWhitespaceProper3([32],[]).
getCleanCharsWhitespaceProper3([10],[]).
getCleanCharsWhitespaceProper3([13],[]).
getCleanCharsWhitespaceProper3([32,32],[]).
getCleanCharsWhitespaceProper3([32,32,32],[]).
getCleanCharsWhitespaceProper3([X],[X]):-!.
getCleanCharsWhitespaceProper3([32,32,32,32,32,32,32|String],[32|Out]) :-!, getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32,32,32,32|String],[32|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32,32|String],[32|Out]) :-!, getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32|String],[32|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([X|String],[X|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3(X,X):-!.



a680 1
:-assert(show_this_hide(getCleanCharsWhitespaceProper,2)).
d682 2
d685 3
d689 2
d692 2
d695 2
d698 2
a699 104
ltrim([],[]):-!.
ltrim([32,32,32,32,32,32,32|String],Out) :-!, ltrim(String,Out),!.
ltrim([32,32,32,32,32|String],Out) :- !,ltrim(String,Out),!.
ltrim([32,32,32|String],Out) :-!, ltrim(String,Out),!.
ltrim([32,32|String],Out) :- !,ltrim(String,Out),!.
ltrim([32|String],Out) :- !,ltrim(String,Out),!.
ltrim(X,X):-!.



%:-discontiguous(conv_pred/3).
%:-discontiguous(conv_pred/3).


% ====================================================================
% conv_readS/3-4 and conv_readP/3-4 
% ====================================================================

conv_readP(RAW,OUTP,VARS):-
            conv_readS(RAW,NEWTERM,VARS),
            getMooTermFromSurface(NEWTERM,OUTP).

conv_readP(Stream,RAW,OUTP,VARS):-
            conv_readS(Stream,RAW,NEWTERM,VARS),
            getMooTermFromSurface(NEWTERM,OUTP).

chars_to_pterm(Chars,PTerm,Vars):-
         once(getSurfaceFromChars(Chars,STERM,Vars)),!,
         getMooTermFromSurface(STERM,PTerm),!.


getMooTermFromSurface([end_of_file],end_of_file):-!.
getMooTermFromSurface(NEWTERM,OUTP):-
               conv_kr_rule_generic(NEWTERM,NEWTERMATOMS),
	       conv_kr_rule_generic(NEWTERMATOMS,OUT),
               cycl_to_pterm(OUT,OUTP).

conv_readS(RAW,NEWTERM,VARS):-!,
                once(readCycL(RRAW)),
               once(getSurfaceFromChars(RRAW,RTERM,RVARS)),
					 once((
                 (RTERM=nil,!,conv_readS(RAW,NEWTERM,VARS),!)
                 ;(once(getCleanCharsWhitespaceProper(RRAW,RAW)),NEWTERM=RTERM,VARS=RVARS)
                 )).

conv_readS(Stream,RAW,NEWTERM,VARS):-!,
                     once(readCycL(Stream,RRAW)),
                     once(getSurfaceFromChars(RRAW,RTERM,RVARS)),
					 once((
                 (RTERM=nil,!,conv_readS(Stream,RAW,NEWTERM,VARS),!)
                 ;(once(getCleanCharsWhitespaceProper(RRAW,RAW)),NEWTERM=RTERM,VARS=RVARS)
                 )).


% ====================================================================
% Moo File IO
% ====================================================================
      
      

:-dynamic(moo_B_seeing/3).
:-dynamic(moo_BInserting/3).
:-asserta((moo_B_seeing(userin,userin,1))).
:-asserta((moo_BInserting(userin,userin,2))).
/*
moo_B_seen:-moo_B_seeing_console,!.
moo_B_seen:-retract(moo_B_seeing(FileName,LocalFile,_IOPort)),!,file_close(_IOPort).
*/
moo_B_told:-moo_BInserting_console,!.
moo_B_told:-retract(moo_BInserting(FileName,LocalFile,_IOPort)),!,file_close(_IOPort).

/*
moo_B_see(userin):-!.
moo_B_see(FileName):-real_cycl_file_name(FileName,LocalFile),!,moo_file_open(LocalFile,'r',_IOPort),asserta(moo_B_seeing(FileName,LocalFile,_IOPort)).
*/

moo_BInsert(userin):-!.
moo_BInsert(FileName):-real_cycl_file_name(FileName,LocalFile),!,moo_file_open(LocalFile,'w',_IOPort),asserta(moo_BInserting(FileName,LocalFile,_IOPort)).

moo_B_get0(Char):-!,get(Char).
moo_B_get0(Char):-moo_B_seeing(FileName,LocalFile,_IOPort),!,file_get0(_IOPort,Char).
moo_B_get0(Stream,OChar):-!,
            catch(file_get0(Stream,OChar),_,OChar=end_of_file).

moo_B_get(Char):-moo_B_seeing_console,!,get(Char).
moo_B_get(TERM):-moo_B_seeing(_FileName,_LocalFile,IOPort),!,file_get(IOPort,TERM,_).

moo_B_read(TERM):-moo_B_seeing_console,!,read(TERM).
moo_B_read(TERM):-moo_B_seeing(_FileName,_LocalFile,IOPort),!,file_read(IOPort,TERM,_).

moo_B_put(Char):-moo_BInserting_console,!,put(Char).
moo_B_put(Char):-moo_BInserting(FileName,LocalFile,_IOPort),!,put(_IOPort,Char).


moo_B_seeing_console:-moo_B_seeing(FileName,LocalFile,_IOPort),!,LocalFile=userin.
moo_BInserting_console:-moo_BInserting(FileName,LocalFile,_IOPort),!,LocalFile=userin.


moo_file_open(_LocalFile,Mode,_IOPort):-file_open(_LocalFile,Mode,_IOPort),once((valid_handle(_IOPort);((writeIfOption(cb_error,['File Not Found',_LocalFile],_X)),!,abort))).

% file_get0(IOPort,Char)  See Platform Specifics

valid_handle('$stream'(_)):-!.
valid_handle(IOPort):- IOPort > 3,!.
d701 3
d705 3
d709 3
d713 6
d720 3
d724 1
d726 7
@


1.1
log
@Interface to the lowerlevel Cyc operations
@
text
@d2 15
d19 2
a20 3
:-dynamic(cycConnected/1).
:-dynamic(cycOutputStream/1).
:-dynamic(cycInputStream/1).
d23 6
a28 1
establishConnection:-cycConnected(_),!.
d30 170
a199 13
		tcp_socket(SocketId),
		tcp_connect(SocketId,'127.0.0.1':3601),
		tcp_open_socket(SocketId, InStream, OutStream),!,
		format(user_error,'Connected to Cyc TCP Server {~w,~w}\n',[InStream,OutStream]),
		flush_output(user_error),
		assert(cycConnected(SocketId)),
		assert(cycOutputStream(OutStream)),
		assert(cycInputStream(InStream)),
		assert(cycConnected),!.

disConnection:-
      retract(cycConnected(SocketId)),
      close(SocketId),!.
d201 1263
@

