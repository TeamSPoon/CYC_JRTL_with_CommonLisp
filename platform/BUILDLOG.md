````

root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# git add test/for-maven -f
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# git add main/for-maven -f
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# rm -rf dist
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# rm -rf target/
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# mvn compile
[INFO] Scanning for projects...
[INFO]
[INFO] ---------------------------< larkc:platform >---------------------------
[INFO] Building LarKC Platform 0.0.1-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-antrun-plugin:1.7:run (validate.platform) @ platform ---
[INFO] Executing tasks

main:

abcl.init:
     [echo] java.version: 1.8.0_222

abcl.java.warning:

abcl.jsr-223.notice:

abcl.compile.java:
    [mkdir] Created dir: /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes
     [echo] java.home=/usr/lib/jvm/java-8-openjdk-amd64/jre
     [echo] src.dir=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src
     [echo] abcl.classpath.build = /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/all-deps:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/ext/junit-4.12.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/hamcrest-all-1.3.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/junit-4.12.jar
    [javac] Compiling 3222 source files to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes
    [javac] Note: Some input files use or override a deprecated API.
    [javac] Note: Recompile with -Xlint:deprecation for details.
    [javac] Note: Some input files use unchecked or unsafe operations.
    [javac] Note: Recompile with -Xlint:unchecked for details.
    [javac] Creating empty /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/package-info.class
[INFO] Executed tasks
[INFO]
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ platform ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/main/resources
[INFO]
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ platform ---
[INFO] Nothing to compile - all classes are up to date
[INFO]
[INFO] --- maven-antrun-plugin:1.7:run (compile.platform) @ platform ---
[INFO] Executing tasks

main:

abcl.clean.maybe:

abcl.copy.lisp:
     [copy] Copying 204 files to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes

abcl.stage:
     [copy] Copying 11 files to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/COPYING to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/COPYING
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/README to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/README
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/abcl.asd to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/abcl.asd
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/abcl.bat.in to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/abcl.bat.in
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/abcl.in to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/abcl.in
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/abcl.properties.in to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/abcl.properties.in
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/abcl.rdf to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/abcl.rdf
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/build.xml to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/build.xml
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/etc/ant/build-maven.xml to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/etc/ant/build-maven.xml
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/etc/ant/build-snapshot.xml to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/etc/ant/build-snapshot.xml
     [copy] Copying /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/etc/ant/netbeans-build.xml to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/etc/ant/netbeans-build.xml

abcl.init:
     [echo] java.version: 1.8.0_222

abcl.java.warning:

abcl.jsr-223.notice:

abcl.compile.java:
     [echo] java.home=/usr/lib/jvm/java-8-openjdk-amd64/jre
     [echo] src.dir=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src
     [echo] abcl.classpath.build = /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/all-deps:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/ext/junit-4.12.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/hamcrest-all-1.3.jar:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/junit-4.12.jar
    [javac] Compiling 9 source files to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes

abcl.system.uptodate:

abcl.system.update.maybe:

abcl.fasls.uptodate:
     [echo] abcl.fasls.uptodate.p result: ${abcl.fasls.uptodate.p}

abcl.compile.lisp:
     [echo] Compiling Lisp system -Da=b
     [echo] from /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp
     [echo]  to  /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp
     [java] java.system.class.loader=null
     [java] Armed Bear Common Lisp 1.6.0-uabcl (built Thu Sep 26 2019 16:44:10 PDT)
     [java] Java 1.8.0_222 Private Build
     [java] OpenJDK 64-Bit Server VM
     [java] Low-level initialization used 0.056 seconds.
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/autoloads-gen.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/autoloads-gen.lisp (0.061 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/autoloads.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/autoloads.lisp (0.007 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/early-defuns.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/early-defuns.lisp (0.018 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/backquote.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/backquote.lisp (0.012 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/destructuring-bind.lisp ...
     [java] ;  COMMON-LISP:CHAR= triggers autoloading of org.armedbear.lisp.CharacterFunctions ...
     [java] ;   Autoloaded org.armedbear.lisp.CharacterFunctions (0.057 seconds)
     [java] ;  COMMON-LISP:LAST triggers autoloading of org.armedbear.lisp.last ...
     [java] ;   Autoloaded org.armedbear.lisp.last (0.007 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/destructuring-bind.lisp (0.135 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defmacro.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defmacro.lisp (0.008 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/setf.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/setf.lisp (0.021 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/fdefinition.lisp ...
     [java] ;  SYSTEM::%SET-ARGLIST triggers autoloading of org.armedbear.lisp.arglist ...
     [java] ;   Autoloaded org.armedbear.lisp.arglist (0.007 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/fdefinition.lisp (0.015 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/featurep.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/featurep.lisp (0.004 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-conditional.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-conditional.lisp (0.003 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/macros.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/macros.lisp (0.016 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-circle.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-circle.lisp (0.047 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inline.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inline.lisp (0.002 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/proclaim.lisp ...
     [java] ;  COMMON-LISP:MAKE-HASH-TABLE triggers autoloading of make-hash-table ...
     [java] ;   Autoloaded make-hash-table (0.005 seconds)
     [java] ;  SYSTEM::%MAKE-HASH-TABLE triggers autoloading of org.armedbear.lisp.HashTableFunctions ...
     [java] ;   Autoloaded org.armedbear.lisp.HashTableFunctions (0.079 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/proclaim.lisp (0.098 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/arrays.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/arrays.lisp (0.008 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-macro.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-macro.lisp (0.012 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/subtypep.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/subtypep.lisp (0.058 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/typep.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/typep.lisp (0.005 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/signal.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/signal.lisp (0.009 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/list.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/list.lisp (0.041 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/require.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/require.lisp (0.003 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/precompiler.lisp ...
     [java] ;  COMMON-LISP:STRINGP triggers autoloading of org.armedbear.lisp.StringFunctions ...
     [java] ;   Autoloaded org.armedbear.lisp.StringFunctions (0.092 seconds)
     [java] ;  SYSTEM::SET-FUNCTION-INFO-VALUE triggers autoloading of org.armedbear.lisp.function_info ...
     [java] ;   Autoloaded org.armedbear.lisp.function_info (0.01 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/precompiler.lisp (0.207 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/extensible-sequences-base.lisp ...
     [java] ;  COMMON-LISP:ADJOIN triggers autoloading of adjoin ...
     [java] ;    COMMON-LISP:COPY-LIST triggers autoloading of org.armedbear.lisp.copy_list ...
     [java] ;     Autoloaded org.armedbear.lisp.copy_list (0.002 seconds)
     [java] ;   Autoloaded adjoin (0.011 seconds)
     [java] ;  COMMON-LISP:STRING= triggers autoloading of strings ...
     [java] ;   Autoloaded strings (0.076 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/extensible-sequences-base.lisp (0.115 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sequences.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sequences.lisp (0.016 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/error.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/error.lisp (0.002 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defpackage.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defpackage.lisp (0.019 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/define-modify-macro.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/define-modify-macro.lisp (0.029 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defstruct.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defstruct.lisp (0.139 seconds)
     [java] ; COMMON-LISP:CONCATENATE triggers autoloading of concatenate ...
     [java] ;  Autoloaded concatenate (0.007 seconds)
     [java] ; COMMON-LISP:MAKE-STRING triggers autoloading of make-string ...
     [java] ;  Autoloaded make-string (0.004 seconds)
     [java] ; SYSTEM::%MAKE-ARRAY triggers autoloading of org.armedbear.lisp.make_array ...
     [java] ;  Autoloaded org.armedbear.lisp.make_array (0.032 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/restart.lisp ...
     [java] ;  COMMON-LISP:ASSOC triggers autoloading of assoc ...
     [java] ;   Autoloaded assoc (0.036 seconds)
     [java] ;  COMMON-LISP:LDIFF triggers autoloading of ldiff ...
     [java] ;   Autoloaded ldiff (0.004 seconds)
     [java] ;  COMMON-LISP:MAPCAN triggers autoloading of map1 ...
     [java] ;   Autoloaded map1 (0.007 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/restart.lisp (0.172 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/late-setf.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/late-setf.lisp (0.009 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/debug.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/debug.lisp (0.016 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print.lisp (0.036 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint-dispatch.lisp ...
     [java] ;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint.lisp ...
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print-object.lisp ...
     [java] ;      Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/clos.lisp ...
     [java] ;      COMMON-LISP:UNION triggers autoloading of sets ...
     [java] ;       Autoloaded sets (0.035 seconds)
     [java] ;      COMMON-LISP:REMOVE-DUPLICATES triggers autoloading of remove-duplicates ...
     [java] ;       Autoloaded remove-duplicates (0.023 seconds)
     [java] ;      COMMON-LISP:BUTLAST triggers autoloading of butlast ...
     [java] ;       Autoloaded butlast (0.009 seconds)
     [java] ;      SYSTEM::SIMPLE-LIST-REMOVE-DUPLICATES triggers autoloading of org.armedbear.lisp.simple_list_remove_duplicates ...
     [java] ;       Autoloaded org.armedbear.lisp.simple_list_remove_duplicates (0.003 seconds)
     [java] ;      COMMON-LISP:REMOVE-IF triggers autoloading of remove ...
     [java] ;         Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/delete.lisp ...
     [java] ;         Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/delete.lisp (0.094 seconds)
     [java] ;       Autoloaded remove (0.185 seconds)
     [java] ;      COMMON-LISP:DELETE-DUPLICATES triggers autoloading of delete-duplicates ...
     [java] ;       Autoloaded delete-duplicates (0.008 seconds)
     [java] ;      COMMON-LISP:FIND-IF-NOT triggers autoloading of find ...
     [java] ;       Autoloaded find (0.078 seconds)
     [java] ;       Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/loop.lisp ...
     [java] ;       Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/loop.lisp (0.269 seconds)
     [java] ;      COMMON-LISP:REVAPPEND triggers autoloading of revappend ...
     [java] ;       Autoloaded revappend (0.005 seconds)
     [java] ;      SYSTEM:%ALLOCATE-FUNCALLABLE-INSTANCE triggers autoloading of org.armedbear.lisp.FuncallableStandardObject ...
     [java] ;       Autoloaded org.armedbear.lisp.FuncallableStandardObject (0.006 seconds)
     [java] ;      COMMON-LISP:SORT triggers autoloading of sort ...
     [java] ;          Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/collect.lisp ...
     [java] ;          Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/collect.lisp (0.006 seconds)
     [java] ;       Autoloaded sort (0.127 seconds)
     [java] ;       Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/mop.lisp ...
     [java] ;       Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/mop.lisp (0.006 seconds)
     [java] ;      Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/clos.lisp (1.56 seconds)
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print-object.lisp (1.584 seconds)
     [java] ;    COMMON-LISP:LOG triggers autoloading of org.armedbear.lisp.MathFunctions ...
     [java] ;     Autoloaded org.armedbear.lisp.MathFunctions (0.047 seconds)
     [java] ;    COMMON-LISP:COERCE triggers autoloading of coerce ...
     [java] ;     Autoloaded coerce (0.012 seconds)
     [java] ;    SYSTEM::COERCE-TO-DOUBLE-FLOAT triggers autoloading of org.armedbear.lisp.FloatFunctions ...
     [java] ;     Autoloaded org.armedbear.lisp.FloatFunctions (0.064 seconds)
     [java] ;    COMMON-LISP:BYTE triggers autoloading of ldb ...
     [java] ;     Autoloaded ldb (0.008 seconds)
     [java] ;    COMMON-LISP:REDUCE triggers autoloading of reduce ...
     [java] ;     Autoloaded reduce (0.014 seconds)
     [java] ;   COMMON-LISP:PARSE-INTEGER triggers autoloading of parse-integer ...
     [java] ;    Autoloaded parse-integer (0.041 seconds)
     [java] ;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint.lisp (2.664 seconds)
     [java] ;  COMMON-LISP:COUNT-IF triggers autoloading of count ...
     [java] ;   Autoloaded count (0.026 seconds)
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint-dispatch.lisp (2.737 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defsetf.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defsetf.lisp (0.009 seconds)
     [java] ;  Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/package.lisp ...
     [java] ;  Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/package.lisp (0.03 seconds)
     [java] Startup completed in 7.919 seconds.
     [java] ;TOP-LEVEL::TOP-LEVEL-LOOP triggers autoloading of top-level ...
     [java] ;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inspect.lisp ...
     [java] ;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inspect.lisp (0.008 seconds)
     [java] ; Autoloaded top-level (0.047 seconds)
     [java] ; SYSTEM::%SET-LOGICAL-PATHNAME-TRANSLATIONS triggers autoloading of pathnames ...
     [java] ;  Autoloaded pathnames (0.033 seconds)
     [java] ; SYSTEM:CANONICALIZE-LOGICAL-HOST triggers autoloading of org.armedbear.lisp.LogicalPathname ...
     [java] ;  Autoloaded org.armedbear.lisp.LogicalPathname (0.006 seconds)
     [java] showST: java.lang.ClassNotFoundException: CycNER
     [java]     at java.net.URLClassLoader.findClass(URLClassLoader.java:382)
     [java]     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
     [java]     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)
     [java]     at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
     [java]     at java.lang.Class.forName0(Native Method)
     [java]     at java.lang.Class.forName(Class.java:264)
     [java]     at org.logicmoo.system.Startup.registerForiegnMethods(Startup.java:3360)
     [java]     at org.armedbear.lisp.Interpreter.initInstance0(Interpreter.java:242)
     [java]     at org.armedbear.lisp.Interpreter.lambda$initInstance$0(Interpreter.java:190)
     [java]     at org.armedbear.lisp.ABCLStatic.subl_preserve_pkg(ABCLStatic.java:32)
     [java]     at org.armedbear.lisp.Interpreter.initInstance(Interpreter.java:190)
     [java]     at org.armedbear.lisp.Interpreter.ensureInitialized(Interpreter.java:395)
     [java]     at org.armedbear.lisp.Interpreter.init(Interpreter.java:793)
     [java]     at org.armedbear.lisp.Interpreter.createDefaultInstance(Interpreter.java:144)
     [java]     at org.armedbear.lisp.Main.main(Main.java:59)
     [java] Low-level initialization completed in 4.888 seconds.
     [java] ;EXTENSIONS:COMPILE-SYSTEM triggers autoloading of compile-system ...
     [java] ;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compile-file.lisp ...
     [java] ;    Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass2.lisp ...
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-types.lisp ...
     [java] ;     SYSTEM::PARSE-LAMBDA-LIST triggers autoloading of parse-lambda-list ...
     [java] ;      Autoloaded parse-lambda-list (0.011 seconds)
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-types.lisp (0.036 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-functions.lisp ...
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-functions.lisp (0.014 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-symbols.lisp ...
     [java] ;      Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-class-file.lisp ...
     [java] ;      COMMON-LISP:SUBSTITUTE triggers autoloading of substitute ...
     [java] ;       Autoloaded substitute (0.031 seconds)
     [java] ;      COMMON-LISP:COPY-SEQ triggers autoloading of copy-seq ...
     [java] ;       Autoloaded copy-seq (0.01 seconds)
     [java] ;      Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-class-file.lisp (0.298 seconds)
     [java] ;      Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/java.lisp ...
     [java] ;      JAVA::GET-DEFAULT-CLASSLOADER triggers autoloading of org.armedbear.lisp.JavaClassLoader ...
     [java] ;       Autoloaded org.armedbear.lisp.JavaClassLoader (0.021 seconds)
     [java] ;      COMMON-LISP:GET-PROPERTIES triggers autoloading of org.armedbear.lisp.get_properties ...
     [java] ;       Autoloaded org.armedbear.lisp.get_properties (0.002 seconds)
     [java] ;      Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/java.lisp (0.125 seconds)
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-symbols.lisp (0.546 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dump-form.lisp ...
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dump-form.lisp (0.016 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-instructions.lisp ...
     [java] ;      Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-error.lisp ...
     [java] ;      Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-error.lisp (0.021 seconds)
     [java] ;     COMMON-LISP:MAKE-STRING-OUTPUT-STREAM triggers autoloading of make-string-output-stream ...
     [java] ;      Autoloaded make-string-output-stream (0.003 seconds)
     [java] ;     SYSTEM::%MAKE-STRING-OUTPUT-STREAM triggers autoloading of org.armedbear.lisp.StringOutputStream ...
     [java] ;      Autoloaded org.armedbear.lisp.StringOutputStream (0.004 seconds)
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-instructions.lisp (0.107 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm.lisp ...
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm.lisp (0.209 seconds)
     [java] ;     Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass1.lisp ...
     [java] ;     Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass1.lisp (0.112 seconds)
     [java] ;    COMMON-LISP:MAKE-SEQUENCE triggers autoloading of make-sequence ...
     [java] ;     Autoloaded make-sequence (0.007 seconds)
     [java] ;    Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass2.lisp (1.498 seconds)
     [java] ;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compile-file.lisp (1.558 seconds)
     [java] ; Autoloaded compile-system (1.58 seconds)
     [java] ;EXTENSIONS:PROBE-DIRECTORY triggers autoloading of org.armedbear.lisp.probe_file ...
     [java] ; Autoloaded org.armedbear.lisp.probe_file (0.012 seconds)
     [java] ;SYSTEM::%TIME triggers autoloading of org.armedbear.lisp.Time ...
     [java] ; Autoloaded org.armedbear.lisp.Time (0.011 seconds)
     [java] ;COMMON-LISP:LOAD triggers autoloading of load ...
     [java] ; Autoloaded load (0.005 seconds)
     [java] ;COMMON-LISP:FILE-WRITE-DATE triggers autoloading of org.armedbear.lisp.file_write_date ...
     [java] ; Autoloaded org.armedbear.lisp.file_write_date (0.002 seconds)
     [java] ;COMMON-LISP:OPEN triggers autoloading of open ...
     [java] ; Autoloaded open (0.012 seconds)
     [java] ;SYSTEM::MAKE-FILE-STREAM triggers autoloading of org.armedbear.lisp.FileStream ...
     [java] ; Autoloaded org.armedbear.lisp.FileStream (0.023 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defstruct.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO DD-NAME (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (0))))
     [java] ;COMMON-LISP:MOD triggers autoloading of org.armedbear.lisp.mod ...
     [java] ; Autoloaded org.armedbear.lisp.mod (0.002 seconds)
     [java] ;SYSTEM::MAKE-FILL-POINTER-OUTPUT-STREAM triggers autoloading of org.armedbear.lisp.FillPointerOutputStream ...
     [java] ; Autoloaded org.armedbear.lisp.FillPointerOutputStream (0.011 seconds)
     [java] ;COMMON-LISP:LOGIOR triggers autoloading of org.armedbear.lisp.logior ...
     [java] ; Autoloaded org.armedbear.lisp.logior (0.002 seconds)
     [java] ;COMMON-LISP:LOGAND triggers autoloading of org.armedbear.lisp.logand ...
     [java] ; Autoloaded org.armedbear.lisp.logand (0.003 seconds)
     [java] ;SYSTEM::%MAKE-BYTE-ARRAY-OUTPUT-STREAM triggers autoloading of org.armedbear.lisp.ByteArrayOutputStream ...
     [java] ; Autoloaded org.armedbear.lisp.ByteArrayOutputStream (0.012 seconds)
     [java] ;COMMON-LISP:WRITE-SEQUENCE triggers autoloading of write-sequence ...
     [java] ; Autoloaded write-sequence (0.005 seconds)
     [java] ;SYSTEM::EXPAND-DEFTYPE triggers autoloading of deftype ...
     [java] ; Autoloaded deftype (0.007 seconds)
     [java] ;COMMON-LISP:STREAM-ELEMENT-TYPE triggers autoloading of org.armedbear.lisp.stream_element_type ...
     [java] ; Autoloaded org.armedbear.lisp.stream_element_type (0.002 seconds)
     [java] ;COMMON-LISP:FILE-LENGTH triggers autoloading of org.armedbear.lisp.file_length ...
     [java] ; Autoloaded org.armedbear.lisp.file_length (0.002 seconds)
     [java] ; (DEFMACRO DD-CONC-NAME (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (1))))
     [java] ; (DEFMACRO DD-DEFAULT-CONSTRUCTOR (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (2))))
     [java] ; (DEFMACRO DD-CONSTRUCTORS (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (3))))
     [java] ; (DEFMACRO DD-COPIER (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (4))))
     [java] ; (DEFMACRO DD-INCLUDE (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (5))))
     [java] ; (DEFMACRO DD-TYPE (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (6))))
     [java] ; (DEFMACRO DD-NAMED (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (7))))
     [java] ; (DEFMACRO DD-INITIAL-OFFSET (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (8))))
     [java] ; (DEFMACRO DD-PREDICATE (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (9))))
     [java] ; (DEFMACRO DD-PRINT-FUNCTION (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (10))))
     [java] ; (DEFMACRO DD-PRINT-OBJECT (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (11))))
     [java] ; (DEFMACRO DD-DIRECT-SLOTS (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (12))))
     [java] ; (DEFMACRO DD-SLOTS (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (13))))
     [java] ; (DEFMACRO DD-INHERITED-ACCESSORS (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (14))))
     [java] ; (DEFUN MAKE-DEFSTRUCT-DESCRIPTION (&KEY NAME CONC-NAME DEFAULT-CONSTRUCTOR CONSTRUCTORS COPIER INCLUDE TYPE NAMED INITIAL-OFFSET PREDICATE PRINT-FUNCTION PRINT-OBJECT DIRECT-SLOTS SLOTS INHERITED-ACCESSORS) (LET ((DD (MAKE-ARRAY 15))) (SETF (DD-NAME DD) NAME (DD-CONC-NAME DD) CONC-NAME (DD-DEFAULT-CONSTRUCTOR DD) DEFAULT-CONSTRUCTOR (DD-CONSTRUCTORS DD) CONSTRUCTORS (DD-COPIER DD) COPIER (DD-INCLUDE DD) INCLUDE (DD-TYPE DD) TYPE (DD-NAMED DD) NAMED (DD-INITIAL-OFFSET DD) INITIAL-OFFSET (DD-PREDICATE DD) PREDICATE (DD-PRINT-FUNCTION DD) PRINT-FUNCTION (DD-PRINT-OBJECT DD) PRINT-OBJECT (DD-DIRECT-SLOTS DD) DIRECT-SLOTS (DD-SLOTS DD) SLOTS (DD-INHERITED-ACCESSORS DD) INHERITED-ACCESSORS) DD))
     [java] ; (DEFMACRO DSD-NAME (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (1))))
     [java] ; (DEFMACRO DSD-INDEX (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (2))))
     [java] ; (DEFMACRO DSD-READER (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (3))))
     [java] ; (DEFMACRO DSD-INITFORM (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (4))))
     [java] ; (DEFMACRO DSD-TYPE (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (5))))
     [java] ; (DEFMACRO DSD-READ-ONLY (X) (BACKQ-LIST* (QUOTE AREF) X (QUOTE (6))))
     [java] ; (DEFUN MAKE-DEFSTRUCT-SLOT-DESCRIPTION (&KEY NAME INDEX READER INITFORM (TYPE T) READ-ONLY) (LET ((DSD (MAKE-ARRAY 7))) (SETF (AREF DSD 0) (QUOTE DEFSTRUCT-SLOT-DESCRIPTION) (DSD-NAME DSD) NAME (DSD-INDEX DSD) INDEX (DSD-READER DSD) READER (DSD-INITFORM DSD) INITFORM (DSD-TYPE DSD) TYPE (DSD-READ-ONLY DSD) READ-ONLY) DSD))
     [java] ; (DEFVAR *DD-NAME*)
     [java] ; (DEFVAR *DD-CONC-NAME*)
     [java] ; (DEFVAR *DD-DEFAULT-CONSTRUCTOR*)
     [java] ; (DEFVAR *DD-CONSTRUCTORS*)
     [java] ; (DEFVAR *DD-COPIER*)
     [java] ; (DEFVAR *DD-INCLUDE*)
     [java] ; (DEFVAR *DD-TYPE*)
     [java] ; (DEFVAR *DD-DEFAULT-SLOT-TYPE* T)
     [java] ; (DEFVAR *DD-NAMED*)
     [java] ; (DEFVAR *DD-INITIAL-OFFSET*)
     [java] ; (DEFVAR *DD-PREDICATE*)
     [java] ; (DEFVAR *DD-PRINT-FUNCTION*)
     [java] ; (DEFVAR *DD-PRINT-OBJECT*)
     [java] ; (DEFVAR *DD-DIRECT-SLOTS*)
     [java] ; (DEFVAR *DD-SLOTS*)
     [java] ; (DEFVAR *DD-INHERITED-ACCESSORS*)
     [java] ; (DEFVAR *DD-DOCUMENTATION*)
     [java] ; (DEFUN KEYWORDIFY (SYMBOL) (INTERN (SYMBOL-NAME SYMBOL) +KEYWORD-PACKAGE+))
     [java] ; (DEFUN DEFINE-KEYWORD-CONSTRUCTOR (CONSTRUCTOR) (LET* ((CONSTRUCTOR-NAME (CAR CONSTRUCTOR)) (KEYS NIL) (VALUES NIL)) (DOLIST (SLOT *DD-SLOTS*) (LET ((NAME (DSD-NAME SLOT)) (INITFORM (DSD-INITFORM SLOT))) (IF (OR NAME (DSD-READER SLOT)) (LET ((DUMMY (GENSYM))) (PUSH (LIST (LIST (KEYWORDIFY NAME) DUMMY) INITFORM) KEYS) (PUSH DUMMY VALUES)) (PUSH INITFORM VALUES)))) (SETF KEYS (CONS (QUOTE &KEY) (NREVERSE KEYS)) VALUES (NREVERSE VALUES)) (COND ((EQ *DD-TYPE* (QUOTE LIST)) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME KEYS (BACKQ-CONS (QUOTE LIST) VALUES)))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (LET ((ELEMENT-TYPE (IF (CONSP *DD-TYPE*) (CADR *DD-TYPE*) T))) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME KEYS (BACKQ-LIST (QUOTE MAKE-ARRAY) (LENGTH VALUES) (QUOTE :ELEMENT-TYPE) (BACKQ-LIST (QUOTE QUOTE) ELEMENT-TYPE) (QUOTE :INITIAL-CONTENTS) (BACKQ-CONS (QUOTE LIST) VALUES)))))) ((<= 1 (LENGTH VALUES) 6) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME KEYS (BACKQ-LIST* (QUOTE MAKE-STRUCTURE) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE SYMBOL) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*)) VALUES)))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME KEYS (BACKQ-LIST (QUOTE %MAKE-STRUCTURE) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE SYMBOL) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*)) (BACKQ-CONS (QUOTE LIST) VALUES))))))))
     [java] ;COMMON-LISP:LOGXOR triggers autoloading of org.armedbear.lisp.logxor ...
     [java] ; Autoloaded org.armedbear.lisp.logxor (0.002 seconds)
     [java] ; (DEFUN FIND-DSD (NAME) (DOLIST (DSD *DD-SLOTS*) (WHEN (STRING= NAME (DSD-NAME DSD)) (RETURN DSD))))
     [java] ; (DEFUN GET-SLOT (NAME) (LET ((RES NIL)) (DOLIST (DSD *DD-SLOTS*) (WHEN (STRING= NAME (DSD-NAME DSD)) (SETF RES DSD) (RETURN))) (IF RES (VALUES (DSD-TYPE RES) (DSD-INITFORM RES)) (VALUES T NIL))))
     [java] ; (DEFUN DEFINE-BOA-CONSTRUCTOR (CONSTRUCTOR) (MULTIPLE-VALUE-BIND (REQ OPT RESTP REST KEYP KEYS ALLOWP AUXP AUX) (PARSE-LAMBDA-LIST (CADR CONSTRUCTOR)) (LET ((ARGLIST NIL) (VARS NIL) (TYPES NIL) (SKIPPED-VARS NIL)) (DOLIST (ARG REQ) (PUSH ARG ARGLIST) (PUSH ARG VARS) (PUSH (GET-SLOT ARG) TYPES)) (WHEN OPT (PUSH (QUOTE &OPTIONAL) ARGLIST) (DOLIST (ARG OPT) (COND ((CONSP ARG) (DESTRUCTURING-BIND (NAME &OPTIONAL (DEF (NTH-VALUE 1 (GET-SLOT NAME))) (SUPPLIED-TEST NIL SUPPLIED-TEST-P)) ARG (PUSH (BACKQ-LIST* NAME DEF (IF SUPPLIED-TEST-P (BACKQ-LIST SUPPLIED-TEST) NIL)) ARGLIST) (PUSH NAME VARS) (PUSH (GET-SLOT NAME) TYPES))) (T (MULTIPLE-VALUE-BIND (TYPE DEFAULT) (GET-SLOT ARG) (PUSH (BACKQ-LIST ARG DEFAULT) ARGLIST) (PUSH ARG VARS) (PUSH TYPE TYPES)))))) (WHEN RESTP (PUSH (QUOTE &REST) ARGLIST) (PUSH REST ARGLIST) (PUSH REST VARS) (PUSH (QUOTE LIST) TYPES)) (WHEN KEYP (PUSH (QUOTE &KEY) ARGLIST) (DOLIST (KEY KEYS) (IF (CONSP KEY) (DESTRUCTURING-BIND (WOT &OPTIONAL (DEF NIL DEF-P) (SUPPLIED-TEST NIL SUPPLIED-TEST-P)) KEY (LET ((NAME (IF (CONSP WOT) (DESTRUCTURING-BIND (KEY VAR) WOT (DECLARE (IGNORE KEY)) VAR) WOT))) (MULTIPLE-VALUE-BIND (TYPE SLOT-DEF) (GET-SLOT NAME) (PUSH (BACKQ-LIST* WOT (IF DEF-P DEF SLOT-DEF) (IF SUPPLIED-TEST-P (BACKQ-LIST SUPPLIED-TEST) NIL)) ARGLIST) (PUSH NAME VARS) (PUSH TYPE TYPES)))) (MULTIPLE-VALUE-BIND (TYPE DEFAULT) (GET-SLOT KEY) (PUSH (BACKQ-LIST KEY DEFAULT) ARGLIST) (PUSH KEY VARS) (PUSH TYPE TYPES))))) (WHEN ALLOWP (PUSH (QUOTE &ALLOW-OTHER-KEYS) ARGLIST)) (WHEN AUXP (PUSH (QUOTE &AUX) ARGLIST) (DOLIST (ARG AUX) (PUSH ARG ARGLIST) (IF (AND (CONSP ARG) (EQL (LENGTH ARG) 2)) (LET ((VAR (FIRST ARG))) (PUSH VAR VARS) (PUSH (GET-SLOT VAR) TYPES)) (PUSH (IF (CONSP ARG) (FIRST ARG) ARG) SKIPPED-VARS)))) (SETQ ARGLIST (NREVERSE ARGLIST)) (SETQ VARS (NREVERSE VARS)) (SETQ TYPES (NREVERSE TYPES)) (SETQ SKIPPED-VARS (NREVERSE SKIPPED-VARS)) (LET ((VALUES NIL)) (DOLIST (DSD *DD-SLOTS*) (LET ((NAME (DSD-NAME DSD)) VAR) (COND ((FIND NAME SKIPPED-VARS :TEST (FUNCTION STRING=)) (PUSH NIL VALUES)) ((SETF VAR (FIND NAME VARS :TEST (FUNCTION STRING=))) (PUSH VAR VALUES)) (T (PUSH (DSD-INITFORM DSD) VALUES))))) (SETF VALUES (NREVERSE VALUES)) (LET* ((CONSTRUCTOR-NAME (CAR CONSTRUCTOR))) (COND ((EQ *DD-TYPE* (QUOTE LIST)) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME ARGLIST (BACKQ-CONS (QUOTE LIST) VALUES)))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (LET ((ELEMENT-TYPE (IF (CONSP *DD-TYPE*) (CADR *DD-TYPE*) T))) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME ARGLIST (BACKQ-LIST (QUOTE MAKE-ARRAY) (LENGTH VALUES) (QUOTE :ELEMENT-TYPE) (BACKQ-LIST (QUOTE QUOTE) ELEMENT-TYPE) (QUOTE :INITIAL-CONTENTS) (BACKQ-CONS (QUOTE LIST) VALUES)))))) ((<= 1 (LENGTH VALUES) 6) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE INLINE) CONSTRUCTOR-NAME)) (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME ARGLIST (BACKQ-LIST* (QUOTE MAKE-STRUCTURE) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE SYMBOL) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*)) VALUES)))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE INLINE) CONSTRUCTOR-NAME)) (BACKQ-LIST (QUOTE DEFUN) CONSTRUCTOR-NAME ARGLIST (BACKQ-LIST (QUOTE %MAKE-STRUCTURE) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE SYMBOL) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*)) (BACKQ-CONS (QUOTE LIST) VALUES)))))))))))
     [java] ; (DEFUN DEFAULT-CONSTRUCTOR-NAME NIL (INTERN (CONCATENATE (QUOTE STRING) "MAKE-" (SYMBOL-NAME *DD-NAME*))))
     [java] ; (DEFUN DEFINE-CONSTRUCTORS NIL (IF *DD-CONSTRUCTORS* (LET ((RESULTS NIL)) (DOLIST (CONSTRUCTOR *DD-CONSTRUCTORS*) (WHEN (CAR CONSTRUCTOR) (SETF RESULTS (NCONC RESULTS (IF (CADR CONSTRUCTOR) (DEFINE-BOA-CONSTRUCTOR CONSTRUCTOR) (DEFINE-KEYWORD-CONSTRUCTOR CONSTRUCTOR)))))) RESULTS) (DEFINE-KEYWORD-CONSTRUCTOR (CONS (DEFAULT-CONSTRUCTOR-NAME) NIL))))
     [java] ; (DEFUN NAME-INDEX NIL (DOLIST (DSD *DD-SLOTS*) (LET ((NAME (DSD-NAME DSD)) (INITFORM (DSD-INITFORM DSD))) (WHEN (AND (NULL NAME) (EQUAL INITFORM (LIST (QUOTE QUOTE) *DD-NAME*))) (RETURN-FROM NAME-INDEX (DSD-INDEX DSD))))) NIL)
     [java] ; (DEFUN DEFINE-PREDICATE NIL (WHEN (AND *DD-PREDICATE* (OR *DD-NAMED* (NULL *DD-TYPE*))) (LET ((PRED (IF (SYMBOLP *DD-PREDICATE*) *DD-PREDICATE* (INTERN *DD-PREDICATE*)))) (COND ((EQ *DD-TYPE* (QUOTE LIST)) (LET ((INDEX (NAME-INDEX))) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) PRED (QUOTE (OBJECT)) (BACKQ-LIST (QUOTE AND) (QUOTE (CONSP OBJECT)) (BACKQ-LIST (QUOTE >) (QUOTE (LENGTH OBJECT)) INDEX) (BACKQ-LIST (QUOTE EQ) (BACKQ-LIST* (QUOTE NTH) INDEX (QUOTE (OBJECT))) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*))))))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (LET ((INDEX (NAME-INDEX))) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) PRED (QUOTE (OBJECT)) (BACKQ-LIST (QUOTE AND) (QUOTE (VECTORP OBJECT)) (BACKQ-LIST (QUOTE >) (QUOTE (LENGTH OBJECT)) INDEX) (BACKQ-LIST (QUOTE EQ) (BACKQ-LIST (QUOTE AREF) (QUOTE OBJECT) INDEX) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*))))))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE DEFUN) PRED (QUOTE (OBJECT)) (BACKQ-LIST (QUOTE SIMPLE-TYPEP) (QUOTE OBJECT) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*)))))))))
     [java] ; (DEFUN MAKE-LIST-READER (INDEX) (FUNCTION (LAMBDA (INSTANCE) (ELT INSTANCE INDEX))))
     [java] ; (DEFUN MAKE-VECTOR-READER (INDEX) (FUNCTION (LAMBDA (INSTANCE) (AREF INSTANCE INDEX))))
     [java] ; (DEFUN MAKE-STRUCTURE-READER (INDEX STRUCTURE-TYPE) (DECLARE (IGNORE STRUCTURE-TYPE)) (FUNCTION (LAMBDA (INSTANCE) (STRUCTURE-REF INSTANCE INDEX))))
     [java] ; (DEFUN DEFINE-READER (SLOT) (LET ((ACCESSOR-NAME (DSD-READER SLOT)) (INDEX (DSD-INDEX SLOT)) (TYPE (DSD-TYPE SLOT))) (COND ((EQ *DD-TYPE* (QUOTE LIST)) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (BACKQ-LIST (QUOTE FUNCTION) (QUOTE *) TYPE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-READER) *DD-NAME*))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE MAKE-LIST-READER) INDEX)))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (BACKQ-LIST (QUOTE FUNCTION) (QUOTE *) TYPE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-READER) *DD-NAME*))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE MAKE-VECTOR-READER) INDEX)) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-READER) *DD-NAME*))) (BACKQ-LIST (QUOTE DEFINE-SOURCE-TRANSFORM) ACCESSOR-NAME (QUOTE (INSTANCE)) (BACKQ-LIST (QUOTE BACKQ-LIST) (QUOTE (QUOTE AREF)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE TRULY-THE)) (BACKQ-LIST (QUOTE QUOTE) *DD-TYPE*) (QUOTE (INSTANCE))) INDEX)))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (BACKQ-LIST (QUOTE FUNCTION) (QUOTE *) TYPE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE MAKE-STRUCTURE-READER) INDEX (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*))) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-READER) *DD-NAME*))) (BACKQ-LIST (QUOTE DEFINE-SOURCE-TRANSFORM) ACCESSOR-NAME (QUOTE (INSTANCE)) (IF (EQ TYPE (QUOTE T)) (BACKQ-LIST (QUOTE BACKQ-LIST) (QUOTE (QUOTE STRUCTURE-REF)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE THE)) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*) (QUOTE (INSTANCE))) INDEX) (BACKQ-LIST (QUOTE BACKQ-LIST) (QUOTE (QUOTE THE)) (BACKQ-LIST (QUOTE QUOTE) TYPE) (BACKQ-LIST (QUOTE BACKQ-LIST) (QUOTE (QUOTE STRUCTURE-REF)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE THE)) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*) (QUOTE (INSTANCE))) INDEX)))))))))
     [java] ; (DEFUN MAKE-LIST-WRITER (INDEX) (FUNCTION (LAMBDA (VALUE INSTANCE) (%SET-ELT INSTANCE INDEX VALUE))))
     [java] ; (DEFUN MAKE-VECTOR-WRITER (INDEX) (FUNCTION (LAMBDA (VALUE INSTANCE) (ASET INSTANCE INDEX VALUE))))
     [java] ; (DEFUN MAKE-STRUCTURE-WRITER (INDEX STRUCTURE-TYPE) (DECLARE (IGNORE STRUCTURE-TYPE)) (FUNCTION (LAMBDA (VALUE INSTANCE) (STRUCTURE-SET INSTANCE INDEX VALUE))))
     [java] ; (DEFUN DEFINE-WRITER (SLOT) (LET ((ACCESSOR-NAME (DSD-READER SLOT)) (INDEX (DSD-INDEX SLOT))) (COND ((EQ *DD-TYPE* (QUOTE LIST)) (BACKQ-LIST (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE SETF) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-WRITER) *DD-NAME*))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (QUOTE ((QUOTE SETF-FUNCTION)))) (BACKQ-LIST (QUOTE MAKE-LIST-WRITER) INDEX)))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (QUOTE ((QUOTE SETF-FUNCTION)))) (BACKQ-LIST (QUOTE MAKE-VECTOR-WRITER) INDEX)) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE SETF) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-WRITER) *DD-NAME*))) (BACKQ-LIST (QUOTE DEFINE-SOURCE-TRANSFORM) (BACKQ-LIST (QUOTE SETF) ACCESSOR-NAME) (QUOTE (VALUE INSTANCE)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE ASET)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE TRULY-THE)) (BACKQ-LIST (QUOTE QUOTE) *DD-TYPE*) (QUOTE (INSTANCE))) INDEX (QUOTE (VALUE)))))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) ACCESSOR-NAME) (QUOTE ((QUOTE SETF-FUNCTION)))) (BACKQ-LIST (QUOTE MAKE-STRUCTURE-WRITER) INDEX (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*))) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE SETF) ACCESSOR-NAME)) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :STRUCTURE-WRITER) *DD-NAME*))) (BACKQ-LIST (QUOTE DEFINE-SOURCE-TRANSFORM) (BACKQ-LIST (QUOTE SETF) ACCESSOR-NAME) (QUOTE (VALUE INSTANCE)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE STRUCTURE-SET)) (BACKQ-LIST* (QUOTE BACKQ-LIST) (QUOTE (QUOTE THE)) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*) (QUOTE (INSTANCE))) INDEX (QUOTE (VALUE)))))))))
     [java] ; (DEFUN DEFINE-ACCESS-FUNCTIONS NIL (LET ((RESULT NIL)) (DOLIST (SLOT *DD-SLOTS*) (LET ((ACCESSOR-NAME (DSD-READER SLOT))) (UNLESS (NULL ACCESSOR-NAME) (UNLESS (ASSOC ACCESSOR-NAME *DD-INHERITED-ACCESSORS*) (SETF RESULT (NCONC RESULT (DEFINE-READER SLOT))) (UNLESS (DSD-READ-ONLY SLOT) (SETF RESULT (NCONC RESULT (DEFINE-WRITER SLOT)))))))) RESULT))
     [java] ; (DEFUN DEFINE-COPIER NIL (WHEN *DD-COPIER* (COND ((EQ *DD-TYPE* (QUOTE LIST)) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (QUOTE (FUNCTION (LIST) LIST)) *DD-COPIER*)) (BACKQ-LIST* (QUOTE SETF) (BACKQ-LIST (QUOTE FDEFINITION) (BACKQ-LIST (QUOTE QUOTE) *DD-COPIER*)) (QUOTE ((FUNCTION COPY-LIST)))))) ((OR (EQ *DD-TYPE* (QUOTE VECTOR)) (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR)))) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (QUOTE (FUNCTION (VECTOR) VECTOR)) *DD-COPIER*)) (BACKQ-LIST* (QUOTE SETF) (BACKQ-LIST (QUOTE FDEFINITION) (BACKQ-LIST (QUOTE QUOTE) *DD-COPIER*)) (QUOTE ((FUNCTION COPY-SEQ)))))) (T (BACKQ-LIST (BACKQ-LIST (QUOTE DECLAIM) (BACKQ-LIST (QUOTE FTYPE) (QUOTE (FUNCTION (T) T)) *DD-COPIER*)) (BACKQ-LIST* (QUOTE SETF) (BACKQ-LIST (QUOTE FDEFINITION) (BACKQ-LIST (QUOTE QUOTE) *DD-COPIER*)) (QUOTE ((FUNCTION COPY-STRUCTURE)))))))))
     [java] ; (DEFUN DEFINE-PRINT-FUNCTION NIL (COND (*DD-PRINT-FUNCTION* (IF (CADR *DD-PRINT-FUNCTION*) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (BACKQ-CONS (BACKQ-LIST (QUOTE INSTANCE) *DD-NAME*) (QUOTE (STREAM))) (BACKQ-LIST* (QUOTE FUNCALL) (BACKQ-LIST (QUOTE FUNCTION) (CADR *DD-PRINT-FUNCTION*)) (QUOTE (INSTANCE STREAM *CURRENT-PRINT-LEVEL*))))) (BACKQ-LIST (BACKQ-LIST* (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (BACKQ-CONS (BACKQ-LIST (QUOTE INSTANCE) *DD-NAME*) (QUOTE (STREAM))) (QUOTE ((WRITE-STRING (%WRITE-TO-STRING INSTANCE) STREAM))))))) (*DD-PRINT-OBJECT* (IF (CADR *DD-PRINT-OBJECT*) (BACKQ-LIST (BACKQ-LIST (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (BACKQ-CONS (BACKQ-LIST (QUOTE INSTANCE) *DD-NAME*) (QUOTE (STREAM))) (BACKQ-LIST* (QUOTE FUNCALL) (BACKQ-LIST (QUOTE FUNCTION) (CADR *DD-PRINT-OBJECT*)) (QUOTE (INSTANCE STREAM))))) (BACKQ-LIST (BACKQ-LIST* (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (BACKQ-CONS (BACKQ-LIST (QUOTE INSTANCE) *DD-NAME*) (QUOTE (STREAM))) (QUOTE ((WRITE-STRING (%WRITE-TO-STRING INSTANCE) STREAM))))))) (T NIL)))
     [java] ; (DEFUN PARSE-1-OPTION (OPTION) (CASE (CAR OPTION) (:CONC-NAME (SETF *DD-CONC-NAME* (IF (SYMBOLP (CADR OPTION)) (CADR OPTION) (MAKE-SYMBOL (STRING (CADR OPTION)))))) (:CONSTRUCTOR (LET* ((ARGS (CDR OPTION)) (NUMARGS (LENGTH ARGS))) (CASE NUMARGS (0 (PUSH (LIST (DEFAULT-CONSTRUCTOR-NAME) NIL) *DD-CONSTRUCTORS*)) (1 (PUSH (LIST (CAR ARGS) NIL) *DD-CONSTRUCTORS*)) (2 (PUSH ARGS *DD-CONSTRUCTORS*))))) (:COPIER (WHEN (EQL (LENGTH OPTION) 2) (SETF *DD-COPIER* (CADR OPTION)))) (:INCLUDE (SETF *DD-INCLUDE* (CDR OPTION))) (:INITIAL-OFFSET (SETF *DD-INITIAL-OFFSET* (CADR OPTION))) (:PREDICATE (WHEN (EQL (LENGTH OPTION) 2) (SETF *DD-PREDICATE* (CADR OPTION)))) (:PRINT-FUNCTION (SETF *DD-PRINT-FUNCTION* OPTION)) (:PRINT-OBJECT (SETF *DD-PRINT-OBJECT* OPTION)) (:TYPE (SETF *DD-TYPE* (CADR OPTION)) (WHEN (AND (CONSP *DD-TYPE*) (EQ (CAR *DD-TYPE*) (QUOTE VECTOR))) (UNLESS (EQ (SECOND *DD-TYPE*) (QUOTE *)) (SETF *DD-DEFAULT-SLOT-TYPE* (SECOND *DD-TYPE*)))))))
     [java] ; (DEFUN PARSE-NAME-AND-OPTIONS (NAME-AND-OPTIONS) (SETF *DD-NAME* (THE SYMBOL (CAR NAME-AND-OPTIONS))) (SETF *DD-CONC-NAME* (MAKE-SYMBOL (CONCATENATE (QUOTE STRING) (SYMBOL-NAME *DD-NAME*) "-"))) (SETF *DD-COPIER* (INTERN (CONCATENATE (QUOTE STRING) "COPY-" (SYMBOL-NAME *DD-NAME*)))) (SETF *DD-PREDICATE* (CONCATENATE (QUOTE STRING) (SYMBOL-NAME *DD-NAME*) "-P")) (LET ((OPTIONS (CDR NAME-AND-OPTIONS))) (DOLIST (OPTION OPTIONS) (COND ((CONSP OPTION) (PARSE-1-OPTION OPTION)) ((EQ OPTION :NAMED) (SETF *DD-NAMED* T)) ((MEMBER OPTION (QUOTE (:CONSTRUCTOR :COPIER :PREDICATE :NAMED :CONC-NAME))) (PARSE-1-OPTION (LIST OPTION))) (T (ERROR "Unrecognized DEFSTRUCT option: ~S." OPTION))))))
     [java] ; (DEFUN COMPILER-DEFSTRUCT (NAME &KEY CONC-NAME DEFAULT-CONSTRUCTOR CONSTRUCTORS COPIER INCLUDE TYPE NAMED INITIAL-OFFSET PREDICATE PRINT-FUNCTION PRINT-OBJECT DIRECT-SLOTS SLOTS INHERITED-ACCESSORS DOCUMENTATION) (LET ((DESCRIPTION (MAKE-DEFSTRUCT-DESCRIPTION :NAME NAME :CONC-NAME CONC-NAME :DEFAULT-CONSTRUCTOR DEFAULT-CONSTRUCTOR :CONSTRUCTORS CONSTRUCTORS :COPIER COPIER :INCLUDE INCLUDE :TYPE TYPE :NAMED NAMED :INITIAL-OFFSET INITIAL-OFFSET :PREDICATE PREDICATE :PRINT-FUNCTION PRINT-FUNCTION :PRINT-OBJECT PRINT-OBJECT :DIRECT-SLOTS DIRECT-SLOTS :SLOTS SLOTS :INHERITED-ACCESSORS INHERITED-ACCESSORS)) (OLD (GET NAME (QUOTE STRUCTURE-DEFINITION)))) (WHEN OLD (UNLESS (AND (EQUALP (AREF OLD 0) (AREF DESCRIPTION 0)) (STRING= (AREF OLD 1) (AREF DESCRIPTION 1)) (EQUALP (AREF OLD 5) (AREF DESCRIPTION 5)) (EQUALP (AREF OLD 6) (AREF DESCRIPTION 6)) (EQUALP (AREF OLD 7) (AREF DESCRIPTION 7)) (EQUALP (AREF OLD 8) (AREF DESCRIPTION 8)) (EVERY (LAMBDA (X Y) (AND (EQUALP (DSD-NAME X) (DSD-NAME Y)) (EQUALP (DSD-INDEX X) (DSD-INDEX Y)) (EQUALP (DSD-TYPE X) (DSD-TYPE Y)))) (APPEND (AREF OLD 12) (AREF OLD 13)) (APPEND (AREF DESCRIPTION 12) (AREF DESCRIPTION 13)))) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Structure redefinition not supported ~
     [java]                               in DEFSTRUCT for ~A" :FORMAT-ARGUMENTS (LIST NAME))) (SETF DESCRIPTION OLD)) (SETF (GET NAME (QUOTE STRUCTURE-DEFINITION)) DESCRIPTION)) (%SET-DOCUMENTATION NAME (QUOTE STRUCTURE) DOCUMENTATION) (WHEN (OR (NULL TYPE) NAMED) (LET ((STRUCTURE-CLASS (MAKE-STRUCTURE-CLASS NAME DIRECT-SLOTS SLOTS (CAR INCLUDE)))) (%SET-DOCUMENTATION NAME (QUOTE TYPE) DOCUMENTATION) (%SET-DOCUMENTATION STRUCTURE-CLASS T DOCUMENTATION))) (WHEN DEFAULT-CONSTRUCTOR (PROCLAIM (BACKQ-LIST (QUOTE FTYPE) (QUOTE (FUNCTION * T)) DEFAULT-CONSTRUCTOR))))
     [java] ; (DEFMACRO DEFSTRUCT (NAME-AND-OPTIONS &REST SLOTS) (LET ((*DD-NAME* NIL) (*DD-CONC-NAME* NIL) (*DD-DEFAULT-CONSTRUCTOR* NIL) (*DD-CONSTRUCTORS* NIL) (*DD-COPIER* NIL) (*DD-INCLUDE* NIL) (*DD-TYPE* NIL) (*DD-DEFAULT-SLOT-TYPE* T) (*DD-NAMED* NIL) (*DD-INITIAL-OFFSET* NIL) (*DD-PREDICATE* NIL) (*DD-PRINT-FUNCTION* NIL) (*DD-PRINT-OBJECT* NIL) (*DD-DIRECT-SLOTS* NIL) (*DD-SLOTS* NIL) (*DD-INHERITED-ACCESSORS* NIL) (*DD-DOCUMENTATION* NIL)) (PARSE-NAME-AND-OPTIONS (IF (ATOM NAME-AND-OPTIONS) (LIST NAME-AND-OPTIONS) NAME-AND-OPTIONS)) (CHECK-DECLARATION-TYPE *DD-NAME*) (IF *DD-CONSTRUCTORS* (DOLIST (CONSTRUCTOR *DD-CONSTRUCTORS*) (UNLESS (CADR CONSTRUCTOR) (SETF *DD-DEFAULT-CONSTRUCTOR* (CAR CONSTRUCTOR)) (RETURN))) (SETF *DD-DEFAULT-CONSTRUCTOR* (DEFAULT-CONSTRUCTOR-NAME))) (WHEN (STRINGP (CAR SLOTS)) (SETF *DD-DOCUMENTATION* (POP SLOTS))) (DOLIST (SLOT SLOTS) (LET* ((NAME (IF (ATOM SLOT) SLOT (CAR SLOT))) (READER (IF *DD-CONC-NAME* (INTERN (CONCATENATE (QUOTE STRING) (SYMBOL-NAME *DD-CONC-NAME*) (SYMBOL-NAME NAME))) NAME)) (INITFORM (IF (ATOM SLOT) NIL (CADR SLOT))) (DSD (APPLY (FUNCTION MAKE-DEFSTRUCT-SLOT-DESCRIPTION) :NAME NAME :READER READER :INITFORM INITFORM (COND ((ATOM SLOT) (LIST :TYPE *DD-DEFAULT-SLOT-TYPE*)) ((GETF (CDDR SLOT) :TYPE) (CDDR SLOT)) (T (LIST* :TYPE *DD-DEFAULT-SLOT-TYPE* (CDDR SLOT))))))) (PUSH DSD *DD-DIRECT-SLOTS*))) (SETF *DD-DIRECT-SLOTS* (NREVERSE *DD-DIRECT-SLOTS*)) (LET ((INDEX 0)) (WHEN *DD-INCLUDE* (LET ((DD (GET (CAR *DD-INCLUDE*) (QUOTE STRUCTURE-DEFINITION)))) (UNLESS DD (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "Class ~S is undefined." :FORMAT-ARGUMENTS (LIST (CAR *DD-INCLUDE*)))) (DOLIST (DSD (DD-SLOTS DD)) (SETF DSD (COPY-SEQ DSD)) (SETF (DSD-INDEX DSD) INDEX (DSD-READER DSD) (IF *DD-CONC-NAME* (INTERN (CONCATENATE (QUOTE STRING) (SYMBOL-NAME *DD-CONC-NAME*) (SYMBOL-NAME (DSD-NAME DSD)))) (DSD-NAME DSD))) (PUSH DSD *DD-SLOTS*) (INCF INDEX)) (SETF *DD-INHERITED-ACCESSORS* (DD-INHERITED-ACCESSORS DD)) (DOLIST (DSD (DD-DIRECT-SLOTS DD)) (PUSH (CONS (DSD-READER DSD) (DSD-NAME DSD)) *DD-INHERITED-ACCESSORS*))) (WHEN (CDR *DD-INCLUDE*) (DOLIST (SLOT (CDR *DD-INCLUDE*)) (LET* ((NAME (IF (ATOM SLOT) SLOT (CAR SLOT))) (INITFORM (IF (ATOM SLOT) NIL (CADR SLOT))) (DSD (FIND-DSD NAME))) (WHEN DSD (SETF (DSD-INITFORM DSD) INITFORM)))))) (WHEN *DD-INITIAL-OFFSET* (DOTIMES (I *DD-INITIAL-OFFSET*) (PUSH (MAKE-DEFSTRUCT-SLOT-DESCRIPTION :NAME NIL :INDEX INDEX :READER NIL :INITFORM NIL :TYPE T :READ-ONLY T) *DD-SLOTS*) (INCF INDEX))) (WHEN *DD-NAMED* (PUSH (MAKE-DEFSTRUCT-SLOT-DESCRIPTION :NAME NIL :INDEX INDEX :READER NIL :INITFORM (LIST (QUOTE QUOTE) *DD-NAME*) :TYPE T :READ-ONLY T) *DD-SLOTS*) (INCF INDEX)) (DOLIST (DSD *DD-DIRECT-SLOTS*) (SETF (DSD-INDEX DSD) INDEX) (PUSH DSD *DD-SLOTS*) (INCF INDEX))) (SETF *DD-SLOTS* (NREVERSE *DD-SLOTS*)) (BACKQ-LIST* (QUOTE PROGN) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-LIST* (QUOTE COMPILER-DEFSTRUCT) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*) (QUOTE :CONC-NAME) (BACKQ-LIST (QUOTE QUOTE) *DD-CONC-NAME*) (QUOTE :DEFAULT-CONSTRUCTOR) (BACKQ-LIST (QUOTE QUOTE) *DD-DEFAULT-CONSTRUCTOR*) (BACKQ-APPEND (IF *DD-CONSTRUCTORS* (BACKQ-LIST (QUOTE :CONSTRUCTORS) (BACKQ-LIST (QUOTE QUOTE) *DD-CONSTRUCTORS*))) (BACKQ-LIST* (QUOTE :COPIER) (BACKQ-LIST (QUOTE QUOTE) *DD-COPIER*) (BACKQ-APPEND (IF *DD-INCLUDE* (BACKQ-LIST (QUOTE :INCLUDE) (BACKQ-LIST (QUOTE QUOTE) *DD-INCLUDE*))) (IF *DD-TYPE* (BACKQ-LIST (QUOTE :TYPE) (BACKQ-LIST (QUOTE QUOTE) *DD-TYPE*))) (IF *DD-NAMED* (BACKQ-LIST (QUOTE :NAMED) *DD-NAMED*)) (IF *DD-INITIAL-OFFSET* (BACKQ-LIST (QUOTE :INITIAL-OFFSET) *DD-INITIAL-OFFSET*)) (BACKQ-LIST* (QUOTE :PREDICATE) (BACKQ-LIST (QUOTE QUOTE) *DD-PREDICATE*) (BACKQ-APPEND (IF *DD-PRINT-FUNCTION* (BACKQ-LIST (QUOTE :PRINT-FUNCTION) (BACKQ-LIST (QUOTE QUOTE) *DD-PRINT-FUNCTION*))) (IF *DD-PRINT-OBJECT* (BACKQ-LIST (QUOTE :PRINT-OBJECT) (BACKQ-LIST (QUOTE QUOTE) *DD-PRINT-OBJECT*))) (BACKQ-LIST (QUOTE :DIRECT-SLOTS) (BACKQ-LIST (QUOTE QUOTE) *DD-DIRECT-SLOTS*) (QUOTE :SLOTS) (BACKQ-LIST (QUOTE QUOTE) *DD-SLOTS*) (QUOTE :INHERITED-ACCESSORS) (BACKQ-LIST (QUOTE QUOTE) *DD-INHERITED-ACCESSORS*) (QUOTE :DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) *DD-DOCUMENTATION*))))))))) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*) (QUOTE (:STRUCTURE))) (BACKQ-APPEND (DEFINE-CONSTRUCTORS) (DEFINE-PREDICATE) (DEFINE-ACCESS-FUNCTIONS) (DEFINE-COPIER) (WHEN (OR *DD-PRINT-FUNCTION* *DD-PRINT-OBJECT*) (QUOTE ((REQUIRE "PRINT-OBJECT")))) (DEFINE-PRINT-FUNCTION) (BACKQ-LIST (BACKQ-LIST (QUOTE QUOTE) *DD-NAME*))))))
     [java] ; (DEFUN DEFSTRUCT-DEFAULT-CONSTRUCTOR (ARG) (LET ((TYPE (COND ((SYMBOLP ARG) ARG) ((CLASSP ARG) (CLASS-NAME ARG)) (T (TYPE-OF ARG))))) (WHEN TYPE (LET ((DD (GET TYPE (QUOTE STRUCTURE-DEFINITION)))) (AND DD (DD-DEFAULT-CONSTRUCTOR DD))))))
     [java] ;COMMON-LISP:DELETE-FILE triggers autoloading of org.armedbear.lisp.delete_file ...
     [java] ; Autoloaded org.armedbear.lisp.delete_file (0.005 seconds)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defstruct.abcl (4.163 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defstruct.abcl ...
     [java] ; SYSTEM::MAKE-FASL-CLASS-LOADER triggers autoloading of org.armedbear.lisp.FaslClassLoader ...
     [java] ;  Autoloaded org.armedbear.lisp.FaslClassLoader (0.012 seconds)
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defstruct.abcl (0.427 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/coerce.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) COERCE-LIST-TO-VECTOR))
     [java] ; (DEFUN COERCE-LIST-TO-VECTOR (LIST) (LET* ((LENGTH (LENGTH LIST)) (RESULT (MAKE-ARRAY LENGTH))) (DOTIMES (I LENGTH) (DECLARE (TYPE INDEX I)) (SETF (AREF RESULT I) (POP LIST))) RESULT))
     [java] ; (DECLAIM (FTYPE (FUNCTION (STRING) SIMPLE-STRING) COPY-STRING))
     [java] ; (DEFUN COPY-STRING (STRING) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (DECLARE (TYPE STRING STRING)) (LET* ((LENGTH (LENGTH STRING)) (COPY (MAKE-STRING LENGTH))) (DOTIMES (I LENGTH COPY) (DECLARE (TYPE FIXNUM I)) (SETF (SCHAR COPY I) (CHAR STRING I)))))
     [java] ; (DEFUN COERCE-ERROR (OBJECT RESULT-TYPE) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM OBJECT :FORMAT-CONTROL "~S cannot be converted to type ~S." :FORMAT-ARGUMENTS (LIST OBJECT RESULT-TYPE)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) COERCE-OBJECT-TO-AND-TYPE))
     [java] ; (DEFUN COERCE-OBJECT-TO-AND-TYPE (OBJECT RESULT-TYPE) (WHEN (AND (CONSP RESULT-TYPE) (EQ (%CAR RESULT-TYPE) (QUOTE AND)) (= (LENGTH RESULT-TYPE) 3)) (LET* ((TYPE1 (%CADR RESULT-TYPE)) (TYPE2 (%CADDR RESULT-TYPE)) (RESULT (COERCE OBJECT TYPE1))) (WHEN (TYPEP OBJECT TYPE2) (RETURN-FROM COERCE-OBJECT-TO-AND-TYPE RESULT)))) (COERCE-ERROR OBJECT RESULT-TYPE))
     [java] ; (DEFUN COERCE (OBJECT RESULT-TYPE) (COND ((EQ RESULT-TYPE T) OBJECT) ((TYPEP OBJECT RESULT-TYPE) OBJECT) ((AND (LISTP OBJECT) (EQ RESULT-TYPE (QUOTE VECTOR))) (COERCE-LIST-TO-VECTOR OBJECT)) ((AND (STRINGP OBJECT) (EQ RESULT-TYPE (QUOTE SIMPLE-STRING))) (COPY-STRING OBJECT)) ((EQ RESULT-TYPE (QUOTE CHARACTER)) (COND ((AND (STRINGP OBJECT) (= (LENGTH OBJECT) 1)) (CHAR OBJECT 0)) ((AND (SYMBOLP OBJECT) (= (LENGTH (SYMBOL-NAME OBJECT)) 1)) (CHAR (SYMBOL-NAME OBJECT) 0)) (T (COERCE-ERROR OBJECT RESULT-TYPE)))) ((MEMQ RESULT-TYPE (QUOTE (FLOAT SINGLE-FLOAT SHORT-FLOAT))) (COERCE-TO-SINGLE-FLOAT OBJECT)) ((MEMQ RESULT-TYPE (QUOTE (DOUBLE-FLOAT LONG-FLOAT))) (COERCE-TO-DOUBLE-FLOAT OBJECT)) ((EQ RESULT-TYPE (QUOTE COMPLEX)) (COND ((FLOATP OBJECT) (COMPLEX OBJECT 0.0f0)) ((NUMBERP OBJECT) OBJECT) (T (COERCE-ERROR OBJECT RESULT-TYPE)))) ((EQ RESULT-TYPE (QUOTE FUNCTION)) (COERCE-TO-FUNCTION OBJECT)) ((AND (CONSP RESULT-TYPE) (EQ (%CAR RESULT-TYPE) (QUOTE COMPLEX))) (WHEN (COMPLEXP OBJECT) (RETURN-FROM COERCE (COMPLEX (COERCE (REALPART OBJECT) (CADR RESULT-TYPE)) (COERCE (IMAGPART OBJECT) (CADR RESULT-TYPE))))) (IF (MEMQ (%CADR RESULT-TYPE) (QUOTE (FLOAT SINGLE-FLOAT DOUBLE-FLOAT SHORT-FLOAT LONG-FLOAT))) (COMPLEX (COERCE OBJECT (CADR RESULT-TYPE)) (COERCE 0.0f0 (CADR RESULT-TYPE))) OBJECT)) ((AND (CONSP RESULT-TYPE) (EQ (%CAR RESULT-TYPE) (QUOTE AND))) (COERCE-OBJECT-TO-AND-TYPE OBJECT RESULT-TYPE)) ((AND (SIMPLE-TYPEP OBJECT (QUOTE SEQUENCE)) (%SUBTYPEP RESULT-TYPE (QUOTE SEQUENCE))) (CONCATENATE RESULT-TYPE OBJECT)) (T (LET ((EXPANDED-TYPE (EXPAND-DEFTYPE RESULT-TYPE))) (UNLESS (EQ EXPANDED-TYPE RESULT-TYPE) (RETURN-FROM COERCE (COERCE OBJECT EXPANDED-TYPE)))) (COERCE-ERROR OBJECT RESULT-TYPE))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/coerce.abcl (0.288 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/coerce.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/coerce.abcl (0.03 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/open.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN UPGRADED-ELEMENT-TYPE-BITS (BITS) (IF (ZEROP (MOD BITS 8)) BITS (+ BITS (- 8 (MOD BITS 8)))))
     [java] ; (DEFUN UPGRADED-ELEMENT-TYPE (ELEMENT-TYPE) (SETF ELEMENT-TYPE (NORMALIZE-TYPE ELEMENT-TYPE)) (LET ((OK NIL)) (IF (ATOM ELEMENT-TYPE) (CASE ELEMENT-TYPE ((CHARACTER BASE-CHAR) (SETF OK T)) ((UNSIGNED-BYTE SIGNED-BYTE) (SETF ELEMENT-TYPE (LIST ELEMENT-TYPE 8) OK T)) (BIT (SETF ELEMENT-TYPE (LIST (QUOTE UNSIGNED-BYTE) (UPGRADED-ELEMENT-TYPE-BITS 1)) OK T)) (INTEGER (SETF ELEMENT-TYPE (QUOTE (SIGNED-BYTE 8)) OK T))) (COND ((EQ (%CAR ELEMENT-TYPE) (QUOTE OR)) (LET ((TYPES (MAPCAR (FUNCTION UPGRADED-ELEMENT-TYPE) (%CDR ELEMENT-TYPE))) (RESULT (QUOTE (UNSIGNED-BYTE 8)))) (DOLIST (TYPE TYPES) (WHEN (EQ (CAR TYPE) (QUOTE SIGNED-BYTE)) (SETF (CAR RESULT) (QUOTE SIGNED-BYTE))) (SETF (CADR RESULT) (MAX (CADR RESULT) (CADR TYPE)))) (SETF ELEMENT-TYPE RESULT OK T))) ((AND (= (LENGTH ELEMENT-TYPE) 2) (MEMQ (%CAR ELEMENT-TYPE) (QUOTE (UNSIGNED-BYTE SIGNED-BYTE)))) (LET ((TYPE (CAR ELEMENT-TYPE)) (WIDTH (CADR ELEMENT-TYPE))) (SETF ELEMENT-TYPE (LIST TYPE (UPGRADED-ELEMENT-TYPE-BITS WIDTH)) OK T))) ((EQ (CAR ELEMENT-TYPE) (QUOTE INTEGER)) (CASE (LENGTH ELEMENT-TYPE) (2 (SETF ELEMENT-TYPE (QUOTE (SIGNED-BYTE 8)) OK T)) (3 (LET ((LOW (CADR ELEMENT-TYPE)) (HIGH (CADDR ELEMENT-TYPE))) (WHEN (CONSP LOW) (SETF LOW (1+ (%CAR LOW)))) (WHEN (CONSP HIGH) (SETF HIGH (1- (%CAR HIGH)))) (SETF ELEMENT-TYPE (COND ((EQ HIGH (QUOTE *)) (IF (MINUSP LOW) (QUOTE (SIGNED-BYTE 8)) (QUOTE (UNSIGNED-BYTE 8)))) ((MINUSP LOW) (LIST (QUOTE SIGNED-BYTE) (UPGRADED-ELEMENT-TYPE-BITS (MAX (1+ (INTEGER-LENGTH LOW)) (INTEGER-LENGTH HIGH))))) (T (LIST (QUOTE UNSIGNED-BYTE) (UPGRADED-ELEMENT-TYPE-BITS (INTEGER-LENGTH HIGH))))) OK T))))))) (IF OK ELEMENT-TYPE (ERROR (QUOTE FILE-ERROR) :FORMAT-CONTROL "Unsupported element type ~S." :FORMAT-ARGUMENTS (LIST ELEMENT-TYPE)))))
     [java] ; (DEFUN OPEN (FILENAME &KEY (DIRECTION :INPUT) (ELEMENT-TYPE (QUOTE CHARACTER)) (IF-EXISTS NIL IF-EXISTS-GIVEN) (IF-DOES-NOT-EXIST NIL IF-DOES-NOT-EXIST-GIVEN) (EXTERNAL-FORMAT :DEFAULT)) (SETF ELEMENT-TYPE (CASE ELEMENT-TYPE ((CHARACTER BASE-CHAR) (QUOTE CHARACTER)) (:DEFAULT (QUOTE (UNSIGNED-BYTE 8))) (T (UPGRADED-ELEMENT-TYPE ELEMENT-TYPE)))) (LET* ((PATHNAME (MERGE-PATHNAMES FILENAME)) (NAMESTRING (NAMESTRING (IF (TYPEP PATHNAME (QUOTE LOGICAL-PATHNAME)) (TRANSLATE-LOGICAL-PATHNAME PATHNAME) PATHNAME)))) (WHEN (WILD-PATHNAME-P PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "Bad place for a wild pathname.")) (WHEN (MEMQ DIRECTION (QUOTE (:OUTPUT :IO))) (UNLESS IF-EXISTS-GIVEN (SETF IF-EXISTS (IF (EQ (PATHNAME-VERSION PATHNAME) :NEWEST) :NEW-VERSION :ERROR)))) (UNLESS IF-DOES-NOT-EXIST-GIVEN (SETF IF-DOES-NOT-EXIST (COND ((EQ DIRECTION :INPUT) :ERROR) ((AND (MEMQ DIRECTION (QUOTE (:OUTPUT :IO))) (MEMQ IF-EXISTS (QUOTE (:OVERWRITE :APPEND)))) :ERROR) ((EQ DIRECTION :PROBE) NIL) (T :CREATE)))) (CASE DIRECTION (:INPUT (CASE IF-DOES-NOT-EXIST (:ERROR (UNLESS (PROBE-FILE PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "The file ~S does not exist." :FORMAT-ARGUMENTS (LIST NAMESTRING)))) (:CREATE (CREATE-NEW-FILE NAMESTRING))) (MAKE-FILE-STREAM PATHNAME NAMESTRING ELEMENT-TYPE :INPUT NIL EXTERNAL-FORMAT)) (:PROBE (CASE IF-DOES-NOT-EXIST (:ERROR (UNLESS (PROBE-FILE PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "The file ~S does not exist." :FORMAT-ARGUMENTS (LIST NAMESTRING)))) (:CREATE (CREATE-NEW-FILE NAMESTRING))) (LET ((STREAM (MAKE-FILE-STREAM PATHNAME NAMESTRING ELEMENT-TYPE :INPUT NIL EXTERNAL-FORMAT))) (WHEN STREAM (CLOSE STREAM)) STREAM)) ((:OUTPUT :IO) (CASE IF-DOES-NOT-EXIST (:ERROR (UNLESS (PROBE-FILE PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "The file ~S does not exist." :FORMAT-ARGUMENTS (LIST NAMESTRING)))) ((NIL) (UNLESS (PROBE-FILE PATHNAME) (RETURN-FROM OPEN NIL)))) (CASE IF-EXISTS (:ERROR (WHEN (PROBE-FILE PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "The file ~S already exists." :FORMAT-ARGUMENTS (LIST NAMESTRING)))) ((NIL) (WHEN (PROBE-FILE PATHNAME) (RETURN-FROM OPEN NIL))) ((:RENAME :RENAME-AND-DELETE) (WHEN (PROBE-FILE PATHNAME) (WHEN (PROBE-DIRECTORY PATHNAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "The file ~S is a directory." :FORMAT-ARGUMENTS (LIST NAMESTRING))) (LET ((BACKUP-NAME (CONCATENATE (QUOTE STRING) NAMESTRING ".bak"))) (WHEN (PROBE-FILE BACKUP-NAME) (WHEN (PROBE-DIRECTORY BACKUP-NAME) (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "Unable to rename ~S." :FORMAT-ARGUMENTS (LIST NAMESTRING))) (DELETE-FILE BACKUP-NAME)) (RENAME-FILE PATHNAME BACKUP-NAME)))) ((:NEW-VERSION :SUPERSEDE :OVERWRITE :APPEND)) (T (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "Option not supported: ~S." :FORMAT-ARGUMENTS (LIST IF-EXISTS)))) (LET ((STREAM (MAKE-FILE-STREAM PATHNAME NAMESTRING ELEMENT-TYPE DIRECTION IF-EXISTS EXTERNAL-FORMAT))) (UNLESS STREAM (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "Unable to open ~S." :FORMAT-ARGUMENTS (LIST NAMESTRING))) STREAM)) (T (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL ":DIRECTION ~S not supported." :FORMAT-ARGUMENTS (LIST DIRECTION))))))
     [java] ;EXTENSIONS:ASSQ triggers autoloading of org.armedbear.lisp.assq ...
     [java] ; Autoloaded org.armedbear.lisp.assq (0.007 seconds)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/open.abcl (0.428 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/open.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/open.abcl (0.016 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dump-form.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DECLAIM (SPECIAL *CIRCULARITY* *CIRCLE-COUNTER* *INSTANCE-FORMS*))
     [java] ; (DEFUN GET-INSTANCE-FORM (OBJECT) (MULTIPLE-VALUE-BIND (VALUE PRESENCE) (GETHASH OBJECT *INSTANCE-FORMS*) (COND (PRESENCE VALUE) (T (MULTIPLE-VALUE-BIND (CREATION-FORM INITIALIZATION-FORM) (MAKE-LOAD-FORM OBJECT) (IF INITIALIZATION-FORM (LET* ((INSTANCE (GENSYM)) LOAD-FORM) (SETF INITIALIZATION-FORM (SUBST INSTANCE OBJECT INITIALIZATION-FORM)) (SETF INITIALIZATION-FORM (SUBST INSTANCE (LIST (QUOTE QUOTE) INSTANCE) INITIALIZATION-FORM :TEST (FUNCTION EQUAL))) (SETF LOAD-FORM (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST INSTANCE CREATION-FORM)) INITIALIZATION-FORM INSTANCE))) (SETF (GETHASH OBJECT *INSTANCE-FORMS*) LOAD-FORM)) (SETF (GETHASH OBJECT *INSTANCE-FORMS*) CREATION-FORM)))))))
     [java] ; (DEFUN DF-REGISTER-CIRCULARITY (OBJECT) (SETF (GETHASH OBJECT *CIRCULARITY*) (IF (GETHASH OBJECT *CIRCULARITY*) :CIRCULAR T)))
     [java] ; (DEFUN DF-CHECK-CONS (OBJECT) (LOOP (DF-CHECK-OBJECT (CAR OBJECT)) (SETF OBJECT (CDR OBJECT)) (WHEN (ATOM OBJECT) (DF-CHECK-OBJECT OBJECT) (RETURN)) (WHEN (NULL OBJECT) (RETURN-FROM DF-CHECK-CONS)) (WHEN (EQ :CIRCULAR (DF-REGISTER-CIRCULARITY OBJECT)) (RETURN))))
     [java] ; (DEFUN DF-CHECK-VECTOR (OBJECT) (DOTIMES (INDEX (LENGTH OBJECT)) (DF-CHECK-OBJECT (AREF OBJECT INDEX))))
     [java] ; (DEFUN DF-CHECK-INSTANCE (OBJECT) (DF-CHECK-OBJECT (GET-INSTANCE-FORM OBJECT)))
     [java] ; (DEFUN DF-CHECK-OBJECT (OBJECT) (UNLESS (EQ :CIRCULAR (DF-REGISTER-CIRCULARITY OBJECT)) (COND ((CONSP OBJECT) (DF-CHECK-CONS OBJECT)) ((VECTORP OBJECT) (DF-CHECK-VECTOR OBJECT)) ((OR (STRUCTURE-OBJECT-P OBJECT) (STANDARD-OBJECT-P OBJECT) (JAVA:JAVA-OBJECT-P OBJECT)) (DF-CHECK-INSTANCE OBJECT)))))
     [java] ; (DEFUN DF-HANDLE-CIRCULARITY (OBJECT STREAM WITHIN-LIST) (LET ((INDEX (GETHASH OBJECT *CIRCULARITY*))) (COND ((EQ INDEX :CIRCULAR) (SETF INDEX (INCF *CIRCLE-COUNTER*)) (SETF (GETHASH OBJECT *CIRCULARITY*) INDEX) (WHEN WITHIN-LIST (WRITE-STRING " . " STREAM)) (%STREAM-WRITE-CHAR #\# STREAM) (WRITE INDEX :STREAM STREAM) (%STREAM-WRITE-CHAR #\= STREAM) (WHEN WITHIN-LIST (DUMP-CONS OBJECT STREAM) (RETURN-FROM DF-HANDLE-CIRCULARITY T)) (RETURN-FROM DF-HANDLE-CIRCULARITY)) ((INTEGERP INDEX) (WHEN WITHIN-LIST (WRITE-STRING " . " STREAM)) (%STREAM-WRITE-CHAR #\# STREAM) (WRITE INDEX :STREAM STREAM) (%STREAM-WRITE-CHAR #\# STREAM) (%STREAM-WRITE-CHAR #\  STREAM) (RETURN-FROM DF-HANDLE-CIRCULARITY T)) (T (UNLESS *PREVENT-FASL-CIRCLE-DETECTION* (ASSERT (OR (EQ INDEX T) (INTEGERP OBJECT))))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (CONS STREAM) T) DUMP-CONS))
     [java] ; (DEFUN DUMP-CONS (OBJECT STREAM) (COND ((AND (EQ (CAR OBJECT) (QUOTE QUOTE)) (PROPER-LIST-OF-LENGTH-P OBJECT 2)) (%STREAM-WRITE-CHAR #\' STREAM) (DUMP-OBJECT (%CADR OBJECT) STREAM)) (T (%STREAM-WRITE-CHAR #\( STREAM) (LOOP (DUMP-OBJECT (%CAR OBJECT) STREAM) (SETF OBJECT (%CDR OBJECT)) (WHEN (NULL OBJECT) (RETURN)) (%STREAM-WRITE-CHAR #\  STREAM) (WHEN (ATOM OBJECT) (%STREAM-WRITE-CHAR #\. STREAM) (%STREAM-WRITE-CHAR #\  STREAM) (DUMP-OBJECT OBJECT STREAM) (RETURN)) (WHEN (DF-HANDLE-CIRCULARITY OBJECT STREAM T) (RETURN)) (WHEN (> (CHARPOS STREAM) 80) (%STREAM-TERPRI STREAM))) (%STREAM-WRITE-CHAR #\) STREAM))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM) T) DUMP-VECTOR))
     [java] ; (DEFUN DUMP-VECTOR (OBJECT STREAM) (WRITE-STRING "#(" STREAM) (LET ((LENGTH (LENGTH OBJECT))) (WHEN (> LENGTH 0) (DOTIMES (I (1- LENGTH)) (DECLARE (TYPE INDEX I)) (DUMP-OBJECT (AREF OBJECT I) STREAM) (WHEN (> (CHARPOS STREAM) 80) (%STREAM-TERPRI STREAM)) (%STREAM-WRITE-CHAR #\  STREAM)) (DUMP-OBJECT (AREF OBJECT (1- LENGTH)) STREAM)) (%STREAM-WRITE-CHAR #\) STREAM)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM) T) DUMP-INSTANCE))
     [java] ; (DEFUN DUMP-INSTANCE (OBJECT STREAM) (WRITE-STRING "#." STREAM) (DUMP-OBJECT (GET-INSTANCE-FORM OBJECT) STREAM))
     [java] ; (DECLAIM (FTYPE (FUNCTION (SYMBOL) INTEGER) DUMP-UNINTERNED-SYMBOL-INDEX))
     [java] ; (DEFUN DUMP-UNINTERNED-SYMBOL-INDEX (SYMBOL) (LET ((INDEX (CDR (ASSOC SYMBOL *FASL-UNINTERNED-SYMBOLS*)))) (UNLESS INDEX (SETQ INDEX (1+ (OR (CDAR *FASL-UNINTERNED-SYMBOLS*) -1))) (SETQ *FASL-UNINTERNED-SYMBOLS* (ACONS SYMBOL INDEX *FASL-UNINTERNED-SYMBOLS*))) INDEX))
     [java] ; (DECLAIM (FTYPE (FUNCTION (PATHNAME STREAM) T) DUMP-PATHNAME))
     [java] ; (DEFUN DUMP-PATHNAME (PATHNAME STREAM) (WRITE-STRING "#P(" STREAM) (WRITE-STRING ":HOST " STREAM) (DUMP-FORM (PATHNAME-HOST PATHNAME) STREAM) (WRITE-STRING " :DEVICE " STREAM) (DUMP-FORM (PATHNAME-DEVICE PATHNAME) STREAM) (WRITE-STRING " :DIRECTORY " STREAM) (DUMP-FORM (PATHNAME-DIRECTORY PATHNAME) STREAM) (WRITE-STRING " :NAME " STREAM) (DUMP-FORM (PATHNAME-NAME PATHNAME) STREAM) (WRITE-STRING " :TYPE " STREAM) (DUMP-FORM (PATHNAME-TYPE PATHNAME) STREAM) (WRITE-STRING " :VERSION " STREAM) (DUMP-FORM (PATHNAME-VERSION PATHNAME) STREAM) (WRITE-STRING ")" STREAM))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM) T) DUMP-OBJECT))
     [java] ; (DEFUN DUMP-OBJECT (OBJECT STREAM) (UNLESS (DF-HANDLE-CIRCULARITY OBJECT STREAM NIL) (COND ((CONSP OBJECT) (DUMP-CONS OBJECT STREAM)) ((STRINGP OBJECT) (%STREAM-OUTPUT-OBJECT OBJECT STREAM)) ((PATHNAMEP OBJECT) (DUMP-PATHNAME OBJECT STREAM)) ((BIT-VECTOR-P OBJECT) (%STREAM-OUTPUT-OBJECT OBJECT STREAM)) ((VECTORP OBJECT) (DUMP-VECTOR OBJECT STREAM)) ((OR (STRUCTURE-OBJECT-P OBJECT) (STANDARD-OBJECT-P OBJECT) (JAVA:JAVA-OBJECT-P OBJECT)) (DUMP-INSTANCE OBJECT STREAM)) ((AND (SYMBOLP OBJECT) (NULL (SYMBOL-PACKAGE OBJECT))) (WRITE-STRING "#" STREAM) (WRITE (DUMP-UNINTERNED-SYMBOL-INDEX OBJECT) :STREAM STREAM) (WRITE-STRING "?" STREAM)) (T (%STREAM-OUTPUT-OBJECT OBJECT STREAM)))))
     [java] ; (DEFVAR *THE-FASL-PRINTER-READTABLE* (COPY-READTABLE (GET-FASL-READTABLE)) "This variable holds a copy of the FASL readtable which we need to bind
     [java] below, in order to prevent the current readtable from influencing the content
     [java] being written to the FASL: the READTABLE-CASE setting influences symbol printing.")
     [java] ; (DEFVAR *PREVENT-FASL-CIRCLE-DETECTION* NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM) T) DUMP-FORM))
     [java] ; (DEFUN DUMP-FORM (FORM STREAM) (LET ((*PRINT-FASL* T) (*PRINT-ARRAY* T) (*PRINT-BASE* 10) (*PRINT-CASE* :UPCASE) (*PRINT-CIRCLE* NIL) (*PRINT-ESCAPE* T) (*PRINT-GENSYM* T) (*PRINT-LENGTH* NIL) (*PRINT-LEVEL* NIL) (*PRINT-LINES* NIL) (*PRINT-PRETTY* NIL) (*PRINT-RADIX* NIL) (*PRINT-RIGHT-MARGIN* NIL) (*PRINT-STRUCTURE* T) (*READTABLE* *THE-FASL-PRINTER-READTABLE*) (*READ-DEFAULT-FLOAT-FORMAT* NIL) (*CIRCULARITY* (MAKE-HASH-TABLE :TEST (FUNCTION EQ))) (*INSTANCE-FORMS* (MAKE-HASH-TABLE :TEST (FUNCTION EQ))) (*CIRCLE-COUNTER* 0)) (UNLESS *PREVENT-FASL-CIRCLE-DETECTION* (DF-CHECK-OBJECT FORM)) (DUMP-OBJECT FORM STREAM)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dump-form.abcl (0.8 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dump-form.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dump-form.abcl (0.332 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-types.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFSTRUCT CONSTANT-TYPE VALUE)
     [java] ;EXTENSIONS:ASSQL triggers autoloading of org.armedbear.lisp.assql ...
     [java] ; Autoloaded org.armedbear.lisp.assql (0.005 seconds)
     [java] ; (DEFCONST +TRUE-TYPE+ (MAKE-CONSTANT-TYPE :VALUE T))
     [java] ; (DEFCONST +FALSE-TYPE+ (MAKE-CONSTANT-TYPE :VALUE NIL))
     [java] ; (DEFSTRUCT (INTEGER-TYPE (:CONSTRUCTOR %MAKE-INTEGER-TYPE (LOW HIGH))) LOW HIGH)
     [java] ; (DEFCONSTANT +FIXNUM-TYPE+ (%MAKE-INTEGER-TYPE MOST-NEGATIVE-FIXNUM MOST-POSITIVE-FIXNUM))
     [java] ; (DEFCONSTANT +INTEGER-TYPE+ (%MAKE-INTEGER-TYPE NIL NIL))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) MAKE-INTEGER-TYPE))
     [java] ; (DEFUN MAKE-INTEGER-TYPE (TYPE) (IF (INTEGER-TYPE-P TYPE) TYPE (COND ((EQ TYPE (QUOTE FIXNUM)) +FIXNUM-TYPE+) ((EQ TYPE (QUOTE INTEGER)) +INTEGER-TYPE+) (T (SETF TYPE (NORMALIZE-TYPE TYPE)) (WHEN (AND (CONSP TYPE) (EQ (%CAR TYPE) (QUOTE INTEGER))) (LET ((LOW (SECOND TYPE)) (HIGH (THIRD TYPE))) (IF (EQ LOW (QUOTE *)) (SETF LOW NIL) (WHEN (AND (CONSP LOW) (INTEGERP (%CAR LOW))) (SETF LOW (1+ (%CAR LOW))))) (IF (EQ HIGH (QUOTE *)) (SETF HIGH NIL) (WHEN (AND (CONSP HIGH) (INTEGERP (%CAR HIGH))) (SETF HIGH (1- (%CAR HIGH))))) (%MAKE-INTEGER-TYPE LOW HIGH)))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) FIXNUM-TYPE-P))
     [java] ; (DEFUN FIXNUM-TYPE-P (COMPILER-TYPE) (AND (INTEGER-TYPE-P COMPILER-TYPE) (FIXNUMP (INTEGER-TYPE-LOW COMPILER-TYPE)) (FIXNUMP (INTEGER-TYPE-HIGH COMPILER-TYPE))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) FIXNUM-CONSTANT-VALUE))
     [java] ; (DEFUN FIXNUM-CONSTANT-VALUE (COMPILER-TYPE) (WHEN (AND COMPILER-TYPE (INTEGER-TYPE-P COMPILER-TYPE)) (LET ((LOW (INTEGER-TYPE-LOW COMPILER-TYPE)) HIGH) (WHEN (FIXNUMP LOW) (SETF HIGH (INTEGER-TYPE-HIGH COMPILER-TYPE)) (WHEN (AND (FIXNUMP HIGH) (= HIGH LOW)) HIGH)))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) INTEGER-CONSTANT-VALUE))
     [java] ; (DEFUN INTEGER-CONSTANT-VALUE (COMPILER-TYPE) (WHEN (AND COMPILER-TYPE (INTEGER-TYPE-P COMPILER-TYPE)) (LET ((LOW (INTEGER-TYPE-LOW COMPILER-TYPE)) HIGH) (WHEN (INTEGERP LOW) (SETF HIGH (INTEGER-TYPE-HIGH COMPILER-TYPE)) (WHEN (AND (INTEGERP HIGH) (= HIGH LOW)) HIGH)))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) JAVA-LONG-TYPE-P))
     [java] ; (DEFUN JAVA-LONG-TYPE-P (COMPILER-TYPE) (AND (INTEGER-TYPE-P COMPILER-TYPE) (TYPEP (INTEGER-TYPE-LOW COMPILER-TYPE) (LIST (QUOTE INTEGER) MOST-NEGATIVE-JAVA-LONG MOST-POSITIVE-JAVA-LONG)) (TYPEP (INTEGER-TYPE-HIGH COMPILER-TYPE) (LIST (QUOTE INTEGER) MOST-NEGATIVE-JAVA-LONG MOST-POSITIVE-JAVA-LONG))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) MAKE-UNION-TYPE))
     [java] ; (DEFUN MAKE-UNION-TYPE (TYPE1 TYPE2) (COND ((AND (INTEGER-TYPE-P TYPE1) (INTEGER-TYPE-P TYPE2)) (LET ((LOW1 (INTEGER-TYPE-LOW TYPE1)) (LOW2 (INTEGER-TYPE-LOW TYPE2)) (HIGH1 (INTEGER-TYPE-HIGH TYPE1)) (HIGH2 (INTEGER-TYPE-HIGH TYPE2))) (IF (AND LOW1 LOW2 HIGH1 HIGH2) (%MAKE-INTEGER-TYPE (MIN LOW1 LOW2) (MAX HIGH1 HIGH2)) +INTEGER-TYPE+))) (T T)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) MAKE-COMPILER-TYPE))
     [java] ; (DEFUN MAKE-COMPILER-TYPE (TYPESPEC) (COND ((INTEGER-TYPE-P TYPESPEC) TYPESPEC) ((CONSTANT-TYPE-P TYPESPEC) TYPESPEC) ((EQ TYPESPEC (QUOTE SINGLE-FLOAT)) (QUOTE SINGLE-FLOAT)) ((EQ TYPESPEC (QUOTE DOUBLE-FLOAT)) (QUOTE DOUBLE-FLOAT)) ((AND (CONSP TYPESPEC) (EQ (%CAR TYPESPEC) (QUOTE SINGLE-FLOAT))) (QUOTE SINGLE-FLOAT)) ((AND (CONSP TYPESPEC) (EQ (%CAR TYPESPEC) (QUOTE DOUBLE-FLOAT))) (QUOTE DOUBLE-FLOAT)) (T (LET ((TYPE (NORMALIZE-TYPE TYPESPEC))) (COND ((CONSP TYPE) (LET ((CAR (%CAR TYPE))) (COND ((EQ CAR (QUOTE INTEGER)) (MAKE-INTEGER-TYPE TYPE)) ((EQ CAR (QUOTE SINGLE-FLOAT)) (QUOTE SINGLE-FLOAT)) ((EQ CAR (QUOTE DOUBLE-FLOAT)) (QUOTE DOUBLE-FLOAT)) ((MEMQ CAR (QUOTE (STRING SIMPLE-STRING LIST))) CAR) ((MEMQ CAR (QUOTE (VECTOR SIMPLE-VECTOR ARRAY SIMPLE-ARRAY))) TYPE) ((EQ CAR (QUOTE OR)) (CASE (LENGTH (CDR TYPE)) (1 (MAKE-COMPILER-TYPE (SECOND TYPE))) (2 (MAKE-UNION-TYPE (MAKE-COMPILER-TYPE (SECOND TYPE)) (MAKE-COMPILER-TYPE (THIRD TYPE)))) (T T))) ((SUBTYPEP TYPE (QUOTE FIXNUM)) +FIXNUM-TYPE+) (T T)))) ((MEMQ TYPE (QUOTE (BOOLEAN CHARACTER HASH-TABLE STREAM SYMBOL))) TYPE) ((EQ TYPE (QUOTE INTEGER)) (%MAKE-INTEGER-TYPE NIL NIL)) (T T))))))
     [java] ; (DEFUN INTEGER-TYPE-SUBTYPEP (TYPE1 TYPESPEC) (IF (EQ TYPESPEC (QUOTE INTEGER)) T (LET ((TYPE2 (MAKE-INTEGER-TYPE TYPESPEC))) (WHEN TYPE2 (LET ((LOW1 (INTEGER-TYPE-LOW TYPE1)) (HIGH1 (INTEGER-TYPE-HIGH TYPE1)) (LOW2 (INTEGER-TYPE-LOW TYPE2)) (HIGH2 (INTEGER-TYPE-HIGH TYPE2))) (COND ((AND LOW1 LOW2 HIGH1 HIGH2) (AND (>= LOW1 LOW2) (<= HIGH1 HIGH2))) ((AND LOW1 LOW2 (< LOW1 LOW2)) NIL) ((AND HIGH1 HIGH2) (> HIGH1 HIGH2) NIL) ((AND (NULL LOW1) LOW2) NIL) ((AND (NULL HIGH1) HIGH2) NIL) (T T)))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) COMPILER-SUBTYPEP))
     [java] ; (DEFUN COMPILER-SUBTYPEP (COMPILER-TYPE TYPESPEC) (COND ((EQ TYPESPEC T) T) ((EQ COMPILER-TYPE T) NIL) ((EQ COMPILER-TYPE TYPESPEC) T) ((EQ TYPESPEC (QUOTE STRING)) (EQ COMPILER-TYPE (QUOTE SIMPLE-STRING))) ((INTEGER-TYPE-P COMPILER-TYPE) (INTEGER-TYPE-SUBTYPEP COMPILER-TYPE TYPESPEC)) (T (VALUES (SUBTYPEP COMPILER-TYPE TYPESPEC)))))
     [java] ; (DECLAIM (TYPE HASH-TABLE *FUNCTION-RESULT-TYPES*))
     [java] ; (DEFVAR *FUNCTION-RESULT-TYPES* (MAKE-HASH-TABLE :TEST (QUOTE EQUAL)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) FUNCTION-RESULT-TYPE))
     [java] ; (DEFUN FUNCTION-RESULT-TYPE (NAME) (IF (SYMBOLP NAME) (GET NAME (QUOTE FUNCTION-RESULT-TYPE)) (GETHASH1 NAME *FUNCTION-RESULT-TYPES*)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) SET-FUNCTION-RESULT-TYPE))
     [java] ; (DEFUN SET-FUNCTION-RESULT-TYPE (NAME RESULT-TYPE) (IF (SYMBOLP NAME) (SETF (GET NAME (QUOTE FUNCTION-RESULT-TYPE)) RESULT-TYPE) (SETF (GETHASH NAME *FUNCTION-RESULT-TYPES*) RESULT-TYPE)))
     [java] ; (DEFUN %DEFKNOWN (NAME-OR-NAMES ARGUMENT-TYPES RESULT-TYPE) (LET ((FTYPE (BACKQ-LIST (QUOTE FUNCTION) ARGUMENT-TYPES RESULT-TYPE)) (RESULT-TYPE (MAKE-COMPILER-TYPE RESULT-TYPE))) (COND ((OR (SYMBOLP NAME-OR-NAMES) (SETF-FUNCTION-NAME-P NAME-OR-NAMES)) (PROCLAIM-FTYPE-1 FTYPE NAME-OR-NAMES) (SET-FUNCTION-RESULT-TYPE NAME-OR-NAMES RESULT-TYPE)) (T (PROCLAIM-FTYPE FTYPE NAME-OR-NAMES) (DOLIST (NAME NAME-OR-NAMES) (SET-FUNCTION-RESULT-TYPE NAME RESULT-TYPE))))) NAME-OR-NAMES)
     [java] ; (DEFMACRO DEFKNOWN (NAME-OR-NAMES ARGUMENT-TYPES RESULT-TYPE) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE %DEFKNOWN) (BACKQ-LIST (QUOTE QUOTE) NAME-OR-NAMES) (BACKQ-LIST (QUOTE QUOTE) ARGUMENT-TYPES) (BACKQ-LIST (QUOTE QUOTE) RESULT-TYPE))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-types.abcl (1.348 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-types.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-types.abcl (0.2 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compile-file.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFVAR *FBOUND-NAMES*)
     [java] ; (DEFVAR *CLASS-NUMBER*)
     [java] ; (DEFVAR *OUTPUT-FILE-PATHNAME*)
     [java] ; (DEFVAR *TOPLEVEL-FUNCTIONS*)
     [java] ; (DEFVAR *TOPLEVEL-MACROS*)
     [java] ; (DEFVAR *TOPLEVEL-EXPORTS*)
     [java] ; (DEFVAR *TOPLEVEL-SETF-EXPANDERS*)
     [java] ; (DEFVAR *TOPLEVEL-SETF-FUNCTIONS*)
     [java] ; (DEFUN BASE-CLASSNAME (&OPTIONAL (OUTPUT-FILE-PATHNAME *OUTPUT-FILE-PATHNAME*)) (SANITIZE-CLASS-NAME (PATHNAME-NAME OUTPUT-FILE-PATHNAME)))
     [java] ; (DEFUN FASL-LOADER-CLASSNAME (&OPTIONAL (OUTPUT-FILE-PATHNAME *OUTPUT-FILE-PATHNAME*)) (%FORMAT NIL "~A_0" (BASE-CLASSNAME OUTPUT-FILE-PATHNAME)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) COMPUTE-CLASSFILE))
     [java] ; (DEFUN COMPUTE-CLASSFILE (N &OPTIONAL (OUTPUT-FILE-PATHNAME *OUTPUT-FILE-PATHNAME*)) "Computes the pathname of the class file associated with number `n'." (LET ((NAME (SANITIZE-CLASS-NAME (%FORMAT NIL "~A_~D" (PATHNAME-NAME OUTPUT-FILE-PATHNAME) N)))) (MERGE-PATHNAMES (MAKE-PATHNAME :NAME NAME :TYPE *COMPILE-FILE-CLASS-EXTENSION*) OUTPUT-FILE-PATHNAME)))
     [java] ; (DEFUN SANITIZE-CLASS-NAME (NAME) (LET ((NAME (COPY-SEQ NAME))) (DOTIMES (I (LENGTH NAME)) (DECLARE (TYPE FIXNUM I)) (WHEN (OR (CHAR= (CHAR NAME I) #\-) (CHAR= (CHAR NAME I) #\.) (CHAR= (CHAR NAME I) #\ )) (SETF (CHAR NAME I) #\_))) NAME))
     [java] ; (DECLAIM (FTYPE (FUNCTION NIL T) NEXT-CLASSFILE))
     [java] ; (DEFUN NEXT-CLASSFILE NIL (COMPUTE-CLASSFILE (INCF *CLASS-NUMBER*)))
     [java] ; (DEFMACRO REPORT-ERROR (&REST FORMS) (BACKQ-LIST* (QUOTE HANDLER-CASE) (BACKQ-CONS (QUOTE PROGN) FORMS) (QUOTE ((COMPILER-UNSUPPORTED-FEATURE-ERROR (CONDITION) (FRESH-LINE) (%FORMAT T "; UNSUPPORTED-FEATURE: ~A~%" CONDITION) (VALUES NIL CONDITION))))))
     [java] ; (DEFUN DUMMY (&REST IGNORED) (DECLARE (IGNORE IGNORED)) (ASSERT NIL))
     [java] ; (DEFPARAMETER *COMPILER-DIAGNOSTIC* NIL "The stream to emit compiler diagnostic messages to, or nil to muffle output.")
     [java] ; (DEFMACRO DIAG (FMT &REST ARGS) (BACKQ-LIST (QUOTE FORMAT) (QUOTE *COMPILER-DIAGNOSTIC*) "~&SYSTEM::*COMPILER-DIAGNOSTIC* ~A~&" (BACKQ-LIST* (QUOTE FORMAT) NIL FMT ARGS)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) VERIFY-LOAD))
     [java] ; (DEFUN VERIFY-LOAD (CLASSFILE &KEY (FORCE NIL)) "Return whether the file at the path denoted by CLASSFILE is a loadable JVM artifact." (DECLARE (IGNORE FORCE)) (UNLESS CLASSFILE (DIAG "Nil classfile argument passed to verify-load.") (RETURN-FROM VERIFY-LOAD NIL)) (WITH-OPEN-FILE (CF CLASSFILE :DIRECTION :INPUT) (WHEN (= 0 (FILE-LENGTH CF)) (DIAG "Internal compiler error detected: Fasl contains ~
     [java] zero-length jvm classfile corresponding to ~A." CLASSFILE) (RETURN-FROM VERIFY-LOAD NIL))) T)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) NOTE-TOPLEVEL-FORM))
     [java] ; (DEFUN NOTE-TOPLEVEL-FORM (FORM) (WHEN *COMPILE-PRINT* (FRESH-LINE) (PRINC "; ") (LET ((*PRINT-LENGTH* 2) (*PRINT-LEVEL* 2) (*PRINT-PRETTY* NIL)) (PRIN1 FORM)) (TERPRI)))
     [java] ; (DEFUN OUTPUT-FORM (FORM) (IF *BINARY-FASLS* (PUSH FORM *FORMS-FOR-OUTPUT*) (PROGN (DUMP-FORM FORM *FASL-STREAM*) (%STREAM-TERPRI *FASL-STREAM*))))
     [java] ; (DEFUN FINALIZE-FASL-OUTPUT NIL (WHEN *BINARY-FASLS* (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD)) (*DOUBLE-COLON-PACKAGE-SEPARATORS* T)) (DUMP-FORM (CONVERT-TOPLEVEL-FORM (LIST* (QUOTE PROGN) (NREVERSE *FORMS-FOR-OUTPUT*)) T) *FASL-STREAM*)) (%STREAM-TERPRI *FASL-STREAM*)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) SIMPLE-TOPLEVEL-FORM-P))
     [java] ; (DEFUN SIMPLE-TOPLEVEL-FORM-P (FORM) "Returns NIL if the form is too complex to become an
     [java] interpreted toplevel form, non-NIL if it is 'simple enough'." (AND (CONSP FORM) (EVERY (FUNCTION (LAMBDA (ARG) (OR (AND (ATOM ARG) (NOT (AND (SYMBOLP ARG) (SYMBOL-MACRO-P ARG)))) (AND (CONSP ARG) (EQ (QUOTE QUOTE) (CAR ARG)))))) (CDR FORM))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) CONVERT-TOPLEVEL-FORM))
     [java] ; (DEFUN CONVERT-TOPLEVEL-FORM (FORM DECLARE-INLINE) (WHEN (OR (SIMPLE-TOPLEVEL-FORM-P FORM) (AND (EQ (CAR FORM) (QUOTE SETQ)) (SIMPLE-TOPLEVEL-FORM-P (THIRD FORM)))) (RETURN-FROM CONVERT-TOPLEVEL-FORM (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))) (LET* ((TOPLEVEL-FORM (THIRD FORM)) (EXPR (BACKQ-LIST (QUOTE LAMBDA) NIL FORM)) (SAVED-CLASS-NUMBER *CLASS-NUMBER*) (CLASSFILE (NEXT-CLASSFILE)) (RESULT (WITH-OPEN-FILE (F CLASSFILE :DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE) (REPORT-ERROR (JVM:COMPILE-DEFUN NIL EXPR *COMPILE-FILE-ENVIRONMENT* CLASSFILE F DECLARE-INLINE)))) (COMPILED-FUNCTION (VERIFY-LOAD CLASSFILE))) (DECLARE (IGNORE TOPLEVEL-FORM RESULT)) (PROGN (SETF FORM (IF COMPILED-FUNCTION (BACKQ-LIST (QUOTE FUNCALL) (BACKQ-LIST (QUOTE GET-FASL-FUNCTION) (QUOTE *FASL-LOADER*) SAVED-CLASS-NUMBER)) (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM T) T) PROCESS-PROGN))
     [java] ; (DEFUN PROCESS-PROGN (FORMS STREAM COMPILE-TIME-TOO) (DOLIST (FORM FORMS) (PROCESS-TOPLEVEL-FORM FORM STREAM COMPILE-TIME-TOO)) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-FORM))
     [java] ; (DEFUN PRECOMPILE-TOPLEVEL-FORM (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (LET ((FORM (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))) (WHEN COMPILE-TIME-TOO (EVAL FORM)) FORM))
     [java] ; (DEFUN PROCESS-TOPLEVEL-MACROLET (FORM STREAM COMPILE-TIME-TOO) (LET ((*COMPILE-FILE-ENVIRONMENT* (MAKE-ENVIRONMENT *COMPILE-FILE-ENVIRONMENT*))) (DOLIST (DEFINITION (CADR FORM)) (ENVIRONMENT-ADD-MACRO-DEFINITION *COMPILE-FILE-ENVIRONMENT* (CAR DEFINITION) (MAKE-MACRO (CAR DEFINITION) (MAKE-MACRO-EXPANDER DEFINITION)))) (DOLIST (BODY-FORM (CDDR FORM)) (PROCESS-TOPLEVEL-FORM BODY-FORM STREAM COMPILE-TIME-TOO))) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFCONSTANT))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFCONSTANT (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (NOTE-TOPLEVEL-FORM FORM) (EVAL FORM) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) (SECOND FORM)) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (SECOND FORM) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) (SECOND FORM)) (QUOTE ((QUOTE SOURCE) NIL))))) FORM))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-QUOTE))
     [java] ; (DEFUN PROCESS-TOPLEVEL-QUOTE (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (WHEN COMPILE-TIME-TOO (EVAL FORM)) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-IMPORT))
     [java] ; (DEFUN PROCESS-TOPLEVEL-IMPORT (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (LET ((FORM (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))) (LET ((*PACKAGE* +KEYWORD-PACKAGE+)) (OUTPUT-FORM FORM)) (WHEN COMPILE-TIME-TOO (EVAL FORM))) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-EXPORT))
     [java] ; (DEFUN PROCESS-TOPLEVEL-EXPORT (FORM STREAM COMPILE-TIME-TOO) (WHEN (AND (LISTP (SECOND FORM)) (EQ (CAR (SECOND FORM)) (QUOTE QUOTE))) (LET ((SYM-OR-SYMS (SECOND (SECOND FORM)))) (SETF *TOPLEVEL-EXPORTS* (APPEND *TOPLEVEL-EXPORTS* (IF (LISTP SYM-OR-SYMS) SYM-OR-SYMS (LIST SYM-OR-SYMS)))))) (PRECOMPILE-TOPLEVEL-FORM FORM STREAM COMPILE-TIME-TOO))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-RECORD-SOURCE-INFORMATION))
     [java] ; (DEFUN PROCESS-RECORD-SOURCE-INFORMATION (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (LET* ((NAME (SECOND FORM)) (TYPE (THIRD FORM))) (WHEN (QUOTED-FORM-P NAME) (SETQ NAME (SECOND NAME))) (WHEN (QUOTED-FORM-P TYPE) (SETQ TYPE (SECOND TYPE))) (LET ((SYM (IF (CONSP NAME) (SECOND NAME) NAME))) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST TYPE (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE ((QUOTE SOURCE) NIL))))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-MOP.ENSURE-METHOD))
     [java] ; (DEFUN PROCESS-TOPLEVEL-MOP.ENSURE-METHOD (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (FLET ((CONVERT-ENSURE-METHOD (FORM KEY) (LET* ((TAIL (CDDR FORM)) (FUNCTION-FORM (GETF TAIL KEY))) (WHEN (AND FUNCTION-FORM (CONSP FUNCTION-FORM) (EQ (%CAR FUNCTION-FORM) (QUOTE FUNCTION))) (LET ((LAMBDA-EXPRESSION (CADR FUNCTION-FORM))) (JVM::WITH-SAVED-COMPILER-POLICY (LET* ((SAVED-CLASS-NUMBER *CLASS-NUMBER*) (CLASSFILE (NEXT-CLASSFILE)) (RESULT (WITH-OPEN-FILE (F CLASSFILE :DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE) (REPORT-ERROR (JVM:COMPILE-DEFUN NIL LAMBDA-EXPRESSION *COMPILE-FILE-ENVIRONMENT* CLASSFILE F NIL)))) (COMPILED-FUNCTION (VERIFY-LOAD CLASSFILE))) (DECLARE (IGNORE RESULT)) (COND (COMPILED-FUNCTION (SETF (GETF TAIL KEY) (BACKQ-LIST (QUOTE GET-FASL-FUNCTION) (QUOTE *FASL-LOADER*) SAVED-CLASS-NUMBER))) (T (FORMAT *ERROR-OUTPUT* "; Unable to compile method~%")))))))))) (WHEN COMPILE-TIME-TOO (LET* ((COPY-FORM (COPY-TREE FORM)) (PRECOMPILED-FORM (PRECOMPILER:PRECOMPILE-FORM COPY-FORM NIL *COMPILE-FILE-ENVIRONMENT*))) (EVAL PRECOMPILED-FORM))) (CONVERT-ENSURE-METHOD FORM :FUNCTION) (CONVERT-ENSURE-METHOD FORM :FAST-FUNCTION)) (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFVAR/DEFPARAMETER))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFVAR/DEFPARAMETER (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (NOTE-TOPLEVEL-FORM FORM) (IF COMPILE-TIME-TOO (EVAL FORM) (LET ((NAME (SECOND FORM))) (%DEFVAR NAME))) (LET ((NAME (SECOND FORM))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE LIST) (QUOTE :VARIABLE) (NAMESTRING *SOURCE*) *SOURCE-POSITION*) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE SOURCE) NIL))))) FORM)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFPACKAGE/IN-PACKAGE))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFPACKAGE/IN-PACKAGE (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (NOTE-TOPLEVEL-FORM FORM) (LET ((DEFPACKAGE-NAME (AND (EQ (CAR FORM) (QUOTE DEFPACKAGE)) (INTERN (STRING (SECOND FORM)) :KEYWORD)))) (SETF FORM (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*)) (EVAL FORM) (LET ((*PACKAGE* +KEYWORD-PACKAGE+)) (OUTPUT-FORM FORM)) (IF DEFPACKAGE-NAME (BACKQ-LIST (QUOTE PUT) DEFPACKAGE-NAME (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :PACKAGE) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) DEFPACKAGE-NAME (QUOTE ((QUOTE SOURCE) NIL))))) NIL)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DECLARE))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DECLARE (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (COMPILER-STYLE-WARN "Misplaced declaration: ~S" FORM) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-PROGN))
     [java] ; (DEFUN PROCESS-TOPLEVEL-PROGN (FORM STREAM COMPILE-TIME-TOO) (PROCESS-PROGN (CDR FORM) STREAM COMPILE-TIME-TOO) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFTYPE))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFTYPE (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (NOTE-TOPLEVEL-FORM FORM) (EVAL FORM) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) (SECOND FORM)) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (SECOND FORM) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) (SECOND FORM)) (QUOTE ((QUOTE SOURCE) NIL))))) FORM))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-EVAL-WHEN))
     [java] ; (DEFUN PROCESS-TOPLEVEL-EVAL-WHEN (FORM STREAM COMPILE-TIME-TOO) (FLET ((PARSE-EVAL-WHEN-SITUATIONS (SITUATIONS) "Parse an EVAL-WHEN situations list, returning three flags,
     [java]             (VALUES COMPILE-TOPLEVEL LOAD-TOPLEVEL EXECUTE), indicating
     [java]             the types of situations present in the list." (WHEN (OR (NOT (LISTP SITUATIONS)) (SET-DIFFERENCE SITUATIONS (QUOTE (:COMPILE-TOPLEVEL COMPILE :LOAD-TOPLEVEL LOAD :EXECUTE EVAL)))) (ERROR "Bad EVAL-WHEN situation list: ~S." SITUATIONS)) (VALUES (INTERSECTION (QUOTE (:COMPILE-TOPLEVEL COMPILE)) SITUATIONS) (INTERSECTION (QUOTE (:LOAD-TOPLEVEL LOAD)) SITUATIONS) (INTERSECTION (QUOTE (:EXECUTE EVAL)) SITUATIONS)))) (MULTIPLE-VALUE-BIND (CT LT E) (PARSE-EVAL-WHEN-SITUATIONS (CADR FORM)) (LET ((NEW-COMPILE-TIME-TOO (OR CT (AND COMPILE-TIME-TOO E))) (BODY (CDDR FORM))) (IF LT (PROCESS-PROGN BODY STREAM NEW-COMPILE-TIME-TOO) (WHEN NEW-COMPILE-TIME-TOO (EVAL (BACKQ-CONS (QUOTE PROGN) BODY))))))) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFMETHOD/DEFGENERIC))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFMETHOD/DEFGENERIC (FORM STREAM COMPILE-TIME-TOO) (NOTE-TOPLEVEL-FORM FORM) (NOTE-NAME-DEFINED (SECOND FORM)) (PUSH (SECOND FORM) *TOPLEVEL-FUNCTIONS*) (WHEN (AND (CONSP (SECOND FORM)) (EQ (QUOTE SETF) (FIRST (SECOND FORM)))) (PUSH (SECOND (SECOND FORM)) *TOPLEVEL-SETF-FUNCTIONS*)) (LET ((*COMPILE-PRINT* NIL)) (PROCESS-TOPLEVEL-FORM (MACROEXPAND-1 FORM *COMPILE-FILE-ENVIRONMENT*) STREAM COMPILE-TIME-TOO)) (LET* ((SYM (IF (CONSP (SECOND FORM)) (SECOND (SECOND FORM)) (SECOND FORM)))) (WHEN (EQ (CAR FORM) (QUOTE DEFGENERIC)) (BACKQ-LIST* (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (BACKQ-LIST (QUOTE :GENERIC-FUNCTION) (SECOND FORM)) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE ((QUOTE SOURCE) NIL))))) (LOOP FOR METHOD-FORM IN (CDDDR FORM) WHEN (EQ (CAR METHOD-FORM) :METHOD) COLLECT (MULTIPLE-VALUE-BIND (FUNCTION-NAME QUALIFIERS LAMBDA-LIST SPECIALIZERS DOCUMENTATION DECLARATIONS BODY) (MOP::PARSE-DEFMETHOD (BACKQ-CONS (SECOND FORM) (REST METHOD-FORM))) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE BACKQ-LIST) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :METHOD) SYM QUALIFIERS SPECIALIZERS)) (NAMESTRING *SOURCE*) *SOURCE-POSITION*) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE ((QUOTE SOURCE) NIL)))))))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-LOCALLY))
     [java] ; (DEFUN PROCESS-TOPLEVEL-LOCALLY (FORM STREAM COMPILE-TIME-TOO) (JVM::WITH-SAVED-COMPILER-POLICY (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY (CDR FORM) NIL) (PROCESS-OPTIMIZATION-DECLARATIONS DECLS) (LET* ((JVM::*VISIBLE-VARIABLES* JVM::*VISIBLE-VARIABLES*) (SPECIALS (JVM::PROCESS-DECLARATIONS-FOR-VARS (CDR FORM) NIL NIL))) (DOLIST (SPECIAL SPECIALS) (PUSH SPECIAL JVM::*VISIBLE-VARIABLES*)) (PROCESS-PROGN FORMS STREAM COMPILE-TIME-TOO)))) NIL)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFMACRO))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFMACRO (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM COMPILE-TIME-TOO)) (NOTE-TOPLEVEL-FORM FORM) (LET ((NAME (SECOND FORM))) (EVAL FORM) (PUSH NAME *TOPLEVEL-MACROS*) (LET* ((EXPR (FUNCTION-LAMBDA-EXPRESSION (MACRO-FUNCTION NAME))) (SAVED-CLASS-NUMBER *CLASS-NUMBER*) (CLASSFILE (NEXT-CLASSFILE))) (WITH-OPEN-FILE (F CLASSFILE :DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE) (IGNORE-ERRORS (JVM:COMPILE-DEFUN NIL EXPR *COMPILE-FILE-ENVIRONMENT* CLASSFILE F NIL))) (WHEN (NULL (VERIFY-LOAD CLASSFILE)) (FORMAT *ERROR-OUTPUT* "; Unable to compile macro ~A~%" NAME) (RETURN-FROM PROCESS-TOPLEVEL-DEFMACRO FORM)) (IF (SPECIAL-OPERATOR-P NAME) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE MACROEXPAND-MACRO)) (BACKQ-LIST (QUOTE MAKE-MACRO) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE GET-FASL-FUNCTION) (QUOTE *FASL-LOADER*) SAVED-CLASS-NUMBER))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :MACRO) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE SOURCE) NIL))))) (BACKQ-LIST (QUOTE FSET) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE MAKE-MACRO) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE GET-FASL-FUNCTION) (QUOTE *FASL-LOADER*) SAVED-CLASS-NUMBER)) *SOURCE-POSITION* (BACKQ-LIST (QUOTE QUOTE) (THIRD FORM)) (%DOCUMENTATION NAME (QUOTE FUNCTION))))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) PROCESS-TOPLEVEL-DEFUN))
     [java] ; (DEFUN PROCESS-TOPLEVEL-DEFUN (FORM STREAM COMPILE-TIME-TOO) (DECLARE (IGNORE STREAM)) (NOTE-TOPLEVEL-FORM FORM) (LET* ((NAME (SECOND FORM)) (BLOCK-NAME (FDEFINITION-BLOCK-NAME NAME)) (LAMBDA-LIST (THIRD FORM)) (BODY (NTHCDR 3 FORM))) (JVM::WITH-SAVED-COMPILER-POLICY (MULTIPLE-VALUE-BIND (BODY DECLS DOC) (PARSE-BODY BODY) (LET* ((EXPR (BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST* (QUOTE BLOCK) BLOCK-NAME BODY))))) (SAVED-CLASS-NUMBER *CLASS-NUMBER*) (CLASSFILE (NEXT-CLASSFILE)) (INTERNAL-COMPILER-ERRORS NIL) (RESULT (WITH-OPEN-FILE (F CLASSFILE :DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE) (HANDLER-BIND ((INTERNAL-COMPILER-ERROR (FUNCTION (LAMBDA (E) (PUSH E INTERNAL-COMPILER-ERRORS) (CONTINUE))))) (REPORT-ERROR (JVM:COMPILE-DEFUN NAME EXPR *COMPILE-FILE-ENVIRONMENT* CLASSFILE F NIL))))) (COMPILED-FUNCTION (IF (NOT INTERNAL-COMPILER-ERRORS) (VERIFY-LOAD CLASSFILE) NIL))) (DECLARE (IGNORE RESULT)) (COND ((AND (NOT INTERNAL-COMPILER-ERRORS) COMPILED-FUNCTION) (WHEN COMPILE-TIME-TOO (EVAL FORM)) (LET ((SYM (IF (CONSP NAME) (SECOND NAME) NAME))) (SETF FORM (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE (QUOTE SOURCE)) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (BACKQ-LIST (QUOTE :FUNCTION) NAME) (NAMESTRING *SOURCE*) *SOURCE-POSITION*)) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) SYM) (QUOTE ((QUOTE SOURCE) NIL))))) (BACKQ-LIST (QUOTE FSET) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE GET-FASL-FUNCTION) (QUOTE *FASL-LOADER*) SAVED-CLASS-NUMBER) *SOURCE-POSITION* (BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) DOC))))) (T (COMPILER-WARN "Unable to compile function ~A.  Using interpreted form instead.~%" NAME) (WHEN INTERNAL-COMPILER-ERRORS (DOLIST (E INTERNAL-COMPILER-ERRORS) (FORMAT *ERROR-OUTPUT* "; ~A~%" E))) (LET ((PRECOMPILED-FUNCTION (PRECOMPILER:PRECOMPILE-FORM EXPR NIL *COMPILE-FILE-ENVIRONMENT*))) (SETF FORM (BACKQ-LIST (QUOTE FSET) (BACKQ-LIST (QUOTE QUOTE) NAME) PRECOMPILED-FUNCTION *SOURCE-POSITION* (BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) DOC))) (WHEN COMPILE-TIME-TOO (EVAL FORM))))) (WHEN (AND (SYMBOLP NAME) (EQ (GET NAME (QUOTE %INLINE)) (QUOTE INLINE))) (SETF (INLINE-EXPANSION NAME) (JVM::GENERATE-INLINE-EXPANSION BLOCK-NAME LAMBDA-LIST (APPEND DECLS BODY))) (OUTPUT-FORM (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE INLINE-EXPANSION) (BACKQ-LIST (QUOTE QUOTE) NAME)) (BACKQ-LIST (QUOTE QUOTE) (INLINE-EXPANSION NAME))))))) (PUSH NAME JVM::*FUNCTIONS-DEFINED-IN-CURRENT-FILE*) (NOTE-NAME-DEFINED NAME) (PUSH NAME *TOPLEVEL-FUNCTIONS*) (WHEN (AND (CONSP NAME) (EQ (QUOTE SETF) (FIRST NAME))) (PUSH (SECOND NAME) *TOPLEVEL-SETF-FUNCTIONS*)) (UNLESS (FBOUNDP NAME) (SETF (FDEFINITION NAME) (FUNCTION DUMMY)) (PUSH NAME *FBOUND-NAMES*))) FORM)
     [java] ; (DEFUN INSTALL-TOPLEVEL-HANDLER (SYMBOL HANDLER) (SETF (GET SYMBOL (QUOTE TOPLEVEL-HANDLER)) HANDLER))
     [java] ; (DOLIST (PAIR (QUOTE ((COMPILER-DEFSTRUCT PRECOMPILE-TOPLEVEL-FORM) (DECLARE PROCESS-TOPLEVEL-DECLARE) (DEFCONSTANT PROCESS-TOPLEVEL-DEFCONSTANT) (DEFGENERIC PROCESS-TOPLEVEL-DEFMETHOD/DEFGENERIC) (DEFMACRO PROCESS-TOPLEVEL-DEFMACRO) (DEFMETHOD PROCESS-TOPLEVEL-DEFMETHOD/DEFGENERIC) (DEFPACKAGE PROCESS-TOPLEVEL-DEFPACKAGE/IN-PACKAGE) (DEFPARAMETER PROCESS-TOPLEVEL-DEFVAR/DEFPARAMETER) (DEFTYPE PROCESS-TOPLEVEL-DEFTYPE) (DEFUN PROCESS-TOPLEVEL-DEFUN) (DEFVAR PROCESS-TOPLEVEL-DEFVAR/DEFPARAMETER) (EVAL-WHEN PROCESS-TOPLEVEL-EVAL-WHEN) (EXPORT PROCESS-TOPLEVEL-EXPORT) (IMPORT PROCESS-TOPLEVEL-IMPORT) (IN-PACKAGE PROCESS-TOPLEVEL-DEFPACKAGE/IN-PACKAGE) (LOCALLY PROCESS-TOPLEVEL-LOCALLY) (MACROLET PROCESS-TOPLEVEL-MACROLET) (PROCLAIM PRECOMPILE-TOPLEVEL-FORM) (PROGN PROCESS-TOPLEVEL-PROGN) (PROVIDE PRECOMPILE-TOPLEVEL-FORM) (PUT PRECOMPILE-TOPLEVEL-FORM) (QUOTE PROCESS-TOPLEVEL-QUOTE) (REQUIRE PRECOMPILE-TOPLEVEL-FORM) (SHADOW PRECOMPILE-TOPLEVEL-FORM) (%SET-FDEFINITION PRECOMPILE-TOPLEVEL-FORM) (MOP::ENSURE-METHOD PROCESS-TOPLEVEL-MOP.ENSURE-METHOD) (RECORD-SOURCE-INFORMATION-FOR-TYPE PROCESS-RECORD-SOURCE-INFORMATION)))) (INSTALL-TOPLEVEL-HANDLER (CAR PAIR) (CADR PAIR)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T STREAM T) T) PROCESS-TOPLEVEL-FORM))
     [java] ; (DEFUN PROCESS-TOPLEVEL-FORM (FORM STREAM COMPILE-TIME-TOO) (UNLESS (ATOM FORM) (LET* ((OPERATOR (%CAR FORM)) (HANDLER (GET OPERATOR (QUOTE TOPLEVEL-HANDLER)))) (WHEN HANDLER (LET ((OUT-FORM (FUNCALL HANDLER FORM STREAM COMPILE-TIME-TOO))) (WHEN OUT-FORM (OUTPUT-FORM OUT-FORM))) (RETURN-FROM PROCESS-TOPLEVEL-FORM)) (WHEN (AND (SYMBOLP OPERATOR) (MACRO-FUNCTION OPERATOR *COMPILE-FILE-ENVIRONMENT*)) (WHEN (EQ OPERATOR (QUOTE DEFINE-SETF-EXPANDER)) (PUSH (SECOND FORM) *TOPLEVEL-SETF-EXPANDERS*)) (WHEN (AND (EQ OPERATOR (QUOTE DEFSETF)) (CONSP (THIRD FORM))) (PUSH (SECOND FORM) *TOPLEVEL-SETF-EXPANDERS*)) (NOTE-TOPLEVEL-FORM FORM) (LET ((*COMPILE-PRINT* NIL)) (PROCESS-TOPLEVEL-FORM (MACROEXPAND-1 FORM *COMPILE-FILE-ENVIRONMENT*) STREAM COMPILE-TIME-TOO)) (RETURN-FROM PROCESS-TOPLEVEL-FORM)) (COND ((AND (SYMBOLP OPERATOR) (NOT (SPECIAL-OPERATOR-P OPERATOR)) (NULL (CDR FORM))) (SETF FORM (PRECOMPILER:PRECOMPILE-FORM FORM NIL *COMPILE-FILE-ENVIRONMENT*))) (T (NOTE-TOPLEVEL-FORM FORM) (SETF FORM (CONVERT-TOPLEVEL-FORM FORM NIL))))) (WHEN (CONSP FORM) (OUTPUT-FORM FORM))) (WHEN COMPILE-TIME-TOO (LET ((*LOAD-TRUENAME* *OUTPUT-FILE-PATHNAME*) (*FASL-LOADER* (MAKE-FASL-CLASS-LOADER (CONCATENATE (QUOTE STRING) "org.armedbear.lisp." (BASE-CLASSNAME))))) (EVAL FORM))))
     [java] ; (DEFUN POPULATE-ZIP-FASL (OUTPUT-FILE) (LET* ((TYPE (%FORMAT NIL "~A~A" (PATHNAME-TYPE OUTPUT-FILE) "-zip")) (OUTPUT-FILE (IF (LOGICAL-PATHNAME-P OUTPUT-FILE) (TRANSLATE-LOGICAL-PATHNAME OUTPUT-FILE) OUTPUT-FILE)) (ZIPFILE (IF (FIND :WINDOWS *FEATURES*) (MAKE-PATHNAME :DEFAULTS OUTPUT-FILE :TYPE TYPE) (MAKE-PATHNAME :DEFAULTS OUTPUT-FILE :TYPE TYPE :DEVICE :UNSPECIFIC))) (PATHNAMES NIL) (FASL-LOADER (MAKE-PATHNAME :DEFAULTS OUTPUT-FILE :NAME (FASL-LOADER-CLASSNAME) :TYPE *COMPILE-FILE-CLASS-EXTENSION*))) (WHEN (PROBE-FILE FASL-LOADER) (PUSH FASL-LOADER PATHNAMES)) (DOTIMES (I *CLASS-NUMBER*) (LET ((TRUENAME (PROBE-FILE (COMPUTE-CLASSFILE (1+ I))))) (WHEN TRUENAME (PUSH TRUENAME PATHNAMES) (WHEN (PROBE-FILE (MAKE-PATHNAME :NAME (FORMAT NIL "~A_0" (PATHNAME-NAME TRUENAME)) :TYPE "clc" :DEFAULTS TRUENAME)) (DOLIST (RESOURCE (DIRECTORY (MAKE-PATHNAME :NAME (FORMAT NIL "~A_*" (PATHNAME-NAME TRUENAME)) :TYPE "clc" :DEFAULTS TRUENAME))) (PUSH RESOURCE PATHNAMES)))))) (SETF PATHNAMES (NREVERSE (REMOVE NIL PATHNAMES))) (LET ((LOAD-FILE (MAKE-PATHNAME :DEFAULTS OUTPUT-FILE :NAME "__loader__" :TYPE "_"))) (RENAME-FILE OUTPUT-FILE LOAD-FILE) (PUSH LOAD-FILE PATHNAMES)) (ZIP ZIPFILE PATHNAMES) (DOLIST (PATHNAME PATHNAMES) (IGNORE-ERRORS (DELETE-FILE PATHNAME))) (RENAME-FILE ZIPFILE OUTPUT-FILE)))
     [java] ; (DEFUN WRITE-FASL-PROLOGUE (STREAM) (LET ((OUT STREAM)) (WRITE "; -*- Mode: Lisp -*-" :ESCAPE NIL :STREAM OUT) (%STREAM-TERPRI OUT) (WRITE (LIST (QUOTE INIT-FASL) :VERSION *FASL-VERSION*) :STREAM OUT) (%STREAM-TERPRI OUT) (WRITE (LIST (QUOTE SETQ) (QUOTE *SOURCE*) *COMPILE-FILE-TRUENAME*) :STREAM OUT) (%STREAM-TERPRI OUT) (WHEN *FASL-UNINTERNED-SYMBOLS* (WRITE (LIST (QUOTE SETQ) (QUOTE *FASL-UNINTERNED-SYMBOLS*) (COERCE (MAPCAR (FUNCTION CAR) (NREVERSE *FASL-UNINTERNED-SYMBOLS*)) (QUOTE VECTOR))) :STREAM OUT :LENGTH NIL)) (%STREAM-TERPRI OUT) (WHEN (> *CLASS-NUMBER* 0) (WRITE (LIST (QUOTE SETQ) (QUOTE *FASL-LOADER*) (BACKQ-LIST (QUOTE MAKE-FASL-CLASS-LOADER) (CONCATENATE (QUOTE STRING) "org.armedbear.lisp." (BASE-CLASSNAME)))) :STREAM OUT)) (%STREAM-TERPRI OUT)))
     [java] ; (DEFVAR *BINARY-FASLS* NIL)
     [java] ; (DEFVAR *FORMS-FOR-OUTPUT* NIL)
     [java] ; (DEFVAR *FASL-STREAM* NIL)
     [java] ; (DEFUN COMPILE-FROM-STREAM (IN OUTPUT-FILE TEMP-FILE TEMP-FILE2 EXTRACT-TOPLEVEL-FUNCS-AND-MACROS FUNCTIONS-FILE MACROS-FILE EXPORTS-FILE SETF-FUNCTIONS-FILE SETF-EXPANDERS-FILE) (LET* ((*COMPILE-FILE-PATHNAME* (MAKE-PATHNAME :DEFAULTS (PATHNAME IN) :VERSION NIL)) (*COMPILE-FILE-TRUENAME* (MAKE-PATHNAME :DEFAULTS (TRUENAME IN) :VERSION NIL)) (*SOURCE* *COMPILE-FILE-TRUENAME*) (*CLASS-NUMBER* 0) (NAMESTRING (NAMESTRING *COMPILE-FILE-TRUENAME*)) (START (GET-INTERNAL-REAL-TIME)) *FASL-UNINTERNED-SYMBOLS* (WARNINGS-P NIL) (FAILURE-P NIL)) (WHEN *COMPILE-VERBOSE* (FORMAT T "; Compiling ~A ...~%" NAMESTRING)) (WITH-COMPILATION-UNIT NIL (WITH-OPEN-FILE (OUT TEMP-FILE :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE :EXTERNAL-FORMAT *FASL-EXTERNAL-FORMAT*) (LET ((*READTABLE* *READTABLE*) (*READ-DEFAULT-FLOAT-FORMAT* *READ-DEFAULT-FLOAT-FORMAT*) (*READ-BASE* *READ-BASE*) (*PACKAGE* *PACKAGE*) (JVM::*FUNCTIONS-DEFINED-IN-CURRENT-FILE* (QUOTE NIL)) (*FBOUND-NAMES* (QUOTE NIL)) (*FASL-STREAM* OUT) *FORMS-FOR-OUTPUT*) (JVM::WITH-SAVED-COMPILER-POLICY (JVM::WITH-FILE-COMPILATION (HANDLER-BIND ((STYLE-WARNING (FUNCTION (LAMBDA (C) (SETF WARNINGS-P T) (SIGNAL C) (CONTINUE)))) ((OR WARNING COMPILER-ERROR) (FUNCTION (LAMBDA (C) (DECLARE (IGNORE C)) (SETF WARNINGS-P T FAILURE-P T))))) (LOOP (LET* ((*SOURCE-POSITION* (FILE-POSITION IN)) (JVM::*SOURCE-LINE-NUMBER* (STREAM-LINE-NUMBER IN)) (FORM (READ IN NIL IN)) (*COMPILER-ERROR-CONTEXT* FORM)) (WHEN (EQ FORM IN) (RETURN)) (PROCESS-TOPLEVEL-FORM FORM OUT NIL)))) (FINALIZE-FASL-OUTPUT) (DOLIST (NAME *FBOUND-NAMES*) (FMAKUNBOUND NAME))))))) (WHEN EXTRACT-TOPLEVEL-FUNCS-AND-MACROS (SETF *TOPLEVEL-FUNCTIONS* (REMOVE-IF-NOT (LAMBDA (FUNC-NAME) (IF (SYMBOLP FUNC-NAME) (SYMBOL-PACKAGE FUNC-NAME) T)) (REMOVE-DUPLICATES *TOPLEVEL-FUNCTIONS*))) (WHEN *TOPLEVEL-FUNCTIONS* (WITH-OPEN-FILE (F-OUT FUNCTIONS-FILE :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (WRITE *TOPLEVEL-FUNCTIONS* :STREAM F-OUT)))) (SETF *TOPLEVEL-MACROS* (REMOVE-IF-NOT (LAMBDA (MAC-NAME) (IF (SYMBOLP MAC-NAME) (SYMBOL-PACKAGE MAC-NAME) T)) (REMOVE-DUPLICATES *TOPLEVEL-MACROS*))) (WHEN *TOPLEVEL-MACROS* (WITH-OPEN-FILE (M-OUT MACROS-FILE :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (WRITE *TOPLEVEL-MACROS* :STREAM M-OUT)))) (SETF *TOPLEVEL-EXPORTS* (REMOVE-IF-NOT (LAMBDA (SYM) (IF (SYMBOLP SYM) (SYMBOL-PACKAGE SYM) T)) (REMOVE-DUPLICATES *TOPLEVEL-EXPORTS*))) (WHEN *TOPLEVEL-EXPORTS* (WITH-OPEN-FILE (E-OUT EXPORTS-FILE :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (WRITE *TOPLEVEL-EXPORTS* :STREAM E-OUT)))) (SETF *TOPLEVEL-SETF-FUNCTIONS* (REMOVE-IF-NOT (LAMBDA (SYM) (IF (SYMBOLP SYM) (SYMBOL-PACKAGE SYM) T)) (REMOVE-DUPLICATES *TOPLEVEL-SETF-FUNCTIONS*))) (WHEN *TOPLEVEL-SETF-FUNCTIONS* (WITH-OPEN-FILE (E-OUT SETF-FUNCTIONS-FILE :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (WRITE *TOPLEVEL-SETF-FUNCTIONS* :STREAM E-OUT)))) (SETF *TOPLEVEL-SETF-EXPANDERS* (REMOVE-IF-NOT (LAMBDA (SYM) (IF (SYMBOLP SYM) (SYMBOL-PACKAGE SYM) T)) (REMOVE-DUPLICATES *TOPLEVEL-SETF-EXPANDERS*))) (WHEN *TOPLEVEL-SETF-EXPANDERS* (WITH-OPEN-FILE (E-OUT SETF-EXPANDERS-FILE :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (WRITE *TOPLEVEL-SETF-EXPANDERS* :STREAM E-OUT))))) (WITH-OPEN-FILE (IN TEMP-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT *FASL-EXTERNAL-FORMAT*) (WITH-OPEN-FILE (OUT TEMP-FILE2 :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE :EXTERNAL-FORMAT *FASL-EXTERNAL-FORMAT*) (LET ((*PACKAGE* (FIND-PACKAGE (QUOTE #:CL))) (*PRINT-FASL* T) (*PRINT-ARRAY* T) (*PRINT-BASE* 10) (*PRINT-CASE* :UPCASE) (*PRINT-CIRCLE* NIL) (*PRINT-ESCAPE* T) (*PRINT-GENSYM* T) (*PRINT-LENGTH* NIL) (*PRINT-LEVEL* NIL) (*PRINT-LINES* NIL) (*PRINT-PRETTY* NIL) (*PRINT-RADIX* NIL) (*PRINT-READABLY* T) (*PRINT-RIGHT-MARGIN* NIL) (*PRINT-STRUCTURE* T) (*READ-DEFAULT-FLOAT-FORMAT* NIL)) (WRITE-FASL-PROLOGUE OUT) (LOOP FOR LINE = (READ-LINE IN NIL :EOF) WHILE (NOT (EQ LINE :EOF)) DO (WRITE-LINE LINE OUT))))) (DELETE-FILE TEMP-FILE) (WHEN (FIND :WINDOWS *FEATURES*) (REMOVE-ZIP-CACHE-ENTRY OUTPUT-FILE)) (RENAME-FILE TEMP-FILE2 OUTPUT-FILE) (WHEN *COMPILE-FILE-ZIP* (POPULATE-ZIP-FASL OUTPUT-FILE)) (WHEN *COMPILE-VERBOSE* (FORMAT T "~&; Wrote ~A (~A seconds)~%" (NAMESTRING OUTPUT-FILE) (/ (- (GET-INTERNAL-REAL-TIME) START) 1000.0f0))) (VALUES (TRUENAME OUTPUT-FILE) WARNINGS-P FAILURE-P)))
     [java] ; (DEFUN COMPILE-FILE (INPUT-FILE &KEY OUTPUT-FILE ((:VERBOSE *COMPILE-VERBOSE*) *COMPILE-VERBOSE*) ((:PRINT *COMPILE-PRINT*) *COMPILE-PRINT*) (EXTRACT-TOPLEVEL-FUNCS-AND-MACROS NIL) (EXTERNAL-FORMAT :UTF-8)) (FLET ((PATHNAME-WITH-TYPE (PATHNAME TYPE &OPTIONAL SUFFIX) (WHEN SUFFIX (SETQ TYPE (CONCATENATE (QUOTE STRING) TYPE SUFFIX))) (MAKE-PATHNAME :TYPE TYPE :DEFAULTS PATHNAME))) (UNLESS (OR (AND (PROBE-FILE INPUT-FILE) (NOT (FILE-DIRECTORY-P INPUT-FILE))) (PATHNAME-TYPE INPUT-FILE)) (LET ((PATHNAME (PATHNAME-WITH-TYPE INPUT-FILE *LISP-FILE-TYPE*))) (WHEN (PROBE-FILE PATHNAME) (SETF INPUT-FILE PATHNAME)))) (SETF OUTPUT-FILE (MAKE-PATHNAME :DEFAULTS (IF OUTPUT-FILE (MERGE-PATHNAMES OUTPUT-FILE *DEFAULT-PATHNAME-DEFAULTS*) (COMPILE-FILE-PATHNAME INPUT-FILE)) :VERSION NIL)) (LET* ((*OUTPUT-FILE-PATHNAME* OUTPUT-FILE) (TYPE (PATHNAME-TYPE OUTPUT-FILE)) (TEMP-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE TYPE "-tmp")) (TEMP-FILE2 (PATHNAME-WITH-TYPE OUTPUT-FILE TYPE "-tmp2")) (FUNCTIONS-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE "funcs")) (MACROS-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE "macs")) (EXPORTS-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE "exps")) (SETF-FUNCTIONS-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE "setf-functions")) (SETF-EXPANDERS-FILE (PATHNAME-WITH-TYPE OUTPUT-FILE "setf-expanders")) *TOPLEVEL-FUNCTIONS* *TOPLEVEL-MACROS* *TOPLEVEL-EXPORTS* *TOPLEVEL-SETF-FUNCTIONS* *TOPLEVEL-SETF-EXPANDERS*) (WITH-OPEN-FILE (IN INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT) (MULTIPLE-VALUE-BIND (OUTPUT-FILE-TRUENAME WARNINGS-P FAILURE-P) (COMPILE-FROM-STREAM IN OUTPUT-FILE TEMP-FILE TEMP-FILE2 EXTRACT-TOPLEVEL-FUNCS-AND-MACROS FUNCTIONS-FILE MACROS-FILE EXPORTS-FILE SETF-FUNCTIONS-FILE SETF-EXPANDERS-FILE) (VALUES (TRUENAME OUTPUT-FILE) WARNINGS-P FAILURE-P))))))
     [java] ; (DEFUN COMPILE-FILE-IF-NEEDED (INPUT-FILE &REST ALLARGS &KEY FORCE-COMPILE &ALLOW-OTHER-KEYS) (SETF INPUT-FILE (TRUENAME INPUT-FILE)) (COND (FORCE-COMPILE (REMF ALLARGS :FORCE-COMPILE) (APPLY (QUOTE COMPILE-FILE) INPUT-FILE ALLARGS)) (T (LET* ((SOURCE-WRITE-TIME (FILE-WRITE-DATE INPUT-FILE)) (OUTPUT-FILE (OR (GETF ALLARGS :OUTPUT-FILE) (COMPILE-FILE-PATHNAME INPUT-FILE))) (TARGET-WRITE-TIME (AND (PROBE-FILE OUTPUT-FILE) (FILE-WRITE-DATE OUTPUT-FILE)))) (IF (OR (NULL TARGET-WRITE-TIME) (<= TARGET-WRITE-TIME SOURCE-WRITE-TIME)) (APPLY (FUNCTION COMPILE-FILE) INPUT-FILE ALLARGS) OUTPUT-FILE)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compile-file.abcl (4.129 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compile-file.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compile-file.abcl (0.387 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/precompiler.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) PROCESS-OPTIMIZATION-DECLARATIONS))
     [java] ; (DEFUN PROCESS-OPTIMIZATION-DECLARATIONS (FORMS) (DOLIST (FORM FORMS) (UNLESS (AND (CONSP FORM) (EQ (%CAR FORM) (QUOTE DECLARE))) (RETURN)) (DOLIST (DECL (%CDR FORM)) (CASE (CAR DECL) (OPTIMIZE (DOLIST (SPEC (%CDR DECL)) (LET ((VAL 3) (QUALITY SPEC)) (WHEN (CONSP SPEC) (SETF QUALITY (%CAR SPEC) VAL (CADR SPEC))) (WHEN (AND (FIXNUMP VAL) (<= 0 VAL 3)) (CASE QUALITY (SPEED (SETF *SPEED* VAL)) (SAFETY (SETF *SAFETY* VAL)) (DEBUG (SETF *DEBUG* VAL)) (SPACE (SETF *SPACE* VAL)) (COMPILATION-SPEED) (T (COMPILER-WARN "Ignoring unknown optimization quality ~S in ~S." QUALITY DECL))))))) ((INLINE NOTINLINE) (DOLIST (SYMBOL (%CDR DECL)) (PUSH (CONS SYMBOL (%CAR DECL)) *INLINE-DECLARATIONS*))) (:EXPLAIN (DOLIST (SPEC (%CDR DECL)) (LET ((VAL T) (QUALITY SPEC)) (WHEN (CONSP SPEC) (SETF QUALITY (%CAR SPEC)) (WHEN (= (LENGTH SPEC) 2) (SETF VAL (%CADR SPEC)))) (IF VAL (PUSHNEW QUALITY *EXPLAIN*) (SETF *EXPLAIN* (REMOVE QUALITY *EXPLAIN*))))))))) T)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) INLINE-P))
     [java] ; (DEFUN INLINE-P (NAME) (DECLARE (OPTIMIZE SPEED)) (LET ((ENTRY (ASSOC NAME *INLINE-DECLARATIONS* :TEST (FUNCTION EQUAL)))) (IF ENTRY (EQ (CDR ENTRY) (QUOTE INLINE)) (AND (SYMBOLP NAME) (EQ (GET NAME (QUOTE %INLINE)) (QUOTE INLINE))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) NOTINLINE-P))
     [java] ; (DEFUN NOTINLINE-P (NAME) (DECLARE (OPTIMIZE SPEED)) (LET ((ENTRY (ASSOC NAME *INLINE-DECLARATIONS* :TEST (FUNCTION EQUAL)))) (IF ENTRY (EQ (CDR ENTRY) (QUOTE NOTINLINE)) (AND (SYMBOLP NAME) (EQ (GET NAME (QUOTE %INLINE)) (QUOTE NOTINLINE))))))
     [java] ; (DEFUN EXPAND-INLINE (FORM EXPANSION) (LET* ((OP (CAR FORM)) (PROCLAIMED-FTYPE (PROCLAIMED-FTYPE OP)) (ARGS (CDR FORM)) (VARS (CADR EXPANSION)) (VARLIST NIL) NEW-FORM) (DO ((VARS VARS (CDR VARS)) (ARGS ARGS (CDR ARGS))) ((NULL VARS)) (PUSH (LIST (CAR VARS) (CAR ARGS)) VARLIST)) (SETF NEW-FORM (LIST* (QUOTE LET) (NREVERSE VARLIST) (COPY-TREE (CDDR EXPANSION)))) (WHEN PROCLAIMED-FTYPE (LET ((RESULT-TYPE (FTYPE-RESULT-TYPE PROCLAIMED-FTYPE))) (WHEN (AND RESULT-TYPE (NEQ RESULT-TYPE T) (NEQ RESULT-TYPE (QUOTE *))) (SETF NEW-FORM (LIST (QUOTE TRULY-THE) RESULT-TYPE NEW-FORM))))) NEW-FORM))
     [java] ; (DEFINE-COMPILER-MACRO ASSOC (&WHOLE FORM &REST ARGS) (COND ((AND (= (LENGTH ARGS) 4) (EQ (THIRD ARGS) :TEST) (OR (EQUAL (FOURTH ARGS) (QUOTE (QUOTE EQ))) (EQUAL (FOURTH ARGS) (QUOTE (FUNCTION EQ))))) (BACKQ-LIST (QUOTE ASSQ) (FIRST ARGS) (SECOND ARGS))) ((= (LENGTH ARGS) 2) (BACKQ-LIST (QUOTE ASSQL) (FIRST ARGS) (SECOND ARGS))) (T FORM)))
     [java] ; (DEFINE-COMPILER-MACRO MEMBER (&WHOLE FORM &REST ARGS) (LET ((ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS))) (CASE (LENGTH ARGS) (2 (BACKQ-LIST (QUOTE MEMQL) ARG1 ARG2)) (4 (LET ((ARG3 (THIRD ARGS)) (ARG4 (FOURTH ARGS))) (COND ((AND (EQ ARG3 :TEST) (OR (EQUAL ARG4 (QUOTE (QUOTE EQ))) (EQUAL ARG4 (QUOTE (FUNCTION EQ))))) (BACKQ-LIST (QUOTE MEMQ) ARG1 ARG2)) ((AND (EQ ARG3 :TEST) (OR (EQUAL ARG4 (QUOTE (QUOTE EQL))) (EQUAL ARG4 (QUOTE (FUNCTION EQL))) (EQUAL ARG4 (QUOTE (QUOTE CHAR=))) (EQUAL ARG4 (QUOTE (FUNCTION CHAR=))))) (BACKQ-LIST (QUOTE MEMQL) ARG1 ARG2)) (T FORM)))) (T FORM))))
     [java] ; (DEFINE-COMPILER-MACRO SEARCH (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 2) (BACKQ-CONS (QUOTE SIMPLE-SEARCH) ARGS) FORM))
     [java] ; (DEFINE-COMPILER-MACRO IDENTITY (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 1) (BACKQ-LIST (QUOTE PROGN) (CAR ARGS)) FORM))
     [java] ; (DEFUN QUOTED-FORM-P (FORM) (AND (CONSP FORM) (EQ (%CAR FORM) (QUOTE QUOTE)) (= (LENGTH FORM) 2)))
     [java] ; (DEFINE-COMPILER-MACRO EQL (&WHOLE FORM &REST ARGS) (LET ((FIRST (CAR ARGS)) (SECOND (CADR ARGS))) (IF (OR (AND (QUOTED-FORM-P FIRST) (SYMBOLP (CADR FIRST))) (AND (QUOTED-FORM-P SECOND) (SYMBOLP (CADR SECOND)))) (BACKQ-LIST (QUOTE EQ) FIRST SECOND) FORM)))
     [java] ; (DEFINE-COMPILER-MACRO NOT (&WHOLE FORM ARG) (IF (ATOM ARG) FORM (LET ((OP (CASE (CAR ARG) (>= (QUOTE <)) (< (QUOTE >=)) (<= (QUOTE >)) (> (QUOTE <=)) (T NIL)))) (IF (AND OP (= (LENGTH ARG) 3)) (CONS OP (CDR ARG)) FORM))))
     [java] ; (DEFUN PREDICATE-FOR-TYPE (TYPE) (CDR (ASSQ TYPE (QUOTE ((ARRAY . ARRAYP) (ATOM . ATOM) (BIT-VECTOR . BIT-VECTOR-P) (CHARACTER . CHARACTERP) (COMPLEX . COMPLEXP) (CONS . CONSP) (FIXNUM . FIXNUMP) (FLOAT . FLOATP) (FUNCTION . FUNCTIONP) (HASH-TABLE . HASH-TABLE-P) (INTEGER . INTEGERP) (LIST . LISTP) (NULL . NULL) (NUMBER . NUMBERP) (NUMBER . NUMBERP) (PACKAGE . PACKAGEP) (RATIONAL . RATIONALP) (REAL . REALP) (SIMPLE-BIT-VECTOR . SIMPLE-BIT-VECTOR-P) (SIMPLE-STRING . SIMPLE-STRING-P) (SIMPLE-VECTOR . SIMPLE-VECTOR-P) (STREAM . STREAMP) (STRING . STRINGP) (SYMBOL . SYMBOLP))))))
     [java] ; (DEFINE-COMPILER-MACRO TYPEP (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 2) (LET* ((OBJECT (%CAR ARGS)) (TYPE-SPECIFIER (%CADR ARGS)) (TYPE (AND (CONSP TYPE-SPECIFIER) (EQ (%CAR TYPE-SPECIFIER) (QUOTE QUOTE)) (%CADR TYPE-SPECIFIER))) (PREDICATE (AND TYPE (PREDICATE-FOR-TYPE TYPE)))) (IF PREDICATE (BACKQ-LIST PREDICATE OBJECT) (BACKQ-CONS (QUOTE %TYPEP) ARGS))) FORM))
     [java] ; (DEFINE-COMPILER-MACRO SUBTYPEP (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 2) (BACKQ-CONS (QUOTE %SUBTYPEP) ARGS) FORM))
     [java] ; (DEFINE-COMPILER-MACRO FUNCALL (&WHOLE FORM &ENVIRONMENT ENV &REST ARGS) (LET ((CALLEE (CAR ARGS))) (IF (AND (>= *SPEED* *DEBUG*) (CONSP CALLEE) (EQ (%CAR CALLEE) (QUOTE FUNCTION)) (SYMBOLP (CADR CALLEE)) (NOT (SPECIAL-OPERATOR-P (CADR CALLEE))) (NOT (MACRO-FUNCTION (CADR CALLEE) ENV)) (MEMQ (SYMBOL-PACKAGE (CADR CALLEE)) (LIST (FIND-PACKAGE "CL") (FIND-PACKAGE "SYS")))) (BACKQ-CONS (CADR CALLEE) (CDR ARGS)) FORM)))
     [java] ; (DEFINE-COMPILER-MACRO BYTE (SIZE POSITION) (BACKQ-LIST (QUOTE CONS) SIZE POSITION))
     [java] ; (DEFINE-COMPILER-MACRO BYTE-SIZE (BYTESPEC) (BACKQ-LIST (QUOTE CAR) BYTESPEC))
     [java] ; (DEFINE-COMPILER-MACRO BYTE-POSITION (BYTESPEC) (BACKQ-LIST (QUOTE CDR) BYTESPEC))
     [java] ; (DEFINE-SOURCE-TRANSFORM CONCATENATE (&WHOLE FORM RESULT-TYPE &REST SEQUENCES) (IF (EQUAL RESULT-TYPE (QUOTE (QUOTE STRING))) (BACKQ-LIST (QUOTE CONCATENATE-TO-STRING) (BACKQ-CONS (QUOTE LIST) SEQUENCES)) FORM))
     [java] ; (DEFINE-SOURCE-TRANSFORM LDB (&WHOLE FORM BYTESPEC INTEGER) (IF (AND (CONSP BYTESPEC) (EQ (%CAR BYTESPEC) (QUOTE BYTE)) (= (LENGTH BYTESPEC) 3)) (LET ((SIZE (%CADR BYTESPEC)) (POSITION (%CADDR BYTESPEC))) (BACKQ-LIST (QUOTE %LDB) SIZE POSITION INTEGER)) FORM))
     [java] ; (DEFINE-SOURCE-TRANSFORM FIND (&WHOLE FORM ITEM SEQUENCE &KEY FROM-END TEST TEST-NOT START END KEY) (COND ((AND (>= (LENGTH FORM) 3) (NULL START) (NULL END)) (COND ((AND (STRINGP SEQUENCE) (NULL FROM-END) (MEMBER TEST (QUOTE ((FUNCTION EQL) (FUNCTION CHAR=))) :TEST (FUNCTION EQUAL)) (NULL TEST-NOT) (NULL KEY)) (BACKQ-LIST (QUOTE STRING-FIND) ITEM SEQUENCE)) (T (LET ((ITEM-VAR (GENSYM)) (SEQ-VAR (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST ITEM-VAR ITEM) (BACKQ-LIST SEQ-VAR SEQUENCE)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE LISTP) SEQ-VAR) (BACKQ-LIST (QUOTE LIST-FIND*) ITEM-VAR SEQ-VAR FROM-END TEST TEST-NOT 0 (BACKQ-LIST (QUOTE LENGTH) SEQ-VAR) KEY) (BACKQ-LIST (QUOTE VECTOR-FIND*) ITEM-VAR SEQ-VAR FROM-END TEST TEST-NOT 0 (BACKQ-LIST (QUOTE LENGTH) SEQ-VAR) KEY))))))) (T FORM)))
     [java] ; (DEFINE-SOURCE-TRANSFORM ADJOIN (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 2) (BACKQ-LIST (QUOTE ADJOIN-EQL) (FIRST ARGS) (SECOND ARGS)) FORM))
     [java] ; (DEFINE-SOURCE-TRANSFORM FORMAT (&WHOLE FORM &REST ARGS) (IF (STRINGP (SECOND ARGS)) (BACKQ-LIST* (QUOTE FORMAT) (POP ARGS) (BACKQ-LIST (QUOTE FORMATTER) (POP ARGS)) ARGS) FORM))
     [java] ; (DEFINE-COMPILER-MACRO CATCH (&WHOLE FORM TAG &REST ARGS) (DECLARE (IGNORE TAG)) (IF (AND (NULL (CDR ARGS)) (CONSTANTP (CAR ARGS))) (CAR ARGS) FORM))
     [java] ; (DEFINE-COMPILER-MACRO STRING= (&WHOLE FORM &REST ARGS) (IF (= (LENGTH ARGS) 2) (BACKQ-CONS (QUOTE %%STRING=) ARGS) FORM))
     [java] ; (DEFINE-COMPILER-MACRO <= (&WHOLE FORM &REST ARGS) (COND ((AND (= (LENGTH ARGS) 3) (NUMBERP (FIRST ARGS)) (NUMBERP (THIRD ARGS)) (= (FIRST ARGS) (THIRD ARGS))) (BACKQ-LIST (QUOTE =) (SECOND ARGS) (FIRST ARGS))) (T FORM)))
     [java] ; (IN-PACKAGE "PRECOMPILER")
     [java] ; (DEFVAR *IN-JVM-COMPILE* NIL)
     [java] ; (DEFVAR *PRECOMPILE-ENV* NIL)
     [java] ; (DECLAIM (INLINE EXPAND-MACRO))
     [java] ; (DEFUN EXPAND-MACRO (FORM) (MACROEXPAND-1 FORM *PRECOMPILE-ENV*))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) PRECOMPILE1))
     [java] ; (DEFUN PRECOMPILE1 (FORM) (COND ((SYMBOLP FORM) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED) (EXPAND-MACRO FORM) (IF EXPANDED (PRECOMPILE1 EXPANSION) FORM))) ((ATOM FORM) FORM) (T (LET ((OP (%CAR FORM)) EXPANDED-2 HANDLER) (WHEN (SYMBOLP OP) (COND ((SETF HANDLER (GET OP (QUOTE PRECOMPILE-HANDLER))) (RETURN-FROM PRECOMPILE1 (FUNCALL HANDLER FORM))) ((MACRO-FUNCTION OP *PRECOMPILE-ENV*) (RETURN-FROM PRECOMPILE1 (PRECOMPILE1 (EXPAND-MACRO FORM)))) ((SPECIAL-OPERATOR-P OP) (SETQ EXPANDED-2 (COMPILER-MACROEXPAND FORM)) (UNLESS (EQUAL FORM EXPANDED-2) (RETURN-FROM PRECOMPILE1 (PRECOMPILE1 EXPANDED-2))) (ERROR "PRECOMPILE1: unsupported special operator ~S." OP)))) (PRECOMPILE-FUNCTION-CALL FORM)))))
     [java] ; (DEFUN PRECOMPILE-IDENTITY (FORM) (DECLARE (OPTIMIZE SPEED)) FORM)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) CONS) PRECOMPILE-CONS))
     [java] ; (DEFUN PRECOMPILE-CONS (FORM) (CONS (CAR FORM) (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) PRECOMPILE-FUNCTION-CALL))
     [java] ; (DEFUN PRECOMPILE-FUNCTION-CALL (FORM) (LET ((OP (CAR FORM))) (WHEN (AND (CONSP OP) (EQ (%CAR OP) (QUOTE LAMBDA))) (RETURN-FROM PRECOMPILE-FUNCTION-CALL (OR (PRECOMPILE-FUNCTION-POSITION-LAMBDA OP (CDR FORM)) (CONS (PRECOMPILE-LAMBDA OP) (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM)))))) (WHEN (OR (NOT *IN-JVM-COMPILE*) (NOTINLINE-P OP)) (RETURN-FROM PRECOMPILE-FUNCTION-CALL (PRECOMPILE-CONS FORM))) (WHEN (SOURCE-TRANSFORM OP) (LET ((NEW-FORM (EXPAND-SOURCE-TRANSFORM FORM))) (WHEN (NEQ NEW-FORM FORM) (RETURN-FROM PRECOMPILE-FUNCTION-CALL (PRECOMPILE1 NEW-FORM))))) (WHEN *ENABLE-INLINE-EXPANSION* (LET ((EXPANSION (INLINE-EXPANSION OP))) (WHEN EXPANSION (LET ((EXPLAIN *EXPLAIN*)) (WHEN (AND EXPLAIN (MEMQ :CALLS EXPLAIN)) (FORMAT T ";   inlining call to ~S~%" OP))) (RETURN-FROM PRECOMPILE-FUNCTION-CALL (PRECOMPILE1 (EXPAND-INLINE FORM EXPANSION)))))) (CONS OP (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM)))))
     [java] ; (DEFUN PRECOMPILE-FUNCTION-POSITION-LAMBDA (LAMBDA ARGS) (LET* ((ARGLIST (SECOND LAMBDA)) (BODY (CDDR LAMBDA)) (SIMPLE-ARGLIST? (NOT (OR (MEMQ (QUOTE &KEY) ARGLIST) (MEMQ (QUOTE &OPTIONAL) ARGLIST) (MEMQ (QUOTE &REST) ARGLIST))))) (OR (AND (= (LENGTH BODY) 1) (CONSP (CAR BODY)) (GET (CAAR BODY) (QUOTE SYSTEM::FUNCTION-POSITION-LAMBDA-TRANSFORM)) (FUNCALL (GET (CAAR BODY) (QUOTE SYSTEM::FUNCTION-POSITION-LAMBDA-TRANSFORM)) (CAAR BODY) (CAR BODY) (MAPCAR (FUNCTION PRECOMPILE1) ARGS))) (AND SIMPLE-ARGLIST? (LET ((ARGLIST-LENGTH (IF (MEMQ (QUOTE &AUX) ARGLIST) (POSITION (QUOTE &AUX) ARGLIST) (LENGTH ARGLIST)))) (IF (= (LENGTH ARGS) ARGLIST-LENGTH) (RETURN-FROM PRECOMPILE-FUNCTION-POSITION-LAMBDA (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-APPEND (LOOP FOR ARG-NAME IN ARGLIST FOR ARG IN (MAPCAR (FUNCTION PRECOMPILE1) ARGS) UNTIL (EQ ARG-NAME (QUOTE &AUX)) COLLECT (LIST ARG-NAME ARG)) (SUBSEQ ARGLIST (1+ ARGLIST-LENGTH))) BODY)) (ERROR "Argument mismatch for lambda in function position: ~a applied to ~a" (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) ARGLIST (QUOTE (BODY))) ARGS)))))))
     [java] ; (DEFMACRO DEFINE-FUNCTION-POSITION-LAMBDA-TRANSFORM (BODY-FUNCTION-NAME (ARGLIST FORM ARGS) &BODY BODY) (SYSTEM::BACKQ-LIST (QUOTE PUT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) BODY-FUNCTION-NAME) (QUOTE (QUOTE SYSTEM::FUNCTION-POSITION-LAMBDA-TRANSFORM)) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST ARGLIST FORM ARGS) BODY))))
     [java] ; (DEFUN PRECOMPILE-LOCALLY (FORM) (LET ((*INLINE-DECLARATIONS* *INLINE-DECLARATIONS*)) (PROCESS-OPTIMIZATION-DECLARATIONS (CDR FORM)) (CONS (QUOTE LOCALLY) (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM)))))
     [java] ; (DEFUN PRECOMPILE-BLOCK (FORM) (LET ((ARGS (CDR FORM))) (IF (NULL (CDR ARGS)) NIL (LIST* (QUOTE BLOCK) (CAR ARGS) (MAPCAR (FUNCTION PRECOMPILE1) (CDR ARGS))))))
     [java] ; (DEFUN PRECOMPILE-DOLIST (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (CONS (QUOTE DOLIST) (CONS (MAPCAR (FUNCTION PRECOMPILE1) (CADR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))))))
     [java] ; (DEFUN PRECOMPILE-DOTIMES (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (CONS (QUOTE DOTIMES) (CONS (MAPCAR (FUNCTION PRECOMPILE1) (CADR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))))))
     [java] ; (DEFUN PRECOMPILE-DO/DO*-VARS (VARLIST) (LET ((RESULT NIL)) (DOLIST (VARSPEC VARLIST) (IF (ATOM VARSPEC) (PUSH VARSPEC RESULT) (CASE (LENGTH VARSPEC) (1 (PUSH (%CAR VARSPEC) RESULT)) (2 (LET* ((VAR (%CAR VARSPEC)) (INIT-FORM (%CADR VARSPEC))) (UNLESS (SYMBOLP VAR) (ERROR (QUOTE TYPE-ERROR))) (PUSH (LIST VAR (PRECOMPILE1 INIT-FORM)) RESULT))) (3 (LET* ((VAR (%CAR VARSPEC)) (INIT-FORM (%CADR VARSPEC)) (STEP-FORM (%CADDR VARSPEC))) (UNLESS (SYMBOLP VAR) (ERROR (QUOTE TYPE-ERROR))) (PUSH (LIST VAR (PRECOMPILE1 INIT-FORM) (PRECOMPILE1 STEP-FORM)) RESULT)))))) (NREVERSE RESULT)))
     [java] ; (DEFUN PRECOMPILE-DO/DO*-END-FORM (END-FORM) (LET ((END-TEST-FORM (CAR END-FORM)) (RESULT-FORMS (CDR END-FORM))) (LIST* (PRECOMPILE1 END-TEST-FORM) (MAPCAR (FUNCTION PRECOMPILE1) RESULT-FORMS))))
     [java] ; (DEFUN PRECOMPILE-DO/DO* (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (LIST* (CAR FORM) (PRECOMPILE-DO/DO*-VARS (CADR FORM)) (PRECOMPILE-DO/DO*-END-FORM (CADDR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDDR FORM)))))
     [java] ; (DEFUN PRECOMPILE-DO-SYMBOLS (FORM) (LIST* (CAR FORM) (CADR FORM) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))))
     [java] ; (DEFUN PRECOMPILE-LOAD-TIME-VALUE (FORM) FORM)
     [java] ; (DEFUN PRECOMPILE-PROGN (FORM) (LET ((BODY (CDR FORM))) (IF (EQL (LENGTH BODY) 1) (LET ((RES (PRECOMPILE1 (%CAR BODY)))) (IF (SYMBOLP RES) (LIST (QUOTE PROGN) RES) RES)) (CONS (QUOTE PROGN) (MAPCAR (FUNCTION PRECOMPILE1) BODY)))))
     [java] ; (DEFUN PRECOMPILE-THREADS-SYNCHRONIZED-ON (FORM) (CONS (QUOTE THREADS:SYNCHRONIZED-ON) (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM))))
     [java] ; (DEFUN PRECOMPILE-PROGV (FORM) (IF (< (LENGTH FORM) 3) (ERROR "Not enough arguments for ~S." (QUOTE PROGV)) (LIST* (QUOTE PROGV) (MAPCAR (FUNCTION PRECOMPILE1) (%CDR FORM)))))
     [java] ; (DEFUN PRECOMPILE-SETF (FORM) (LET ((PLACE (SECOND FORM))) (COND ((AND (CONSP PLACE) (EQ (%CAR PLACE) (QUOTE VALUES))) (SETF FORM (LIST* (QUOTE SETF) (LIST* (QUOTE VALUES) (MAPCAR (FUNCTION PRECOMPILE1) (%CDR PLACE))) (CDDR FORM))) (PRECOMPILE1 (EXPAND-MACRO FORM))) ((SYMBOLP PLACE) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED) (MACROEXPAND-1 PLACE *PRECOMPILE-ENV*) (IF EXPANDED (PRECOMPILE1 (LIST* (QUOTE SETF) EXPANSION (CDDR FORM))) (PRECOMPILE1 (EXPAND-MACRO FORM))))) (T (PRECOMPILE1 (EXPAND-MACRO FORM))))))
     [java] ; (DEFUN PRECOMPILE-SETQ (FORM) (LET* ((ARGS (CDR FORM)) (LEN (LENGTH ARGS))) (WHEN (ODDP LEN) (ERROR (QUOTE SIMPLE-PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of arguments to SETQ.")) (IF (= LEN 2) (LET* ((SYM (%CAR ARGS)) (VAL (%CADR ARGS))) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED) (MACROEXPAND-1 SYM *PRECOMPILE-ENV*) (IF EXPANDED (PRECOMPILE1 (LIST (QUOTE SETF) EXPANSION VAL)) (LIST (QUOTE SETQ) SYM (PRECOMPILE1 VAL))))) (LET ((RESULT NIL)) (LOOP (WHEN (NULL ARGS) (RETURN)) (PUSH (PRECOMPILE-SETQ (LIST (QUOTE SETQ) (CAR ARGS) (CADR ARGS))) RESULT) (SETQ ARGS (CDDR ARGS))) (SETQ RESULT (NREVERSE RESULT)) (PUSH (QUOTE PROGN) RESULT) RESULT))))
     [java] ; (DEFUN PRECOMPILE-PSETF (FORM) (SETF FORM (LIST* (QUOTE PSETF) (MAPCAR (FUNCTION PRECOMPILE1) (CDR FORM)))) (PRECOMPILE1 (EXPAND-MACRO FORM)))
     [java] ; (DEFUN PRECOMPILE-PSETQ (FORM) (DO* ((REST (CDR FORM) (CDDR REST)) (VAR (CAR REST))) ((NULL REST)) (UNLESS (SYMBOLP VAR) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "~S is not a symbol." :FORMAT-ARGUMENTS (LIST VAR)))) (PRECOMPILE-PSETF FORM))
     [java] ; (DEFUN PRECOMPILE-LAMBDA-LIST (FORM) (LET (NEW AUX-TAIL) (DOLIST (ARG FORM (NREVERSE NEW)) (IF (OR (ATOM ARG) (> 2 (LENGTH ARG))) (PROGN (WHEN (EQ ARG (QUOTE &AUX)) (SETF AUX-TAIL T)) (PUSH ARG NEW)) (LET ((NEW-ARG (COPY-LIST ARG))) (UNLESS (<= 1 (LENGTH ARG) (IF AUX-TAIL 2 3)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "The ~A binding specification ~S is invalid." :FORMAT-ARGUMENTS (LIST (IF AUX-TAIL "&AUX" "&OPTIONAL/&KEY") ARG))) (SETF (SECOND NEW-ARG) (PRECOMPILE1 (SECOND ARG))) (PUSH NEW-ARG NEW))))))
     [java] ; (DEFUN EXTRACT-LAMBDA-VARS (LAMBDA-LIST) (LET ((STATE :REQUIRED) VARS) (DOLIST (VAR/KEY LAMBDA-LIST VARS) (COND ((EQ (QUOTE &AUX) VAR/KEY) (SETF STATE :AUX)) ((EQ (QUOTE &KEY) VAR/KEY) (SETF STATE :KEY)) ((EQ (QUOTE &OPTIONAL) VAR/KEY) (SETF STATE :OPTIONAL)) ((EQ (QUOTE &REST) VAR/KEY) (SETF STATE :REST)) ((SYMBOLP VAR/KEY) (UNLESS (EQ VAR/KEY (QUOTE &ALLOW-OTHER-KEYS)) (PUSH VAR/KEY VARS))) ((AND (CONSP VAR/KEY) (MEMBER STATE (QUOTE (:OPTIONAL :KEY)))) (SETF VAR/KEY (CAR VAR/KEY)) (WHEN (AND (CONSP VAR/KEY) (EQ STATE :KEY)) (SETF VAR/KEY (SECOND VAR/KEY))) (IF (SYMBOLP VAR/KEY) (PUSH VAR/KEY VARS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Unexpected ~A variable specifier ~A." :FORMAT-ARGUMENTS (LIST STATE VAR/KEY)))) ((AND (CONSP VAR/KEY) (EQ STATE :AUX)) (IF (SYMBOLP (CAR VAR/KEY)) (PUSH (CAR VAR/KEY) VARS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Unexpected &AUX format for ~A." :FORMAT-ARGUMENTS (LIST VAR/KEY)))) (T (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Unexpected lambda-list format: ~A." :FORMAT-ARGUMENTS (LIST LAMBDA-LIST)))))))
     [java] ; (DEFUN PRECOMPILE-LAMBDA (FORM) (LET ((BODY (CDDR FORM)) (PRECOMPILED-LAMBDA-LIST (PRECOMPILE-LAMBDA-LIST (CADR FORM))) (*INLINE-DECLARATIONS* *INLINE-DECLARATIONS*) (*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (DOLIST (VAR (EXTRACT-LAMBDA-VARS PRECOMPILED-LAMBDA-LIST)) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* VAR NIL)) (LIST* (QUOTE LAMBDA) PRECOMPILED-LAMBDA-LIST (MAPCAR (FUNCTION PRECOMPILE1) BODY))))
     [java] ; (DEFUN PRECOMPILE-NAMED-LAMBDA (FORM) (LET ((LAMBDA-FORM (LIST* (QUOTE LAMBDA) (CADDR FORM) (CDDDR FORM)))) (LET ((BODY (CDDR LAMBDA-FORM)) (PRECOMPILED-LAMBDA-LIST (PRECOMPILE-LAMBDA-LIST (CADR LAMBDA-FORM))) (*INLINE-DECLARATIONS* *INLINE-DECLARATIONS*) (*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (DOLIST (VAR (EXTRACT-LAMBDA-VARS PRECOMPILED-LAMBDA-LIST)) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* VAR NIL)) (LIST* (QUOTE NAMED-LAMBDA) (CADR FORM) PRECOMPILED-LAMBDA-LIST (MAPCAR (FUNCTION PRECOMPILE1) BODY)))))
     [java] ; (DEFUN PRECOMPILE-DEFUN (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (EXPAND-MACRO FORM)) FORM))
     [java] ; (DEFUN PRECOMPILE-MACROLET (FORM) (LET ((*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (DOLIST (DEFINITION (CADR FORM)) (ENVIRONMENT-ADD-MACRO-DEFINITION *PRECOMPILE-ENV* (CAR DEFINITION) (MAKE-MACRO (CAR DEFINITION) (MAKE-CLOSURE (MAKE-MACRO-EXPANDER DEFINITION) NIL)))) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY (CDDR FORM) NIL) (SYSTEM::BACKQ-CONS (QUOTE LOCALLY) (SYSTEM::BACKQ-APPEND DECLS (MAPCAR (FUNCTION PRECOMPILE1) BODY))))))
     [java] ; (DEFUN PRECOMPILE-SYMBOL-MACROLET (FORM) (LET ((*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*)) (DEFS (CADR FORM))) (DOLIST (DEF DEFS) (LET ((SYM (CAR DEF)) (EXPANSION (CADR DEF))) (WHEN (SPECIAL-VARIABLE-P SYM) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Attempt to bind the special variable ~S with SYMBOL-MACROLET." :FORMAT-ARGUMENTS (LIST SYM))) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* SYM (MAKE-SYMBOL-MACRO EXPANSION)))) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY (CDDR FORM) NIL) (WHEN DECLS (LET ((SPECIALS NIL)) (DOLIST (DECL DECLS) (WHEN (EQ (CAR DECL) (QUOTE DECLARE)) (DOLIST (DECLSPEC (CDR DECL)) (WHEN (EQ (CAR DECLSPEC) (QUOTE SPECIAL)) (SETF SPECIALS (APPEND SPECIALS (CDR DECLSPEC))))))) (WHEN SPECIALS (LET ((SYMS (MAPCAR (FUNCTION CAR) (CADR FORM)))) (DOLIST (SPECIAL SPECIALS) (WHEN (MEMQ SPECIAL SYMS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~S is a symbol-macro and may not be declared special." :FORMAT-ARGUMENTS (LIST SPECIAL)))))))) (SYSTEM::BACKQ-CONS (QUOTE LOCALLY) (SYSTEM::BACKQ-APPEND DECLS (MAPCAR (FUNCTION PRECOMPILE1) BODY))))))
     [java] ; (DEFUN PRECOMPILE-THE (FORM) (LIST (QUOTE THE) (SECOND FORM) (PRECOMPILE1 (THIRD FORM))))
     [java] ; (DEFUN PRECOMPILE-TRULY-THE (FORM) (LIST (QUOTE TRULY-THE) (SECOND FORM) (PRECOMPILE1 (THIRD FORM))))
     [java] ; (DEFUN PRECOMPILE-LET/LET*-VARS (VARS) (LET ((RESULT NIL)) (DOLIST (VAR VARS) (COND ((CONSP VAR) (UNLESS (<= 1 (LENGTH VAR) 2) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "The LET/LET* binding specification ~S is invalid." :FORMAT-ARGUMENTS (LIST VAR))) (LET ((V (%CAR VAR)) (EXPR (CADR VAR))) (UNLESS (SYMBOLP V) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "The variable ~S is not a symbol." :FORMAT-ARGUMENTS (LIST V))) (PUSH (LIST V (PRECOMPILE1 EXPR)) RESULT) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* V NIL))) (T (PUSH VAR RESULT) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* VAR NIL)))) (NREVERSE RESULT)))
     [java] ; (DEFUN PRECOMPILE-LET (FORM) (LET ((*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (LIST* (QUOTE LET) (PRECOMPILE-LET/LET*-VARS (CADR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM)))))
     [java] ; (DEFUN MAYBE-FOLD-LET* (FORM) (IF (AND (= (LENGTH FORM) 3) (CONSP (%CADDR FORM)) (EQ (%CAR (%CADDR FORM)) (QUOTE LET*))) (LET ((THIRD (MAYBE-FOLD-LET* (%CADDR FORM)))) (LIST* (QUOTE LET*) (APPEND (%CADR FORM) (CADR THIRD)) (CDDR THIRD))) FORM))
     [java] ; (DEFUN PRECOMPILE-LET* (FORM) (SETF FORM (MAYBE-FOLD-LET* FORM)) (LET ((*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (LIST* (QUOTE LET*) (PRECOMPILE-LET/LET*-VARS (CADR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM)))))
     [java] ; (DEFUN PRECOMPILE-CASE (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (LET* ((KEYFORM (CADR FORM)) (CLAUSES (CDDR FORM)) (RESULT (LIST (PRECOMPILE1 KEYFORM)))) (DOLIST (CLAUSE CLAUSES) (PUSH (PRECOMPILE-CASE-CLAUSE CLAUSE) RESULT)) (CONS (CAR FORM) (NREVERSE RESULT)))))
     [java] ; (DEFUN PRECOMPILE-CASE-CLAUSE (CLAUSE) (LET ((KEYS (CAR CLAUSE)) (FORMS (CDR CLAUSE))) (CONS KEYS (MAPCAR (FUNCTION PRECOMPILE1) FORMS))))
     [java] ; (DEFUN PRECOMPILE-COND (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (LET ((CLAUSES (CDR FORM)) (RESULT NIL)) (DOLIST (CLAUSE CLAUSES) (PUSH (PRECOMPILE-COND-CLAUSE CLAUSE) RESULT)) (CONS (QUOTE COND) (NREVERSE RESULT)))))
     [java] ; (DEFUN PRECOMPILE-COND-CLAUSE (CLAUSE) (LET ((TEST (CAR CLAUSE)) (FORMS (CDR CLAUSE))) (CONS (PRECOMPILE1 TEST) (MAPCAR (FUNCTION PRECOMPILE1) FORMS))))
     [java] ; (DEFUN PRECOMPILE-LOCAL-FUNCTION-DEF (DEF) (LET ((NAME (CAR DEF)) (BODY (CDDR DEF))) (ENVIRONMENT-ADD-FUNCTION-DEFINITION *PRECOMPILE-ENV* NAME BODY) (CDR (PRECOMPILE-NAMED-LAMBDA (LIST* (QUOTE NAMED-LAMBDA) DEF)))))
     [java] ; (DEFUN PRECOMPILE-LOCAL-FUNCTIONS (DEFS) (LET ((RESULT NIL)) (DOLIST (DEF DEFS (NREVERSE RESULT)) (PUSH (PRECOMPILE-LOCAL-FUNCTION-DEF DEF) RESULT))))
     [java] ; (DEFUN FIND-USE (NAME EXPRESSION) (COND ((ATOM EXPRESSION) NIL) ((EQ (%CAR EXPRESSION) NAME) T) ((CONSP NAME) T) (T (OR (FIND-USE NAME (%CAR EXPRESSION)) (FIND-USE NAME (%CDR EXPRESSION))))))
     [java] ; (DEFUN PRECOMPILE-FLET/LABELS (FORM) (LET* ((*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*)) (OPERATOR (CAR FORM)) (LOCALS (CADR FORM)) PRECOMPILED-LOCALS APPLICABLE-LOCALS BODY) (WHEN (EQ OPERATOR (QUOTE FLET)) (SETF PRECOMPILED-LOCALS (PRECOMPILE-LOCAL-FUNCTIONS LOCALS)) (SETF APPLICABLE-LOCALS PRECOMPILED-LOCALS)) (DOLIST (LOCAL LOCALS) (ENVIRONMENT-ADD-FUNCTION-DEFINITION *PRECOMPILE-ENV* (CAR LOCAL) (CDDR LOCAL))) (WHEN (EQ OPERATOR (QUOTE LABELS)) (SETF PRECOMPILED-LOCALS (PRECOMPILE-LOCAL-FUNCTIONS LOCALS)) (SETF APPLICABLE-LOCALS PRECOMPILED-LOCALS)) (SETQ BODY (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))) (DOLIST (LOCAL PRECOMPILED-LOCALS) (LET* ((NAME (CAR LOCAL)) (USED-P (FIND-USE NAME BODY))) (UNLESS USED-P (WHEN (EQ OPERATOR (QUOTE LABELS)) (DOLIST (LOCAL PRECOMPILED-LOCALS) (WHEN (NEQ NAME (CAR LOCAL)) (WHEN (FIND-USE NAME (CDDR LOCAL)) (SETF USED-P T) (RETURN)) (LET ((VARS (OR (CDR (MEMQ (QUOTE &OPTIONAL) (CADR LOCAL))) (CDR (MEMQ (QUOTE &KEY) (CADR LOCAL))) (CDR (MEMQ (QUOTE &AUX) (CADR LOCAL)))))) (WHEN (AND VARS (FIND-USE NAME VARS)) (SETF USED-P T) (RETURN))))))) (UNLESS USED-P (COMPILER-STYLE-WARN "; Note: deleting unused local function ~A ~S~%" OPERATOR NAME) (SETF APPLICABLE-LOCALS (REMOVE LOCAL APPLICABLE-LOCALS))))) (IF APPLICABLE-LOCALS (LIST* OPERATOR APPLICABLE-LOCALS BODY) (LIST* (QUOTE LOCALLY) BODY))))
     [java] ; (DEFUN PRECOMPILE-FUNCTION (FORM) (IF (AND (CONSP (CADR FORM)) (EQ (CAADR FORM) (QUOTE LAMBDA))) (LIST (QUOTE FUNCTION) (PRECOMPILE-LAMBDA (%CADR FORM))) FORM))
     [java] ; (DEFUN PRECOMPILE-IF (FORM) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (2 (LET ((TEST (PRECOMPILE1 (%CAR ARGS)))) (COND ((NULL TEST) NIL) ((EQ TEST T) (PRECOMPILE1 (%CADR ARGS))) (T (LIST (QUOTE IF) TEST (PRECOMPILE1 (%CADR ARGS))))))) (3 (LET ((TEST (PRECOMPILE1 (%CAR ARGS)))) (COND ((NULL TEST) (PRECOMPILE1 (%CADDR ARGS))) ((EQ TEST T) (PRECOMPILE1 (%CADR ARGS))) (T (LIST (QUOTE IF) TEST (PRECOMPILE1 (%CADR ARGS)) (PRECOMPILE1 (%CADDR ARGS))))))) (T (ERROR "wrong number of arguments for IF")))))
     [java] ; (DEFUN PRECOMPILE-WHEN (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (PRECOMPILE-CONS FORM)))
     [java] ; (DEFUN PRECOMPILE-UNLESS (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (PRECOMPILE-CONS FORM)))
     [java] ; (DEFUN PRECOMPILE-MULTIPLE-VALUE-BIND (FORM) (LET ((VARS (CADR FORM)) (VALUES-FORM (CADDR FORM)) (BODY (CDDDR FORM)) (*PRECOMPILE-ENV* (MAKE-ENVIRONMENT *PRECOMPILE-ENV*))) (DOLIST (VAR VARS) (ENVIRONMENT-ADD-SYMBOL-BINDING *PRECOMPILE-ENV* VAR NIL)) (LIST* (QUOTE MULTIPLE-VALUE-BIND) VARS (PRECOMPILE1 VALUES-FORM) (MAPCAR (FUNCTION PRECOMPILE1) BODY))))
     [java] ; (DEFUN PRECOMPILE-MULTIPLE-VALUE-LIST (FORM) (LIST (QUOTE MULTIPLE-VALUE-LIST) (PRECOMPILE1 (CADR FORM))))
     [java] ; (DEFUN PRECOMPILE-NTH-VALUE (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) FORM))
     [java] ; (DEFUN PRECOMPILE-RETURN (FORM) (IF *IN-JVM-COMPILE* (PRECOMPILE1 (MACROEXPAND FORM *PRECOMPILE-ENV*)) (LIST (QUOTE RETURN) (PRECOMPILE1 (CADR FORM)))))
     [java] ; (DEFUN PRECOMPILE-RETURN-FROM (FORM) (LIST (QUOTE RETURN-FROM) (CADR FORM) (PRECOMPILE1 (CADDR FORM))))
     [java] ; (DEFUN PRECOMPILE-TAGBODY (FORM) (DO ((BODY (CDR FORM) (CDR BODY)) (RESULT NIL)) ((NULL BODY) (CONS (QUOTE TAGBODY) (NREVERSE RESULT))) (IF (ATOM (CAR BODY)) (PUSH (CAR BODY) RESULT) (PUSH (LET* ((FIRST-FORM (CAR BODY)) (EXPANDED (PRECOMPILE1 FIRST-FORM))) (IF (AND (SYMBOLP EXPANDED) (NEQ EXPANDED FIRST-FORM)) (LIST (QUOTE PROGN) EXPANDED) EXPANDED)) RESULT))))
     [java] ; (DEFUN PRECOMPILE-EVAL-WHEN (FORM) (LIST* (QUOTE EVAL-WHEN) (CADR FORM) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))))
     [java] ; (DEFUN PRECOMPILE-UNWIND-PROTECT (FORM) (LIST* (QUOTE UNWIND-PROTECT) (PRECOMPILE1 (CADR FORM)) (MAPCAR (FUNCTION PRECOMPILE1) (CDDR FORM))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) PRECOMPILE-FORM))
     [java] ; (DEFUN PRECOMPILE-FORM (FORM IN-JVM-COMPILE &OPTIONAL PRECOMPILE-ENV) (LET ((*IN-JVM-COMPILE* IN-JVM-COMPILE) (*INLINE-DECLARATIONS* *INLINE-DECLARATIONS*) (*PRECOMPILE-ENV* PRECOMPILE-ENV)) (PRECOMPILE1 FORM)))
     [java] ; (DEFUN INSTALL-HANDLER (SYMBOL &OPTIONAL HANDLER) (DECLARE (TYPE SYMBOL SYMBOL)) (LET ((HANDLER (OR HANDLER (FIND-SYMBOL (SYSTEM::%FORMAT NIL "PRECOMPILE-~A" (SYMBOL-NAME SYMBOL)) (QUOTE PRECOMPILER))))) (UNLESS (AND HANDLER (FBOUNDP HANDLER)) (ERROR "No handler for ~S." (LET ((*PACKAGE* (FIND-PACKAGE :KEYWORD))) (FORMAT NIL "~S" SYMBOL)))) (SETF (GET SYMBOL (QUOTE PRECOMPILE-HANDLER)) HANDLER)))
     [java] ; (DEFUN INSTALL-HANDLERS NIL (MAPCAR (FUNCTION INSTALL-HANDLER) (QUOTE (BLOCK CASE COND DOLIST DOTIMES EVAL-WHEN FUNCTION IF LAMBDA MACROLET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-LIST NAMED-LAMBDA NTH-VALUE PROGN PROGV PSETF PSETQ RETURN RETURN-FROM SETF SETQ SYMBOL-MACROLET TAGBODY UNWIND-PROTECT UNLESS WHEN))) (DOLIST (PAIR (QUOTE ((ECASE PRECOMPILE-CASE) (AND PRECOMPILE-CONS) (OR PRECOMPILE-CONS) (CATCH PRECOMPILE-CONS) (MULTIPLE-VALUE-CALL PRECOMPILE-CONS) (MULTIPLE-VALUE-PROG1 PRECOMPILE-CONS) (DO PRECOMPILE-DO/DO*) (DO* PRECOMPILE-DO/DO*) (LET PRECOMPILE-LET) (LET* PRECOMPILE-LET*) (LOCALLY PRECOMPILE-LOCALLY) (FLET PRECOMPILE-FLET/LABELS) (LABELS PRECOMPILE-FLET/LABELS) (LOAD-TIME-VALUE PRECOMPILE-LOAD-TIME-VALUE) (DECLARE PRECOMPILE-IDENTITY) (DEFUN PRECOMPILE-DEFUN) (GO PRECOMPILE-IDENTITY) (QUOTE PRECOMPILE-IDENTITY) (THE PRECOMPILE-THE) (THROW PRECOMPILE-CONS) (TRULY-THE PRECOMPILE-TRULY-THE) (THREADS:SYNCHRONIZED-ON PRECOMPILE-THREADS-SYNCHRONIZED-ON) (JVM:WITH-INLINE-CODE PRECOMPILE-IDENTITY)))) (INSTALL-HANDLER (FIRST PAIR) (SECOND PAIR))))
     [java] ; (IN-PACKAGE #:EXT)
     [java] ; (DEFUN MACROEXPAND-ALL (FORM &OPTIONAL ENV) (PRECOMPILER:PRECOMPILE-FORM FORM T ENV))
     [java] ; (IN-PACKAGE #:LISP)
     [java] ; (DEFMACRO COMPILER-LET (BINDINGS &BODY FORMS &ENVIRONMENT ENV) (LET ((BINDINGS (MAPCAR (FUNCTION (LAMBDA (BINDING) (IF (ATOM BINDING) (LIST BINDING) BINDING))) BINDINGS))) (PROGV (MAPCAR (FUNCTION CAR) BINDINGS) (MAPCAR (FUNCTION (LAMBDA (BINDING) (EVAL (CADR BINDING)))) BINDINGS) (MACROEXPAND-ALL (SYSTEM::BACKQ-CONS (QUOTE PROGN) FORMS) ENV))))
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN SET-FUNCTION-DEFINITION (NAME NEW OLD) (LET ((*WARN-ON-REDEFINITION* NIL)) (%SET-LAMBDA-NAME NEW NAME) (SET-CALL-COUNT NEW (CALL-COUNT OLD)) (%SET-ARGLIST NEW (ARGLIST OLD)) (WHEN (MACRO-FUNCTION NAME) (SETF NEW (MAKE-MACRO NAME NEW))) (IF (TYPEP OLD (QUOTE MOP:FUNCALLABLE-STANDARD-OBJECT)) (MOP:SET-FUNCALLABLE-INSTANCE-FUNCTION OLD NEW) (SETF (FDEFINITION NAME) NEW))))
     [java] ; (DEFUN PRECOMPILE (NAME &OPTIONAL DEFINITION) (UNLESS DEFINITION (SETQ DEFINITION (OR (AND (SYMBOLP NAME) (MACRO-FUNCTION NAME)) (FDEFINITION NAME)))) (LET ((EXPR DEFINITION) ENV RESULT (PRECOMPILER::*PRECOMPILE-ENV* NIL)) (WHEN (FUNCTIONP DEFINITION) (MULTIPLE-VALUE-BIND (FORM CLOSURE-P) (FUNCTION-LAMBDA-EXPRESSION DEFINITION) (UNLESS FORM (RETURN-FROM PRECOMPILE (VALUES NIL T T))) (SETQ ENV CLOSURE-P) (SETQ EXPR FORM))) (UNLESS (AND (CONSP EXPR) (EQ (CAR EXPR) (QUOTE LAMBDA))) (FORMAT T "Unable to precompile ~S.~%" NAME) (RETURN-FROM PRECOMPILE (VALUES NIL T T))) (SETF RESULT (MAKE-CLOSURE (PRECOMPILER:PRECOMPILE-FORM EXPR NIL ENV) ENV)) (WHEN (AND NAME (FUNCTIONP RESULT)) (SET-FUNCTION-DEFINITION NAME RESULT DEFINITION)) (VALUES (OR NAME RESULT) NIL NIL)))
     [java] ; (DEFUN PRECOMPILE-PACKAGE (PKG &KEY (VERBOSE *COMPILE-VERBOSE*)) (DOLIST (SYM (PACKAGE-SYMBOLS PKG)) (WHEN (FBOUNDP SYM) (UNLESS (SPECIAL-OPERATOR-P SYM) (LET ((F (FDEFINITION SYM))) (UNLESS (COMPILED-FUNCTION-P F) (WHEN VERBOSE (FORMAT T "~&; precompiler; Precompiling ~S~%" SYM) (FINISH-OUTPUT)) (PRECOMPILE SYM)))))) T)
     [java] ; (DEFUN %COMPILE (NAME DEFINITION) (IF (AND NAME (FBOUNDP NAME) (%TYPEP (SYMBOL-FUNCTION NAME) (QUOTE GENERIC-FUNCTION))) (VALUES NAME NIL NIL) (PRECOMPILE NAME DEFINITION)))
     [java] ; (WHEN (GET (QUOTE DEFMACRO) (QUOTE MACROEXPAND-MACRO)) (FSET (QUOTE DEFMACRO) (GET (QUOTE DEFMACRO) (QUOTE MACROEXPAND-MACRO))) (REMPROP (QUOTE DEFMACRO) (QUOTE MACROEXPAND-MACRO)))
     [java] ; (DEFVAR *DEFINED-FUNCTIONS*)
     [java] ; (DEFVAR *UNDEFINED-FUNCTIONS*)
     [java] ; (DEFUN NOTE-NAME-DEFINED (NAME) (WHEN (BOUNDP (QUOTE *DEFINED-FUNCTIONS*)) (PUSH NAME *DEFINED-FUNCTIONS*)) (WHEN (AND (BOUNDP (QUOTE *UNDEFINED-FUNCTIONS*)) (NOT (NULL *UNDEFINED-FUNCTIONS*))) (SETF *UNDEFINED-FUNCTIONS* (REMOVE NAME *UNDEFINED-FUNCTIONS*))))
     [java] ; (DEFMACRO DEFUN (NAME LAMBDA-LIST &BODY BODY &ENVIRONMENT ENV) (NOTE-NAME-DEFINED NAME) (MULTIPLE-VALUE-BIND (BODY DECLS DOC) (PARSE-BODY BODY) (LET* ((BLOCK-NAME (FDEFINITION-BLOCK-NAME NAME)) (LAMBDA-EXPRESSION (BACKQ-LIST* (QUOTE NAMED-LAMBDA) NAME LAMBDA-LIST (BACKQ-APPEND DECLS (WHEN DOC (BACKQ-LIST DOC)) (BACKQ-LIST (BACKQ-LIST* (QUOTE BLOCK) BLOCK-NAME BODY)))))) (COND ((AND (BOUNDP (QUOTE JVM::*FILE-COMPILATION*)) JVM::*FILE-COMPILATION*) (BACKQ-LIST* (QUOTE PROGN) (BACKQ-LIST (QUOTE FSET) (BACKQ-LIST (QUOTE QUOTE) NAME) LAMBDA-EXPRESSION) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) (IF (CONSP NAME) (SECOND NAME) NAME)) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :FUNCTION) NAME))) (BACKQ-LIST (QUOTE %SET-ARGLIST) (BACKQ-LIST (QUOTE FDEFINITION) (BACKQ-LIST (QUOTE QUOTE) NAME)) (BACKQ-LIST (QUOTE QUOTE) (THIRD LAMBDA-EXPRESSION))) (BACKQ-APPEND (WHEN DOC (BACKQ-LIST (BACKQ-LIST (QUOTE %SET-DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE FUNCTION)) DOC))) (BACKQ-LIST (BACKQ-LIST (QUOTE QUOTE) NAME))))) (T (WHEN (AND ENV (EMPTY-ENVIRONMENT-P ENV)) (SETF ENV NIL)) (WHEN (NULL ENV) (SETF LAMBDA-EXPRESSION (PRECOMPILER:PRECOMPILE-FORM LAMBDA-EXPRESSION NIL))) (LET ((SYM (IF (CONSP NAME) (SECOND NAME) NAME))) (BACKQ-LIST* (QUOTE PROG1) (BACKQ-LIST (QUOTE %DEFUN) (BACKQ-LIST (QUOTE QUOTE) NAME) LAMBDA-EXPRESSION) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) SYM) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :FUNCTION) NAME))) (BACKQ-LIST (QUOTE %SET-ARGLIST) (BACKQ-LIST (QUOTE FDEFINITION) (BACKQ-LIST (QUOTE QUOTE) NAME)) (BACKQ-LIST (QUOTE QUOTE) (THIRD LAMBDA-EXPRESSION))) (WHEN DOC (BACKQ-LIST (BACKQ-LIST (QUOTE %SET-DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE FUNCTION)) DOC))))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/precompiler.abcl (5.478 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/precompiler.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/precompiler.abcl (0.861 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass1.lisp ...
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DEFUN GENERATE-INLINE-EXPANSION (NAME LAMBDA-LIST BODY &OPTIONAL (ARGS NIL ARGS-P)) "Generates code that can be used to expand a named local function inline.
     [java] It can work either per-function (no args provided) or per-call." (IF ARGS-P (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY BODY) (EXPAND-FUNCTION-CALL-INLINE NIL LAMBDA-LIST (COPY-TREE (SYSTEM::BACKQ-APPEND DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NAME BODY)))) ARGS)) (COND ((INTERSECTION LAMBDA-LIST (QUOTE (&OPTIONAL &REST &KEY &ALLOW-OTHER-KEYS &AUX)) :TEST (FUNCTION EQ)) NIL) (T (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY BODY) (SETF BODY (COPY-TREE BODY)) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NAME BODY)))))))))
     [java] ; (DEFUN PARSE-LAMBDA-LIST (LAMBDA-LIST) "Breaks the lambda list into the different elements, returning the values
     [java]
     [java]  required-vars
     [java]  optional-vars
     [java]  key-vars
     [java]  key-p
     [java]  rest-var
     [java]  allow-other-keys-p
     [java]  aux-vars
     [java]  whole-var
     [java]  env-var
     [java]
     [java] where each of the vars returned is a list with these elements:
     [java]
     [java]  var      - the actual variable name
     [java]  initform - the init form if applicable; optional, keyword and aux vars
     [java]  p-var    - variable indicating presence
     [java]  keyword  - the keyword argument to match against
     [java]
     [java] " (LET ((REMAINING LAMBDA-LIST) (STATE :REQ) KEYWORD-REQUIRED REQ OPT KEY REST WHOLE ENV AUX KEY-P ALLOW-OTHERS-P) (WHEN (EQ (CAR LAMBDA-LIST) (QUOTE &WHOLE)) (LET ((VAR (SECOND LAMBDA-LIST))) (WHEN (MEMQ VAR LAMBDA-LIST-KEYWORDS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Lambda list keyword ~A found where &WHOLE ~
     [java]                                   variable expected in lambda list ~A." :FORMAT-ARGUMENTS (LIST VAR LAMBDA-LIST))) (SETF WHOLE (LIST VAR)) (SETF REMAINING (NTHCDR 2 LAMBDA-LIST)))) (DO* ((ARG (POP REMAINING) (POP TAIL)) (TAIL REMAINING TAIL)) ((AND (NULL ARG) (ENDP TAIL))) (LET* ((ALLOWABLE-PREVIOUS-STATES (CDR (MEMBER ARG (QUOTE (&WHOLE &ENVIRONMENT &AUX &ALLOW-OTHER-KEYS &KEY &REST &OPTIONAL :REQ)))))) (COND (ALLOWABLE-PREVIOUS-STATES (SETF KEYWORD-REQUIRED NIL) (CASE ARG (&KEY (SETF KEY-P T)) (&REST (WHEN (ENDP TAIL) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "&REST without variable in lambda list ~A." :FORMAT-ARGUMENTS (LIST LAMBDA-LIST))) (SETF REST (LIST (POP TAIL)) KEYWORD-REQUIRED T)) (&ALLOW-OTHER-KEYS (UNLESS (EQ STATE (QUOTE &KEY)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "&ALLOW-OTHER-KEYS outside of &KEY ~
     [java]                                         section in lambda list ~A" :FORMAT-ARGUMENTS (LIST LAMBDA-LIST))) (SETF ALLOW-OTHERS-P T KEYWORD-REQUIRED T ARG NIL)) (&ENVIRONMENT (SETF ENV (LIST (POP TAIL)) KEYWORD-REQUIRED T ARG STATE)) (&WHOLE (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "&WHOLE must appear first in lambda list ~A." :FORMAT-ARGUMENTS (LIST LAMBDA-LIST)))) (WHEN ARG (UNLESS (OR (NULL STATE) (MEMBER STATE ALLOWABLE-PREVIOUS-STATES)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A not allowed after ~A ~
     [java]                                        in lambda-list ~S" :FORMAT-ARGUMENTS (LIST ARG STATE LAMBDA-LIST))) (SETF STATE ARG))) (KEYWORD-REQUIRED (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Lambda list keyword expected, but found ~
     [java]                                    ~A in lambda list ~A" :FORMAT-ARGUMENTS (LIST ARG LAMBDA-LIST))) (T (CASE STATE (:REQ (PUSH (LIST ARG) REQ)) (&OPTIONAL (COND ((SYMBOLP ARG) (PUSH (LIST ARG) OPT)) ((CONSP ARG) (PUSH (LIST (CAR ARG) (CADR ARG) (CADDR ARG)) OPT)) (T (ERROR "Invalid &OPTIONAL variable.")))) (&KEY (COND ((SYMBOLP ARG) (PUSH (LIST ARG NIL NIL (SYSTEM::KEYWORDIFY ARG)) KEY)) ((CONSP ARG) (PUSH (LIST (IF (CONSP (CAR ARG)) (CADAR ARG) (CAR ARG)) (CADR ARG) (CADDR ARG) (IF (CONSP (CAR ARG)) (CAAR ARG) (SYSTEM::KEYWORDIFY (CAR ARG)))) KEY)) (T (ERROR "Invalid &KEY variable.")))) (&AUX (COND ((SYMBOLP ARG) (PUSH (LIST ARG NIL NIL NIL) AUX)) ((CONSP ARG) (PUSH (LIST (CAR ARG) (CADR ARG) NIL NIL) AUX)) (T (ERROR "Invalid &aux state.")))) (T (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Invalid state found: ~A." :FORMAT-ARGUMENTS (LIST STATE)))))))) (VALUES (NREVERSE REQ) (NREVERSE OPT) (NREVERSE KEY) KEY-P REST ALLOW-OTHERS-P (NREVERSE AUX) WHOLE ENV)))
     [java] ; (DEFINE-CONDITION LAMBDA-LIST-MISMATCH (ERROR) ((MISMATCH-TYPE :READER LAMBDA-LIST-MISMATCH-TYPE :INITARG :MISMATCH-TYPE)))
     [java] ; (DEFMACRO PUSH-ARGUMENT-BINDING (VAR FORM TEMP-BINDINGS BINDINGS) (LET ((G (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS G (QUOTE ((GENSYM (SYMBOL-NAME (QUOTE #:TEMP))))))) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE LIST) G FORM) TEMP-BINDINGS) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE LIST) VAR G) BINDINGS))))
     [java] ; (DEFUN MATCH-LAMBDA-LIST (PARSED-LAMBDA-LIST ARGUMENTS) (FLET ((POP-REQUIRED-ARGUMENT NIL (IF (NULL ARGUMENTS) (ERROR (QUOTE LAMBDA-LIST-MISMATCH) :MISMATCH-TYPE :TOO-FEW-ARGUMENTS) (POP ARGUMENTS))) (VAR (VAR-INFO) (CAR VAR-INFO)) (INITFORM (VAR-INFO) (CADR VAR-INFO)) (P-VAR (VAR-INFO) (CADDR VAR-INFO))) (DESTRUCTURING-BIND (REQ OPT KEY KEY-P REST ALLOW-OTHERS-P AUX WHOLE ENV) PARSED-LAMBDA-LIST (DECLARE (IGNORE WHOLE ENV)) (LET (REQ-BINDINGS TEMP-BINDINGS BINDINGS IGNORABLES) (SETF REQ-BINDINGS (LOOP :FOR (VAR) :IN REQ :COLLECT (SYSTEM::BACKQ-LIST VAR (POP-REQUIRED-ARGUMENT)))) (WHEN OPT (DOLIST (VAR-INFO OPT) (IF ARGUMENTS (PROGN (PUSH-ARGUMENT-BINDING (VAR VAR-INFO) (POP ARGUMENTS) TEMP-BINDINGS BINDINGS) (WHEN (P-VAR VAR-INFO) (PUSH (SYSTEM::BACKQ-CONS (P-VAR VAR-INFO) (QUOTE (T))) BINDINGS))) (PROGN (PUSH (SYSTEM::BACKQ-LIST (VAR VAR-INFO) (INITFORM VAR-INFO)) BINDINGS) (WHEN (P-VAR VAR-INFO) (PUSH (SYSTEM::BACKQ-CONS (P-VAR VAR-INFO) (QUOTE (NIL))) BINDINGS))))) (SETF BINDINGS (NREVERSE BINDINGS))) (UNLESS (OR KEY-P REST (NULL ARGUMENTS)) (ERROR (QUOTE LAMBDA-LIST-MISMATCH) :MISMATCH-TYPE :TOO-MANY-ARGUMENTS)) (IF KEY-P (MULTIPLE-VALUE-BIND (KBINDINGS KTEMPS KIGNOR) (MATCH-KEYWORD-AND-REST-ARGS KEY ALLOW-OTHERS-P REST ARGUMENTS) (SETF BINDINGS (APPEND BINDINGS KBINDINGS) TEMP-BINDINGS (APPEND TEMP-BINDINGS KTEMPS) IGNORABLES (APPEND KIGNOR IGNORABLES))) (WHEN REST (LET (REST-BINDING) (PUSH-ARGUMENT-BINDING (VAR REST) (SYSTEM::BACKQ-CONS (QUOTE LIST) ARGUMENTS) TEMP-BINDINGS REST-BINDING) (SETF BINDINGS (APPEND BINDINGS REST-BINDING))))) (WHEN AUX (SETF BINDINGS (SYSTEM::BACKQ-APPEND BINDINGS (LOOP :FOR VAR-INFO :IN AUX :COLLECT (SYSTEM::BACKQ-LIST (VAR VAR-INFO) (INITFORM VAR-INFO)))))) (VALUES (APPEND REQ-BINDINGS TEMP-BINDINGS BINDINGS) IGNORABLES)))))
     [java] ; (DEFUN MATCH-KEYWORD-AND-REST-ARGS (KEY ALLOW-OTHERS-P REST ARGUMENTS) (FLET ((VAR (VAR-INFO) (CAR VAR-INFO)) (INITFORM (VAR-INFO) (CADR VAR-INFO)) (P-VAR (VAR-INFO) (CADDR VAR-INFO)) (KEYWORD (VAR-INFO) (CADDDR VAR-INFO))) (WHEN (ODDP (LIST-LENGTH ARGUMENTS)) (ERROR (QUOTE LAMBDA-LIST-MISMATCH) :MISMATCH-TYPE :ODD-NUMBER-OF-KEYWORD-ARGUMENTS)) (LET (TEMP-BINDINGS BINDINGS OTHER-KEYS-FOUND-P IGNORABLES ALREADY-SEEN ARGS) (UNLESS (FIND :ALLOW-OTHER-KEYS KEY :KEY (FUNCTION KEYWORD)) (LET ((ALLOW-OTHER-KEYS-TEMP (GENSYM (SYMBOL-NAME :ALLOW-OTHER-KEYS)))) (PUSH ALLOW-OTHER-KEYS-TEMP IGNORABLES) (PUSH (LIST ALLOW-OTHER-KEYS-TEMP NIL NIL :ALLOW-OTHER-KEYS) KEY))) (LOOP :FOR VAR :IN ARGUMENTS :BY (FUNCTION CDDR) :FOR VALUE :IN (CDR ARGUMENTS) :BY (FUNCTION CDDR) :DO (LET ((VAR-INFO (FIND VAR KEY :KEY (FUNCTION KEYWORD)))) (IF (AND VAR-INFO (NOT (MEMBER VAR ALREADY-SEEN))) (PROGN (PUSH-ARGUMENT-BINDING (VAR VAR-INFO) VALUE TEMP-BINDINGS BINDINGS) (WHEN (P-VAR VAR-INFO) (PUSH (SYSTEM::BACKQ-CONS (P-VAR VAR-INFO) (QUOTE (T))) BINDINGS)) (PUSH VAR ARGS) (PUSH (VAR VAR-INFO) ARGS) (PUSH VAR ALREADY-SEEN)) (LET ((G (GENSYM))) (PUSH (SYSTEM::BACKQ-LIST G VALUE) TEMP-BINDINGS) (PUSH VAR ARGS) (PUSH G ARGS) (PUSH G IGNORABLES) (UNLESS VAR-INFO (SETF OTHER-KEYS-FOUND-P T)))))) (LET (DEFAULTS) (LOOP :FOR VAR-INFO :IN KEY :DO (UNLESS (FIND (VAR VAR-INFO) BINDINGS :KEY (FUNCTION CAR)) (PUSH (SYSTEM::BACKQ-LIST (VAR VAR-INFO) (INITFORM VAR-INFO)) DEFAULTS) (WHEN (P-VAR VAR-INFO) (PUSH (SYSTEM::BACKQ-CONS (P-VAR VAR-INFO) (QUOTE (NIL))) DEFAULTS)))) (SETF BINDINGS (APPEND (NREVERSE DEFAULTS) BINDINGS))) (WHEN (AND OTHER-KEYS-FOUND-P (NOT ALLOW-OTHERS-P)) (IF (LOOP :FOR VAR :IN ARGUMENTS :BY (FUNCTION CDDR) :IF (EQ VAR :ALLOW-OTHER-KEYS) :DO (RETURN T)) (LET* ((ARG (VAR (FIND :ALLOW-OTHER-KEYS KEY :KEY (FUNCTION KEYWORD)))) (BINDING (FIND ARG BINDINGS :KEY (FUNCTION CAR))) (FORM (CADR BINDING))) (IF (CONSTANTP FORM) (UNLESS (EVAL FORM) (ERROR (QUOTE LAMBDA-LIST-MISMATCH) :MISMATCH-TYPE :UNKNOWN-KEYWORD)) (SETF (CADR BINDING) (SYSTEM::BACKQ-LIST* (QUOTE OR) (CADR BINDING) (QUOTE ((ERROR (QUOTE PROGRAM-ERROR) "Unrecognized keyword argument"))))))) (ERROR (QUOTE LAMBDA-LIST-MISMATCH) :MISMATCH-TYPE :UNKNOWN-KEYWORD))) (WHEN REST (SETF BINDINGS (APPEND BINDINGS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (VAR REST) (SYSTEM::BACKQ-CONS (QUOTE LIST) (NREVERSE ARGS))))))) (VALUES BINDINGS TEMP-BINDINGS IGNORABLES))))
     [java] ; (DEFUN EXPAND-FUNCTION-CALL-INLINE (FORM LAMBDA-LIST BODY ARGS) (HANDLER-CASE (MULTIPLE-VALUE-BIND (BINDINGS IGNORABLES) (MATCH-LAMBDA-LIST (MULTIPLE-VALUE-LIST (PARSE-LAMBDA-LIST LAMBDA-LIST)) ARGS) (SYSTEM::BACKQ-LIST* (QUOTE LET*) BINDINGS (SYSTEM::BACKQ-APPEND (WHEN IGNORABLES (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-CONS (QUOTE IGNORABLE) IGNORABLES)))) BODY))) (LAMBDA-LIST-MISMATCH (X) (COMPILER-WARN "Invalid function call: ~S (mismatch type: ~A)" FORM (LAMBDA-LIST-MISMATCH-TYPE X)) FORM)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (LIST LIST BLOCK-NODE) LIST) PROCESS-DECLARATIONS-FOR-VARS))
     [java] ; (DEFUN PROCESS-DECLARATIONS-FOR-VARS (BODY VARIABLES BLOCK) (LET ((FREE-SPECIALS (QUOTE NIL))) (DOLIST (SUBFORM BODY) (UNLESS (AND (CONSP SUBFORM) (EQ (%CAR SUBFORM) (QUOTE DECLARE))) (RETURN)) (LET ((DECLS (%CDR SUBFORM))) (DOLIST (DECL DECLS) (CASE (CAR DECL) ((DYNAMIC-EXTENT FTYPE INLINE NOTINLINE OPTIMIZE)) ((IGNORE IGNORABLE) (PROCESS-IGNORE/IGNORABLE (%CAR DECL) (%CDR DECL) VARIABLES)) (SPECIAL (DOLIST (NAME (%CDR DECL)) (LET ((VARIABLE (FIND-VARIABLE NAME VARIABLES))) (COND ((AND VARIABLE (EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*)) (SETF (VARIABLE-SPECIAL-P VARIABLE) T)) (T (DFORMAT T "adding free special ~S~%" NAME) (PUSH (MAKE-VARIABLE :NAME NAME :SPECIAL-P T :BLOCK BLOCK) FREE-SPECIALS)))))) (TYPE (DOLIST (NAME (CDDR DECL)) (LET ((VARIABLE (FIND-VARIABLE NAME VARIABLES))) (WHEN (AND VARIABLE (EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*)) (SETF (VARIABLE-DECLARED-TYPE VARIABLE) (MAKE-COMPILER-TYPE (CADR DECL))))))) (T (DOLIST (NAME (CDR DECL)) (LET ((VARIABLE (FIND-VARIABLE NAME VARIABLES))) (WHEN VARIABLE (SETF (VARIABLE-DECLARED-TYPE VARIABLE) (MAKE-COMPILER-TYPE (%CAR DECL))))))))))) FREE-SPECIALS))
     [java] ; (DEFUN CHECK-NAME (NAME) (UNLESS (SYMBOLP NAME) (COMPILER-ERROR "The variable ~S is not a symbol." NAME)) (WHEN (CONSTANTP NAME) (COMPILER-ERROR "The name of the variable ~S is already in use to name a constant." NAME)) NAME)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) P1-BODY))
     [java] ; (DEFUN P1-BODY (BODY) (DECLARE (OPTIMIZE SPEED)) (LOOP FOR FORM IN BODY FOR PROCESSED-FORM = (P1 FORM) COLLECT PROCESSED-FORM WHILE (NOT (AND (CONSP PROCESSED-FORM) (MEMQ (CAR PROCESSED-FORM) (QUOTE (GO RETURN-FROM THROW)))))))
     [java] ; (DEFKNOWN P1-DEFAULT (T) T)
     [java] ; (DECLAIM (INLINE P1-DEFAULT))
     [java] ; (DEFUN P1-DEFAULT (FORM) (DECLARE (OPTIMIZE SPEED)) (CONS (CAR FORM) (LOOP FOR F IN (CDR FORM) COLLECT (P1 F))))
     [java] ; (DEFUN LET/LET*-VARIABLES (BLOCK BINDINGS) (LOOP FOR BINDING IN BINDINGS IF (CONSP BINDING) COLLECT (MAKE-VARIABLE :NAME (CHECK-NAME (CAR BINDING)) :INITFORM (CADR BINDING) :BLOCK BLOCK) ELSE COLLECT (MAKE-VARIABLE :NAME (CHECK-NAME BINDING) :BLOCK BLOCK)))
     [java] ; (DEFUN VALID-LET/LET*-BINDING-P (VARSPEC) (WHEN (CONSP VARSPEC) (UNLESS (<= 1 (LENGTH VARSPEC) 2) (COMPILER-ERROR "The LET/LET* binding specification ~
     [java]                        ~S is invalid." VARSPEC))) T)
     [java] ; (DEFUN CHECK-LET/LET*-BINDINGS (BINDINGS) (EVERY (FUNCTION VALID-LET/LET*-BINDING-P) BINDINGS))
     [java] ; (DEFKNOWN P1-LET-VARS (T) T)
     [java] ; (DEFUN P1-LET-VARS (BLOCK VARLIST) (CHECK-LET/LET*-BINDINGS VARLIST) (LET ((VARS (LET/LET*-VARIABLES BLOCK VARLIST))) (DOLIST (VARIABLE VARS) (SETF (VARIABLE-INITFORM VARIABLE) (P1 (VARIABLE-INITFORM VARIABLE)))) (DOLIST (VARIABLE VARS) (PUSH VARIABLE *VISIBLE-VARIABLES*) (PUSH VARIABLE *ALL-VARIABLES*)) VARS))
     [java] ; (DEFKNOWN P1-LET*-VARS (T) T)
     [java] ; (DEFUN P1-LET*-VARS (BLOCK VARLIST) (CHECK-LET/LET*-BINDINGS VARLIST) (LET ((VARS (LET/LET*-VARIABLES BLOCK VARLIST))) (DOLIST (VARIABLE VARS) (SETF (VARIABLE-INITFORM VARIABLE) (P1 (VARIABLE-INITFORM VARIABLE))) (PUSH VARIABLE *VISIBLE-VARIABLES*) (PUSH VARIABLE *ALL-VARIABLES*)) VARS))
     [java] ; (DEFUN P1-LET/LET* (FORM) (DECLARE (TYPE CONS FORM)) (LET* ((*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (BLOCK (MAKE-LET/LET*-NODE)) (*BLOCK* BLOCK) (OP (%CAR FORM)) (VARLIST (CADR FORM)) (BODY (CDDR FORM))) (AVER (OR (EQ OP (QUOTE LET)) (EQ OP (QUOTE LET*)))) (WHEN (EQ OP (QUOTE LET)) (IF (NULL (CDR VARLIST)) (SETF OP (QUOTE LET*)) (DOLIST (VARSPEC VARLIST (SETF OP (QUOTE LET*))) (OR (ATOM VARSPEC) (CONSTANTP (CADR VARSPEC)) (EQ (CAR VARSPEC) (CADR VARSPEC)) (RETURN))))) (LET ((VARS (IF (EQ OP (QUOTE LET)) (P1-LET-VARS BLOCK VARLIST) (P1-LET*-VARS BLOCK VARLIST)))) (DOLIST (VARIABLE VARS) (WHEN (SPECIAL-VARIABLE-P (VARIABLE-NAME VARIABLE)) (SETF (VARIABLE-SPECIAL-P VARIABLE) T (LET-ENVIRONMENT-REGISTER BLOCK) T))) (SETF (LET-FREE-SPECIALS BLOCK) (PROCESS-DECLARATIONS-FOR-VARS BODY (REVERSE VARS) BLOCK)) (SETF (LET-VARS BLOCK) VARS) (DOLIST (VARIABLE (LET-FREE-SPECIALS BLOCK)) (PUSH VARIABLE *VISIBLE-VARIABLES*))) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (SETF BODY (P1-BODY BODY))) (SETF (LET-FORM BLOCK) (LIST* OP VARLIST BODY)) BLOCK)))
     [java] ; (DEFUN P1-LOCALLY (FORM) (LET* ((*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (BLOCK (MAKE-LOCALLY-NODE)) (*BLOCK* BLOCK) (FREE-SPECIALS (PROCESS-DECLARATIONS-FOR-VARS (CDR FORM) NIL BLOCK))) (SETF (LOCALLY-FREE-SPECIALS BLOCK) FREE-SPECIALS) (DOLIST (SPECIAL FREE-SPECIALS) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDR FORM)) (SETF (LOCALLY-FORM BLOCK) (LIST* (QUOTE LOCALLY) (P1-BODY (CDR FORM)))) BLOCK))))
     [java] ; (DEFKNOWN P1-M-V-B (T) T)
     [java] ; (DEFUN P1-M-V-B (FORM) (WHEN (= (LENGTH (CADR FORM)) 1) (LET ((NEW-FORM (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (CAADR FORM) (CADDR FORM))) (CDDDR FORM)))) (RETURN-FROM P1-M-V-B (P1-LET/LET* NEW-FORM)))) (LET* ((*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (BLOCK (MAKE-M-V-B-NODE)) (*BLOCK* BLOCK) (VARLIST (CADR FORM)) (VALUES-FORM (P1 (CADDR FORM))) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (BODY (CDDDR FORM))) (LET ((VARS NIL)) (DOLIST (SYMBOL VARLIST) (LET ((VAR (MAKE-VARIABLE :NAME SYMBOL :BLOCK BLOCK))) (PUSH VAR VARS) (PUSH VAR *VISIBLE-VARIABLES*) (PUSH VAR *ALL-VARIABLES*))) (DOLIST (VARIABLE VARS) (WHEN (SPECIAL-VARIABLE-P (VARIABLE-NAME VARIABLE)) (SETF (VARIABLE-SPECIAL-P VARIABLE) T (M-V-B-ENVIRONMENT-REGISTER BLOCK) T))) (SETF (M-V-B-FREE-SPECIALS BLOCK) (PROCESS-DECLARATIONS-FOR-VARS BODY VARS BLOCK)) (DOLIST (SPECIAL (M-V-B-FREE-SPECIALS BLOCK)) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (SETF (M-V-B-VARS BLOCK) (NREVERSE VARS))) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (SETF BODY (P1-BODY BODY)) (SETF (M-V-B-FORM BLOCK) (LIST* (QUOTE MULTIPLE-VALUE-BIND) VARLIST VALUES-FORM BODY)) BLOCK)))
     [java] ; (DEFUN P1-BLOCK (FORM) (LET* ((BLOCK (MAKE-BLOCK-NODE (CADR FORM))) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (FORM (LIST* (CAR FORM) (CADR FORM) (P1-BODY (CDDR FORM))))) (SETF (BLOCK-FORM BLOCK) FORM) (WHEN (BLOCK-NON-LOCAL-RETURN-P BLOCK) (PUSH (SETF (BLOCK-ID-VARIABLE BLOCK) (MAKE-VARIABLE :NAME (GENSYM) :BLOCK BLOCK :USED-NON-LOCALLY-P T)) *ALL-VARIABLES*)) BLOCK))
     [java] ; (DEFUN P1-CATCH (FORM) (LET* ((TAG (P1 (CADR FORM))) (BODY (CDDR FORM)) (BLOCK (MAKE-CATCH-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (RESULT (QUOTE NIL))) (DOLIST (SUBFORM BODY) (LET ((OP (AND (CONSP SUBFORM) (%CAR SUBFORM)))) (PUSH (P1 SUBFORM) RESULT) (WHEN (MEMQ OP (QUOTE (GO RETURN-FROM THROW))) (RETURN)))) (SETF RESULT (NREVERSE RESULT)) (WHEN (AND (NULL (CDR RESULT)) (CONSP (CAR RESULT)) (EQ (CAAR RESULT) (QUOTE GO))) (RETURN-FROM P1-CATCH (CAR RESULT))) (PUSH TAG RESULT) (PUSH (QUOTE CATCH) RESULT) (SETF (CATCH-FORM BLOCK) RESULT) BLOCK))
     [java] ; (DEFUN P1-THREADS-SYNCHRONIZED-ON (FORM) (LET* ((SYNCHRONIZED-OBJECT (P1 (CADR FORM))) (BODY (CDDR FORM)) (BLOCK (MAKE-SYNCHRONIZED-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*))) (SETF (SYNCHRONIZED-FORM BLOCK) (LIST* (QUOTE THREADS:SYNCHRONIZED-ON) SYNCHRONIZED-OBJECT (P1-BODY BODY))) BLOCK))
     [java] ; (DEFUN P1-JAVA-JRUN-EXCEPTION-PROTECTED (FORM) (ASSERT (EQ (FIRST FORM) (QUOTE JAVA:JRUN-EXCEPTION-PROTECTED))) (ASSERT (OR (EQ (CAR (SECOND FORM)) (QUOTE LAMBDA)) (AND (EQ (CAR (SECOND FORM)) (QUOTE FUNCTION)) (EQ (CAR (SECOND (SECOND FORM))) (QUOTE LAMBDA))))) (LET* ((BODY (IF (EQ (CAR (SECOND FORM)) (QUOTE LAMBDA)) (CDDR (SECOND FORM)) (CDDR (SECOND (SECOND FORM))))) (BLOCK (MAKE-EXCEPTION-PROTECTED-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*))) (SETF (EXCEPTION-PROTECTED-FORM BLOCK) (P1-BODY BODY)) BLOCK))
     [java] ; (DEFUN P1-UNWIND-PROTECT (FORM) (IF (= (LENGTH FORM) 2) (P1 (SECOND FORM)) (LET* ((BLOCK (MAKE-UNWIND-PROTECT-NODE)) (*BLOCK* BLOCK) (UNWINDING-FORMS (P1-BODY (COPY-TREE (CDDR FORM)))) (UNPROTECTED-FORMS (P1-BODY (CDDR FORM))) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (PROTECTED-FORM (P1 (CADR FORM)))) (SETF (UNWIND-PROTECT-FORM BLOCK) (SYSTEM::BACKQ-LIST* (QUOTE UNWIND-PROTECT) PROTECTED-FORM (SYSTEM::BACKQ-CONS (QUOTE PROGN) UNWINDING-FORMS) UNPROTECTED-FORMS)) BLOCK)))
     [java] ; (DEFKNOWN P1-RETURN-FROM (T) T)
     [java] ; (DEFUN P1-RETURN-FROM (FORM) (LET* ((NAME (SECOND FORM)) (BLOCK (FIND-BLOCK NAME)) NON-LOCAL-P) (WHEN (NULL BLOCK) (COMPILER-ERROR "RETURN-FROM ~S: no block named ~S is currently visible." NAME NAME)) (DFORMAT T "p1-return-from block = ~S~%" (BLOCK-NAME BLOCK)) (COND ((EQ (BLOCK-COMPILAND BLOCK) *CURRENT-COMPILAND*) (LET ((PROTECTED (ENCLOSED-BY-PROTECTED-BLOCK-P BLOCK))) (DFORMAT T "p1-return-from protected = ~S~%" PROTECTED) (IF PROTECTED (SETF (BLOCK-NON-LOCAL-RETURN-P BLOCK) T NON-LOCAL-P T) (WHEN (NULL (BLOCK-NEEDS-ENVIRONMENT-RESTORATION BLOCK)) (SETF (BLOCK-NEEDS-ENVIRONMENT-RESTORATION BLOCK) (ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P BLOCK)))))) (T (SETF (BLOCK-NON-LOCAL-RETURN-P BLOCK) T NON-LOCAL-P T))) (WHEN (BLOCK-NON-LOCAL-RETURN-P BLOCK) (DFORMAT T "non-local return from block ~S~%" (BLOCK-NAME BLOCK))) (LET ((VALUE-FORM (P1 (CADDR FORM)))) (PUSH VALUE-FORM (BLOCK-RETURN-VALUE-FORMS BLOCK)) (MAKE-JUMP-NODE (LIST (QUOTE RETURN-FROM) NAME VALUE-FORM) NON-LOCAL-P BLOCK))))
     [java] ; (DEFUN P1-TAGBODY (FORM) (LET* ((BLOCK (MAKE-TAGBODY-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (*VISIBLE-TAGS* *VISIBLE-TAGS*) (LOCAL-TAGS (QUOTE NIL)) (BODY (CDR FORM))) (DOLIST (SUBFORM BODY) (WHEN (OR (SYMBOLP SUBFORM) (INTEGERP SUBFORM)) (LET* ((TAG (MAKE-TAG :NAME SUBFORM :LABEL (GENSYM) :BLOCK BLOCK))) (PUSH TAG LOCAL-TAGS) (PUSH TAG *VISIBLE-TAGS*)))) (LET ((NEW-BODY (QUOTE NIL)) (LIVE T)) (DOLIST (SUBFORM BODY) (COND ((OR (SYMBOLP SUBFORM) (INTEGERP SUBFORM)) (PUSH SUBFORM NEW-BODY) (PUSH (FIND SUBFORM LOCAL-TAGS :KEY (FUNCTION TAG-NAME) :TEST (FUNCTION EQL)) (TAGBODY-TAGS BLOCK)) (SETF LIVE T)) ((NOT LIVE)) (T (WHEN (AND (CONSP SUBFORM) (MEMQ (%CAR SUBFORM) (QUOTE (GO RETURN-FROM THROW)))) (SETF LIVE NIL)) (PUSH (P1 SUBFORM) NEW-BODY)))) (SETF (TAGBODY-FORM BLOCK) (LIST* (QUOTE TAGBODY) (NREVERSE NEW-BODY)))) (WHEN (SOME (FUNCTION TAG-USED-NON-LOCALLY) (TAGBODY-TAGS BLOCK)) (PUSH (SETF (TAGBODY-ID-VARIABLE BLOCK) (MAKE-VARIABLE :NAME (GENSYM) :BLOCK BLOCK :USED-NON-LOCALLY-P T)) *ALL-VARIABLES*)) BLOCK))
     [java] ; (DEFKNOWN P1-GO (T) T)
     [java] ; (DEFUN P1-GO (FORM) (LET* ((NAME (CADR FORM)) (TAG (FIND-TAG NAME))) (UNLESS TAG (ERROR "p1-go: tag not found: ~S" NAME)) (SETF (TAG-USED TAG) T) (LET ((TAG-BLOCK (TAG-BLOCK TAG)) NON-LOCAL-P) (COND ((EQ (TAG-COMPILAND TAG) *CURRENT-COMPILAND*) (IF (ENCLOSED-BY-PROTECTED-BLOCK-P TAG-BLOCK) (SETF (TAGBODY-NON-LOCAL-GO-P TAG-BLOCK) T (TAG-USED-NON-LOCALLY TAG) T NON-LOCAL-P T) (WHEN (NULL (TAGBODY-NEEDS-ENVIRONMENT-RESTORATION TAG-BLOCK)) (SETF (TAGBODY-NEEDS-ENVIRONMENT-RESTORATION TAG-BLOCK) (ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P TAG-BLOCK))))) (T (SETF (TAGBODY-NON-LOCAL-GO-P TAG-BLOCK) T (TAG-USED-NON-LOCALLY TAG) T NON-LOCAL-P T))) (MAKE-JUMP-NODE FORM NON-LOCAL-P TAG-BLOCK TAG))))
     [java] ; (DEFUN SPLIT-DECLS (FORMS SPECIFIC-VARS) (LET ((OTHER-DECLS NIL) (SPECIFIC-DECLS NIL)) (DOLIST (FORM FORMS) (UNLESS (AND (CONSP FORM) (EQ (CAR FORM) (QUOTE DECLARE))) (RETURN)) (DOLIST (DECL (CDR FORM)) (CASE (CAR DECL) ((OPTIMIZE DECLARATION DYNAMIC-EXTENT FTYPE INLINE NOTINLINE) (PUSH (LIST (QUOTE DECLARE) DECL) OTHER-DECLS)) (SPECIAL (DOLIST (NAME (CDR DECL)) (IF (MEMQ NAME SPECIFIC-VARS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE SPECIAL) NAME)) SPECIFIC-DECLS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE SPECIAL) NAME)) OTHER-DECLS)))) (TYPE (DOLIST (NAME (CDDR DECL)) (IF (MEMQ NAME SPECIFIC-VARS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) (CADR DECL) NAME)) SPECIFIC-DECLS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) (CADR DECL) NAME)) OTHER-DECLS)))) (T (DOLIST (NAME (CDR DECL)) (IF (MEMQ NAME SPECIFIC-VARS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (CAR DECL) NAME)) SPECIFIC-DECLS) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (CAR DECL) NAME)) OTHER-DECLS))))))) (VALUES (NREVERSE OTHER-DECLS) (NREVERSE SPECIFIC-DECLS))))
     [java] ; (DEFUN LAMBDA-LIST-NAMES (LAMBDA-LIST) "Returns a list of variable names extracted from `lambda-list'." (MULTIPLE-VALUE-BIND (REQ OPT KEY KEY-P REST ALLOW-KEY-P AUX WHOLE ENV) (PARSE-LAMBDA-LIST LAMBDA-LIST) (DECLARE (IGNORE KEY-P ALLOW-KEY-P)) (MAPCAN (LAMBDA (X) (MAPCAR (FUNCTION FIRST) X)) (LIST REQ OPT KEY AUX (LIST REST) (LIST WHOLE) (LIST ENV)))))
     [java] ; (DEFUN LAMBDA-LIST-KEYWORD-P (X) (MEMQ X LAMBDA-LIST-KEYWORDS))
     [java] ; (DEFUN REWRITE-AUX-VARS (FORM) (LET* ((LAMBDA-LIST (CADR FORM)) (AUX-P (MEMQ (QUOTE &AUX) LAMBDA-LIST)) (POST-AUX-&ENVIRONMENT (MEMQ (QUOTE &ENVIRONMENT) AUX-P)) (LETS (LDIFF (CDR AUX-P) POST-AUX-&ENVIRONMENT)) AUX-VARS) (UNLESS AUX-P (RETURN-FROM REWRITE-AUX-VARS FORM)) (DOLIST (VAR LETS) (WHEN (LAMBDA-LIST-KEYWORD-P VAR) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Lambda list keyword ~A not allowed after &AUX in ~A." :FORMAT-ARGUMENTS (LIST VAR LAMBDA-LIST)))) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY (CDDR FORM)) (DOLIST (FORM LETS) (COND ((CONSP FORM) (PUSH (CAR FORM) AUX-VARS)) (T (PUSH FORM AUX-VARS)))) (SETF LAMBDA-LIST (APPEND (SUBSEQ LAMBDA-LIST 0 (POSITION (QUOTE &AUX) LAMBDA-LIST)) POST-AUX-&ENVIRONMENT)) (MULTIPLE-VALUE-BIND (LET-DECLS LAMBDA-DECLS) (SPLIT-DECLS DECLS (LAMBDA-LIST-NAMES LAMBDA-LIST)) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND LAMBDA-DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE LET*) LETS (SYSTEM::BACKQ-APPEND LET-DECLS BODY)))))))))
     [java] ; (DEFUN REWRITE-LAMBDA (FORM) (SETF FORM (REWRITE-AUX-VARS FORM)) (LET* ((LAMBDA-LIST (CADR FORM))) (IF (NOT (OR (MEMQ (QUOTE &OPTIONAL) LAMBDA-LIST) (MEMQ (QUOTE &KEY) LAMBDA-LIST))) FORM (MULTIPLE-VALUE-BIND (BODY DECLS DOC) (PARSE-BODY (CDDR FORM)) (LET (STATE LET-BINDINGS NEW-LAMBDA-LIST (NON-CONSTANTS 0)) (DO* ((VARS LAMBDA-LIST (CDR VARS)) (VAR (CAR VARS) (CAR VARS))) ((ENDP VARS)) (PUSH (CAR VARS) NEW-LAMBDA-LIST) (LET ((REPLACEMENT (GENSYM))) (FLET ((PARSE-COMPOUND-ARGUMENT (ARG) "Returns the values NAME, KEYWORD, INITFORM, INITFORM-P,
     [java]    SUPPLIED-P and SUPPLIED-P-P assuming ARG is a compound argument." (DESTRUCTURING-BIND (NAME &OPTIONAL (INITFORM NIL INITFORM-SUPPLIED-P) (SUPPLIED-P NIL SUPPLIED-P-SUPPLIED-P)) (IF (LISTP ARG) ARG (LIST ARG)) (IF (LISTP NAME) (VALUES (CADR NAME) (CAR NAME) INITFORM INITFORM-SUPPLIED-P SUPPLIED-P SUPPLIED-P-SUPPLIED-P) (VALUES NAME (MAKE-KEYWORD NAME) INITFORM INITFORM-SUPPLIED-P SUPPLIED-P SUPPLIED-P-SUPPLIED-P))))) (CASE VAR (&OPTIONAL (SETF STATE :OPTIONAL)) (&KEY (SETF STATE :KEY)) ((&WHOLE &ENVIRONMENT &REST &BODY &ALLOW-OTHER-KEYS)) (T (COND ((ATOM VAR) (SETF (CAR NEW-LAMBDA-LIST) (IF (EQ STATE :KEY) (LIST (LIST (MAKE-KEYWORD VAR) REPLACEMENT)) REPLACEMENT)) (PUSH (LIST VAR REPLACEMENT) LET-BINDINGS)) ((CONSTANTP (SECOND VAR)) (MULTIPLE-VALUE-BIND (NAME KEYWORD INITFORM INITFORM-SUPPLIED-P SUPPLIED-P SUPPLIED-P-SUPPLIED-P) (PARSE-COMPOUND-ARGUMENT VAR) (LET ((VAR-FORM (IF (EQ STATE :KEY) (LIST KEYWORD REPLACEMENT) REPLACEMENT)) (SUPPLIED-P-REPLACEMENT (GENSYM))) (SETF (CAR NEW-LAMBDA-LIST) (COND ((NOT INITFORM-SUPPLIED-P) (LIST VAR-FORM)) ((NOT SUPPLIED-P-SUPPLIED-P) (LIST VAR-FORM INITFORM)) (T (LIST VAR-FORM INITFORM SUPPLIED-P-REPLACEMENT)))) (PUSH (LIST NAME REPLACEMENT) LET-BINDINGS) (WHEN SUPPLIED-P-SUPPLIED-P (PUSH (LIST SUPPLIED-P SUPPLIED-P-REPLACEMENT) LET-BINDINGS))))) (T (INCF NON-CONSTANTS) (MULTIPLE-VALUE-BIND (NAME KEYWORD INITFORM INITFORM-SUPPLIED-P SUPPLIED-P SUPPLIED-P-SUPPLIED-P) (PARSE-COMPOUND-ARGUMENT VAR) (DECLARE (IGNORE INITFORM-SUPPLIED-P)) (LET ((VAR-FORM (IF (EQ STATE :KEY) (LIST KEYWORD REPLACEMENT) REPLACEMENT)) (SUPPLIED-P-REPLACEMENT (GENSYM))) (SETF (CAR NEW-LAMBDA-LIST) (LIST VAR-FORM NIL SUPPLIED-P-REPLACEMENT)) (PUSH (LIST NAME (SYSTEM::BACKQ-LIST (QUOTE IF) SUPPLIED-P-REPLACEMENT REPLACEMENT INITFORM)) LET-BINDINGS) (WHEN SUPPLIED-P-SUPPLIED-P (PUSH (LIST SUPPLIED-P SUPPLIED-P-REPLACEMENT) LET-BINDINGS))))))))))) (IF (ZEROP NON-CONSTANTS) FORM (LET ((RV (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) (NREVERSE NEW-LAMBDA-LIST) (SYSTEM::BACKQ-APPEND (WHEN DOC (LIST DOC)) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE LET*) (NREVERSE LET-BINDINGS) (SYSTEM::BACKQ-APPEND DECLS BODY))))))) RV)))))))
     [java] ; (DEFUN VALIDATE-FUNCTION-NAME (NAME) (UNLESS (OR (SYMBOLP NAME) (SETF-FUNCTION-NAME-P NAME)) (COMPILER-ERROR "~S is not a valid function name." NAME)) NAME)
     [java] ; (DEFUN CONSTRUCT-FLET/LABELS-FUNCTION (DEFINITION) (LET* ((NAME (CAR DEFINITION)) (BLOCK-NAME (FDEFINITION-BLOCK-NAME (VALIDATE-FUNCTION-NAME NAME))) (LAMBDA-LIST (CADR DEFINITION)) (COMPILAND (MAKE-COMPILAND :NAME NAME :PARENT *CURRENT-COMPILAND*)) (LOCAL-FUNCTION (MAKE-LOCAL-FUNCTION :NAME NAME :COMPILAND COMPILAND))) (PUSH LOCAL-FUNCTION (COMPILAND-CHILDREN *CURRENT-COMPILAND*)) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY (CDDR DEFINITION)) (SETF (LOCAL-FUNCTION-DEFINITION LOCAL-FUNCTION) (COPY-TREE (CDR DEFINITION))) (SETF (COMPILAND-LAMBDA-EXPRESSION COMPILAND) (REWRITE-LAMBDA (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) BLOCK-NAME BODY))))))) LOCAL-FUNCTION))
     [java] ; (DEFUN P1-FLET (FORM) (LET* ((LOCAL-FUNCTIONS (MAPCAR (FUNCTION (LAMBDA (DEFINITION) (CONSTRUCT-FLET/LABELS-FUNCTION DEFINITION))) (CADR FORM))) (*LOCAL-FUNCTIONS* *LOCAL-FUNCTIONS*)) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (P1-COMPILAND (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION))) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (PUSH LOCAL-FUNCTION *LOCAL-FUNCTIONS*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDDR FORM)) (LET* ((BLOCK (MAKE-FLET-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (BODY (CDDR FORM)) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*)) (SETF (FLET-FREE-SPECIALS BLOCK) (PROCESS-DECLARATIONS-FOR-VARS BODY NIL BLOCK)) (DOLIST (SPECIAL (FLET-FREE-SPECIALS BLOCK)) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (SETF BODY (P1-BODY BODY) (FLET-FORM BLOCK) (LIST* (CAR FORM) (REMOVE-IF (FUNCTION (LAMBDA (FN) (AND (INLINE-P (LOCAL-FUNCTION-NAME FN)) (NOT (LOCAL-FUNCTION-REFERENCES-NEEDED-P FN))))) LOCAL-FUNCTIONS) BODY)) BLOCK))))
     [java] ; (DEFUN P1-LABELS (FORM) (LET* ((LOCAL-FUNCTIONS (MAPCAR (FUNCTION (LAMBDA (DEFINITION) (CONSTRUCT-FLET/LABELS-FUNCTION DEFINITION))) (CADR FORM))) (*LOCAL-FUNCTIONS* *LOCAL-FUNCTIONS*) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*)) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (PUSH LOCAL-FUNCTION *LOCAL-FUNCTIONS*)) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (P1-COMPILAND (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION))) (LET* ((BLOCK (MAKE-LABELS-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (BODY (CDDR FORM)) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*)) (SETF (LABELS-FREE-SPECIALS BLOCK) (PROCESS-DECLARATIONS-FOR-VARS BODY NIL BLOCK)) (DOLIST (SPECIAL (LABELS-FREE-SPECIALS BLOCK)) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDDR FORM)) (SETF (LABELS-FORM BLOCK) (LIST* (CAR FORM) LOCAL-FUNCTIONS (P1-BODY (CDDR FORM)))) BLOCK))))
     [java] ; (DEFKNOWN P1-FUNCALL (T) T)
     [java] ; (DEFUN P1-FUNCALL (FORM) (UNLESS (> (LENGTH FORM) 1) (COMPILER-WARN "Wrong number of arguments for ~A." (CAR FORM)) (RETURN-FROM P1-FUNCALL FORM)) (LET ((FUNCTION-FORM (%CADR FORM))) (WHEN (AND (CONSP FUNCTION-FORM) (EQ (%CAR FUNCTION-FORM) (QUOTE FUNCTION))) (LET ((NAME (%CADR FUNCTION-FORM))) (LET ((SOURCE-TRANSFORM (SOURCE-TRANSFORM NAME))) (WHEN SOURCE-TRANSFORM (LET ((NEW-FORM (EXPAND-SOURCE-TRANSFORM (LIST* NAME (CDDR FORM))))) (RETURN-FROM P1-FUNCALL (P1 NEW-FORM)))))))) (P1-FUNCTION-CALL FORM))
     [java] ; (DEFUN P1-FUNCTION (FORM) (LET ((FORM (COPY-TREE FORM)) LOCAL-FUNCTION) (COND ((AND (CONSP (CADR FORM)) (OR (EQ (CAADR FORM) (QUOTE LAMBDA)) (EQ (CAADR FORM) (QUOTE NAMED-LAMBDA)))) (LET* ((NAMED-LAMBDA-P (EQ (CAADR FORM) (QUOTE NAMED-LAMBDA))) (NAMED-LAMBDA-FORM (WHEN NAMED-LAMBDA-P (CADR FORM))) (NAME (WHEN NAMED-LAMBDA-P (CADR NAMED-LAMBDA-FORM))) (LAMBDA-FORM (IF NAMED-LAMBDA-P (CONS (QUOTE LAMBDA) (CDDR NAMED-LAMBDA-FORM)) (CADR FORM))) (LAMBDA-LIST (CADR LAMBDA-FORM)) (BODY (CDDR LAMBDA-FORM)) (COMPILAND (MAKE-COMPILAND :NAME (IF NAMED-LAMBDA-P NAME (GENSYM "ANONYMOUS-LAMBDA-")) :LAMBDA-EXPRESSION LAMBDA-FORM :PARENT *CURRENT-COMPILAND*)) (LOCAL-FUNCTION (MAKE-LOCAL-FUNCTION :COMPILAND COMPILAND))) (PUSH LOCAL-FUNCTION (COMPILAND-CHILDREN *CURRENT-COMPILAND*)) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-BODY BODY) (SETF (COMPILAND-LAMBDA-EXPRESSION COMPILAND) (REWRITE-LAMBDA (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLS BODY)))) (LET ((*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (*CURRENT-COMPILAND* COMPILAND)) (P1-COMPILAND COMPILAND))) (LIST (QUOTE FUNCTION) LOCAL-FUNCTION))) ((SETF LOCAL-FUNCTION (FIND-LOCAL-FUNCTION (CADR FORM))) (DFORMAT "p1-function local function ~S~%" (CADR FORM)) (SETF (LOCAL-FUNCTION-REFERENCES-NEEDED-P LOCAL-FUNCTION) T) FORM) (T FORM))))
     [java] ; (DEFUN P1-LAMBDA (FORM) (SETF FORM (REWRITE-LAMBDA FORM)) (LET* ((LAMBDA-LIST (CADR FORM))) (WHEN (OR (MEMQ (QUOTE &OPTIONAL) LAMBDA-LIST) (MEMQ (QUOTE &KEY) LAMBDA-LIST)) (LET ((STATE NIL)) (DOLIST (ARG LAMBDA-LIST) (COND ((MEMQ ARG LAMBDA-LIST-KEYWORDS) (SETF STATE ARG)) ((MEMQ STATE (QUOTE (&OPTIONAL &KEY))) (WHEN (AND (CONSP ARG) (NOT (CONSTANTP (SECOND ARG)))) (COMPILER-UNSUPPORTED "P1-LAMBDA: can't handle optional argument with non-constant initform."))))))) (P1-FUNCTION (LIST (QUOTE FUNCTION) FORM))))
     [java] ; (DEFUN P1-EVAL-WHEN (FORM) (LIST* (CAR FORM) (CADR FORM) (MAPCAR (FUNCTION P1) (CDDR FORM))))
     [java] ; (DEFKNOWN P1-PROGV (T) T)
     [java] ; (DEFUN P1-PROGV (FORM) (LET* ((SYMBOLS-FORM (P1 (CADR FORM))) (VALUES-FORM (P1 (CADDR FORM))) (BLOCK (MAKE-PROGV-NODE)) (*BLOCK* BLOCK) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (BODY (CDDDR FORM))) (SETF (PROGV-ENVIRONMENT-REGISTER BLOCK) T (PROGV-FORM BLOCK) (SYSTEM::BACKQ-LIST* (QUOTE PROGV) SYMBOLS-FORM VALUES-FORM (P1-BODY BODY))) BLOCK))
     [java] ; (DEFUN P1-QUOTE (FORM) (UNLESS (= (LENGTH FORM) 2) (COMPILER-ERROR "Wrong number of arguments for special operator ~A (expected 1, but received ~D)." (QUOTE QUOTE) (1- (LENGTH FORM)))) (LET ((ARG (%CADR FORM))) (IF (OR (NUMBERP ARG) (CHARACTERP ARG)) ARG FORM)))
     [java] ; (DEFUN P1-SETQ (FORM) (UNLESS (= (LENGTH FORM) 3) (ERROR "Too many arguments for SETQ.")) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (LET ((VARIABLE (FIND-VISIBLE-VARIABLE ARG1))) (IF VARIABLE (PROGN (WHEN (VARIABLE-IGNORE-P VARIABLE) (COMPILER-STYLE-WARN "Variable ~S is assigned even though it was declared to be ignored." (VARIABLE-NAME VARIABLE))) (INCF (VARIABLE-WRITES VARIABLE)) (COND ((EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*) (DFORMAT T "p1-setq: write ~S~%" ARG1)) (T (DFORMAT T "p1-setq: non-local write ~S~%" ARG1) (SETF (VARIABLE-USED-NON-LOCALLY-P VARIABLE) T)))) (DFORMAT T "p1-setq: unknown variable ~S~%" ARG1))) (LIST (QUOTE SETQ) ARG1 (P1 ARG2))))
     [java] ; (DEFUN P1-THE (FORM) (UNLESS (= (LENGTH FORM) 3) (COMPILER-ERROR "Wrong number of arguments for special operator ~A (expected 2, but received ~D)." (QUOTE THE) (1- (LENGTH FORM)))) (LET ((TYPE (%CADR FORM)) (EXPR (%CADDR FORM))) (COND ((AND (LISTP TYPE) (EQ (CAR TYPE) (QUOTE VALUES))) (P1 EXPR)) ((= *SAFETY* 3) (LET* ((SYM (GENSYM)) (NEW-EXPR (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SYM EXPR)) (SYSTEM::BACKQ-LIST (QUOTE REQUIRE-TYPE) SYM (SYSTEM::BACKQ-LIST (QUOTE QUOTE) TYPE)) SYM))) (P1 NEW-EXPR))) ((AND (<= 1 *SAFETY* 2) (SYMBOLP TYPE)) (LET* ((SYM (GENSYM)) (NEW-EXPR (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SYM EXPR)) (SYSTEM::BACKQ-LIST (QUOTE REQUIRE-TYPE) SYM (SYSTEM::BACKQ-LIST (QUOTE QUOTE) TYPE)) SYM))) (P1 NEW-EXPR))) (T (LIST (QUOTE THE) TYPE (P1 EXPR))))))
     [java] ; (DEFUN P1-TRULY-THE (FORM) (UNLESS (= (LENGTH FORM) 3) (COMPILER-ERROR "Wrong number of arguments for special operator ~A (expected 2, but received ~D)." (QUOTE TRULY-THE) (1- (LENGTH FORM)))) (LIST (QUOTE TRULY-THE) (%CADR FORM) (P1 (%CADDR FORM))))
     [java] ; (DEFKNOWN P1-THROW (T) T)
     [java] ; (DEFUN P1-THROW (FORM) (LIST* (QUOTE THROW) (MAPCAR (FUNCTION P1) (CDR FORM))))
     [java] ; (DEFKNOWN REWRITE-FUNCTION-CALL (T) T)
     [java] ; (DEFUN REWRITE-FUNCTION-CALL (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (COND ((AND (EQ OP (QUOTE FUNCALL)) (LISTP (CAR ARGS)) (EQ (CAAR ARGS) (QUOTE LAMBDA))) (LET ((OP (CAR ARGS)) (ARGS (CDR ARGS))) (EXPAND-FUNCTION-CALL-INLINE FORM (CADR OP) (COPY-TREE (CDDR OP)) ARGS))) ((AND (LISTP OP) (EQ (CAR OP) (QUOTE LAMBDA))) (EXPAND-FUNCTION-CALL-INLINE FORM (CADR OP) (COPY-TREE (CDDR OP)) ARGS)) (T FORM))))
     [java] ; (DEFKNOWN P1-FUNCTION-CALL (T) T)
     [java] ; (DEFUN P1-FUNCTION-CALL (FORM) (LET ((NEW-FORM (REWRITE-FUNCTION-CALL FORM))) (WHEN (NEQ NEW-FORM FORM) (RETURN-FROM P1-FUNCTION-CALL (P1 NEW-FORM)))) (LET* ((OP (CAR FORM)) (LOCAL-FUNCTION (FIND-LOCAL-FUNCTION OP))) (WHEN LOCAL-FUNCTION (WHEN (AND *ENABLE-INLINE-EXPANSION* (INLINE-P OP) (LOCAL-FUNCTION-DEFINITION LOCAL-FUNCTION)) (LET* ((DEFINITION (LOCAL-FUNCTION-DEFINITION LOCAL-FUNCTION)) (LAMBDA-LIST (CAR DEFINITION)) (BODY (CDR DEFINITION)) (EXPANSION (GENERATE-INLINE-EXPANSION OP LAMBDA-LIST BODY (CDR FORM)))) (WHEN EXPANSION (LET ((EXPLAIN *EXPLAIN*)) (WHEN (AND EXPLAIN (MEMQ :CALLS EXPLAIN)) (FORMAT T ";   inlining call to local function ~S~%" OP))) (RETURN-FROM P1-FUNCTION-CALL (LET ((*INLINE-DECLARATIONS* (REMOVE OP *INLINE-DECLARATIONS* :KEY (FUNCTION CAR) :TEST (FUNCTION EQUAL)))) (P1 EXPANSION)))))))) (P1-DEFAULT FORM))
     [java] ; (DEFUN %FUNCALL (FN &REST ARGS) "Dummy FUNCALL wrapper to force p1 not to optimize the call." (APPLY FN ARGS))
     [java] ; (DEFUN P1-VARIABLE-REFERENCE (VAR) (LET ((VARIABLE (FIND-VISIBLE-VARIABLE VAR))) (WHEN (NULL VARIABLE) (UNLESS (OR (SPECIAL-VARIABLE-P VAR) (MEMQ VAR *UNDEFINED-VARIABLES*)) (COMPILER-STYLE-WARN "Undefined variable ~S assumed special" VAR) (PUSH VAR *UNDEFINED-VARIABLES*)) (SETF VARIABLE (MAKE-VARIABLE :NAME VAR :SPECIAL-P T)) (PUSH VARIABLE *VISIBLE-VARIABLES*)) (LET ((REF (MAKE-VAR-REF VARIABLE))) (UNLESS (VARIABLE-SPECIAL-P VARIABLE) (WHEN (VARIABLE-IGNORE-P VARIABLE) (COMPILER-STYLE-WARN "Variable ~S is read even though it was declared to be ignored." (VARIABLE-NAME VARIABLE))) (PUSH REF (VARIABLE-REFERENCES VARIABLE)) (INCF (VARIABLE-READS VARIABLE)) (COND ((EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*) (DFORMAT T "p1: read ~S~%" VAR)) (T (DFORMAT T "p1: non-local read ~S variable-compiland = ~S current compiland = ~S~%" VAR (COMPILAND-NAME (VARIABLE-COMPILAND VARIABLE)) (COMPILAND-NAME *CURRENT-COMPILAND*)) (SETF (VARIABLE-USED-NON-LOCALLY-P VARIABLE) T)))) REF)))
     [java] ; (DEFKNOWN P1 (T) T)
     [java] ; (DEFUN P1 (FORM) (COND ((SYMBOLP FORM) (LET (VALUE) (COND ((NULL FORM) FORM) ((EQ FORM T) FORM) ((KEYWORDP FORM) FORM) ((AND (CONSTANTP FORM) (PROGN (SETF VALUE (SYMBOL-VALUE FORM)) (OR (NUMBERP VALUE) (STRINGP VALUE) (PATHNAMEP VALUE)))) (SETF FORM VALUE)) (T (P1-VARIABLE-REFERENCE FORM))))) ((ATOM FORM) FORM) (T (LET ((OP (%CAR FORM)) HANDLER) (COND ((SYMBOLP OP) (WHEN (FIND-LOCAL-FUNCTION OP) (RETURN-FROM P1 (P1-FUNCTION-CALL FORM))) (WHEN (COMPILER-MACRO-FUNCTION OP) (UNLESS (NOTINLINE-P OP) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED-P) (COMPILER-MACROEXPAND FORM) (WHEN EXPANDED-P (RETURN-FROM P1 (P1 EXPANSION)))))) (COND ((SETF HANDLER (GET OP (QUOTE P1-HANDLER))) (FUNCALL HANDLER FORM)) ((MACRO-FUNCTION OP *COMPILE-FILE-ENVIRONMENT*) (P1 (MACROEXPAND FORM *COMPILE-FILE-ENVIRONMENT*))) ((SPECIAL-OPERATOR-P OP) (COMPILER-UNSUPPORTED "P1: unsupported special operator ~S" OP)) (T (P1-FUNCTION-CALL FORM)))) ((AND (CONSP OP) (EQ (%CAR OP) (QUOTE LAMBDA))) (LET ((MAYBE-OPTIMIZED-CALL (REWRITE-FUNCTION-CALL FORM))) (IF (EQ MAYBE-OPTIMIZED-CALL FORM) (P1 (SYSTEM::BACKQ-LIST* (QUOTE %FUNCALL) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) OP) (CDR FORM))) (P1 MAYBE-OPTIMIZED-CALL)))) (T (COMPILER-UNSUPPORTED "P1 unhandled case ~S" FORM)))))))
     [java] ; (DEFUN INSTALL-P1-HANDLER (SYMBOL HANDLER) (SETF (GET SYMBOL (QUOTE P1-HANDLER)) HANDLER))
     [java] ; (DEFUN INITIALIZE-P1-HANDLERS NIL (DOLIST (PAIR (QUOTE ((AND P1-DEFAULT) (BLOCK P1-BLOCK) (CATCH P1-CATCH) (DECLARE IDENTITY) (EVAL-WHEN P1-EVAL-WHEN) (FLET P1-FLET) (FUNCALL P1-FUNCALL) (FUNCTION P1-FUNCTION) (GO P1-GO) (IF P1-DEFAULT) (LABELS P1-LABELS) (LAMBDA P1-LAMBDA) (LET P1-LET/LET*) (LET* P1-LET/LET*) (LOAD-TIME-VALUE IDENTITY) (LOCALLY P1-LOCALLY) (MULTIPLE-VALUE-BIND P1-M-V-B) (MULTIPLE-VALUE-CALL P1-DEFAULT) (MULTIPLE-VALUE-LIST P1-DEFAULT) (MULTIPLE-VALUE-PROG1 P1-DEFAULT) (OR P1-DEFAULT) (PROGN P1-DEFAULT) (PROGV P1-PROGV) (QUOTE P1-QUOTE) (RETURN-FROM P1-RETURN-FROM) (SETQ P1-SETQ) (SYMBOL-MACROLET IDENTITY) (TAGBODY P1-TAGBODY) (THE P1-THE) (THROW P1-THROW) (TRULY-THE P1-TRULY-THE) (UNWIND-PROTECT P1-UNWIND-PROTECT) (THREADS:SYNCHRONIZED-ON P1-THREADS-SYNCHRONIZED-ON) (JAVA:JRUN-EXCEPTION-PROTECTED P1-JAVA-JRUN-EXCEPTION-PROTECTED) (WITH-INLINE-CODE IDENTITY)))) (INSTALL-P1-HANDLER (%CAR PAIR) (%CADR PAIR))))
     [java] ; (DEFUN P1-COMPILAND (COMPILAND) (LET ((*CURRENT-COMPILAND* COMPILAND) (*LOCAL-FUNCTIONS* *LOCAL-FUNCTIONS*) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (FORM (COMPILAND-LAMBDA-EXPRESSION COMPILAND))) (AVER (EQ (CAR FORM) (QUOTE LAMBDA))) (SETF FORM (REWRITE-LAMBDA FORM)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDDR FORM)) (LET* ((LAMBDA-LIST (CADR FORM)) (BODY (CDDR FORM)) (CLOSURE (MAKE-CLOSURE (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (QUOTE (NIL))) NIL)) (SYMS (SYSTEM::VARLIST CLOSURE)) (VARS NIL) COMPILAND-RESULT) (DOLIST (SYM SYMS) (LET ((VAR (MAKE-VARIABLE :NAME SYM :SPECIAL-P (SPECIAL-VARIABLE-P SYM)))) (PUSH VAR VARS) (PUSH VAR *ALL-VARIABLES*) (PUSH VAR *VISIBLE-VARIABLES*))) (SETF (COMPILAND-ARG-VARS COMPILAND) (NREVERSE VARS)) (LET ((FREE-SPECIALS (PROCESS-DECLARATIONS-FOR-VARS BODY VARS NIL))) (SETF (COMPILAND-FREE-SPECIALS COMPILAND) FREE-SPECIALS) (DOLIST (VAR FREE-SPECIALS) (PUSH VAR *VISIBLE-VARIABLES*))) (SETF COMPILAND-RESULT (LIST* (QUOTE LAMBDA) LAMBDA-LIST (P1-BODY BODY))) (SETF (COMPILAND-%SINGLE-VALUED-P COMPILAND) (SINGLE-VALUED-P COMPILAND-RESULT)) (SETF (COMPILAND-P1-RESULT COMPILAND) COMPILAND-RESULT)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass1.abcl (4.776 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass1.abcl ...
     [java] ; SYSTEM::MAKE-MEMORY-CLASS-LOADER triggers autoloading of org.armedbear.lisp.MemoryClassLoader ...
     [java] ;  Autoloaded org.armedbear.lisp.MemoryClassLoader (0.016 seconds)
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass1.abcl (0.507 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-pass2.lisp ...
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DECLAIM (INLINE POOL-NAME POOL-STRING POOL-NAME-AND-TYPE POOL-CLASS POOL-FIELD POOL-METHOD POOL-INT POOL-FLOAT POOL-LONG POOL-DOUBLE))
     [java] ; (DECLAIM (SPECIAL *MEMORY-CLASS-LOADER*))
     [java] ; (DECLAIM (INLINE POOL-NAME POOL-NAME-AND-TYPE POOL-STRING POOL-FIELD POOL-METHOD POOL-INT POOL-FLOAT POOL-LONG POOL-DOUBLE ADD-EXCEPTION-HANDLER))
     [java] ; (DEFUN POOL-NAME (NAME) (POOL-ADD-UTF8 *POOL* NAME))
     [java] ; (DEFUN POOL-NAME-AND-TYPE (NAME TYPE) (POOL-ADD-NAME/TYPE *POOL* NAME TYPE))
     [java] ; (DEFUN POOL-CLASS (NAME) (POOL-ADD-CLASS *POOL* NAME))
     [java] ; (DEFUN POOL-STRING (STRING) (POOL-ADD-STRING *POOL* STRING))
     [java] ; (DEFUN POOL-FIELD (CLASS-NAME FIELD-NAME TYPE-NAME) (POOL-ADD-FIELD-REF *POOL* CLASS-NAME FIELD-NAME TYPE-NAME))
     [java] ; (DEFUN POOL-METHOD (CLASS-NAME METHOD-NAME TYPE-NAME) (POOL-ADD-METHOD-REF *POOL* CLASS-NAME METHOD-NAME TYPE-NAME))
     [java] ; (DEFUN POOL-INT (INT) (POOL-ADD-INT *POOL* INT))
     [java] ; (DEFUN POOL-FLOAT (FLOAT) (POOL-ADD-FLOAT *POOL* FLOAT))
     [java] ; (DEFUN POOL-LONG (LONG) (POOL-ADD-LONG *POOL* LONG))
     [java] ; (DEFUN POOL-DOUBLE (DOUBLE) (POOL-ADD-DOUBLE *POOL* DOUBLE))
     [java] ; (DEFUN ADD-EXCEPTION-HANDLER (START END HANDLER TYPE) (CODE-ADD-EXCEPTION-HANDLER *CURRENT-CODE-ATTRIBUTE* START END HANDLER TYPE))
     [java] ; (DEFKNOWN EMIT-PUSH-NIL NIL T)
     [java] ; (DECLAIM (INLINE EMIT-PUSH-NIL))
     [java] ; (DEFUN EMIT-PUSH-NIL NIL (EMIT-GETSTATIC +LISP+ "NIL" +LISP-SYMBOL+))
     [java] ; (DEFKNOWN EMIT-PUSH-NIL-SYMBOL NIL T)
     [java] ; (DECLAIM (INLINE EMIT-PUSH-NIL-SYMBOL))
     [java] ; (DEFUN EMIT-PUSH-NIL-SYMBOL NIL (EMIT-GETSTATIC +LISP-NIL+ "NIL" +LISP-SYMBOL+))
     [java] ; (DEFKNOWN EMIT-PUSH-T NIL T)
     [java] ; (DECLAIM (INLINE EMIT-PUSH-T))
     [java] ; (DEFUN EMIT-PUSH-T NIL (EMIT-GETSTATIC +LISP+ "T" +LISP-SYMBOL+))
     [java] ; (DEFKNOWN EMIT-PUSH-FALSE (T) T)
     [java] ; (DEFUN EMIT-PUSH-FALSE (REPRESENTATION) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_0))) ((NIL) (EMIT-PUSH-NIL))))
     [java] ; (DEFKNOWN EMIT-PUSH-TRUE (T) T)
     [java] ; (DEFUN EMIT-PUSH-TRUE (REPRESENTATION) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_1))) ((NIL) (EMIT-PUSH-T))))
     [java] ; (DEFKNOWN EMIT-PUSH-CONSTANT-INT (FIXNUM) T)
     [java] ; (DEFUN EMIT-PUSH-CONSTANT-INT (N) (CASE N (-1 (EMIT (QUOTE ICONST_M1))) (0 (EMIT (QUOTE ICONST_0))) (1 (EMIT (QUOTE ICONST_1))) (2 (EMIT (QUOTE ICONST_2))) (3 (EMIT (QUOTE ICONST_3))) (4 (EMIT (QUOTE ICONST_4))) (5 (EMIT (QUOTE ICONST_5))) (T (IF (<= -128 N 127) (EMIT (QUOTE BIPUSH) N) (IF (<= -32768 N 32767) (EMIT (QUOTE SIPUSH) N) (EMIT (QUOTE LDC) (POOL-INT N)))))))
     [java] ; (DEFKNOWN EMIT-PUSH-CONSTANT-LONG (INTEGER) T)
     [java] ; (DEFUN EMIT-PUSH-CONSTANT-LONG (N) (CASE N (0 (EMIT (QUOTE LCONST_0))) (1 (EMIT (QUOTE LCONST_1))) (T (EMIT (QUOTE LDC2_W) (POOL-LONG N)))))
     [java] ; (DEFKNOWN EMIT-PUSH-CONSTANT-FLOAT (SINGLE-FLOAT) T)
     [java] ; (DEFUN EMIT-PUSH-CONSTANT-FLOAT (N) (CASE N (0.0f0 (EMIT (QUOTE FCONST_0))) (1.0f0 (EMIT (QUOTE FCONST_1))) (2.0f0 (EMIT (QUOTE FCONST_2))) (T (EMIT (QUOTE LDC) (POOL-FLOAT N)))))
     [java] ; (DEFKNOWN EMIT-PUSH-CONSTANT-DOUBLE (DOUBLE-FLOAT) T)
     [java] ; (DEFUN EMIT-PUSH-CONSTANT-DOUBLE (N) (CASE N (0.0d0 (EMIT (QUOTE DCONST_0))) (1.0d0 (EMIT (QUOTE DCONST_1))) (T (EMIT (QUOTE LDC2_W) (POOL-DOUBLE N)))))
     [java] ; (DEFKNOWN EMIT-DUP (SYMBOL) T)
     [java] ; (DEFUN EMIT-DUP (REPRESENTATION &KEY (PAST NIL PAST-SUPPLIED-P)) "Emits the 'dup' instruction required to duplicate `representation'.
     [java]
     [java] If `past' is specified, the newly duplicated value is inserted on the
     [java] stack past the top-most value, which is assumed to be of the representation
     [java] passed in `past'." (EMIT (NTH (IF PAST-SUPPLIED-P (REPRESENTATION-SIZE PAST) 0) (ECASE (REPRESENTATION-SIZE REPRESENTATION) (1 (QUOTE (DUP DUP_X1 DUP_X2))) (2 (QUOTE (DUP2 DUP2_X1 DUP2_X2)))))))
     [java] ; (DEFKNOWN EMIT-SWAP (SYMBOL SYMBOL) T)
     [java] ; (DEFUN EMIT-SWAP (REP1 REP2) "Swaps 2 values on the stack,
     [java] the top-most value's representation being 'rep1'." (LET ((R1-SIZE (REPRESENTATION-SIZE REP1)) (R2-SIZE (REPRESENTATION-SIZE REP2))) (COND ((AND (= 1 R1-SIZE) (= 1 R2-SIZE)) (EMIT (QUOTE SWAP))) ((AND (= 1 R1-SIZE) (= 2 R2-SIZE)) (EMIT (QUOTE DUP2_X1)) (EMIT (QUOTE POP2))) ((AND (= 2 R1-SIZE) (= 1 R2-SIZE)) (EMIT (QUOTE DUP_X2)) (EMIT (QUOTE POP))) ((AND (= 2 R1-SIZE) (= 2 R2-SIZE)) (EMIT (QUOTE DUP2_X2)) (EMIT (QUOTE POP2))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION * T) EMIT-INVOKESTATIC))
     [java] ; (DEFUN EMIT-INVOKESTATIC (CLASS-NAME METHOD-NAME ARG-TYPES RETURN-TYPE) (LET* ((STACK-EFFECT (APPLY (FUNCTION DESCRIPTOR-STACK-EFFECT) RETURN-TYPE ARG-TYPES)) (INDEX (POOL-ADD-METHOD-REF *POOL* CLASS-NAME METHOD-NAME (CONS RETURN-TYPE ARG-TYPES))) (INSTRUCTION (%EMIT (QUOTE INVOKESTATIC) INDEX))) (SETF (INSTRUCTION-STACK INSTRUCTION) STACK-EFFECT)))
     [java] ; (DECLAIM (FTYPE (FUNCTION T STRING) PRETTY-JAVA-CLASS))
     [java] ; (DEFUN PRETTY-JAVA-CLASS (CLASS) (COND ((EQUAL CLASS +LISP-OBJECT+) "LispObject") ((EQUAL CLASS +LISP-SYMBOL+) "Symbol") ((EQUAL CLASS +LISP-THREAD+) "LispThread") (T CLASS)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) CONS) GET-DESCRIPTOR-INFO))
     [java] ; (DEFUN GET-DESCRIPTOR-INFO (ARG-TYPES RETURN-TYPE) (SETF (GETHASH KEY HT) (MAKE-DESCRIPTOR-INFO ARG-TYPES RETURN-TYPE)))
     [java] ;SYSTEM:%MAKE-CONDITION triggers autoloading of org.armedbear.lisp.make_condition ...
     [java] ; Autoloaded org.armedbear.lisp.make_condition (0.04 seconds)
     [java] ; in (DEFUN GET-DESCRIPTOR-INFO (ARG-TYPES RETURN-TYPE) (SETF (GETHASH KEY HT) (MAKE-DESCRIPTOR-INFO ARG-TYPES RETURN-TYPE)))
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   ;COMMON-LISP:SIMPLE-CONDITION-FORMAT-CONTROL triggers autoloading of org.armedbear.lisp.SimpleCondition ...
     [java] ; Autoloaded org.armedbear.lisp.SimpleCondition (0.007 seconds)
     [java] Undefined variable KEY assumed special
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   Undefined variable HT assumed special
     [java]
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) CONS) MAKE-DESCRIPTOR-INFO))
     [java] ; (DEFUN MAKE-DESCRIPTOR-INFO (ARG-TYPES RETURN-TYPE) (LET ((DESCRIPTOR (WITH-STANDARD-IO-SYNTAX (WITH-OUTPUT-TO-STRING (S) (PRINC #\( S) (DOLIST (TYPE ARG-TYPES) (PRINC TYPE S)) (PRINC #\) S) (PRINC (OR RETURN-TYPE "V") S)))) (STACK-EFFECT (LET ((RESULT (COND ((NULL RETURN-TYPE) 0) ((OR (EQUAL RETURN-TYPE "J") (EQUAL RETURN-TYPE "D")) 2) (T 1)))) (DOLIST (TYPE ARG-TYPES RESULT) (DECF RESULT (IF (OR (EQUAL TYPE "J") (EQUAL TYPE "D")) 2 1)))))) (CONS DESCRIPTOR STACK-EFFECT)))
     [java] ; (DEFKNOWN EMIT-INVOKEINTERFACE (T T T T) T)
     [java] ; (DEFUN EMIT-INVOKEINTERFACE (CLASS-NAME METHOD-NAME ARG-TYPES RETURN-TYPE) (LET* ((INFO (GET-DESCRIPTOR-INFO ARG-TYPES RETURN-TYPE)) (DESCRIPTOR (CAR INFO)) (STACK-EFFECT (CDR INFO)) (INSTRUCTION (EMIT (QUOTE INVOKEINTERFACE) CLASS-NAME METHOD-NAME DESCRIPTOR (1+ (LENGTH ARG-TYPES))))) (DECLARE (TYPE (SIGNED-BYTE 8) STACK-EFFECT)) (LET ((EXPLAIN *EXPLAIN*)) (WHEN (AND EXPLAIN (MEMQ :JAVA-CALLS EXPLAIN)) (UNLESS (STRING= METHOD-NAME "execute") (FORMAT T ";   call to ~A ~A.~A(~{~A~^,~})~%" (PRETTY-JAVA-TYPE RETURN-TYPE) (PRETTY-JAVA-CLASS CLASS-NAME) METHOD-NAME (MAPCAR (QUOTE PRETTY-JAVA-TYPE) ARG-TYPES))))) (SETF (INSTRUCTION-STACK INSTRUCTION) (- STACK-EFFECT 1))))
     [java] ; (DEFKNOWN EMIT-INVOKEVIRTUAL (T T T T) T)
     [java] ; (DEFUN EMIT-INVOKEVIRTUAL (CLASS-NAME METHOD-NAME ARG-TYPES RETURN-TYPE) (LET* ((STACK-EFFECT (APPLY (FUNCTION DESCRIPTOR-STACK-EFFECT) RETURN-TYPE ARG-TYPES)) (INDEX (POOL-ADD-METHOD-REF *POOL* CLASS-NAME METHOD-NAME (CONS RETURN-TYPE ARG-TYPES))) (INSTRUCTION (%EMIT (QUOTE INVOKEVIRTUAL) INDEX))) (DECLARE (TYPE (SIGNED-BYTE 8) STACK-EFFECT)) (LET ((EXPLAIN *EXPLAIN*)) (WHEN (AND EXPLAIN (MEMQ :JAVA-CALLS EXPLAIN)) (UNLESS (STRING= METHOD-NAME "execute") (FORMAT T ";   call to ~A ~A.~A(~{~A~^,~})~%" (PRETTY-JAVA-TYPE RETURN-TYPE) (PRETTY-JAVA-CLASS CLASS-NAME) METHOD-NAME (MAPCAR (QUOTE PRETTY-JAVA-TYPE) ARG-TYPES))))) (SETF (INSTRUCTION-STACK INSTRUCTION) (1- STACK-EFFECT))))
     [java] ; (DEFKNOWN EMIT-INVOKESPECIAL-INIT (STRING LIST) T)
     [java] ; (DEFUN EMIT-INVOKESPECIAL-INIT (CLASS-NAME ARG-TYPES) (LET* ((STACK-EFFECT (APPLY (FUNCTION DESCRIPTOR-STACK-EFFECT) :VOID ARG-TYPES)) (INDEX (POOL-ADD-METHOD-REF *POOL* CLASS-NAME "<init>" (CONS NIL ARG-TYPES))) (INSTRUCTION (%EMIT (QUOTE INVOKESPECIAL) INDEX))) (DECLARE (TYPE (SIGNED-BYTE 8) STACK-EFFECT)) (SETF (INSTRUCTION-STACK INSTRUCTION) (1- STACK-EFFECT))))
     [java] ; (DEFKNOWN PRETTY-JAVA-TYPE (T) STRING)
     [java] ; (DEFUN PRETTY-JAVA-TYPE (TYPE) (LET ((ARRAYP NIL) (PRETTY-STRING NIL)) (WHEN (AND (STRINGP TYPE) (> (LENGTH TYPE) 0) (CHAR= (CHAR TYPE 0) #\[)) (SETF ARRAYP T TYPE (SUBSEQ TYPE 1))) (SETF PRETTY-STRING (COND ((EQUAL TYPE +LISP-OBJECT+) "LispObject") ((EQUAL TYPE +LISP-SYMBOL+) "Symbol") ((EQUAL TYPE +LISP-THREAD+) "LispThread") ((EQUAL TYPE :CHAR) "char") ((EQUAL TYPE :INT) "int") ((EQUAL TYPE :BOOLEAN) "boolean") ((OR (NULL TYPE) (EQ TYPE :VOID)) "void") (T TYPE))) (WHEN ARRAYP (SETF PRETTY-STRING (CONCATENATE (QUOTE STRING) PRETTY-STRING "[]"))) PRETTY-STRING))
     [java] ; (DECLAIM (INLINE EMIT-GETSTATIC EMIT-PUTSTATIC))
     [java] ; (DEFKNOWN EMIT-GETSTATIC (T T T) T)
     [java] ; (DEFUN EMIT-GETSTATIC (CLASS-NAME FIELD-NAME TYPE) (LET ((INDEX (POOL-ADD-FIELD-REF *POOL* CLASS-NAME FIELD-NAME TYPE))) (%EMIT (QUOTE GETSTATIC) INDEX)))
     [java] ; (DEFKNOWN EMIT-PUTSTATIC (T T T) T)
     [java] ; (DEFUN EMIT-PUTSTATIC (CLASS-NAME FIELD-NAME TYPE) (LET ((INDEX (POOL-ADD-FIELD-REF *POOL* CLASS-NAME FIELD-NAME TYPE))) (%EMIT (QUOTE PUTSTATIC) INDEX)))
     [java] ; (DECLAIM (INLINE EMIT-GETFIELD EMIT-PUTFIELD))
     [java] ; (DEFKNOWN EMIT-GETFIELD (T T T) T)
     [java] ; (DEFUN EMIT-GETFIELD (CLASS-NAME FIELD-NAME TYPE) (LET* ((INDEX (POOL-ADD-FIELD-REF *POOL* CLASS-NAME FIELD-NAME TYPE))) (%EMIT (QUOTE GETFIELD) INDEX)))
     [java] ; (DEFKNOWN EMIT-PUTFIELD (T T T) T)
     [java] ; (DEFUN EMIT-PUTFIELD (CLASS-NAME FIELD-NAME TYPE) (LET* ((INDEX (POOL-ADD-FIELD-REF *POOL* CLASS-NAME FIELD-NAME TYPE))) (%EMIT (QUOTE PUTFIELD) INDEX)))
     [java] ; (DEFKNOWN EMIT-NEW (T) T)
     [java] ; (DECLAIM (INLINE EMIT-NEW EMIT-ANEWARRAY EMIT-CHECKCAST EMIT-INSTANCEOF))
     [java] ; (DEFUN EMIT-NEW (CLASS-NAME) (%EMIT (QUOTE NEW) (POOL-CLASS CLASS-NAME)))
     [java] ; (DEFKNOWN EMIT-ANEWARRAY (T) T)
     [java] ; (DEFUN EMIT-ANEWARRAY (CLASS-NAME) (APPLY (FUNCTION %EMIT) (QUOTE ANEWARRAY) (U2 (POOL-CLASS CLASS-NAME))))
     [java] ; (DEFKNOWN EMIT-CHECKCAST (T) T)
     [java] ; (DEFUN EMIT-CHECKCAST (CLASS-NAME) (APPLY (FUNCTION %EMIT) (QUOTE CHECKCAST) (LIST (POOL-CLASS CLASS-NAME))))
     [java] ; (DEFKNOWN EMIT-INSTANCEOF (T) T)
     [java] ; (DEFUN EMIT-INSTANCEOF (CLASS-NAME) (APPLY (FUNCTION %EMIT) (QUOTE INSTANCEOF) (LIST (POOL-CLASS CLASS-NAME))))
     [java] ; (DEFVAR TYPE-REPRESENTATIONS (QUOTE ((:INT FIXNUM) (:LONG (INTEGER -9223372036854775808 9223372036854775807)) (:FLOAT SINGLE-FLOAT) (:DOUBLE DOUBLE-FLOAT) (:CHAR BASE-CHAR CHARACTER) (:BOOLEAN BOOLEAN))) "Lists the widest Lisp types to be stored in each of the Java primitives
     [java] supported (and used) by the compiler.")
     [java] ; (DEFUN TYPE-REPRESENTATION (THE-TYPE) "Converts a type specification or compiler type into a representation." (WHEN (NULL THE-TYPE) (RETURN-FROM TYPE-REPRESENTATION)) (DO* ((TYPES TYPE-REPRESENTATIONS (CDR TYPES))) ((ENDP TYPES) NIL) (DO* ((TYPE-LIST (CDR (CAR TYPES)) (CDR TYPE-LIST)) (TYPE (CAR TYPE-LIST) (CAR TYPE-LIST))) ((ENDP TYPE-LIST)) (WHEN (OR (SUBTYPEP THE-TYPE TYPE) (COMPILER-SUBTYPEP THE-TYPE (MAKE-COMPILER-TYPE TYPE))) (RETURN-FROM TYPE-REPRESENTATION (CAAR TYPES))))))
     [java] ; (DEFKNOWN EMIT-UNBOX-BOOLEAN NIL T)
     [java] ; (DEFUN EMIT-UNBOX-BOOLEAN NIL (EMIT-INSTANCEOF +LISP-NIL+) (EMIT (QUOTE ICONST_1)) (EMIT (QUOTE IXOR)))
     [java] ; (DEFKNOWN EMIT-UNBOX-CHARACTER NIL T)
     [java] ; (DEFUN EMIT-UNBOX-CHARACTER NIL (COND ((> *SAFETY* 0) (EMIT-INVOKESTATIC +LISP-CHARACTER+ "getValue" (LISP-OBJECT-ARG-TYPES 1) :CHAR)) (T (EMIT-CHECKCAST +LISP-CHARACTER+) (EMIT-GETFIELD +LISP-CHARACTER+ "value" :CHAR))))
     [java] ; (DEFVAR REP-CONVERSION (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS NIL (SYSTEM::BACKQ-VECTOR (SYSTEM::BACKQ-LIST* (FUNCTION EMIT-UNBOX-BOOLEAN) (FUNCTION EMIT-UNBOX-CHARACTER) (QUOTE ("intValue" "longValue" "floatValue" "doubleValue"))))) (SYSTEM::BACKQ-CONS (QUOTE :BOOLEAN) (SYSTEM::BACKQ-VECTOR (QUOTE (NIL :ERR :ERR :ERR :ERR :ERR)))) (SYSTEM::BACKQ-CONS (QUOTE :CHAR) (SYSTEM::BACKQ-VECTOR (QUOTE (1 NIL :ERR :ERR :ERR :ERR)))) (SYSTEM::BACKQ-CONS (QUOTE :INT) (SYSTEM::BACKQ-VECTOR (QUOTE (1 :ERR NIL I2L I2F I2D)))) (SYSTEM::BACKQ-CONS (QUOTE :LONG) (SYSTEM::BACKQ-VECTOR (QUOTE (1 :ERR L2I NIL L2F L2D)))) (SYSTEM::BACKQ-CONS (QUOTE :FLOAT) (SYSTEM::BACKQ-VECTOR (QUOTE (1 :ERR :ERR :ERR NIL F2D)))) (SYSTEM::BACKQ-CONS (QUOTE :DOUBLE) (SYSTEM::BACKQ-VECTOR (QUOTE (1 :ERR :ERR :ERR D2F NIL))))) "Contains a table with operations to be performed to do
     [java] internal representation conversion.")
     [java] ; (DEFVAR REP-CLASSES (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (QUOTE :BOOLEAN) +LISP-OBJECT+) (SYSTEM::BACKQ-CONS (QUOTE :CHAR) +LISP-CHARACTER+) (SYSTEM::BACKQ-CONS (QUOTE :INT) +LISP-INTEGER+) (SYSTEM::BACKQ-CONS (QUOTE :LONG) +LISP-INTEGER+) (SYSTEM::BACKQ-CONS (QUOTE :FLOAT) +LISP-SINGLE-FLOAT+) (SYSTEM::BACKQ-CONS (QUOTE :DOUBLE) +LISP-DOUBLE-FLOAT+)) "Lists the class on which to call the `getInstance' method on,
     [java] when converting the internal representation to a LispObject.")
     [java] ; (DEFUN CONVERT-REPRESENTATION (IN OUT) "Converts the value on the stack in the `in' representation
     [java] to a value on the stack in the `out' representation." (WHEN (EQL IN OUT) (RETURN-FROM CONVERT-REPRESENTATION)) (WHEN (NULL OUT) (WHEN IN (LET ((CLASS (CDR (ASSOC IN REP-CLASSES)))) (EMIT-INVOKESTATIC CLASS "getInstance" (LIST IN) CLASS))) (RETURN-FROM CONVERT-REPRESENTATION)) (LET* ((IN-MAP (CDR (ASSOC IN REP-CONVERSION))) (OP-NUM (POSITION OUT (QUOTE (:BOOLEAN :CHAR :INT :LONG :FLOAT :DOUBLE)))) (OP (AREF IN-MAP OP-NUM))) (WHEN OP (ASSERT (NEQ OP :ERR)) (COND ((EQL OP 1) (EMIT-MOVE-FROM-STACK NIL IN) (EMIT (QUOTE ICONST_1))) ((FUNCTIONP OP) (FUNCALL OP)) ((STRINGP OP) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ OP NIL OUT)) (T (EMIT OP))))))
     [java] ; (DEFVAR COMMON-REPRESENTATIONS (QUOTE ((:INT :LONG :LONG) (:INT :FLOAT :DOUBLE) (:INT :DOUBLE :DOUBLE) (:FLOAT :INT :DOUBLE) (:FLOAT :DOUBLE :DOUBLE) (:DOUBLE :INT :DOUBLE) (:DOUBLE :FLOAT :DOUBLE))) "Representations to convert unequal representations to, in order
     [java] to get the correct (exact where required) comparisons.")
     [java] ; (DEFUN COMMON-REPRESENTATION (REP1 REP2) (WHEN (EQ REP1 REP2) (RETURN-FROM COMMON-REPRESENTATION REP1)) (DO* ((REMAINING COMMON-REPRESENTATIONS (CDR REMAINING)) (REP (CAR REMAINING) (CAR REMAINING))) ((ENDP REMAINING)) (DESTRUCTURING-BIND (R1 R2 RESULT) REP (WHEN (AND (EQ REP1 R1) (EQ REP2 R2)) (RETURN-FROM COMMON-REPRESENTATION RESULT)))))
     [java] ; (DEFVAR *THREAD* NIL)
     [java] ; (DEFVAR *INITIALIZE-THREAD-VAR* NIL)
     [java] ; (DEFUN MAYBE-INITIALIZE-THREAD-VAR NIL (WHEN *INITIALIZE-THREAD-VAR* (EMIT-INVOKESTATIC +LISP-THREAD+ "currentThread" NIL +LISP-THREAD+) (ASTORE *THREAD*) (SETF *INITIALIZE-THREAD-VAR* NIL)))
     [java] ; (DEFKNOWN ENSURE-THREAD-VAR-INITIALIZED NIL T)
     [java] ; (DECLAIM (INLINE ENSURE-THREAD-VAR-INITIALIZED))
     [java] ; (DEFUN ENSURE-THREAD-VAR-INITIALIZED NIL (SETF *INITIALIZE-THREAD-VAR* T))
     [java] ; (DEFKNOWN EMIT-PUSH-CURRENT-THREAD NIL T)
     [java] ; (DEFUN EMIT-PUSH-CURRENT-THREAD NIL (DECLARE (OPTIMIZE SPEED)) (ENSURE-THREAD-VAR-INITIALIZED) (ALOAD *THREAD*))
     [java] ; (DEFUN VARIABLE-LOCAL-P (VARIABLE) "Return non-NIL if `variable' is a local variable.
     [java]
     [java] Special variables are not considered local." (OR (VARIABLE-REGISTER VARIABLE) (VARIABLE-INDEX VARIABLE)))
     [java] ; (DEFUN EMIT-LOAD-LOCAL-VARIABLE (VARIABLE) "Loads a local variable in the top stack position." (AVER (VARIABLE-LOCAL-P VARIABLE)) (IF (VARIABLE-REGISTER VARIABLE) (ALOAD (VARIABLE-REGISTER VARIABLE)) (PROGN (ALOAD (COMPILAND-ARGUMENT-REGISTER *CURRENT-COMPILAND*)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)))))
     [java] ; (DEFUN EMIT-PUSH-VARIABLE-NAME (VARIABLE) (EMIT-LOAD-EXTERNALIZED-OBJECT (VARIABLE-NAME VARIABLE)))
     [java] ; (DEFKNOWN GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VARIABLE (T T) T)
     [java] ; (DEFUN GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VARIABLE (VARIABLE EXPECTED-TYPE) "Generate a type check for `variable'.
     [java]
     [java] The stack pointer is returned to the position from
     [java] before the emitted code: the code is 'stack-neutral'." (DECLARE (TYPE SYMBOL EXPECTED-TYPE)) (UNLESS (VARIABLE-LOCAL-P VARIABLE) (RETURN-FROM GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VARIABLE)) (LET ((INSTANCEOF-CLASS (ECASE EXPECTED-TYPE (SYMBOL +LISP-SYMBOL+) (CHARACTER +LISP-CHARACTER+) (CONS +LISP-CONS+) (HASH-TABLE +LISP-HASH-TABLE+) (FIXNUM +LISP-FIXNUM+) (STREAM +LISP-STREAM+) (STRING +LISP-ABSTRACT-STRING+) (VECTOR +LISP-ABSTRACT-VECTOR+))) (EXPECTED-TYPE-JAVA-SYMBOL-NAME (CASE EXPECTED-TYPE (HASH-TABLE "HASH_TABLE") (T (SYMBOL-NAME EXPECTED-TYPE)))) (LABEL1 (GENSYM))) (EMIT-LOAD-LOCAL-VARIABLE VARIABLE) (EMIT-INSTANCEOF INSTANCEOF-CLASS) (EMIT (QUOTE IFNE) LABEL1) (EMIT-LOAD-LOCAL-VARIABLE VARIABLE) (EMIT-GETSTATIC +LISP-SYMBOL+ EXPECTED-TYPE-JAVA-SYMBOL-NAME +LISP-SYMBOL+) (EMIT-INVOKESTATIC +LISP+ "type_error" (LISP-OBJECT-ARG-TYPES 2) +LISP-OBJECT+) (EMIT (QUOTE ARETURN)) (LABEL LABEL1)) T)
     [java] ; (DEFUN FIND-TYPE-FOR-TYPE-CHECK (DECLARED-TYPE) (IF (EQ DECLARED-TYPE :NONE) NIL (OR (WHEN (FIXNUM-TYPE-P DECLARED-TYPE) (QUOTE FIXNUM)) (FIND-IF (FUNCTION (LAMBDA (TYPE) (EQ TYPE DECLARED-TYPE))) (QUOTE (SYMBOL CHARACTER CONS HASH-TABLE))) (FIND-IF (FUNCTION (LAMBDA (TYPE) (SUBTYPEP DECLARED-TYPE TYPE))) (QUOTE (STRING VECTOR STREAM))))))
     [java] ; (DEFKNOWN GENERATE-TYPE-CHECK-FOR-VARIABLE (T) T)
     [java] ; (DEFUN GENERATE-TYPE-CHECK-FOR-VARIABLE (VARIABLE) (LET ((TYPE-TO-USE (FIND-TYPE-FOR-TYPE-CHECK (VARIABLE-DECLARED-TYPE VARIABLE)))) (WHEN TYPE-TO-USE (GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VARIABLE VARIABLE TYPE-TO-USE))))
     [java] ; (DEFKNOWN MAYBE-GENERATE-TYPE-CHECK (T) T)
     [java] ; (DEFUN MAYBE-GENERATE-TYPE-CHECK (VARIABLE) (UNLESS (OR (ZEROP *SAFETY*) (VARIABLE-SPECIAL-P VARIABLE) (EQ (VARIABLE-REPRESENTATION VARIABLE) :INT)) (LET ((DECLARED-TYPE (VARIABLE-DECLARED-TYPE VARIABLE))) (UNLESS (EQ DECLARED-TYPE :NONE) (UNLESS (SUBTYPEP (DERIVE-TYPE (VARIABLE-INITFORM VARIABLE)) DECLARED-TYPE) (GENERATE-TYPE-CHECK-FOR-VARIABLE VARIABLE))))))
     [java] ; (DEFKNOWN GENERATE-TYPE-CHECKS-FOR-VARIABLES (LIST) T)
     [java] ; (DEFUN GENERATE-TYPE-CHECKS-FOR-VARIABLES (VARIABLES) (UNLESS (ZEROP *SAFETY*) (DOLIST (VARIABLE VARIABLES) (UNLESS (VARIABLE-SPECIAL-P VARIABLE) (GENERATE-TYPE-CHECK-FOR-VARIABLE VARIABLE))) T))
     [java] ; (DEFUN GENERATE-ARG-COUNT-CHECK (ARITY) (AVER (FIXNUMP ARITY)) (AVER (NOT (MINUSP ARITY))) (AVER (NOT (NULL (COMPILAND-ARGUMENT-REGISTER *CURRENT-COMPILAND*)))) (LET ((LABEL1 (GENSYM))) (ALOAD (COMPILAND-ARGUMENT-REGISTER *CURRENT-COMPILAND*)) (EMIT (QUOTE ARRAYLENGTH)) (EMIT-PUSH-CONSTANT-INT ARITY) (EMIT (QUOTE IF_ICMPEQ) LABEL1) (ALOAD 0) (EMIT-INVOKEVIRTUAL *THIS-CLASS* "argCountError" NIL NIL) (LABEL LABEL1)))
     [java] ; (DEFUN MAYBE-GENERATE-INTERRUPT-CHECK NIL (UNLESS (> *SPEED* *SAFETY*) (LET ((LABEL1 (GENSYM))) (EMIT-GETSTATIC +LISP+ "interrupted" :BOOLEAN) (EMIT (QUOTE IFEQ) LABEL1) (EMIT-INVOKESTATIC +LISP+ "handleInterrupt" NIL NIL) (LABEL LABEL1))))
     [java] ; (DEFKNOWN SINGLE-VALUED-P (T) T)
     [java] ; (DEFUN SINGLE-VALUED-P (FORM) (COND ((NODE-P FORM) (COND ((TAGBODY-NODE-P FORM) T) ((BLOCK-NODE-P FORM) (AND (SINGLE-VALUED-P (CAR (LAST (NODE-FORM FORM)))) (EVERY (FUNCTION SINGLE-VALUED-P) (BLOCK-RETURN-VALUE-FORMS FORM)))) ((OR (FLET-NODE-P FORM) (LABELS-NODE-P FORM) (LET/LET*-NODE-P FORM) (M-V-B-NODE-P FORM) (PROGV-NODE-P FORM) (LOCALLY-NODE-P FORM) (SYNCHRONIZED-NODE-P FORM)) (SINGLE-VALUED-P (CAR (LAST (NODE-FORM FORM))))) ((UNWIND-PROTECT-NODE-P FORM) (SINGLE-VALUED-P (SECOND (NODE-FORM FORM)))) ((CATCH-NODE-P FORM) NIL) ((JUMP-NODE-P FORM) (SINGLE-VALUED-P (NODE-FORM FORM))) ((EXCEPTION-PROTECTED-NODE-P FORM) (SINGLE-VALUED-P (EXCEPTION-PROTECTED-FORM FORM))) (T (ASSERT (NOT "SINGLE-VALUED-P unhandled NODE-P branch"))))) ((VAR-REF-P FORM) T) ((ATOM FORM) T) (T (LET ((OP (%CAR FORM)) RESULT-TYPE COMPILAND) (ASSERT (NOT (MEMBER OP (QUOTE (LET LET* FLET LABELS TAGBODY CATCH MULTIPLE-VALUE-BIND UNWIND-PROTECT BLOCK PROGV LOCALLY))))) (COND ((EQ OP (QUOTE IF)) (AND (SINGLE-VALUED-P (THIRD FORM)) (SINGLE-VALUED-P (FOURTH FORM)))) ((EQ OP (QUOTE PROGN)) (SINGLE-VALUED-P (CAR (LAST FORM)))) ((MEMQ OP (QUOTE (AND OR))) (EVERY (FUNCTION SINGLE-VALUED-P) (CDR FORM))) ((EQ OP (QUOTE RETURN-FROM)) (SINGLE-VALUED-P (THIRD FORM))) ((MEMQ OP (QUOTE (THE TRULY-THE))) (SINGLE-VALUED-P (THIRD FORM))) ((SETF RESULT-TYPE (OR (FUNCTION-RESULT-TYPE OP) (AND (PROCLAIMED-FTYPE OP) (FTYPE-RESULT-TYPE (PROCLAIMED-FTYPE OP))))) (COND ((EQ RESULT-TYPE (QUOTE *)) NIL) ((ATOM RESULT-TYPE) T) ((EQ (%CAR RESULT-TYPE) (QUOTE VALUES)) (= (LENGTH RESULT-TYPE) 2)) (T T))) ((AND (SETF COMPILAND *CURRENT-COMPILAND*) (EQ OP (COMPILAND-NAME COMPILAND))) (COMPILAND-%SINGLE-VALUED-P COMPILAND)) (T NIL))))))
     [java] ; (DEFKNOWN EMIT-CLEAR-VALUES NIL T)
     [java] ; (DEFUN EMIT-CLEAR-VALUES NIL (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (ENSURE-THREAD-VAR-INITIALIZED) (EMIT (QUOTE CLEAR-VALUES) *THREAD*))
     [java] ; (DEFKNOWN MAYBE-EMIT-CLEAR-VALUES (&REST T) T)
     [java] ; (DEFUN MAYBE-EMIT-CLEAR-VALUES (&REST FORMS) (DECLARE (OPTIMIZE SPEED)) (DOLIST (FORM FORMS) (UNLESS (SINGLE-VALUED-P FORM) (ENSURE-THREAD-VAR-INITIALIZED) (EMIT (QUOTE CLEAR-VALUES) *THREAD*) (RETURN))))
     [java] ; (DEFUN COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (&REST FORMS-AND-COMPILE-ARGS) (LET ((FORMS-FOR-EMIT-CLEAR (LOOP FOR (FORM ARG1 ARG2) ON FORMS-AND-COMPILE-ARGS BY (FUNCTION CDDDR) DO (COMPILE-FORM FORM ARG1 ARG2) COLLECTING FORM))) (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) FORMS-FOR-EMIT-CLEAR)))
     [java] ; (DECLAIM (SPECIAL *SAVED-OPERANDS* *OPERAND-REPRESENTATIONS*))
     [java] ; (DEFMACRO WITH-OPERAND-ACCUMULATION ((&BODY ARGUMENT-ACCUMULATION-BODY) &BODY CALL-BODY) "Macro used to operand-stack-safely collect arguments in the
     [java] `argument-accumulation-body' to be available on the stack upon entry of the
     [java] `call-body'. The argument-accumulation-body code may not assume arguments
     [java] are actually on the stack while accumulating.
     [java]
     [java] This macro closes over a code-generating block. Operands can be collected
     [java] using the `accumulate-operand', `compile-operand', `emit-variable-operand'
     [java] and `emit-load-externalized-object-operand'." (SYSTEM::BACKQ-LIST* (QUOTE LET) (QUOTE (*SAVED-OPERANDS* *OPERAND-REPRESENTATIONS* (*REGISTER* *REGISTER*))) (SYSTEM::BACKQ-APPEND ARGUMENT-ACCUMULATION-BODY (SYSTEM::BACKQ-CONS (QUOTE (LOAD-SAVED-OPERANDS)) CALL-BODY))))
     [java] ; (DEFMACRO ACCUMULATE-OPERAND ((REPRESENTATION &KEY UNSAFE-P) &BODY BODY) "Macro used to collect a single operand.
     [java]
     [java] This macro closes over a code-generating block. The generated code should
     [java] leave a single operand on the stack, with representation `representation'.
     [java] The value `unsafe-p', when provided, is an expression evaluated at run time
     [java] to indicate if the body is opstack unsafe." (SYSTEM::BACKQ-CONS (QUOTE PROGN) (SYSTEM::BACKQ-APPEND (WHEN UNSAFE-P (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE WHEN) UNSAFE-P (QUOTE ((SAVE-EXISTING-OPERANDS)))))) BODY (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE SAVE-OPERAND) REPRESENTATION)))))
     [java] ; (DEFUN LOAD-SAVED-OPERANDS NIL "Load any operands which have been saved into registers
     [java] back onto the stack in preparation of the execution of the opcode." (MAPCAR (FUNCTION EMIT-PUSH-REGISTER) (REVERSE *SAVED-OPERANDS*) (REVERSE *OPERAND-REPRESENTATIONS*)))
     [java] ; (DEFUN SAVE-EXISTING-OPERANDS NIL "If any operands have been compiled to the stack,
     [java] save them in registers." (WHEN (NULL *SAVED-OPERANDS*) (DOLIST (REPRESENTATION *OPERAND-REPRESENTATIONS*) (LET ((REGISTER (ALLOCATE-REGISTER REPRESENTATION))) (PUSH REGISTER *SAVED-OPERANDS*) (EMIT-MOVE-FROM-STACK REGISTER REPRESENTATION))) (SETF *SAVED-OPERANDS* (NREVERSE *SAVED-OPERANDS*))))
     [java] ; (DEFUN SAVE-OPERAND (REPRESENTATION) "Saves an operand from the stack (with `representation') to
     [java] a register and updates associated operand collection variables." (PUSH REPRESENTATION *OPERAND-REPRESENTATIONS*) (WHEN *SAVED-OPERANDS* (LET ((REGISTER (ALLOCATE-REGISTER REPRESENTATION))) (PUSH REGISTER *SAVED-OPERANDS*) (EMIT-MOVE-FROM-STACK REGISTER REPRESENTATION))))
     [java] ; (DEFUN COMPILE-OPERAND (FORM REPRESENTATION &OPTIONAL CAST) "Compiles `form' into `representation', storing the resulting value
     [java] on the operand stack, if it's safe to do so. Otherwise stores the value
     [java] in a register" (LET ((UNSAFE (OR *SAVED-OPERANDS* (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS FORM))))) (WHEN (AND UNSAFE (NULL *SAVED-OPERANDS*)) (SAVE-EXISTING-OPERANDS)) (COMPILE-FORM FORM (QUOTE STACK) REPRESENTATION) (WHEN CAST (EMIT-CHECKCAST CAST)) (WHEN UNSAFE (LET ((REGISTER (ALLOCATE-REGISTER REPRESENTATION))) (PUSH REGISTER *SAVED-OPERANDS*) (EMIT-MOVE-FROM-STACK REGISTER REPRESENTATION))) (PUSH REPRESENTATION *OPERAND-REPRESENTATIONS*)))
     [java] ; (DEFUN EMIT-VARIABLE-OPERAND (VARIABLE) "Pushes a variable onto the operand stack, if it's safe to do so. Otherwise
     [java] stores the value in a register." (PUSH (VARIABLE-REPRESENTATION VARIABLE) *OPERAND-REPRESENTATIONS*) (COND ((AND *SAVED-OPERANDS* (VARIABLE-REGISTER VARIABLE)) (PUSH (VARIABLE-REGISTER VARIABLE) *SAVED-OPERANDS*)) (T (EMIT-PUSH-VARIABLE VARIABLE) (WHEN *SAVED-OPERANDS* (LET ((REGISTER (ALLOCATE-REGISTER (VARIABLE-REPRESENTATION VARIABLE)))) (PUSH REGISTER *SAVED-OPERANDS*) (EMIT-MOVE-FROM-STACK REGISTER (VARIABLE-REPRESENTATION VARIABLE)))))))
     [java] ; (DEFUN EMIT-REGISTER-OPERAND (REGISTER REPRESENTATION) (PUSH REPRESENTATION *OPERAND-REPRESENTATIONS*) (COND (*SAVED-OPERANDS* (PUSH REGISTER *SAVED-OPERANDS*)) (T (EMIT-PUSH-REGISTER REGISTER REPRESENTATION))))
     [java] ; (DEFUN EMIT-THREAD-OPERAND NIL (ENSURE-THREAD-VAR-INITIALIZED) (EMIT-REGISTER-OPERAND *THREAD* NIL))
     [java] ; (DEFUN EMIT-LOAD-EXTERNALIZED-OBJECT-OPERAND (OBJECT) (PUSH NIL *OPERAND-REPRESENTATIONS*) (EMIT-LOAD-EXTERNALIZED-OBJECT OBJECT) (WHEN *SAVED-OPERANDS* (LET ((REGISTER (ALLOCATE-REGISTER NIL))) (PUSH REGISTER *SAVED-OPERANDS*) (EMIT (QUOTE ASTORE) REGISTER))))
     [java] ; (DEFKNOWN EMIT-UNBOX-FIXNUM NIL T)
     [java] ; (DEFUN EMIT-UNBOX-FIXNUM NIL (DECLARE (OPTIMIZE SPEED)) (COND ((= *SAFETY* 3) (EMIT-INVOKESTATIC +LISP-FIXNUM+ "getValue" (LISP-OBJECT-ARG-TYPES 1) :INT)) (T (EMIT-CHECKCAST +LISP-FIXNUM+) (EMIT-GETFIELD +LISP-FIXNUM+ "value" :INT))))
     [java] ; (DEFKNOWN EMIT-UNBOX-LONG NIL T)
     [java] ; (DEFUN EMIT-UNBOX-LONG NIL (EMIT-INVOKESTATIC +LISP-BIGNUM+ "longValue" (LISP-OBJECT-ARG-TYPES 1) :LONG))
     [java] ; (DEFKNOWN EMIT-UNBOX-FLOAT NIL T)
     [java] ; (DEFUN EMIT-UNBOX-FLOAT NIL (DECLARE (OPTIMIZE SPEED)) (COND ((= *SAFETY* 3) (EMIT-INVOKESTATIC +LISP-SINGLE-FLOAT+ "getValue" (LISP-OBJECT-ARG-TYPES 1) :FLOAT)) (T (EMIT-CHECKCAST +LISP-SINGLE-FLOAT+) (EMIT-GETFIELD +LISP-SINGLE-FLOAT+ "value" :FLOAT))))
     [java] ; (DEFKNOWN EMIT-UNBOX-DOUBLE NIL T)
     [java] ; (DEFUN EMIT-UNBOX-DOUBLE NIL (DECLARE (OPTIMIZE SPEED)) (COND ((= *SAFETY* 3) (EMIT-INVOKESTATIC +LISP-DOUBLE-FLOAT+ "getValue" (LISP-OBJECT-ARG-TYPES 1) :DOUBLE)) (T (EMIT-CHECKCAST +LISP-DOUBLE-FLOAT+) (EMIT-GETFIELD +LISP-DOUBLE-FLOAT+ "value" :DOUBLE))))
     [java] ; (DEFKNOWN FIX-BOXING (T T) T)
     [java] ; (DEFUN FIX-BOXING (REQUIRED-REPRESENTATION DERIVED-TYPE) "Generate code to convert a boxed LispObject on the stack to the specified
     [java] representation, based on the derived type of the LispObject." (COND ((NULL REQUIRED-REPRESENTATION)) ((EQ REQUIRED-REPRESENTATION :INT) (COND ((AND (FIXNUM-TYPE-P DERIVED-TYPE) (< *SAFETY* 3)) (EMIT-CHECKCAST +LISP-FIXNUM+) (EMIT-GETFIELD +LISP-FIXNUM+ "value" :INT)) (T (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "intValue" NIL :INT)))) ((EQ REQUIRED-REPRESENTATION :CHAR) (EMIT-UNBOX-CHARACTER)) ((EQ REQUIRED-REPRESENTATION :BOOLEAN) (EMIT-UNBOX-BOOLEAN)) ((EQ REQUIRED-REPRESENTATION :LONG) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "longValue" NIL :LONG)) ((EQ REQUIRED-REPRESENTATION :FLOAT) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "floatValue" NIL :FLOAT)) ((EQ REQUIRED-REPRESENTATION :DOUBLE) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "doubleValue" NIL :DOUBLE)) (T (ASSERT NIL))))
     [java] ; (DEFKNOWN EMIT-MOVE-FROM-STACK (T &OPTIONAL T) T)
     [java] ; (DEFUN EMIT-MOVE-FROM-STACK (TARGET &OPTIONAL REPRESENTATION) (DECLARE (OPTIMIZE SPEED)) (COND ((NULL TARGET) (ECASE REPRESENTATION ((:LONG :DOUBLE) (EMIT (QUOTE POP2))) ((NIL :INT :BOOLEAN :CHAR :FLOAT) (EMIT (QUOTE POP))))) ((EQ TARGET (QUOTE STACK))) ((FIXNUMP TARGET) (EMIT (ECASE REPRESENTATION ((:INT :BOOLEAN :CHAR) (QUOTE ISTORE)) (:LONG (QUOTE LSTORE)) (:FLOAT (QUOTE FSTORE)) (:DOUBLE (QUOTE DSTORE)) ((NIL) (QUOTE ASTORE))) TARGET)) (T (SYSTEM::%FORMAT T "emit-move-from-stack general case~%") (AVER NIL))))
     [java] ; (DEFKNOWN EMIT-PUSH-REGISTER (T &OPTIONAL T) T)
     [java] ; (DEFUN EMIT-PUSH-REGISTER (SOURCE &OPTIONAL REPRESENTATION) (DECLARE (OPTIMIZE SPEED)) (ASSERT (FIXNUMP SOURCE)) (EMIT (ECASE REPRESENTATION ((:INT :BOOLEAN :CHAR) (QUOTE ILOAD)) (:LONG (QUOTE LLOAD)) (:FLOAT (QUOTE FLOAD)) (:DOUBLE (QUOTE DLOAD)) ((NIL) (QUOTE ALOAD))) SOURCE))
     [java] ; (DEFKNOWN EMIT-INVOKE-METHOD (T T T) T)
     [java] ; (DEFUN EMIT-INVOKE-METHOD (METHOD-NAME TARGET REPRESENTATION) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ METHOD-NAME NIL +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))
     [java] ; (DEFUN CHECK-NUMBER-OF-ARGS (FORM N &OPTIONAL MINIMUM) (DECLARE (TYPE FIXNUM N)) (LET* ((OP (CAR FORM)) (ARGS (CDR FORM)) (OK (IF MINIMUM (>= (LENGTH ARGS) N) (= (LENGTH ARGS) N)))) (DECLARE (TYPE BOOLEAN OK)) (UNLESS OK (FUNCALL (IF (EQ (SYMBOL-PACKAGE OP) +CL-PACKAGE+) (FUNCTION COMPILER-WARN) (FUNCTION COMPILER-STYLE-WARN)) "Wrong number of arguments for ~A (expected~:[~; at least~] ~D, but received ~D)." OP MINIMUM N (LENGTH ARGS))) OK))
     [java] ; (DEFKNOWN CHECK-ARG-COUNT (T FIXNUM) T)
     [java] ; (DEFUN CHECK-ARG-COUNT (FORM N) (CHECK-NUMBER-OF-ARGS FORM N))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T FIXNUM) T) CHECK-MIN-ARGS))
     [java] ; (DEFUN CHECK-MIN-ARGS (FORM N) (CHECK-NUMBER-OF-ARGS FORM N T))
     [java] ; (DEFUN EMIT-CONSTRUCTOR-LAMBDA-NAME (LAMBDA-NAME) (COND ((AND LAMBDA-NAME (SYMBOLP LAMBDA-NAME) (SYMBOL-PACKAGE (TRULY-THE SYMBOL LAMBDA-NAME))) (EMIT (QUOTE LDC) (POOL-STRING (SYMBOL-NAME (TRULY-THE SYMBOL LAMBDA-NAME)))) (EMIT (QUOTE LDC) (POOL-STRING (PACKAGE-NAME (SYMBOL-PACKAGE (TRULY-THE SYMBOL LAMBDA-NAME))))) (EMIT-INVOKESTATIC +LISP+ "internInPackage" (LIST +JAVA-STRING+ +JAVA-STRING+) +LISP-SYMBOL+)) (T (EMIT-PUSH-NIL))))
     [java] ; (DEFUN EMIT-CONSTRUCTOR-LAMBDA-LIST (LAMBDA-LIST) (IF LAMBDA-LIST (SERIALIZE-OBJECT LAMBDA-LIST) (EMIT-PUSH-NIL)))
     [java] ; (DEFUN EMIT-READ-FROM-STRING (OBJECT) (EMIT-CONSTRUCTOR-LAMBDA-LIST OBJECT))
     [java] ; (DEFUN MAKE-CONSTRUCTOR (CLASS LAMBDA-NAME ARGS) (LET* ((*COMPILER-DEBUG* NIL) (METHOD (MAKE-JVM-METHOD :CONSTRUCTOR :VOID NIL :FLAGS (QUOTE (:PUBLIC)))) (SUPER (CLASS-FILE-SUPERCLASS CLASS)) OPT-PARAMS-REGISTER KEY-PARAMS-REGISTER REQ-COUNT REST-P KEYS-P MORE-KEYS-P ALP-REGISTER) (WITH-CODE-TO-METHOD (CLASS METHOD) (ALLOCATE-REGISTER NIL) (UNLESS (EQ SUPER +LISP-COMPILED-PRIMITIVE+) (MULTIPLE-VALUE-BIND (REQ OPT KEY KEY-P REST ALLOW-OTHER-KEYS-P) (PARSE-LAMBDA-LIST ARGS) (SETF REST-P REST MORE-KEYS-P ALLOW-OTHER-KEYS-P KEYS-P KEY-P REQ-COUNT (LENGTH REQ)) (MACROLET ((PARAMETERS-TO-ARRAY ((PARAM PARAMS REGISTER CLASS) &BODY BODY) (LET ((COUNT-SYM (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE EMIT-PUSH-CONSTANT-INT) (SYSTEM::BACKQ-LIST (QUOTE LENGTH) PARAMS)) (SYSTEM::BACKQ-LIST (QUOTE EMIT-ANEWARRAY) CLASS) (SYSTEM::BACKQ-LIST (QUOTE ASTORE) (SYSTEM::BACKQ-LIST* (QUOTE SETF) REGISTER (QUOTE (*REGISTERS-ALLOCATED*)))) (QUOTE (ALLOCATE-REGISTER NIL)) (SYSTEM::BACKQ-LIST* (QUOTE DO*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST COUNT-SYM 0 (SYSTEM::BACKQ-LIST (QUOTE 1+) COUNT-SYM)) (SYSTEM::BACKQ-LIST PARAMS PARAMS (SYSTEM::BACKQ-LIST (QUOTE CDR) PARAMS)) (SYSTEM::BACKQ-LIST PARAM (SYSTEM::BACKQ-LIST (QUOTE CAR) PARAMS) (SYSTEM::BACKQ-LIST (QUOTE CAR) PARAMS))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE ENDP) PARAMS)) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) PARAM)) (SYSTEM::BACKQ-LIST (QUOTE ALOAD) REGISTER) (SYSTEM::BACKQ-LIST (QUOTE EMIT-PUSH-CONSTANT-INT) COUNT-SYM) (SYSTEM::BACKQ-LIST (QUOTE EMIT-NEW) CLASS) (QUOTE (EMIT (QUOTE DUP))) (SYSTEM::BACKQ-APPEND BODY (QUOTE ((EMIT (QUOTE AASTORE)))))))))) (PARAMETERS-TO-ARRAY (PARAM OPT OPT-PARAMS-REGISTER +ALP-OPTIONAL-PARAMETER+) (IF (NULL (THIRD PARAM)) (EMIT (QUOTE ICONST_0)) (EMIT (QUOTE ICONST_1))) (EMIT-READ-FROM-STRING (SECOND PARAM)) (EMIT-INVOKESPECIAL-INIT +ALP-OPTIONAL-PARAMETER+ (LIST :BOOLEAN +LISP-OBJECT+))) (PARAMETERS-TO-ARRAY (PARAM KEY KEY-PARAMS-REGISTER +ALP-KEYWORD-PARAMETER+) (IF (NULL (THIRD PARAM)) (EMIT (QUOTE ICONST_0)) (EMIT (QUOTE ICONST_1))) (EMIT-READ-FROM-STRING (SECOND PARAM)) (LET ((KEYWORD (FOURTH PARAM))) (IF (KEYWORDP KEYWORD) (PROGN (EMIT (QUOTE LDC) (POOL-STRING (SYMBOL-NAME KEYWORD))) (EMIT-INVOKESTATIC +LISP+ "internKeyword" (LIST +JAVA-STRING+) +LISP-SYMBOL+)) (PROGN (EMIT (QUOTE LDC) (POOL-STRING (SYMBOL-NAME KEYWORD))) (EMIT (QUOTE LDC) (POOL-STRING (PACKAGE-NAME (SYMBOL-PACKAGE KEYWORD)))) (EMIT-INVOKESTATIC +LISP+ "internInPackage" (LIST +JAVA-STRING+ +JAVA-STRING+) +LISP-SYMBOL+)))) (EMIT-INVOKESPECIAL-INIT +ALP-KEYWORD-PARAMETER+ (LIST :BOOLEAN +LISP-OBJECT+ +LISP-SYMBOL+)))))) (ALOAD 0) (COND ((EQ SUPER +LISP-COMPILED-PRIMITIVE+) (EMIT-CONSTRUCTOR-LAMBDA-NAME LAMBDA-NAME) (EMIT-CONSTRUCTOR-LAMBDA-LIST ARGS) (EMIT-INVOKESPECIAL-INIT SUPER (LISP-OBJECT-ARG-TYPES 2))) ((EQUAL SUPER +LISP-COMPILED-CLOSURE+) (EMIT-NEW +ARGUMENT-LIST-PROCESSOR+) (EMIT (QUOTE DUP)) (EMIT (QUOTE DUP)) (ASTORE (SETF ALP-REGISTER (ALLOCATE-REGISTER NIL))) (EMIT (QUOTE ACONST_NULL)) (EMIT-PUSH-INT REQ-COUNT) (ALOAD OPT-PARAMS-REGISTER) (ALOAD KEY-PARAMS-REGISTER) (IF KEYS-P (EMIT (QUOTE ICONST_1)) (EMIT (QUOTE ICONST_0))) (IF MORE-KEYS-P (EMIT (QUOTE ICONST_1)) (EMIT (QUOTE ICONST_0))) (IF REST-P (EMIT-PUSH-T) (EMIT (QUOTE ACONST_NULL))) (EMIT-INVOKESPECIAL-INIT +ARGUMENT-LIST-PROCESSOR+ (LIST +LISP-OPERATOR+ :INT (CLASS-ARRAY +ALP-OPTIONAL-PARAMETER+) (CLASS-ARRAY +ALP-KEYWORD-PARAMETER+) :BOOLEAN :BOOLEAN +LISP-SYMBOL+)) (EMIT-INVOKESPECIAL-INIT SUPER (LIST +ARGUMENT-LIST-PROCESSOR+)) (ALOAD ALP-REGISTER) (ALOAD 0) (EMIT-INVOKEVIRTUAL +ARGUMENT-LIST-PROCESSOR+ "setFunction" (LIST +LISP-OPERATOR+) NIL)) (T (SYSTEM::%FORMAT T "unhandled superclass ~A for ~A~%" SUPER (ABCL-CLASS-FILE-CLASS-NAME CLASS)) (AVER NIL)))) METHOD))
     [java] ; (DEFUN MAKE-STATIC-INITIALIZER (CLASS) (LET ((*COMPILER-DEBUG* NIL) (METHOD (MAKE-JVM-METHOD :STATIC-INITIALIZER :VOID NIL :FLAGS (QUOTE (:PUBLIC :STATIC))))) (WITH-CODE-TO-METHOD (CLASS METHOD) METHOD)))
     [java] ; (DEFVAR *SOURCE-LINE-NUMBER* NIL)
     [java] ; (DEFUN FINISH-CLASS (CLASS STREAM) "Finalizes the `class' and writes the result to `stream'.
     [java]
     [java] The compiler calls this function to indicate it doesn't want to
     [java] extend the class any further." (WITH-CODE-TO-METHOD (CLASS (ABCL-CLASS-FILE-CONSTRUCTOR CLASS)) (EMIT (QUOTE RETURN))) (WITH-CODE-TO-METHOD (CLASS (ABCL-CLASS-FILE-STATIC-INITIALIZER CLASS)) (IF (= 0 (LENGTH *CODE*)) (CLASS-REMOVE-METHOD CLASS (ABCL-CLASS-FILE-STATIC-INITIALIZER CLASS)) (EMIT (QUOTE RETURN)))) (WHEN *COMPILER-DEBUG* (PRINT "; Writing class file ") (PRINT (ABCL-CLASS-FILE-CLASS-NAME CLASS)) (TERPRI)) (FINALIZE-CLASS-FILE CLASS) (WRITE-CLASS-FILE CLASS STREAM))
     [java] ; (DEFKNOWN DECLARE-FIELD (T T T) T)
     [java] ; (DEFUN DECLARE-FIELD (NAME DESCRIPTOR) (LET ((FIELD (MAKE-FIELD NAME DESCRIPTOR :FLAGS (QUOTE (:FINAL :STATIC))))) (CLASS-ADD-FIELD *CLASS-FILE* FIELD)))
     [java] ; (DEFKNOWN SANITIZE (SYMBOL) STRING)
     [java] ; (DEFUN SANITIZE (SYMBOL) (DECLARE (TYPE SYMBOL SYMBOL)) (DECLARE (OPTIMIZE SPEED)) (LET* ((INPUT (SYMBOL-NAME SYMBOL)) (OUTPUT (MAKE-ARRAY (LENGTH INPUT) :FILL-POINTER 0 :ELEMENT-TYPE (QUOTE CHARACTER)))) (DOTIMES (I (LENGTH INPUT)) (DECLARE (TYPE FIXNUM I)) (LET ((C (CHAR-UPCASE (CHAR INPUT I)))) (COND ((<= 65 (CHAR-CODE C) 90) (VECTOR-PUSH C OUTPUT)) ((<= 48 (CHAR-CODE C) 57) (VECTOR-PUSH C OUTPUT)) ((EQL C #\-) (VECTOR-PUSH #\_ OUTPUT))))) (WHEN (PLUSP (LENGTH OUTPUT)) OUTPUT)))
     [java] ; (DEFVAR *DECLARE-INLINE* NIL)
     [java] ; (DEFMACRO DECLARE-WITH-HASHTABLE (DECLARED-ITEM HASHTABLE HASHTABLE-VAR ITEM-VAR &BODY BODY) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST HASHTABLE-VAR HASHTABLE) (SYSTEM::BACKQ-LIST ITEM-VAR (SYSTEM::BACKQ-LIST (QUOTE GETHASH1) DECLARED-ITEM HASHTABLE-VAR))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) (QUOTE HASH-TABLE) HASHTABLE-VAR)) (SYSTEM::BACKQ-LIST* (QUOTE UNLESS) ITEM-VAR BODY) ITEM-VAR))
     [java] ; (DEFUN SERIALIZE-INTEGER (N) "Generates code to restore a serialized integer." (COND ((<= 0 N 255) (EMIT-GETSTATIC +LISP-FIXNUM+ "constants" +LISP-FIXNUM-ARRAY+) (EMIT-PUSH-CONSTANT-INT N) (EMIT (QUOTE AALOAD))) ((<= MOST-NEGATIVE-FIXNUM N MOST-POSITIVE-FIXNUM) (EMIT-PUSH-CONSTANT-INT N) (EMIT-INVOKESTATIC +LISP-FIXNUM+ "makeFixnum" (QUOTE (:INT)) +LISP-FIXNUM+)) ((<= MOST-NEGATIVE-JAVA-LONG N MOST-POSITIVE-JAVA-LONG) (EMIT-PUSH-CONSTANT-LONG N) (EMIT-INVOKESTATIC +LISP-BIGNUM+ "makeBignum" (QUOTE (:LONG)) +LISP-INTEGER+)) (T (LET* ((*PRINT-BASE* 10) (S (WITH-OUTPUT-TO-STRING (STREAM) (DUMP-FORM N STREAM)))) (EMIT (QUOTE LDC) (POOL-STRING S)) (EMIT-PUSH-CONSTANT-INT 10) (EMIT-INVOKESTATIC +LISP-BIGNUM+ "makeBignum" (LIST +JAVA-STRING+ :INT) +LISP-INTEGER+)))))
     [java] ; (DEFUN SERIALIZE-CHARACTER (C) "Generates code to restore a serialized character." (EMIT-PUSH-CONSTANT-INT (CHAR-CODE C)) (EMIT-INVOKESTATIC +LISP-CHARACTER+ "makeCharacter" (QUOTE (:CHAR)) +LISP-CHARACTER+))
     [java] ; (DEFUN SERIALIZE-FLOAT (S) "Generates code to restore a serialized single-float." (EMIT-NEW +LISP-SINGLE-FLOAT+) (EMIT (QUOTE DUP)) (EMIT (QUOTE LDC) (POOL-FLOAT S)) (EMIT-INVOKESPECIAL-INIT +LISP-SINGLE-FLOAT+ (QUOTE (:FLOAT))))
     [java] ; (DEFUN SERIALIZE-DOUBLE (D) "Generates code to restore a serialized double-float." (EMIT-NEW +LISP-DOUBLE-FLOAT+) (EMIT (QUOTE DUP)) (EMIT (QUOTE LDC2_W) (POOL-DOUBLE D)) (EMIT-INVOKESPECIAL-INIT +LISP-DOUBLE-FLOAT+ (QUOTE (:DOUBLE))))
     [java] ; (DEFUN SERIALIZE-STRING (STRING) "Generate code to restore a serialized string." (COND ((< (LENGTH STRING) 65535) (EMIT-NEW +LISP-SIMPLE-STRING+) (EMIT (QUOTE DUP)) (EMIT (QUOTE LDC) (POOL-STRING STRING)) (EMIT-INVOKESPECIAL-INIT +LISP-SIMPLE-STRING+ (LIST +JAVA-STRING+))) (T (SERIALIZE-OBJECT STRING))))
     [java] ; (DEFUN SERIALIZE-PACKAGE (PKG) "Generate code to restore a serialized package." (EMIT (QUOTE LDC) (POOL-STRING (CONCATENATE (QUOTE STRING) "#.(CL:FIND-PACKAGE \"" (PACKAGE-NAME PKG) "\")"))) (EMIT-INVOKESTATIC +LISP+ "readObjectFromString" (LIST +JAVA-STRING+) +LISP-OBJECT+))
     [java] ; (DEFUN COMPILAND-EXTERNAL-CONSTANT-RESOURCE-NAME (COMPILAND) (LET ((RESOURCE-NUMBER (COMPILAND-NEXT-RESOURCE COMPILAND)) (PATHNAME (ABCL-CLASS-FILE-PATHNAME (COMPILAND-CLASS-FILE COMPILAND)))) (INCF (COMPILAND-NEXT-RESOURCE COMPILAND)) (MAKE-PATHNAME :NAME (FORMAT NIL "~A_~D" (PATHNAME-NAME PATHNAME) RESOURCE-NUMBER) :TYPE "clc" :DEFAULTS PATHNAME)))
     [java] ; (DEFUN SERIALIZE-OBJECT (OBJECT) "Generate code to restore a serialized object which is not of any
     [java] of the other types." (LET ((S (WITH-OUTPUT-TO-STRING (STREAM) (DUMP-FORM OBJECT STREAM)))) (COND ((< (LENGTH S) 65535) (EMIT (QUOTE LDC) (POOL-STRING S)) (EMIT-INVOKESTATIC +LISP+ "readObjectFromString" (LIST +JAVA-STRING+) +LISP-OBJECT+)) (T (EMIT (QUOTE LDC_W) (POOL-CLASS *THIS-CLASS*)) (LET ((PATHNAME (COMPILAND-EXTERNAL-CONSTANT-RESOURCE-NAME *CURRENT-COMPILAND*))) (WITH-OPEN-FILE (F PATHNAME :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE :IF-DOES-NOT-EXIST :CREATE) (WRITE-STRING S F)) (EMIT (QUOTE LDC) (POOL-STRING (NAMESTRING (MAKE-PATHNAME :NAME (PATHNAME-NAME PATHNAME) :TYPE (PATHNAME-TYPE PATHNAME) :VERSION NIL))))) (EMIT-INVOKEVIRTUAL +JAVA-CLASS+ "getResourceAsStream" (LIST +JAVA-STRING+) +JAVA-IO-INPUT-STREAM+) (EMIT-INVOKESTATIC +LISP+ "readObjectFromStream" (LIST +JAVA-IO-INPUT-STREAM+) +LISP-OBJECT+)))))
     [java] ; (DEFUN SERIALIZE-SYMBOL (SYMBOL) "Generate code to restore a serialized symbol." (MULTIPLE-VALUE-BIND (NAME CLASS) (LOOKUP-KNOWN-SYMBOL SYMBOL) (COND (NAME (EMIT-GETSTATIC CLASS NAME +LISP-SYMBOL+)) ((NULL (SYMBOL-PACKAGE SYMBOL)) (EMIT-PUSH-CONSTANT-INT (DUMP-UNINTERNED-SYMBOL-INDEX SYMBOL)) (EMIT-INVOKESTATIC +LISP-LOAD+ "getUninternedSymbol" (QUOTE (:INT)) +LISP-OBJECT+) (EMIT-CHECKCAST +LISP-SYMBOL+)) ((KEYWORDP SYMBOL) (EMIT (QUOTE LDC) (POOL-STRING (SYMBOL-NAME SYMBOL))) (EMIT-INVOKESTATIC +LISP+ "internKeyword" (LIST +JAVA-STRING+) +LISP-SYMBOL+)) (T (EMIT (QUOTE LDC) (POOL-STRING (SYMBOL-NAME SYMBOL))) (EMIT (QUOTE LDC) (POOL-STRING (PACKAGE-NAME (SYMBOL-PACKAGE SYMBOL)))) (EMIT-INVOKESTATIC +LISP+ "internInPackage" (LIST +JAVA-STRING+ +JAVA-STRING+) +LISP-SYMBOL+)))))
     [java] ; (DEFVAR SERIALIZATION-TABLE (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE INTEGER) "INT" (FUNCTION EQL) (FUNCTION SERIALIZE-INTEGER) +LISP-INTEGER+) (SYSTEM::BACKQ-LIST (QUOTE CHARACTER) "CHR" (FUNCTION EQL) (FUNCTION SERIALIZE-CHARACTER) +LISP-CHARACTER+) (SYSTEM::BACKQ-LIST (QUOTE SINGLE-FLOAT) "FLT" (FUNCTION EQL) (FUNCTION SERIALIZE-FLOAT) +LISP-SINGLE-FLOAT+) (SYSTEM::BACKQ-LIST (QUOTE DOUBLE-FLOAT) "DBL" (FUNCTION EQL) (FUNCTION SERIALIZE-DOUBLE) +LISP-DOUBLE-FLOAT+) (SYSTEM::BACKQ-LIST (QUOTE STRING) "STR" (FUNCTION EQUAL) (FUNCTION SERIALIZE-STRING) +LISP-ABSTRACT-STRING+) (SYSTEM::BACKQ-LIST (QUOTE PACKAGE) "PKG" (FUNCTION EQ) (FUNCTION SERIALIZE-PACKAGE) +LISP-OBJECT+) (SYSTEM::BACKQ-LIST (QUOTE SYMBOL) "SYM" (FUNCTION EQ) (FUNCTION SERIALIZE-SYMBOL) +LISP-SYMBOL+) (SYSTEM::BACKQ-LIST (QUOTE T) "OBJ" (FUNCTION EQ) (FUNCTION SERIALIZE-OBJECT) +LISP-OBJECT+)) "A list of 5-element lists. The elements of the sublists mean:
     [java]
     [java] 1. The type of the value to be serialized
     [java] 2. The string to be used as a field prefix
     [java] 3. The function to be used to determine equality (coalescing or not)
     [java] 4. The function to dispatch serialization to
     [java] 5. The type of the field to save the serialized result to")
     [java] ; (DEFKNOWN EMIT-LOAD-EXTERNALIZED-OBJECT (T &OPTIONAL T) STRING)
     [java] ; (DEFUN EMIT-LOAD-EXTERNALIZED-OBJECT (OBJECT &OPTIONAL CAST) "Externalizes `object' for use in a FASL.
     [java]
     [java] Returns the name of the field (in `*this-class*') from which
     [java] the value of the object can be loaded. Objects may be coalesced based
     [java] on the equality indicator in the `serialization-table'.
     [java]
     [java] Code to restore the serialized object is inserted into the current method or
     [java] the constructor if `*declare-inline*' is non-nil.
     [java] " (DESTRUCTURING-BIND (TYPE PREFIX SIMILARITY-FN DISPATCH-FN FIELD-TYPE) (ASSOC-IF (FUNCTION (LAMBDA (X) (TYPEP OBJECT X))) SERIALIZATION-TABLE) (DECLARE (IGNORE TYPE)) (WHEN (NOT *FILE-COMPILATION*) (SETF SIMILARITY-FN (FUNCTION EQ))) (LET ((EXISTING (ASSOC OBJECT *EXTERNALIZED-OBJECTS* :TEST SIMILARITY-FN))) (WHEN EXISTING (EMIT-GETSTATIC *THIS-CLASS* (CDR EXISTING) FIELD-TYPE) (WHEN CAST (EMIT-CHECKCAST CAST)) (RETURN-FROM EMIT-LOAD-EXTERNALIZED-OBJECT FIELD-TYPE))) (LET ((FIELD-NAME (SYMBOL-NAME (GENSYM PREFIX)))) (DECLARE-FIELD FIELD-NAME FIELD-TYPE) (PUSH (CONS OBJECT FIELD-NAME) *EXTERNALIZED-OBJECTS*) (COND ((NOT *FILE-COMPILATION*) (WITH-CODE-TO-METHOD (*CLASS-FILE* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*)) (REMEMBER FIELD-NAME OBJECT) (EMIT (QUOTE LDC) (POOL-STRING FIELD-NAME)) (EMIT-INVOKESTATIC +LISP+ "recall" (LIST +JAVA-STRING+) +LISP-OBJECT+) (WHEN (NOT (EQ FIELD-TYPE +LISP-OBJECT+)) (EMIT-CHECKCAST FIELD-TYPE)) (EMIT-PUTSTATIC *THIS-CLASS* FIELD-NAME FIELD-TYPE))) (*DECLARE-INLINE* (FUNCALL DISPATCH-FN OBJECT) (EMIT-PUTSTATIC *THIS-CLASS* FIELD-NAME FIELD-TYPE)) (T (WITH-CODE-TO-METHOD (*CLASS-FILE* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*)) (FUNCALL DISPATCH-FN OBJECT) (EMIT-PUTSTATIC *THIS-CLASS* FIELD-NAME FIELD-TYPE)))) (EMIT-GETSTATIC *THIS-CLASS* FIELD-NAME FIELD-TYPE) (WHEN CAST (EMIT-CHECKCAST CAST)) FIELD-TYPE)))
     [java] ; (DEFKNOWN DECLARE-FUNCTION (SYMBOL &OPTIONAL SETF) STRING)
     [java] ; (DEFUN DECLARE-FUNCTION (SYMBOL &OPTIONAL SETF) (DECLARE (TYPE SYMBOL SYMBOL)) (DECLARE-WITH-HASHTABLE SYMBOL *DECLARED-FUNCTIONS* HT F (SETF F (SYMBOL-NAME (IF SETF (GENSYM "SETF") (GENSYM "FUN")))) (LET ((S (SANITIZE SYMBOL))) (WHEN S (SETF F (CONCATENATE (QUOTE STRING) F "_" S)))) (DECLARE-FIELD F +LISP-OBJECT+) (MULTIPLE-VALUE-BIND (NAME CLASS) (LOOKUP-KNOWN-SYMBOL SYMBOL) (UNLESS NAME (SETF NAME (IF *FILE-COMPILATION* (DECLARE-OBJECT-AS-STRING SYMBOL) (DECLARE-OBJECT SYMBOL)) CLASS *THIS-CLASS*)) (WITH-CODE-TO-METHOD (*CLASS-FILE* (IF *DECLARE-INLINE* *METHOD* (ABCL-CLASS-FILE-CONSTRUCTOR *CLASS-FILE*))) (IF (EQ CLASS *THIS-CLASS*) (PROGN (EMIT-GETSTATIC CLASS NAME +LISP-OBJECT+) (EMIT-CHECKCAST +LISP-SYMBOL+)) (EMIT-GETSTATIC CLASS NAME +LISP-SYMBOL+)) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ (IF SETF "getSymbolSetfFunctionOrDie" "getSymbolFunctionOrDie") NIL +LISP-OBJECT+) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "resolve" NIL +LISP-OBJECT+) (EMIT-PUTSTATIC *THIS-CLASS* F +LISP-OBJECT+) (SETF (GETHASH SYMBOL HT) F)) F)))
     [java] ; (DEFKNOWN DECLARE-SETF-FUNCTION (NAME) STRING)
     [java] ; (DEFUN DECLARE-SETF-FUNCTION (NAME) (DECLARE-FUNCTION (CADR NAME) T))
     [java] ; (DEFUN LOCAL-FUNCTION-CLASS-AND-FIELD (LOCAL-FUNCTION) (LET ((LOCAL-FUNCTION-PARENT-COMPILAND (COMPILAND-PARENT (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION)))) (VALUES (ABCL-CLASS-FILE-CLASS-NAME (COMPILAND-CLASS-FILE LOCAL-FUNCTION-PARENT-COMPILAND)) (LOCAL-FUNCTION-FIELD LOCAL-FUNCTION))))
     [java] ; (DEFKNOWN DECLARE-LOCAL-FUNCTION (LOCAL-FUNCTION) STRING)
     [java] ; (DEFUN DECLARE-LOCAL-FUNCTION (LOCAL-FUNCTION) (LET ((CLASS-NAME (ABCL-CLASS-FILE-CLASS-NAME (COMPILAND-CLASS-FILE (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION)))) (FIELD-NAME (LOCAL-FUNCTION-FIELD LOCAL-FUNCTION))) (WITH-CODE-TO-METHOD (*CLASS-FILE* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*)) (DECLARE-FIELD FIELD-NAME +LISP-OBJECT+) (EMIT-NEW CLASS-NAME) (EMIT (QUOTE DUP)) (EMIT-INVOKESPECIAL-INIT CLASS-NAME (QUOTE NIL)) (EMIT-PUTSTATIC *THIS-CLASS* FIELD-NAME +LISP-OBJECT+))))
     [java] ; (DEFKNOWN DECLARE-OBJECT-AS-STRING (T) STRING)
     [java] ; (DEFUN DECLARE-OBJECT-AS-STRING (OBJ) (LET ((G (SYMBOL-NAME (GENSYM "OBJSTR"))) (S (WITH-OUTPUT-TO-STRING (STREAM) (DUMP-FORM OBJ STREAM)))) (WITH-CODE-TO-METHOD (*CLASS-FILE* (IF *DECLARE-INLINE* *METHOD* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*))) (DECLARE-FIELD G +LISP-OBJECT+) (EMIT (QUOTE LDC) (POOL-STRING S)) (EMIT-INVOKESTATIC +LISP+ "readObjectFromString" (LIST +JAVA-STRING+) +LISP-OBJECT+) (EMIT-PUTSTATIC *THIS-CLASS* G +LISP-OBJECT+)) G))
     [java] ; (DEFUN DECLARE-LOAD-TIME-VALUE (OBJ) (LET ((G (SYMBOL-NAME (GENSYM "LTV"))) (S (WITH-OUTPUT-TO-STRING (STREAM) (DUMP-FORM OBJ STREAM)))) (WITH-CODE-TO-METHOD (*CLASS-FILE* (IF *DECLARE-INLINE* *METHOD* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*))) (DECLARE-FIELD G +LISP-OBJECT+) (EMIT (QUOTE LDC) (POOL-STRING S)) (EMIT-INVOKESTATIC +LISP+ "readObjectFromString" (LIST +JAVA-STRING+) +LISP-OBJECT+) (EMIT-INVOKESTATIC +LISP+ "loadTimeValue" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-PUTSTATIC *THIS-CLASS* G +LISP-OBJECT+)) G))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) STRING) DECLARE-OBJECT))
     [java] ; (DEFUN DECLARE-OBJECT (OBJ) "Stores the object OBJ in the object-lookup-table,
     [java] loading the object value into a field upon class-creation time.
     [java]
     [java] The field type of the object is specified by OBJ-REF." (LET ((G (SYMBOL-NAME (GENSYM "OBJ")))) (REMEMBER G OBJ) (WITH-CODE-TO-METHOD (*CLASS-FILE* (ABCL-CLASS-FILE-STATIC-INITIALIZER *CLASS-FILE*)) (DECLARE-FIELD G +LISP-OBJECT+) (EMIT (QUOTE LDC) (POOL-STRING G)) (EMIT-INVOKESTATIC +LISP+ "recall" (LIST +JAVA-STRING+) +LISP-OBJECT+) (EMIT-PUTSTATIC *THIS-CLASS* G +LISP-OBJECT+)) G))
     [java] ; (DEFKNOWN COMPILE-CONSTANT (T T T) T)
     [java] ; (DEFUN COMPILE-CONSTANT (FORM TARGET REPRESENTATION) (UNLESS TARGET (RETURN-FROM COMPILE-CONSTANT)) (ECASE REPRESENTATION (:INT (COND ((FIXNUMP FORM) (EMIT-PUSH-CONSTANT-INT FORM)) ((INTEGERP FORM) (EMIT-LOAD-EXTERNALIZED-OBJECT FORM) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "intValue" NIL :INT)) (T (SYSTEM::%FORMAT T "compile-constant int representation~%") (ASSERT NIL))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) (:LONG (COND ((<= MOST-NEGATIVE-JAVA-LONG FORM MOST-POSITIVE-JAVA-LONG) (EMIT-PUSH-CONSTANT-LONG FORM)) ((INTEGERP FORM) (EMIT-LOAD-EXTERNALIZED-OBJECT FORM) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "longValue" NIL :LONG)) (T (SYSTEM::%FORMAT T "compile-constant long representation~%") (ASSERT NIL))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) (:CHAR (COND ((CHARACTERP FORM) (EMIT-PUSH-CONSTANT-INT (CHAR-CODE FORM)) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) (T (SYSTEM::%FORMAT T "compile-constant :char representation~%") (ASSERT NIL)))) (:BOOLEAN (EMIT (IF FORM (QUOTE ICONST_1) (QUOTE ICONST_0))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) (:FLOAT (COND ((INTEGERP FORM) (EMIT-PUSH-CONSTANT-FLOAT (COERCE FORM (QUOTE SINGLE-FLOAT)))) ((TYPEP FORM (QUOTE SINGLE-FLOAT)) (EMIT-PUSH-CONSTANT-FLOAT FORM)) ((TYPEP FORM (QUOTE DOUBLE-FLOAT)) (EMIT-PUSH-CONSTANT-DOUBLE FORM) (EMIT (QUOTE D2F))) (T (SYSTEM::%FORMAT T "compile-constant :float representation~%") (ASSERT NIL))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) (:DOUBLE (COND ((OR (INTEGERP FORM) (TYPEP FORM (QUOTE SINGLE-FLOAT))) (EMIT-PUSH-CONSTANT-DOUBLE (COERCE FORM (QUOTE DOUBLE-FLOAT)))) ((TYPEP FORM (QUOTE DOUBLE-FLOAT)) (EMIT-PUSH-CONSTANT-DOUBLE FORM)) (T (SYSTEM::%FORMAT T "compile-constant :double representation~%") (ASSERT NIL))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM COMPILE-CONSTANT)) ((NIL))) (COND ((OR (NUMBERP FORM) (TYPEP FORM (QUOTE SINGLE-FLOAT)) (TYPEP FORM (QUOTE DOUBLE-FLOAT)) (CHARACTERP FORM) (STRINGP FORM) (PACKAGEP FORM) (PATHNAMEP FORM) (ARRAYP FORM) (STRUCTURE-OBJECT-P FORM) (STANDARD-OBJECT-P FORM) (JAVA:JAVA-OBJECT-P FORM)) (EMIT-LOAD-EXTERNALIZED-OBJECT FORM)) (T (IF *FILE-COMPILATION* (ERROR "COMPILE-CONSTANT unhandled case ~S" FORM) (EMIT-LOAD-EXTERNALIZED-OBJECT FORM)))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))
     [java] ; (DEFPARAMETER *UNARY-OPERATORS* NIL)
     [java] ; (DEFUN INITIALIZE-UNARY-OPERATORS NIL (LET ((HT (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (DOLIST (PAIR (QUOTE ((ABS "ABS") (CADDR "caddr") (CADR "cadr") (CDDR "cddr") (CDR "cdr") (CLASS-OF "classOf") (COMPLEXP "COMPLEXP") (DENOMINATOR "DENOMINATOR") (FIRST "car") (SYSTEM::%LENGTH "LENGTH") (NREVERSE "nreverse") (NUMERATOR "NUMERATOR") (REST "cdr") (REVERSE "reverse") (SECOND "cadr") (SIMPLE-STRING-P "SIMPLE_STRING_P") (STRING "STRING") (THIRD "caddr")))) (SETF (GETHASH (%CAR PAIR) HT) (%CADR PAIR))) (SETF *UNARY-OPERATORS* HT)))
     [java] ; (DEFKNOWN INSTALL-P2-HANDLER * T)
     [java] ; (DEFUN INSTALL-P2-HANDLER (SYMBOL &OPTIONAL HANDLER) (DECLARE (TYPE SYMBOL SYMBOL)) (LET ((HANDLER (OR HANDLER (FIND-SYMBOL (CONCATENATE (QUOTE STRING) "COMPILE-" (SYMBOL-NAME SYMBOL)) (QUOTE JVM))))) (UNLESS (AND HANDLER (FBOUNDP HANDLER)) (ERROR "Handler not found: ~S" HANDLER)) (SETF (GET SYMBOL (QUOTE P2-HANDLER)) HANDLER)))
     [java] ; (DEFPARAMETER *PREDICATES* (MAKE-HASH-TABLE :TEST (QUOTE EQ)))
     [java] ; (DEFUN DEFINE-PREDICATE (NAME BOXED-METHOD-NAME UNBOXED-METHOD-NAME) (SETF (GETHASH NAME *PREDICATES*) (CONS BOXED-METHOD-NAME UNBOXED-METHOD-NAME)) (INSTALL-P2-HANDLER NAME (QUOTE P2-PREDICATE)))
     [java] ; (DEFMACRO DEFINE-INLINED-FUNCTION (NAME PARAMS PREAMBLE-AND-TEST &BODY BODY) (LET* ((TEST (SECOND PREAMBLE-AND-TEST)) (PREAMBLE (AND TEST (FIRST PREAMBLE-AND-TEST))) (TEST (OR TEST (FIRST PREAMBLE-AND-TEST)))) (SYSTEM::BACKQ-LIST* (QUOTE DEFUN) NAME PARAMS PREAMBLE (SYSTEM::BACKQ-LIST (QUOTE UNLESS) TEST (SYSTEM::BACKQ-CONS (QUOTE COMPILE-FUNCTION-CALL) PARAMS) (SYSTEM::BACKQ-LIST (QUOTE RETURN-FROM) NAME)) BODY)))
     [java] ; (DEFKNOWN P2-PREDICATE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-PREDICATE (FORM TARGET REPRESENTATION) ((= (LENGTH FORM) 2)) (LET* ((OP (CAR FORM)) (INFO (GETHASH OP *PREDICATES*)) (BOXED-METHOD-NAME (CAR INFO)) (UNBOXED-METHOD-NAME (CDR INFO))) (COND ((AND BOXED-METHOD-NAME UNBOXED-METHOD-NAME) (LET ((ARG (CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (ECASE REPRESENTATION (:BOOLEAN (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ UNBOXED-METHOD-NAME NIL :BOOLEAN)) ((NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ BOXED-METHOD-NAME NIL +LISP-OBJECT+))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFINE-PREDICATE (QUOTE CONSTANTP) "CONSTANTP" "constantp")
     [java] ; (DEFINE-PREDICATE (QUOTE ENDP) "ENDP" "endp")
     [java] ; (DEFINE-PREDICATE (QUOTE EVENP) "EVENP" "evenp")
     [java] ; (DEFINE-PREDICATE (QUOTE FLOATP) "FLOATP" "floatp")
     [java] ; (DEFINE-PREDICATE (QUOTE INTEGERP) "INTEGERP" "integerp")
     [java] ; (DEFINE-PREDICATE (QUOTE LISTP) "LISTP" "listp")
     [java] ; (DEFINE-PREDICATE (QUOTE MINUSP) "MINUSP" "minusp")
     [java] ; (DEFINE-PREDICATE (QUOTE NUMBERP) "NUMBERP" "numberp")
     [java] ; (DEFINE-PREDICATE (QUOTE ODDP) "ODDP" "oddp")
     [java] ; (DEFINE-PREDICATE (QUOTE PLUSP) "PLUSP" "plusp")
     [java] ; (DEFINE-PREDICATE (QUOTE RATIONALP) "RATIONALP" "rationalp")
     [java] ; (DEFINE-PREDICATE (QUOTE REALP) "REALP" "realp")
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T T) T) COMPILE-FUNCTION-CALL-1))
     [java] ; (DEFUN COMPILE-FUNCTION-CALL-1 (OP ARGS TARGET REPRESENTATION) (LET ((ARG (FIRST ARGS))) (WHEN (EQ OP (QUOTE 1+)) (P2-PLUS (LIST (QUOTE +) ARG 1) TARGET REPRESENTATION) (RETURN-FROM COMPILE-FUNCTION-CALL-1 T)) (WHEN (EQ OP (QUOTE 1-)) (P2-MINUS (LIST (QUOTE -) ARG 1) TARGET REPRESENTATION) (RETURN-FROM COMPILE-FUNCTION-CALL-1 T)) (LET ((S (GETHASH1 OP (THE HASH-TABLE *UNARY-OPERATORS*)))) (COND (S (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD S TARGET REPRESENTATION) T) (T NIL)))))
     [java] ; (DEFPARAMETER *BINARY-OPERATORS* NIL)
     [java] ; (DEFUN INITIALIZE-BINARY-OPERATORS NIL (LET ((HT (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (DOLIST (PAIR (QUOTE ((EQL "EQL") (EQUAL "EQUAL") (+ "add") (- "subtract") (/ "divideBy") (* "multiplyBy") (< "IS_LT") (<= "IS_LE") (> "IS_GT") (>= "IS_GE") (= "IS_E") (/= "IS_NE") (ASH "ash") (AREF "AREF") (SIMPLE-TYPEP "typep") (RPLACA "RPLACA") (RPLACD "RPLACD")))) (SETF (GETHASH (%CAR PAIR) HT) (%CADR PAIR))) (SETF *BINARY-OPERATORS* HT)))
     [java] ; (DEFUN COMPILE-BINARY-OPERATION (OP ARGS TARGET REPRESENTATION) (LET ((ARG1 (CAR ARGS)) (ARG2 (CADR ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ OP (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+)) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T T) T) COMPILE-FUNCTION-CALL-2))
     [java] ; (DEFUN COMPILE-FUNCTION-CALL-2 (OP ARGS TARGET REPRESENTATION) (LET ((TRANSLATION (GETHASH1 OP (THE HASH-TABLE *BINARY-OPERATORS*)))) (WHEN TRANSLATION (COMPILE-BINARY-OPERATION TRANSLATION ARGS TARGET REPRESENTATION))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) FIXNUM-OR-UNBOXED-VARIABLE-P))
     [java] ; (DEFUN FIXNUM-OR-UNBOXED-VARIABLE-P (ARG) (OR (FIXNUMP ARG) (UNBOXED-FIXNUM-VARIABLE ARG)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) EMIT-PUSH-INT))
     [java] ; (DEFUN EMIT-PUSH-INT (ARG) (IF (FIXNUMP ARG) (EMIT-PUSH-CONSTANT-INT ARG) (LET ((VARIABLE (UNBOXED-FIXNUM-VARIABLE ARG))) (IF VARIABLE (EMIT (QUOTE ILOAD) (VARIABLE-REGISTER VARIABLE)) (PROGN (SYSTEM::%FORMAT T "emit-push-int~%") (AVER NIL))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) EMIT-PUSH-LONG))
     [java] ; (DEFUN EMIT-PUSH-LONG (ARG) (COND ((EQL ARG 0) (EMIT (QUOTE LCONST_0))) ((EQL ARG 1) (EMIT (QUOTE LCONST_1))) ((FIXNUMP ARG) (EMIT-PUSH-CONSTANT-INT ARG) (EMIT (QUOTE I2L))) (T (LET ((VARIABLE (UNBOXED-FIXNUM-VARIABLE ARG))) (AVER (NOT (NULL VARIABLE))) (AVER (NOT (NULL (VARIABLE-REGISTER VARIABLE)))) (EMIT (QUOTE ILOAD) (VARIABLE-REGISTER VARIABLE)) (EMIT (QUOTE I2L))))))
     [java] ; (DEFKNOWN P2-EQ/NEQ (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-EQ/NEQ (FORM TARGET REPRESENTATION) ((AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (CHECK-ARG-COUNT FORM 2)) (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (IF (EQ OP (QUOTE EQ)) (QUOTE IF_ACMPNE) (QUOTE IF_ACMPEQ)) LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (LABEL LABEL2))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) T)
     [java] ; (DEFUN EMIT-IFNE-FOR-EQL (REPRESENTATION INSTRUCTION-TYPE) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" INSTRUCTION-TYPE :BOOLEAN) (CONVERT-REPRESENTATION :BOOLEAN REPRESENTATION))
     [java] ; (DEFKNOWN P2-EQL (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-EQL (FORM TARGET REPRESENTATION) ((AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (CHECK-ARG-COUNT FORM 2)) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IF_ICMPEQ) LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (LABEL LABEL2))) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-IFNE-FOR-EQL REPRESENTATION (QUOTE (:INT)))) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-IFNE-FOR-EQL REPRESENTATION (QUOTE (:INT)))) ((EQ TYPE2 (QUOTE CHARACTER)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :CHAR) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-IFNE-FOR-EQL REPRESENTATION (QUOTE (:CHAR)))) ((EQ TYPE1 (QUOTE CHARACTER)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :CHAR) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-IFNE-FOR-EQL REPRESENTATION (QUOTE (:CHAR)))) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (ECASE REPRESENTATION (:BOOLEAN (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN)) ((NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "EQL" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+))))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFKNOWN P2-MEMQ (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-MEMQ (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (COND ((EQ REPRESENTATION :BOOLEAN) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESTATIC +LISP+ "memq" (LISP-OBJECT-ARG-TYPES 2) :BOOLEAN) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-MEMQL (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-MEMQL (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (COND ((EQ REPRESENTATION :BOOLEAN) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (COND ((EQ TYPE1 (QUOTE SYMBOL)) (EMIT-INVOKESTATIC +LISP+ "memq" (LISP-OBJECT-ARG-TYPES 2) :BOOLEAN)) (T (EMIT-INVOKESTATIC +LISP+ "memql" (LISP-OBJECT-ARG-TYPES 2) :BOOLEAN))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-GENSYM (FORM TARGET REPRESENTATION) (COND ((AND (NULL REPRESENTATION) (NULL (CDR FORM))) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKESTATIC +LISP+ "gensym" (LIST +LISP-THREAD+) +LISP-SYMBOL+) (EMIT-MOVE-FROM-STACK TARGET)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-GET (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS))) (CASE (LENGTH ARGS) ((2 3) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (WHEN ARG3 (COMPILE-OPERAND ARG3 NIL)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3))) (EMIT-INVOKESTATIC +LISP+ "get" (LISP-OBJECT-ARG-TYPES (IF ARG3 3 2)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILER-WARN "Wrong number of arguments for ~A (expected 2 or 3, but received ~D)." (QUOTE GET) (LENGTH ARGS)) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-GETF (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (ARG-COUNT (LENGTH ARGS))) (CASE ARG-COUNT ((2 3) (LET ((ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (COMPILE-OPERAND ARG3 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3))) (EMIT-INVOKESTATIC +LISP+ "getf" (LISP-OBJECT-ARG-TYPES 3) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-GETHASH (FORM TARGET REPRESENTATION) (COND ((AND (EQ (CAR FORM) (QUOTE GETHASH1)) (= (LENGTH FORM) 3) (EQ (DERIVE-TYPE (%CADDR FORM)) (QUOTE HASH-TABLE))) (LET ((KEY-FORM (%CADR FORM)) (HT-FORM (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND HT-FORM NIL +LISP-HASH-TABLE+) (COMPILE-OPERAND KEY-FORM NIL) (MAYBE-EMIT-CLEAR-VALUES HT-FORM KEY-FORM))) (EMIT-INVOKEVIRTUAL +LISP-HASH-TABLE+ "gethash1" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-PUTHASH (FORM TARGET REPRESENTATION) (COND ((AND (= (LENGTH FORM) 4) (EQ (DERIVE-TYPE (%CADDR FORM)) (QUOTE HASH-TABLE))) (LET ((KEY-FORM (%CADR FORM)) (HT-FORM (%CADDR FORM)) (VALUE-FORM (FOURTH FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND HT-FORM NIL +LISP-HASH-TABLE+) (COMPILE-OPERAND KEY-FORM NIL) (COMPILE-OPERAND VALUE-FORM NIL) (MAYBE-EMIT-CLEAR-VALUES HT-FORM KEY-FORM VALUE-FORM))) (COND (TARGET (EMIT-INVOKEVIRTUAL +LISP-HASH-TABLE+ "puthash" (LISP-OBJECT-ARG-TYPES 2) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (EMIT-INVOKEVIRTUAL +LISP-HASH-TABLE+ "put" (LISP-OBJECT-ARG-TYPES 2) NIL))))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFVAR *FUNCTIONS-DEFINED-IN-CURRENT-FILE* NIL)
     [java] ; (DEFUN INLINE-OK (NAME) (DECLARE (OPTIMIZE SPEED)) (COND ((NOTINLINE-P NAME) NIL) ((BUILT-IN-FUNCTION-P NAME) T) ((MEMQ NAME *FUNCTIONS-DEFINED-IN-CURRENT-FILE*) T) (T NIL)))
     [java] ; (DEFKNOWN PROCESS-ARGS (T T) T)
     [java] ; (DEFUN PROCESS-ARGS (ARGS STACK) "Compiles forms specified as function call arguments.
     [java]
     [java] The results are either accumulated on the stack or in an array
     [java] in order to call the relevant `execute' form. The function call
     [java] itself is *not* compiled by this function." (WHEN ARGS (LET ((NUMARGS (LENGTH ARGS))) (LET ((MUST-CLEAR-VALUES NIL) (UNSAFE-ARGS (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (MAPCAN (FUNCTION FIND-ENCLOSED-BLOCKS) ARGS)))) (DECLARE (TYPE BOOLEAN MUST-CLEAR-VALUES)) (COND ((AND UNSAFE-ARGS (<= NUMARGS CALL-REGISTERS-LIMIT)) (LET ((*REGISTER* *REGISTER*) OPERAND-REGISTERS) (DOLIST (STACK-ITEM STACK) (LET ((REGISTER (ALLOCATE-REGISTER NIL))) (PUSH REGISTER OPERAND-REGISTERS) (EMIT-MOVE-FROM-STACK REGISTER STACK-ITEM))) (SETF OPERAND-REGISTERS (REVERSE OPERAND-REGISTERS)) (DOLIST (ARG ARGS) (PUSH (ALLOCATE-REGISTER NIL) OPERAND-REGISTERS) (COMPILE-FORM ARG (CAR OPERAND-REGISTERS) NIL) (UNLESS MUST-CLEAR-VALUES (UNLESS (SINGLE-VALUED-P ARG) (SETF MUST-CLEAR-VALUES T)))) (DOLIST (REGISTER (NREVERSE OPERAND-REGISTERS)) (ALOAD REGISTER)))) ((<= NUMARGS CALL-REGISTERS-LIMIT) (DOLIST (ARG ARGS) (COMPILE-FORM ARG (QUOTE STACK) NIL) (UNLESS MUST-CLEAR-VALUES (UNLESS (SINGLE-VALUED-P ARG) (SETF MUST-CLEAR-VALUES T))))) (T (LET* ((*REGISTER* *REGISTER*) (ARRAY-REGISTER (ALLOCATE-REGISTER NIL)) SAVED-STACK) (WHEN UNSAFE-ARGS (DOLIST (STACK-ITEM STACK) (LET ((REGISTER (ALLOCATE-REGISTER NIL))) (PUSH REGISTER SAVED-STACK) (EMIT-MOVE-FROM-STACK REGISTER STACK-ITEM)))) (EMIT-PUSH-CONSTANT-INT NUMARGS) (EMIT-ANEWARRAY +LISP-OBJECT+) (ASTORE ARRAY-REGISTER) (LET ((I 0)) (DOLIST (ARG ARGS) (COND ((NOT (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARG))) (ALOAD ARRAY-REGISTER) (EMIT-PUSH-CONSTANT-INT I) (COMPILE-FORM ARG (QUOTE STACK) NIL)) (T (COMPILE-FORM ARG (QUOTE STACK) NIL) (ALOAD ARRAY-REGISTER) (EMIT (QUOTE SWAP)) (EMIT-PUSH-CONSTANT-INT I) (EMIT (QUOTE SWAP)))) (EMIT (QUOTE AASTORE)) (UNLESS MUST-CLEAR-VALUES (UNLESS (SINGLE-VALUED-P ARG) (SETF MUST-CLEAR-VALUES T))) (INCF I)) (WHEN UNSAFE-ARGS (MAPCAR (FUNCTION EMIT-PUSH-REGISTER) SAVED-STACK (REVERSE STACK))) (ALOAD ARRAY-REGISTER))))) (WHEN MUST-CLEAR-VALUES (EMIT-CLEAR-VALUES))))) T)
     [java] ; (DEFKNOWN LISP-OBJECT-ARG-TYPES (FIXNUM) LIST)
     [java] ; (LET ((TABLE (MAKE-ARRAY 10))) (DOTIMES (I 10) (DECLARE (TYPE FIXNUM I)) (SETF (AREF TABLE I) (MAKE-LIST I :INITIAL-ELEMENT +LISP-OBJECT+))) (DEFUN LISP-OBJECT-ARG-TYPES (N) (DECLARE (TYPE FIXNUM N)) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (IF (< N 10) (AREF TABLE N) (MAKE-LIST N :INITIAL-ELEMENT +LISP-OBJECT+))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) EMIT-CALL-EXECUTE))
     [java] ; (DEFUN EMIT-CALL-EXECUTE (NUMARGS) (LET ((ARG-TYPES (IF (<= NUMARGS CALL-REGISTERS-LIMIT) (LISP-OBJECT-ARG-TYPES NUMARGS) (LIST +LISP-OBJECT-ARRAY+))) (RETURN-TYPE +LISP-OBJECT+)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "execute" ARG-TYPES RETURN-TYPE)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) EMIT-CALL-THREAD-EXECUTE))
     [java] ; (DEFUN EMIT-CALL-THREAD-EXECUTE (NUMARGS) (LET ((ARG-TYPES (IF (<= NUMARGS CALL-REGISTERS-LIMIT) (LISP-OBJECT-ARG-TYPES (1+ NUMARGS)) (LIST +LISP-OBJECT+ +LISP-OBJECT-ARRAY+))) (RETURN-TYPE +LISP-OBJECT+)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "execute" ARG-TYPES RETURN-TYPE)))
     [java] ; (DEFKNOWN COMPILE-FUNCTION-CALL (T T T) T)
     [java] ; (DEFUN COMPILE-FUNCTION-CALL (FORM TARGET REPRESENTATION) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (DECLARE (TYPE SYMBOL OP)) (WHEN (FIND-LOCAL-FUNCTION OP) (RETURN-FROM COMPILE-FUNCTION-CALL (COMPILE-LOCAL-FUNCTION-CALL FORM TARGET REPRESENTATION))) (WHEN (AND (BOUNDP (QUOTE *DEFINED-FUNCTIONS*)) (BOUNDP (QUOTE *UNDEFINED-FUNCTIONS*))) (UNLESS (OR (FBOUNDP OP) (EQ OP (COMPILAND-NAME *CURRENT-COMPILAND*)) (MEMQ OP *DEFINED-FUNCTIONS*) (PROCLAIMED-FTYPE OP)) (PUSHNEW OP *UNDEFINED-FUNCTIONS*))) (LET ((NUMARGS (LENGTH ARGS))) (CASE NUMARGS (1 (WHEN (COMPILE-FUNCTION-CALL-1 OP ARGS TARGET REPRESENTATION) (RETURN-FROM COMPILE-FUNCTION-CALL))) (2 (WHEN (COMPILE-FUNCTION-CALL-2 OP ARGS TARGET REPRESENTATION) (RETURN-FROM COMPILE-FUNCTION-CALL)))) (LET ((EXPLAIN *EXPLAIN*)) (WHEN (AND EXPLAIN (MEMQ :CALLS EXPLAIN)) (LET ((PACKAGE (SYMBOL-PACKAGE OP))) (WHEN (OR (EQ PACKAGE +CL-PACKAGE+) (EQ PACKAGE (FIND-PACKAGE "SYSTEM"))) (FORMAT T ";   full call to ~S~%" OP))))) (WHEN (OR (<= *SPEED* *DEBUG*) *REQUIRE-STACK-FRAME*) (EMIT-PUSH-CURRENT-THREAD)) (COND ((AND (EQ OP (COMPILAND-NAME *CURRENT-COMPILAND*)) (NULL (COMPILAND-PARENT *CURRENT-COMPILAND*))) (IF (NOTINLINE-P OP) (EMIT-LOAD-EXTERNALIZED-OBJECT OP) (ALOAD 0))) (T (EMIT-LOAD-EXTERNALIZED-OBJECT OP))) (PROCESS-ARGS ARGS (IF (OR (<= *SPEED* *DEBUG*) *REQUIRE-STACK-FRAME*) (QUOTE (NIL NIL)) (QUOTE (NIL)))) (IF (OR (<= *SPEED* *DEBUG*) *REQUIRE-STACK-FRAME*) (EMIT-CALL-THREAD-EXECUTE NUMARGS) (EMIT-CALL-EXECUTE NUMARGS)) (FIX-BOXING REPRESENTATION (DERIVE-COMPILER-TYPE FORM)) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))
     [java] ; (DEFUN COMPILE-CALL (ARGS STACK) "Compiles a function call.
     [java]
     [java] Depending on the `*speed*' and `*debug*' settings, a stack frame
     [java] is registered (or not)." (LET ((NUMARGS (LENGTH ARGS))) (COND ((> *SPEED* *DEBUG*) (PROCESS-ARGS ARGS STACK) (EMIT-CALL-EXECUTE NUMARGS)) (T (EMIT-PUSH-CURRENT-THREAD) (EMIT (QUOTE SWAP)) (PROCESS-ARGS ARGS (LIST* (CAR STACK) NIL (CDR STACK))) (EMIT-CALL-THREAD-EXECUTE NUMARGS)))))
     [java] ; (DEFINE-SOURCE-TRANSFORM FUNCALL (&WHOLE FORM FUN &REST ARGS) (COND ((> *DEBUG* *SPEED*) FORM) ((AND (CONSP FUN) (EQ (%CAR FUN) (QUOTE FUNCTION)) (SYMBOLP (CADR FUN))) (SYSTEM::BACKQ-CONS (CADR FUN) ARGS)) ((AND (CONSP FUN) (EQ (%CAR FUN) (QUOTE QUOTE))) (LET ((SYM (CADR FUN))) (IF (AND (SYMBOLP SYM) (EQ (SYMBOL-PACKAGE (TRULY-THE SYMBOL SYM)) +CL-PACKAGE+) (NOT (SPECIAL-OPERATOR-P SYM)) (NOT (MACRO-FUNCTION SYM))) (SYSTEM::BACKQ-CONS (CADR FUN) ARGS) FORM))) (T FORM)))
     [java] ; (DEFINE-SOURCE-TRANSFORM MAPCAR (&WHOLE FORM FUNCTION &REST LISTS) (COND ((OR (> *DEBUG* *SPEED*) (> *SPACE* *SPEED*)) FORM) ((= (LENGTH LISTS) 1) (LET ((LIST (GENSYM)) (RESULT (GENSYM)) (TEMP (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST LIST (CAR LISTS)) (SYSTEM::BACKQ-CONS RESULT (QUOTE ((LIST NIL)))) (SYSTEM::BACKQ-LIST TEMP RESULT)) (SYSTEM::BACKQ-LIST (QUOTE LOOP) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE NULL) LIST) (SYSTEM::BACKQ-LIST (QUOTE RETURN) (SYSTEM::BACKQ-LIST (QUOTE CDR) RESULT))) (SYSTEM::BACKQ-LIST (QUOTE RPLACD) TEMP (SYSTEM::BACKQ-LIST (QUOTE SETF) TEMP (SYSTEM::BACKQ-LIST (QUOTE LIST) (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) FUNCTION (SYSTEM::BACKQ-LIST (QUOTE CAR) LIST))))) (SYSTEM::BACKQ-LIST (QUOTE SETF) LIST (SYSTEM::BACKQ-LIST (QUOTE CDR) LIST)))))) (T FORM)))
     [java] ; (DEFINE-SOURCE-TRANSFORM MAPC (&WHOLE FORM FUNCTION &REST LISTS) (COND ((OR (> *DEBUG* *SPEED*) (> *SPACE* *SPEED*)) FORM) ((= (LENGTH LISTS) 1) (LET ((LIST (GENSYM)) (RESULT (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST LIST (CAR LISTS)) (SYSTEM::BACKQ-LIST RESULT LIST)) (SYSTEM::BACKQ-LIST (QUOTE LOOP) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE NULL) LIST) (SYSTEM::BACKQ-LIST (QUOTE RETURN) RESULT)) (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) FUNCTION (SYSTEM::BACKQ-LIST (QUOTE CAR) LIST)) (SYSTEM::BACKQ-LIST (QUOTE SETF) LIST (SYSTEM::BACKQ-LIST (QUOTE %CDR) LIST)))))) (T FORM)))
     [java] ; (DEFKNOWN P2-FUNCALL (T T T) T)
     [java] ; (DEFUN P2-FUNCALL (FORM TARGET REPRESENTATION) (UNLESS (> (LENGTH FORM) 1) (COMPILER-WARN "Wrong number of arguments for ~A." (CAR FORM)) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-FUNCALL)) (WHEN (> *DEBUG* *SPEED*) (RETURN-FROM P2-FUNCALL (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (CADR FORM) (QUOTE STACK) NIL) (COMPILE-CALL (CDDR FORM) (QUOTE (NIL))) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET))
     [java] ; (DEFUN DUPLICATE-CLOSURE-ARRAY (COMPILAND) (LET* ((*REGISTER* *REGISTER*) (REGISTER (ALLOCATE-REGISTER NIL))) (ALOAD (COMPILAND-CLOSURE-REGISTER COMPILAND)) (EMIT-PUSH-CONSTANT-INT 0) (EMIT-PUSH-CONSTANT-INT (LENGTH *CLOSURE-VARIABLES*)) (EMIT-ANEWARRAY +LISP-CLOSURE-BINDING+) (EMIT (QUOTE DUP)) (ASTORE REGISTER) (EMIT-PUSH-CONSTANT-INT 0) (EMIT-PUSH-CONSTANT-INT (LENGTH *CLOSURE-VARIABLES*)) (EMIT-INVOKESTATIC +JAVA-SYSTEM+ "arraycopy" (LIST +JAVA-OBJECT+ :INT +JAVA-OBJECT+ :INT :INT) NIL) (ALOAD REGISTER)))
     [java] ; (DEFUN EMIT-LOAD-LOCAL-FUNCTION (LOCAL-FUNCTION) (WHEN (EQ *CURRENT-COMPILAND* (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION)) (ALOAD 0) (RETURN-FROM EMIT-LOAD-LOCAL-FUNCTION)) (MULTIPLE-VALUE-BIND (CLASS FIELD) (LOCAL-FUNCTION-CLASS-AND-FIELD LOCAL-FUNCTION) (EMIT-GETSTATIC CLASS FIELD +LISP-OBJECT+)) (WHEN *CLOSURE-VARIABLES* (EMIT-CHECKCAST +LISP-COMPILED-CLOSURE+) (DUPLICATE-CLOSURE-ARRAY *CURRENT-COMPILAND*) (EMIT-INVOKESTATIC +LISP+ "makeCompiledClosure" (LIST +LISP-OBJECT+ +CLOSURE-BINDING-ARRAY+) +LISP-OBJECT+)))
     [java] ; (DEFKNOWN COMPILE-LOCAL-FUNCTION-CALL (T T T) T)
     [java] ; (DEFUN COMPILE-LOCAL-FUNCTION-CALL (FORM TARGET REPRESENTATION) "Compiles a call to a function marked as `*child-p*'; a local function.
     [java]
     [java] Functions this applies to can be FLET, LABELS, LAMBDA or NAMED-LAMBDA.
     [java] Note: DEFUN implies a named lambda." (LET* ((OP (CAR FORM)) (ARGS (CDR FORM)) (LOCAL-FUNCTION (FIND-LOCAL-FUNCTION OP)) (*REGISTER* *REGISTER*)) (COND ((LOCAL-FUNCTION-ENVIRONMENT LOCAL-FUNCTION) (ASSERT (LOCAL-FUNCTION-REFERENCES-ALLOWED-P LOCAL-FUNCTION)) (ASSERT (NOT *FILE-COMPILATION*)) (EMIT-LOAD-EXTERNALIZED-OBJECT (LOCAL-FUNCTION-ENVIRONMENT LOCAL-FUNCTION) +LISP-ENVIRONMENT+) (EMIT-LOAD-EXTERNALIZED-OBJECT (LOCAL-FUNCTION-NAME LOCAL-FUNCTION)) (EMIT-INVOKEVIRTUAL +LISP-ENVIRONMENT+ "lookupFunction" (LIST +LISP-OBJECT+) +LISP-OBJECT+)) (T (DFORMAT T "compile-local-function-call default case~%") (EMIT-LOAD-LOCAL-FUNCTION LOCAL-FUNCTION))) (PROCESS-ARGS ARGS (QUOTE (NIL))) (EMIT-CALL-EXECUTE (LENGTH ARGS)) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) T)
     [java] ; (DEFVAR COMPARISON-OPS (QUOTE (< <= > >= =)))
     [java] ; (DEFVAR COMPARISON-INS (QUOTE ((:INT . #(IF_ICMPGE IF_ICMPGT IF_ICMPLE IF_ICMPLT IF_ICMPNE)) (:LONG . #((LCMP IFGE) (LCMP IFGT) (LCMP IFLE) (LCMP IFLT) (LCMP IFNE))) (:FLOAT . #((FCMPG IFGE) (FCMPG IFGT) (FCMPL IFLE) (FCMPL IFLT) (FCMPL IFNE))) (:DOUBLE . #((DCMPG IFGE) (DCMPG IFGT) (DCMPL IFLE) (DCMPL IFLT) (DCMPL IFNE))))) "Instructions to be generated upon each comparison operation,
     [java] given a specific common representation.")
     [java] ; (DEFUN EMIT-NUMERIC-COMPARISON (OP REPRESENTATION FALSE-LABEL) (LET* ((POS (POSITION OP COMPARISON-OPS)) (OPS-TABLE (CDR (ASSOC REPRESENTATION COMPARISON-INS))) (OPS (AREF OPS-TABLE POS))) (IF (LISTP OPS) (PROGN (EMIT (CAR OPS)) (EMIT (CADR OPS) FALSE-LABEL)) (EMIT OPS FALSE-LABEL))))
     [java] ; (DEFKNOWN P2-NUMERIC-COMPARISON (T T T) T)
     [java] ; (DEFUN P2-NUMERIC-COMPARISON (FORM TARGET REPRESENTATION) (AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (LET ((OP (CAR FORM)) (ARGS (%CDR FORM))) (CASE (LENGTH ARGS) (2 (LET* ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (COMMON-REP (COMMON-REPRESENTATION (TYPE-REPRESENTATION TYPE1) (TYPE-REPRESENTATION TYPE2)))) (COND ((AND (INTEGERP ARG1) (INTEGERP ARG2)) (LET ((RESULT (FUNCALL OP ARG1 ARG2))) (IF RESULT (EMIT-PUSH-TRUE REPRESENTATION) (EMIT-PUSH-FALSE REPRESENTATION))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-NUMERIC-COMPARISON)) (COMMON-REP (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 COMMON-REP) (COMPILE-OPERAND ARG2 COMMON-REP) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT-NUMERIC-COMPARISON OP COMMON-REP LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (LABEL LABEL2))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-NUMERIC-COMPARISON)) ((FIXNUMP ARG2) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-PUSH-CONSTANT-INT ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (CASE OP (< "isLessThan") (<= "isLessThanOrEqualTo") (> "isGreaterThan") (>= "isGreaterThanOrEqualTo") (= "isEqualTo")) (QUOTE (:INT)) :BOOLEAN) (CONVERT-REPRESENTATION :BOOLEAN REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-NUMERIC-COMPARISON))))) (3 (WHEN (DOLIST (ARG ARGS T) (UNLESS (FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE ARG)) (RETURN NIL))) (LET* ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (ARG3 (%CADDR ARGS)) (TEST (CASE OP (< (QUOTE IF_ICMPGE)) (<= (QUOTE IF_ICMPGT)) (> (QUOTE IF_ICMPLE)) (>= (QUOTE IF_ICMPLT)) (= (QUOTE IF_ICMPNE)))) (LABEL1 (GENSYM)) (LABEL2 (GENSYM)) (*REGISTER* *REGISTER*) (ARG2-REGISTER (UNLESS (AND (OR (NODE-CONSTANT-P ARG2) (VAR-REF-P ARG2)) (NODE-CONSTANT-P ARG3)) (ALLOCATE-REGISTER NIL))) (ARG3-REGISTER (UNLESS (NODE-CONSTANT-P ARG3) (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (WHEN ARG3-REGISTER (COMPILE-OPERAND ARG3 :INT)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3)) (WHEN ARG3-REGISTER (EMIT (QUOTE ISTORE) ARG3-REGISTER)) (WHEN ARG2-REGISTER (EMIT (QUOTE DUP)) (EMIT (QUOTE ISTORE) ARG2-REGISTER))) (EMIT TEST LABEL1) (COND (ARG2-REGISTER (EMIT (QUOTE ILOAD) ARG2-REGISTER)) (T (COMPILE-FORM ARG2 (QUOTE STACK) :INT))) (COND (ARG3-REGISTER (EMIT (QUOTE ILOAD) ARG3-REGISTER)) (T (COMPILE-FORM ARG3 (QUOTE STACK) :INT))) (EMIT TEST LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (LABEL LABEL2) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-NUMERIC-COMPARISON)))))) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))
     [java] ; (DEFPARAMETER *P2-TEST-HANDLERS* NIL)
     [java] ; (DEFUN P2-TEST-HANDLER (OP) (GETHASH1 OP (THE HASH-TABLE *P2-TEST-HANDLERS*)))
     [java] ; (DEFUN INITIALIZE-P2-TEST-HANDLERS NIL (LET ((HT (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (DOLIST (PAIR (QUOTE ((/= P2-TEST-/=) (< P2-TEST-NUMERIC-COMPARISON) (<= P2-TEST-NUMERIC-COMPARISON) (= P2-TEST-NUMERIC-COMPARISON) (> P2-TEST-NUMERIC-COMPARISON) (>= P2-TEST-NUMERIC-COMPARISON) (AND P2-TEST-AND) (OR P2-TEST-OR) (ATOM P2-TEST-ATOM) (BIT-VECTOR-P P2-TEST-BIT-VECTOR-P) (CHAR= P2-TEST-CHAR=) (CHARACTERP P2-TEST-CHARACTERP) (CONSP P2-TEST-CONSP) (CONSTANTP P2-TEST-CONSTANTP) (ENDP P2-TEST-ENDP) (EQ P2-TEST-EQ) (NEQ P2-TEST-NEQ) (EQL P2-TEST-EQL) (EQUAL P2-TEST-EQUALITY) (EQUALP P2-TEST-EQUALITY) (EVENP P2-TEST-EVENP) (FIXNUMP P2-TEST-FIXNUMP) (FLOATP P2-TEST-FLOATP) (INTEGERP P2-TEST-INTEGERP) (LISTP P2-TEST-LISTP) (MEMQ P2-TEST-MEMQ) (MEMQL P2-TEST-MEMQL) (MINUSP P2-TEST-MINUSP) (NOT P2-TEST-NOT/NULL) (NULL P2-TEST-NOT/NULL) (NUMBERP P2-TEST-NUMBERP) (PACKAGEP P2-TEST-PACKAGEP) (ODDP P2-TEST-ODDP) (PLUSP P2-TEST-PLUSP) (RATIONALP P2-TEST-RATIONALP) (REALP P2-TEST-REALP) (SIMPLE-TYPEP P2-TEST-SIMPLE-TYPEP) (SIMPLE-VECTOR-P P2-TEST-SIMPLE-VECTOR-P) (SPECIAL-OPERATOR-P P2-TEST-SPECIAL-OPERATOR-P) (SPECIAL-VARIABLE-P P2-TEST-SPECIAL-VARIABLE-P) (STRINGP P2-TEST-STRINGP) (SYMBOLP P2-TEST-SYMBOLP) (VECTORP P2-TEST-VECTORP) (ZEROP P2-TEST-ZEROP)))) (SETF (GETHASH (%CAR PAIR) HT) (%CADR PAIR))) (SETF *P2-TEST-HANDLERS* HT)))
     [java] ; (DEFKNOWN NEGATE-JUMP-CONDITION (T) T)
     [java] ; (DEFUN NEGATE-JUMP-CONDITION (JUMP-INSTRUCTION) (ECASE JUMP-INSTRUCTION ((QUOTE IF_ACMPEQ) (QUOTE IF_ACMPNE)) ((QUOTE IF_ACMPNE) (QUOTE IF_ACMPEQ)) ((QUOTE IFEQ) (QUOTE IFNE)) ((QUOTE IFNE) (QUOTE IFEQ)) ((QUOTE IFLT) (QUOTE IFGE)) ((QUOTE IFGE) (QUOTE IFLT)) ((QUOTE IFGT) (QUOTE IFLE)) ((QUOTE IFLE) (QUOTE IFGT)) ((QUOTE IF_ICMPEQ) (QUOTE IF_ICMPNE)) ((QUOTE IF_ICMPNE) (QUOTE IF_ICMPEQ)) ((QUOTE IF_ICMPLT) (QUOTE IF_ICMPGE)) ((QUOTE IF_ICMPGE) (QUOTE IF_ICMPLT)) ((QUOTE IF_ICMPGT) (QUOTE IF_ICMPLE)) ((QUOTE IF_ICMPLE) (QUOTE IF_ICMPGT))))
     [java] ; (DEFKNOWN EMIT-TEST-JUMP (T T T) T)
     [java] ; (DEFUN EMIT-TEST-JUMP (JUMP SUCCESS-LABEL FAILURE-LABEL) (COND (FAILURE-LABEL (EMIT JUMP FAILURE-LABEL) (WHEN SUCCESS-LABEL (EMIT (QUOTE GOTO) SUCCESS-LABEL))) (T (EMIT (NEGATE-JUMP-CONDITION JUMP) SUCCESS-LABEL))) T)
     [java] ; (DEFKNOWN P2-TEST-PREDICATE (T T) T)
     [java] ; (DEFUN P2-TEST-PREDICATE (FORM JAVA-PREDICATE SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 1) (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ JAVA-PREDICATE NIL :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T T) T) P2-TEST-INSTANCEOF-PREDICATE))
     [java] ; (DEFUN P2-TEST-INSTANCEOF-PREDICATE (FORM JAVA-CLASS SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 1) (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INSTANCEOF JAVA-CLASS) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-BIT-VECTOR-P (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-ABSTRACT-BIT-VECTOR+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-CHARACTERP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-CHARACTER+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-CONSTANTP (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (= (LENGTH FORM) 2) (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "constantp" NIL :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-ENDP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "endp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFMACRO P2-TEST-INTEGER-PREDICATE ((FORM PREDICATE SUCCESS-LABEL FAILURE-LABEL) &BODY INSTRUCTIONS) (LET ((TMPFORM (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST TMPFORM FORM)) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST* (QUOTE CHECK-ARG-COUNT) TMPFORM (QUOTE (1))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE ARG) (SYSTEM::BACKQ-LIST (QUOTE %CADR) TMPFORM))) (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-LIST* (QUOTE (FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE ARG))) (QUOTE (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :INT)) INSTRUCTIONS) (SYSTEM::BACKQ-LIST (QUOTE T) (SYSTEM::BACKQ-LIST (QUOTE P2-TEST-PREDICATE) TMPFORM PREDICATE SUCCESS-LABEL FAILURE-LABEL))))))))
     [java] ; (DEFUN P2-TEST-EVENP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INTEGER-PREDICATE (FORM "evenp" SUCCESS-LABEL FAILURE-LABEL) (EMIT-PUSH-CONSTANT-INT 1) (EMIT (QUOTE IAND)) (EMIT-TEST-JUMP (QUOTE IFNE) SUCCESS-LABEL FAILURE-LABEL)))
     [java] ; (DEFUN P2-TEST-ODDP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INTEGER-PREDICATE (FORM "oddp" SUCCESS-LABEL FAILURE-LABEL) (EMIT-PUSH-CONSTANT-INT 1) (EMIT (QUOTE IAND)) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)))
     [java] ; (DEFUN P2-TEST-FLOATP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "floatp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-INTEGERP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "integerp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-LISTP (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 1) (LET* ((ARG (%CADR FORM)) (ARG-TYPE (DERIVE-COMPILER-TYPE ARG))) (COND ((MEMQ ARG-TYPE (QUOTE (CONS LIST NULL))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG NIL NIL) :CONSEQUENT) ((NEQ ARG-TYPE T) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG NIL NIL) :ALTERNATE) (T (P2-TEST-PREDICATE FORM "listp" SUCCESS-LABEL FAILURE-LABEL))))))
     [java] ; (DEFUN P2-TEST-MINUSP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INTEGER-PREDICATE (FORM "minusp" SUCCESS-LABEL FAILURE-LABEL) (EMIT-TEST-JUMP (QUOTE IFGE) SUCCESS-LABEL FAILURE-LABEL)))
     [java] ; (DEFUN P2-TEST-PLUSP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INTEGER-PREDICATE (FORM "plusp" SUCCESS-LABEL FAILURE-LABEL) (EMIT-TEST-JUMP (QUOTE IFLE) SUCCESS-LABEL FAILURE-LABEL)))
     [java] ; (DEFUN P2-TEST-ZEROP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INTEGER-PREDICATE (FORM "zerop" SUCCESS-LABEL FAILURE-LABEL) (EMIT-TEST-JUMP (QUOTE IFNE) SUCCESS-LABEL FAILURE-LABEL)))
     [java] ; (DEFUN P2-TEST-NUMBERP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "numberp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-PACKAGEP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-PACKAGE+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-RATIONALP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "rationalp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-REALP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "realp" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-SPECIAL-OPERATOR-P (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "isSpecialOperator" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-SPECIAL-VARIABLE-P (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-PREDICATE FORM "isSpecialVariable" SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-SYMBOLP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-SYMBOL+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-CONSP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-CONS+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-ATOM (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-CONS+ FAILURE-LABEL SUCCESS-LABEL))
     [java] ; (DEFUN P2-TEST-FIXNUMP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-FIXNUM+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-STRINGP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-ABSTRACT-STRING+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-VECTORP (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-ABSTRACT-VECTOR+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFUN P2-TEST-SIMPLE-VECTOR-P (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-INSTANCEOF-PREDICATE FORM +LISP-SIMPLE-VECTOR+ SUCCESS-LABEL FAILURE-LABEL))
     [java] ; (DEFKNOWN COMPILE-TEST-FORM (T) T)
     [java] ; (DEFUN COMPILE-TEST-FORM (TEST-FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CONSP TEST-FORM) (LET* ((OP (%CAR TEST-FORM)) (HANDLER (P2-TEST-HANDLER OP)) (RESULT (AND HANDLER (FUNCALL HANDLER TEST-FORM SUCCESS-LABEL FAILURE-LABEL)))) (WHEN RESULT (RETURN-FROM COMPILE-TEST-FORM RESULT)))) (COND ((EQ TEST-FORM T) :CONSEQUENT) ((EQ (DERIVE-COMPILER-TYPE TEST-FORM) (QUOTE BOOLEAN)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES TEST-FORM (QUOTE STACK) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES TEST-FORM (QUOTE STACK) NIL) (EMIT-PUSH-NIL) (EMIT-TEST-JUMP (QUOTE IF_ACMPEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-NOT/NULL (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 1) (LET* ((ARG (%CADR FORM)) (RESULT (COMPILE-TEST-FORM ARG FAILURE-LABEL SUCCESS-LABEL))) (CASE RESULT (:CONSEQUENT :ALTERNATE) (:ALTERNATE :CONSEQUENT) (T RESULT)))))
     [java] ; (DEFUN P2-TEST-CHAR= (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (= (LENGTH FORM) 3) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :CHAR) (COMPILE-OPERAND ARG2 :CHAR) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (QUOTE IF_ICMPNE) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-EQ (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (QUOTE IF_ACMPNE) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-OR (FORM SUCCESS-LABEL FAILURE-LABEL) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 :ALTERNATE) (1 (COMPILE-TEST-FORM (%CAR ARGS) SUCCESS-LABEL FAILURE-LABEL)) (T (LOOP WITH LOCAL-SUCCESS-LABEL = (OR SUCCESS-LABEL (GENSYM)) FOR ARG IN ARGS FOR RESULT = (COMPILE-TEST-FORM ARG LOCAL-SUCCESS-LABEL NIL) WHEN (EQ :CONSEQUENT RESULT) DO (PROGN (EMIT (QUOTE GOTO) LOCAL-SUCCESS-LABEL) (LOOP-FINISH)) FINALLY (PROGN (WHEN FAILURE-LABEL (EMIT (QUOTE GOTO) FAILURE-LABEL)) (UNLESS (EQ SUCCESS-LABEL LOCAL-SUCCESS-LABEL) (LABEL LOCAL-SUCCESS-LABEL)) (RETURN T)))))))
     [java] ; (DEFUN P2-TEST-AND (FORM SUCCESS-LABEL FAILURE-LABEL) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 :CONSEQUENT) (1 (COMPILE-TEST-FORM (%CAR ARGS) SUCCESS-LABEL FAILURE-LABEL)) (T (LOOP WITH LOCAL-FAIL-LABEL = (OR FAILURE-LABEL (GENSYM)) FOR ARG IN ARGS FOR RESULT = (COMPILE-TEST-FORM ARG NIL LOCAL-FAIL-LABEL) WHEN (EQ :ALTERNATE RESULT) DO (PROGN (EMIT (QUOTE GOTO) LOCAL-FAIL-LABEL) (LOOP-FINISH)) FINALLY (PROGN (WHEN SUCCESS-LABEL (EMIT (QUOTE GOTO) SUCCESS-LABEL)) (UNLESS (EQ FAILURE-LABEL LOCAL-FAIL-LABEL) (LABEL LOCAL-FAIL-LABEL)) (RETURN T)))))))
     [java] ; (DEFUN P2-TEST-NEQ (FORM SUCCESS-LABEL FAILURE-LABEL) (P2-TEST-EQ FORM FAILURE-LABEL SUCCESS-LABEL))
     [java] ; (DEFUN P2-TEST-EQL (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (QUOTE IF_ICMPNE) SUCCESS-LABEL FAILURE-LABEL)) ((AND (EQ TYPE1 (QUOTE CHARACTER)) (EQ TYPE2 (QUOTE CHARACTER))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :CHAR) (COMPILE-OPERAND ARG2 :CHAR) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (QUOTE IF_ICMPNE) SUCCESS-LABEL FAILURE-LABEL)) ((EQ TYPE2 (QUOTE CHARACTER)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :CHAR) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (QUOTE (:CHAR)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) ((EQ TYPE1 (QUOTE CHARACTER)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :CHAR) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (QUOTE (:CHAR)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "eql" (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))))
     [java] ; (DEFUN P2-TEST-EQUALITY (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET* ((OP (%CAR FORM)) (TRANSLATED-OP (ECASE OP (EQUAL "equal") (EQUALP "equalp"))) (ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (COND ((FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE ARG2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ TRANSLATED-OP (QUOTE (:INT)) :BOOLEAN)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ TRANSLATED-OP (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN))) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-SIMPLE-TYPEP (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "typep" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-PUSH-NIL) (EMIT-TEST-JUMP (QUOTE IF_ACMPEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-MEMQ (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESTATIC +LISP+ "memq" (LISP-OBJECT-ARG-TYPES 2) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-MEMQL (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-ARG-COUNT FORM 2) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESTATIC +LISP+ "memql" (LISP-OBJECT-ARG-TYPES 2) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))
     [java] ; (DEFUN P2-TEST-/= (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (= (LENGTH FORM) 3) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (NUMBERP ARG1) (NUMBERP ARG2)) (IF (/= ARG1 ARG2) :CONSEQUENT :ALTERNATE)) ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (QUOTE IF_ICMPEQ) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "isNotEqualTo" (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "isNotEqualTo" (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "isNotEqualTo" (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL))))))
     [java] ; (DEFUN P2-TEST-NUMERIC-COMPARISON (FORM SUCCESS-LABEL FAILURE-LABEL) (WHEN (CHECK-MIN-ARGS FORM 1) (WHEN (= (LENGTH FORM) 3) (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (FIXNUMP ARG1) (FIXNUMP ARG2)) (IF (FUNCALL OP ARG1 ARG2) :CONSEQUENT :ALTERNATE)) ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-TEST-JUMP (ECASE OP (< (QUOTE IF_ICMPGE)) (<= (QUOTE IF_ICMPGT)) (> (QUOTE IF_ICMPLE)) (>= (QUOTE IF_ICMPLT)) (= (QUOTE IF_ICMPNE))) SUCCESS-LABEL FAILURE-LABEL)) ((AND (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :LONG) (COMPILE-OPERAND ARG2 :LONG) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE LCMP)) (EMIT-TEST-JUMP (ECASE OP (< (QUOTE IFGE)) (<= (QUOTE IFGT)) (> (QUOTE IFLE)) (>= (QUOTE IFLT)) (= (QUOTE IFNE))) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (ECASE OP (< "isLessThan") (<= "isLessThanOrEqualTo") (> "isGreaterThan") (>= "isGreaterThanOrEqualTo") (= "isEqualTo")) (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (ECASE OP (< "isGreaterThan") (<= "isGreaterThanOrEqualTo") (> "isLessThan") (>= "isLessThanOrEqualTo") (= "isEqualTo")) (QUOTE (:INT)) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (ECASE OP (< "isLessThan") (<= "isLessThanOrEqualTo") (> "isGreaterThan") (>= "isGreaterThanOrEqualTo") (= "isEqualTo")) (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN) (EMIT-TEST-JUMP (QUOTE IFEQ) SUCCESS-LABEL FAILURE-LABEL)))))))
     [java] ; (DEFKNOWN P2-IF (T T T) T)
     [java] ; (DEFUN P2-IF (FORM TARGET REPRESENTATION) (LET* ((TEST (SECOND FORM)) (CONSEQUENT (THIRD FORM)) (ALTERNATE (FOURTH FORM)) (LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (LET ((RESULT (COMPILE-TEST-FORM TEST NIL LABEL1))) (CASE RESULT (:CONSEQUENT (COMPILE-FORM CONSEQUENT TARGET REPRESENTATION)) (:ALTERNATE (COMPILE-FORM ALTERNATE TARGET REPRESENTATION)) (T (COMPILE-FORM CONSEQUENT TARGET REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (COMPILE-FORM ALTERNATE TARGET REPRESENTATION) (LABEL LABEL2))))))
     [java] ; (DEFUN COMPILE-MULTIPLE-VALUE-LIST (FORM TARGET REPRESENTATION) (EMIT-CLEAR-VALUES) (COMPILE-FORM (SECOND FORM) (QUOTE STACK) NIL) (EMIT-INVOKESTATIC +LISP+ "multipleValueList" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET))
     [java] ; (DEFUN COMPILE-MULTIPLE-VALUE-PROG1 (FORM TARGET REPRESENTATION) (LET ((FIRST-SUBFORM (CADR FORM)) (SUBFORMS (CDDR FORM)) (RESULT-REGISTER (ALLOCATE-REGISTER NIL)) (VALUES-REGISTER (ALLOCATE-REGISTER NIL))) (EMIT-CLEAR-VALUES) (COMPILE-FORM FIRST-SUBFORM RESULT-REGISTER NIL) (EMIT-PUSH-CURRENT-THREAD) (EMIT-GETFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (ASTORE VALUES-REGISTER) (COMPILE-PROGN-BODY SUBFORMS NIL NIL) (EMIT-PUSH-CURRENT-THREAD) (ALOAD VALUES-REGISTER) (EMIT-PUTFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (ALOAD RESULT-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET)))
     [java] ; (DEFUN COMPILE-MULTIPLE-VALUE-CALL (FORM TARGET REPRESENTATION) (AVER (NULL REPRESENTATION)) (CASE (LENGTH FORM) (1 (ERROR "Wrong number of arguments for MULTIPLE-VALUE-CALL.")) (2 (COMPILE-FORM (SECOND FORM) (QUOTE STACK) NIL) (EMIT-INVOKESTATIC +LISP+ "coerceToFunction" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "execute" NIL +LISP-OBJECT+)) (3 (LET* ((*REGISTER* *REGISTER*) (FUNCTION-REGISTER (ALLOCATE-REGISTER NIL))) (COMPILE-FORM (SECOND FORM) FUNCTION-REGISTER NIL) (COMPILE-FORM (THIRD FORM) (QUOTE STACK) NIL) (ALOAD FUNCTION-REGISTER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKESTATIC +LISP+ "multipleValueCall1" (LIST +LISP-OBJECT+ +LISP-OBJECT+ +LISP-THREAD+) +LISP-OBJECT+))) (T (LET* ((*REGISTER* *REGISTER*) (FUNCTION-REGISTER (ALLOCATE-REGISTER NIL)) (VALUES-REGISTER (ALLOCATE-REGISTER NIL))) (COMPILE-FORM (SECOND FORM) (QUOTE STACK) NIL) (EMIT-INVOKESTATIC +LISP+ "coerceToFunction" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK FUNCTION-REGISTER) (EMIT (QUOTE ACONST_NULL)) (ASTORE VALUES-REGISTER) (DOLIST (VALUES-FORM (CDDR FORM)) (COMPILE-FORM VALUES-FORM (QUOTE STACK) NIL) (EMIT-PUSH-CURRENT-THREAD) (EMIT (QUOTE SWAP)) (ALOAD VALUES-REGISTER) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "accumulateValues" (LIST +LISP-OBJECT+ +LISP-OBJECT-ARRAY+) +LISP-OBJECT-ARRAY+) (ASTORE VALUES-REGISTER) (MAYBE-EMIT-CLEAR-VALUES VALUES-FORM)) (ALOAD FUNCTION-REGISTER) (ALOAD VALUES-REGISTER) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "dispatch" (LIST +LISP-OBJECT-ARRAY+) +LISP-OBJECT+)))) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET))
     [java] ; (DEFKNOWN UNUSED-VARIABLE (T) T)
     [java] ; (DEFUN UNUSED-VARIABLE (VARIABLE) (UNLESS (OR (VARIABLE-IGNORE-P VARIABLE) (VARIABLE-IGNORABLE-P VARIABLE)) (COMPILER-STYLE-WARN "The variable ~S is defined but never used." (VARIABLE-NAME VARIABLE))))
     [java] ; (DEFKNOWN CHECK-FOR-UNUSED-VARIABLES (LIST) T)
     [java] ; (DEFUN CHECK-FOR-UNUSED-VARIABLES (LIST) (DOLIST (VARIABLE LIST) (WHEN (AND (NOT (VARIABLE-SPECIAL-P VARIABLE)) (ZEROP (VARIABLE-READS VARIABLE)) (ZEROP (VARIABLE-WRITES VARIABLE))) (UNUSED-VARIABLE VARIABLE))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) EMIT-NEW-CLOSURE-BINDING))
     [java] ; (DEFUN EMIT-NEW-CLOSURE-BINDING (VARIABLE) "" (EMIT-NEW +LISP-CLOSURE-BINDING+) (EMIT (QUOTE DUP_X1)) (EMIT (QUOTE SWAP)) (EMIT-INVOKESPECIAL-INIT +LISP-CLOSURE-BINDING+ (LIST +LISP-OBJECT+)) (ALOAD (COMPILAND-CLOSURE-REGISTER *CURRENT-COMPILAND*)) (EMIT (QUOTE SWAP)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-CLOSURE-INDEX VARIABLE)) (EMIT (QUOTE SWAP)) (EMIT (QUOTE AASTORE)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) COMPILE-BINDING))
     [java] ; (DEFUN COMPILE-BINDING (VARIABLE) (COND ((VARIABLE-REGISTER VARIABLE) (ASTORE (VARIABLE-REGISTER VARIABLE))) ((VARIABLE-SPECIAL-P VARIABLE) (EMIT-PUSH-CURRENT-THREAD) (EMIT (QUOTE SWAP)) (EMIT-PUSH-VARIABLE-NAME VARIABLE) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "bindSpecial" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) +LISP-SPECIAL-BINDING+) (IF (VARIABLE-BINDING-REGISTER VARIABLE) (ASTORE (VARIABLE-BINDING-REGISTER VARIABLE)) (EMIT (QUOTE POP)))) ((VARIABLE-CLOSURE-INDEX VARIABLE) (EMIT-NEW-CLOSURE-BINDING VARIABLE)) (T (SYSTEM::%FORMAT T "compile-binding~%") (AVER NIL))))
     [java] ; (DEFKNOWN COMPILE-PROGN-BODY (T T &OPTIONAL T) T)
     [java] ; (DEFUN COMPILE-PROGN-BODY (BODY TARGET &OPTIONAL REPRESENTATION) (COND ((NULL BODY) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET))) (T (LOOP WITH CLEAR-VALUES = NIL FOR TAIL ON BODY FOR FORM = (CAR TAIL) DO (COND ((NULL (CDR TAIL)) (WHEN CLEAR-VALUES (EMIT-CLEAR-VALUES)) (COMPILE-FORM FORM TARGET REPRESENTATION) (RETURN)) (T (COMPILE-FORM FORM NIL NIL) (UNLESS CLEAR-VALUES (UNLESS (SINGLE-VALUED-P FORM) (SETQ CLEAR-VALUES T)))))))) T)
     [java] ; (DEFUN RESTORE-DYNAMIC-ENVIRONMENT (REGISTER) (EMIT-PUSH-CURRENT-THREAD) (ALOAD REGISTER) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "resetSpecialBindings" (LIST +LISP-SPECIAL-BINDINGS-MARK+) NIL))
     [java] ; (DEFUN SAVE-DYNAMIC-ENVIRONMENT (REGISTER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "markSpecialBindings" NIL +LISP-SPECIAL-BINDINGS-MARK+) (ASTORE REGISTER))
     [java] ; (DEFUN P2-M-V-B-NODE (BLOCK TARGET) (LET* ((*REGISTER* *REGISTER*) (FORM (M-V-B-FORM BLOCK)) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (VARS (SECOND FORM)) (BIND-SPECIAL-P NIL) (VARIABLES (M-V-B-VARS BLOCK))) (DOLIST (VARIABLE VARIABLES) (LET ((SPECIAL-P (VARIABLE-SPECIAL-P VARIABLE))) (COND (SPECIAL-P (SETF BIND-SPECIAL-P T)) (T (UNLESS (VARIABLE-CLOSURE-INDEX VARIABLE) (SETF (VARIABLE-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL))))))) (WHEN BIND-SPECIAL-P (DFORMAT T "p2-m-v-b-node lastSpecialBinding~%") (SETF (M-V-B-ENVIRONMENT-REGISTER BLOCK) (ALLOCATE-REGISTER NIL)) (SAVE-DYNAMIC-ENVIRONMENT (M-V-B-ENVIRONMENT-REGISTER BLOCK))) (EMIT-CLEAR-VALUES) (AVER (= (LENGTH VARS) (LENGTH VARIABLES))) (COND ((= (LENGTH VARS) 1) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (THIRD FORM) (QUOTE STACK) NIL) (COMPILE-BINDING (CAR VARIABLES))) (T (LET* ((*REGISTER* *REGISTER*) (RESULT-REGISTER (ALLOCATE-REGISTER NIL)) (VALUES-REGISTER (ALLOCATE-REGISTER NIL)) (LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (COMPILE-FORM (THIRD FORM) RESULT-REGISTER NIL) (EMIT-PUSH-CURRENT-THREAD) (EMIT-GETFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (EMIT-MOVE-FROM-STACK VALUES-REGISTER) (ALOAD VALUES-REGISTER) (EMIT (QUOTE IFNULL) LABEL1) (ALOAD VALUES-REGISTER) (EMIT (QUOTE ARRAYLENGTH)) (EMIT-PUSH-CONSTANT-INT (LENGTH VARS)) (EMIT (QUOTE IF_ICMPLT) LABEL1) (ALOAD VALUES-REGISTER) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-CURRENT-THREAD) (ALOAD RESULT-REGISTER) (EMIT-PUSH-CONSTANT-INT (LENGTH VARS)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "getValues" (LIST +LISP-OBJECT+ :INT) +LISP-OBJECT-ARRAY+) (LABEL LABEL2) (LET ((INDEX 0)) (DOLIST (VARIABLE VARIABLES) (WHEN (< INDEX (1- (LENGTH VARS))) (EMIT (QUOTE DUP))) (EMIT-PUSH-CONSTANT-INT INDEX) (INCF INDEX) (EMIT (QUOTE AALOAD)) (COMPILE-BINDING VARIABLE))) (MAYBE-EMIT-CLEAR-VALUES (THIRD FORM))))) (DOLIST (VARIABLE VARIABLES) (PUSH VARIABLE *VISIBLE-VARIABLES*)) (DOLIST (VARIABLE (M-V-B-FREE-SPECIALS BLOCK)) (PUSH VARIABLE *VISIBLE-VARIABLES*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDDDR FORM)) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY (CDDDR FORM) TARGET))) (WHEN BIND-SPECIAL-P (RESTORE-DYNAMIC-ENVIRONMENT (M-V-B-ENVIRONMENT-REGISTER BLOCK)))))
     [java] ; (DEFUN PROPAGATE-VARS (BLOCK) (LET ((REMOVED (QUOTE NIL))) (DOLIST (VARIABLE (LET-VARS BLOCK)) (UNLESS (OR (VARIABLE-SPECIAL-P VARIABLE) (VARIABLE-CLOSURE-INDEX VARIABLE)) (WHEN (EQL (VARIABLE-WRITES VARIABLE) 0) (LET ((INITFORM (VARIABLE-INITFORM VARIABLE))) (COND ((VAR-REF-P INITFORM) (LET ((SOURCE-VAR (VAR-REF-VARIABLE INITFORM))) (COND ((NULL SOURCE-VAR) (AVER (VAR-REF-CONSTANT-P INITFORM)) (LET ((VALUE (VAR-REF-CONSTANT-VALUE INITFORM))) (DOLIST (REF (VARIABLE-REFERENCES VARIABLE)) (AVER (EQ (VAR-REF-VARIABLE REF) VARIABLE)) (SETF (VAR-REF-VARIABLE REF) NIL (VAR-REF-CONSTANT-P REF) T (VAR-REF-CONSTANT-VALUE REF) VALUE)))) (T (UNLESS (OR (VARIABLE-SPECIAL-P SOURCE-VAR) (VARIABLE-USED-NON-LOCALLY-P SOURCE-VAR)) (WHEN (EQL (VARIABLE-WRITES SOURCE-VAR) 0) (AVER (= (VARIABLE-READS VARIABLE) (LENGTH (VARIABLE-REFERENCES VARIABLE)))) (DOLIST (REF (VARIABLE-REFERENCES VARIABLE)) (AVER (EQ (VAR-REF-VARIABLE REF) VARIABLE)) (SETF (VAR-REF-VARIABLE REF) SOURCE-VAR)) (WHEN (GET (VARIABLE-NAME VARIABLE) (QUOTE SYSTEM::DOTIMES-LIMIT-VARIABLE-P)) (LET* ((SYMBOL (GET (VARIABLE-NAME VARIABLE) (QUOTE SYSTEM::DOTIMES-INDEX-VARIABLE-NAME))) (INDEX-VARIABLE (FIND-VARIABLE SYMBOL (LET-VARS BLOCK)))) (WHEN INDEX-VARIABLE (SETF (GET (VARIABLE-NAME INDEX-VARIABLE) (QUOTE SYSTEM::DOTIMES-LIMIT-VARIABLE-NAME)) (VARIABLE-NAME SOURCE-VAR))))) (PUSH VARIABLE REMOVED))))))) ((FIXNUMP INITFORM) (DOLIST (REF (VARIABLE-REFERENCES VARIABLE)) (AVER (EQ (VAR-REF-VARIABLE REF) VARIABLE)) (SETF (VAR-REF-VARIABLE REF) NIL (VAR-REF-CONSTANT-P REF) T (VAR-REF-CONSTANT-VALUE REF) INITFORM)) (PUSH VARIABLE REMOVED))))))) (WHEN REMOVED (DOLIST (VARIABLE REMOVED) (SETF (LET-VARS BLOCK) (REMOVE VARIABLE (LET-VARS BLOCK)))))))
     [java] ; (DEFUN DERIVE-VARIABLE-REPRESENTATION (VARIABLE BLOCK &KEY (TYPE NIL TYPE-SUPPLIED-P)) (WHEN (NOT (NULL (VARIABLE-REPRESENTATION VARIABLE))) (RETURN-FROM DERIVE-VARIABLE-REPRESENTATION)) (WHEN TYPE-SUPPLIED-P (SETF (VARIABLE-DECLARED-TYPE VARIABLE) TYPE)) (WHEN (OR (VARIABLE-CLOSURE-INDEX VARIABLE) (VARIABLE-INDEX VARIABLE)) (RETURN-FROM DERIVE-VARIABLE-REPRESENTATION)) (LET ((TYPE (VARIABLE-DECLARED-TYPE VARIABLE))) (WHEN (AND (EQ (VARIABLE-DECLARED-TYPE VARIABLE) :NONE) (EQL (VARIABLE-WRITES VARIABLE) 0)) (VARIABLE-DERIVED-TYPE VARIABLE)) (COND ((NEQ TYPE :NONE) (SETF (VARIABLE-REPRESENTATION VARIABLE) (TYPE-REPRESENTATION TYPE)) (UNLESS (MEMQ (VARIABLE-REPRESENTATION VARIABLE) (QUOTE (:INT :LONG))) (SETF (VARIABLE-REPRESENTATION VARIABLE) NIL))) ((ZEROP (VARIABLE-WRITES VARIABLE)) (WHEN (EQ :NONE (VARIABLE-DERIVED-TYPE VARIABLE)) (SETF (VARIABLE-DERIVED-TYPE VARIABLE) (DERIVE-COMPILER-TYPE (VARIABLE-INITFORM VARIABLE)))) (LET ((DERIVED-TYPE (VARIABLE-DERIVED-TYPE VARIABLE))) (SETF (VARIABLE-DERIVED-TYPE VARIABLE) DERIVED-TYPE) (SETF (VARIABLE-REPRESENTATION VARIABLE) (TYPE-REPRESENTATION DERIVED-TYPE)) (UNLESS (MEMQ (VARIABLE-REPRESENTATION VARIABLE) (QUOTE (:INT :LONG))) (SETF (VARIABLE-REPRESENTATION VARIABLE) NIL)))) ((AND BLOCK (GET (VARIABLE-NAME VARIABLE) (QUOTE SYSTEM::DOTIMES-INDEX-VARIABLE-P))) (LET* ((NAME (GET (VARIABLE-NAME VARIABLE) (QUOTE SYSTEM::DOTIMES-LIMIT-VARIABLE-NAME))) (LIMIT-VARIABLE (AND NAME (OR (FIND-VARIABLE NAME (LET-VARS BLOCK)) (FIND-VISIBLE-VARIABLE NAME))))) (WHEN LIMIT-VARIABLE (DERIVE-VARIABLE-REPRESENTATION LIMIT-VARIABLE BLOCK) (SETF (VARIABLE-REPRESENTATION VARIABLE) (VARIABLE-REPRESENTATION LIMIT-VARIABLE)) (LET ((LIMIT-TYPE (VARIABLE-DERIVED-TYPE LIMIT-VARIABLE))) (WHEN (INTEGER-TYPE-P LIMIT-TYPE) (SETF (VARIABLE-DERIVED-TYPE VARIABLE) (%MAKE-INTEGER-TYPE 0 (INTEGER-TYPE-HIGH LIMIT-TYPE)))))))))))
     [java] ; (DEFUN ALLOCATE-VARIABLE-REGISTER (VARIABLE) (SETF (VARIABLE-REGISTER VARIABLE) (ALLOCATE-REGISTER (VARIABLE-REPRESENTATION VARIABLE))))
     [java] ; (DEFUN EMIT-MOVE-TO-VARIABLE (VARIABLE) (LET ((REPRESENTATION (VARIABLE-REPRESENTATION VARIABLE))) (COND ((VARIABLE-REGISTER VARIABLE) (EMIT (ECASE (VARIABLE-REPRESENTATION VARIABLE) ((:INT :BOOLEAN :CHAR) (QUOTE ISTORE)) (:LONG (QUOTE LSTORE)) (:FLOAT (QUOTE FSTORE)) (:DOUBLE (QUOTE DSTORE)) ((NIL) (QUOTE ASTORE))) (VARIABLE-REGISTER VARIABLE))) ((VARIABLE-INDEX VARIABLE) (ALOAD (COMPILAND-ARGUMENT-REGISTER *CURRENT-COMPILAND*)) (EMIT-SWAP REPRESENTATION NIL) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT-SWAP REPRESENTATION :INT) (EMIT (QUOTE AASTORE))) ((VARIABLE-CLOSURE-INDEX VARIABLE) (ALOAD (COMPILAND-CLOSURE-REGISTER *CURRENT-COMPILAND*)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-CLOSURE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)) (EMIT-SWAP REPRESENTATION NIL) (EMIT-PUTFIELD +LISP-CLOSURE-BINDING+ "value" +LISP-OBJECT+)) ((VARIABLE-ENVIRONMENT VARIABLE) (ASSERT (NOT *FILE-COMPILATION*)) (EMIT-LOAD-EXTERNALIZED-OBJECT (VARIABLE-ENVIRONMENT VARIABLE) +LISP-ENVIRONMENT+) (EMIT (QUOTE SWAP)) (EMIT-PUSH-VARIABLE-NAME VARIABLE) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-ENVIRONMENT+ "rebind" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) NIL)) (T (ASSERT NIL)))))
     [java] ; (DEFUN EMIT-PUSH-VARIABLE (VARIABLE) (COND ((VARIABLE-REGISTER VARIABLE) (EMIT (ECASE (VARIABLE-REPRESENTATION VARIABLE) ((:INT :BOOLEAN :CHAR) (QUOTE ILOAD)) (:LONG (QUOTE LLOAD)) (:FLOAT (QUOTE FLOAD)) (:DOUBLE (QUOTE DLOAD)) ((NIL) (QUOTE ALOAD))) (VARIABLE-REGISTER VARIABLE))) ((VARIABLE-INDEX VARIABLE) (ALOAD (COMPILAND-ARGUMENT-REGISTER *CURRENT-COMPILAND*)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD))) ((VARIABLE-CLOSURE-INDEX VARIABLE) (ALOAD (COMPILAND-CLOSURE-REGISTER *CURRENT-COMPILAND*)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-CLOSURE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)) (EMIT-GETFIELD +LISP-CLOSURE-BINDING+ "value" +LISP-OBJECT+)) ((VARIABLE-ENVIRONMENT VARIABLE) (ASSERT (NOT *FILE-COMPILATION*)) (EMIT-LOAD-EXTERNALIZED-OBJECT (VARIABLE-ENVIRONMENT VARIABLE) +LISP-ENVIRONMENT+) (EMIT-PUSH-VARIABLE-NAME VARIABLE) (EMIT-INVOKEVIRTUAL +LISP-ENVIRONMENT+ "lookup" (LIST +LISP-OBJECT+) +LISP-OBJECT+)) (T (ASSERT NIL))))
     [java] ; (DEFKNOWN P2-LET-BINDINGS (T) T)
     [java] ; (DEFUN P2-LET-BINDINGS (BLOCK) (DOLIST (VARIABLE (LET-VARS BLOCK)) (UNLESS (OR (VARIABLE-SPECIAL-P VARIABLE) (VARIABLE-CLOSURE-INDEX VARIABLE) (ZEROP (VARIABLE-READS VARIABLE))) (AVER (NULL (VARIABLE-REGISTER VARIABLE))) (SETF (VARIABLE-REGISTER VARIABLE) T))) (LET (MUST-CLEAR-VALUES TEMPORARY-STORAGE) (DECLARE (TYPE BOOLEAN MUST-CLEAR-VALUES)) (DOLIST (VARIABLE (LET-VARS BLOCK)) (LET* ((INITFORM (VARIABLE-INITFORM VARIABLE)) (UNUSED-P (AND (NOT (VARIABLE-SPECIAL-P VARIABLE)) (ZEROP (VARIABLE-READS VARIABLE))))) (COND (UNUSED-P (COMPILE-FORM INITFORM NIL NIL)) (T (COND (INITFORM (WHEN (EQ (VARIABLE-REGISTER VARIABLE) T) (DERIVE-VARIABLE-REPRESENTATION VARIABLE BLOCK)) (COMPILE-FORM INITFORM (QUOTE STACK) (VARIABLE-REPRESENTATION VARIABLE)) (UNLESS MUST-CLEAR-VALUES (UNLESS (SINGLE-VALUED-P INITFORM) (SETF MUST-CLEAR-VALUES T)))) (T (EMIT-PUSH-NIL))) (WHEN (EQ (VARIABLE-REGISTER VARIABLE) T) (ALLOCATE-VARIABLE-REGISTER VARIABLE)) (WHEN (VARIABLE-SPECIAL-P VARIABLE) (SETF (VARIABLE-BINDING-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL))) (COND ((VARIABLE-SPECIAL-P VARIABLE) (LET ((TEMP-REGISTER (ALLOCATE-REGISTER NIL))) (PUSH (CONS TEMP-REGISTER VARIABLE) TEMPORARY-STORAGE) (EMIT-MOVE-FROM-STACK TEMP-REGISTER))) ((VARIABLE-REPRESENTATION VARIABLE) (EMIT-MOVE-TO-VARIABLE VARIABLE)) (T (COMPILE-BINDING VARIABLE))))))) (WHEN MUST-CLEAR-VALUES (EMIT-CLEAR-VALUES)) (DOLIST (TEMP TEMPORARY-STORAGE) (ALOAD (CAR TEMP)) (COMPILE-BINDING (CDR TEMP)))) (DOLIST (VARIABLE (LET-VARS BLOCK)) (PUSH VARIABLE *VISIBLE-VARIABLES*)) T)
     [java] ; (DEFKNOWN P2-LET*-BINDINGS (T) T)
     [java] ; (DEFUN P2-LET*-BINDINGS (BLOCK) (LET ((MUST-CLEAR-VALUES NIL)) (DECLARE (TYPE BOOLEAN MUST-CLEAR-VALUES)) (DOLIST (VARIABLE (LET-VARS BLOCK)) (LET* ((INITFORM (VARIABLE-INITFORM VARIABLE)) (UNUSED-P (AND (NOT (VARIABLE-SPECIAL-P VARIABLE)) (ZEROP (VARIABLE-READS VARIABLE)) (ZEROP (VARIABLE-WRITES VARIABLE)))) (BOUNDP NIL)) (DECLARE (TYPE BOOLEAN UNUSED-P BOUNDP)) (MACROLET ((UPDATE-MUST-CLEAR-VALUES NIL (QUOTE (UNLESS MUST-CLEAR-VALUES (UNLESS (SINGLE-VALUED-P INITFORM) (SETF MUST-CLEAR-VALUES T)))))) (COND ((AND (VARIABLE-SPECIAL-P VARIABLE) (EQ INITFORM (VARIABLE-NAME VARIABLE))) (EMIT-PUSH-CURRENT-THREAD) (EMIT-PUSH-VARIABLE-NAME VARIABLE) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "bindSpecialToCurrentValue" (LIST +LISP-SYMBOL+) +LISP-SPECIAL-BINDING+) (IF (VARIABLE-BINDING-REGISTER VARIABLE) (ASTORE (VARIABLE-BINDING-REGISTER VARIABLE)) (EMIT (QUOTE POP))) (SETF BOUNDP T)) ((AND (NOT (VARIABLE-SPECIAL-P VARIABLE)) (ZEROP (VARIABLE-READS VARIABLE))) (COMPILE-FORM INITFORM NIL NIL) (UPDATE-MUST-CLEAR-VALUES) (SETF BOUNDP T)) ((NULL INITFORM) (COND ((AND (NULL (VARIABLE-CLOSURE-INDEX VARIABLE)) (NOT (VARIABLE-SPECIAL-P VARIABLE)) (EQ (VARIABLE-DECLARED-TYPE VARIABLE) (QUOTE BOOLEAN))) (SETF (VARIABLE-REPRESENTATION VARIABLE) :BOOLEAN) (SETF (VARIABLE-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL)) (EMIT (QUOTE ICONST_0)) (EMIT (QUOTE ISTORE) (VARIABLE-REGISTER VARIABLE)) (SETF BOUNDP T)) (T (EMIT-PUSH-NIL)))) (T (COND (UNUSED-P (COMPILE-FORM INITFORM NIL NIL) (UPDATE-MUST-CLEAR-VALUES) (SETF BOUNDP T)) ((AND (NULL (VARIABLE-CLOSURE-INDEX VARIABLE)) (NOT (VARIABLE-SPECIAL-P VARIABLE))) (WHEN (AND (EQ (VARIABLE-DECLARED-TYPE VARIABLE) :NONE) (EQL (VARIABLE-WRITES VARIABLE) 0)) (SETF (VARIABLE-DERIVED-TYPE VARIABLE) (DERIVE-COMPILER-TYPE INITFORM))) (DERIVE-VARIABLE-REPRESENTATION VARIABLE BLOCK) (ALLOCATE-VARIABLE-REGISTER VARIABLE) (COMPILE-FORM INITFORM (QUOTE STACK) (VARIABLE-REPRESENTATION VARIABLE)) (UPDATE-MUST-CLEAR-VALUES) (EMIT-MOVE-TO-VARIABLE VARIABLE) (SETF BOUNDP T)) (T (COMPILE-FORM INITFORM (QUOTE STACK) NIL) (UPDATE-MUST-CLEAR-VALUES)))))) (UNLESS (OR BOUNDP (VARIABLE-SPECIAL-P VARIABLE)) (UNLESS (OR (VARIABLE-CLOSURE-INDEX VARIABLE) (VARIABLE-REGISTER VARIABLE)) (SETF (VARIABLE-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL)))) (PUSH VARIABLE *VISIBLE-VARIABLES*) (UNLESS BOUNDP (WHEN (VARIABLE-SPECIAL-P VARIABLE) (SETF (VARIABLE-BINDING-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL))) (COMPILE-BINDING VARIABLE)) (MAYBE-GENERATE-TYPE-CHECK VARIABLE))) (WHEN MUST-CLEAR-VALUES (EMIT-CLEAR-VALUES))) T)
     [java] ; (DEFUN P2-LET/LET*-NODE (BLOCK TARGET REPRESENTATION) (LET* ((*REGISTER* *REGISTER*) (FORM (LET-FORM BLOCK)) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (SPECIALP NIL)) (DOLIST (VARIABLE (LET-VARS BLOCK)) (COND ((VARIABLE-SPECIAL-P VARIABLE) (SETF SPECIALP T)) ((ZEROP (VARIABLE-READS VARIABLE)) (UNUSED-VARIABLE VARIABLE)))) (WHEN SPECIALP (SETF (LET-ENVIRONMENT-REGISTER BLOCK) (ALLOCATE-REGISTER NIL)) (SAVE-DYNAMIC-ENVIRONMENT (LET-ENVIRONMENT-REGISTER BLOCK))) (PROPAGATE-VARS BLOCK) (ECASE (CAR FORM) (LET (P2-LET-BINDINGS BLOCK)) (LET* (P2-LET*-BINDINGS BLOCK))) (DOLIST (VARIABLE (LET-FREE-SPECIALS BLOCK)) (PUSH VARIABLE *VISIBLE-VARIABLES*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS (CDDR FORM)) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY (CDDR FORM) TARGET REPRESENTATION))) (WHEN SPECIALP (RESTORE-DYNAMIC-ENVIRONMENT (LET-ENVIRONMENT-REGISTER BLOCK)))))
     [java] ; (DEFKNOWN P2-LOCALLY-NODE (T T T) T)
     [java] ; (DEFUN P2-LOCALLY-NODE (BLOCK TARGET REPRESENTATION) (WITH-SAVED-COMPILER-POLICY (LET* ((BODY (CDR (LOCALLY-FORM BLOCK))) (*VISIBLE-VARIABLES* (APPEND (LOCALLY-FREE-SPECIALS BLOCK) *VISIBLE-VARIABLES*)) (*BLOCKS* (CONS BLOCK *BLOCKS*))) (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (COMPILE-PROGN-BODY BODY TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-TAGBODY-NODE (T T) T)
     [java] ; (DEFUN P2-TAGBODY-NODE (BLOCK TARGET) (LET* ((*BLOCKS* (CONS BLOCK *BLOCKS*)) (*VISIBLE-TAGS* *VISIBLE-TAGS*) (*REGISTER* *REGISTER*) (FORM (TAGBODY-FORM BLOCK)) (BODY (CDR FORM)) (BEGIN-BLOCK (GENSYM "F")) (END-BLOCK (GENSYM "U")) (RETHROW (GENSYM "T")) (EXIT (GENSYM "E")) (MUST-CLEAR-VALUES NIL) (SPECIALS-REGISTER (WHEN (TAGBODY-NON-LOCAL-GO-P BLOCK) (ALLOCATE-REGISTER NIL)))) (DOLIST (TAG (TAGBODY-TAGS BLOCK)) (PUSH TAG *VISIBLE-TAGS*)) (WHEN (TAGBODY-ID-VARIABLE BLOCK) (ASSERT (NOT (NULL (VARIABLE-CLOSURE-INDEX (TAGBODY-ID-VARIABLE BLOCK))))) (EMIT-NEW +BLOCK-LISP-OBJECT+) (EMIT (QUOTE DUP)) (EMIT-INVOKESPECIAL-INIT +BLOCK-LISP-OBJECT+ (QUOTE NIL)) (EMIT-NEW-CLOSURE-BINDING (TAGBODY-ID-VARIABLE BLOCK))) (WHEN (TAGBODY-NON-LOCAL-GO-P BLOCK) (SAVE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER)) (LABEL BEGIN-BLOCK) (DO* ((REST BODY (CDR REST)) (SUBFORM (CAR REST) (CAR REST))) ((NULL REST)) (COND ((OR (SYMBOLP SUBFORM) (INTEGERP SUBFORM)) (LET ((TAG (FIND SUBFORM (TAGBODY-TAGS BLOCK) :KEY (FUNCTION TAG-NAME) :TEST (FUNCTION EQL)))) (UNLESS TAG (ERROR "COMPILE-TAGBODY: tag not found: ~S~%" SUBFORM)) (WHEN (TAG-USED TAG) (LABEL (TAG-LABEL TAG))))) (T (COMPILE-FORM SUBFORM NIL NIL) (UNLESS MUST-CLEAR-VALUES (SETF MUST-CLEAR-VALUES (NOT (SINGLE-VALUED-P SUBFORM))))))) (LABEL END-BLOCK) (EMIT (QUOTE GOTO) EXIT) (WHEN (TAGBODY-NON-LOCAL-GO-P BLOCK) (LET* ((HANDLER (GENSYM "H")) (EXTENT-EXIT-HANDLER (GENSYM "HE")) (*REGISTER* *REGISTER*) (GO-REGISTER (ALLOCATE-REGISTER NIL)) (TAG-REGISTER (ALLOCATE-REGISTER NIL))) (LABEL HANDLER) (EMIT (QUOTE DUP)) (ASTORE GO-REGISTER) (EMIT-GETFIELD +LISP-GO+ "tagbody" +LISP-OBJECT+) (EMIT-PUSH-VARIABLE (TAGBODY-ID-VARIABLE BLOCK)) (EMIT (QUOTE IF_ACMPNE) RETHROW) (ALOAD GO-REGISTER) (EMIT-GETFIELD +LISP-GO+ "tag" +LISP-OBJECT+) (ASTORE TAG-REGISTER) (RESTORE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (DOLIST (TAG (REMOVE-IF-NOT (FUNCTION TAG-USED-NON-LOCALLY) (TAGBODY-TAGS BLOCK))) (ALOAD TAG-REGISTER) (EMIT-LOAD-EXTERNALIZED-OBJECT (TAG-LABEL TAG)) (EMIT (QUOTE IF_ACMPEQ) (TAG-LABEL TAG))) (LABEL RETHROW) (ALOAD GO-REGISTER) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (TAGBODY-ID-VARIABLE BLOCK)) (EMIT (QUOTE ATHROW)) (LABEL EXTENT-EXIT-HANDLER) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (TAGBODY-ID-VARIABLE BLOCK)) (EMIT (QUOTE ATHROW)) (ADD-EXCEPTION-HANDLER BEGIN-BLOCK END-BLOCK HANDLER +LISP-GO+) (ADD-EXCEPTION-HANDLER BEGIN-BLOCK END-BLOCK EXTENT-EXIT-HANDLER NIL))) (LABEL EXIT) (WHEN (TAGBODY-NON-LOCAL-GO-P BLOCK) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (TAGBODY-ID-VARIABLE BLOCK))) (WHEN MUST-CLEAR-VALUES (EMIT-CLEAR-VALUES)) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET))))
     [java] ; (DEFKNOWN P2-GO (T T T) T)
     [java] ; (DEFUN P2-GO (FORM TARGET REPRESENTATION) (DECLARE (IGNORE TARGET REPRESENTATION)) (LET* ((NODE FORM) (FORM (NODE-FORM FORM)) (NAME (CADR FORM)) (TAG (JUMP-TARGET-TAG NODE)) (TAG-BLOCK (WHEN TAG (JUMP-TARGET-BLOCK NODE)))) (UNLESS TAG (ERROR "p2-go: tag not found: ~S" NAME)) (WHEN (AND (EQ (TAG-COMPILAND TAG) *CURRENT-COMPILAND*) (NOT (ENCLOSED-BY-PROTECTED-BLOCK-P TAG-BLOCK))) (WHEN (AND (TAGBODY-NEEDS-ENVIRONMENT-RESTORATION TAG-BLOCK) (ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P TAG-BLOCK)) (RESTORE-DYNAMIC-ENVIRONMENT (ENVIRONMENT-REGISTER-TO-RESTORE TAG-BLOCK))) (MAYBE-GENERATE-INTERRUPT-CHECK) (EMIT (QUOTE GOTO) (TAG-LABEL TAG)) (RETURN-FROM P2-GO)) (EMIT-PUSH-VARIABLE (TAGBODY-ID-VARIABLE TAG-BLOCK)) (EMIT-LOAD-EXTERNALIZED-OBJECT (TAG-LABEL TAG)) (EMIT-INVOKESTATIC +LISP+ "nonLocalGo" (LISP-OBJECT-ARG-TYPES 2) +LISP-OBJECT+) (EMIT (QUOTE ARETURN))))
     [java] ; (DEFKNOWN P2-ATOM (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-ATOM (FORM TARGET REPRESENTATION) ((AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (CHECK-ARG-COUNT FORM 1)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (CADR FORM) (QUOTE STACK) NIL) (EMIT-INSTANCEOF +LISP-CONS+) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IFEQ) LABEL1) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_0))) ((NIL) (EMIT-PUSH-NIL))) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_1))) ((NIL) (EMIT-PUSH-T))) (LABEL LABEL2) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFKNOWN P2-INSTANCEOF-PREDICATE (T T T T) T)
     [java] ; (DEFUN P2-INSTANCEOF-PREDICATE (FORM TARGET REPRESENTATION JAVA-CLASS) (UNLESS (CHECK-ARG-COUNT FORM 1) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-INSTANCEOF-PREDICATE)) (LET ((ARG (%CADR FORM))) (COND ((NULL TARGET) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG NIL NIL)) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INSTANCEOF JAVA-CLASS) (CONVERT-REPRESENTATION :BOOLEAN REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-BIT-VECTOR-P (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-ABSTRACT-BIT-VECTOR+))
     [java] ; (DEFUN P2-CHARACTERP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-CHARACTER+))
     [java] ; (DEFUN P2-CONSP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-CONS+))
     [java] ; (DEFUN P2-FIXNUMP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-FIXNUM+))
     [java] ; (DEFUN P2-PACKAGEP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-PACKAGE+))
     [java] ; (DEFUN P2-READTABLEP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-READTABLE+))
     [java] ; (DEFUN P2-SIMPLE-VECTOR-P (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-SIMPLE-VECTOR+))
     [java] ; (DEFUN P2-STRINGP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-ABSTRACT-STRING+))
     [java] ; (DEFUN P2-SYMBOLP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-SYMBOL+))
     [java] ; (DEFUN P2-VECTORP (FORM TARGET REPRESENTATION) (P2-INSTANCEOF-PREDICATE FORM TARGET REPRESENTATION +LISP-ABSTRACT-VECTOR+))
     [java] ; (DEFINE-INLINED-FUNCTION P2-COERCE-TO-FUNCTION (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (%CADR FORM) (QUOTE STACK) NIL) (EMIT-INVOKESTATIC +LISP+ "coerceToFunction" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET))
     [java] ; (DEFUN P2-BLOCK-NODE (BLOCK TARGET REPRESENTATION) (UNLESS (BLOCK-NODE-P BLOCK) (SYSTEM::%FORMAT T "type-of block = ~S~%" (TYPE-OF BLOCK)) (AVER (BLOCK-NODE-P BLOCK))) (LET* ((*BLOCKS* (CONS BLOCK *BLOCKS*)) (*REGISTER* *REGISTER*) (BEGIN-BLOCK (GENSYM "F")) (END-BLOCK (GENSYM "U")) (BLOCK-EXIT (BLOCK-EXIT BLOCK)) (SPECIALS-REGISTER (WHEN (BLOCK-NON-LOCAL-RETURN-P BLOCK) (ALLOCATE-REGISTER NIL)))) (SETF (BLOCK-TARGET BLOCK) TARGET) (WHEN (BLOCK-ID-VARIABLE BLOCK) (ASSERT (NOT (NULL (VARIABLE-CLOSURE-INDEX (BLOCK-ID-VARIABLE BLOCK))))) (EMIT-NEW +BLOCK-LISP-OBJECT+) (EMIT (QUOTE DUP)) (EMIT-INVOKESPECIAL-INIT +BLOCK-LISP-OBJECT+ (QUOTE NIL)) (EMIT-NEW-CLOSURE-BINDING (BLOCK-ID-VARIABLE BLOCK))) (DFORMAT T "*all-variables* = ~S~%" (MAPCAR (FUNCTION VARIABLE-NAME) *ALL-VARIABLES*)) (WHEN (BLOCK-NON-LOCAL-RETURN-P BLOCK) (SAVE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER)) (LABEL BEGIN-BLOCK) (COMPILE-PROGN-BODY (CDDR (BLOCK-FORM BLOCK)) TARGET) (LABEL END-BLOCK) (WHEN (BLOCK-NON-LOCAL-RETURN-P BLOCK) (EMIT (QUOTE GOTO) BLOCK-EXIT) (LET ((HANDLER (GENSYM "H")) (EXTENT-EXIT-HANDLER (GENSYM "HE")) (THIS-BLOCK (GENSYM))) (LABEL HANDLER) (EMIT (QUOTE DUP)) (EMIT-GETFIELD +LISP-RETURN+ "tag" +LISP-OBJECT+) (EMIT-PUSH-VARIABLE (BLOCK-ID-VARIABLE BLOCK)) (EMIT (QUOTE IF_ACMPEQ) THIS-BLOCK) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (BLOCK-ID-VARIABLE BLOCK)) (EMIT (QUOTE ATHROW)) (LABEL EXTENT-EXIT-HANDLER) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (BLOCK-ID-VARIABLE BLOCK)) (EMIT (QUOTE ATHROW)) (LABEL THIS-BLOCK) (RESTORE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (EMIT-GETFIELD +LISP-RETURN+ "result" +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET) (ADD-EXCEPTION-HANDLER BEGIN-BLOCK END-BLOCK HANDLER +LISP-RETURN+) (ADD-EXCEPTION-HANDLER BEGIN-BLOCK END-BLOCK EXTENT-EXIT-HANDLER NIL))) (LABEL BLOCK-EXIT) (WHEN (BLOCK-ID-VARIABLE BLOCK) (EMIT (QUOTE ACONST_NULL)) (EMIT-MOVE-TO-VARIABLE (BLOCK-ID-VARIABLE BLOCK))) (FIX-BOXING REPRESENTATION NIL)))
     [java] ; (DEFKNOWN P2-RETURN-FROM (T T T) T)
     [java] ; (DEFUN P2-RETURN-FROM (FORM TARGET REPRESENTATION) (DECLARE (IGNORE TARGET REPRESENTATION)) (LET* ((NODE FORM) (FORM (NODE-FORM FORM)) (NAME (SECOND FORM)) (RESULT-FORM (THIRD FORM)) (BLOCK (JUMP-TARGET-BLOCK NODE))) (WHEN (NULL BLOCK) (ERROR "No block named ~S is currently visible." NAME)) (LET ((COMPILAND *CURRENT-COMPILAND*)) (WHEN (EQ (BLOCK-COMPILAND BLOCK) COMPILAND) (UNLESS (ENCLOSED-BY-PROTECTED-BLOCK-P BLOCK) (EMIT-CLEAR-VALUES) (COMPILE-FORM RESULT-FORM (BLOCK-TARGET BLOCK) NIL) (WHEN (AND (BLOCK-NEEDS-ENVIRONMENT-RESTORATION BLOCK) (ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P BLOCK)) (RESTORE-DYNAMIC-ENVIRONMENT (ENVIRONMENT-REGISTER-TO-RESTORE BLOCK))) (EMIT (QUOTE GOTO) (BLOCK-EXIT BLOCK)) (RETURN-FROM P2-RETURN-FROM)))) (AVER (BLOCK-NON-LOCAL-RETURN-P BLOCK)) (EMIT-CLEAR-VALUES) (WITH-OPERAND-ACCUMULATION ((EMIT-VARIABLE-OPERAND (BLOCK-ID-VARIABLE BLOCK)) (EMIT-LOAD-EXTERNALIZED-OBJECT-OPERAND (BLOCK-NAME BLOCK)) (COMPILE-OPERAND RESULT-FORM NIL)) (EMIT-INVOKESTATIC +LISP+ "nonLocalReturn" (LISP-OBJECT-ARG-TYPES 3) +LISP-OBJECT+)) (EMIT (QUOTE ARETURN))))
     [java] ; (DEFUN EMIT-CAR/CDR (ARG TARGET REPRESENTATION FIELD) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD FIELD TARGET REPRESENTATION))
     [java] ; (DEFINE-INLINED-FUNCTION P2-CAR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (%CADR FORM))) (COND ((AND (NULL TARGET) (< *SAFETY* 3)) (COMPILE-FORM ARG TARGET NIL)) ((AND (CONSP ARG) (EQ (%CAR ARG) (QUOTE CDR)) (= (LENGTH ARG) 2)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (SECOND ARG) (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD "cadr" TARGET REPRESENTATION)) (T (EMIT-CAR/CDR ARG TARGET REPRESENTATION "car")))))
     [java] ; (DEFINE-INLINED-FUNCTION P2-CDR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (%CADR FORM))) (EMIT-CAR/CDR ARG TARGET REPRESENTATION "cdr")))
     [java] ; (DEFINE-INLINED-FUNCTION P2-CONS (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (CONS-REGISTER (WHEN (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARGS)) (ALLOCATE-REGISTER NIL)))) (EMIT-NEW +LISP-CONS+) (IF CONS-REGISTER (ASTORE CONS-REGISTER) (EMIT (QUOTE DUP))) (WITH-OPERAND-ACCUMULATION ((WHEN CONS-REGISTER (EMIT-REGISTER-OPERAND CONS-REGISTER NIL)) (COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESPECIAL-INIT +LISP-CONS+ (LISP-OBJECT-ARG-TYPES 2)) (WHEN CONS-REGISTER (EMIT-PUSH-REGISTER CONS-REGISTER NIL)) (EMIT-MOVE-FROM-STACK TARGET)))
     [java] ; (DEFUN COMPILE-PROGN (FORM TARGET REPRESENTATION) (COMPILE-PROGN-BODY (CDR FORM) TARGET) (FIX-BOXING REPRESENTATION NIL))
     [java] ; (DEFUN P2-EVAL-WHEN (FORM TARGET REPRESENTATION) (COND ((OR (MEMQ :EXECUTE (CADR FORM)) (MEMQ (QUOTE EVAL) (CADR FORM))) (COMPILE-PROGN-BODY (CDDR FORM) TARGET) (FIX-BOXING REPRESENTATION NIL)) (T (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET))))
     [java] ; (DEFUN P2-LOAD-TIME-VALUE (FORM TARGET REPRESENTATION) (COND (*FILE-COMPILATION* (EMIT-GETSTATIC *THIS-CLASS* (DECLARE-LOAD-TIME-VALUE (SECOND FORM)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-CONSTANT (EVAL (SECOND FORM)) TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-PROGV-NODE (BLOCK TARGET REPRESENTATION) (LET* ((FORM (PROGV-FORM BLOCK)) (SYMBOLS-FORM (CADR FORM)) (VALUES-FORM (CADDR FORM)) (*REGISTER* *REGISTER*) (ENVIRONMENT-REGISTER (SETF (PROGV-ENVIRONMENT-REGISTER BLOCK) (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND SYMBOLS-FORM NIL) (COMPILE-OPERAND VALUES-FORM NIL)) (UNLESS (AND (SINGLE-VALUED-P SYMBOLS-FORM) (SINGLE-VALUED-P VALUES-FORM)) (EMIT-CLEAR-VALUES)) (SAVE-DYNAMIC-ENVIRONMENT ENVIRONMENT-REGISTER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKESTATIC +LISP+ "progvBindVars" (LIST +LISP-OBJECT+ +LISP-OBJECT+ +LISP-THREAD+) NIL)) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY (CDDDR FORM) TARGET REPRESENTATION)) (RESTORE-DYNAMIC-ENVIRONMENT ENVIRONMENT-REGISTER)))
     [java] ; (DEFUN P2-QUOTE (FORM TARGET REPRESENTATION) (AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (LET ((OBJ (SECOND FORM))) (COND ((NULL OBJ) (WHEN TARGET (EMIT-PUSH-FALSE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) ((EQ REPRESENTATION :BOOLEAN) (EMIT (QUOTE ICONST_1)) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((SYMBOLP OBJ) (EMIT-LOAD-EXTERNALIZED-OBJECT OBJ) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((LISTP OBJ) (EMIT-LOAD-EXTERNALIZED-OBJECT OBJ) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((CONSTANTP OBJ) (COMPILE-CONSTANT OBJ TARGET REPRESENTATION)) (T (COMPILER-UNSUPPORTED "COMPILE-QUOTE: unsupported case: ~S" FORM)))))
     [java] ; (DEFINE-INLINED-FUNCTION P2-RPLACD (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (CDR FORM)) (*REGISTER* *REGISTER*) (TARGET-REGISTER (ALLOCATE-REGISTER NIL))) (WITH-OPERAND-ACCUMULATION ((ACCUMULATE-OPERAND (NIL :UNSAFE-P (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS (FIRST ARGS)))) (COMPILE-FORM (FIRST ARGS) (QUOTE STACK) NIL) (WHEN TARGET-REGISTER (EMIT (QUOTE DUP)) (ASTORE TARGET-REGISTER))) (COMPILE-OPERAND (SECOND ARGS) NIL))) (MAYBE-EMIT-CLEAR-VALUES (CAR ARGS) (CADR ARGS)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "setCdr" (LISP-OBJECT-ARG-TYPES 1) NIL) (WHEN TARGET-REGISTER (ALOAD TARGET-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))
     [java] ; (DEFINE-INLINED-FUNCTION P2-SET-CAR/CDR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (*REGISTER* *REGISTER*) (TARGET-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND (%CAR ARGS) NIL) (ACCUMULATE-OPERAND (NIL :UNSAFE-P (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS (CADR ARGS)))) (COMPILE-FORM (%CADR ARGS) (QUOTE STACK) NIL) (WHEN TARGET-REGISTER (EMIT (QUOTE DUP)) (ASTORE TARGET-REGISTER))) (MAYBE-EMIT-CLEAR-VALUES (CAR ARGS) (CADR ARGS)))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (IF (EQ OP (QUOTE SET-CAR)) "setCar" "setCdr") (LISP-OBJECT-ARG-TYPES 1) NIL) (WHEN TARGET-REGISTER (ALOAD TARGET-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))
     [java] ; (DEFUN COMPILE-DECLARE (FORM TARGET REPRESENTATION) (DECLARE (IGNORE FORM REPRESENTATION)) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET)))
     [java] ; (DEFUN COMPILE-LOCAL-FUNCTION (LOCAL-FUNCTION) (LET* ((COMPILAND (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION)) (PATHNAME (FUNCALL *PATHNAMES-GENERATOR*)) (CLASS-FILE (MAKE-ABCL-CLASS-FILE :PATHNAME PATHNAME)) (STREAM (UNLESS *FILE-COMPILATION* (SYSTEM::%MAKE-BYTE-ARRAY-OUTPUT-STREAM)))) (SETF (COMPILAND-CLASS-FILE COMPILAND) CLASS-FILE) (WITH-OPEN-STREAM (F (OR STREAM (OPEN PATHNAME :DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE))) (WITH-CLASS-FILE CLASS-FILE (COMPILE-TO-JVM-CLASS COMPILAND) (FINISH-CLASS (COMPILAND-CLASS-FILE COMPILAND) F))) (WHEN STREAM (LET ((BYTES (SYSTEM::%GET-OUTPUT-STREAM-BYTES STREAM))) (SYSTEM::PUT-MEMORY-FUNCTION *MEMORY-CLASS-LOADER* (CLASS-NAME-INTERNAL (ABCL-CLASS-FILE-CLASS-NAME (COMPILAND-CLASS-FILE COMPILAND))) BYTES)))))
     [java] ; (DEFKNOWN P2-FLET-NODE (T T T) T)
     [java] ; (DEFUN P2-FLET-NODE (BLOCK TARGET REPRESENTATION) (LET* ((FORM (FLET-FORM BLOCK)) (*LOCAL-FUNCTIONS* *LOCAL-FUNCTIONS*) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (LOCAL-FUNCTIONS (CADR FORM)) (BODY (CDDR FORM))) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (COMPILE-LOCAL-FUNCTION LOCAL-FUNCTION)) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (PUSH LOCAL-FUNCTION *LOCAL-FUNCTIONS*)) (DOLIST (SPECIAL (FLET-FREE-SPECIALS BLOCK)) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY BODY TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-LABELS-NODE (T T T) T)
     [java] ; (DEFUN P2-LABELS-NODE (BLOCK TARGET REPRESENTATION) (LET* ((FORM (LABELS-FORM BLOCK)) (*LOCAL-FUNCTIONS* *LOCAL-FUNCTIONS*) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (LOCAL-FUNCTIONS (CADR FORM)) (BODY (CDDR FORM))) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (PUSH LOCAL-FUNCTION *LOCAL-FUNCTIONS*)) (DOLIST (LOCAL-FUNCTION LOCAL-FUNCTIONS) (COMPILE-LOCAL-FUNCTION LOCAL-FUNCTION)) (DOLIST (SPECIAL (LABELS-FREE-SPECIALS BLOCK)) (PUSH SPECIAL *VISIBLE-VARIABLES*)) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY BODY TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-LAMBDA (LOCAL-FUNCTION TARGET) (COMPILE-LOCAL-FUNCTION LOCAL-FUNCTION) (EMIT-LOAD-LOCAL-FUNCTION LOCAL-FUNCTION) (EMIT-MOVE-FROM-STACK TARGET))
     [java] ; (DEFKNOWN P2-FUNCTION (T T T) T)
     [java] ; (DEFUN P2-FUNCTION (FORM TARGET REPRESENTATION) (DECLARE (IGNORE REPRESENTATION)) (LET ((NAME (SECOND FORM)) LOCAL-FUNCTION) (COND ((SYMBOLP NAME) (DFORMAT T "p2-function case 1~%") (COND ((SETF LOCAL-FUNCTION (FIND-LOCAL-FUNCTION NAME)) (DFORMAT T "p2-function 1~%") (EMIT-LOAD-LOCAL-FUNCTION LOCAL-FUNCTION) (EMIT-MOVE-FROM-STACK TARGET)) ((INLINE-OK NAME) (EMIT-GETSTATIC *THIS-CLASS* (DECLARE-FUNCTION NAME) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)) (T (EMIT-LOAD-EXTERNALIZED-OBJECT NAME) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSymbolFunctionOrDie" NIL +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)))) ((AND (CONSP NAME) (EQ (%CAR NAME) (QUOTE SETF))) (DFORMAT T "p2-function case 2~%") (COND ((SETF LOCAL-FUNCTION (FIND-LOCAL-FUNCTION NAME)) (DFORMAT T "p2-function 1~%") (EMIT-LOAD-LOCAL-FUNCTION LOCAL-FUNCTION)) ((AND (MEMBER NAME *FUNCTIONS-DEFINED-IN-CURRENT-FILE* :TEST (FUNCTION EQUAL)) (NOT (NOTINLINE-P NAME))) (EMIT-GETSTATIC *THIS-CLASS* (DECLARE-SETF-FUNCTION NAME) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)) ((AND (NULL *FILE-COMPILATION*) (FBOUNDP NAME) (FDEFINITION NAME)) (EMIT-LOAD-EXTERNALIZED-OBJECT (FDEFINITION NAME)) (EMIT-MOVE-FROM-STACK TARGET)) (T (EMIT-LOAD-EXTERNALIZED-OBJECT (CADR NAME)) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ "getSymbolSetfFunctionOrDie" NIL +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)))) ((LOCAL-FUNCTION-P NAME) (DFORMAT T "p2-function case 3~%") (P2-LAMBDA NAME TARGET)) (T (COMPILER-UNSUPPORTED "p2-function: unsupported case: ~S" FORM)))))
     [java] ; (DEFKNOWN P2-ASH (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-ASH (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (LOW2 (AND (FIXNUM-TYPE-P TYPE2) (INTEGER-TYPE-LOW TYPE2))) (HIGH2 (AND (FIXNUM-TYPE-P TYPE2) (INTEGER-TYPE-HIGH TYPE2))) (CONSTANT-SHIFT (FIXNUM-CONSTANT-VALUE TYPE2)) (RESULT-TYPE (DERIVE-COMPILER-TYPE FORM))) (COND ((AND (INTEGERP ARG1) (INTEGERP ARG2)) (COMPILE-CONSTANT (ASH ARG1 ARG2) TARGET REPRESENTATION)) ((AND CONSTANT-SHIFT (<= -31 CONSTANT-SHIFT 31) (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P RESULT-TYPE)) (COMPILE-FORM ARG1 (QUOTE STACK) :INT) (COND ((PLUSP CONSTANT-SHIFT) (COMPILE-FORM ARG2 (QUOTE STACK) :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE ISHL))) ((MINUSP CONSTANT-SHIFT) (COND ((FIXNUMP ARG2) (EMIT-PUSH-CONSTANT-INT (- ARG2))) (T (COMPILE-FORM ARG2 (QUOTE STACK) :INT) (EMIT (QUOTE INEG)))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE ISHR))) ((ZEROP CONSTANT-SHIFT) (COMPILE-FORM ARG2 NIL NIL))) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((AND CONSTANT-SHIFT (<= -63 CONSTANT-SHIFT 63) (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P RESULT-TYPE)) (COMPILE-FORM ARG1 (QUOTE STACK) :LONG) (COND ((PLUSP CONSTANT-SHIFT) (COMPILE-FORM ARG2 (QUOTE STACK) :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE LSHL))) ((MINUSP CONSTANT-SHIFT) (COND ((FIXNUMP ARG2) (EMIT-PUSH-CONSTANT-INT (- ARG2))) (T (COMPILE-FORM ARG2 (QUOTE STACK) :INT) (EMIT (QUOTE INEG)))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE LSHR))) ((ZEROP CONSTANT-SHIFT) (COMPILE-FORM ARG2 NIL NIL))) (CONVERT-REPRESENTATION :LONG REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((AND (FIXNUM-TYPE-P TYPE1) LOW2 HIGH2 (<= -31 LOW2 HIGH2 0)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) :INT ARG2 (QUOTE STACK) :INT) (EMIT (QUOTE INEG)) (EMIT (QUOTE ISHR)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (COND ((AND LOW2 HIGH2 (<= 0 LOW2 HIGH2 63) (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P RESULT-TYPE)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) :LONG ARG2 (QUOTE STACK) :INT) (EMIT (QUOTE LSHL)) (CONVERT-REPRESENTATION :LONG REPRESENTATION)) ((AND LOW2 HIGH2 (<= -63 LOW2 HIGH2 0) (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P RESULT-TYPE)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) :LONG ARG2 (QUOTE STACK) :INT) (EMIT (QUOTE INEG)) (EMIT (QUOTE LSHR)) (CONVERT-REPRESENTATION :LONG REPRESENTATION)) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL ARG2 (QUOTE STACK) :INT) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "ash" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-LOGAND (T T T) T)
     [java] ; (DEFUN P2-LOGAND (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (2 (LET* ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (RESULT-TYPE (DERIVE-COMPILER-TYPE FORM))) (COND ((AND (INTEGERP ARG1) (INTEGERP ARG2)) (COMPILE-CONSTANT (LOGAND ARG1 ARG2) TARGET REPRESENTATION)) ((AND (INTEGER-TYPE-P TYPE1) (EQL ARG2 0)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 NIL NIL) (COMPILE-CONSTANT 0 TARGET REPRESENTATION)) ((EQL (FIXNUM-CONSTANT-VALUE TYPE1) -1) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 NIL NIL ARG2 TARGET REPRESENTATION)) ((EQL (FIXNUM-CONSTANT-VALUE TYPE2) -1) (LET ((TARGET-REGISTER (IF (OR (NOT (EQ TARGET (QUOTE STACK))) (NOT (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARG2)))) TARGET (ALLOCATE-REGISTER REPRESENTATION)))) (COMPILE-FORM ARG1 TARGET-REGISTER REPRESENTATION) (COMPILE-FORM ARG2 NIL NIL) (WHEN (AND (EQ TARGET (QUOTE STACK)) (NOT (EQ TARGET-REGISTER (QUOTE STACK)))) (EMIT-PUSH-REGISTER TARGET-REGISTER)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE IAND)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((OR (AND (FIXNUM-TYPE-P TYPE1) (MEMBER TYPE2 (QUOTE (:LONG :INT))) (COMPILER-SUBTYPEP TYPE1 (QUOTE UNSIGNED-BYTE))) (AND (FIXNUM-TYPE-P TYPE2) (MEMBER TYPE1 (QUOTE (:LONG :INT))) (COMPILER-SUBTYPEP TYPE2 (QUOTE UNSIGNED-BYTE)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE IAND)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((AND (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :LONG) (COMPILE-OPERAND ARG2 :LONG) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE LAND)) (CONVERT-REPRESENTATION :LONG REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((OR (AND (JAVA-LONG-TYPE-P TYPE1) (MEMBER TYPE2 (QUOTE (:LONG :INT))) (COMPILER-SUBTYPEP TYPE1 (QUOTE UNSIGNED-BYTE))) (AND (JAVA-LONG-TYPE-P TYPE2) (MEMBER TYPE1 (QUOTE (:LONG :INT))) (COMPILER-SUBTYPEP TYPE2 (QUOTE UNSIGNED-BYTE)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :LONG) (COMPILE-OPERAND ARG2 :LONG) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE LAND)) (CONVERT-REPRESENTATION :LONG REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGAND" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGAND" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGAND" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-LOGIOR (T T T) T)
     [java] ; (DEFUN P2-LOGIOR (FORM TARGET REPRESENTATION) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 (COMPILE-CONSTANT 0 TARGET REPRESENTATION)) (1 (LET ((ARG (%CAR ARGS))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG TARGET REPRESENTATION))) (2 (LET* ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) TYPE1 TYPE2 RESULT-TYPE) (WHEN (AND (INTEGERP ARG1) (INTEGERP ARG2)) (COMPILE-CONSTANT (LOGIOR ARG1 ARG2) TARGET REPRESENTATION) (RETURN-FROM P2-LOGIOR T)) (WHEN (INTEGERP ARG1) (SETF ARG1 (%CADR ARGS) ARG2 (%CAR ARGS))) (SETF TYPE1 (DERIVE-COMPILER-TYPE ARG1) TYPE2 (DERIVE-COMPILER-TYPE ARG2) RESULT-TYPE (DERIVE-COMPILER-TYPE FORM)) (COND ((AND (FIXNUM-CONSTANT-VALUE TYPE1) (FIXNUM-CONSTANT-VALUE TYPE2)) (COMPILE-CONSTANT (LOGIOR (FIXNUM-CONSTANT-VALUE TYPE1) (FIXNUM-CONSTANT-VALUE TYPE2)) TARGET REPRESENTATION)) ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE IOR)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((AND (EQL (FIXNUM-CONSTANT-VALUE TYPE1) 0) (< *SAFETY* 3)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 NIL NIL ARG2 TARGET REPRESENTATION)) ((AND (EQL (FIXNUM-CONSTANT-VALUE TYPE2) 0) (< *SAFETY* 3)) (LET ((TARGET-REGISTER (IF (OR (NOT (EQ TARGET (QUOTE STACK))) (NOT (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARG2)))) TARGET (ALLOCATE-REGISTER REPRESENTATION)))) (COMPILE-FORM ARG1 TARGET-REGISTER REPRESENTATION) (COMPILE-FORM ARG2 NIL NIL) (WHEN (AND (EQ TARGET (QUOTE STACK)) (NOT (EQ TARGET-REGISTER (QUOTE STACK)))) (EMIT-PUSH-REGISTER TARGET-REGISTER)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) ((OR (EQ REPRESENTATION :LONG) (AND (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P TYPE2))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :LONG) (COMPILE-OPERAND ARG2 :LONG) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE LOR)) (CONVERT-REPRESENTATION :LONG REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGIOR" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGIOR" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGIOR" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))) (T (LET ((NEW-FORM (SYSTEM::BACKQ-LIST (QUOTE LOGIOR) (CAR ARGS) (SYSTEM::BACKQ-CONS (QUOTE LOGIOR) (CDR ARGS))))) (P2-LOGIOR NEW-FORM TARGET REPRESENTATION))))))
     [java] ; (DEFKNOWN P2-LOGXOR (T T T) T)
     [java] ; (DEFUN P2-LOGXOR (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (LEN (LENGTH ARGS))) (CASE LEN (0 (COMPILE-CONSTANT 0 TARGET REPRESENTATION)) (1 (LET ((ARG (%CAR ARGS))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG TARGET REPRESENTATION))) (2 (LET* ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) TYPE1 TYPE2 RESULT-TYPE) (WHEN (AND (INTEGERP ARG1) (INTEGERP ARG2)) (COMPILE-CONSTANT (LOGXOR ARG1 ARG2) TARGET REPRESENTATION) (RETURN-FROM P2-LOGXOR)) (WHEN (INTEGERP ARG1) (SETF ARG1 (%CADR ARGS) ARG2 (%CAR ARGS))) (SETF TYPE1 (DERIVE-COMPILER-TYPE ARG1) TYPE2 (DERIVE-COMPILER-TYPE ARG2) RESULT-TYPE (DERIVE-COMPILER-TYPE FORM)) (COND ((OR (EQ REPRESENTATION :INT) (AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE IXOR)) (CONVERT-REPRESENTATION :INT REPRESENTATION)) ((AND (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :LONG) (COMPILE-OPERAND ARG2 :LONG) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE LXOR)) (CONVERT-REPRESENTATION :LONG REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGXOR" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGXOR" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (LET ((NEW-FORM (SYSTEM::BACKQ-LIST (QUOTE LOGXOR) (CAR ARGS) (SYSTEM::BACKQ-CONS (QUOTE LOGXOR) (CDR ARGS))))) (P2-LOGXOR NEW-FORM TARGET REPRESENTATION))))))
     [java] ; (DEFKNOWN P2-LOGNOT (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-LOGNOT (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (COND ((AND (FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE FORM))) (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :INT) (EMIT (QUOTE ICONST_M1)) (EMIT (QUOTE IXOR)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LOGNOT" NIL +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-%LDB (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-%LDB (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 3)) (LET* ((ARGS (CDR FORM)) (SIZE-ARG (%CAR ARGS)) (POSITION-ARG (%CADR ARGS)) (ARG3 (%CADDR ARGS)) (SIZE-TYPE (DERIVE-COMPILER-TYPE SIZE-ARG)) (POSITION-TYPE (DERIVE-COMPILER-TYPE POSITION-ARG)) (SIZE (FIXNUM-CONSTANT-VALUE SIZE-TYPE)) (POSITION (FIXNUM-CONSTANT-VALUE POSITION-TYPE))) (COND ((EQL SIZE 0) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES SIZE-ARG NIL NIL POSITION-ARG NIL NIL ARG3 NIL NIL) (COMPILE-CONSTANT 0 TARGET REPRESENTATION)) ((AND SIZE POSITION) (COND ((<= (+ POSITION SIZE) 31) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES SIZE-ARG NIL NIL POSITION-ARG NIL NIL ARG3 (QUOTE STACK) :INT) (UNLESS (ZEROP POSITION) (EMIT-PUSH-CONSTANT-INT POSITION) (EMIT (QUOTE ISHR))) (EMIT-PUSH-CONSTANT-INT (1- (EXPT 2 SIZE))) (EMIT (QUOTE IAND)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((<= (+ POSITION SIZE) 63) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES SIZE-ARG NIL NIL POSITION-ARG NIL NIL ARG3 (QUOTE STACK) :LONG) (UNLESS (ZEROP POSITION) (EMIT-PUSH-CONSTANT-INT POSITION) (EMIT (QUOTE LSHR))) (COND ((<= SIZE 31) (EMIT (QUOTE L2I)) (EMIT-PUSH-CONSTANT-INT (1- (EXPT 2 SIZE))) (EMIT (QUOTE IAND)) (CONVERT-REPRESENTATION :INT REPRESENTATION)) (T (EMIT-PUSH-CONSTANT-LONG (1- (EXPT 2 SIZE))) (EMIT (QUOTE LAND)) (CONVERT-REPRESENTATION :LONG REPRESENTATION))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG3 (QUOTE STACK) NIL) (EMIT-PUSH-CONSTANT-INT SIZE) (EMIT-PUSH-CONSTANT-INT POSITION) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LDB" (QUOTE (:INT :INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))) ((AND (FIXNUM-TYPE-P SIZE-TYPE) (FIXNUM-TYPE-P POSITION-TYPE)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND SIZE-ARG :INT) (COMPILE-OPERAND POSITION-ARG :INT) (COMPILE-OPERAND ARG3 NIL) (MAYBE-EMIT-CLEAR-VALUES SIZE-ARG POSITION-ARG ARG3))) (EMIT (QUOTE DUP_X2)) (EMIT (QUOTE POP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LDB" (QUOTE (:INT :INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-MOD (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-MOD (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (EQ REPRESENTATION :INT) (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESTATIC +LISP+ "mod" (QUOTE (:INT :INT)) :INT) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "MOD" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "MOD" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-ZEROP (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-ZEROP (FORM TARGET REPRESENTATION) ((AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (CHECK-ARG-COUNT FORM 1)) (LET* ((ARG (CADR FORM)) (TYPE (DERIVE-COMPILER-TYPE ARG))) (COND ((FIXNUM-TYPE-P TYPE) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :INT) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IFNE) LABEL1) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_1))) ((NIL) (EMIT-PUSH-T))) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_0))) ((NIL) (EMIT-PUSH-NIL))) (LABEL LABEL2) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) ((JAVA-LONG-TYPE-P TYPE) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :LONG) (EMIT (QUOTE LCONST_0)) (EMIT (QUOTE LCMP)) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IFNE) LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (LABEL LABEL2) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD "ZEROP" TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-FIND-CLASS (T T T) T)
     [java] ; (DEFUN P2-FIND-CLASS (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (ARG-COUNT (LENGTH ARGS)) (ARG1 (FIRST ARGS)) CLASS) (WHEN (AND (<= 1 ARG-COUNT 2) (CONSP ARG1) (= (LENGTH ARG1) 2) (EQ (FIRST ARG1) (QUOTE QUOTE)) (SYMBOLP (SECOND ARG1)) (EQ (SYMBOL-PACKAGE (SECOND ARG1)) (FIND-PACKAGE "CL")) (SETF CLASS (FIND-CLASS (SECOND ARG1) NIL))) (COMPILE-CONSTANT CLASS TARGET REPRESENTATION) (RETURN-FROM P2-FIND-CLASS)) (CASE ARG-COUNT (1 (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-PUSH-CONSTANT-INT 1) (EMIT-INVOKESTATIC +LISP-CLASS+ "findClass" (LIST +LISP-OBJECT+ :BOOLEAN) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (2 (LET ((ARG2 (SECOND ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :BOOLEAN) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKESTATIC +LISP-CLASS+ "findClass" (LIST +LISP-OBJECT+ :BOOLEAN) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-VECTOR-PUSH-EXTEND (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (ARG-COUNT (LENGTH ARGS)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS))) (CASE ARG-COUNT (2 (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE SWAP)) (COND (TARGET (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "VECTOR_PUSH_EXTEND" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "vectorPushExtend" (LISP-OBJECT-ARG-TYPES 1) NIL)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-STD-SLOT-VALUE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-STD-SLOT-VALUE (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "SLOT_VALUE" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFKNOWN P2-SET-STD-SLOT-VALUE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-SET-STD-SLOT-VALUE (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 3)) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS)) (*REGISTER* *REGISTER*) (VALUE-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (COMPILE-OPERAND ARG3 NIL))) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (ASTORE VALUE-REGISTER)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "setSlotValue" (LISP-OBJECT-ARG-TYPES 2) NIL) (WHEN VALUE-REGISTER (ALOAD VALUE-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-STREAM-ELEMENT-TYPE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-STREAM-ELEMENT-TYPE (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (%CADR FORM))) (COND ((EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE STREAM)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-STREAM+) (EMIT-INVOKEVIRTUAL +LISP-STREAM+ "getStreamElementType" NIL +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-WRITE-8-BITS (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-WRITE-8-BITS (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (COMPILER-SUBTYPEP TYPE1 (QUOTE (UNSIGNED-BYTE 8))) (EQ TYPE2 (QUOTE STREAM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL +LISP-STREAM+))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-STREAM+ "_writeByte" (QUOTE (:INT)) NIL) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET))) ((FIXNUM-TYPE-P TYPE1) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT-INVOKESTATIC +LISP+ "writeByte" (LIST :INT +LISP-OBJECT+) NIL) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-READ-LINE (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (LEN (LENGTH ARGS))) (CASE LEN (1 (LET* ((ARG1 (%CAR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1))) (COND ((COMPILER-SUBTYPEP TYPE1 (QUOTE STREAM)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-STREAM+) (EMIT-PUSH-CONSTANT-INT 1) (EMIT-PUSH-NIL) (EMIT-INVOKEVIRTUAL +LISP-STREAM+ "readLine" (LIST :BOOLEAN +LISP-OBJECT+) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))) (2 (LET* ((ARG1 (%CAR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (ARG2 (%CADR ARGS))) (COND ((AND (COMPILER-SUBTYPEP TYPE1 (QUOTE STREAM)) (NULL ARG2)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-STREAM+) (EMIT-PUSH-CONSTANT-INT 0) (EMIT-PUSH-NIL) (EMIT-INVOKEVIRTUAL +LISP-STREAM+ "readLine" (LIST :BOOLEAN +LISP-OBJECT+) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFMACRO DEFINE-DERIVE-TYPE-HANDLER (OP LAMBDA-LIST &BODY BODY) (LET ((NAME (INTERN (CONCATENATE (QUOTE STRING) "DERIVE-TYPE-" (SYMBOL-NAME OP))))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE DEFKNOWN) NAME (QUOTE ((T) T))) (SYSTEM::BACKQ-LIST* (QUOTE DEFUN) NAME LAMBDA-LIST BODY) (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST* (QUOTE GET) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) OP) (QUOTE ((QUOTE DERIVE-TYPE-HANDLER)))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME)))))
     [java] ; (DEFINE-DERIVE-TYPE-HANDLER AREF (FORM) (LET* ((ARGS (CDR FORM)) (ARRAY-ARG (CAR ARGS)) (ARRAY-TYPE (NORMALIZE-TYPE (DERIVE-TYPE ARRAY-ARG))) (RESULT-TYPE T)) (COND ((AND (CONSP ARRAY-TYPE) (MEMQ (%CAR ARRAY-TYPE) (QUOTE (ARRAY SIMPLE-ARRAY VECTOR)))) (LET ((ELEMENT-TYPE (SECOND ARRAY-TYPE))) (UNLESS (EQ ELEMENT-TYPE (QUOTE *)) (SETF RESULT-TYPE ELEMENT-TYPE)))) ((AND (CONSP ARRAY-TYPE) (MEMQ (%CAR ARRAY-TYPE) (QUOTE (STRING SIMPLE-STRING)))) (SETF RESULT-TYPE (QUOTE CHARACTER)))) RESULT-TYPE))
     [java] ; (DEFINE-DERIVE-TYPE-HANDLER FIXNUMP (FORM) (IF (FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE (CADR FORM))) +TRUE-TYPE+ (QUOTE BOOLEAN)))
     [java] ; (DEFINE-DERIVE-TYPE-HANDLER SETQ (FORM) (IF (= (LENGTH FORM) 3) (DERIVE-COMPILER-TYPE (THIRD FORM)) T))
     [java] ; (DEFKNOWN DERIVE-TYPE-LOGIOR/LOGXOR (T) T)
     [java] ; (DEFUN DERIVE-TYPE-LOGIOR/LOGXOR (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM)) (RESULT-TYPE +INTEGER-TYPE+)) (CASE (LENGTH ARGS) (0 (SETF RESULT-TYPE (MAKE-INTEGER-TYPE (QUOTE (INTEGER 0 0))))) (1 (SETF RESULT-TYPE (DERIVE-COMPILER-TYPE (CAR ARGS)))) (2 (LET ((TYPE1 (DERIVE-COMPILER-TYPE (%CAR ARGS))) (TYPE2 (DERIVE-COMPILER-TYPE (%CADR ARGS)))) (COND ((AND (COMPILER-SUBTYPEP TYPE1 (QUOTE UNSIGNED-BYTE)) (COMPILER-SUBTYPEP TYPE2 (QUOTE UNSIGNED-BYTE))) (LET ((HIGH1 (INTEGER-TYPE-HIGH TYPE1)) (HIGH2 (INTEGER-TYPE-HIGH TYPE2))) (COND ((AND HIGH1 HIGH2) (LET ((LENGTH (INTEGER-LENGTH (MAX HIGH1 HIGH2)))) (SETF RESULT-TYPE (MAKE-COMPILER-TYPE (LIST (QUOTE INTEGER) 0 (1- (EXPT 2 LENGTH))))))) (T (SETF RESULT-TYPE (MAKE-COMPILER-TYPE (QUOTE UNSIGNED-BYTE))))))) ((AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (SETF RESULT-TYPE (MAKE-COMPILER-TYPE (QUOTE FIXNUM))))))) (T (SETF RESULT-TYPE (DERIVE-TYPE-LOGIOR/LOGXOR (SYSTEM::BACKQ-LIST OP (CAR ARGS) (SYSTEM::BACKQ-CONS OP (CDR ARGS))))))) RESULT-TYPE))
     [java] ; (DEFKNOWN DERIVE-TYPE-LOGAND (T) T)
     [java] ; (DEFUN DERIVE-TYPE-LOGAND (FORM) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 (MAKE-INTEGER-TYPE (QUOTE (INTEGER -1 -1)))) (1 (LET ((TYPE (DERIVE-COMPILER-TYPE (%CAR ARGS)))) (IF (INTEGER-TYPE-P TYPE) TYPE (MAKE-INTEGER-TYPE (QUOTE INTEGER))))) (2 (DFORMAT T "derive-type-logand 2-arg case~%") (LET* ((TYPE1 (DERIVE-COMPILER-TYPE (%CAR ARGS))) (TYPE2 (DERIVE-COMPILER-TYPE (%CADR ARGS))) LOW1 HIGH1 LOW2 HIGH2 RESULT-LOW RESULT-HIGH RESULT-TYPE) (WHEN (INTEGER-TYPE-P TYPE1) (SETF LOW1 (INTEGER-TYPE-LOW TYPE1) HIGH1 (INTEGER-TYPE-HIGH TYPE1))) (WHEN (INTEGER-TYPE-P TYPE2) (SETF LOW2 (INTEGER-TYPE-LOW TYPE2) HIGH2 (INTEGER-TYPE-HIGH TYPE2))) (COND ((AND LOW1 LOW2 (>= LOW1 0) (>= LOW2 0)) (DFORMAT T "both args are non-negative~%") (SETF RESULT-LOW 0) (SETF RESULT-HIGH (IF (AND HIGH1 HIGH2) (MIN HIGH1 HIGH2) (OR HIGH1 HIGH2)))) ((AND LOW1 (>= LOW1 0)) (DFORMAT T "arg1 is non-negative~%") (SETF RESULT-LOW 0) (SETF RESULT-HIGH HIGH1)) ((AND LOW2 (>= LOW2 0)) (DFORMAT T "arg2 is non-negative~%") (SETF RESULT-LOW 0) (SETF RESULT-HIGH HIGH2))) (DFORMAT T "result-low = ~S~%" RESULT-LOW) (DFORMAT T "result-high = ~S~%" RESULT-HIGH) (SETF RESULT-TYPE (MAKE-INTEGER-TYPE (LIST (QUOTE INTEGER) RESULT-LOW RESULT-HIGH))) (DFORMAT T "result-type = ~S~%" RESULT-TYPE) RESULT-TYPE)) (T (MAKE-INTEGER-TYPE (QUOTE INTEGER))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) DERIVE-TYPE-LOGNOT))
     [java] ; (DEFUN DERIVE-TYPE-LOGNOT (FORM) (LET (ARG-TYPE) (IF (AND (= (LENGTH FORM) 2) (FIXNUM-TYPE-P (SETF ARG-TYPE (DERIVE-COMPILER-TYPE (%CADR FORM))))) (LET* ((ARG-LOW (INTEGER-TYPE-LOW ARG-TYPE)) (ARG-HIGH (INTEGER-TYPE-HIGH ARG-TYPE)) (RESULT-LOW (IF ARG-HIGH (LOGNOT ARG-HIGH) NIL)) (RESULT-HIGH (IF ARG-LOW (LOGNOT ARG-LOW) NIL))) (MAKE-INTEGER-TYPE (LIST (QUOTE INTEGER) RESULT-LOW RESULT-HIGH))) +INTEGER-TYPE+)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) DERIVE-TYPE-MOD))
     [java] ; (DEFUN DERIVE-TYPE-MOD (FORM) (IF (= (LENGTH FORM) 3) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (INTEGER-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (QUOTE FIXNUM)) (T T))) T))
     [java] ; (DEFKNOWN DERIVE-TYPE-COERCE (T) T)
     [java] ; (DEFUN DERIVE-TYPE-COERCE (FORM) (IF (= (LENGTH FORM) 3) (LET ((TYPE-FORM (%CADDR FORM))) (IF (AND (CONSP TYPE-FORM) (EQ (%CAR TYPE-FORM) (QUOTE QUOTE)) (= (LENGTH TYPE-FORM) 2)) (%CADR TYPE-FORM) T)) T))
     [java] ; (DEFKNOWN DERIVE-TYPE-COPY-SEQ (T) T)
     [java] ; (DEFUN DERIVE-TYPE-COPY-SEQ (FORM) (IF (= (LENGTH FORM) 2) (LET ((TYPE (DERIVE-COMPILER-TYPE (SECOND FORM)))) (CASE TYPE ((STRING SIMPLE-STRING) (MAKE-COMPILER-TYPE TYPE)) (T T))) T))
     [java] ; (DEFKNOWN DERIVE-TYPE-INTEGER-LENGTH (T) T)
     [java] ; (DEFUN DERIVE-TYPE-INTEGER-LENGTH (FORM) (WHEN (= (LENGTH FORM) 2) (LET ((TYPE (MAKE-INTEGER-TYPE (DERIVE-TYPE (%CADR FORM))))) (WHEN TYPE (LET ((LOW (INTEGER-TYPE-LOW TYPE)) (HIGH (INTEGER-TYPE-HIGH TYPE))) (WHEN (AND (INTEGERP LOW) (INTEGERP HIGH)) (RETURN-FROM DERIVE-TYPE-INTEGER-LENGTH (LIST (QUOTE INTEGER) 0 (MAX (INTEGER-LENGTH LOW) (INTEGER-LENGTH HIGH))))))))) (LIST (QUOTE INTEGER) 0 (QUOTE *)))
     [java] ; (DEFKNOWN DERIVE-TYPE-%LDB (T) T)
     [java] ; (DEFUN DERIVE-TYPE-%LDB (FORM) (WHEN (= (LENGTH FORM) 4) (LET* ((ARGS (CDR FORM)) (SIZE-ARG (FIRST ARGS))) (WHEN (FIXNUMP SIZE-ARG) (RETURN-FROM DERIVE-TYPE-%LDB (LIST (QUOTE INTEGER) 0 (1- (EXPT 2 SIZE-ARG))))))) (LIST (QUOTE INTEGER) 0 (QUOTE *)))
     [java] ; (DEFMACRO DEFINE-INT-BOUNDS-DERIVATION (NAME (LOW1 HIGH1 LOW2 HIGH2) &BODY BODY) "Associates an integer-bounds calculation function with a numeric
     [java] operator `name', assuming 2 integer arguments." (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST* (QUOTE GET) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE INT-BOUNDS)))) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST LOW1 HIGH1 LOW2 HIGH2) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) LOW1 HIGH1 LOW2 HIGH2)) BODY))))
     [java] ; (DEFUN DERIVE-INTEGER-TYPE (OP TYPE1 TYPE2) "Derives the composed integer type of operation `op' given integer
     [java] types `type1' and `type2'." (LET ((LOW1 (INTEGER-TYPE-LOW TYPE1)) (HIGH1 (INTEGER-TYPE-HIGH TYPE1)) (LOW2 (INTEGER-TYPE-LOW TYPE2)) (HIGH2 (INTEGER-TYPE-HIGH TYPE2)) (OP-FN (GET OP (QUOTE INT-BOUNDS)))) (ASSERT OP-FN) (MULTIPLE-VALUE-BIND (LOW HIGH NON-INT-P) (FUNCALL OP-FN LOW1 HIGH1 LOW2 HIGH2) (IF NON-INT-P NON-INT-P (%MAKE-INTEGER-TYPE LOW HIGH)))))
     [java] ; (DEFVAR NUMERIC-OP-TYPE-DERIVATION (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE (+ - *)) (SYSTEM::BACKQ-LIST (QUOTE INTEGER) (QUOTE INTEGER) (FUNCTION DERIVE-INTEGER-TYPE)) (QUOTE ((INTEGER SINGLE-FLOAT SINGLE-FLOAT) (INTEGER DOUBLE-FLOAT DOUBLE-FLOAT) (SINGLE-FLOAT INTEGER SINGLE-FLOAT) (SINGLE-FLOAT DOUBLE-FLOAT DOUBLE-FLOAT) (DOUBLE-FLOAT INTEGER DOUBLE-FLOAT) (DOUBLE-FLOAT SINGLE-FLOAT DOUBLE-FLOAT)))) (QUOTE ((/) (INTEGER SINGLE-FLOAT SINGLE-FLOAT) (INTEGER DOUBLE-FLOAT DOUBLE-FLOAT) (SINGLE-FLOAT INTEGER SINGLE-FLOAT) (SINGLE-FLOAT DOUBLE-FLOAT DOUBLE-FLOAT) (DOUBLE-FLOAT INTEGER DOUBLE-FLOAT) (DOUBLE-FLOAT SINGLE-FLOAT DOUBLE-FLOAT))) (SYSTEM::BACKQ-LIST (QUOTE (ASH)) (SYSTEM::BACKQ-LIST (QUOTE INTEGER) (QUOTE INTEGER) (FUNCTION DERIVE-INTEGER-TYPE))) (SYSTEM::BACKQ-LIST* (QUOTE (MIN MAX)) (SYSTEM::BACKQ-LIST (QUOTE INTEGER) (QUOTE INTEGER) (FUNCTION DERIVE-INTEGER-TYPE)) (QUOTE ((INTEGER SINGLE-FLOAT SINGLE-FLOAT) (INTEGER DOUBLE-FLOAT DOUBLE-FLOAT) (SINGLE-FLOAT DOUBLE-FLOAT DOUBLE-FLOAT) (DOUBLE-FLOAT SINGLE-FLOAT DOUBLE-FLOAT))))) "Table used to derive the return type of a numeric operation,
     [java] based on the types of the arguments.")
     [java] ; (DEFUN DERIVE-TYPE-NUMERIC-OP (OP &REST TYPES) "Returns the result type of the numeric operation `op' and the types
     [java] of the operation arguments given in `types'." (LET ((TYPES-TABLE (CDR (ASSOC OP NUMERIC-OP-TYPE-DERIVATION :TEST (FUNCTION MEMBER))))) (ASSERT TYPES-TABLE) (FLET ((MATCH (TYPE1 TYPE2) (DO* ((REMAINING-TYPES TYPES-TABLE (CDR REMAINING-TYPES))) ((ENDP REMAINING-TYPES) T) (DESTRUCTURING-BIND (T1 T2 RESULT-TYPE) (CAR REMAINING-TYPES) (WHEN (AND (OR (SUBTYPEP TYPE1 T1) (COMPILER-SUBTYPEP TYPE1 T1)) (OR (SUBTYPEP TYPE2 T2) (COMPILER-SUBTYPEP TYPE2 T2))) (RETURN-FROM MATCH (IF (FUNCTIONP RESULT-TYPE) (FUNCALL RESULT-TYPE OP TYPE1 TYPE2) RESULT-TYPE))))))) (LET ((TYPE1 (CAR TYPES)) (TYPE2 (CADR TYPES))) (WHEN (AND (EQ TYPE1 TYPE2) (MEMQ TYPE1 (QUOTE (SINGLE-FLOAT DOUBLE-FLOAT)))) (RETURN-FROM DERIVE-TYPE-NUMERIC-OP TYPE1)) (MATCH TYPE1 TYPE2)))))
     [java] ; (DEFVAR ZERO-INTEGER-TYPE (%MAKE-INTEGER-TYPE 0 0) "Integer type representing the 0 (zero)
     [java] value for use with derive-type-minus and derive-type-plus.")
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION - (LOW1 HIGH1 LOW2 HIGH2) (VALUES (WHEN (AND LOW1 HIGH2) (IF LOW2 (MIN (- LOW1 LOW2) (- LOW1 HIGH2)) (- LOW1 HIGH2))) (WHEN (AND HIGH1 LOW2) (IF HIGH2 (MAX (- HIGH1 LOW2) (- HIGH1 HIGH2)) (- HIGH1 LOW2)))))
     [java] ; (DEFUN DERIVE-COMPILER-TYPES (ARGS OP) (FLET ((COMBINE (X Y) (DERIVE-TYPE-NUMERIC-OP OP X Y))) (REDUCE (FUNCTION COMBINE) (CDR ARGS) :KEY (FUNCTION DERIVE-COMPILER-TYPE) :INITIAL-VALUE (DERIVE-COMPILER-TYPE (CAR ARGS)))))
     [java] ; (DEFKNOWN DERIVE-TYPE-MINUS (T) T)
     [java] ; (DEFUN DERIVE-TYPE-MINUS (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (CASE (LENGTH ARGS) (1 (DERIVE-TYPE-NUMERIC-OP (CAR FORM) ZERO-INTEGER-TYPE (DERIVE-COMPILER-TYPE (%CAR ARGS)))) (2 (DERIVE-COMPILER-TYPES ARGS OP)))))
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION + (LOW1 HIGH1 LOW2 HIGH2) (VALUES (AND LOW1 LOW2 (+ LOW1 LOW2)) (AND HIGH1 HIGH2 (+ HIGH1 HIGH2))))
     [java] ; (DEFKNOWN DERIVE-TYPE-PLUS (T) T)
     [java] ; (DEFUN DERIVE-TYPE-PLUS (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (IF (NULL ARGS) ZERO-INTEGER-TYPE (DERIVE-COMPILER-TYPES ARGS OP))))
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION * (LOW1 HIGH1 LOW2 HIGH2) (COND ((OR (NULL LOW1) (NULL LOW2)) (VALUES NIL NIL)) ((OR (NULL HIGH1) (NULL HIGH2)) (VALUES (IF (OR (MINUSP LOW1) (MINUSP LOW2)) (- (* (ABS LOW1) (ABS LOW2))) (* LOW1 LOW2)) NIL)) ((OR (MINUSP LOW1) (MINUSP LOW2)) (LET ((MAX (* (MAX (ABS LOW1) (ABS HIGH1)) (MAX (ABS LOW2) (ABS HIGH2))))) (VALUES (- MAX) MAX))) (T (VALUES (* LOW1 LOW2) (* HIGH1 HIGH2)))))
     [java] ; (DEFVAR ONE-INTEGER-TYPE (%MAKE-INTEGER-TYPE 1 1) "Integer type representing the value 1 (one)
     [java] for use with derive-type-times.")
     [java] ; (DEFUN DERIVE-TYPE-TIMES (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (IF (NULL ARGS) ONE-INTEGER-TYPE (DERIVE-COMPILER-TYPES ARGS OP))))
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION MAX (LOW1 HIGH1 LOW2 HIGH2) (VALUES (OR (WHEN (AND LOW1 LOW2) (MAX LOW1 LOW2)) LOW1 LOW2) (WHEN (AND HIGH1 HIGH2) (MAX HIGH1 HIGH2))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) DERIVE-TYPE-MAX))
     [java] ; (DEFUN DERIVE-TYPE-MAX (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (DERIVE-COMPILER-TYPES ARGS OP)))
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION MIN (LOW1 HIGH1 LOW2 HIGH2) (VALUES (WHEN (AND LOW1 LOW2) (MIN LOW1 LOW2)) (OR (WHEN (AND HIGH1 HIGH2) (MIN HIGH1 HIGH2)) HIGH1 HIGH2)))
     [java] ; (DEFKNOWN DERIVE-TYPE-MIN (T) T)
     [java] ; (DEFUN DERIVE-TYPE-MIN (FORM) (LET ((OP (CAR FORM)) (ARGS (CDR FORM))) (DERIVE-COMPILER-TYPES ARGS OP)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) DERIVE-TYPE-READ-CHAR))
     [java] ; (DEFUN DERIVE-TYPE-READ-CHAR (FORM) (IF (< (LENGTH FORM) 3) (QUOTE CHARACTER) T))
     [java] ; (DEFINE-INT-BOUNDS-DERIVATION ASH (LOW1 HIGH1 LOW2 HIGH2) (WHEN (AND LOW1 HIGH1 LOW2 HIGH2) (COND ((AND (>= LOW1 0) (>= HIGH1 0) (>= LOW2 0) (>= HIGH2 0)) (VALUES (ASH LOW1 LOW2) (UNLESS (<= 64 HIGH2) (ASH HIGH1 HIGH2)))) ((AND (>= LOW1 0) (>= HIGH1 0) (<= LOW2 0) (<= HIGH2 0)) (VALUES (ASH LOW1 LOW2) (ASH HIGH1 HIGH2))))))
     [java] ; (DEFKNOWN DERIVE-TYPE-ASH (T) T)
     [java] ; (DEFUN DERIVE-TYPE-ASH (FORM) (DERIVE-TYPE-NUMERIC-OP (CAR FORM) (DERIVE-COMPILER-TYPE (CADR FORM)) (DERIVE-COMPILER-TYPE (CADDR FORM))))
     [java] ; (DEFKNOWN DERIVE-TYPE (T) T)
     [java] ; (DEFUN DERIVE-TYPE (FORM) (COND ((CONSP FORM) (LET* ((OP (%CAR FORM)) (HANDLER (AND (SYMBOLP OP) (GET OP (QUOTE DERIVE-TYPE-HANDLER))))) (IF HANDLER (FUNCALL HANDLER FORM) (CASE OP (ASH (DERIVE-TYPE-ASH FORM)) ((CHAR SCHAR) (QUOTE CHARACTER)) (COERCE (DERIVE-TYPE-COERCE FORM)) (COPY-SEQ (DERIVE-TYPE-COPY-SEQ FORM)) (INTEGER-LENGTH (DERIVE-TYPE-INTEGER-LENGTH FORM)) (%LDB (DERIVE-TYPE-%LDB FORM)) (LENGTH (QUOTE (INTEGER 0 2147483646))) (LOGAND (DERIVE-TYPE-LOGAND FORM)) (LOGNOT (DERIVE-TYPE-LOGNOT FORM)) ((LOGIOR LOGXOR) (DERIVE-TYPE-LOGIOR/LOGXOR FORM)) (MOD (DERIVE-TYPE-MOD FORM)) (- (DERIVE-TYPE-MINUS FORM)) (1- (DERIVE-TYPE-MINUS (LIST (QUOTE -) (CADR FORM) 1))) (+ (DERIVE-TYPE-PLUS FORM)) (1+ (DERIVE-TYPE-PLUS (LIST (QUOTE +) (CADR FORM) 1))) (* (DERIVE-TYPE-TIMES FORM)) (MAX (DERIVE-TYPE-MAX FORM)) (MIN (DERIVE-TYPE-MIN FORM)) (READ-CHAR (DERIVE-TYPE-READ-CHAR FORM)) ((THE TRULY-THE) (SECOND FORM)) (T (LET ((TYPE (OR (FUNCTION-RESULT-TYPE OP) (FTYPE-RESULT-TYPE (PROCLAIMED-FTYPE OP))))) (IF (EQ TYPE (QUOTE *)) T TYPE))))))) ((NULL FORM) (QUOTE NULL)) ((INTEGERP FORM) (LIST (QUOTE INTEGER) FORM FORM)) ((TYPEP FORM (QUOTE SINGLE-FLOAT)) (QUOTE SINGLE-FLOAT)) ((TYPEP FORM (QUOTE DOUBLE-FLOAT)) (QUOTE DOUBLE-FLOAT)) ((CHARACTERP FORM) (QUOTE CHARACTER)) ((STRINGP FORM) (QUOTE STRING)) ((ARRAYP FORM) (TYPE-OF FORM)) ((VARIABLE-P FORM) (COND ((NEQ (VARIABLE-DECLARED-TYPE FORM) :NONE) (VARIABLE-DECLARED-TYPE FORM)) ((NEQ (VARIABLE-DERIVED-TYPE FORM) :NONE) (VARIABLE-DERIVED-TYPE FORM)) (T T))) ((VAR-REF-P FORM) (COND ((VAR-REF-CONSTANT-P FORM) (DERIVE-TYPE (VAR-REF-CONSTANT-VALUE FORM))) (T (LET ((VARIABLE (VAR-REF-VARIABLE FORM))) (COND ((VARIABLE-SPECIAL-P VARIABLE) (OR (PROCLAIMED-TYPE (VARIABLE-NAME VARIABLE)) T)) ((NEQ (VARIABLE-DECLARED-TYPE VARIABLE) :NONE) (VARIABLE-DECLARED-TYPE VARIABLE)) ((NEQ (VARIABLE-DERIVED-TYPE VARIABLE) :NONE) (VARIABLE-DERIVED-TYPE VARIABLE)) ((= 0 (VARIABLE-WRITES VARIABLE)) (DERIVE-TYPE (VARIABLE-INITFORM VARIABLE))) (T T)))))) ((SYMBOLP FORM) (COND ((KEYWORDP FORM) (QUOTE SYMBOL)) ((EQ FORM T) T) ((AND (SPECIAL-VARIABLE-P FORM) (CONSTANTP FORM)) (DERIVE-TYPE (SYMBOL-VALUE FORM))) (T (LET ((VARIABLE (FIND-VISIBLE-VARIABLE FORM))) (IF VARIABLE (DERIVE-TYPE VARIABLE) T))))) ((NODE-P FORM) (LET ((RESULT T)) RESULT)) (T T)))
     [java] ; (DEFUN DERIVE-COMPILER-TYPE (FORM) (MAKE-COMPILER-TYPE (DERIVE-TYPE FORM)))
     [java] ; (DEFKNOWN P2-DELETE (T T T) T)
     [java] ; (DEFUN P2-DELETE (FORM TARGET REPRESENTATION) (UNLESS (NOTINLINE-P (QUOTE DELETE)) (WHEN (= (LENGTH FORM) 3) (LET* ((ARGS (CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-TYPE ARG1)) (TYPE2 (DERIVE-TYPE ARG2)) (TEST (IF (MEMQ TYPE1 (QUOTE (SYMBOL NULL))) (QUOTE EQ) (QUOTE EQL)))) (COND ((SUBTYPEP TYPE2 (QUOTE VECTOR)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL +LISP-ABSTRACT-VECTOR+))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-ABSTRACT-VECTOR+ (IF (EQ TEST (QUOTE EQ)) "deleteEq" "deleteEql") (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET) (RETURN-FROM P2-DELETE T)) (T (SETF (CAR FORM) (IF (EQ TEST (QUOTE EQ)) (QUOTE DELETE-EQ) (QUOTE DELETE-EQL)))))))) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))
     [java] ; (DEFINE-INLINED-FUNCTION P2-LENGTH (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (ECASE REPRESENTATION (:INT (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "cl_length" NIL :INT)) ((:LONG :FLOAT :DOUBLE) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "cl_length" NIL :INT) (CONVERT-REPRESENTATION :INT REPRESENTATION)) (:BOOLEAN (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "cl_length" NIL :INT) (EMIT (QUOTE POP)) (EMIT (QUOTE ICONST_1))) (:CHAR (SYSTEM::%FORMAT T "p2-length: :char case~%") (AVER NIL)) ((NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "LENGTH" NIL +LISP-OBJECT+))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFUN CONS-FOR-LIST/LIST* (FORM TARGET REPRESENTATION &OPTIONAL LIST-STAR-P) (LET* ((ARGS (CDR FORM)) (LENGTH (LENGTH ARGS)) (CONS-HEADS (IF LIST-STAR-P (BUTLAST ARGS 1) ARGS))) (COND ((AND (NOT (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARGS))) (>= 4 LENGTH 1)) (DOLIST (CONS-HEAD CONS-HEADS) (EMIT-NEW +LISP-CONS+) (EMIT (QUOTE DUP)) (COMPILE-FORM CONS-HEAD (QUOTE STACK) NIL)) (IF LIST-STAR-P (COMPILE-FORM (FIRST (LAST ARGS)) (QUOTE STACK) NIL) (PROGN (EMIT-INVOKESPECIAL-INIT +LISP-CONS+ (LISP-OBJECT-ARG-TYPES 1)) (POP CONS-HEADS))) (DOLIST (CONS-HEAD CONS-HEADS) (DECLARE (IGNORE CONS-HEAD)) (EMIT-INVOKESPECIAL-INIT +LISP-CONS+ (LISP-OBJECT-ARG-TYPES 2))) (IF LIST-STAR-P (PROGN (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) ARGS) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (PROGN (UNLESS (EVERY (QUOTE SINGLE-VALUED-P) ARGS) (EMIT-CLEAR-VALUES)) (EMIT-MOVE-FROM-STACK TARGET)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-LIST (FORM TARGET REPRESENTATION) (CONS-FOR-LIST/LIST* FORM TARGET REPRESENTATION))
     [java] ; (DEFUN P2-LIST* (FORM TARGET REPRESENTATION) (CONS-FOR-LIST/LIST* FORM TARGET REPRESENTATION T))
     [java] ; (DEFINE-INLINED-FUNCTION COMPILE-NTH (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((INDEX-FORM (SECOND FORM)) (LIST-FORM (THIRD FORM)) (INDEX-TYPE (DERIVE-COMPILER-TYPE INDEX-FORM))) (UNLESS (FIXNUM-TYPE-P INDEX-TYPE) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM COMPILE-NTH)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND INDEX-FORM :INT) (COMPILE-OPERAND LIST-FORM NIL) (MAYBE-EMIT-CLEAR-VALUES INDEX-FORM LIST-FORM)) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "NTH" (QUOTE (:INT)) +LISP-OBJECT+)) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFUN P2-TIMES (FORM TARGET REPRESENTATION) (CASE (LENGTH FORM) (1 (COMPILE-CONSTANT 1 TARGET REPRESENTATION)) (2 (COMPILE-FORM (CADR FORM) TARGET REPRESENTATION)) (3 (LET* ((ARGS (CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) RESULT-TYPE RESULT-REP VALUE) (WHEN (FIXNUMP ARG1) (ROTATEF ARG1 ARG2)) (SETF RESULT-TYPE (DERIVE-COMPILER-TYPE FORM) RESULT-REP (TYPE-REPRESENTATION RESULT-TYPE)) (COND ((AND (NUMBERP ARG1) (NUMBERP ARG2)) (DFORMAT T "p2-times case 1~%") (COMPILE-CONSTANT (* ARG1 ARG2) TARGET REPRESENTATION)) ((SETF VALUE (FIXNUM-CONSTANT-VALUE RESULT-TYPE)) (DFORMAT T "p2-times case 1a~%") (COMPILE-CONSTANT VALUE TARGET REPRESENTATION)) (RESULT-REP (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 RESULT-REP) (COMPILE-OPERAND ARG2 RESULT-REP) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT (CASE RESULT-REP (:INT (QUOTE IMUL)) (:LONG (QUOTE LMUL)) (:FLOAT (QUOTE FMUL)) (:DOUBLE (QUOTE DMUL)) (T (FORMAT T "p2-times: unsupported rep case"))))) (CONVERT-REPRESENTATION RESULT-REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUMP ARG2) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-PUSH-INT ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "multiplyBy" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (DFORMAT T "p2-times case 4~%") (COMPILE-BINARY-OPERATION "multiplyBy" ARGS TARGET REPRESENTATION))))) (T (DFORMAT T "p2-times case 5~%") (P2-TIMES (SYSTEM::BACKQ-LIST* (CAR FORM) (SYSTEM::BACKQ-LIST (CAR FORM) (SECOND FORM) (THIRD FORM)) (NTHCDR 3 FORM)) TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-MIN/MAX (T T T) T)
     [java] ; (DEFUN P2-MIN/MAX (FORM TARGET REPRESENTATION) (CASE (LENGTH FORM) (1 (ERROR (QUOTE PROGRAM-ERROR) "Wrong number of arguments for ~A." (CAR FORM))) (2 (COMPILE-FORM (CADR FORM) TARGET REPRESENTATION)) (3 (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (*REGISTER* *REGISTER*)) (WHEN (NULL TARGET) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 NIL NIL ARG2 NIL NIL) (RETURN-FROM P2-MIN/MAX)) (WHEN (NOTINLINE-P OP) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-MIN/MAX)) (LET ((TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((AND (JAVA-LONG-TYPE-P TYPE1) (JAVA-LONG-TYPE-P TYPE2)) (LET* ((COMMON-REP (IF (AND (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) :INT :LONG)) (LABEL1 (GENSYM)) (LABEL2 (GENSYM)) (ARG1-REGISTER (ALLOCATE-REGISTER COMMON-REP)) (ARG2-REGISTER (ALLOCATE-REGISTER COMMON-REP))) (COMPILE-FORM ARG1 ARG1-REGISTER COMMON-REP) (COMPILE-FORM ARG2 (QUOTE STACK) COMMON-REP) (EMIT-DUP COMMON-REP) (EMIT-MOVE-FROM-STACK ARG2-REGISTER COMMON-REP) (EMIT-PUSH-REGISTER ARG1-REGISTER COMMON-REP) (EMIT-NUMERIC-COMPARISON (IF (EQ OP (QUOTE MAX)) (QUOTE <=) (QUOTE >=)) COMMON-REP LABEL1) (EMIT-PUSH-REGISTER ARG1-REGISTER COMMON-REP) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-REGISTER ARG2-REGISTER COMMON-REP) (LABEL LABEL2) (CONVERT-REPRESENTATION COMMON-REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (LET* ((ARG1-REGISTER (ALLOCATE-REGISTER NIL)) (ARG2-REGISTER (ALLOCATE-REGISTER NIL))) (COMPILE-FORM ARG1 ARG1-REGISTER NIL) (COMPILE-FORM ARG2 (QUOTE STACK) NIL) (EMIT-DUP NIL) (ASTORE ARG2-REGISTER) (EMIT-PUSH-REGISTER ARG1-REGISTER NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (IF (EQ OP (QUOTE MAX)) "isLessThanOrEqualTo" "isGreaterThanOrEqualTo") (LISP-OBJECT-ARG-TYPES 1) :BOOLEAN) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IFEQ) LABEL1) (EMIT-PUSH-REGISTER ARG1-REGISTER NIL) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-REGISTER ARG2-REGISTER NIL) (LABEL LABEL2)) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))))) (T (P2-MIN/MAX (SYSTEM::BACKQ-LIST* (CAR FORM) (SYSTEM::BACKQ-LIST (CAR FORM) (SECOND FORM) (THIRD FORM)) (NTHCDR 3 FORM)) TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-PLUS (FORM TARGET REPRESENTATION) (CASE (LENGTH FORM) (1 (COMPILE-CONSTANT 0 TARGET REPRESENTATION)) (2 (COMPILE-FORM (CADR FORM) TARGET REPRESENTATION)) (3 (LET* ((ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (RESULT-TYPE (DERIVE-COMPILER-TYPE FORM)) (RESULT-REP (TYPE-REPRESENTATION RESULT-TYPE))) (COND ((AND (NUMBERP ARG1) (NUMBERP ARG2)) (COMPILE-CONSTANT (+ ARG1 ARG2) TARGET REPRESENTATION)) ((AND (NUMBERP ARG1) (EQL ARG1 0)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 NIL NIL ARG2 (QUOTE STACK) REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((AND (NUMBERP ARG2) (EQL ARG2 0)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) REPRESENTATION ARG2 NIL NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (RESULT-REP (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 RESULT-REP) (COMPILE-OPERAND ARG2 RESULT-REP) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT (CASE RESULT-REP (:INT (QUOTE IADD)) (:LONG (QUOTE LADD)) (:FLOAT (QUOTE FADD)) (:DOUBLE (QUOTE DADD)) (T (FORMAT T "p2-plus: Unexpected result-rep ~S for form ~S." RESULT-REP FORM) (ASSERT NIL))))) (CONVERT-REPRESENTATION RESULT-REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((EQL ARG2 1) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD "incr" TARGET REPRESENTATION)) ((EQL ARG1 1) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG2 (QUOTE STACK) NIL) (EMIT-INVOKE-METHOD "incr" TARGET REPRESENTATION)) ((OR (FIXNUM-TYPE-P TYPE1) (FIXNUM-TYPE-P TYPE2)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 (WHEN (FIXNUM-TYPE-P TYPE1) :INT)) (COMPILE-OPERAND ARG2 (WHEN (NULL (FIXNUM-TYPE-P TYPE1)) :INT)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (WHEN (FIXNUM-TYPE-P TYPE1) (EMIT (QUOTE SWAP))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "add" (QUOTE (:INT)) +LISP-OBJECT+)) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-BINARY-OPERATION "add" ARGS TARGET REPRESENTATION))))) (T (LET ((NEW-FORM (SYSTEM::BACKQ-LIST* (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE +) (SECOND FORM) (THIRD FORM)) (NTHCDR 3 FORM)))) (P2-PLUS NEW-FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-MINUS (FORM TARGET REPRESENTATION) (CASE (LENGTH FORM) (1 (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)) (2 (LET* ((ARG (%CADR FORM)) (TYPE (DERIVE-COMPILER-TYPE FORM)) (TYPE-REP (TYPE-REPRESENTATION TYPE))) (COND ((NUMBERP ARG) (COMPILE-CONSTANT (- ARG) (QUOTE STACK) REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (TYPE-REP (COMPILE-FORM ARG (QUOTE STACK) TYPE-REP) (EMIT (CASE TYPE-REP (:INT (QUOTE INEG)) (:LONG (QUOTE LNEG)) (:FLOAT (QUOTE FNEG)) (:DOUBLE (QUOTE DNEG)) (T (FORMAT T "p2-minus: unsupported rep (~S) for '~S'~%" TYPE-REP FORM) (ASSERT NIL)))) (CONVERT-REPRESENTATION TYPE-REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "negate" NIL +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))))) (3 (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (RESULT-TYPE (DERIVE-COMPILER-TYPE FORM)) (RESULT-REP (TYPE-REPRESENTATION RESULT-TYPE))) (COND ((AND (NUMBERP ARG1) (NUMBERP ARG2)) (COMPILE-CONSTANT (- ARG1 ARG2) TARGET REPRESENTATION)) (RESULT-REP (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 RESULT-REP) (COMPILE-OPERAND ARG2 RESULT-REP) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT (CASE RESULT-REP (:INT (QUOTE ISUB)) (:LONG (QUOTE LSUB)) (:FLOAT (QUOTE FSUB)) (:DOUBLE (QUOTE DSUB)) (T (SYSTEM::%FORMAT T "p2-minus sub-instruction (rep: ~S); form: ~S~%" RESULT-REP FORM) (ASSERT NIL))))) (CONVERT-REPRESENTATION RESULT-REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "subtract" (QUOTE (:INT)) +LISP-OBJECT+)) (FIX-BOXING REPRESENTATION RESULT-TYPE) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-BINARY-OPERATION "subtract" ARGS TARGET REPRESENTATION))))) (T (LET ((NEW-FORM (SYSTEM::BACKQ-LIST* (QUOTE -) (SYSTEM::BACKQ-LIST (QUOTE -) (SECOND FORM) (THIRD FORM)) (NTHCDR 3 FORM)))) (P2-MINUS NEW-FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-CHAR/SCHAR (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-CHAR/SCHAR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2))) (COND ((OR (AND (EQ REPRESENTATION :CHAR) (ZEROP *SAFETY*)) (AND (EQ REPRESENTATION :CHAR) (OR (EQ OP (QUOTE CHAR)) (< *SAFETY* 3)) (COMPILER-SUBTYPEP TYPE1 (QUOTE STRING)) (FIXNUM-TYPE-P TYPE2))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL +LISP-ABSTRACT-STRING+) (COMPILE-OPERAND ARG2 :INT))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT-INVOKEVIRTUAL +LISP-ABSTRACT-STRING+ "charAt" (QUOTE (:INT)) :CHAR) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUM-TYPE-P TYPE2) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (SYMBOL-NAME OP) (QUOTE (:INT)) +LISP-OBJECT+) (WHEN (EQ REPRESENTATION :CHAR) (EMIT-UNBOX-CHARACTER)) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-SET-CHAR/SCHAR (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-SET-CHAR/SCHAR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 3)) (LET* ((OP (%CAR FORM)) (ARGS (%CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1)) (TYPE2 (DERIVE-COMPILER-TYPE ARG2)) (TYPE3 (DERIVE-COMPILER-TYPE ARG3))) (COND ((AND (< *SAFETY* 3) (OR (NULL REPRESENTATION) (EQ REPRESENTATION :CHAR)) (COMPILER-SUBTYPEP TYPE1 (QUOTE STRING)) (FIXNUM-TYPE-P TYPE2) (COMPILER-SUBTYPEP TYPE3 (QUOTE CHARACTER))) (LET* ((*REGISTER* *REGISTER*) (VALUE-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL))) (CLASS (IF (EQ OP (QUOTE SCHAR)) +LISP-SIMPLE-STRING+ +LISP-ABSTRACT-STRING+))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL CLASS) (COMPILE-OPERAND ARG2 :INT) (ACCUMULATE-OPERAND (:CHAR :UNSAFE-P (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARG3))) (COMPILE-FORM ARG3 (QUOTE STACK) :CHAR) (WHEN TARGET (EMIT (QUOTE DUP)) (EMIT-MOVE-FROM-STACK VALUE-REGISTER :CHAR))))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3) (EMIT-INVOKEVIRTUAL CLASS "setCharAt" (QUOTE (:INT :CHAR)) NIL) (WHEN TARGET (EMIT (QUOTE ILOAD) VALUE-REGISTER) (CONVERT-REPRESENTATION :CHAR REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-SVREF (FORM TARGET REPRESENTATION) (COND ((AND (CHECK-ARG-COUNT FORM 2) (NEQ REPRESENTATION :CHAR)) (LET ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "SVREF" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-SVSET (FORM TARGET REPRESENTATION) (COND ((CHECK-ARG-COUNT FORM 3) (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (ARG3 (FOURTH FORM)) (*REGISTER* *REGISTER*) (VALUE-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (COMPILE-OPERAND ARG3 NIL))) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (EMIT-MOVE-FROM-STACK VALUE-REGISTER NIL)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "svset" (LIST :INT +LISP-OBJECT+) NIL) (WHEN VALUE-REGISTER (ALOAD VALUE-REGISTER) (EMIT-MOVE-FROM-STACK TARGET NIL)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-TRUNCATE (FORM TARGET REPRESENTATION) (LET ((ARGS (CDR FORM)) ARG1 ARG2) (CASE (LENGTH ARGS) (1 (SETF ARG1 (%CAR ARGS) ARG2 1)) (2 (SETF ARG1 (%CAR ARGS) ARG2 (%CADR ARGS))) (T (COMPILER-WARN "Wrong number of arguments for ~A (expected 1 or 2, but received ~D)." (QUOTE TRUNCATE) (LENGTH ARGS)) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-TRUNCATE))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "truncate" (LISP-OBJECT-ARG-TYPES 1) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFUN P2-ELT (FORM TARGET REPRESENTATION) (COND ((AND (CHECK-ARG-COUNT FORM 2) (FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE (THIRD FORM))) (NEQ REPRESENTATION :CHAR)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND (SECOND FORM) NIL) (COMPILE-OPERAND (THIRD FORM) :INT) (MAYBE-EMIT-CLEAR-VALUES (SECOND FORM) (THIRD FORM)))) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "elt" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-AREF (FORM TARGET REPRESENTATION) (CASE (LENGTH FORM) (3 (LET* ((ARG1 (%CADR FORM)) (ARG2 (%CADDR FORM)) (TYPE1 (DERIVE-COMPILER-TYPE ARG1))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL (WHEN (COMPILER-SUBTYPEP TYPE1 (QUOTE STRING)) +LISP-ABSTRACT-STRING+)) (COMPILE-OPERAND ARG2 :INT) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)) (ECASE REPRESENTATION (:INT (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "aref" (QUOTE (:INT)) :INT)) (:LONG (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "aref_long" (QUOTE (:INT)) :LONG)) (:CHAR (COND ((COMPILER-SUBTYPEP TYPE1 (QUOTE STRING)) (EMIT-INVOKEVIRTUAL +LISP-ABSTRACT-STRING+ "charAt" (QUOTE (:INT)) :CHAR)) (T (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "AREF" (QUOTE (:INT)) +LISP-OBJECT+) (EMIT-UNBOX-CHARACTER)))) ((NIL :FLOAT :DOUBLE :BOOLEAN) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "AREF" (QUOTE (:INT)) +LISP-OBJECT+) (CONVERT-REPRESENTATION NIL REPRESENTATION)))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFUN P2-ASET (FORM TARGET REPRESENTATION) (COND ((= (LENGTH FORM) 4) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS)) (TYPE3 (DERIVE-COMPILER-TYPE ARG3)) (*REGISTER* *REGISTER*) (VALUE-REGISTER (UNLESS (NULL TARGET) (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 :INT) (ACCUMULATE-OPERAND ((WHEN (FIXNUM-TYPE-P TYPE3) :INT) :UNSAFE-P (SOME-NESTED-BLOCK (FUNCTION NODE-OPSTACK-UNSAFE-P) (FIND-ENCLOSED-BLOCKS ARG3))) (COND ((FIXNUM-TYPE-P TYPE3) (COMPILE-FORM ARG3 (QUOTE STACK) :INT) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (EMIT-MOVE-FROM-STACK VALUE-REGISTER :INT))) (T (COMPILE-FORM ARG3 (QUOTE STACK) NIL) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (EMIT-MOVE-FROM-STACK VALUE-REGISTER NIL))))))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2 ARG3) (COND ((FIXNUM-TYPE-P TYPE3) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "aset" (QUOTE (:INT :INT)) NIL)) (T (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "aset" (LIST :INT +LISP-OBJECT+) NIL))) (WHEN VALUE-REGISTER (COND ((FIXNUM-TYPE-P TYPE3) (EMIT (QUOTE ILOAD) VALUE-REGISTER) (CONVERT-REPRESENTATION :INT REPRESENTATION)) (T (ALOAD VALUE-REGISTER) (FIX-BOXING REPRESENTATION TYPE3))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-STRUCTURE-REF (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-STRUCTURE-REF (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS))) (COND ((AND (FIXNUMP ARG2) (NULL REPRESENTATION)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (CASE ARG2 (0 (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue_0" NIL +LISP-OBJECT+)) (1 (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue_1" NIL +LISP-OBJECT+)) (2 (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue_2" NIL +LISP-OBJECT+)) (3 (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue_3" NIL +LISP-OBJECT+)) (T (EMIT-PUSH-CONSTANT-INT ARG2) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue" (QUOTE (:INT)) +LISP-OBJECT+))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((FIXNUMP ARG2) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) NIL) (EMIT-PUSH-CONSTANT-INT ARG2) (ECASE REPRESENTATION (:INT (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getFixnumSlotValue" (QUOTE (:INT)) :INT)) ((NIL :CHAR :LONG :FLOAT :DOUBLE) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValue" (QUOTE (:INT)) +LISP-OBJECT+) (CONVERT-REPRESENTATION NIL REPRESENTATION)) (:BOOLEAN (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getSlotValueAsBoolean" (QUOTE (:INT)) :BOOLEAN))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-STRUCTURE-SET (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-STRUCTURE-SET (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 3)) (LET* ((ARGS (CDR FORM)) (ARG1 (FIRST ARGS)) (ARG2 (SECOND ARGS)) (ARG3 (THIRD ARGS))) (COND ((AND (FIXNUMP ARG2) (<= 0 ARG2 3)) (LET* ((*REGISTER* *REGISTER*) (VALUE-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG3 NIL))) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (ASTORE VALUE-REGISTER)) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG3) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ (FORMAT NIL "setSlotValue_~D" ARG2) (LISP-OBJECT-ARG-TYPES 1) NIL) (WHEN VALUE-REGISTER (ALOAD VALUE-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))) ((FIXNUMP ARG2) (LET* ((*REGISTER* *REGISTER*) (VALUE-REGISTER (WHEN TARGET (ALLOCATE-REGISTER NIL)))) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG3 NIL))) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG3) (WHEN VALUE-REGISTER (EMIT (QUOTE DUP)) (ASTORE VALUE-REGISTER)) (EMIT-PUSH-CONSTANT-INT ARG2) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "setSlotValue" (LIST :INT +LISP-OBJECT+) NIL) (WHEN VALUE-REGISTER (ALOAD VALUE-REGISTER) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFINE-INLINED-FUNCTION P2-NOT/NULL (FORM TARGET REPRESENTATION) ((AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (CHECK-ARG-COUNT FORM 1)) (LET ((ARG (SECOND FORM))) (COND ((NULL ARG) (EMIT-PUSH-TRUE REPRESENTATION)) ((NODE-CONSTANT-P ARG) (EMIT-PUSH-FALSE REPRESENTATION)) ((AND (CONSP ARG) (MEMQ (%CAR ARG) (QUOTE (NOT NULL)))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES (SECOND ARG) (QUOTE STACK) NIL) (EMIT-PUSH-NIL) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IF_ACMPEQ) LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (LABEL LABEL2))) ((EQ REPRESENTATION :BOOLEAN) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :BOOLEAN) (EMIT (QUOTE ICONST_1)) (EMIT (QUOTE IXOR))) ((EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE BOOLEAN)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) :BOOLEAN) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IFEQ) LABEL1) (EMIT-PUSH-NIL) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-T) (LABEL LABEL2))) (T (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT-PUSH-NIL) (EMIT (QUOTE IF_ACMPEQ) LABEL1) (EMIT-PUSH-NIL) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-T) (LABEL LABEL2))))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))
     [java] ; (DEFINE-INLINED-FUNCTION P2-NTHCDR (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 2)) (LET* ((ARGS (%CDR FORM)) (ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS))) (COND ((FIXNUM-TYPE-P (DERIVE-COMPILER-TYPE ARG1)) (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :INT) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))) (EMIT (QUOTE SWAP)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "nthcdr" (QUOTE (:INT)) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-AND (FORM TARGET REPRESENTATION) (AVER (OR (NULL REPRESENTATION) (EQ REPRESENTATION :BOOLEAN))) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 (EMIT-PUSH-TRUE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (1 (COMPILE-FORM (%CAR ARGS) TARGET REPRESENTATION)) (T (LET ((FAIL (GENSYM)) (DONE (GENSYM)) (BUTLAST-ARGS (BUTLAST ARGS))) (LOOP FOR FORM IN BUTLAST-ARGS DO (COMPILE-FORM FORM (QUOTE STACK) NIL) DO (EMIT-PUSH-NIL) DO (EMIT (QUOTE IF_ACMPEQ) FAIL)) (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) BUTLAST-ARGS) (COMPILE-FORM (CAR (LAST ARGS)) TARGET REPRESENTATION) (EMIT (QUOTE GOTO) DONE) (LABEL FAIL) (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) BUTLAST-ARGS) (EMIT-PUSH-FALSE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (LABEL DONE))))))
     [java] ; (DEFKNOWN P2-OR (T T T) T)
     [java] ; (DEFUN P2-OR (FORM TARGET REPRESENTATION) (LET ((ARGS (CDR FORM))) (CASE (LENGTH ARGS) (0 (EMIT-PUSH-FALSE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (1 (COMPILE-FORM (%CAR ARGS) TARGET REPRESENTATION)) (T (LET ((SUCCESS (GENSYM)) (DONE (GENSYM)) (BUTLAST-ARGS (BUTLAST ARGS))) (LOOP FOR FORM IN BUTLAST-ARGS DO (COMPILE-FORM FORM (QUOTE STACK) NIL) DO (EMIT (QUOTE DUP)) DO (EMIT-PUSH-NIL) DO (EMIT (QUOTE IF_ACMPNE) SUCCESS) DO (EMIT (QUOTE POP))) (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) BUTLAST-ARGS) (COMPILE-FORM (CAR (LAST ARGS)) TARGET REPRESENTATION) (EMIT (QUOTE GOTO) DONE) (LABEL SUCCESS) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (APPLY (FUNCTION MAYBE-EMIT-CLEAR-VALUES) BUTLAST-ARGS) (LABEL DONE))))))
     [java] ; (DEFUN P2-VALUES (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (LEN (LENGTH ARGS))) (CASE LEN (0 (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "setValues" NIL +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET)) (1 (LET ((ARG (%CAR ARGS))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG TARGET REPRESENTATION))) (2 (LET ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS))) (COND ((AND (EQ ARG1 T) (EQ ARG2 T)) (EMIT-PUSH-CURRENT-THREAD) (EMIT-PUSH-T) (EMIT (QUOTE DUP))) ((AND (EQ ARG1 NIL) (EQ ARG2 NIL)) (EMIT-PUSH-CURRENT-THREAD) (EMIT-PUSH-NIL) (EMIT (QUOTE DUP))) (T (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (COMPILE-OPERAND ARG1 NIL) (COMPILE-OPERAND ARG2 NIL) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2)))))) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "setValues" (LISP-OBJECT-ARG-TYPES LEN) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET)) ((3 4) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (DOLIST (ARG ARGS) (COMPILE-OPERAND ARG NIL)))) (WHEN (NOTEVERY (FUNCTION SINGLE-VALUED-P) ARGS) (EMIT-CLEAR-VALUES)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "setValues" (LISP-OBJECT-ARG-TYPES LEN) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN COMPILE-SPECIAL-REFERENCE (VARIABLE TARGET REPRESENTATION) (LET ((NAME (VARIABLE-NAME VARIABLE))) (WHEN (CONSTANTP NAME) (LET ((VALUE (SYMBOL-VALUE NAME))) (WHEN (OR (NULL *FILE-COMPILATION*) (STRINGP VALUE) (NUMBERP VALUE) (PACKAGEP VALUE)) (COMPILE-CONSTANT VALUE TARGET REPRESENTATION) (RETURN-FROM COMPILE-SPECIAL-REFERENCE)))) (UNLESS (AND (VARIABLE-BINDING-REGISTER VARIABLE) (EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*) (NOT (ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P (VARIABLE-BLOCK VARIABLE)))) (EMIT-LOAD-EXTERNALIZED-OBJECT NAME)) (COND ((CONSTANTP NAME) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ "getSymbolValue" NIL +LISP-OBJECT+)) ((AND (VARIABLE-BINDING-REGISTER VARIABLE) (EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*) (NOT (ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P (VARIABLE-BLOCK VARIABLE)))) (ALOAD (VARIABLE-BINDING-REGISTER VARIABLE)) (EMIT-GETFIELD +LISP-SPECIAL-BINDING+ "value" +LISP-OBJECT+)) (T (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ "symbolValue" (LIST +LISP-THREAD+) +LISP-OBJECT+))) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))
     [java] ; (DEFKNOWN COMPILE-VAR-REF (T T T) T)
     [java] ; (DEFUN COMPILE-VAR-REF (REF TARGET REPRESENTATION) (WHEN TARGET (IF (VAR-REF-CONSTANT-P REF) (COMPILE-CONSTANT (VAR-REF-CONSTANT-VALUE REF) TARGET REPRESENTATION) (LET ((VARIABLE (VAR-REF-VARIABLE REF))) (COND ((VARIABLE-SPECIAL-P VARIABLE) (COMPILE-SPECIAL-REFERENCE VARIABLE TARGET REPRESENTATION)) ((OR (VARIABLE-REPRESENTATION VARIABLE) (VARIABLE-REGISTER VARIABLE) (VARIABLE-CLOSURE-INDEX VARIABLE) (VARIABLE-INDEX VARIABLE) (VARIABLE-ENVIRONMENT VARIABLE)) (EMIT-PUSH-VARIABLE VARIABLE) (CONVERT-REPRESENTATION (VARIABLE-REPRESENTATION VARIABLE) REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (SYSTEM::%FORMAT T "compile-var-ref general case~%") (AVER NIL)))))))
     [java] ; (DEFUN P2-SET (FORM TARGET REPRESENTATION) (COND ((AND (CHECK-ARG-COUNT FORM 2) (EQ (DERIVE-TYPE (%CADR FORM)) (QUOTE SYMBOL))) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (COMPILE-OPERAND (%CADR FORM) NIL +LISP-SYMBOL+) (COMPILE-OPERAND (%CADDR FORM) NIL))) (MAYBE-EMIT-CLEAR-VALUES (%CADR FORM) (%CADDR FORM)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "setSpecialVariable" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-SETQ (T T T) T)
     [java] ; (DEFUN P2-SETQ (FORM TARGET REPRESENTATION) (UNLESS (= (LENGTH FORM) 3) (ASSERT (NOT "p2-setq should receive exactly 2 arguments!"))) (LET* ((NAME (%CADR FORM)) (VARIABLE (FIND-VISIBLE-VARIABLE NAME)) (VALUE-FORM (%CADDR FORM))) (WHEN (OR (NULL VARIABLE) (VARIABLE-SPECIAL-P VARIABLE)) (COND ((AND VARIABLE (VARIABLE-BINDING-REGISTER VARIABLE) (EQ (VARIABLE-COMPILAND VARIABLE) *CURRENT-COMPILAND*) (NOT (ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P (VARIABLE-BLOCK VARIABLE)))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES VALUE-FORM (QUOTE STACK) NIL) (EMIT (QUOTE DUP)) (ALOAD (VARIABLE-BINDING-REGISTER VARIABLE)) (EMIT (QUOTE SWAP)) (EMIT-PUTFIELD +LISP-SPECIAL-BINDING+ "value" +LISP-OBJECT+)) ((AND (CONSP VALUE-FORM) (EQ (FIRST VALUE-FORM) (QUOTE CONS)) (= (LENGTH VALUE-FORM) 3) (VAR-REF-P (THIRD VALUE-FORM)) (EQ (VARIABLE-NAME (VAR-REF-VARIABLE (THIRD VALUE-FORM))) NAME)) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (EMIT-LOAD-EXTERNALIZED-OBJECT-OPERAND NAME) (COMPILE-OPERAND (SECOND VALUE-FORM) NIL) (MAYBE-EMIT-CLEAR-VALUES (SECOND VALUE-FORM))) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "pushSpecial" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) +LISP-OBJECT+))) (T (UNLESS (SYMBOLP NAME) (ERROR (QUOTE PROGRAM-ERROR) "First argument to SETQ is not a symbol in ~S" FORM)) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (EMIT-LOAD-EXTERNALIZED-OBJECT-OPERAND NAME) (COMPILE-OPERAND VALUE-FORM NIL) (MAYBE-EMIT-CLEAR-VALUES VALUE-FORM)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "setSpecialVariable" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) +LISP-OBJECT+)))) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-SETQ)) (WHEN (ZEROP (VARIABLE-READS VARIABLE)) (COND (TARGET (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES VALUE-FORM (QUOTE STACK) NIL) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FORM VALUE-FORM NIL NIL))) (RETURN-FROM P2-SETQ)) (LET ((INCF-P NIL)) (WHEN (AND (EQ (VARIABLE-REPRESENTATION VARIABLE) :INT) (CONSP VALUE-FORM)) (LET ((OP (CAR VALUE-FORM)) (LEN (LENGTH VALUE-FORM))) (CASE OP (1+ (WHEN (= LEN 2) (LET ((ARG (CADR VALUE-FORM))) (WHEN (AND (VAR-REF-P ARG) (EQ (VAR-REF-VARIABLE ARG) VARIABLE)) (SETF INCF-P T))))) (+ (WHEN (= LEN 3) (LET ((ARG1 (SECOND VALUE-FORM)) (ARG2 (THIRD VALUE-FORM))) (WHEN (EQL ARG1 1) (SETF ARG1 ARG2 ARG2 1)) (WHEN (EQL ARG2 1) (WHEN (AND (VAR-REF-P ARG1) (EQ (VAR-REF-VARIABLE ARG1) VARIABLE)) (SETF INCF-P T))))))))) (WHEN INCF-P (AVER (VARIABLE-REGISTER VARIABLE)) (EMIT (QUOTE IINC) (VARIABLE-REGISTER VARIABLE) 1) (WHEN TARGET (EMIT (QUOTE ILOAD) (VARIABLE-REGISTER VARIABLE)) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (RETURN-FROM P2-SETQ))) (COND ((AND (EQ (VARIABLE-REPRESENTATION VARIABLE) :INT) (OR (EQUAL VALUE-FORM (LIST (QUOTE 1+) (VARIABLE-NAME VARIABLE))) (EQUAL VALUE-FORM (LIST (QUOTE +) (VARIABLE-NAME VARIABLE) 1)) (EQUAL VALUE-FORM (LIST (QUOTE +) 1 (VARIABLE-NAME VARIABLE))))) (EMIT (QUOTE IINC) (VARIABLE-REGISTER VARIABLE) 1) (WHEN TARGET (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) ((AND (EQ (VARIABLE-REPRESENTATION VARIABLE) :INT) (OR (EQUAL VALUE-FORM (LIST (QUOTE 1-) (VARIABLE-NAME VARIABLE))) (EQUAL VALUE-FORM (LIST (QUOTE -) (VARIABLE-NAME VARIABLE) 1)))) (DFORMAT T "p2-setq decf :int case~%") (EMIT (QUOTE IINC) (VARIABLE-REGISTER VARIABLE) -1) (WHEN TARGET (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (LET ((REP (VARIABLE-REPRESENTATION VARIABLE))) (DFORMAT T "p2-setq ~A case value-form = ~S~%" REP VALUE-FORM) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES VALUE-FORM (QUOTE STACK) REP) (WHEN TARGET (EMIT-DUP REP)) (EMIT-MOVE-TO-VARIABLE VARIABLE) (WHEN TARGET (CONVERT-REPRESENTATION REP REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))))))
     [java] ; (DEFUN P2-SXHASH (FORM TARGET REPRESENTATION) (COND ((CHECK-ARG-COUNT FORM 1) (LET ((ARG (%CADR FORM))) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "sxhash" NIL :INT) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION))) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-SYMBOL-NAME (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-SYMBOL-NAME (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (%CADR FORM))) (COND ((AND (EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE SYMBOL)) (< *SAFETY* 3)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-SYMBOL+) (EMIT-GETFIELD +LISP-SYMBOL+ "name" +LISP-ABSTRACT-STRING+) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-SYMBOL-PACKAGE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-SYMBOL-PACKAGE (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (%CADR FORM))) (COND ((AND (EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE SYMBOL)) (< *SAFETY* 3)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-SYMBOL+) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ "getPackageOrNil" NIL +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-SYMBOL-VALUE (T T T) T)
     [java] ; (DEFUN P2-SYMBOL-VALUE (FORM TARGET REPRESENTATION) (WHEN (CHECK-ARG-COUNT FORM 1) (LET ((ARG (%CADR FORM))) (WHEN (EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE SYMBOL)) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG (QUOTE STACK) NIL) (EMIT-CHECKCAST +LISP-SYMBOL+) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-SYMBOL+ "symbolValue" (LIST +LISP-THREAD+) +LISP-OBJECT+) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-SYMBOL-VALUE)))) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))
     [java] ; (DEFKNOWN GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VALUE (T) T)
     [java] ; (DEFUN GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VALUE (EXPECTED-TYPE) (DECLARE (TYPE SYMBOL EXPECTED-TYPE)) (LET ((INSTANCEOF-CLASS (ECASE EXPECTED-TYPE (SYMBOL +LISP-SYMBOL+) (CHARACTER +LISP-CHARACTER+) (CONS +LISP-CONS+) (HASH-TABLE +LISP-HASH-TABLE+) (FIXNUM +LISP-FIXNUM+) (STREAM +LISP-STREAM+) (STRING +LISP-ABSTRACT-STRING+) (VECTOR +LISP-ABSTRACT-VECTOR+))) (EXPECTED-TYPE-JAVA-SYMBOL-NAME (CASE EXPECTED-TYPE (HASH-TABLE "HASH_TABLE") (T (SYMBOL-NAME EXPECTED-TYPE)))) (LABEL1 (GENSYM))) (EMIT (QUOTE DUP)) (EMIT-INSTANCEOF INSTANCEOF-CLASS) (EMIT (QUOTE IFNE) LABEL1) (EMIT-GETSTATIC +LISP-SYMBOL+ EXPECTED-TYPE-JAVA-SYMBOL-NAME +LISP-SYMBOL+) (EMIT-INVOKESTATIC +LISP+ "type_error" (LISP-OBJECT-ARG-TYPES 2) +LISP-OBJECT+) (LABEL LABEL1)) T)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) GENERATE-TYPE-CHECK-FOR-VALUE))
     [java] ; (DEFUN GENERATE-TYPE-CHECK-FOR-VALUE (DECLARED-TYPE) (LET ((TYPE-TO-USE (FIND-TYPE-FOR-TYPE-CHECK DECLARED-TYPE))) (WHEN TYPE-TO-USE (GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VALUE TYPE-TO-USE))))
     [java] ; (DEFUN P2-THE (FORM TARGET REPRESENTATION) (LET ((TYPE-FORM (SECOND FORM)) (VALUE-FORM (THIRD FORM))) (COND ((AND (SUBTYPEP TYPE-FORM (QUOTE FIXNUM)) (CONSP VALUE-FORM) (EQ (CAR VALUE-FORM) (QUOTE STRUCTURE-REF))) (COMPILE-FORM VALUE-FORM TARGET REPRESENTATION)) ((AND (> *SAFETY* 0) (NOT (COMPILER-SUBTYPEP (DERIVE-TYPE VALUE-FORM) TYPE-FORM))) (COMPILE-FORM VALUE-FORM (QUOTE STACK) NIL) (GENERATE-TYPE-CHECK-FOR-VALUE TYPE-FORM) (FIX-BOXING REPRESENTATION NIL) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FORM VALUE-FORM TARGET REPRESENTATION)))))
     [java] ; (DEFUN P2-TRULY-THE (FORM TARGET REPRESENTATION) (COMPILE-FORM (THIRD FORM) TARGET REPRESENTATION))
     [java] ; (DEFKNOWN P2-CHAR-CODE (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-CHAR-CODE (FORM TARGET REPRESENTATION) ((CHECK-ARG-COUNT FORM 1)) (LET ((ARG (SECOND FORM))) (COND ((CHARACTERP ARG) (COMPILE-CONSTANT (CHAR-CODE ARG) TARGET REPRESENTATION)) ((AND (< *SAFETY* 3) (EQ (DERIVE-COMPILER-TYPE ARG) (QUOTE CHARACTER))) (COMPILE-FORM ARG (QUOTE STACK) :CHAR) (CONVERT-REPRESENTATION :INT REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-JAVA-JCLASS (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-JAVA-JCLASS (FORM TARGET REPRESENTATION) ((AND (= 2 (LENGTH FORM)) (STRINGP (CADR FORM)))) (LET ((C (IGNORE-ERRORS (JAVA:JCLASS (CADR FORM))))) (IF C (COMPILE-CONSTANT C TARGET REPRESENTATION) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-JAVA-JCONSTRUCTOR (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-JAVA-JCONSTRUCTOR (FORM TARGET REPRESENTATION) ((AND (< 1 (LENGTH FORM)) (EVERY (FUNCTION STRINGP) (CDR FORM)))) (LET ((C (IGNORE-ERRORS (APPLY (FUNCTION JAVA:JCONSTRUCTOR) (CDR FORM))))) (IF C (COMPILE-CONSTANT C TARGET REPRESENTATION) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-JAVA-JMETHOD (T T T) T)
     [java] ; (DEFINE-INLINED-FUNCTION P2-JAVA-JMETHOD (FORM TARGET REPRESENTATION) ((AND (< 1 (LENGTH FORM)) (EVERY (FUNCTION STRINGP) (CDR FORM)))) (LET ((M (IGNORE-ERRORS (APPLY (FUNCTION JAVA:JMETHOD) (CDR FORM))))) (IF M (COMPILE-CONSTANT M TARGET REPRESENTATION) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION))))
     [java] ; (DEFKNOWN P2-CHAR= (T T T) T)
     [java] ; (DEFUN P2-CHAR= (FORM TARGET REPRESENTATION) (LET* ((ARGS (CDR FORM)) (NUMARGS (LENGTH ARGS))) (WHEN (= NUMARGS 0) (COMPILER-WARN "Wrong number of arguments for ~A." (CAR FORM)) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-CHAR=)) (UNLESS (= NUMARGS 2) (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION) (RETURN-FROM P2-CHAR=)) (LET ((ARG1 (%CAR ARGS)) (ARG2 (%CADR ARGS))) (WHEN (AND (CHARACTERP ARG1) (CHARACTERP ARG2)) (COND ((EQL ARG1 ARG2) (EMIT-PUSH-TRUE REPRESENTATION)) (T (EMIT-PUSH-FALSE REPRESENTATION))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION) (RETURN-FROM P2-CHAR=)) (COND ((CHARACTERP ARG1) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG2 (QUOTE STACK) :CHAR) (EMIT-PUSH-CONSTANT-INT (CHAR-CODE ARG1))) ((CHARACTERP ARG2) (COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES ARG1 (QUOTE STACK) :CHAR) (EMIT-PUSH-CONSTANT-INT (CHAR-CODE ARG2))) (T (WITH-OPERAND-ACCUMULATION ((COMPILE-OPERAND ARG1 :CHAR) (COMPILE-OPERAND ARG2 :CHAR) (MAYBE-EMIT-CLEAR-VALUES ARG1 ARG2))))) (LET ((LABEL1 (GENSYM)) (LABEL2 (GENSYM))) (EMIT (QUOTE IF_ICMPEQ) LABEL1) (EMIT-PUSH-FALSE REPRESENTATION) (EMIT (QUOTE GOTO) LABEL2) (LABEL LABEL1) (EMIT-PUSH-TRUE REPRESENTATION) (LABEL LABEL2) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)))))
     [java] ; (DEFKNOWN P2-THREADS-SYNCHRONIZED-ON (T T) T)
     [java] ; (DEFUN P2-THREADS-SYNCHRONIZED-ON (BLOCK TARGET) (LET* ((FORM (SYNCHRONIZED-FORM BLOCK)) (*REGISTER* *REGISTER*) (OBJECT-REGISTER (ALLOCATE-REGISTER NIL)) (BEGIN-PROTECTED-RANGE (GENSYM "F")) (END-PROTECTED-RANGE (GENSYM "U")) (EXIT (GENSYM "E"))) (COMPILE-FORM (CADR FORM) (QUOTE STACK) NIL) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "lockableInstance" NIL +JAVA-OBJECT+) (EMIT (QUOTE DUP)) (ASTORE OBJECT-REGISTER) (EMIT (QUOTE MONITORENTER)) (LABEL BEGIN-PROTECTED-RANGE) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (COMPILE-PROGN-BODY (CDDR FORM) TARGET)) (EMIT (QUOTE GOTO) EXIT) (LABEL END-PROTECTED-RANGE) (ALOAD OBJECT-REGISTER) (EMIT (QUOTE MONITOREXIT)) (EMIT (QUOTE ATHROW)) (LABEL EXIT) (ALOAD OBJECT-REGISTER) (EMIT (QUOTE MONITOREXIT)) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE END-PROTECTED-RANGE NIL)))
     [java] ; (DEFUN P2-JAVA-JRUN-EXCEPTION-PROTECTED (BLOCK TARGET) (LET* ((FORM (EXCEPTION-PROTECTED-FORM BLOCK)) (*REGISTER* *REGISTER*) (*BLOCKS* (CONS BLOCK *BLOCKS*)) (BEGIN-PROTECTED-RANGE (GENSYM "F")) (END-PROTECTED-RANGE (GENSYM "U")) (STACK-EXHAUST (GENSYM "S")) (MEMORY-EXHAUST (GENSYM "M")) (EXIT (GENSYM "E"))) (LABEL BEGIN-PROTECTED-RANGE) (COMPILE-PROGN-BODY FORM TARGET) (EMIT (QUOTE GOTO) EXIT) (LABEL END-PROTECTED-RANGE) (LABEL STACK-EXHAUST) (EMIT (QUOTE POP)) (EMIT-INVOKESTATIC +LISP+ "stackError" NIL +LISP-OBJECT+) (EMIT (QUOTE ARETURN)) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE STACK-EXHAUST +JAVA-STACK-OVERFLOW+) (LABEL MEMORY-EXHAUST) (EMIT-INVOKESTATIC +LISP+ "memoryError" (LIST +JAVA-OUT-OF-MEMORY+) +LISP-OBJECT+) (EMIT (QUOTE ARETURN)) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE MEMORY-EXHAUST +JAVA-OUT-OF-MEMORY+) (LABEL EXIT)))
     [java] ; (DEFKNOWN P2-CATCH-NODE (T T) T)
     [java] ; (DEFUN P2-CATCH-NODE (BLOCK TARGET) (LET ((FORM (CATCH-FORM BLOCK))) (WHEN (= (LENGTH FORM) 2) (WHEN TARGET (EMIT-PUSH-NIL) (EMIT-MOVE-FROM-STACK TARGET)) (RETURN-FROM P2-CATCH-NODE)) (LET* ((*REGISTER* *REGISTER*) (TAG-REGISTER (ALLOCATE-REGISTER NIL)) (BEGIN-PROTECTED-RANGE (GENSYM "F")) (END-PROTECTED-RANGE (GENSYM "U")) (THROW-HANDLER (GENSYM "H")) (RETHROW (GENSYM)) (DEFAULT-HANDLER (GENSYM)) (EXIT (GENSYM "E")) (SPECIALS-REGISTER (ALLOCATE-REGISTER NIL))) (COMPILE-FORM (SECOND FORM) TAG-REGISTER NIL) (EMIT-PUSH-CURRENT-THREAD) (ALOAD TAG-REGISTER) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "pushCatchTag" (LISP-OBJECT-ARG-TYPES 1) NIL) (LET ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (SAVE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (LABEL BEGIN-PROTECTED-RANGE) (COMPILE-PROGN-BODY (CDDR FORM) TARGET) (LABEL END-PROTECTED-RANGE) (EMIT (QUOTE GOTO) EXIT)) (LABEL THROW-HANDLER) (EMIT (QUOTE DUP)) (EMIT-GETFIELD +LISP-THROW+ "tag" +LISP-OBJECT+) (ALOAD TAG-REGISTER) (EMIT (QUOTE IF_ACMPNE) RETHROW) (RESTORE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THROW+ "getResult" (LIST +LISP-THREAD+) +LISP-OBJECT+) (EMIT-MOVE-FROM-STACK TARGET) (EMIT (QUOTE GOTO) EXIT) (LABEL RETHROW) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "popCatchTag" NIL NIL) (EMIT (QUOTE ATHROW)) (LABEL DEFAULT-HANDLER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "popCatchTag" NIL NIL) (EMIT (QUOTE ATHROW)) (LABEL EXIT) (EMIT-PUSH-CURRENT-THREAD) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "popCatchTag" NIL NIL) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE THROW-HANDLER +LISP-THROW+) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE DEFAULT-HANDLER NIL))) T)
     [java] ; (DEFUN P2-THROW (FORM TARGET REPRESENTATION) (DECLARE (IGNORE REPRESENTATION)) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (COMPILE-OPERAND (SECOND FORM) NIL) (EMIT-CLEAR-VALUES) (COMPILE-OPERAND (THIRD FORM) NIL)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "throwToTag" (LISP-OBJECT-ARG-TYPES 2) NIL)) (WHEN TARGET (ECASE REPRESENTATION ((:INT :BOOLEAN :CHAR) (EMIT (QUOTE ICONST_0))) ((NIL) (EMIT-PUSH-NIL))) (EMIT-MOVE-FROM-STACK TARGET)))
     [java] ; in (DEFUN P2-THROW (FORM TARGET REPRESENTATION) (DECLARE (IGNORE REPRESENTATION)) (WITH-OPERAND-ACCUMULATION ((EMIT-THREAD-OPERAND) (COMPILE-OPERAND (SECOND FORM) NIL) (EMIT-CLEAR-VALUES) (COMPILE-OPERAND (THIRD FORM) NIL)) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "throwToTag" (LISP-OBJECT-ARG-TYPES 2) NIL)) (WHEN TARGET (ECASE REPRESENTATION ((:INT :BOOLEAN :CHAR) (EMIT (QUOTE ICONST_0))) ((NIL) (EMIT-PUSH-NIL))) (EMIT-MOVE-FROM-STACK TARGET)))
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   Variable REPRESENTATION is read even though it was declared to be ignored.
     [java]
     [java] ; (DEFUN P2-UNWIND-PROTECT-NODE (BLOCK TARGET) (LET ((FORM (UNWIND-PROTECT-FORM BLOCK))) (WHEN (= (LENGTH FORM) 2) (COMPILE-FORM (SECOND FORM) TARGET NIL) (RETURN-FROM P2-UNWIND-PROTECT-NODE)) (LET* ((PROTECTED-FORM (CADR FORM)) (UNWINDING-FORM (CADDR FORM)) (CLEANUP-FORMS (CDDDR FORM)) (*REGISTER* *REGISTER*) (EXCEPTION-REGISTER (ALLOCATE-REGISTER NIL)) (RESULT-REGISTER (ALLOCATE-REGISTER NIL)) (VALUES-REGISTER (ALLOCATE-REGISTER NIL)) (SPECIALS-REGISTER (ALLOCATE-REGISTER NIL)) (BEGIN-PROTECTED-RANGE (GENSYM "F")) (END-PROTECTED-RANGE (GENSYM "U")) (HANDLER (GENSYM "H")) (EXIT (GENSYM "E"))) (EMIT-CLEAR-VALUES) (LET* ((*BLOCKS* (CONS BLOCK *BLOCKS*))) (SAVE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (LABEL BEGIN-PROTECTED-RANGE) (COMPILE-FORM PROTECTED-FORM RESULT-REGISTER NIL) (UNLESS (SINGLE-VALUED-P PROTECTED-FORM) (EMIT-PUSH-CURRENT-THREAD) (EMIT-GETFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (ASTORE VALUES-REGISTER)) (LABEL END-PROTECTED-RANGE)) (LET ((*REGISTER* *REGISTER*)) (COMPILE-FORM UNWINDING-FORM NIL NIL)) (WHEN (SINGLE-VALUED-P PROTECTED-FORM) (MAYBE-EMIT-CLEAR-VALUES UNWINDING-FORM)) (EMIT (QUOTE GOTO) EXIT) (LABEL HANDLER) (ASTORE EXCEPTION-REGISTER) (EMIT-PUSH-CURRENT-THREAD) (EMIT-GETFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (ASTORE VALUES-REGISTER) (RESTORE-DYNAMIC-ENVIRONMENT SPECIALS-REGISTER) (LET ((*REGISTER* *REGISTER*)) (COMPILE-PROGN-BODY CLEANUP-FORMS NIL NIL)) (EMIT-PUSH-CURRENT-THREAD) (ALOAD VALUES-REGISTER) (EMIT-PUTFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+) (ALOAD EXCEPTION-REGISTER) (EMIT (QUOTE ATHROW)) (LABEL EXIT) (UNLESS (SINGLE-VALUED-P PROTECTED-FORM) (EMIT-PUSH-CURRENT-THREAD) (ALOAD VALUES-REGISTER) (EMIT-PUTFIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+)) (ALOAD RESULT-REGISTER) (EMIT-MOVE-FROM-STACK TARGET) (ADD-EXCEPTION-HANDLER BEGIN-PROTECTED-RANGE END-PROTECTED-RANGE HANDLER NIL))))
     [java] ; (DEFKNOWN COMPILE-FORM (T T T) T)
     [java] ; (DEFUN COMPILE-FORM (FORM TARGET REPRESENTATION) (COND ((CONSP FORM) (LET* ((OP (%CAR FORM)) (HANDLER (AND (SYMBOLP OP) (GET OP (QUOTE P2-HANDLER))))) (COND (HANDLER (FUNCALL HANDLER FORM TARGET REPRESENTATION)) ((SYMBOLP OP) (COND ((SPECIAL-OPERATOR-P OP) (DFORMAT T "form = ~S~%" FORM) (COMPILER-UNSUPPORTED "COMPILE-FORM: unsupported special operator ~S" OP)) (T (COMPILE-FUNCTION-CALL FORM TARGET REPRESENTATION)))) ((AND (CONSP OP) (EQ (%CAR OP) (QUOTE LAMBDA))) (AVER (PROGN (QUOTE UNEXPECTED-LAMBDA) NIL)) (LET ((NEW-FORM (LIST* (QUOTE FUNCALL) FORM))) (COMPILE-FORM NEW-FORM TARGET REPRESENTATION))) (T (COMPILER-UNSUPPORTED "COMPILE-FORM unhandled case ~S" FORM))))) ((SYMBOLP FORM) (COND ((NULL FORM) (EMIT-PUSH-FALSE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((EQ FORM T) (EMIT-PUSH-TRUE REPRESENTATION) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) ((KEYWORDP FORM) (ECASE REPRESENTATION (:BOOLEAN (EMIT (QUOTE ICONST_1))) ((NIL) (EMIT-LOAD-EXTERNALIZED-OBJECT FORM))) (EMIT-MOVE-FROM-STACK TARGET REPRESENTATION)) (T (AVER NIL)))) ((VAR-REF-P FORM) (COMPILE-VAR-REF FORM TARGET REPRESENTATION)) ((NODE-P FORM) (COND ((JUMP-NODE-P FORM) (LET ((OP (CAR (NODE-FORM FORM)))) (COND ((EQ OP (QUOTE GO)) (P2-GO FORM TARGET REPRESENTATION)) ((EQ OP (QUOTE RETURN-FROM)) (P2-RETURN-FROM FORM TARGET REPRESENTATION)) (T (ASSERT (NOT "jump-node: can't happen")))))) ((BLOCK-NODE-P FORM) (P2-BLOCK-NODE FORM TARGET REPRESENTATION)) ((LET/LET*-NODE-P FORM) (P2-LET/LET*-NODE FORM TARGET REPRESENTATION)) ((TAGBODY-NODE-P FORM) (P2-TAGBODY-NODE FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) ((UNWIND-PROTECT-NODE-P FORM) (P2-UNWIND-PROTECT-NODE FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) ((M-V-B-NODE-P FORM) (P2-M-V-B-NODE FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) ((FLET-NODE-P FORM) (P2-FLET-NODE FORM TARGET REPRESENTATION)) ((LABELS-NODE-P FORM) (P2-LABELS-NODE FORM TARGET REPRESENTATION)) ((LOCALLY-NODE-P FORM) (P2-LOCALLY-NODE FORM TARGET REPRESENTATION)) ((CATCH-NODE-P FORM) (P2-CATCH-NODE FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) ((PROGV-NODE-P FORM) (P2-PROGV-NODE FORM TARGET REPRESENTATION)) ((SYNCHRONIZED-NODE-P FORM) (P2-THREADS-SYNCHRONIZED-ON FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) ((PROTECTED-NODE-P FORM) (P2-JAVA-JRUN-EXCEPTION-PROTECTED FORM TARGET) (FIX-BOXING REPRESENTATION NIL)) (T (AVER (NOT "Can't happen"))))) ((CONSTANTP FORM) (COMPILE-CONSTANT FORM TARGET REPRESENTATION)) (T (COMPILER-UNSUPPORTED "COMPILE-FORM unhandled case ~S" FORM))) T)
     [java] ; (DEFMACRO WITH-OPEN-CLASS-FILE ((VAR CLASS-FILE) &BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE WITH-OPEN-FILE) (SYSTEM::BACKQ-LIST* VAR (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-PATHNAME) CLASS-FILE) (QUOTE (:DIRECTION :OUTPUT :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :IF-EXISTS :SUPERSEDE))) BODY))
     [java] ; (DEFKNOWN P2-COMPILAND-PROCESS-TYPE-DECLARATIONS (LIST) T)
     [java] ; (DEFUN P2-COMPILAND-PROCESS-TYPE-DECLARATIONS (BODY) (FLET ((PROCESS-DECLARATION (NAME TYPE) (LET ((VARIABLE (FIND-VISIBLE-VARIABLE NAME))) (WHEN VARIABLE (SETF (VARIABLE-DECLARED-TYPE VARIABLE) TYPE))))) (DOLIST (SUBFORM BODY) (UNLESS (AND (CONSP SUBFORM) (EQ (%CAR SUBFORM) (QUOTE DECLARE))) (RETURN)) (LET ((DECLS (%CDR SUBFORM))) (DOLIST (DECL DECLS) (CASE (CAR DECL) (TYPE (LET ((TYPE (MAKE-COMPILER-TYPE (CADR DECL)))) (DOLIST (NAME (CDDR DECL)) (PROCESS-DECLARATION NAME TYPE)))) ((IGNORE IGNORABLE) (PROCESS-IGNORE/IGNORABLE (%CAR DECL) (%CDR DECL) *VISIBLE-VARIABLES*)) ((DYNAMIC-EXTENT FTYPE INLINE NOTINLINE OPTIMIZE SPECIAL)) (T (LET ((TYPE (MAKE-COMPILER-TYPE (CAR DECL)))) (DOLIST (NAME (CDR DECL)) (PROCESS-DECLARATION NAME TYPE))))))))) T)
     [java] ; (DEFKNOWN P2-COMPILAND-UNBOX-VARIABLE (VARIABLE) T)
     [java] ; (DEFUN P2-COMPILAND-UNBOX-VARIABLE (VARIABLE) (LET ((REGISTER (VARIABLE-REGISTER VARIABLE))) (WHEN (AND REGISTER (NOT (VARIABLE-SPECIAL-P VARIABLE)) (NOT (VARIABLE-USED-NON-LOCALLY-P VARIABLE)) (NULL (COMPILAND-CHILDREN *CURRENT-COMPILAND*))) (WHEN (MEMQ (TYPE-REPRESENTATION (VARIABLE-DECLARED-TYPE VARIABLE)) (QUOTE (:INT :LONG))) (EMIT-PUSH-VARIABLE VARIABLE) (DERIVE-VARIABLE-REPRESENTATION VARIABLE NIL) (WHEN (< 1 (REPRESENTATION-SIZE (VARIABLE-REPRESENTATION VARIABLE))) (ALLOCATE-VARIABLE-REGISTER VARIABLE)) (CONVERT-REPRESENTATION NIL (VARIABLE-REPRESENTATION VARIABLE)) (EMIT-MOVE-TO-VARIABLE VARIABLE)))) T)
     [java] ; (DEFUN ASSIGN-FIELD-NAME (LOCAL-FUNCTION) (SETF (LOCAL-FUNCTION-FIELD LOCAL-FUNCTION) (SYMBOL-NAME (GENSYM "LFUN"))))
     [java] ; (DEFKNOWN P2-COMPILAND (T) T)
     [java] ; (DEFUN P2-COMPILAND (COMPILAND METHOD) (LET* ((P1-RESULT (COMPILAND-P1-RESULT COMPILAND)) (CLASS-FILE (COMPILAND-CLASS-FILE COMPILAND)) (*THIS-CLASS* (ABCL-CLASS-FILE-CLASS CLASS-FILE)) (CLOSURE-ARGS (INTERSECTION *CLOSURE-VARIABLES* (COMPILAND-ARG-VARS COMPILAND))) (LOCAL-CLOSURE-VARS (FIND COMPILAND *CLOSURE-VARIABLES* :KEY (FUNCTION VARIABLE-COMPILAND))) (BODY (CDDR P1-RESULT)) (*CHILD-P* (NOT (NULL (COMPILAND-PARENT COMPILAND)))) (*VISIBLE-VARIABLES* *VISIBLE-VARIABLES*) (*THREAD* NIL) (*INITIALIZE-THREAD-VAR* NIL) (*CURRENT-COMPILAND* COMPILAND)) (WITH-CODE-TO-METHOD (CLASS-FILE METHOD) (SETF *REGISTER* 1 *REGISTERS-ALLOCATED* 1) (WHEN (FIXNUMP *SOURCE-LINE-NUMBER*) (LET ((TABLE (MAKE-LINE-NUMBERS-ATTRIBUTE))) (CODE-ADD-ATTRIBUTE *CURRENT-CODE-ATTRIBUTE* TABLE) (LINE-NUMBERS-ADD-LINE TABLE 0 *SOURCE-LINE-NUMBER*))) (DOLIST (LOCAL-FUNCTION (COMPILAND-CHILDREN COMPILAND)) (ASSIGN-FIELD-NAME LOCAL-FUNCTION)) (DOLIST (VAR (COMPILAND-ARG-VARS COMPILAND)) (PUSH VAR *VISIBLE-VARIABLES*)) (DOLIST (VAR (COMPILAND-FREE-SPECIALS COMPILAND)) (PUSH VAR *VISIBLE-VARIABLES*)) (WHEN *USING-ARG-ARRAY* (SETF (COMPILAND-ARGUMENT-REGISTER COMPILAND) (ALLOCATE-REGISTER NIL))) (LET ((INDEX 0)) (DOLIST (VARIABLE (COMPILAND-ARG-VARS COMPILAND)) (AVER (NULL (VARIABLE-REGISTER VARIABLE))) (AVER (NULL (VARIABLE-INDEX VARIABLE))) (IF *USING-ARG-ARRAY* (SETF (VARIABLE-INDEX VARIABLE) INDEX) (SETF (VARIABLE-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL))) (INCF INDEX))) (SETF *THREAD* (ALLOCATE-REGISTER NIL)) (WHEN *CLOSURE-VARIABLES* (SETF (COMPILAND-CLOSURE-REGISTER COMPILAND) (ALLOCATE-REGISTER NIL)) (DFORMAT T "p2-compiland 2 closure register = ~S~%" (COMPILAND-CLOSURE-REGISTER COMPILAND))) (WHEN *CLOSURE-VARIABLES* (IF (NOT *CHILD-P*) (PROGN (EMIT-PUSH-CONSTANT-INT (LENGTH *CLOSURE-VARIABLES*)) (EMIT-ANEWARRAY +LISP-CLOSURE-BINDING+)) (PROGN (ALOAD 0) (EMIT-GETFIELD +LISP-COMPILED-CLOSURE+ "ctx" +CLOSURE-BINDING-ARRAY+) (WHEN LOCAL-CLOSURE-VARS (EMIT (QUOTE ASTORE) (COMPILAND-CLOSURE-REGISTER COMPILAND)) (DUPLICATE-CLOSURE-ARRAY COMPILAND))))) (WHEN (OR CLOSURE-ARGS (AND *CLOSURE-VARIABLES* (NOT *CHILD-P*))) (DFORMAT T "~S moving arguments to closure array~%" (COMPILAND-NAME COMPILAND)) (DOTIMES (I (LENGTH *CLOSURE-VARIABLES*)) (LET ((VARIABLE (FIND I CLOSURE-ARGS :KEY (FUNCTION VARIABLE-CLOSURE-INDEX) :TEST (FUNCTION EQL)))) (WHEN (OR (NOT *CHILD-P*) VARIABLE) (EMIT (QUOTE DUP)) (EMIT-PUSH-CONSTANT-INT I) (EMIT-NEW +LISP-CLOSURE-BINDING+) (EMIT (QUOTE DUP)) (COND ((NULL VARIABLE) (ASSERT (NOT *CHILD-P*)) (EMIT (QUOTE ACONST_NULL))) ((VARIABLE-REGISTER VARIABLE) (ASSERT (NOT (EQL (VARIABLE-REGISTER VARIABLE) (COMPILAND-CLOSURE-REGISTER COMPILAND)))) (ALOAD (VARIABLE-REGISTER VARIABLE)) (SETF (VARIABLE-REGISTER VARIABLE) NIL)) ((VARIABLE-INDEX VARIABLE) (ALOAD (COMPILAND-ARGUMENT-REGISTER COMPILAND)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)) (SETF (VARIABLE-INDEX VARIABLE) NIL)) (T (ASSERT (NOT "Can't happen!!")))) (EMIT-INVOKESPECIAL-INIT +LISP-CLOSURE-BINDING+ (LIST +LISP-OBJECT+)) (EMIT (QUOTE AASTORE)))))) (WHEN *CLOSURE-VARIABLES* (AVER (NOT (NULL (COMPILAND-CLOSURE-REGISTER COMPILAND)))) (ASTORE (COMPILAND-CLOSURE-REGISTER COMPILAND)) (DFORMAT T "~S done moving arguments to closure array~%" (COMPILAND-NAME COMPILAND))) (WHEN *USING-ARG-ARRAY* (DOLIST (VARIABLE (COMPILAND-ARG-VARS COMPILAND)) (UNLESS (OR (VARIABLE-SPECIAL-P VARIABLE) (NULL (VARIABLE-INDEX VARIABLE)) (< (+ (VARIABLE-READS VARIABLE) (VARIABLE-WRITES VARIABLE)) 2)) (LET ((REGISTER (ALLOCATE-REGISTER NIL))) (ALOAD (COMPILAND-ARGUMENT-REGISTER COMPILAND)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)) (ASTORE REGISTER) (SETF (VARIABLE-REGISTER VARIABLE) REGISTER) (SETF (VARIABLE-INDEX VARIABLE) NIL))))) (WITH-SAVED-COMPILER-POLICY (PROCESS-OPTIMIZATION-DECLARATIONS BODY) (P2-COMPILAND-PROCESS-TYPE-DECLARATIONS BODY) (GENERATE-TYPE-CHECKS-FOR-VARIABLES (COMPILAND-ARG-VARS COMPILAND)) (DOLIST (VARIABLE (COMPILAND-ARG-VARS COMPILAND)) (P2-COMPILAND-UNBOX-VARIABLE VARIABLE)) (WHEN (SOME (FUNCTION VARIABLE-SPECIAL-P) (COMPILAND-ARG-VARS COMPILAND)) (SETF (COMPILAND-ENVIRONMENT-REGISTER COMPILAND) (ALLOCATE-REGISTER NIL)) (SAVE-DYNAMIC-ENVIRONMENT (COMPILAND-ENVIRONMENT-REGISTER COMPILAND)) (DOLIST (VARIABLE (COMPILAND-ARG-VARS COMPILAND)) (WHEN (VARIABLE-SPECIAL-P VARIABLE) (SETF (VARIABLE-BINDING-REGISTER VARIABLE) (ALLOCATE-REGISTER NIL)) (EMIT-PUSH-CURRENT-THREAD) (EMIT-PUSH-VARIABLE-NAME VARIABLE) (COND ((VARIABLE-REGISTER VARIABLE) (ALOAD (VARIABLE-REGISTER VARIABLE)) (SETF (VARIABLE-REGISTER VARIABLE) NIL)) ((VARIABLE-INDEX VARIABLE) (ALOAD (COMPILAND-ARGUMENT-REGISTER COMPILAND)) (EMIT-PUSH-CONSTANT-INT (VARIABLE-INDEX VARIABLE)) (EMIT (QUOTE AALOAD)) (SETF (VARIABLE-INDEX VARIABLE) NIL))) (EMIT-INVOKEVIRTUAL +LISP-THREAD+ "bindSpecial" (LIST +LISP-SYMBOL+ +LISP-OBJECT+) +LISP-SPECIAL-BINDING+) (ASTORE (VARIABLE-BINDING-REGISTER VARIABLE))))) (COMPILE-PROGN-BODY BODY (QUOTE STACK))) (WHEN (COMPILAND-ENVIRONMENT-REGISTER COMPILAND) (RESTORE-DYNAMIC-ENVIRONMENT (COMPILAND-ENVIRONMENT-REGISTER COMPILAND))) (UNLESS *CODE* (EMIT-PUSH-NIL)) (EMIT (QUOTE ARETURN)) (CHECK-FOR-UNUSED-VARIABLES (COMPILAND-ARG-VARS COMPILAND)) (DOLIST (LOCAL-FUNCTION (COMPILAND-CHILDREN COMPILAND)) (WHEN (COMPILAND-CLASS-FILE (LOCAL-FUNCTION-COMPILAND LOCAL-FUNCTION)) (DECLARE-LOCAL-FUNCTION LOCAL-FUNCTION))) (LET ((CODE *CODE*)) (SETF *CODE* NIL) (LET ((ARITY (COMPILAND-ARITY COMPILAND))) (WHEN (AND ARITY *USING-ARG-ARRAY*) (GENERATE-ARG-COUNT-CHECK ARITY))) (WHEN *HAIRY-ARGLIST-P* (ALOAD 0) (AVER (NOT (NULL (COMPILAND-ARGUMENT-REGISTER COMPILAND)))) (ALOAD (COMPILAND-ARGUMENT-REGISTER COMPILAND)) (EMIT (QUOTE ACONST_NULL)) (EMIT-INVOKEVIRTUAL *THIS-CLASS* "processArgs" (LIST +LISP-OBJECT-ARRAY+ +LISP-THREAD+) +LISP-OBJECT-ARRAY+) (ASTORE (COMPILAND-ARGUMENT-REGISTER COMPILAND))) (MAYBE-INITIALIZE-THREAD-VAR) (SETF *CODE* (NCONC CODE *CODE*))))) T)
     [java] ; (DEFUN COMPILE-TO-JVM-CLASS (COMPILAND) "Returns ?what? ### a jvm class-file object?" (LET* ((CLASS-FILE (COMPILAND-CLASS-FILE COMPILAND)) (ARGS (CADR (COMPILAND-P1-RESULT COMPILAND))) (*HAIRY-ARGLIST-P* (OR (MEMQ (QUOTE &KEY) ARGS) (MEMQ (QUOTE &OPTIONAL) ARGS) (MEMQ (QUOTE &REST) ARGS))) (*USING-ARG-ARRAY* (OR *HAIRY-ARGLIST-P* (< CALL-REGISTERS-LIMIT (LENGTH ARGS))))) (SETF (ABCL-CLASS-FILE-SUPERCLASS CLASS-FILE) (IF (OR *HAIRY-ARGLIST-P* (AND (NOT (NULL (COMPILAND-PARENT COMPILAND))) *CLOSURE-VARIABLES*)) +LISP-COMPILED-CLOSURE+ +LISP-COMPILED-PRIMITIVE+)) (UNLESS *HAIRY-ARGLIST-P* (SETF (COMPILAND-ARITY COMPILAND) (LENGTH ARGS))) (LET ((CLINIT (MAKE-STATIC-INITIALIZER CLASS-FILE))) (SETF (ABCL-CLASS-FILE-STATIC-INITIALIZER CLASS-FILE) CLINIT) (CLASS-ADD-METHOD CLASS-FILE CLINIT)) (LET ((CONSTRUCTOR (MAKE-CONSTRUCTOR CLASS-FILE (COMPILAND-NAME COMPILAND) ARGS))) (SETF (ABCL-CLASS-FILE-CONSTRUCTOR CLASS-FILE) CONSTRUCTOR) (CLASS-ADD-METHOD CLASS-FILE CONSTRUCTOR)) (LET* ((METHOD-ARG-TYPES (IF *USING-ARG-ARRAY* (LIST +LISP-OBJECT-ARRAY+) (LISP-OBJECT-ARG-TYPES (LENGTH ARGS)))) (METHOD (MAKE-JVM-METHOD "execute" +LISP-OBJECT+ METHOD-ARG-TYPES :FLAGS (QUOTE (:FINAL :PUBLIC))))) (CLASS-ADD-METHOD CLASS-FILE METHOD) (P2-COMPILAND COMPILAND METHOD))))
     [java] ; (DEFUN P2-WITH-INLINE-CODE (FORM TARGET REPRESENTATION) (DESTRUCTURING-BIND (&OPTIONAL TARGET-VAR REPR-VAR) (CADR FORM) (EVAL (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-APPEND (WHEN TARGET-VAR (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST TARGET-VAR TARGET))) (WHEN REPR-VAR (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST REPR-VAR REPRESENTATION)))) (CDDR FORM)))))
     [java] ; (DEFUN COMPILE-1 (COMPILAND STREAM) (LET ((*ALL-VARIABLES* NIL) (*CLOSURE-VARIABLES* NIL) (*UNDEFINED-VARIABLES* NIL) (*LOCAL-FUNCTIONS* NIL)) (P1-COMPILAND COMPILAND) (SETF *CLOSURE-VARIABLES* (REMOVE-IF (FUNCTION VARIABLE-SPECIAL-P) (REMOVE-IF-NOT (FUNCTION VARIABLE-USED-NON-LOCALLY-P) *ALL-VARIABLES*))) (LET ((I 0)) (DOLIST (VAR (REVERSE *CLOSURE-VARIABLES*)) (SETF (VARIABLE-CLOSURE-INDEX VAR) I) (DFORMAT T "var = ~S closure index = ~S~%" (VARIABLE-NAME VAR) (VARIABLE-CLOSURE-INDEX VAR)) (INCF I))) (ASSERT (= 0 (LENGTH (REMOVE-IF (COMPLEMENT (FUNCTION VARIABLE-REFERENCES)) (REMOVE-IF (FUNCTION VARIABLE-REFERENCES-ALLOWED-P) *VISIBLE-VARIABLES*))))) (WITH-CLASS-FILE (COMPILAND-CLASS-FILE COMPILAND) (COMPILE-TO-JVM-CLASS COMPILAND) (FINISH-CLASS (COMPILAND-CLASS-FILE COMPILAND) STREAM))))
     [java] ; (DEFVAR *COMPILER-ERROR-BAILOUT*)
     [java] ; (DEFUN MAKE-COMPILER-ERROR-FORM (FORM CONDITION) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (CADR FORM) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE PROGRAM-ERROR)) (QUOTE :FORMAT-CONTROL) "Program error while compiling ~a" (QUOTE :FORMAT-ARGUMENTS) (SYSTEM::BACKQ-LIST* (QUOTE IF) CONDITION (SYSTEM::BACKQ-LIST (QUOTE LIST) (SYSTEM::BACKQ-LIST (QUOTE APPLY) (QUOTE (QUOTE FORMAT)) NIL (SLOT-VALUE CONDITION (QUOTE SYSTEM::FORMAT-CONTROL)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SLOT-VALUE CONDITION (QUOTE SYSTEM::FORMAT-ARGUMENTS))))) (QUOTE ((LIST "a form")))))))
     [java] ; (DEFUN COMPILE-DEFUN (NAME FORM ENVIRONMENT FILESPEC STREAM *DECLARE-INLINE*) "Compiles a lambda expression `form'. If `filespec' is NIL,
     [java] a random Java class name is generated, if it is non-NIL, it's used
     [java] to derive a Java class name from.
     [java]
     [java] Returns the a abcl-class-file structure containing the description of the
     [java] generated class." (AVER (EQ (CAR FORM) (QUOTE LAMBDA))) (CATCH (QUOTE COMPILE-DEFUN-ABORT) (FLET ((COMPILER-BAILOUT (&OPTIONAL CONDITION) (LET ((CLASS-FILE (MAKE-ABCL-CLASS-FILE :PATHNAME FILESPEC)) (ERROR-FORM (MAKE-COMPILER-ERROR-FORM FORM CONDITION))) (COMPILE-1 (MAKE-COMPILAND :NAME NAME :LAMBDA-EXPRESSION ERROR-FORM :CLASS-FILE CLASS-FILE) STREAM) CLASS-FILE))) (LET* ((CLASS-FILE (MAKE-ABCL-CLASS-FILE :PATHNAME FILESPEC)) (*COMPILER-ERROR-BAILOUT* (FUNCTION COMPILER-BAILOUT)) (*COMPILE-FILE-ENVIRONMENT* ENVIRONMENT) (PRECOMPILED-FORM (PRECOMPILER:PRECOMPILE-FORM FORM T ENVIRONMENT))) (COMPILE-1 (MAKE-COMPILAND :NAME NAME :LAMBDA-EXPRESSION PRECOMPILED-FORM :CLASS-FILE CLASS-FILE) STREAM) CLASS-FILE))))
     [java] ; (DEFVAR *CATCH-ERRORS* T)
     [java] ; (DEFVAR *LAST-ERROR-CONTEXT* NIL)
     [java] ; (DEFUN NOTE-ERROR-CONTEXT NIL (LET ((CONTEXT *COMPILER-ERROR-CONTEXT*)) (WHEN (AND CONTEXT (NEQ CONTEXT *LAST-ERROR-CONTEXT*)) (FRESH-LINE *ERROR-OUTPUT*) (PRINC "; in " *ERROR-OUTPUT*) (LET ((*PRINT-LENGTH* 2) (*PRINT-LEVEL* 2) (*PRINT-PRETTY* NIL)) (PRIN1 CONTEXT *ERROR-OUTPUT*)) (TERPRI *ERROR-OUTPUT*) (TERPRI *ERROR-OUTPUT*) (SETF *LAST-ERROR-CONTEXT* CONTEXT))))
     [java] ; (DEFVAR *RESIGNAL-COMPILER-WARNINGS* NIL "This generalized boolean JVM:*RESIGNAL-COMPILER-WARNINGS* controls whether the compiler signals dignaostics to the condition system or merely outputs them to the standard reporting stream.
     [java]
     [java] The default is to not signal.
     [java]
     [java] Could arguably better named as *SIGNAL-COMPILE-WARNINGS-P*.")
     [java] ; (DEFUN HANDLE-WARNING (CONDITION) (COND (*RESIGNAL-COMPILER-WARNINGS* (SIGNAL CONDITION)) (T (UNLESS *SUPPRESS-COMPILER-WARNINGS* (FRESH-LINE *ERROR-OUTPUT*) (NOTE-ERROR-CONTEXT) (FORMAT *ERROR-OUTPUT* "; Caught ~A:~%;   ~A~2%" (TYPE-OF CONDITION) CONDITION)) (MUFFLE-WARNING))))
     [java] ; (DEFUN HANDLE-COMPILER-ERROR (CONDITION) (FRESH-LINE *ERROR-OUTPUT*) (NOTE-ERROR-CONTEXT) (FORMAT *ERROR-OUTPUT* "; Caught ERROR:~%;   ~A~2%" CONDITION) (THROW (QUOTE COMPILE-DEFUN-ABORT) (FUNCALL *COMPILER-ERROR-BAILOUT* CONDITION)))
     [java] ; (DEFVAR *IN-COMPILATION-UNIT* NIL)
     [java] ; (DEFMACRO WITH-COMPILATION-UNIT (OPTIONS &BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE %WITH-COMPILATION-UNIT) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) NIL BODY) OPTIONS))
     [java] ; (DEFUN %WITH-COMPILATION-UNIT (FN &KEY OVERRIDE) (IF (AND *IN-COMPILATION-UNIT* (NOT OVERRIDE)) (FUNCALL FN) (LET ((STYLE-WARNINGS 0) (WARNINGS 0) (ERRORS 0) (*DEFINED-FUNCTIONS* NIL) (*UNDEFINED-FUNCTIONS* NIL) (*IN-COMPILATION-UNIT* T)) (UNWIND-PROTECT (HANDLER-BIND ((STYLE-WARNING (FUNCTION (LAMBDA (C) (INCF STYLE-WARNINGS) (HANDLE-WARNING C)))) (WARNING (FUNCTION (LAMBDA (C) (INCF WARNINGS) (HANDLE-WARNING C)))) (COMPILER-ERROR (FUNCTION (LAMBDA (C) (INCF ERRORS) (HANDLE-COMPILER-ERROR C))))) (FUNCALL FN)) (UNLESS (OR (AND *SUPPRESS-COMPILER-WARNINGS* (ZEROP ERRORS)) (AND (ZEROP (+ ERRORS WARNINGS STYLE-WARNINGS)) (NULL *UNDEFINED-FUNCTIONS*))) (FORMAT *ERROR-OUTPUT* "~%; Compilation unit finished~%") (UNLESS (ZEROP ERRORS) (FORMAT *ERROR-OUTPUT* ";   Caught ~D ERROR condition~P~%" ERRORS ERRORS)) (UNLESS *SUPPRESS-COMPILER-WARNINGS* (UNLESS (ZEROP WARNINGS) (FORMAT *ERROR-OUTPUT* ";   Caught ~D WARNING condition~P~%" WARNINGS WARNINGS)) (UNLESS (ZEROP STYLE-WARNINGS) (FORMAT *ERROR-OUTPUT* ";   Caught ~D STYLE-WARNING condition~P~%" STYLE-WARNINGS STYLE-WARNINGS)) (WHEN *UNDEFINED-FUNCTIONS* (FORMAT *ERROR-OUTPUT* ";   The following functions were used but not defined:~%") (DOLIST (NAME *UNDEFINED-FUNCTIONS*) (FORMAT *ERROR-OUTPUT* ";     ~S~%" NAME)))) (TERPRI *ERROR-OUTPUT*))))))
     [java] ; (DEFUN %JVM-COMPILE (NAME DEFINITION EXPR ENV) (LET* (COMPILED-FUNCTION (*MEMORY-CLASS-LOADER* (SYSTEM::MAKE-MEMORY-CLASS-LOADER))) (WITH-COMPILATION-UNIT NIL (WITH-SAVED-COMPILER-POLICY (SETF COMPILED-FUNCTION (WITH-OPEN-STREAM (S (SYSTEM::%MAKE-BYTE-ARRAY-OUTPUT-STREAM)) (LET* ((CLASS-FILE (COMPILE-DEFUN NAME EXPR ENV NIL S NIL)) (BYTES (PROGN (FINISH-OUTPUT S) (SYSTEM::%GET-OUTPUT-STREAM-BYTES S))) (CLASS-NAME (CLASS-NAME-INTERNAL (ABCL-CLASS-FILE-CLASS-NAME CLASS-FILE)))) (SYSTEM::PUT-MEMORY-FUNCTION *MEMORY-CLASS-LOADER* CLASS-NAME BYTES) (SYSTEM::GET-MEMORY-FUNCTION *MEMORY-CLASS-LOADER* CLASS-NAME)))))) (WHEN (AND NAME (FUNCTIONP COMPILED-FUNCTION)) (SYSTEM::SET-FUNCTION-DEFINITION NAME COMPILED-FUNCTION DEFINITION)) (OR NAME COMPILED-FUNCTION)))
     [java] ; (DEFUN JVM-COMPILE (NAME &OPTIONAL DEFINITION) (UNLESS DEFINITION (RESOLVE NAME) (SETF DEFINITION (FDEFINITION NAME))) (WHEN (COMPILED-FUNCTION-P DEFINITION) (RETURN-FROM JVM-COMPILE (VALUES (OR NAME DEFINITION) NIL NIL))) (WHEN (TYPEP DEFINITION (QUOTE STANDARD-GENERIC-FUNCTION)) (RETURN-FROM JVM-COMPILE (VALUES (OR NAME DEFINITION) NIL NIL))) (LET ((CATCH-ERRORS *CATCH-ERRORS*) (WARNINGS-P NIL) (FAILURE-P NIL) (*PACKAGE* (OR (AND NAME (SYMBOL-PACKAGE NAME)) *PACKAGE*)) (EXPRESSION DEFINITION) (*FILE-COMPILATION* NIL) (*VISIBLE-VARIABLES* NIL) (*LOCAL-FUNCTIONS* NIL) (*PATHNAMES-GENERATOR* (CONSTANTLY NIL)) ENVIRONMENT) (UNLESS (AND (CONSP DEFINITION) (EQ (CAR DEFINITION) (QUOTE LAMBDA))) (LET ((FUNCTION DEFINITION)) (WHEN (TYPEP DEFINITION (QUOTE MOP:FUNCALLABLE-STANDARD-OBJECT)) (SETF FUNCTION (MOP::FUNCALLABLE-INSTANCE-FUNCTION FUNCTION))) (MULTIPLE-VALUE-SETQ (EXPRESSION ENVIRONMENT) (FUNCTION-LAMBDA-EXPRESSION FUNCTION)))) (UNLESS EXPRESSION (ERROR "Can't find a definition for ~S." DEFINITION)) (WHEN ENVIRONMENT (DOLIST (VAR (REVERSE (ENVIRONMENT-ALL-VARIABLES ENVIRONMENT))) (PUSH (MAKE-VARIABLE :NAME (IF (SYMBOLP VAR) VAR (CAR VAR)) :SPECIAL-P (SYMBOLP VAR) :ENVIRONMENT ENVIRONMENT :REFERENCES-ALLOWED-P (NOT (SYMBOL-MACRO-P (CDR VAR))) :COMPILAND NIL) *VISIBLE-VARIABLES*)) (DOLIST (FUN (REVERSE (ENVIRONMENT-ALL-FUNCTIONS ENVIRONMENT))) (PUSH (MAKE-LOCAL-FUNCTION :NAME (CAR FUN) :REFERENCES-ALLOWED-P (NOT (MACRO-FUNCTION-P (CDR FUN))) :ENVIRONMENT ENVIRONMENT) *LOCAL-FUNCTIONS*))) (HANDLER-BIND ((COMPILER-UNSUPPORTED-FEATURE-ERROR (FUNCTION (LAMBDA (C) (WHEN CATCH-ERRORS (FRESH-LINE) (SYSTEM::%FORMAT T "; UNSUPPORTED FEATURE: ~A~%" C) (SYSTEM::%FORMAT T "; Unable to compile ~S.~%" (OR NAME "top-level form")) (RETURN-FROM JVM-COMPILE (PRECOMPILE NAME DEFINITION)))))) (STYLE-WARNING (FUNCTION (LAMBDA (C) (DECLARE (IGNORE C)) (SETF WARNINGS-P T) NIL))) ((OR WARNING COMPILER-ERROR) (FUNCTION (LAMBDA (C) (DECLARE (IGNORE C)) (SETF WARNINGS-P T FAILURE-P T) NIL)))) (VALUES (%JVM-COMPILE NAME DEFINITION EXPRESSION ENVIRONMENT) WARNINGS-P FAILURE-P))))
     [java] ; (DEFVAR *FILE-COMPILATION* NIL)
     [java] ; (DEFVAR *PATHNAMES-GENERATOR* (FUNCTION MAKE-TEMP-FILE))
     [java] ; (DEFUN COMPILE (NAME &OPTIONAL DEFINITION) (JVM-COMPILE NAME DEFINITION))
     [java] ; (DEFMACRO WITH-FILE-COMPILATION (&BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE LET) (QUOTE ((*FILE-COMPILATION* T) (*PATHNAMES-GENERATOR* (FUNCTION SYSTEM::NEXT-CLASSFILE)))) BODY))
     [java] ; (DEFUN INITIALIZE-P2-HANDLERS NIL (MAPC (FUNCTION INSTALL-P2-HANDLER) (QUOTE (DECLARE MULTIPLE-VALUE-CALL MULTIPLE-VALUE-LIST MULTIPLE-VALUE-PROG1 NTH PROGN))) (INSTALL-P2-HANDLER (QUOTE %LDB) (QUOTE P2-%LDB)) (INSTALL-P2-HANDLER (QUOTE *) (QUOTE P2-TIMES)) (INSTALL-P2-HANDLER (QUOTE +) (QUOTE P2-PLUS)) (INSTALL-P2-HANDLER (QUOTE -) (QUOTE P2-MINUS)) (INSTALL-P2-HANDLER (QUOTE <) (QUOTE P2-NUMERIC-COMPARISON)) (INSTALL-P2-HANDLER (QUOTE <=) (QUOTE P2-NUMERIC-COMPARISON)) (INSTALL-P2-HANDLER (QUOTE =) (QUOTE P2-NUMERIC-COMPARISON)) (INSTALL-P2-HANDLER (QUOTE >) (QUOTE P2-NUMERIC-COMPARISON)) (INSTALL-P2-HANDLER (QUOTE >=) (QUOTE P2-NUMERIC-COMPARISON)) (INSTALL-P2-HANDLER (QUOTE AND) (QUOTE P2-AND)) (INSTALL-P2-HANDLER (QUOTE AREF) (QUOTE P2-AREF)) (INSTALL-P2-HANDLER (QUOTE ASET) (QUOTE P2-ASET)) (INSTALL-P2-HANDLER (QUOTE ASH) (QUOTE P2-ASH)) (INSTALL-P2-HANDLER (QUOTE ATOM) (QUOTE P2-ATOM)) (INSTALL-P2-HANDLER (QUOTE BIT-VECTOR-P) (QUOTE P2-BIT-VECTOR-P)) (INSTALL-P2-HANDLER (QUOTE CAR) (QUOTE P2-CAR)) (INSTALL-P2-HANDLER (QUOTE CDR) (QUOTE P2-CDR)) (INSTALL-P2-HANDLER (QUOTE CHAR) (QUOTE P2-CHAR/SCHAR)) (INSTALL-P2-HANDLER (QUOTE CHAR-CODE) (QUOTE P2-CHAR-CODE)) (INSTALL-P2-HANDLER (QUOTE JAVA:JCLASS) (QUOTE P2-JAVA-JCLASS)) (INSTALL-P2-HANDLER (QUOTE JAVA:JCONSTRUCTOR) (QUOTE P2-JAVA-JCONSTRUCTOR)) (INSTALL-P2-HANDLER (QUOTE JAVA:JMETHOD) (QUOTE P2-JAVA-JMETHOD)) (INSTALL-P2-HANDLER (QUOTE CHAR=) (QUOTE P2-CHAR=)) (INSTALL-P2-HANDLER (QUOTE CHARACTERP) (QUOTE P2-CHARACTERP)) (INSTALL-P2-HANDLER (QUOTE COERCE-TO-FUNCTION) (QUOTE P2-COERCE-TO-FUNCTION)) (INSTALL-P2-HANDLER (QUOTE CONS) (QUOTE P2-CONS)) (INSTALL-P2-HANDLER (QUOTE SYSTEM::BACKQ-CONS) (QUOTE P2-CONS)) (INSTALL-P2-HANDLER (QUOTE CONSP) (QUOTE P2-CONSP)) (INSTALL-P2-HANDLER (QUOTE DELETE) (QUOTE P2-DELETE)) (INSTALL-P2-HANDLER (QUOTE ELT) (QUOTE P2-ELT)) (INSTALL-P2-HANDLER (QUOTE EQ) (QUOTE P2-EQ/NEQ)) (INSTALL-P2-HANDLER (QUOTE EQL) (QUOTE P2-EQL)) (INSTALL-P2-HANDLER (QUOTE EVAL-WHEN) (QUOTE P2-EVAL-WHEN)) (INSTALL-P2-HANDLER (QUOTE FIND-CLASS) (QUOTE P2-FIND-CLASS)) (INSTALL-P2-HANDLER (QUOTE FIXNUMP) (QUOTE P2-FIXNUMP)) (INSTALL-P2-HANDLER (QUOTE FUNCALL) (QUOTE P2-FUNCALL)) (INSTALL-P2-HANDLER (QUOTE FUNCTION) (QUOTE P2-FUNCTION)) (INSTALL-P2-HANDLER (QUOTE GENSYM) (QUOTE P2-GENSYM)) (INSTALL-P2-HANDLER (QUOTE GET) (QUOTE P2-GET)) (INSTALL-P2-HANDLER (QUOTE GETF) (QUOTE P2-GETF)) (INSTALL-P2-HANDLER (QUOTE GETHASH) (QUOTE P2-GETHASH)) (INSTALL-P2-HANDLER (QUOTE GETHASH1) (QUOTE P2-GETHASH)) (INSTALL-P2-HANDLER (QUOTE GO) (QUOTE P2-GO)) (INSTALL-P2-HANDLER (QUOTE IF) (QUOTE P2-IF)) (INSTALL-P2-HANDLER (QUOTE SYSTEM::%LENGTH) (QUOTE P2-LENGTH)) (INSTALL-P2-HANDLER (QUOTE LIST) (QUOTE P2-LIST)) (INSTALL-P2-HANDLER (QUOTE SYSTEM::BACKQ-LIST) (QUOTE P2-LIST)) (INSTALL-P2-HANDLER (QUOTE LIST*) (QUOTE P2-LIST*)) (INSTALL-P2-HANDLER (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE P2-LIST*)) (INSTALL-P2-HANDLER (QUOTE LOAD-TIME-VALUE) (QUOTE P2-LOAD-TIME-VALUE)) (INSTALL-P2-HANDLER (QUOTE LOGAND) (QUOTE P2-LOGAND)) (INSTALL-P2-HANDLER (QUOTE LOGIOR) (QUOTE P2-LOGIOR)) (INSTALL-P2-HANDLER (QUOTE LOGNOT) (QUOTE P2-LOGNOT)) (INSTALL-P2-HANDLER (QUOTE LOGXOR) (QUOTE P2-LOGXOR)) (INSTALL-P2-HANDLER (QUOTE MAX) (QUOTE P2-MIN/MAX)) (INSTALL-P2-HANDLER (QUOTE MEMQ) (QUOTE P2-MEMQ)) (INSTALL-P2-HANDLER (QUOTE MEMQL) (QUOTE P2-MEMQL)) (INSTALL-P2-HANDLER (QUOTE MIN) (QUOTE P2-MIN/MAX)) (INSTALL-P2-HANDLER (QUOTE MOD) (QUOTE P2-MOD)) (INSTALL-P2-HANDLER (QUOTE NEQ) (QUOTE P2-EQ/NEQ)) (INSTALL-P2-HANDLER (QUOTE NOT) (QUOTE P2-NOT/NULL)) (INSTALL-P2-HANDLER (QUOTE NTHCDR) (QUOTE P2-NTHCDR)) (INSTALL-P2-HANDLER (QUOTE NULL) (QUOTE P2-NOT/NULL)) (INSTALL-P2-HANDLER (QUOTE OR) (QUOTE P2-OR)) (INSTALL-P2-HANDLER (QUOTE PACKAGEP) (QUOTE P2-PACKAGEP)) (INSTALL-P2-HANDLER (QUOTE PUTHASH) (QUOTE P2-PUTHASH)) (INSTALL-P2-HANDLER (QUOTE QUOTE) (QUOTE P2-QUOTE)) (INSTALL-P2-HANDLER (QUOTE READ-LINE) (QUOTE P2-READ-LINE)) (INSTALL-P2-HANDLER (QUOTE READTABLEP) (QUOTE P2-READTABLEP)) (INSTALL-P2-HANDLER (QUOTE RETURN-FROM) (QUOTE P2-RETURN-FROM)) (INSTALL-P2-HANDLER (QUOTE RPLACD) (QUOTE P2-RPLACD)) (INSTALL-P2-HANDLER (QUOTE SCHAR) (QUOTE P2-CHAR/SCHAR)) (INSTALL-P2-HANDLER (QUOTE SET) (QUOTE P2-SET)) (INSTALL-P2-HANDLER (QUOTE SET-CAR) (QUOTE P2-SET-CAR/CDR)) (INSTALL-P2-HANDLER (QUOTE SET-CDR) (QUOTE P2-SET-CAR/CDR)) (INSTALL-P2-HANDLER (QUOTE SET-CHAR) (QUOTE P2-SET-CHAR/SCHAR)) (INSTALL-P2-HANDLER (QUOTE SET-SCHAR) (QUOTE P2-SET-CHAR/SCHAR)) (INSTALL-P2-HANDLER (QUOTE SET-STD-SLOT-VALUE) (QUOTE P2-SET-STD-SLOT-VALUE)) (INSTALL-P2-HANDLER (QUOTE SETQ) (QUOTE P2-SETQ)) (INSTALL-P2-HANDLER (QUOTE SIMPLE-VECTOR-P) (QUOTE P2-SIMPLE-VECTOR-P)) (INSTALL-P2-HANDLER (QUOTE STD-SLOT-VALUE) (QUOTE P2-STD-SLOT-VALUE)) (INSTALL-P2-HANDLER (QUOTE STREAM-ELEMENT-TYPE) (QUOTE P2-STREAM-ELEMENT-TYPE)) (INSTALL-P2-HANDLER (QUOTE STRINGP) (QUOTE P2-STRINGP)) (INSTALL-P2-HANDLER (QUOTE STRUCTURE-REF) (QUOTE P2-STRUCTURE-REF)) (INSTALL-P2-HANDLER (QUOTE STRUCTURE-SET) (QUOTE P2-STRUCTURE-SET)) (INSTALL-P2-HANDLER (QUOTE SVREF) (QUOTE P2-SVREF)) (INSTALL-P2-HANDLER (QUOTE SVSET) (QUOTE P2-SVSET)) (INSTALL-P2-HANDLER (QUOTE SXHASH) (QUOTE P2-SXHASH)) (INSTALL-P2-HANDLER (QUOTE SYMBOL-NAME) (QUOTE P2-SYMBOL-NAME)) (INSTALL-P2-HANDLER (QUOTE SYMBOL-PACKAGE) (QUOTE P2-SYMBOL-PACKAGE)) (INSTALL-P2-HANDLER (QUOTE SYMBOL-VALUE) (QUOTE P2-SYMBOL-VALUE)) (INSTALL-P2-HANDLER (QUOTE SYMBOLP) (QUOTE P2-SYMBOLP)) (INSTALL-P2-HANDLER (QUOTE THE) (QUOTE P2-THE)) (INSTALL-P2-HANDLER (QUOTE THROW) (QUOTE P2-THROW)) (INSTALL-P2-HANDLER (QUOTE TRULY-THE) (QUOTE P2-TRULY-THE)) (INSTALL-P2-HANDLER (QUOTE TRUNCATE) (QUOTE P2-TRUNCATE)) (INSTALL-P2-HANDLER (QUOTE VALUES) (QUOTE P2-VALUES)) (INSTALL-P2-HANDLER (QUOTE VECTORP) (QUOTE P2-VECTORP)) (INSTALL-P2-HANDLER (QUOTE VECTOR-PUSH-EXTEND) (QUOTE P2-VECTOR-PUSH-EXTEND)) (INSTALL-P2-HANDLER (QUOTE WRITE-8-BITS) (QUOTE P2-WRITE-8-BITS)) (INSTALL-P2-HANDLER (QUOTE ZEROP) (QUOTE P2-ZEROP)) (INSTALL-P2-HANDLER (QUOTE WITH-INLINE-CODE) (QUOTE P2-WITH-INLINE-CODE)) T)
     [java] ; (DEFVAR *ENABLE-AUTOCOMPILE*)
     [java] ; (DEFUN AUTOCOMPILE (FUNCTION) (WHEN *ENABLE-AUTOCOMPILE* (LET ((*ENABLE-AUTOCOMPILE* NIL)) (VALUES (COMPILE NIL FUNCTION)))))
     [java] ; (SETF *ENABLE-AUTOCOMPILE* T)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass2.abcl (25.756 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass2.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-pass2.abcl (2.526 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-class-file.lisp ...
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DEFUN MAP-PRIMITIVE-TYPE (TYPE) "Maps a symbolic primitive type name to its Java string representation." (CASE TYPE (:INT "I") (:LONG "J") (:FLOAT "F") (:DOUBLE "D") (:BOOLEAN "Z") (:CHAR "C") (:BYTE "B") (:SHORT "S") ((NIL :VOID) "V")))
     [java] ; (DEFUN PRETTY-CLASS (TYPE &OPTIONAL (DEFAULT-PACKAGE "")) (LET* ((P-LEN (1+ (LENGTH DEFAULT-PACKAGE))) (LEN (LENGTH TYPE)) (CNT (WHEN (< P-LEN LEN) (COUNT #\/ TYPE :START P-LEN))) (TYPE (IF (AND CNT (= 0 CNT)) (SUBSEQ TYPE P-LEN LEN) (SUBSTITUTE #\. #\/ TYPE)))) TYPE))
     [java] ; (DEFUN PRETTY-TYPE (TYPE &OPTIONAL (DEFAULT-PACKAGE "")) (COND ((EQL #\I TYPE) "int") ((EQL #\J TYPE) "long") ((EQL #\F TYPE) "float") ((EQL #\D TYPE) "double") ((EQL #\Z TYPE) "boolean") ((EQL #\C TYPE) "char") ((EQL #\B TYPE) "byte") ((EQL #\S TYPE) "short") ((EQL #\V TYPE) "void") ((STRINGP TYPE) (PRETTY-CLASS (SUBSEQ TYPE 1 (1- (LENGTH TYPE))) DEFAULT-PACKAGE))))
     [java] ; (DEFSTRUCT (JVM-CLASS-NAME (:CONC-NAME CLASS-) (:CONSTRUCTOR %MAKE-JVM-CLASS-NAME) (:PRINT-OBJECT %PRINT-JVM-CLASS-NAME)) "Used for class identification.
     [java]
     [java] The caller should instantiate only one `class-name' per class, as they are
     [java] used as class identifiers and compared using EQ.
     [java]
     [java] Some instructions need a class argument, others need a reference identifier.
     [java] This class is used to abstract from the difference." NAME-INTERNAL REF ARRAY-CLASS)
     [java] ; (DEFUN %PRINT-JVM-CLASS-NAME (NAME STREAM) (PRINT-UNREADABLE-OBJECT (NAME STREAM :TYPE T) (WRITE-STRING (CLASS-NAME-INTERNAL NAME) STREAM)))
     [java] ; (DEFUN MAKE-JVM-CLASS-NAME (NAME) "Creates a `class-name' structure for the class or interface `name'.
     [java]
     [java] `name' should be specified using Java representation, which is converted
     [java] to 'internal' (JVM) representation by this function." (SETF NAME (SUBSTITUTE #\/ #\. NAME)) (%MAKE-JVM-CLASS-NAME :NAME-INTERNAL NAME :REF (CONCATENATE (QUOTE STRING) "L" NAME ";")))
     [java] ; (DEFUN CLASS-ARRAY (CLASS-NAME) "Returns a class-name representing an array of `class-name'.
     [java] For multi-dimensional arrays, call this function multiple times, using
     [java] its own result.
     [java]
     [java] This function can be called multiple times on the same `class-name' without
     [java] violating the 'only one instance' requirement: the returned value is cached
     [java] and used on successive calls." (UNLESS (CLASS-ARRAY-CLASS CLASS-NAME) (LET ((NAME-AND-REF (CONCATENATE (QUOTE STRING) "[" (CLASS-REF CLASS-NAME)))) (SETF (CLASS-ARRAY-CLASS CLASS-NAME) (%MAKE-JVM-CLASS-NAME :NAME-INTERNAL NAME-AND-REF :REF NAME-AND-REF)))) (CLASS-ARRAY-CLASS CLASS-NAME))
     [java] ; (DEFMACRO DEFINE-CLASS-NAME (SYMBOL JAVA-DOTTED-NAME &OPTIONAL DOCUMENTATION) "Convenience macro to define constants for `class-name' structures,
     [java] initialized from the `java-dotted-name'." (SYSTEM::BACKQ-LIST (QUOTE DEFCONSTANT) SYMBOL (SYSTEM::BACKQ-LIST (QUOTE MAKE-JVM-CLASS-NAME) JAVA-DOTTED-NAME) DOCUMENTATION))
     [java] ; (DEFINE-CLASS-NAME +JAVA-CLASS+ "java.lang.Class")
     [java] ; (DEFINE-CLASS-NAME +JAVA-OBJECT+ "java.lang.Object")
     [java] ; (DEFINE-CLASS-NAME +JAVA-STRING+ "java.lang.String")
     [java] ; (DEFINE-CLASS-NAME +JAVA-SYSTEM+ "java.lang.System")
     [java] ; (DEFINE-CLASS-NAME +JAVA-STACK-OVERFLOW+ "java.lang.StackOverflowError")
     [java] ; (DEFINE-CLASS-NAME +JAVA-OUT-OF-MEMORY+ "java.lang.OutOfMemoryError")
     [java] ; (DEFINE-CLASS-NAME +JAVA-IO-INPUT-STREAM+ "java.io.InputStream")
     [java] ; (DEFINE-CLASS-NAME +JAVA-UTIL-COLLECTION+ "java.util.Collection")
     [java] ; (DEFINE-CLASS-NAME +BLOCK-LISP-OBJECT+ "org.armedbear.lisp.BlockLispObject")
     [java] ; (DEFINE-CLASS-NAME +LISP-OBJECT+ "org.armedbear.lisp.LispObject")
     [java] ; (DEFCONSTANT +LISP-OBJECT-ARRAY+ (CLASS-ARRAY +LISP-OBJECT+))
     [java] ; (DEFINE-CLASS-NAME +LISP-SIMPLE-STRING+ "org.armedbear.lisp.SimpleString")
     [java] ; (DEFINE-CLASS-NAME +LISP+ "org.armedbear.lisp.Lisp")
     [java] ; (DEFINE-CLASS-NAME +LISP-NIL+ "org.armedbear.lisp.Nil")
     [java] ; (DEFINE-CLASS-NAME +LISP-CLASS+ "org.armedbear.lisp.LispClass")
     [java] ; (DEFINE-CLASS-NAME +LISP-SYMBOL+ "org.armedbear.lisp.Symbol")
     [java] ; (DEFINE-CLASS-NAME +LISP-THREAD+ "org.armedbear.lisp.LispThread")
     [java] ; (DEFINE-CLASS-NAME +LISP-CLOSURE-BINDING+ "org.armedbear.lisp.ClosureBinding")
     [java] ; (DEFCONSTANT +CLOSURE-BINDING-ARRAY+ (CLASS-ARRAY +LISP-CLOSURE-BINDING+))
     [java] ; (DEFINE-CLASS-NAME +LISP-INTEGER+ "org.armedbear.lisp.LispInteger")
     [java] ; (DEFINE-CLASS-NAME +LISP-FIXNUM+ "org.armedbear.lisp.Fixnum")
     [java] ; (DEFCONSTANT +LISP-FIXNUM-ARRAY+ (CLASS-ARRAY +LISP-FIXNUM+))
     [java] ; (DEFINE-CLASS-NAME +LISP-BIGNUM+ "org.armedbear.lisp.Bignum")
     [java] ; (DEFINE-CLASS-NAME +LISP-SINGLE-FLOAT+ "org.armedbear.lisp.SingleFloat")
     [java] ; (DEFINE-CLASS-NAME +LISP-DOUBLE-FLOAT+ "org.armedbear.lisp.DoubleFloat")
     [java] ; (DEFINE-CLASS-NAME +LISP-CONS+ "org.armedbear.lisp.Cons")
     [java] ; (DEFINE-CLASS-NAME +LISP-LOAD+ "org.armedbear.lisp.Load")
     [java] ; (DEFINE-CLASS-NAME +LISP-CHARACTER+ "org.armedbear.lisp.LispCharacter")
     [java] ; (DEFCONSTANT +LISP-CHARACTER-ARRAY+ (CLASS-ARRAY +LISP-CHARACTER+))
     [java] ; (DEFINE-CLASS-NAME +LISP-STRUCTURE-OBJECT+ "org.armedbear.lisp.StructureObject")
     [java] ; (DEFINE-CLASS-NAME +LISP-SIMPLE-VECTOR+ "org.armedbear.lisp.SimpleVector")
     [java] ; (DEFINE-CLASS-NAME +LISP-ABSTRACT-STRING+ "org.armedbear.lisp.AbstractString")
     [java] ; (DEFINE-CLASS-NAME +LISP-ABSTRACT-VECTOR+ "org.armedbear.lisp.AbstractVector")
     [java] ; (DEFINE-CLASS-NAME +LISP-ABSTRACT-BIT-VECTOR+ "org.armedbear.lisp.AbstractBitVector")
     [java] ; (DEFINE-CLASS-NAME +LISP-ENVIRONMENT+ "org.armedbear.lisp.Environment")
     [java] ; (DEFINE-CLASS-NAME +LISP-SPECIAL-BINDING+ "org.armedbear.lisp.SpecialBinding")
     [java] ; (DEFINE-CLASS-NAME +LISP-SPECIAL-BINDINGS-MARK+ "org.armedbear.lisp.SpecialBindingsMark")
     [java] ; (DEFINE-CLASS-NAME +LISP-THROW+ "org.armedbear.lisp.Throw")
     [java] ; (DEFINE-CLASS-NAME +LISP-RETURN+ "org.armedbear.lisp.Return")
     [java] ; (DEFINE-CLASS-NAME +LISP-GO+ "org.armedbear.lisp.Go")
     [java] ; (DEFINE-CLASS-NAME +LISP-PRIMITIVE+ "org.armedbear.lisp.Primitive")
     [java] ; (DEFINE-CLASS-NAME +LISP-COMPILED-PRIMITIVE+ "org.armedbear.lisp.CompiledPrimitive")
     [java] ; (DEFINE-CLASS-NAME +LISP-EQL-HASH-TABLE+ "org.armedbear.lisp.EqlHashTable")
     [java] ; (DEFINE-CLASS-NAME +LISP-HASH-TABLE+ "org.armedbear.lisp.HashTable")
     [java] ; (DEFINE-CLASS-NAME +LISP-PACKAGE+ "org.armedbear.lisp.Package")
     [java] ; (DEFINE-CLASS-NAME +LISP-READTABLE+ "org.armedbear.lisp.Readtable")
     [java] ; (DEFINE-CLASS-NAME +LISP-STREAM+ "org.armedbear.lisp.Stream")
     [java] ; (DEFINE-CLASS-NAME +LISP-OPERATOR+ "org.armedbear.lisp.Operator")
     [java] ; (DEFINE-CLASS-NAME +LISP-CLOSURE+ "org.armedbear.lisp.Closure")
     [java] ; (DEFINE-CLASS-NAME +LISP-COMPILED-CLOSURE+ "org.armedbear.lisp.CompiledClosure")
     [java] ; (DEFINE-CLASS-NAME +ARGUMENT-LIST-PROCESSOR+ "org.armedbear.lisp.ArgumentListProcessor")
     [java] ; (DEFINE-CLASS-NAME +ALP-REQUIRED-PARAMETER+ "org.armedbear.lisp.ArgumentListProcessor$RequiredParam")
     [java] ; (DEFINE-CLASS-NAME +ALP-OPTIONAL-PARAMETER+ "org.armedbear.lisp.ArgumentListProcessor$OptionalParam")
     [java] ; (DEFINE-CLASS-NAME +ALP-KEYWORD-PARAMETER+ "org.armedbear.lisp.ArgumentListProcessor$KeywordParam")
     [java] ; (DEFUN INTERNAL-FIELD-TYPE (FIELD-TYPE) "Returns a string containing the JVM-internal representation
     [java] of `field-type', which should either be a symbol identifying a primitive
     [java] type, or a `class-name' structure identifying a class or interface." (IF (SYMBOLP FIELD-TYPE) (MAP-PRIMITIVE-TYPE FIELD-TYPE) (CLASS-NAME-INTERNAL FIELD-TYPE)))
     [java] ; (DEFUN INTERNAL-FIELD-REF (FIELD-TYPE) "Returns a string containing the JVM-internal representation of a reference
     [java] to `field-type', which should either be a symbol identifying a primitive
     [java] type, or a `class-name' structure identifying a class or interface." (IF (SYMBOLP FIELD-TYPE) (MAP-PRIMITIVE-TYPE FIELD-TYPE) (CLASS-REF FIELD-TYPE)))
     [java] ; (DEFUN DESCRIPTOR (RETURN-TYPE &REST ARGUMENT-TYPES) "Returns a string describing the `return-type' and `argument-types'
     [java] in JVM-internal representation." (LET* ((ARG-STRINGS (MAPCAR (FUNCTION INTERNAL-FIELD-REF) ARGUMENT-TYPES)) (RET-STRING (INTERNAL-FIELD-REF RETURN-TYPE)) (SIZE (+ 2 (REDUCE (FUNCTION +) ARG-STRINGS :KEY (FUNCTION LENGTH) :INITIAL-VALUE (LENGTH RET-STRING)))) (STR (MAKE-ARRAY SIZE :FILL-POINTER 0 :ELEMENT-TYPE (QUOTE CHARACTER)))) (WITH-OUTPUT-TO-STRING (S STR) (PRINC #\( S) (DOLIST (ARG-STRING ARG-STRINGS) (PRINC ARG-STRING S)) (PRINC #\) S) (PRINC RET-STRING S)) STR))
     [java] ; (DEFUN DESCRIPTOR-STACK-EFFECT (RETURN-TYPE &REST ARGUMENT-TYPES) "Returns the effect on the stack position of the `argument-types' and
     [java] `return-type' of a method call.
     [java]
     [java] If the method consumes an implicit `this' argument, this function does not
     [java] take that effect into account." (FLET ((TYPE-STACK-EFFECT (ARG) (CASE ARG ((:LONG :DOUBLE) 2) ((NIL :VOID) 0) (OTHERWISE 1)))) (+ (REDUCE (FUNCTION -) ARGUMENT-TYPES :KEY (FUNCTION TYPE-STACK-EFFECT) :INITIAL-VALUE 0) (TYPE-STACK-EFFECT RETURN-TYPE))))
     [java] ; (DEFSTRUCT POOL (INDEX 0) ENTRIES-LIST (ENTRIES (MAKE-HASH-TABLE :TEST (FUNCTION EQUAL) :SIZE 2048 :REHASH-SIZE 2.0f0)))
     [java] ; (DEFUN MATCHING-INDEX-P (ENTRY INDEX) (EQL (CONSTANT-INDEX ENTRY) INDEX))
     [java] ; (DEFUN FIND-POOL-ENTRY (POOL ITEM &KEY (TEST (FUNCTION MATCHING-INDEX-P))) (FIND-IF (LAMBDA (X) (FUNCALL TEST X ITEM)) (POOL-ENTRIES-LIST POOL)))
     [java] ; (DEFSTRUCT CONSTANT "Structure to be included in all constant sub-types." TAG INDEX)
     [java] ; (DEFGENERIC PRINT-POOL-CONSTANT (POOL ENTRY STREAM &KEY &ALLOW-OTHER-KEYS) (:METHOD (POOL (ENTRY T) STREAM &KEY) (PRINT-OBJECT ENTRY STREAM)))
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT :AROUND (POOL ENTRY STREAM &KEY RECURSIVE) (COND ((AND (NULL *PRINT-READABLY*) (NULL *PRINT-ESCAPE*) (NULL RECURSIVE)) (PRINC #\# STREAM) (PRINC (CONSTANT-INDEX ENTRY) STREAM) (PRINC #\  STREAM) (PRINC #\< STREAM) (CALL-NEXT-METHOD) (PRINC #\> STREAM)) (T (CALL-NEXT-METHOD))))
     [java] ; (DEFPARAMETER +CONSTANT-TYPE-MAP+ (QUOTE ((:CLASS 7 1) (:FIELD-REF 9 1) (:METHOD-REF 10 1) (:STRING 8 1) (:INTEGER 3 1) (:FLOAT 4 1) (:LONG 5 2) (:DOUBLE 6 2) (:NAME-AND-TYPE 12 1) (:UTF8 1 1))))
     [java] ; (DEFSTRUCT (CONSTANT-CLASS (:CONSTRUCTOR MAKE-CONSTANT-CLASS (INDEX NAME-INDEX)) (:INCLUDE CONSTANT (TAG 7))) "Structure holding information on a 'class' type item in the constant pool." NAME-INDEX)
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-CLASS) STREAM &KEY RECURSIVE PACKAGE) (COND ((AND (NULL *PRINT-ESCAPE*) (NULL *PRINT-READABLY*)) (UNLESS RECURSIVE (PRINC "Class " STREAM)) (PRINC (PRETTY-CLASS (CONSTANT-UTF8-VALUE (FIND-POOL-ENTRY POOL (CONSTANT-CLASS-NAME-INDEX ENTRY))) PACKAGE) STREAM)) (T (CALL-NEXT-METHOD))))
     [java] ; (DEFSTRUCT (CONSTANT-MEMBER-REF (:CONSTRUCTOR %MAKE-CONSTANT-MEMBER-REF (TAG INDEX CLASS-INDEX NAME/TYPE-INDEX)) (:INCLUDE CONSTANT)) "Structure holding information on a member reference type item
     [java] (a field, method or interface method reference) in the constant pool." CLASS-INDEX NAME/TYPE-INDEX)
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-MEMBER-REF) STREAM &KEY RECURSIVE PACKAGE) (COND ((AND (NULL *PRINT-ESCAPE*) (NULL *PRINT-READABLY*)) (UNLESS RECURSIVE (PRINC (CASE (CONSTANT-MEMBER-REF-TAG ENTRY) (9 "Field ") (10 "Method ") (11 "Interface method ")) STREAM)) (LET ((NAME-PREFIX (WITH-OUTPUT-TO-STRING (S) (PRINT-POOL-CONSTANT POOL (FIND-POOL-ENTRY POOL (CONSTANT-MEMBER-REF-CLASS-INDEX ENTRY)) S :RECURSIVE T :PACKAGE PACKAGE) (PRINC #\. S)))) (PRINT-POOL-CONSTANT POOL (FIND-POOL-ENTRY POOL (CONSTANT-MEMBER-REF-NAME/TYPE-INDEX ENTRY)) STREAM :NAME-PREFIX NAME-PREFIX :RECURSIVE T :PACKAGE PACKAGE))) (T (CALL-NEXT-METHOD))))
     [java] ; (DECLAIM (INLINE MAKE-CONSTANT-FIELD-REF MAKE-CONSTANT-METHOD-REF MAKE-CONSTANT-INTERFACE-METHOD-REF))
     [java] ; (DEFUN MAKE-CONSTANT-FIELD-REF (INDEX CLASS-INDEX NAME/TYPE-INDEX) "Creates a `constant-member-ref' instance containing a field reference." (%MAKE-CONSTANT-MEMBER-REF 9 INDEX CLASS-INDEX NAME/TYPE-INDEX))
     [java] ; (DEFUN MAKE-CONSTANT-METHOD-REF (INDEX CLASS-INDEX NAME/TYPE-INDEX) "Creates a `constant-member-ref' instance containing a method reference." (%MAKE-CONSTANT-MEMBER-REF 10 INDEX CLASS-INDEX NAME/TYPE-INDEX))
     [java] ; (DEFUN MAKE-CONSTANT-INTERFACE-METHOD-REF (INDEX CLASS-INDEX NAME/TYPE-INDEX) "Creates a `constant-member-ref' instance containing an
     [java] interface-method reference." (%MAKE-CONSTANT-MEMBER-REF 11 INDEX CLASS-INDEX NAME/TYPE-INDEX))
     [java] ; (DEFSTRUCT (CONSTANT-STRING (:CONSTRUCTOR MAKE-CONSTANT-STRING (INDEX VALUE-INDEX)) (:INCLUDE CONSTANT (TAG 8))) "Structure holding information on a 'string' type item in the constant pool." VALUE-INDEX)
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-STRING) STREAM &KEY RECURSIVE) (COND ((AND (NULL *PRINT-READABLY*) (NULL *PRINT-ESCAPE*)) (UNLESS RECURSIVE (PRINC "String " STREAM)) (PRINC #\" STREAM) (PRINT-POOL-CONSTANT POOL (FIND-POOL-ENTRY POOL (CONSTANT-STRING-VALUE-INDEX ENTRY)) STREAM :RECURSIVE T) (PRINC #\" STREAM)) (T (CALL-NEXT-METHOD))))
     [java] ; (DEFSTRUCT (CONSTANT-FLOAT/INT (:CONSTRUCTOR %MAKE-CONSTANT-FLOAT/INT (TAG INDEX VALUE)) (:INCLUDE CONSTANT)) "Structure holding information on a 'float' or 'integer' type item
     [java] in the constant pool." VALUE)
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-FLOAT/INT) STREAM &KEY RECURSIVE) (COND ((AND (NULL *PRINT-ESCAPE*) (NULL *PRINT-READABLY*)) (UNLESS RECURSIVE (PRINC (CASE (CONSTANT-TAG ENTRY) (3 "int ") (4 "float ")) STREAM)) (PRINC (CONSTANT-FLOAT/INT-VALUE ENTRY) STREAM)) (T (CALL-NEXT-METHOD))))
     [java] ; (DECLAIM (INLINE MAKE-CONSTANT-FLOAT MAKE-CONSTANT-INT))
     [java] ; (DEFUN MAKE-CONSTANT-FLOAT (INDEX VALUE) "Creates a `constant-float/int' structure instance containing a float." (%MAKE-CONSTANT-FLOAT/INT 4 INDEX VALUE))
     [java] ; (DEFUN MAKE-CONSTANT-INT (INDEX VALUE) "Creates a `constant-float/int' structure instance containing an int." (%MAKE-CONSTANT-FLOAT/INT 3 INDEX VALUE))
     [java] ; (DEFSTRUCT (CONSTANT-DOUBLE/LONG (:CONSTRUCTOR %MAKE-CONSTANT-DOUBLE/LONG (TAG INDEX VALUE)) (:INCLUDE CONSTANT)) "Structure holding information on a 'double' or 'long' type item
     [java] in the constant pool." VALUE)
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-DOUBLE/LONG) STREAM &KEY RECURSIVE) (COND ((AND (NULL *PRINT-ESCAPE*) (NULL *PRINT-READABLY*)) (UNLESS RECURSIVE (PRINC (CASE (CONSTANT-TAG ENTRY) (5 "long ") (6 "double ")) STREAM)) (PRINC (CONSTANT-DOUBLE/LONG-VALUE ENTRY) STREAM)) (T (CALL-NEXT-METHOD))))
     [java] ; (DECLAIM (INLINE MAKE-CONSTANT-DOUBLE MAKE-CONSTANT-FLOAT))
     [java] ; (DEFUN MAKE-CONSTANT-DOUBLE (INDEX VALUE) "Creates a `constant-double/long' structure instance containing a double." (%MAKE-CONSTANT-DOUBLE/LONG 6 INDEX VALUE))
     [java] ; (DEFUN MAKE-CONSTANT-LONG (INDEX VALUE) "Creates a `constant-double/long' structure instance containing a long." (%MAKE-CONSTANT-DOUBLE/LONG 5 INDEX VALUE))
     [java] ; (DEFSTRUCT (CONSTANT-NAME/TYPE (:CONSTRUCTOR MAKE-CONSTANT-NAME/TYPE (INDEX NAME-INDEX DESCRIPTOR-INDEX)) (:INCLUDE CONSTANT (TAG 12))) "Structure holding information on a 'name-and-type' type item in the
     [java] constant pool; this type of element is used by 'member-ref' type items." NAME-INDEX DESCRIPTOR-INDEX)
     [java] ; (DEFUN PARSE-DESCRIPTOR (DESCRIPTOR) (LET (ARGUMENTS METHOD-DESCRIPTOR-P (INDEX 0)) (WHEN (EQL (AREF DESCRIPTOR 0) #\() (ASSERT (FIND #\) DESCRIPTOR)) (SETF METHOD-DESCRIPTOR-P T) (LOOP UNTIL (EQL (AREF DESCRIPTOR INDEX) #\)) DO (INCF INDEX) IF (FIND (AREF DESCRIPTOR INDEX) "IJFDZCBSV") DO (PUSH (AREF DESCRIPTOR INDEX) ARGUMENTS) IF (EQL (AREF DESCRIPTOR INDEX) #\L) DO (LOOP FOR I UPFROM INDEX UNTIL (EQL (AREF DESCRIPTOR I) #\;) FINALLY (PUSH (SUBSEQ DESCRIPTOR INDEX (1+ I)) ARGUMENTS) FINALLY (SETF INDEX I)) FINALLY (INCF INDEX))) (VALUES (LET ((RETURN-VALUE (SUBSEQ DESCRIPTOR INDEX))) (IF (= (LENGTH RETURN-VALUE) 1) (AREF RETURN-VALUE 0) RETURN-VALUE)) (NREVERSE ARGUMENTS) METHOD-DESCRIPTOR-P)))
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-NAME/TYPE) STREAM &KEY NAME-PREFIX PACKAGE) (COND ((AND (NULL *PRINT-READABLY*) (NULL *PRINT-ESCAPE*)) (MULTIPLE-VALUE-BIND (TYPE ARGUMENTS METHOD-DESCRIPTOR-P) (LET ((ENTRY (FIND-POOL-ENTRY POOL (CONSTANT-NAME/TYPE-DESCRIPTOR-INDEX ENTRY)))) (IF (CONSTANT-UTF8-P ENTRY) (PARSE-DESCRIPTOR (CONSTANT-UTF8-VALUE ENTRY)) (CLASS-REF ENTRY))) (PRINC (PRETTY-TYPE TYPE PACKAGE) STREAM) (PRINC #\  STREAM) (WHEN NAME-PREFIX (PRINC NAME-PREFIX STREAM)) (PRINT-POOL-CONSTANT POOL (FIND-POOL-ENTRY POOL (CONSTANT-NAME/TYPE-NAME-INDEX ENTRY)) STREAM :RECURSIVE T) (WHEN METHOD-DESCRIPTOR-P (FORMAT STREAM "(~{~A~^,~})" (MAPCAR (LAMBDA (X) (PRETTY-TYPE X PACKAGE)) ARGUMENTS))))) (T (CALL-NEXT-METHOD))))
     [java] ; (DEFSTRUCT (CONSTANT-UTF8 (:CONSTRUCTOR MAKE-CONSTANT-UTF8 (INDEX VALUE)) (:INCLUDE CONSTANT (TAG 1))) "Structure holding information on a 'utf8' type item in the constant pool;
     [java]
     [java] This type of item is used for text representation of identifiers
     [java] and string contents." VALUE)
     [java] ; (DEFUN POOL-ADD-CLASS (POOL CLASS) "Returns the index of the constant-pool class item for `class'.
     [java]
     [java] `class' must be an instance of `class-name' or a string (which will be converted
     [java] to a `class-name')." (LET ((CLASS (IF (JVM-CLASS-NAME-P CLASS) CLASS (MAKE-JVM-CLASS-NAME CLASS)))) (LET ((ENTRY (GETHASH CLASS (POOL-ENTRIES POOL)))) (UNLESS ENTRY (LET ((UTF8 (POOL-ADD-UTF8 POOL (CLASS-NAME-INTERNAL CLASS)))) (SETF ENTRY (MAKE-CONSTANT-CLASS (INCF (POOL-INDEX POOL)) UTF8) (GETHASH CLASS (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY))))
     [java] ; (DEFUN POOL-ADD-FIELD-REF (POOL CLASS NAME TYPE) "Returns the index of the constant-pool item which denotes a reference
     [java] to the `name' field of the `class', being of `type'.
     [java]
     [java] `class' should be an instance of `class-name'.
     [java] `name' is a string.
     [java] `type' is a field-type (see `internal-field-type')" (LET ((ENTRY (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (LET ((C (POOL-ADD-CLASS POOL CLASS)) (N/T (POOL-ADD-NAME/TYPE POOL NAME TYPE))) (SETF ENTRY (MAKE-CONSTANT-FIELD-REF (INCF (POOL-INDEX POOL)) C N/T) (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-METHOD-REF (POOL CLASS NAME TYPE) "Returns the index of the constant-pool item which denotes a reference
     [java] to the method with `name' in `class', which is of `type'.
     [java]
     [java] Here, `type' is a method descriptor, which defines the argument types
     [java] and return type. `class' is an instance of `class-name'." (LET ((ENTRY (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (LET ((C (POOL-ADD-CLASS POOL CLASS)) (N/T (POOL-ADD-NAME/TYPE POOL NAME TYPE))) (SETF ENTRY (MAKE-CONSTANT-METHOD-REF (INCF (POOL-INDEX POOL)) C N/T) (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-INTERFACE-METHOD-REF (POOL CLASS NAME TYPE) "Returns the index of the constant-pool item which denotes a reference to
     [java] the method `name' in the interface `class', which is of `type'.
     [java]
     [java] See `pool-add-method-ref' for remarks." (LET ((ENTRY (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (LET ((C (POOL-ADD-CLASS POOL CLASS)) (N/T (POOL-ADD-NAME/TYPE POOL NAME TYPE))) (SETF ENTRY (MAKE-CONSTANT-INTERFACE-METHOD-REF (INCF (POOL-INDEX POOL)) C N/T) (GETHASH (ACONS NAME TYPE CLASS) (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-STRING (POOL STRING) "Returns the index of the constant-pool item denoting the string." (LET ((ENTRY (GETHASH (CONS 8 STRING) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (LET ((UTF8 (POOL-ADD-UTF8 POOL STRING))) (SETF ENTRY (MAKE-CONSTANT-STRING (INCF (POOL-INDEX POOL)) UTF8) (GETHASH (CONS 8 STRING) (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-INT (POOL INT) "Returns the index of the constant-pool item denoting the int." (LET ((ENTRY (GETHASH (CONS 3 INT) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (SETF ENTRY (MAKE-CONSTANT-INT (INCF (POOL-INDEX POOL)) INT) (GETHASH (CONS 3 INT) (POOL-ENTRIES POOL)) ENTRY) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-FLOAT (POOL FLOAT) "Returns the index of the constant-pool item denoting the float." (LET ((ENTRY (GETHASH (CONS 4 FLOAT) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (SETF ENTRY (MAKE-CONSTANT-FLOAT (INCF (POOL-INDEX POOL)) (%FLOAT-BITS FLOAT)) (GETHASH (CONS 4 FLOAT) (POOL-ENTRIES POOL)) ENTRY) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-LONG (POOL LONG) "Returns the index of the constant-pool item denoting the long." (LET ((ENTRY (GETHASH (CONS 5 LONG) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (SETF ENTRY (MAKE-CONSTANT-LONG (INCF (POOL-INDEX POOL)) LONG) (GETHASH (CONS 5 LONG) (POOL-ENTRIES POOL)) ENTRY) (PUSH ENTRY (POOL-ENTRIES-LIST POOL)) (INCF (POOL-INDEX POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-DOUBLE (POOL DOUBLE) "Returns the index of the constant-pool item denoting the double." (LET ((ENTRY (GETHASH (CONS 6 DOUBLE) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (SETF ENTRY (MAKE-CONSTANT-DOUBLE (INCF (POOL-INDEX POOL)) (%FLOAT-BITS DOUBLE)) (GETHASH (CONS 6 DOUBLE) (POOL-ENTRIES POOL)) ENTRY) (PUSH ENTRY (POOL-ENTRIES-LIST POOL)) (INCF (POOL-INDEX POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-NAME/TYPE (POOL NAME TYPE) "Returns the index of the constant-pool item denoting
     [java] the name/type identifier." (LET ((ENTRY (GETHASH (CONS NAME TYPE) (POOL-ENTRIES POOL))) (INTERNAL-TYPE (IF (LISTP TYPE) (APPLY (FUNCTION DESCRIPTOR) TYPE) (INTERNAL-FIELD-REF TYPE)))) (UNLESS ENTRY (LET ((N (POOL-ADD-UTF8 POOL NAME)) (I-T (POOL-ADD-UTF8 POOL INTERNAL-TYPE))) (SETF ENTRY (MAKE-CONSTANT-NAME/TYPE (INCF (POOL-INDEX POOL)) N I-T) (GETHASH (CONS NAME TYPE) (POOL-ENTRIES POOL)) ENTRY)) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFUN POOL-ADD-UTF8 (POOL UTF8-AS-STRING) "Returns the index of the textual value that will be stored in the
     [java] class file as UTF-8 encoded data." (LET ((ENTRY (GETHASH (CONS 11 UTF8-AS-STRING) (POOL-ENTRIES POOL)))) (UNLESS ENTRY (SETF ENTRY (MAKE-CONSTANT-UTF8 (INCF (POOL-INDEX POOL)) UTF8-AS-STRING) (GETHASH (CONS 11 UTF8-AS-STRING) (POOL-ENTRIES POOL)) ENTRY) (PUSH ENTRY (POOL-ENTRIES-LIST POOL))) (CONSTANT-INDEX ENTRY)))
     [java] ; (DEFSTRUCT (CLASS-FILE (:CONSTRUCTOR MAKE-CLASS-FILE (CLASS SUPERCLASS ACCESS-FLAGS))) "Holds the components of a class file." (CONSTANTS (MAKE-POOL)) ACCESS-FLAGS CLASS SUPERCLASS INTERFACES FIELDS METHODS ATTRIBUTES)
     [java] ; (DEFUN MAKE-CLASS-INTERFACE-FILE (CLASS) "Create the components of a class file representing a public Java
     [java] interface." (MAKE-CLASS-FILE CLASS +JAVA-OBJECT+ (QUOTE (:PUBLIC :ABSTRACT :INTERFACE))))
     [java] ; (DEFUN CLASS-ADD-FIELD (CLASS FIELD) "Adds a `field' created by `make-field'." (PUSH FIELD (CLASS-FILE-FIELDS CLASS)))
     [java] ; (DEFUN CLASS-FIELD (CLASS NAME) "Finds a field by name." (FIND NAME (CLASS-FILE-FIELDS CLASS) :TEST (FUNCTION STRING=) :KEY (FUNCTION FIELD-NAME)))
     [java] ; (DEFUN CLASS-ADD-METHOD (CLASS METHOD) "Adds a `method' to `class'; the method must have been created using
     [java] `make-jvm-method'." (PUSH METHOD (CLASS-FILE-METHODS CLASS)))
     [java] ; (DEFUN CLASS-METHODS-BY-NAME (CLASS NAME) "Returns all methods which have `name'." (REMOVE (MAP-METHOD-NAME NAME) (CLASS-FILE-METHODS CLASS) :TEST-NOT (FUNCTION STRING=) :KEY (FUNCTION METHOD-NAME)))
     [java] ; (DEFUN CLASS-METHOD (CLASS NAME RETURN &REST ARGS) "Return the method which is (uniquely) identified by its name AND descriptor." (LET ((RETURN-AND-ARGS (CONS RETURN ARGS)) (NAME (MAP-METHOD-NAME NAME))) (FIND-IF (FUNCTION (LAMBDA (C) (AND (STRING= (METHOD-NAME C) NAME) (EQUAL (METHOD-DESCRIPTOR C) RETURN-AND-ARGS)))) (CLASS-FILE-METHODS CLASS))))
     [java] ; (DEFUN CLASS-REMOVE-METHOD (CLASS METHOD) (SETF (CLASS-FILE-METHODS CLASS) (REMOVE METHOD (CLASS-FILE-METHODS CLASS))) METHOD)
     [java] ; (DEFUN CLASS-ADD-ATTRIBUTE (CLASS ATTRIBUTE) "Adds `attribute' to the class; attributes must be instances of
     [java] structure classes which include the `attribute' structure class." (PUSH ATTRIBUTE (CLASS-FILE-ATTRIBUTES CLASS)))
     [java] ; (DEFUN CLASS-ADD-SUPERINTERFACE (CLASS INTERFACE) "Adds the java-class-name contained in `interface' as a superinterface of the `class'.
     [java]
     [java] For a class that represents an object, the requirements in `interface'
     [java] must then be implemented in the class.  For a class that represents an
     [java] interface, the `interface' imposes additional requirements to the
     [java] classes which implement this class." (PUSH INTERFACE (CLASS-FILE-INTERFACES CLASS)))
     [java] ; (DEFUN CLASS-ATTRIBUTE (CLASS NAME) "Returns the attribute which is named `name'." (FIND NAME (CLASS-FILE-ATTRIBUTES CLASS) :TEST (FUNCTION STRING=) :KEY (FUNCTION ATTRIBUTE-NAME)))
     [java] ; (DEFUN FINALIZE-INTERFACES (CLASS) "Finalize the interfaces for `class'.
     [java]
     [java] Interface finalization first ensures that all the classes referenced
     [java] by the interfaces members exist in the pool.  Then, it destructively
     [java] modfies the interfaces members with a list of the references to the
     [java] corresponding pool indices." (LET ((INTERFACE-REFS NIL)) (DOLIST (INTERFACE (CLASS-FILE-INTERFACES CLASS)) (PUSH (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) INTERFACE) INTERFACE-REFS)) (SETF (CLASS-FILE-INTERFACES CLASS) INTERFACE-REFS)))
     [java] ; (DEFUN FINALIZE-CLASS-FILE (CLASS) "Transforms the representation of the class-file from one
     [java] which allows easy modification to one which works best for serialization.
     [java]
     [java] The class can't be modified after finalization." (SETF (CLASS-FILE-ACCESS-FLAGS CLASS) (MAP-FLAGS (CLASS-FILE-ACCESS-FLAGS CLASS))) (SETF (CLASS-FILE-SUPERCLASS CLASS) (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) (CLASS-FILE-SUPERCLASS CLASS)) (CLASS-FILE-CLASS CLASS) (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) (CLASS-FILE-CLASS CLASS))) (FINALIZE-INTERFACES CLASS) (DOLIST (FIELD (CLASS-FILE-FIELDS CLASS)) (FINALIZE-FIELD FIELD CLASS)) (DOLIST (METHOD (CLASS-FILE-METHODS CLASS)) (FINALIZE-METHOD METHOD CLASS)) (FINALIZE-ATTRIBUTES (CLASS-FILE-ATTRIBUTES CLASS) NIL CLASS))
     [java] ; (DECLAIM (INLINE WRITE-U1 WRITE-U2 WRITE-U4 WRITE-S4))
     [java] ; (DEFUN WRITE-U1 (N STREAM) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (UNSIGNED-BYTE 8) N)) (DECLARE (TYPE STREAM STREAM)) (WRITE-8-BITS N STREAM))
     [java] ; (DEFKNOWN WRITE-U2 (T T) T)
     [java] ; (DEFUN WRITE-U2 (N STREAM) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (UNSIGNED-BYTE 16) N)) (DECLARE (TYPE STREAM STREAM)) (WRITE-8-BITS (LOGAND (ASH N -8) 255) STREAM) (WRITE-8-BITS (LOGAND N 255) STREAM))
     [java] ; (DEFKNOWN WRITE-U4 (INTEGER STREAM) T)
     [java] ; (DEFUN WRITE-U4 (N STREAM) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (UNSIGNED-BYTE 32) N)) (WRITE-U2 (LOGAND (ASH N -16) 65535) STREAM) (WRITE-U2 (LOGAND N 65535) STREAM))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) WRITE-S4))
     [java] ; (DEFUN WRITE-S4 (N STREAM) (DECLARE (OPTIMIZE SPEED)) (COND ((MINUSP N) (WRITE-U4 (1+ (LOGXOR (- N) 4294967295)) STREAM)) (T (WRITE-U4 N STREAM))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) WRITE-ASCII))
     [java] ; (DEFUN WRITE-ASCII (STRING LENGTH STREAM) (DECLARE (TYPE STRING STRING)) (DECLARE (TYPE (UNSIGNED-BYTE 16) LENGTH)) (DECLARE (TYPE STREAM STREAM)) (WRITE-U2 LENGTH STREAM) (DOTIMES (I LENGTH) (DECLARE (TYPE (UNSIGNED-BYTE 16) I)) (WRITE-8-BITS (CHAR-CODE (CHAR STRING I)) STREAM)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T) T) WRITE-UTF8))
     [java] ; (DEFUN WRITE-UTF8 (STRING STREAM) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE STRING STRING)) (DECLARE (TYPE STREAM STREAM)) (LET ((LENGTH (LENGTH STRING)) (MUST-CONVERT NIL)) (DECLARE (TYPE FIXNUM LENGTH)) (DOTIMES (I LENGTH) (DECLARE (TYPE FIXNUM I)) (UNLESS (< 0 (CHAR-CODE (CHAR STRING I)) 128) (SETF MUST-CONVERT T) (RETURN))) (IF MUST-CONVERT (LET ((OCTETS (MAKE-ARRAY (* LENGTH 2) :ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)) :ADJUSTABLE T :FILL-POINTER 0))) (DECLARE (TYPE (VECTOR (UNSIGNED-BYTE 8)) OCTETS)) (DOTIMES (I LENGTH) (DECLARE (TYPE FIXNUM I)) (LET* ((C (CHAR STRING I)) (N (CHAR-CODE C))) (COND ((ZEROP N) (VECTOR-PUSH-EXTEND 192 OCTETS) (VECTOR-PUSH-EXTEND 128 OCTETS)) ((< 0 N 128) (VECTOR-PUSH-EXTEND N OCTETS)) (T (LET ((CHAR-OCTETS (CHAR-TO-UTF8 C))) (DOTIMES (J (LENGTH CHAR-OCTETS)) (DECLARE (TYPE FIXNUM J)) (VECTOR-PUSH-EXTEND (SVREF CHAR-OCTETS J) OCTETS))))))) (WRITE-U2 (LENGTH OCTETS) STREAM) (DOTIMES (I (LENGTH OCTETS)) (DECLARE (TYPE FIXNUM I)) (WRITE-8-BITS (AREF OCTETS I) STREAM))) (WRITE-ASCII STRING LENGTH STREAM))))
     [java] ; (DEFUN WRITE-CLASS-FILE (CLASS STREAM) "Serializes `class' to `stream', after it has been finalized." (WRITE-U4 3405691582 STREAM) (WRITE-U2 0 STREAM) (WRITE-U2 49 STREAM) (WRITE-CONSTANTS (CLASS-FILE-CONSTANTS CLASS) STREAM) (WRITE-U2 (CLASS-FILE-ACCESS-FLAGS CLASS) STREAM) (WRITE-U2 (CLASS-FILE-CLASS CLASS) STREAM) (WRITE-U2 (CLASS-FILE-SUPERCLASS CLASS) STREAM) (IF (CLASS-FILE-INTERFACES CLASS) (PROGN (WRITE-U2 (LENGTH (CLASS-FILE-INTERFACES CLASS)) STREAM) (DOLIST (INTERFACE-REF (CLASS-FILE-INTERFACES CLASS)) (WRITE-U2 INTERFACE-REF STREAM))) (WRITE-U2 0 STREAM)) (WRITE-U2 (LENGTH (CLASS-FILE-FIELDS CLASS)) STREAM) (DOLIST (FIELD (CLASS-FILE-FIELDS CLASS)) (WRITE-FIELD FIELD STREAM)) (WRITE-U2 (LENGTH (CLASS-FILE-METHODS CLASS)) STREAM) (DOLIST (METHOD (CLASS-FILE-METHODS CLASS)) (WRITE-METHOD METHOD STREAM)) (WRITE-ATTRIBUTES (CLASS-FILE-ATTRIBUTES CLASS) STREAM))
     [java] ; (DEFVAR *JVM-CLASS-DEBUG-POOL* NIL "When bound to a non-NIL value, enables output to *standard-output*
     [java] to allow debugging output of the constant section of the class file.")
     [java] ; (DEFUN WRITE-CONSTANTS (CONSTANTS STREAM) "Writes the constant section given in `constants' to the class file `stream'." (LET ((POOL-INDEX 0)) (WRITE-U2 (1+ (POOL-INDEX CONSTANTS)) STREAM) (WHEN *JVM-CLASS-DEBUG-POOL* (SYSTEM::%FORMAT T "pool count ~A~%" (POOL-INDEX CONSTANTS))) (DOLIST (ENTRY (REVERSE (POOL-ENTRIES-LIST CONSTANTS))) (INCF POOL-INDEX) (LET ((TAG (CONSTANT-TAG ENTRY))) (WHEN *JVM-CLASS-DEBUG-POOL* (PRINT-ENTRY ENTRY T)) (WRITE-U1 TAG STREAM) (CASE TAG (1 (WRITE-UTF8 (CONSTANT-UTF8-VALUE ENTRY) STREAM)) ((3 4) (WRITE-U4 (CONSTANT-FLOAT/INT-VALUE ENTRY) STREAM)) ((5 6) (WRITE-U4 (LOGAND (ASH (CONSTANT-DOUBLE/LONG-VALUE ENTRY) -32) 4294967295) STREAM) (WRITE-U4 (LOGAND (CONSTANT-DOUBLE/LONG-VALUE ENTRY) 4294967295) STREAM)) ((9 10 11) (WRITE-U2 (CONSTANT-MEMBER-REF-CLASS-INDEX ENTRY) STREAM) (WRITE-U2 (CONSTANT-MEMBER-REF-NAME/TYPE-INDEX ENTRY) STREAM)) (12 (WRITE-U2 (CONSTANT-NAME/TYPE-NAME-INDEX ENTRY) STREAM) (WRITE-U2 (CONSTANT-NAME/TYPE-DESCRIPTOR-INDEX ENTRY) STREAM)) (7 (WRITE-U2 (CONSTANT-CLASS-NAME-INDEX ENTRY) STREAM)) (8 (WRITE-U2 (CONSTANT-STRING-VALUE-INDEX ENTRY) STREAM)) (T (ERROR "write-constant-pool-entry unhandled tag ~D~%" TAG)))))))
     [java] ; (DEFUN PRINT-ENTRY (ENTRY STREAM) "Debugging helper to print the content of a constant-pool entry." (LET ((TAG (CONSTANT-TAG ENTRY)) (INDEX (CONSTANT-INDEX ENTRY))) (SYSTEM::%FORMAT STREAM "pool element ~a, tag ~a, " INDEX TAG) (CASE TAG (1 (SYSTEM::%FORMAT T "utf8: ~a~%" (CONSTANT-UTF8-VALUE ENTRY))) ((3 4) (SYSTEM::%FORMAT T "f/i: ~a~%" (CONSTANT-FLOAT/INT-VALUE ENTRY))) ((5 6) (SYSTEM::%FORMAT T "d/l: ~a~%" (CONSTANT-DOUBLE/LONG-VALUE ENTRY))) ((9 10 11) (SYSTEM::%FORMAT T "ref: ~a,~a~%" (CONSTANT-MEMBER-REF-CLASS-INDEX ENTRY) (CONSTANT-MEMBER-REF-NAME/TYPE-INDEX ENTRY))) (12 (SYSTEM::%FORMAT T "n/t: ~a,~a~%" (CONSTANT-NAME/TYPE-NAME-INDEX ENTRY) (CONSTANT-NAME/TYPE-DESCRIPTOR-INDEX ENTRY))) (7 (SYSTEM::%FORMAT T "cls: ~a~%" (CONSTANT-CLASS-NAME-INDEX ENTRY))) (8 (SYSTEM::%FORMAT T "str: ~a~%" (CONSTANT-STRING-VALUE-INDEX ENTRY))))))
     [java] ; (DEFMETHOD PRINT-POOL-CONSTANT (POOL (ENTRY CONSTANT-UTF8) STREAM &KEY) (IF (AND (NULL *PRINT-ESCAPE*) (NULL *PRINT-READABLY*)) (PRINC (CONSTANT-UTF8-VALUE ENTRY) STREAM) (CALL-NEXT-METHOD)))
     [java] ; (DEFPARAMETER +ACCESS-FLAGS-MAP+ (QUOTE ((:PUBLIC 1) (:PRIVATE 2) (:PROTECTED 4) (:STATIC 8) (:FINAL 16) (:VOLATILE 64) (:SYNCHRONIZED 32) (:TRANSIENT 128) (:NATIVE 256) (:INTERFACE 512) (:ABSTRACT 1024) (:STRICT 2048))) "List of keyword symbols used for human readable representation of (access)
     [java] flags and their binary values.")
     [java] ; (DEFUN MAP-FLAGS (FLAGS) "Calculates the bitmap of the flags from a list of symbols." (REDUCE (FUNCTION (LAMBDA (Y X) (LOGIOR (OR (WHEN (MEMBER (CAR X) FLAGS) (SECOND X)) 0) Y))) +ACCESS-FLAGS-MAP+ :INITIAL-VALUE 0))
     [java] ; (DEFSTRUCT (FIELD (:CONSTRUCTOR %MAKE-FIELD)) "Holds information on the properties of fields in the class(-file)." ACCESS-FLAGS NAME DESCRIPTOR ATTRIBUTES)
     [java] ; (DEFUN MAKE-FIELD (NAME TYPE &KEY (FLAGS (QUOTE (:PUBLIC)))) "Creates a field for addition to a class file." (%MAKE-FIELD :ACCESS-FLAGS FLAGS :NAME NAME :DESCRIPTOR TYPE))
     [java] ; (DEFUN FIELD-ADD-ATTRIBUTE (FIELD ATTRIBUTE) "Adds an attribute to a field." (PUSH ATTRIBUTE (FIELD-ATTRIBUTES FIELD)))
     [java] ; (DEFUN FIELD-ATTRIBUTE (FIELD NAME) "Retrieves an attribute named `name' of `field'.
     [java]
     [java] Returns NIL if the attribute isn't found." (FIND NAME (FIELD-ATTRIBUTES FIELD) :TEST (FUNCTION STRING=) :KEY (FUNCTION ATTRIBUTE-NAME)))
     [java] ; (DEFUN FINALIZE-FIELD (FIELD CLASS) "Prepares `field' for serialization." (LET ((POOL (CLASS-FILE-CONSTANTS CLASS))) (SETF (FIELD-ACCESS-FLAGS FIELD) (MAP-FLAGS (FIELD-ACCESS-FLAGS FIELD)) (FIELD-DESCRIPTOR FIELD) (POOL-ADD-UTF8 POOL (INTERNAL-FIELD-REF (FIELD-DESCRIPTOR FIELD))) (FIELD-NAME FIELD) (POOL-ADD-UTF8 POOL (FIELD-NAME FIELD)))) (FINALIZE-ATTRIBUTES (FIELD-ATTRIBUTES FIELD) NIL CLASS))
     [java] ; (DEFUN WRITE-FIELD (FIELD STREAM) "Writes classfile representation of `field' to `stream'." (WRITE-U2 (FIELD-ACCESS-FLAGS FIELD) STREAM) (WRITE-U2 (FIELD-NAME FIELD) STREAM) (WRITE-U2 (FIELD-DESCRIPTOR FIELD) STREAM) (WRITE-ATTRIBUTES (FIELD-ATTRIBUTES FIELD) STREAM))
     [java] ; (DEFSTRUCT (JVM-METHOD (:CONSTRUCTOR %MAKE-JVM-METHOD) (:CONC-NAME METHOD-)) "Holds information on the properties of methods in the class(-file)." ACCESS-FLAGS NAME DESCRIPTOR ATTRIBUTES)
     [java] ; (DEFUN MAP-METHOD-NAME (NAME) "Methods should be identified by strings containing their names, or,
     [java] be one of two keyword identifiers to identify special methods:
     [java]
     [java]  * :static-initializer
     [java]  * :constructor
     [java] " (COND ((EQ NAME :STATIC-INITIALIZER) "<clinit>") ((EQ NAME :CONSTRUCTOR) "<init>") (T NAME)))
     [java] ; (DEFUN MAKE-JVM-METHOD (NAME RETURN ARGS &KEY (FLAGS (QUOTE (:PUBLIC)))) "Creates a method for addition to a class file." (%MAKE-JVM-METHOD :DESCRIPTOR (CONS RETURN ARGS) :ACCESS-FLAGS FLAGS :NAME (MAP-METHOD-NAME NAME)))
     [java] ; (DEFUN METHOD-ADD-ATTRIBUTE (METHOD ATTRIBUTE) "Add `attribute' to the list of attributes of `method',
     [java] returning `attribute'." (PUSH ATTRIBUTE (METHOD-ATTRIBUTES METHOD)) ATTRIBUTE)
     [java] ; (DEFUN METHOD-ADD-CODE (METHOD &OPTIONAL (OPTIMIZE T)) "Creates an (empty) 'Code' attribute for the method,
     [java] returning the created attribute." (METHOD-ADD-ATTRIBUTE METHOD (MAKE-CODE-ATTRIBUTE (+ (LENGTH (CDR (METHOD-DESCRIPTOR METHOD))) (IF (MEMBER :STATIC (METHOD-ACCESS-FLAGS METHOD)) 0 1)) OPTIMIZE)))
     [java] ; (DEFUN METHOD-ENSURE-CODE (METHOD &OPTIONAL (OPTIMIZE T)) "Ensures the existence of a 'Code' attribute for the method,
     [java] returning the attribute." (LET ((CODE (METHOD-ATTRIBUTE METHOD "Code"))) (IF (NULL CODE) (METHOD-ADD-CODE METHOD OPTIMIZE) CODE)))
     [java] ; (DEFUN METHOD-ATTRIBUTE (METHOD NAME) "Returns the first attribute of `method' with `name'." (FIND NAME (METHOD-ATTRIBUTES METHOD) :TEST (FUNCTION STRING=) :KEY (FUNCTION ATTRIBUTE-NAME)))
     [java] ; (DEFUN FINALIZE-METHOD (METHOD CLASS) "Prepares `method' for serialization." (LET ((POOL (CLASS-FILE-CONSTANTS CLASS))) (SETF (METHOD-ACCESS-FLAGS METHOD) (MAP-FLAGS (METHOD-ACCESS-FLAGS METHOD)) (METHOD-DESCRIPTOR METHOD) (POOL-ADD-UTF8 POOL (APPLY (FUNCTION DESCRIPTOR) (METHOD-DESCRIPTOR METHOD))) (METHOD-NAME METHOD) (POOL-ADD-UTF8 POOL (METHOD-NAME METHOD)))) (FINALIZE-ATTRIBUTES (METHOD-ATTRIBUTES METHOD) NIL CLASS))
     [java] ; (DEFUN WRITE-METHOD (METHOD STREAM) "Write class file representation of `method' to `stream'." (WRITE-U2 (METHOD-ACCESS-FLAGS METHOD) STREAM) (WRITE-U2 (METHOD-NAME METHOD) STREAM) (WRITE-U2 (METHOD-DESCRIPTOR METHOD) STREAM) (WRITE-ATTRIBUTES (METHOD-ATTRIBUTES METHOD) STREAM))
     [java] ; (DEFSTRUCT ATTRIBUTE "Parent attribute structure to be included into other attributes, mainly
     [java] to define common fields.
     [java]
     [java] Having common fields allows common driver code for
     [java] finalizing and serializing attributes." NAME FINALIZER WRITER)
     [java] ; (DEFUN FINALIZE-ATTRIBUTES (ATTRIBUTES ATT CLASS) "Prepare `attributes' (a list) of attribute `att' list for serialization." (DOLIST (ATTRIBUTE ATTRIBUTES) (SETF (ATTRIBUTE-NAME ATTRIBUTE) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (ATTRIBUTE-NAME ATTRIBUTE))) (FUNCALL (ATTRIBUTE-FINALIZER ATTRIBUTE) ATTRIBUTE ATT CLASS)))
     [java] ; (DEFUN WRITE-ATTRIBUTES (ATTRIBUTES STREAM) "Writes the `attributes' to `stream'." (WRITE-U2 (LENGTH ATTRIBUTES) STREAM) (DOLIST (ATTRIBUTE ATTRIBUTES) (WRITE-U2 (ATTRIBUTE-NAME ATTRIBUTE) STREAM) (LET ((LOCAL-STREAM (SYSTEM::%MAKE-BYTE-ARRAY-OUTPUT-STREAM))) (FUNCALL (ATTRIBUTE-WRITER ATTRIBUTE) ATTRIBUTE LOCAL-STREAM) (LET ((ARRAY (SYSTEM::%GET-OUTPUT-STREAM-ARRAY LOCAL-STREAM))) (WRITE-U4 (LENGTH ARRAY) STREAM) (WRITE-SEQUENCE ARRAY STREAM)))))
     [java] ; (DEFSTRUCT (CODE-ATTRIBUTE (:CONC-NAME CODE-) (:INCLUDE ATTRIBUTE (NAME "Code") (FINALIZER (FUNCTION FINALIZE-CODE-ATTRIBUTE)) (WRITER (FUNCTION WRITE-CODE-ATTRIBUTE))) (:CONSTRUCTOR %MAKE-CODE-ATTRIBUTE)) "The attribute containing the actual JVM byte code;
     [java] an attribute of a method." MAX-STACK MAX-LOCALS CODE EXCEPTION-HANDLERS ATTRIBUTES LABELS OPTIMIZE (CURRENT-LOCAL 0))
     [java] ; (DEFUN CODE-LABEL-OFFSET (CODE LABEL) "Retrieves the `label' offset within a `code' attribute after the
     [java] attribute has been finalized." (CDR (ASSOC LABEL (CODE-LABELS CODE))))
     [java] ; (DEFUN (SETF CODE-LABEL-OFFSET) (OFFSET CODE LABEL) "Sets the `label' offset within a `code' attribute after the attribute
     [java] has been finalized." (SETF (CODE-LABELS CODE) (ACONS LABEL OFFSET (CODE-LABELS CODE))))
     [java] ; (DEFUN FINALIZE-CODE-ATTRIBUTE (CODE PARENT CLASS) "Prepares the `code' attribute for serialization, within method `parent'." (LET* ((HANDLERS (CODE-EXCEPTION-HANDLERS CODE)) (C (FINALIZE-CODE (CODE-CODE CODE) (NCONC (MAPCAR (FUNCTION EXCEPTION-START-PC) HANDLERS) (MAPCAR (FUNCTION EXCEPTION-END-PC) HANDLERS) (MAPCAR (FUNCTION EXCEPTION-HANDLER-PC) HANDLERS)) (CODE-OPTIMIZE CODE) (CLASS-FILE-CONSTANTS CLASS)))) (INVOKE-CALLBACKS :CODE-FINALIZED CLASS PARENT (COERCE C (QUOTE LIST)) HANDLERS) (UNLESS (CODE-MAX-STACK CODE) (SETF (CODE-MAX-STACK CODE) (ANALYZE-STACK C (MAPCAR (FUNCTION EXCEPTION-HANDLER-PC) HANDLERS)))) (UNLESS (CODE-MAX-LOCALS CODE) (SETF (CODE-MAX-LOCALS CODE) (ANALYZE-LOCALS CODE))) (MULTIPLE-VALUE-BIND (C LABELS) (CODE-BYTES C) (ASSERT (< 0 (LENGTH C) 65536)) (SETF (CODE-CODE CODE) C (CODE-LABELS CODE) LABELS))) (SETF (CODE-EXCEPTION-HANDLERS CODE) (REMOVE-IF (FUNCTION (LAMBDA (H) (EQL (CODE-LABEL-OFFSET CODE (EXCEPTION-START-PC H)) (CODE-LABEL-OFFSET CODE (EXCEPTION-END-PC H))))) (CODE-EXCEPTION-HANDLERS CODE))) (DOLIST (EXCEPTION (CODE-EXCEPTION-HANDLERS CODE)) (SETF (EXCEPTION-START-PC EXCEPTION) (CODE-LABEL-OFFSET CODE (EXCEPTION-START-PC EXCEPTION)) (EXCEPTION-END-PC EXCEPTION) (CODE-LABEL-OFFSET CODE (EXCEPTION-END-PC EXCEPTION)) (EXCEPTION-HANDLER-PC EXCEPTION) (CODE-LABEL-OFFSET CODE (EXCEPTION-HANDLER-PC EXCEPTION)) (EXCEPTION-CATCH-TYPE EXCEPTION) (IF (NULL (EXCEPTION-CATCH-TYPE EXCEPTION)) 0 (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) (EXCEPTION-CATCH-TYPE EXCEPTION))))) (FINALIZE-ATTRIBUTES (CODE-ATTRIBUTES CODE) CODE CLASS))
     [java] ; (DEFUN WRITE-CODE-ATTRIBUTE (CODE STREAM) "Writes the attribute `code' to `stream'." (WRITE-U2 (CODE-MAX-STACK CODE) STREAM) (WRITE-U2 (CODE-MAX-LOCALS CODE) STREAM) (LET ((CODE-ARRAY (CODE-CODE CODE))) (WRITE-U4 (LENGTH CODE-ARRAY) STREAM) (DOTIMES (I (LENGTH CODE-ARRAY)) (WRITE-U1 (SVREF CODE-ARRAY I) STREAM))) (WRITE-U2 (LENGTH (CODE-EXCEPTION-HANDLERS CODE)) STREAM) (DOLIST (EXCEPTION (REVERSE (CODE-EXCEPTION-HANDLERS CODE))) (WRITE-U2 (EXCEPTION-START-PC EXCEPTION) STREAM) (WRITE-U2 (EXCEPTION-END-PC EXCEPTION) STREAM) (WRITE-U2 (EXCEPTION-HANDLER-PC EXCEPTION) STREAM) (WRITE-U2 (EXCEPTION-CATCH-TYPE EXCEPTION) STREAM)) (WRITE-ATTRIBUTES (CODE-ATTRIBUTES CODE) STREAM))
     [java] ; (DEFUN MAKE-CODE-ATTRIBUTE (ARG-COUNT &OPTIONAL OPTIMIZE) "Creates an empty 'Code' attribute for a method which takes
     [java] `arg-count` parameters, including the implicit `this` parameter." (%MAKE-CODE-ATTRIBUTE :MAX-LOCALS ARG-COUNT :OPTIMIZE OPTIMIZE))
     [java] ; (DEFUN CODE-ADD-ATTRIBUTE (CODE ATTRIBUTE) "Adds `attribute' to `code', returning `attribute'." (PUSH ATTRIBUTE (CODE-ATTRIBUTES CODE)) ATTRIBUTE)
     [java] ; (DEFUN CODE-ATTRIBUTE (CODE NAME) "Returns an attribute of `code' identified by `name'." (FIND NAME (CODE-ATTRIBUTES CODE) :TEST (FUNCTION STRING=) :KEY (FUNCTION ATTRIBUTE-NAME)))
     [java] ; (DEFUN CODE-ADD-EXCEPTION-HANDLER (CODE START END HANDLER TYPE) "Adds an exception handler to `code' protecting the region from
     [java] labels `start' to `end' (inclusive) from exception `type' - where
     [java] a value of NIL indicates all types. Upon an exception of the given
     [java] type, control is transferred to label `handler'." (PUSH (MAKE-EXCEPTION :START-PC START :END-PC END :HANDLER-PC HANDLER :CATCH-TYPE TYPE) (CODE-EXCEPTION-HANDLERS CODE)))
     [java] ; (DEFSTRUCT EXCEPTION "Exception handler information.
     [java]
     [java] After finalization, the fields contain offsets instead of labels." START-PC END-PC HANDLER-PC CATCH-TYPE)
     [java] ; (DEFSTRUCT (CONSTANT-VALUE-ATTRIBUTE (:CONC-NAME CONSTANT-VALUE-) (:INCLUDE ATTRIBUTE (NAME "ConstantValue"))) "An attribute of a field of primitive type.
     [java]
     [java] ")
     [java] ; (DEFSTRUCT (CHECKED-EXCEPTIONS-ATTRIBUTE (:CONC-NAME CHECKED-) (:INCLUDE ATTRIBUTE (NAME "Exceptions") (FINALIZER (FUNCTION FINALIZE-CHECKED-EXCEPTIONS)) (WRITER (FUNCTION WRITE-CHECKED-EXCEPTIONS)))) "An attribute of `code-attribute', " TABLE)
     [java] ; (DEFUN FINALIZE-CHECKED-EXCEPTIONS (CHECKED-EXCEPTIONS CODE CLASS) (DECLARE (IGNORABLE CODE CLASS)) "Prepare `checked-exceptions' for serialization." (SETF (CHECKED-TABLE CHECKED-EXCEPTIONS) (MAPCAR (FUNCTION (LAMBDA (EXCEPTION) (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) EXCEPTION))) (CHECKED-TABLE CHECKED-EXCEPTIONS))))
     [java] ; (DEFUN WRITE-CHECKED-EXCEPTIONS (CHECKED-EXCEPTIONS STREAM) "Write `checked-exceptions' to `stream' in class file representation." (WRITE-U2 (LENGTH (CHECKED-TABLE CHECKED-EXCEPTIONS)) STREAM) (DOLIST (EXCEPTION (REVERSE (CHECKED-TABLE CHECKED-EXCEPTIONS))) (WRITE-U2 EXCEPTION STREAM)))
     [java] ; (DEFSTRUCT (DEPRECATED-ATTRIBUTE (:INCLUDE ATTRIBUTE (NAME "Deprecated") (FINALIZER (CONSTANTLY NIL)) (WRITER (CONSTANTLY NIL)))) "An attribute of a class file, field or method, indicating the element
     [java] to which it has been attached has been superseded.")
     [java] ; (DEFVAR *CURRENT-CODE-ATTRIBUTE* NIL)
     [java] ; (DEFVAR *METHOD*)
     [java] ; (DEFUN SAVE-CODE-SPECIALS (CODE) (SETF (CODE-CODE CODE) *CODE* (CODE-MAX-LOCALS CODE) *REGISTERS-ALLOCATED* (CODE-CURRENT-LOCAL CODE) *REGISTER*))
     [java] ; (DEFUN RESTORE-CODE-SPECIALS (CODE) (SETF *CODE* (CODE-CODE CODE) *REGISTERS-ALLOCATED* (CODE-MAX-LOCALS CODE) *REGISTER* (CODE-CURRENT-LOCAL CODE)))
     [java] ; (DEFMACRO WITH-CODE-TO-METHOD ((CLASS-FILE METHOD) &BODY BODY) (LET ((M (GENSYM)) (C (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (QUOTE (WHEN *CURRENT-CODE-ATTRIBUTE* (SAVE-CODE-SPECIALS *CURRENT-CODE-ATTRIBUTE*))) (SYSTEM::BACKQ-LIST* (QUOTE UNWIND-PROTECT) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST M METHOD) (SYSTEM::BACKQ-LIST (QUOTE *METHOD*) M) (SYSTEM::BACKQ-LIST C (SYSTEM::BACKQ-LIST (QUOTE METHOD-ENSURE-CODE) METHOD)) (SYSTEM::BACKQ-LIST (QUOTE *POOL*) (SYSTEM::BACKQ-LIST (QUOTE CLASS-FILE-CONSTANTS) CLASS-FILE)) (SYSTEM::BACKQ-LIST (QUOTE *CODE*) (SYSTEM::BACKQ-LIST (QUOTE CODE-CODE) C)) (SYSTEM::BACKQ-LIST (QUOTE *REGISTERS-ALLOCATED*) (SYSTEM::BACKQ-LIST (QUOTE CODE-MAX-LOCALS) C)) (SYSTEM::BACKQ-LIST (QUOTE *REGISTER*) (SYSTEM::BACKQ-LIST (QUOTE CODE-CURRENT-LOCAL) C)) (SYSTEM::BACKQ-LIST (QUOTE *CURRENT-CODE-ATTRIBUTE*) C)) (SYSTEM::BACKQ-CONS (QUOTE UNWIND-PROTECT) (SYSTEM::BACKQ-APPEND BODY (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE CODE-CODE) C) (QUOTE *CODE*) (SYSTEM::BACKQ-LIST (QUOTE CODE-CURRENT-LOCAL) C) (QUOTE *REGISTER*) (SYSTEM::BACKQ-LIST (QUOTE CODE-MAX-LOCALS) C) (QUOTE (*REGISTERS-ALLOCATED*))))))) (QUOTE ((WHEN *CURRENT-CODE-ATTRIBUTE* (RESTORE-CODE-SPECIALS *CURRENT-CODE-ATTRIBUTE*))))))))
     [java] ; (DEFSTRUCT (SOURCE-FILE-ATTRIBUTE (:CONC-NAME SOURCE-) (:INCLUDE ATTRIBUTE (NAME "SourceFile") (FINALIZER (FUNCTION FINALIZE-SOURCE-FILE)) (WRITER (FUNCTION WRITE-SOURCE-FILE)))) "An attribute of the class file indicating which source file
     [java] it was compiled from." FILENAME)
     [java] ; (DEFUN FINALIZE-SOURCE-FILE (SOURCE-FILE CODE CLASS) (DECLARE (IGNORABLE CODE CLASS)) (SETF (SOURCE-FILENAME SOURCE-FILE) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (SOURCE-FILENAME SOURCE-FILE))))
     [java] ; (DEFUN WRITE-SOURCE-FILE (SOURCE-FILE STREAM) (WRITE-U2 (SOURCE-FILENAME SOURCE-FILE) STREAM))
     [java] ; (DEFSTRUCT (SYNTHETIC-ATTRIBUTE (:INCLUDE ATTRIBUTE (NAME "Synthetic") (FINALIZER (CONSTANTLY NIL)) (WRITER (CONSTANTLY NIL)))) "An attribute of a class file, field or method to mark that it wasn't
     [java] included in the sources - but was generated artificially.")
     [java] ; (DEFSTRUCT (LINE-NUMBERS-ATTRIBUTE (:CONC-NAME LINE-NUMBERS-) (:INCLUDE ATTRIBUTE (NAME "LineNumberTable") (FINALIZER (FUNCTION FINALIZE-LINE-NUMBERS)) (WRITER (FUNCTION WRITE-LINE-NUMBERS)))) "An attribute of `code-attribute', containing a mapping of offsets
     [java] within the code section to the line numbers in the source file." TABLE)
     [java] ; (DEFSTRUCT LINE-NUMBER START-PC LINE)
     [java] ; (DEFUN FINALIZE-LINE-NUMBERS (LINE-NUMBERS CODE CLASS) (DECLARE (IGNORABLE CODE CLASS)) (DOLIST (LINE-NUMBER (LINE-NUMBERS-TABLE LINE-NUMBERS)) (UNLESS (ZEROP (LINE-NUMBER-START-PC LINE-NUMBER)) (SETF (LINE-NUMBER-START-PC LINE-NUMBER) (CODE-LABEL-OFFSET CODE (LINE-NUMBER-START-PC LINE-NUMBER))))))
     [java] ; (DEFUN WRITE-LINE-NUMBERS (LINE-NUMBERS STREAM) (WRITE-U2 (LENGTH (LINE-NUMBERS-TABLE LINE-NUMBERS)) STREAM) (DOLIST (LINE-NUMBER (REVERSE (LINE-NUMBERS-TABLE LINE-NUMBERS))) (WRITE-U2 (LINE-NUMBER-START-PC LINE-NUMBER) STREAM) (WRITE-U2 (LINE-NUMBER-LINE LINE-NUMBER) STREAM)))
     [java] ; (DEFUN LINE-NUMBERS-ADD-LINE (LINE-NUMBERS START-PC LINE) (PUSH (MAKE-LINE-NUMBER :START-PC START-PC :LINE LINE) (LINE-NUMBERS-TABLE LINE-NUMBERS)))
     [java] ; (DEFSTRUCT (LOCAL-VARIABLES-ATTRIBUTE (:CONC-NAME LOCAL-VAR-) (:INCLUDE ATTRIBUTE (NAME "LocalVariableTable") (FINALIZER (FUNCTION FINALIZE-LOCAL-VARIABLES)) (WRITER (FUNCTION WRITE-LOCAL-VARIABLES)))) "An attribute of the `code-attribute', containing a table of local variable
     [java] names, their type and their scope of validity." TABLE)
     [java] ; (DEFSTRUCT (LOCAL-VARIABLE (:CONC-NAME LOCAL-)) START-PC LENGTH NAME DESCRIPTOR INDEX)
     [java] ; (DEFUN FINALIZE-LOCAL-VARIABLES (LOCAL-VARIABLES CODE CLASS) (DOLIST (LOCAL-VARIABLE (LOCAL-VAR-TABLE LOCAL-VARIABLES)) (SETF (LOCAL-START-PC LOCAL-VARIABLE) (CODE-LABEL-OFFSET CODE (LOCAL-START-PC LOCAL-VARIABLE)) (LOCAL-LENGTH LOCAL-VARIABLE) (- (CODE-LABEL-OFFSET CODE (LOCAL-LENGTH LOCAL-VARIABLE)) (LOCAL-START-PC LOCAL-VARIABLE)) (LOCAL-NAME LOCAL-VARIABLE) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (LOCAL-NAME LOCAL-VARIABLE)) (LOCAL-DESCRIPTOR LOCAL-VARIABLE) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (LOCAL-DESCRIPTOR LOCAL-VARIABLE)))))
     [java] ; (DEFUN WRITE-LOCAL-VARIABLES (LOCAL-VARIABLES STREAM) (WRITE-U2 (LENGTH (LOCAL-VAR-TABLE LOCAL-VARIABLES)) STREAM) (DOLIST (LOCAL-VARIABLE (REVERSE (LOCAL-VAR-TABLE LOCAL-VARIABLES))) (WRITE-U2 (LOCAL-START-PC LOCAL-VARIABLE) STREAM) (WRITE-U2 (LOCAL-LENGTH LOCAL-VARIABLE) STREAM) (WRITE-U2 (LOCAL-NAME LOCAL-VARIABLE) STREAM) (WRITE-U2 (LOCAL-DESCRIPTOR LOCAL-VARIABLE) STREAM) (WRITE-U2 (LOCAL-INDEX LOCAL-VARIABLE) STREAM)))
     [java] ; (DEFSTRUCT (ANNOTATIONS-ATTRIBUTE (:CONC-NAME ANNOTATIONS-) (:INCLUDE ATTRIBUTE (FINALIZER (FUNCTION FINALIZE-ANNOTATIONS)) (WRITER (FUNCTION WRITE-ANNOTATIONS)))) "An attribute of a class, method or field, containing a list of annotations.
     [java] This structure serves as the abstract supertype of concrete annotations types." LIST)
     [java] ; (DEFSTRUCT ANNOTATION "Each value of the annotations table represents a single runtime-visible annotation on a program element.
     [java]    The annotation structure has the following format:
     [java]      annotation {
     [java]        u2 type_index;
     [java]        u2 num_element_value_pairs;
     [java]        {
     [java]          u2 element_name_index;
     [java]          element_value value;
     [java]        } element_value_pairs[num_element_value_pairs]
     [java]      }" TYPE ELEMENTS)
     [java] ; (DEFSTRUCT ANNOTATION-ELEMENT (NAME "value") TAG FINALIZER WRITER)
     [java] ; (DEFSTRUCT (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT (:INCLUDE ANNOTATION-ELEMENT (FINALIZER (LAMBDA (SELF CLASS) (LET ((VALUE (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF))) (ETYPECASE VALUE (BOOLEAN (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\Z) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-INT (CLASS-FILE-CONSTANTS CLASS) (IF VALUE 1 0)))) (CHARACTER (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\C) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-INT (CLASS-FILE-CONSTANTS CLASS) (CHAR-CODE VALUE)))) (FIXNUM (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\I) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-INT (CLASS-FILE-CONSTANTS CLASS) VALUE))) (INTEGER (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\J) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-LONG (CLASS-FILE-CONSTANTS CLASS) VALUE))) (DOUBLE-FLOAT (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\D) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-DOUBLE (CLASS-FILE-CONSTANTS CLASS) VALUE))) (SINGLE-FLOAT (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\F) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-FLOAT (CLASS-FILE-CONSTANTS CLASS) VALUE))) (STRING (SETF (ANNOTATION-ELEMENT-TAG SELF) (CHAR-CODE #\s) (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) VALUE))))))) (WRITER (LAMBDA (SELF STREAM) (WRITE-U1 (ANNOTATION-ELEMENT-TAG SELF) STREAM) (WRITE-U2 (PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-VALUE SELF) STREAM))))) VALUE)
     [java] ; (DEFSTRUCT (ENUM-VALUE-ANNOTATION-ELEMENT (:INCLUDE ANNOTATION-ELEMENT (TAG (CHAR-CODE #\e)) (FINALIZER (LAMBDA (SELF CLASS) (SETF (ENUM-VALUE-ANNOTATION-ELEMENT-TYPE SELF) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (ENUM-VALUE-ANNOTATION-ELEMENT-TYPE SELF)) (ENUM-VALUE-ANNOTATION-ELEMENT-VALUE SELF) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (ENUM-VALUE-ANNOTATION-ELEMENT-VALUE SELF))))) (WRITER (LAMBDA (SELF STREAM) (WRITE-U1 (ANNOTATION-ELEMENT-TAG SELF) STREAM) (WRITE-U2 (ENUM-VALUE-ANNOTATION-ELEMENT-TYPE SELF) STREAM) (WRITE-U2 (ENUM-VALUE-ANNOTATION-ELEMENT-VALUE SELF) STREAM))))) TYPE VALUE)
     [java] ; (DEFSTRUCT (ANNOTATION-VALUE-ANNOTATION-ELEMENT (:INCLUDE ANNOTATION-ELEMENT (TAG (CHAR-CODE #\@)) (FINALIZER (LAMBDA (SELF CLASS) (FINALIZE-ANNOTATION (ANNOTATION-VALUE-ANNOTATION-ELEMENT-VALUE SELF) CLASS))) (WRITER (LAMBDA (SELF STREAM) (WRITE-U1 (ANNOTATION-ELEMENT-TAG SELF) STREAM) (WRITE-ANNOTATION (ANNOTATION-VALUE-ANNOTATION-ELEMENT-VALUE SELF) STREAM))))) VALUE)
     [java] ; (DEFSTRUCT (ARRAY-ANNOTATION-ELEMENT (:INCLUDE ANNOTATION-ELEMENT (TAG (CHAR-CODE #\[)) (FINALIZER (LAMBDA (SELF CLASS) (DOLIST (ELEM (ARRAY-ANNOTATION-ELEMENT-VALUES SELF)) (FINALIZE-ANNOTATION-ELEMENT ELEM CLASS)))) (WRITER (LAMBDA (SELF STREAM) (WRITE-U1 (ANNOTATION-ELEMENT-TAG SELF) STREAM) (WRITE-U2 (LENGTH (ARRAY-ANNOTATION-ELEMENT-VALUES SELF)) STREAM) (DOLIST (ELEM (ARRAY-ANNOTATION-ELEMENT-VALUES SELF)) (WRITE-ANNOTATION-ELEMENT ELEM STREAM)))))) VALUES)
     [java] ; (DEFSTRUCT (RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE (:INCLUDE ANNOTATIONS-ATTRIBUTE (NAME "RuntimeVisibleAnnotations"))) "4.8.15 The RuntimeVisibleAnnotations attribute
     [java] The RuntimeVisibleAnnotations attribute is a variable length attribute in the
     [java] attributes table of the ClassFile, field_info, and method_info structures. The
     [java] RuntimeVisibleAnnotations attribute records runtime-visible Java program-
     [java] ming language annotations on the corresponding class, method, or field. Each
     [java] ClassFile, field_info, and method_info structure may contain at most one
     [java] RuntimeVisibleAnnotations attribute, which records all the runtime-visible
     [java] Java programming language annotations on the corresponding program element.
     [java] The JVM must make these annotations available so they can be returned by the
     [java] appropriate reflective APIs.")
     [java] ; (DEFUN FINALIZE-ANNOTATIONS (ANNOTATIONS CODE CLASS) (DECLARE (IGNORE CODE)) (DOLIST (ANN (ANNOTATIONS-LIST ANNOTATIONS)) (FINALIZE-ANNOTATION ANN CLASS)))
     [java] ; (DEFUN FINALIZE-ANNOTATION (ANN CLASS) (SETF (ANNOTATION-TYPE ANN) (POOL-ADD-CLASS (CLASS-FILE-CONSTANTS CLASS) (ANNOTATION-TYPE ANN))) (DOLIST (ELEM (ANNOTATION-ELEMENTS ANN)) (FINALIZE-ANNOTATION-ELEMENT ELEM CLASS)))
     [java] ; (DEFUN FINALIZE-ANNOTATION-ELEMENT (ELEM CLASS) (WHEN (ANNOTATION-ELEMENT-NAME ELEM) (SETF (ANNOTATION-ELEMENT-NAME ELEM) (POOL-ADD-UTF8 (CLASS-FILE-CONSTANTS CLASS) (ANNOTATION-ELEMENT-NAME ELEM)))) (FUNCALL (ANNOTATION-ELEMENT-FINALIZER ELEM) ELEM CLASS))
     [java] ; (DEFUN WRITE-ANNOTATIONS (ANNOTATIONS STREAM) (WRITE-U2 (LENGTH (ANNOTATIONS-LIST ANNOTATIONS)) STREAM) (DOLIST (ANNOTATION (REVERSE (ANNOTATIONS-LIST ANNOTATIONS))) (WRITE-ANNOTATION ANNOTATION STREAM)))
     [java] ; (DEFUN WRITE-ANNOTATION (ANNOTATION STREAM) (WRITE-U2 (ANNOTATION-TYPE ANNOTATION) STREAM) (WRITE-U2 (LENGTH (ANNOTATION-ELEMENTS ANNOTATION)) STREAM) (DOLIST (ELEM (REVERSE (ANNOTATION-ELEMENTS ANNOTATION))) (WRITE-ANNOTATION-ELEMENT ELEM STREAM)))
     [java] ; (DEFUN WRITE-ANNOTATION-ELEMENT (ELEM STREAM) (WHEN (ANNOTATION-ELEMENT-NAME ELEM) (WRITE-U2 (ANNOTATION-ELEMENT-NAME ELEM) STREAM)) (FUNCALL (ANNOTATION-ELEMENT-WRITER ELEM) ELEM STREAM))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-class-file.abcl (30.866 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-class-file.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-class-file.abcl (4.636 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm.lisp ...
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DEFVAR *CLOSURE-VARIABLES* NIL)
     [java] ; (DEFVAR *ENABLE-DFORMAT* NIL)
     [java] ; (DEFVAR *CALLBACKS* NIL "A list of functions to be called by the compiler and code generator
     [java] in order to generate 'compilation events'.
     [java]
     [java] A callback function takes five arguments:
     [java] CALLBACK-TYPE CLASS PARENT CONTENT EXCEPTION-HANDLERS.")
     [java] ; (DECLAIM (INLINE INVOKE-CALLBACKS))
     [java] ; (DEFUN INVOKE-CALLBACKS (&REST ARGS) (DOLIST (CB *CALLBACKS*) (APPLY CB ARGS)))
     [java] ; (DEFMACRO DFORMAT (&REST IGNORED) (DECLARE (IGNORE IGNORED)))
     [java] ; (DEFMACRO WITH-SAVED-COMPILER-POLICY (&BODY BODY) "Saves compiler policy variables, restoring them after evaluating `body'." (SYSTEM::BACKQ-LIST* (QUOTE LET) (QUOTE ((*SPEED* *SPEED*) (*SPACE* *SPACE*) (*SAFETY* *SAFETY*) (*DEBUG* *DEBUG*) (*EXPLAIN* *EXPLAIN*) (*INLINE-DECLARATIONS* *INLINE-DECLARATIONS*))) BODY))
     [java] ; (DEFVAR *COMPILER-DEBUG* NIL)
     [java] ; (DEFVAR *POOL* NIL)
     [java] ; (DEFVAR *STATIC-CODE* NIL)
     [java] ; (DEFVAR *CLASS-FILE* NIL)
     [java] ; (DEFVAR *EXTERNALIZED-OBJECTS* NIL)
     [java] ; (DEFVAR *DECLARED-FUNCTIONS* NIL)
     [java] ; (DEFSTRUCT (ABCL-CLASS-FILE (:INCLUDE CLASS-FILE) (:CONSTRUCTOR %MAKE-ABCL-CLASS-FILE)) PATHNAME CLASS-NAME STATIC-INITIALIZER CONSTRUCTOR OBJECTS (FUNCTIONS (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))))
     [java] ; (DEFUN CLASS-NAME-FROM-FILESPEC (FILESPEC) (LET* ((NAME (PATHNAME-NAME FILESPEC))) (DECLARE (TYPE STRING NAME)) (DOTIMES (I (LENGTH NAME)) (DECLARE (TYPE FIXNUM I)) (WHEN (OR (CHAR= (CHAR NAME I) #\-) (CHAR= (CHAR NAME I) #\ )) (SETF (CHAR NAME I) #\_))) (MAKE-JVM-CLASS-NAME (CONCATENATE (QUOTE STRING) "org.armedbear.lisp." NAME))))
     [java] ; (DEFUN MAKE-UNIQUE-CLASS-NAME NIL "Creates a random class name for use with a `class-file' structure's
     [java] `class' slot." (MAKE-JVM-CLASS-NAME (CONCATENATE (QUOTE STRING) "abcl_" (SUBSTITUTE #\_ #\- (JAVA:JCALL (JAVA:JMETHOD "java.util.UUID" "toString") (JAVA:JSTATIC "randomUUID" "java.util.UUID"))))))
     [java] ;JAVA:JCLASS-NAME triggers autoloading of org.armedbear.lisp.jclass_name ...
     [java] ; Autoloaded org.armedbear.lisp.jclass_name (0.004 seconds)
     [java] ;JAVA:JCLASS-OF triggers autoloading of org.armedbear.lisp.jclass_of ...
     [java] ; Autoloaded org.armedbear.lisp.jclass_of (0.004 seconds)
     [java] ; (DEFUN MAKE-ABCL-CLASS-FILE (&KEY PATHNAME) "Creates a `class-file' structure. If `pathname' is non-NIL, it's
     [java] used to derive a class name. If it is NIL, a random one created
     [java] using `make-unique-class-name'." (LET* ((CLASS-NAME (IF PATHNAME (CLASS-NAME-FROM-FILESPEC PATHNAME) (MAKE-UNIQUE-CLASS-NAME))) (CLASS-FILE (%MAKE-ABCL-CLASS-FILE :PATHNAME PATHNAME :CLASS CLASS-NAME :CLASS-NAME CLASS-NAME :ACCESS-FLAGS (QUOTE (:PUBLIC :FINAL))))) (WHEN *FILE-COMPILATION* (LET ((SOURCE-ATTRIBUTE (MAKE-SOURCE-FILE-ATTRIBUTE :FILENAME (FILE-NAMESTRING *COMPILE-FILE-TRUENAME*)))) (CLASS-ADD-ATTRIBUTE CLASS-FILE SOURCE-ATTRIBUTE))) CLASS-FILE))
     [java] ; (DEFMACRO WITH-CLASS-FILE (CLASS-FILE &BODY BODY) (LET ((VAR (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST VAR CLASS-FILE) (SYSTEM::BACKQ-LIST (QUOTE *CLASS-FILE*) VAR) (SYSTEM::BACKQ-LIST (QUOTE *POOL*) (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-CONSTANTS) VAR)) (SYSTEM::BACKQ-LIST (QUOTE *EXTERNALIZED-OBJECTS*) (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-OBJECTS) VAR)) (SYSTEM::BACKQ-LIST (QUOTE *DECLARED-FUNCTIONS*) (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-FUNCTIONS) VAR))) (SYSTEM::BACKQ-CONS (QUOTE PROGN) BODY) (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-OBJECTS) VAR) (QUOTE *EXTERNALIZED-OBJECTS*) (SYSTEM::BACKQ-LIST (QUOTE ABCL-CLASS-FILE-FUNCTIONS) VAR) (QUOTE (*DECLARED-FUNCTIONS*))))))
     [java] ; (DEFSTRUCT COMPILAND NAME LAMBDA-EXPRESSION ARG-VARS FREE-SPECIALS ARITY P1-RESULT PARENT CHILDREN BLOCKS (NEXT-RESOURCE 0) ARGUMENT-REGISTER CLOSURE-REGISTER ENVIRONMENT-REGISTER CLASS-FILE (%SINGLE-VALUED-P T))
     [java] ; (DEFKNOWN COMPILAND-SINGLE-VALUED-P (T) T)
     [java] ; (DEFUN COMPILAND-SINGLE-VALUED-P (COMPILAND) (UNLESS (COMPILAND-PARENT COMPILAND) (LET ((NAME (COMPILAND-NAME COMPILAND))) (WHEN NAME (LET ((RESULT-TYPE (OR (FUNCTION-RESULT-TYPE NAME) (AND (PROCLAIMED-FTYPE NAME) (FTYPE-RESULT-TYPE (PROCLAIMED-FTYPE NAME)))))) (WHEN RESULT-TYPE (RETURN-FROM COMPILAND-SINGLE-VALUED-P (COND ((EQ RESULT-TYPE (QUOTE *)) NIL) ((ATOM RESULT-TYPE) T) ((EQ (%CAR RESULT-TYPE) (QUOTE VALUES)) (= (LENGTH RESULT-TYPE) 2)) (T T)))))))) (COMPILAND-%SINGLE-VALUED-P COMPILAND))
     [java] ; (DEFVAR *CURRENT-COMPILAND* NIL)
     [java] ; (DEFVAR *THIS-CLASS* NIL)
     [java] ; (DEFVAR *VISIBLE-TAGS* NIL)
     [java] ; (DEFVAR *REGISTER* 0)
     [java] ; (DEFVAR *REGISTERS-ALLOCATED* 0)
     [java] ; (DEFVAR *VISIBLE-VARIABLES* NIL "All variables visible to the form currently being
     [java] processed, including free specials.")
     [java] ; (DEFVAR *ALL-VARIABLES* NIL "All variables in the lexical scope (thus excluding free specials)
     [java] of the compilands being processed (p1: so far; p2: in total).")
     [java] ; (DEFVAR *UNDEFINED-VARIABLES* NIL)
     [java] ; (DEFVAR *DUMP-VARIABLES* NIL)
     [java] ; (DEFUN DUMP-1-VARIABLE (VARIABLE) (SYSTEM::%FORMAT T "  ~S special-p = ~S register = ~S binding-reg = ~S index = ~S declared-type = ~S~%" (VARIABLE-NAME VARIABLE) (VARIABLE-SPECIAL-P VARIABLE) (VARIABLE-REGISTER VARIABLE) (VARIABLE-BINDING-REGISTER VARIABLE) (VARIABLE-INDEX VARIABLE) (VARIABLE-DECLARED-TYPE VARIABLE)))
     [java] ; (DEFUN DUMP-VARIABLES (LIST CAPTION &OPTIONAL (FORCE NIL)) (WHEN (OR FORCE *DUMP-VARIABLES*) (WRITE-STRING CAPTION) (IF LIST (DOLIST (VARIABLE LIST) (DUMP-1-VARIABLE VARIABLE)) (SYSTEM::%FORMAT T "  None.~%"))))
     [java] ; (DEFSTRUCT (VARIABLE-INFO (:CONC-NAME VARIABLE-) (:CONSTRUCTOR MAKE-VARIABLE) (:PREDICATE VARIABLE-P)) NAME INITFORM (DECLARED-TYPE :NONE) (DERIVED-TYPE :NONE) IGNORE-P IGNORABLE-P REPRESENTATION SPECIAL-P REGISTER BINDING-REGISTER INDEX CLOSURE-INDEX ENVIRONMENT (READS 0 :TYPE FIXNUM) (WRITES 0 :TYPE FIXNUM) REFERENCES (REFERENCES-ALLOWED-P T) USED-NON-LOCALLY-P (COMPILAND *CURRENT-COMPILAND*) BLOCK)
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJECT VARIABLE-INFO) STREAM) (PRINT-UNREADABLE-OBJECT (OBJECT STREAM :TYPE T :IDENTITY T) (PRINC (VARIABLE-NAME OBJECT) STREAM) (PRINC " in " STREAM) (PRINC (COMPILAND-NAME (VARIABLE-COMPILAND OBJECT)) STREAM)))
     [java] ; (DEFSTRUCT (VAR-REF (:CONSTRUCTOR MAKE-VAR-REF (VARIABLE))) VARIABLE CONSTANT-P CONSTANT-VALUE)
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJECT VAR-REF) STREAM) (PRINT-UNREADABLE-OBJECT (OBJECT STREAM :TYPE T :IDENTITY T) (PRINC "ref ") (PRINT-OBJECT (VAR-REF-VARIABLE OBJECT) STREAM)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) UNBOXED-FIXNUM-VARIABLE))
     [java] ; (DEFUN UNBOXED-FIXNUM-VARIABLE (OBJ) (COND ((SYMBOLP OBJ) (LET ((VARIABLE (FIND-VISIBLE-VARIABLE OBJ))) (IF (AND VARIABLE (EQ (VARIABLE-REPRESENTATION VARIABLE) :INT)) VARIABLE NIL))) ((VARIABLE-P OBJ) (IF (EQ (VARIABLE-REPRESENTATION OBJ) :INT) OBJ NIL)) (T NIL)))
     [java] ; (DEFVAR *CHILD-P* NIL "True for local functions created by FLET, LABELS and (NAMED-)LAMBDA")
     [java] ; (DEFKNOWN FIND-VARIABLE (SYMBOL LIST) T)
     [java] ; (DEFUN FIND-VARIABLE (NAME VARIABLES) (DOLIST (VARIABLE VARIABLES) (WHEN (EQ NAME (VARIABLE-NAME VARIABLE)) (RETURN VARIABLE))))
     [java] ; (DEFKNOWN FIND-VISIBLE-VARIABLE (T) T)
     [java] ; (DEFUN FIND-VISIBLE-VARIABLE (NAME) (DOLIST (VARIABLE *VISIBLE-VARIABLES*) (WHEN (EQ NAME (VARIABLE-NAME VARIABLE)) (RETURN VARIABLE))))
     [java] ; (DEFKNOWN REPRESENTATION-SIZE (T) (INTEGER 0 65535))
     [java] ; (DEFUN REPRESENTATION-SIZE (REPRESENTATION) (ECASE REPRESENTATION ((NIL :INT :BOOLEAN :FLOAT :CHAR) 1) ((:LONG :DOUBLE) 2)))
     [java] ; (DEFKNOWN ALLOCATE-REGISTER (T) (INTEGER 0 65535))
     [java] ; (DEFUN ALLOCATE-REGISTER (REPRESENTATION) (LET ((REGISTER *REGISTER*)) (INCF *REGISTER* (REPRESENTATION-SIZE REPRESENTATION)) (SETF *REGISTERS-ALLOCATED* (MAX *REGISTERS-ALLOCATED* *REGISTER*)) REGISTER))
     [java] ; (DEFSTRUCT LOCAL-FUNCTION NAME DEFINITION COMPILAND FIELD INLINE-EXPANSION ENVIRONMENT (REFERENCES-ALLOWED-P T) (REFERENCES-NEEDED-P NIL))
     [java] ; (DEFVAR *LOCAL-FUNCTIONS* NIL)
     [java] ; (DEFKNOWN FIND-LOCAL-FUNCTION (T) T)
     [java] ; (DEFUN FIND-LOCAL-FUNCTION (NAME) (DOLIST (LOCAL-FUNCTION *LOCAL-FUNCTIONS* NIL) (WHEN (EQUAL NAME (LOCAL-FUNCTION-NAME LOCAL-FUNCTION)) (RETURN LOCAL-FUNCTION))))
     [java] ; (DEFVAR *USING-ARG-ARRAY* NIL)
     [java] ; (DEFVAR *HAIRY-ARGLIST-P* NIL)
     [java] ; (DEFVAR *BLOCK* NIL "The innermost block applicable to the current lexical environment.")
     [java] ; (DEFVAR *BLOCKS* NIL "The list of blocks in effect in the current lexical environment.
     [java]
     [java] The top node does not need to be equal to the value of `*block*`. E.g.
     [java] when processing the bindings of a LET form, `*block*` is bound to the node
     [java] of that LET, while the block is not considered 'in effect': that only happens
     [java] until the body is being processed.")
     [java] ; (DEFSTRUCT NODE FORM CHILDREN (COMPILAND *CURRENT-COMPILAND*))
     [java] ; (DECLAIM (INLINE ADD-NODE-CHILD))
     [java] ; (DEFUN ADD-NODE-CHILD (PARENT CHILD) "Add a child node to the `children` list of a parent node,
     [java] if that parent belongs to the same compiland." (WHEN PARENT (WHEN (EQ (NODE-COMPILAND PARENT) *CURRENT-COMPILAND*) (PUSH CHILD (NODE-CHILDREN PARENT)))))
     [java] ; (DEFSTRUCT (CONTROL-TRANSFERRING-NODE (:INCLUDE NODE)) NEEDS-ENVIRONMENT-RESTORATION)
     [java] ; (DEFSTRUCT (TAGBODY-NODE (:CONC-NAME TAGBODY-) (:INCLUDE CONTROL-TRANSFERRING-NODE) (:CONSTRUCTOR %MAKE-TAGBODY-NODE NIL)) NON-LOCAL-GO-P TAGS ID-VARIABLE)
     [java] ; (DEFKNOWN MAKE-TAGBODY-NODE NIL T)
     [java] ; (DEFUN MAKE-TAGBODY-NODE NIL (LET ((BLOCK (%MAKE-TAGBODY-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (CATCH-NODE (:CONC-NAME CATCH-) (:INCLUDE CONTROL-TRANSFERRING-NODE) (:CONSTRUCTOR %MAKE-CATCH-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-CATCH-NODE NIL T)
     [java] ; (DEFUN MAKE-CATCH-NODE NIL (LET ((BLOCK (%MAKE-CATCH-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (BLOCK-NODE (:CONC-NAME BLOCK-) (:INCLUDE CONTROL-TRANSFERRING-NODE) (:CONSTRUCTOR %MAKE-BLOCK-NODE (NAME))) NAME (EXIT (GENSYM)) TARGET NON-LOCAL-RETURN-P ID-VARIABLE RETURN-VALUE-FORMS)
     [java] ; (DEFKNOWN MAKE-BLOCK-NODE (T) T)
     [java] ; (DEFUN MAKE-BLOCK-NODE (NAME) (LET ((BLOCK (%MAKE-BLOCK-NODE NAME))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (JUMP-NODE (:CONC-NAME JUMP-) (:INCLUDE NODE) (:CONSTRUCTOR %MAKE-JUMP-NODE (NON-LOCAL-P TARGET-BLOCK TARGET-TAG))) NON-LOCAL-P TARGET-BLOCK TARGET-TAG)
     [java] ; (DEFUN MAKE-JUMP-NODE (FORM NON-LOCAL-P TARGET-BLOCK &OPTIONAL TARGET-TAG) (LET ((NODE (%MAKE-JUMP-NODE NON-LOCAL-P TARGET-BLOCK TARGET-TAG))) (SETF (NODE-FORM NODE) FORM) (ADD-NODE-CHILD *BLOCK* NODE) NODE))
     [java] ; (DEFSTRUCT (BINDING-NODE (:INCLUDE NODE)) ENVIRONMENT-REGISTER VARS FREE-SPECIALS)
     [java] ; (DEFSTRUCT (LET/LET*-NODE (:CONC-NAME LET-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-LET/LET*-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-LET/LET*-NODE NIL T)
     [java] ; (DEFUN MAKE-LET/LET*-NODE NIL (LET ((BLOCK (%MAKE-LET/LET*-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (FLET-NODE (:CONC-NAME FLET-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-FLET-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-FLET-NODE NIL T)
     [java] ; (DEFUN MAKE-FLET-NODE NIL (LET ((BLOCK (%MAKE-FLET-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (LABELS-NODE (:CONC-NAME LABELS-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-LABELS-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-LABELS-NODE NIL T)
     [java] ; (DEFUN MAKE-LABELS-NODE NIL (LET ((BLOCK (%MAKE-LABELS-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (M-V-B-NODE (:CONC-NAME M-V-B-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-M-V-B-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-M-V-B-NODE NIL T)
     [java] ; (DEFUN MAKE-M-V-B-NODE NIL (LET ((BLOCK (%MAKE-M-V-B-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (PROGV-NODE (:CONC-NAME PROGV-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-PROGV-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-PROGV-NODE NIL T)
     [java] ; (DEFUN MAKE-PROGV-NODE NIL (LET ((BLOCK (%MAKE-PROGV-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) BLOCK))
     [java] ; (DEFSTRUCT (LOCALLY-NODE (:CONC-NAME LOCALLY-) (:INCLUDE BINDING-NODE) (:CONSTRUCTOR %MAKE-LOCALLY-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-LOCALLY-NODE NIL T)
     [java] ; (DEFUN MAKE-LOCALLY-NODE NIL (LET ((BLOCK (%MAKE-LOCALLY-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (PROTECTED-NODE (:INCLUDE NODE) (:CONSTRUCTOR %MAKE-PROTECTED-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-PROTECTED-NODE NIL T)
     [java] ; (DEFUN MAKE-PROTECTED-NODE NIL (LET ((BLOCK (%MAKE-PROTECTED-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (UNWIND-PROTECT-NODE (:CONC-NAME UNWIND-PROTECT-) (:INCLUDE PROTECTED-NODE) (:CONSTRUCTOR %MAKE-UNWIND-PROTECT-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-UNWIND-PROTECT-NODE NIL T)
     [java] ; (DEFUN MAKE-UNWIND-PROTECT-NODE NIL (LET ((BLOCK (%MAKE-UNWIND-PROTECT-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (SYNCHRONIZED-NODE (:CONC-NAME SYNCHRONIZED-) (:INCLUDE PROTECTED-NODE) (:CONSTRUCTOR %MAKE-SYNCHRONIZED-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-SYNCHRONIZED-NODE NIL T)
     [java] ; (DEFUN MAKE-SYNCHRONIZED-NODE NIL (LET ((BLOCK (%MAKE-SYNCHRONIZED-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFSTRUCT (EXCEPTION-PROTECTED-NODE (:CONC-NAME EXCEPTION-PROTECTED-) (:INCLUDE PROTECTED-NODE) (:CONSTRUCTOR %MAKE-EXCEPTION-PROTECTED-NODE NIL)))
     [java] ; (DEFKNOWN MAKE-EXCEPTION-PROTECTED-NODE NIL T)
     [java] ; (DEFUN MAKE-EXCEPTION-PROTECTED-NODE NIL (LET ((BLOCK (%MAKE-EXCEPTION-PROTECTED-NODE))) (PUSH BLOCK (COMPILAND-BLOCKS *CURRENT-COMPILAND*)) (ADD-NODE-CHILD *BLOCK* BLOCK) BLOCK))
     [java] ; (DEFUN FIND-BLOCK (NAME) (DOLIST (BLOCK *BLOCKS*) (WHEN (AND (BLOCK-NODE-P BLOCK) (EQ NAME (BLOCK-NAME BLOCK))) (RETURN BLOCK))))
     [java] ; (DEFUN %FIND-ENCLOSED-BLOCKS (FORM TRAVERSED-BLOCKS) "Helper function for `find-enclosed-blocks`, implementing the actual
     [java] algorithm specified there.
     [java] `traversed-blocks' prevents traversal of recursive structures." (COND ((NODE-P FORM) (LIST FORM)) ((ATOM FORM) NIL) (T (DO* ((TAIL FORM (CDR TAIL)) (CURRENT-BLOCK (IF (CONSP TAIL) (CAR TAIL) TAIL) (IF (CONSP TAIL) (CAR TAIL) TAIL)) BLOCKS) ((NULL TAIL) BLOCKS) (UNLESS (GETHASH CURRENT-BLOCK TRAVERSED-BLOCKS) (SETF (GETHASH CURRENT-BLOCK TRAVERSED-BLOCKS) T) (SETF BLOCKS (NCONC (%FIND-ENCLOSED-BLOCKS CURRENT-BLOCK TRAVERSED-BLOCKS) BLOCKS))) (WHEN (NOT (LISTP TAIL)) (RETURN BLOCKS))))))
     [java] ; (DEFUN FIND-ENCLOSED-BLOCKS (FORM) "Returns the immediate enclosed blocks by searching the form's subforms.
     [java]
     [java] More deeply nested blocks can be reached through the `node-children`
     [java] field of the immediate enclosed blocks." (WHEN *BLOCKS* (LET ((FIRST-ENCLOSING-BLOCK (CAR *BLOCKS*))) (WHEN (AND (EQ *CURRENT-COMPILAND* (NODE-COMPILAND FIRST-ENCLOSING-BLOCK)) (NULL (NODE-CHILDREN FIRST-ENCLOSING-BLOCK))) (RETURN-FROM FIND-ENCLOSED-BLOCKS)))) (%FIND-ENCLOSED-BLOCKS FORM (MAKE-HASH-TABLE :TEST (QUOTE EQ))))
     [java] ; (DEFUN SOME-NESTED-BLOCK (PREDICATE BLOCKS) "Applies `predicate` recursively to the `blocks` and its children,
     [java] until predicate returns non-NIL, returning that value.
     [java]
     [java] `blocks` may be a single block or a list of blocks." (WHEN BLOCKS (SOME (FUNCTION (LAMBDA (B) (OR (FUNCALL PREDICATE B) (SOME-NESTED-BLOCK PREDICATE (NODE-CHILDREN B))))) (IF (LISTP BLOCKS) BLOCKS (LIST BLOCKS)))))
     [java] ; (DEFKNOWN NODE-CONSTANT-P (T) BOOLEAN)
     [java] ; (DEFUN NODE-CONSTANT-P (OBJECT) (COND ((NODE-P OBJECT) NIL) ((VAR-REF-P OBJECT) NIL) ((CONSTANTP OBJECT) T) (T NIL)))
     [java] ; (DEFKNOWN BLOCK-REQUIRES-NON-LOCAL-EXIT-P (T) BOOLEAN)
     [java] ; (DEFUN BLOCK-REQUIRES-NON-LOCAL-EXIT-P (OBJECT) "A block which *always* requires a 'non-local-exit' is a block which
     [java] requires a transfer control exception to be thrown: e.g. Go and Return.
     [java]
     [java] Non-local exits are required by blocks which do more in their cleanup
     [java] than just restore the lastSpecialBinding (= dynamic environment).
     [java] " (OR (UNWIND-PROTECT-NODE-P OBJECT) (CATCH-NODE-P OBJECT) (SYNCHRONIZED-NODE-P OBJECT)))
     [java] ; (DEFUN NODE-OPSTACK-UNSAFE-P (NODE) (OR (WHEN (JUMP-NODE-P NODE) (LET ((TARGET-BLOCK (JUMP-TARGET-BLOCK NODE))) (AND (NULL (JUMP-NON-LOCAL-P NODE)) (MEMBER TARGET-BLOCK *BLOCKS*)))) (WHEN (TAGBODY-NODE-P NODE) (TAGBODY-NON-LOCAL-GO-P NODE)) (WHEN (BLOCK-NODE-P NODE) (BLOCK-NON-LOCAL-RETURN-P NODE)) (CATCH-NODE-P NODE)))
     [java] ; (DEFKNOWN BLOCK-CREATES-RUNTIME-BINDINGS-P (T) BOOLEAN)
     [java] ; (DEFUN BLOCK-CREATES-RUNTIME-BINDINGS-P (BLOCK) (PROGV-NODE-P BLOCK))
     [java] ; (DEFKNOWN ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P (T) BOOLEAN)
     [java] ; (DEFUN ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P (OUTERMOST-BLOCK) "Indicates whether the code being compiled/analyzed is enclosed in a
     [java] block which creates special bindings at runtime." (DOLIST (ENCLOSING-BLOCK *BLOCKS*) (WHEN (EQ ENCLOSING-BLOCK OUTERMOST-BLOCK) (RETURN-FROM ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P NIL)) (WHEN (BLOCK-CREATES-RUNTIME-BINDINGS-P ENCLOSING-BLOCK) (RETURN-FROM ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P T))))
     [java] ; (DEFKNOWN ENCLOSED-BY-PROTECTED-BLOCK-P (&OPTIONAL T) BOOLEAN)
     [java] ; (DEFUN ENCLOSED-BY-PROTECTED-BLOCK-P (&OPTIONAL OUTERMOST-BLOCK) "Indicates whether the code being compiled/analyzed is enclosed in
     [java] a block which requires a non-local transfer of control exception to
     [java] be generated.
     [java] " (DOLIST (ENCLOSING-BLOCK *BLOCKS*) (WHEN (EQ ENCLOSING-BLOCK OUTERMOST-BLOCK) (RETURN-FROM ENCLOSED-BY-PROTECTED-BLOCK-P NIL)) (WHEN (BLOCK-REQUIRES-NON-LOCAL-EXIT-P ENCLOSING-BLOCK) (RETURN-FROM ENCLOSED-BY-PROTECTED-BLOCK-P T))))
     [java] ; (DEFKNOWN ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P (&OPTIONAL T) BOOLEAN)
     [java] ; (DEFUN ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P (&OPTIONAL OUTERMOST-BLOCK) (DOLIST (ENCLOSING-BLOCK *BLOCKS*) (WHEN (EQ ENCLOSING-BLOCK OUTERMOST-BLOCK) (RETURN NIL)) (WHEN (AND (BINDING-NODE-P ENCLOSING-BLOCK) (BINDING-NODE-ENVIRONMENT-REGISTER ENCLOSING-BLOCK)) (RETURN T))))
     [java] ; (DEFKNOWN ENVIRONMENT-REGISTER-TO-RESTORE (&OPTIONAL T) T)
     [java] ; (DEFUN ENVIRONMENT-REGISTER-TO-RESTORE (&OPTIONAL OUTERMOST-BLOCK) "Returns the environment register which contains the
     [java] saved environment from the outermost enclosing block:
     [java]
     [java] That's the one which contains the environment used in the outermost block." (FLET ((OUTERMOST-REGISTER (LAST-REGISTER BLOCK) (WHEN (EQ BLOCK OUTERMOST-BLOCK) (RETURN-FROM ENVIRONMENT-REGISTER-TO-RESTORE LAST-REGISTER)) (OR (AND (BINDING-NODE-P BLOCK) (BINDING-NODE-ENVIRONMENT-REGISTER BLOCK)) LAST-REGISTER))) (REDUCE (FUNCTION OUTERMOST-REGISTER) *BLOCKS* :INITIAL-VALUE NIL)))
     [java] ; (DEFSTRUCT TAG NAME LABEL BLOCK (COMPILAND *CURRENT-COMPILAND*) USED USED-NON-LOCALLY)
     [java] ; (DEFKNOWN FIND-TAG (T) T)
     [java] ; (DEFUN FIND-TAG (NAME) (DOLIST (TAG *VISIBLE-TAGS*) (WHEN (EQL NAME (TAG-NAME TAG)) (RETURN TAG))))
     [java] ; (DEFUN PROCESS-IGNORE/IGNORABLE (DECLARATION NAMES VARIABLES) (WHEN (MEMQ DECLARATION (QUOTE (IGNORE IGNORABLE))) (LET ((WHAT (IF (EQ DECLARATION (QUOTE IGNORE)) "ignored" "ignorable"))) (DOLIST (NAME NAMES) (UNLESS (AND (CONSP NAME) (EQ (CAR NAME) (QUOTE FUNCTION))) (LET ((VARIABLE (FIND-VARIABLE NAME VARIABLES))) (COND ((NULL VARIABLE) (COMPILER-STYLE-WARN "Declaring unknown variable ~S to be ~A." NAME WHAT)) ((VARIABLE-SPECIAL-P VARIABLE) (COMPILER-STYLE-WARN "Declaring special variable ~S to be ~A." NAME WHAT)) ((EQ DECLARATION (QUOTE IGNORE)) (SETF (VARIABLE-IGNORE-P VARIABLE) T)) (T (SETF (VARIABLE-IGNORABLE-P VARIABLE) T)))))))))
     [java] ; (DEFUN FINALIZE-GENERIC-FUNCTIONS NIL (DOLIST (SYM (QUOTE (MAKE-INSTANCE INITIALIZE-INSTANCE SHARED-INITIALIZE))) (LET ((GF (AND (FBOUNDP SYM) (FDEFINITION SYM)))) (WHEN (TYPEP GF (QUOTE STANDARD-GENERIC-FUNCTION)) (UNLESS (COMPILED-FUNCTION-P GF) (MOP::FINALIZE-STANDARD-GENERIC-FUNCTION GF))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm.abcl (32.821 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm.abcl (4.472 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/source-transform.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN SOURCE-TRANSFORM (NAME) (GET-FUNCTION-INFO-VALUE NAME :SOURCE-TRANSFORM))
     [java] ; (DEFUN SET-SOURCE-TRANSFORM (NAME TRANSFORM) (SET-FUNCTION-INFO-VALUE NAME :SOURCE-TRANSFORM TRANSFORM))
     [java] ; (DEFSETF SOURCE-TRANSFORM SET-SOURCE-TRANSFORM)
     [java] ; (DEFMACRO DEFINE-SOURCE-TRANSFORM (NAME LAMBDA-LIST &REST BODY) (LET* ((FORM (GENSYM)) (ENV (GENSYM)) (BLOCK-NAME (IF (SYMBOLP NAME) NAME (CADR NAME))) (BODY (PARSE-DEFMACRO LAMBDA-LIST FORM BODY NAME (QUOTE DEFMACRO) :ENVIRONMENT ENV :ERROR-FUN (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (&REST IGNORED)) (QUOTE (DECLARE (IGNORE IGNORED))) (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK-NAME FORM)))) (EXPANDER (BACKQ-LIST (QUOTE LAMBDA) (BACKQ-LIST FORM) (BACKQ-LIST (QUOTE BLOCK) BLOCK-NAME BODY)))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE :SOURCE-TRANSFORM) NAME))) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE SOURCE-TRANSFORM) (BACKQ-LIST (QUOTE QUOTE) NAME)) EXPANDER) (BACKQ-LIST (QUOTE QUOTE) NAME)))))
     [java] ; (DEFUN EXPAND-SOURCE-TRANSFORM-1 (FORM) (LET ((EXPANDER NIL) (NEWDEF NIL)) (COND ((ATOM FORM) (VALUES FORM NIL)) ((AND (CONSP (%CAR FORM)) (EQ (CAAR FORM) (QUOTE SETF)) (SETF EXPANDER (SOURCE-TRANSFORM (%CAR FORM)))) (VALUES (SETF NEWDEF (FUNCALL EXPANDER FORM)) (NOT (EQ NEWDEF FORM)))) ((AND (SYMBOLP (%CAR FORM)) (SETF EXPANDER (SOURCE-TRANSFORM (%CAR FORM)))) (VALUES (SETF NEWDEF (FUNCALL EXPANDER FORM)) (NOT (EQ NEWDEF FORM)))) (T (VALUES FORM NIL)))))
     [java] ; (DEFUN EXPAND-SOURCE-TRANSFORM (FORM) (LET ((EXPANDED-P NIL)) (LOOP (MULTIPLE-VALUE-BIND (EXPANSION EXP-P) (EXPAND-SOURCE-TRANSFORM-1 FORM) (IF EXP-P (SETF FORM EXPANSION EXPANDED-P T) (RETURN)))) (VALUES FORM EXPANDED-P)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/source-transform.abcl (0.232 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/source-transform.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/source-transform.abcl (0.038 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-macro.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFVAR *COMPILER-MACROS* (MAKE-HASH-TABLE :TEST (FUNCTION EQUAL)))
     [java] ; (DEFUN COMPILER-MACRO-FUNCTION (NAME &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (GETHASH1 NAME (THE HASH-TABLE *COMPILER-MACROS*)))
     [java] ; (DEFUN (SETF COMPILER-MACRO-FUNCTION) (NEW-FUNCTION NAME &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (SETF (GETHASH NAME (THE HASH-TABLE *COMPILER-MACROS*)) NEW-FUNCTION))
     [java] ; (DEFMACRO DEFINE-COMPILER-MACRO (NAME LAMBDA-LIST &REST BODY) (LET* ((FORM (GENSYM)) (ENV (GENSYM)) (BLOCK-NAME (FDEFINITION-BLOCK-NAME NAME))) (MULTIPLE-VALUE-BIND (BODY DECLS) (PARSE-DEFMACRO LAMBDA-LIST FORM BODY NAME (QUOTE DEFMACRO) :ENVIRONMENT ENV :ERROR-FUN (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (&REST IGNORED)) (QUOTE (DECLARE (IGNORE IGNORED))) (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK-NAME FORM))) (LET ((EXPANDER (BACKQ-LIST (QUOTE LAMBDA) (BACKQ-LIST FORM ENV) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORABLE) ENV)) (BACKQ-LIST (QUOTE BLOCK) BLOCK-NAME BODY)))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:COMPILER-MACRO))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE COMPILER-MACRO-FUNCTION) (BACKQ-LIST (QUOTE QUOTE) NAME)) (BACKQ-LIST (QUOTE FUNCTION) EXPANDER)) (BACKQ-LIST (QUOTE QUOTE) NAME))))))
     [java] ; (DEFUN COMPILER-MACROEXPAND-1 (FORM &OPTIONAL ENV) (LET ((EXPANDER NIL) (NEW-FORM NIL)) (IF (AND (CONSP FORM) (SYMBOLP (%CAR FORM)) (SETQ EXPANDER (COMPILER-MACRO-FUNCTION (%CAR FORM) ENV))) (VALUES (SETQ NEW-FORM (FUNCALL EXPANDER FORM ENV)) (NEQ NEW-FORM FORM)) (VALUES FORM NIL))))
     [java] ; (DEFUN COMPILER-MACROEXPAND (FORM &OPTIONAL ENV) (LET ((EXPANDED-P NIL)) (LOOP (MULTIPLE-VALUE-BIND (EXPANSION EXP-P) (COMPILER-MACROEXPAND-1 FORM ENV) (IF EXP-P (SETF FORM EXPANSION EXPANDED-P T) (RETURN)))) (VALUES FORM EXPANDED-P)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-macro.abcl (0.246 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-macro.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-macro.abcl (0.042 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/jvm-instructions.lisp ...
     [java] ; (IN-PACKAGE #:JVM)
     [java] ; (DECLAIM (INLINE U2 S1 S2))
     [java] ; (DEFKNOWN U2 (FIXNUM) CONS)
     [java] ; (DEFUN U2 (N) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (UNSIGNED-BYTE 16) N)) (WHEN (NOT (<= 0 N 65535)) (ERROR "u2 argument ~A out of 65k range." N)) (LIST (LOGAND (ASH N -8) 255) (LOGAND N 255)))
     [java] ; (DEFKNOWN S1 (FIXNUM) FIXNUM)
     [java] ; (DEFUN S1 (N) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (SIGNED-BYTE 8) N)) (WHEN (NOT (<= -128 N 127)) (ERROR "s1 argument ~A out of 8-bit signed range." N)) (IF (< N 0) (1+ (LOGXOR (- N) 255)) N))
     [java] ; (DEFKNOWN S2 (FIXNUM) CONS)
     [java] ; (DEFUN S2 (N) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE (SIGNED-BYTE 16) N)) (WHEN (NOT (<= -32768 N 32767)) (ERROR "s2 argument ~A out of 16-bit signed range." N)) (U2 (IF (< N 0) (1+ (LOGXOR (- N) 65535)) N)))
     [java] ; (DEFCONST *OPCODE-TABLE* (MAKE-ARRAY 256))
     [java] ; (DEFCONST *OPCODES* (MAKE-HASH-TABLE :TEST (QUOTE EQUALP)))
     [java] ; (DEFSTRUCT JVM-OPCODE NAME NUMBER SIZE STACK-EFFECT REGISTER-USED (ARGS-SPEC ""))
     [java] ; (DEFUN %DEFINE-OPCODE (NAME NUMBER SIZE STACK-EFFECT REGISTER &OPTIONAL ARGS-SPEC) (DECLARE (TYPE FIXNUM NUMBER SIZE)) (LET* ((NAME (STRING NAME)) (OPCODE (MAKE-JVM-OPCODE :NAME NAME :NUMBER NUMBER :SIZE SIZE :STACK-EFFECT STACK-EFFECT :REGISTER-USED REGISTER :ARGS-SPEC ARGS-SPEC))) (SETF (SVREF *OPCODE-TABLE* NUMBER) OPCODE) (SETF (GETHASH NAME *OPCODES*) OPCODE) (SETF (GETHASH NUMBER *OPCODES*) OPCODE)))
     [java] ; (DEFMACRO DEFINE-OPCODE (NAME NUMBER SIZE STACK-EFFECT REGISTER &OPTIONAL ARGS-SPEC) (SYSTEM::BACKQ-LIST* (QUOTE %DEFINE-OPCODE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) NUMBER SIZE STACK-EFFECT REGISTER (WHEN ARGS-SPEC (LIST ARGS-SPEC))))
     [java] ; (DEFINE-OPCODE NOP 0 1 0 NIL)
     [java] ; (DEFINE-OPCODE ACONST_NULL 1 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_M1 2 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_0 3 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_1 4 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_2 5 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_3 6 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_4 7 1 1 NIL)
     [java] ; (DEFINE-OPCODE ICONST_5 8 1 1 NIL)
     [java] ; (DEFINE-OPCODE LCONST_0 9 1 2 NIL)
     [java] ; (DEFINE-OPCODE LCONST_1 10 1 2 NIL)
     [java] ; (DEFINE-OPCODE FCONST_0 11 1 1 NIL)
     [java] ; (DEFINE-OPCODE FCONST_1 12 1 1 NIL)
     [java] ; (DEFINE-OPCODE FCONST_2 13 1 1 NIL)
     [java] ; (DEFINE-OPCODE DCONST_0 14 1 2 NIL)
     [java] ; (DEFINE-OPCODE DCONST_1 15 1 2 NIL)
     [java] ; (DEFINE-OPCODE BIPUSH 16 2 1 NIL)
     [java] ; (DEFINE-OPCODE SIPUSH 17 3 1 NIL)
     [java] ; (DEFINE-OPCODE LDC 18 2 1 NIL "p")
     [java] ; (DEFINE-OPCODE LDC_W 19 3 1 NIL "P")
     [java] ; (DEFINE-OPCODE LDC2_W 20 3 2 NIL "P")
     [java] ; (DEFINE-OPCODE ILOAD 21 2 1 T)
     [java] ; (DEFINE-OPCODE LLOAD 22 2 2 T)
     [java] ; (DEFINE-OPCODE FLOAD 23 2 NIL T)
     [java] ; (DEFINE-OPCODE DLOAD 24 2 NIL T)
     [java] ; (DEFINE-OPCODE ALOAD 25 2 1 T)
     [java] ; (DEFINE-OPCODE ILOAD_0 26 1 1 0)
     [java] ; (DEFINE-OPCODE ILOAD_1 27 1 1 1)
     [java] ; (DEFINE-OPCODE ILOAD_2 28 1 1 2)
     [java] ; (DEFINE-OPCODE ILOAD_3 29 1 1 3)
     [java] ; (DEFINE-OPCODE LLOAD_0 30 1 2 0)
     [java] ; (DEFINE-OPCODE LLOAD_1 31 1 2 1)
     [java] ; (DEFINE-OPCODE LLOAD_2 32 1 2 2)
     [java] ; (DEFINE-OPCODE LLOAD_3 33 1 2 3)
     [java] ; (DEFINE-OPCODE FLOAD_0 34 1 NIL 0)
     [java] ; (DEFINE-OPCODE FLOAD_1 35 1 NIL 1)
     [java] ; (DEFINE-OPCODE FLOAD_2 36 1 NIL 2)
     [java] ; (DEFINE-OPCODE FLOAD_3 37 1 NIL 3)
     [java] ; (DEFINE-OPCODE DLOAD_0 38 1 NIL 0)
     [java] ; (DEFINE-OPCODE DLOAD_1 39 1 NIL 1)
     [java] ; (DEFINE-OPCODE DLOAD_2 40 1 NIL 2)
     [java] ; (DEFINE-OPCODE DLOAD_3 41 1 NIL 3)
     [java] ; (DEFINE-OPCODE ALOAD_0 42 1 1 0)
     [java] ; (DEFINE-OPCODE ALOAD_1 43 1 1 1)
     [java] ; (DEFINE-OPCODE ALOAD_2 44 1 1 2)
     [java] ; (DEFINE-OPCODE ALOAD_3 45 1 1 3)
     [java] ; (DEFINE-OPCODE IALOAD 46 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LALOAD 47 1 0 NIL)
     [java] ; (DEFINE-OPCODE FALOAD 48 1 -1 NIL)
     [java] ; (DEFINE-OPCODE DALOAD 49 1 0 NIL)
     [java] ; (DEFINE-OPCODE AALOAD 50 1 -1 NIL)
     [java] ; (DEFINE-OPCODE BALOAD 51 1 NIL NIL)
     [java] ; (DEFINE-OPCODE CALOAD 52 1 NIL NIL)
     [java] ; (DEFINE-OPCODE SALOAD 53 1 NIL NIL)
     [java] ; (DEFINE-OPCODE ISTORE 54 2 -1 T)
     [java] ; (DEFINE-OPCODE LSTORE 55 2 -2 T)
     [java] ; (DEFINE-OPCODE FSTORE 56 2 NIL T)
     [java] ; (DEFINE-OPCODE DSTORE 57 2 NIL T)
     [java] ; (DEFINE-OPCODE ASTORE 58 2 -1 T)
     [java] ; (DEFINE-OPCODE ISTORE_0 59 1 -1 0)
     [java] ; (DEFINE-OPCODE ISTORE_1 60 1 -1 1)
     [java] ; (DEFINE-OPCODE ISTORE_2 61 1 -1 2)
     [java] ; (DEFINE-OPCODE ISTORE_3 62 1 -1 3)
     [java] ; (DEFINE-OPCODE LSTORE_0 63 1 -2 0)
     [java] ; (DEFINE-OPCODE LSTORE_1 64 1 -2 1)
     [java] ; (DEFINE-OPCODE LSTORE_2 65 1 -2 2)
     [java] ; (DEFINE-OPCODE LSTORE_3 66 1 -2 3)
     [java] ; (DEFINE-OPCODE FSTORE_0 67 1 NIL 0)
     [java] ; (DEFINE-OPCODE FSTORE_1 68 1 NIL 1)
     [java] ; (DEFINE-OPCODE FSTORE_2 69 1 NIL 2)
     [java] ; (DEFINE-OPCODE FSTORE_3 70 1 NIL 3)
     [java] ; (DEFINE-OPCODE DSTORE_0 71 1 NIL 0)
     [java] ; (DEFINE-OPCODE DSTORE_1 72 1 NIL 1)
     [java] ; (DEFINE-OPCODE DSTORE_2 73 1 NIL 2)
     [java] ; (DEFINE-OPCODE DSTORE_3 74 1 NIL 3)
     [java] ; (DEFINE-OPCODE ASTORE_0 75 1 -1 0)
     [java] ; (DEFINE-OPCODE ASTORE_1 76 1 -1 1)
     [java] ; (DEFINE-OPCODE ASTORE_2 77 1 -1 2)
     [java] ; (DEFINE-OPCODE ASTORE_3 78 1 -1 3)
     [java] ; (DEFINE-OPCODE IASTORE 79 1 -3 NIL)
     [java] ; (DEFINE-OPCODE LASTORE 80 1 -4 NIL)
     [java] ; (DEFINE-OPCODE FASTORE 81 1 -3 NIL)
     [java] ; (DEFINE-OPCODE DASTORE 82 1 -4 NIL)
     [java] ; (DEFINE-OPCODE AASTORE 83 1 -3 NIL)
     [java] ; (DEFINE-OPCODE BASTORE 84 1 NIL NIL)
     [java] ; (DEFINE-OPCODE CASTORE 85 1 NIL NIL)
     [java] ; (DEFINE-OPCODE SASTORE 86 1 NIL NIL)
     [java] ; (DEFINE-OPCODE POP 87 1 -1 NIL)
     [java] ; (DEFINE-OPCODE POP2 88 1 -2 NIL)
     [java] ; (DEFINE-OPCODE DUP 89 1 1 NIL)
     [java] ; (DEFINE-OPCODE DUP_X1 90 1 1 NIL)
     [java] ; (DEFINE-OPCODE DUP_X2 91 1 1 NIL)
     [java] ; (DEFINE-OPCODE DUP2 92 1 2 NIL)
     [java] ; (DEFINE-OPCODE DUP2_X1 93 1 2 NIL)
     [java] ; (DEFINE-OPCODE DUP2_X2 94 1 2 NIL)
     [java] ; (DEFINE-OPCODE SWAP 95 1 0 NIL)
     [java] ; (DEFINE-OPCODE IADD 96 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LADD 97 1 -2 NIL)
     [java] ; (DEFINE-OPCODE FADD 98 1 -1 NIL)
     [java] ; (DEFINE-OPCODE DADD 99 1 -2 NIL)
     [java] ; (DEFINE-OPCODE ISUB 100 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LSUB 101 1 -2 NIL)
     [java] ; (DEFINE-OPCODE FSUB 102 1 -1 NIL)
     [java] ; (DEFINE-OPCODE DSUB 103 1 -2 NIL)
     [java] ; (DEFINE-OPCODE IMUL 104 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LMUL 105 1 -2 NIL)
     [java] ; (DEFINE-OPCODE FMUL 106 1 -1 NIL)
     [java] ; (DEFINE-OPCODE DMUL 107 1 -2 NIL)
     [java] ; (DEFINE-OPCODE IDIV 108 1 NIL NIL)
     [java] ; (DEFINE-OPCODE LDIV 109 1 NIL NIL)
     [java] ; (DEFINE-OPCODE FDIV 110 1 NIL NIL)
     [java] ; (DEFINE-OPCODE DDIV 111 1 NIL NIL)
     [java] ; (DEFINE-OPCODE IREM 112 1 NIL NIL)
     [java] ; (DEFINE-OPCODE LREM 113 1 NIL NIL)
     [java] ; (DEFINE-OPCODE FREM 114 1 NIL NIL)
     [java] ; (DEFINE-OPCODE DREM 115 1 NIL NIL)
     [java] ; (DEFINE-OPCODE INEG 116 1 0 NIL)
     [java] ; (DEFINE-OPCODE LNEG 117 1 0 NIL)
     [java] ; (DEFINE-OPCODE FNEG 118 1 0 NIL)
     [java] ; (DEFINE-OPCODE DNEG 119 1 0 NIL)
     [java] ; (DEFINE-OPCODE ISHL 120 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LSHL 121 1 -1 NIL)
     [java] ; (DEFINE-OPCODE ISHR 122 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LSHR 123 1 -1 NIL)
     [java] ; (DEFINE-OPCODE IUSHR 124 1 NIL NIL)
     [java] ; (DEFINE-OPCODE LUSHR 125 1 NIL NIL)
     [java] ; (DEFINE-OPCODE IAND 126 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LAND 127 1 -2 NIL)
     [java] ; (DEFINE-OPCODE IOR 128 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LOR 129 1 -2 NIL)
     [java] ; (DEFINE-OPCODE IXOR 130 1 -1 NIL)
     [java] ; (DEFINE-OPCODE LXOR 131 1 -2 NIL)
     [java] ; (DEFINE-OPCODE IINC 132 3 0 T)
     [java] ; (DEFINE-OPCODE I2L 133 1 1 NIL)
     [java] ; (DEFINE-OPCODE I2F 134 1 0 NIL)
     [java] ; (DEFINE-OPCODE I2D 135 1 1 NIL)
     [java] ; (DEFINE-OPCODE L2I 136 1 -1 NIL)
     [java] ; (DEFINE-OPCODE L2F 137 1 -1 NIL)
     [java] ; (DEFINE-OPCODE L2D 138 1 0 NIL)
     [java] ; (DEFINE-OPCODE F2I 139 1 NIL NIL)
     [java] ; (DEFINE-OPCODE F2L 140 1 NIL NIL)
     [java] ; (DEFINE-OPCODE F2D 141 1 1 NIL)
     [java] ; (DEFINE-OPCODE D2I 142 1 NIL NIL)
     [java] ; (DEFINE-OPCODE D2L 143 1 NIL NIL)
     [java] ; (DEFINE-OPCODE D2F 144 1 -1 NIL)
     [java] ; (DEFINE-OPCODE I2B 145 1 NIL NIL)
     [java] ; (DEFINE-OPCODE I2C 146 1 NIL NIL)
     [java] ; (DEFINE-OPCODE I2S 147 1 NIL NIL)
     [java] ; (DEFINE-OPCODE LCMP 148 1 -3 NIL)
     [java] ; (DEFINE-OPCODE FCMPL 149 1 -1 NIL)
     [java] ; (DEFINE-OPCODE FCMPG 150 1 -1 NIL)
     [java] ; (DEFINE-OPCODE DCMPL 151 1 -3 NIL)
     [java] ; (DEFINE-OPCODE DCMPG 152 1 -3 NIL)
     [java] ; (DEFINE-OPCODE IFEQ 153 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFNE 154 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFLT 155 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFGE 156 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFGT 157 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFLE 158 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPEQ 159 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPNE 160 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPLT 161 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPGE 162 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPGT 163 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ICMPLE 164 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ACMPEQ 165 3 -2 NIL)
     [java] ; (DEFINE-OPCODE IF_ACMPNE 166 3 -2 NIL)
     [java] ; (DEFINE-OPCODE GOTO 167 3 0 NIL)
     [java] ; (DEFINE-OPCODE TABLESWITCH 170 0 NIL NIL)
     [java] ; (DEFINE-OPCODE LOOKUPSWITCH 171 0 NIL NIL)
     [java] ; (DEFINE-OPCODE IRETURN 172 1 NIL NIL)
     [java] ; (DEFINE-OPCODE LRETURN 173 1 NIL NIL)
     [java] ; (DEFINE-OPCODE FRETURN 174 1 NIL NIL)
     [java] ; (DEFINE-OPCODE DRETURN 175 1 NIL NIL)
     [java] ; (DEFINE-OPCODE IRETURN 172 1 -1 NIL)
     [java] ; (DEFINE-OPCODE ARETURN 176 1 -1 NIL)
     [java] ; (DEFINE-OPCODE RETURN 177 1 0 NIL)
     [java] ; (DEFINE-OPCODE GETSTATIC 178 3 1 NIL "P")
     [java] ; (DEFINE-OPCODE PUTSTATIC 179 3 -1 NIL "P")
     [java] ; (DEFINE-OPCODE GETFIELD 180 3 0 NIL "P")
     [java] ; (DEFINE-OPCODE PUTFIELD 181 3 -2 NIL "P")
     [java] ; (DEFINE-OPCODE INVOKEVIRTUAL 182 3 NIL NIL "P")
     [java] ; (DEFINE-OPCODE INVOKESPECIAL 183 3 NIL NIL "P")
     [java] ; (DEFINE-OPCODE INVOKESTATIC 184 3 NIL NIL "P")
     [java] ; (DEFINE-OPCODE INVOKEINTERFACE 185 5 NIL NIL "P")
     [java] ; (DEFINE-OPCODE UNUSED 186 0 NIL NIL)
     [java] ; (DEFINE-OPCODE NEW 187 3 1 NIL "P")
     [java] ; (DEFINE-OPCODE NEWARRAY 188 2 NIL NIL)
     [java] ; (DEFINE-OPCODE ANEWARRAY 189 3 0 NIL)
     [java] ; (DEFINE-OPCODE ARRAYLENGTH 190 1 0 NIL)
     [java] ; (DEFINE-OPCODE ATHROW 191 1 0 NIL)
     [java] ; (DEFINE-OPCODE CHECKCAST 192 3 0 NIL "P")
     [java] ; (DEFINE-OPCODE INSTANCEOF 193 3 0 NIL "P")
     [java] ; (DEFINE-OPCODE MONITORENTER 194 1 -1 NIL)
     [java] ; (DEFINE-OPCODE MONITOREXIT 195 1 -1 NIL)
     [java] ; (DEFINE-OPCODE WIDE 196 0 NIL NIL)
     [java] ; (DEFINE-OPCODE MULTIANEWARRAY 197 4 NIL NIL)
     [java] ; (DEFINE-OPCODE IFNULL 198 3 -1 NIL)
     [java] ; (DEFINE-OPCODE IFNONNULL 199 3 NIL NIL)
     [java] ; (DEFINE-OPCODE GOTO_W 200 5 NIL NIL)
     [java] ; (DEFINE-OPCODE LABEL 202 0 0 NIL)
     [java] ; (DEFINE-OPCODE CLEAR-VALUES 205 0 0 T)
     [java] ; (DEFPARAMETER *LAST-OPCODE* 206)
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) OPCODE-NAME))
     [java] ; (DEFUN OPCODE-NAME (OPCODE-NUMBER) (LET ((OPCODE (GETHASH OPCODE-NUMBER *OPCODES*))) (AND OPCODE (JVM-OPCODE-NAME OPCODE))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) (INTEGER 0 255)) OPCODE-NUMBER))
     [java] ; (DEFUN OPCODE-NUMBER (OPCODE-NAME) (DECLARE (OPTIMIZE SPEED)) (LET ((OPCODE (GETHASH (STRING OPCODE-NAME) *OPCODES*))) (IF OPCODE (JVM-OPCODE-NUMBER OPCODE) (ERROR "Unknown opcode ~S." OPCODE-NAME))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) FIXNUM) OPCODE-SIZE))
     [java] ; (DEFUN OPCODE-SIZE (OPCODE-NUMBER) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (DECLARE (TYPE (INTEGER 0 255) OPCODE-NUMBER)) (JVM-OPCODE-SIZE (SVREF *OPCODE-TABLE* OPCODE-NUMBER)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) OPCODE-STACK-EFFECT))
     [java] ; (DEFUN OPCODE-STACK-EFFECT (OPCODE-NUMBER) (DECLARE (OPTIMIZE SPEED)) (JVM-OPCODE-STACK-EFFECT (SVREF *OPCODE-TABLE* OPCODE-NUMBER)))
     [java] ; (DEFUN OPCODE-ARGS-SPEC (OPCODE-NUMBER) (LET ((OPCODE (GETHASH OPCODE-NUMBER *OPCODES*))) (AND OPCODE (JVM-OPCODE-ARGS-SPEC))))
     [java] ; (DEFSTRUCT (INSTRUCTION (:CONSTRUCTOR %MAKE-INSTRUCTION (OPCODE ARGS))) (OPCODE 0 :TYPE (INTEGER 0 255)) ARGS STACK DEPTH WIDE)
     [java] ; (DEFUN MAKE-INSTRUCTION (OPCODE ARGS) (LET ((INST (APPLY (FUNCTION %MAKE-INSTRUCTION) (LIST OPCODE (REMOVE :WIDE-PREFIX ARGS))))) (WHEN (MEMQ :WIDE-PREFIX ARGS) (SETF (INST-WIDE INST) T)) INST))
     [java] ; (DEFUN PRINT-INSTRUCTION (INSTRUCTION) (SYSTEM::%FORMAT NIL "~A ~A stack = ~S depth = ~S" (OPCODE-NAME (INSTRUCTION-OPCODE INSTRUCTION)) (INSTRUCTION-ARGS INSTRUCTION) (INSTRUCTION-STACK INSTRUCTION) (INSTRUCTION-DEPTH INSTRUCTION)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) INSTRUCTION-LABEL))
     [java] ; (DEFUN INSTRUCTION-LABEL (INSTRUCTION) (AND INSTRUCTION (= (INSTRUCTION-OPCODE (THE INSTRUCTION INSTRUCTION)) 202) (CAR (INSTRUCTION-ARGS INSTRUCTION))))
     [java] ; (DEFKNOWN INST * T)
     [java] ; (DEFUN INST (INSTR &OPTIONAL ARGS) (DECLARE (OPTIMIZE SPEED)) (LET ((OPCODE (IF (FIXNUMP INSTR) INSTR (OPCODE-NUMBER INSTR)))) (UNLESS (LISTP ARGS) (SETF ARGS (LIST ARGS))) (MAKE-INSTRUCTION OPCODE ARGS)))
     [java] ; (DEFVAR *CODE* NIL)
     [java] ; (DEFKNOWN %%EMIT * T)
     [java] ; (DEFUN %%EMIT (INSTR &REST ARGS) (DECLARE (OPTIMIZE SPEED)) (LET ((INSTRUCTION (MAKE-INSTRUCTION INSTR ARGS))) (PUSH INSTRUCTION *CODE*) INSTRUCTION))
     [java] ; (DEFKNOWN %EMIT * T)
     [java] ; (DEFUN %EMIT (INSTR &REST ARGS) (DECLARE (OPTIMIZE SPEED)) (LET ((INSTRUCTION (INST INSTR ARGS))) (PUSH INSTRUCTION *CODE*) INSTRUCTION))
     [java] ; (DEFMACRO EMIT (INSTR &REST ARGS) (WHEN (AND (CONSP INSTR) (EQ (CAR INSTR) (QUOTE QUOTE)) (SYMBOLP (CADR INSTR))) (SETF INSTR (OPCODE-NUMBER (CADR INSTR)))) (IF (FIXNUMP INSTR) (SYSTEM::BACKQ-LIST* (QUOTE %%EMIT) INSTR ARGS) (SYSTEM::BACKQ-LIST* (QUOTE %EMIT) INSTR ARGS)))
     [java] ; (DEFKNOWN LABEL (SYMBOL) T)
     [java] ; (DEFUN LABEL (SYMBOL) (DECLARE (TYPE SYMBOL SYMBOL)) (DECLARE (OPTIMIZE SPEED)) (EMIT (QUOTE LABEL) SYMBOL) (SETF (SYMBOL-VALUE SYMBOL) NIL))
     [java] ; (DEFKNOWN ALOAD (FIXNUM) T)
     [java] ; (DEFUN ALOAD (INDEX) (CASE INDEX (0 (EMIT (QUOTE ALOAD_0))) (1 (EMIT (QUOTE ALOAD_1))) (2 (EMIT (QUOTE ALOAD_2))) (3 (EMIT (QUOTE ALOAD_3))) (T (EMIT (QUOTE ALOAD) INDEX))))
     [java] ; (DEFKNOWN ASTORE (FIXNUM) T)
     [java] ; (DEFUN ASTORE (INDEX) (CASE INDEX (0 (EMIT (QUOTE ASTORE_0))) (1 (EMIT (QUOTE ASTORE_1))) (2 (EMIT (QUOTE ASTORE_2))) (3 (EMIT (QUOTE ASTORE_3))) (T (EMIT (QUOTE ASTORE) INDEX))))
     [java] ; (DEFKNOWN ILOAD (FIXNUM) T)
     [java] ; (DEFUN ILOAD (INDEX) (CASE INDEX (0 (EMIT (QUOTE ILOAD_0))) (1 (EMIT (QUOTE ILOAD_1))) (2 (EMIT (QUOTE ILOAD_2))) (3 (EMIT (QUOTE ILOAD_3))) (T (EMIT (QUOTE ILOAD) INDEX))))
     [java] ; (DEFKNOWN ISTORE (FIXNUM) T)
     [java] ; (DEFUN ISTORE (INDEX) (CASE INDEX (0 (EMIT (QUOTE ISTORE_0))) (1 (EMIT (QUOTE ISTORE_1))) (2 (EMIT (QUOTE ISTORE_2))) (3 (EMIT (QUOTE ISTORE_3))) (T (EMIT (QUOTE ISTORE) INDEX))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) BRANCH-P) (INLINE BRANCH-P))
     [java] ; (DEFUN BRANCH-P (OPCODE) (OR (<= 153 OPCODE 167) (<= 198 OPCODE 200)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) UNCONDITIONAL-CONTROL-TRANSFER-P) (INLINE UNCONDITIONAL-CONTROL-TRANSFER-P))
     [java] ; (DEFUN UNCONDITIONAL-CONTROL-TRANSFER-P (OPCODE) (OR (= 167 OPCODE) (= 200 OPCODE) (<= 172 OPCODE 177) (= 191 OPCODE)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) BOOLEAN) LABEL-P) (INLINE LABEL-P))
     [java] ; (DEFUN LABEL-P (INSTRUCTION) (AND INSTRUCTION (= (THE FIXNUM (INSTRUCTION-OPCODE (THE INSTRUCTION INSTRUCTION))) 202)))
     [java] ; (DEFUN FORMAT-INSTRUCTION-ARGS (INSTRUCTION POOL) (IF (MEMQL (INSTRUCTION-OPCODE INSTRUCTION) (QUOTE (18 19 20 178 179 180 181 182 183 184 185 187 192 193))) (LET ((*PRINT-READABLY* NIL) (*PRINT-ESCAPE* NIL)) (WITH-OUTPUT-TO-STRING (S) (PRINT-POOL-CONSTANT POOL (FIND-POOL-ENTRY POOL (CAR (INSTRUCTION-ARGS INSTRUCTION))) S :PACKAGE "org/armedbear/lisp"))) (WHEN (INSTRUCTION-ARGS INSTRUCTION) (FORMAT NIL "~S" (INSTRUCTION-ARGS INSTRUCTION)))))
     [java] ; (DEFUN PRINT-CODE (CODE POOL) (DECLARE (IGNORABLE POOL)) (DOTIMES (I (LENGTH CODE)) (LET ((INSTRUCTION (ELT CODE I))) (FORMAT T "~3D ~A ~19T~A ~A ~A~%" I (OPCODE-NAME (INSTRUCTION-OPCODE INSTRUCTION)) (OR (FORMAT-INSTRUCTION-ARGS INSTRUCTION POOL) "") (OR (INSTRUCTION-STACK INSTRUCTION) "") (OR (INSTRUCTION-DEPTH INSTRUCTION) "")))))
     [java] ; (DEFUN PRINT-CODE2 (CODE POOL) (DECLARE (IGNORABLE POOL)) (DOTIMES (I (LENGTH CODE)) (LET ((INSTRUCTION (ELT CODE I))) (CASE (INSTRUCTION-OPCODE INSTRUCTION) (202 (FORMAT T "~A:~%" (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (T (FORMAT T "~8D:   ~A ~S~%" I (OPCODE-NAME (INSTRUCTION-OPCODE INSTRUCTION)) (INSTRUCTION-ARGS INSTRUCTION)))))))
     [java] ; (DEFUN EXPAND-VIRTUAL-INSTRUCTIONS (CODE) (LET* ((LEN (LENGTH CODE)) (VECTOR (MAKE-ARRAY (ASH LEN 1) :FILL-POINTER 0 :ADJUSTABLE T))) (DOTIMES (INDEX LEN VECTOR) (DECLARE (TYPE (UNSIGNED-BYTE 16) INDEX)) (LET ((INSTRUCTION (SVREF CODE INDEX))) (CASE (INSTRUCTION-OPCODE INSTRUCTION) (205 (DOLIST (INSTRUCTION (LIST (INST (QUOTE ALOAD) (CAR (INSTRUCTION-ARGS INSTRUCTION))) (INST (QUOTE ACONST_NULL)) (INST (QUOTE PUTFIELD) (LIST (POOL-FIELD +LISP-THREAD+ "_values" +LISP-OBJECT-ARRAY+))))) (VECTOR-PUSH-EXTEND INSTRUCTION VECTOR))) (T (VECTOR-PUSH-EXTEND INSTRUCTION VECTOR)))))))
     [java] ; (DEFUN UNSUPPORTED-OPCODE (INSTRUCTION) (ERROR "Unsupported opcode ~D." (INSTRUCTION-OPCODE INSTRUCTION)))
     [java] ; (DECLAIM (TYPE HASH-TABLE +RESOLVERS+))
     [java] ; (DEFCONST +RESOLVERS+ (MAKE-HASH-TABLE))
     [java] ; (DEFUN INITIALIZE-RESOLVERS NIL (LET ((HT +RESOLVERS+)) (DOTIMES (N (1+ *LAST-OPCODE*)) (SETF (GETHASH N HT) (FUNCTION UNSUPPORTED-OPCODE))) (DOLIST (N (QUOTE (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 26 27 28 29 42 43 44 45 46 47 48 49 50 54 59 60 61 62 75 76 77 78 79 80 81 82 83 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 116 117 118 119 120 121 122 123 126 127 128 129 130 131 133 134 135 136 137 138 141 144 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 172 176 177 189 190 191 194 195 198 202))) (SETF (GETHASH N HT) NIL))))
     [java] ; (DEFMACRO DEFINE-RESOLVER (OPCODES ARGS &BODY BODY) (LET ((NAME (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE DEFUN) NAME ARGS BODY) (SYSTEM::BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:LOAD-TOPLEVEL :EXECUTE)) (IF (LISTP OPCODES) (SYSTEM::BACKQ-LIST (QUOTE DOLIST) (SYSTEM::BACKQ-LIST (QUOTE OP) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) OPCODES)) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (GETHASH OP +RESOLVERS+)) (SYSTEM::BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME)))) (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST* (QUOTE GETHASH) OPCODES (QUOTE (+RESOLVERS+))) (SYSTEM::BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME))))))))
     [java] ; (DEFUN LOAD/STORE-RESOLVER (INSTRUCTION INST-INDEX INST-INDEX2 ERROR-TEXT) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION)) (INDEX (CAR ARGS))) (DECLARE (TYPE (UNSIGNED-BYTE 16) INDEX)) (COND ((<= 0 INDEX 3) (INST (+ INDEX INST-INDEX))) ((<= 0 INDEX 255) (INST INST-INDEX2 INDEX)) (T (ERROR ERROR-TEXT)))))
     [java] ; (DEFINE-RESOLVER 25 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 42 25 "ALOAD unsupported case"))
     [java] ; (DEFINE-RESOLVER 58 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 75 58 "ASTORE unsupported case"))
     [java] ; (DEFINE-RESOLVER 21 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 26 21 "ILOAD unsupported case"))
     [java] ; (DEFINE-RESOLVER 54 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 59 54 "ISTORE unsupported case"))
     [java] ; (DEFINE-RESOLVER 22 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 30 22 "LLOAD unsupported case"))
     [java] ; (DEFINE-RESOLVER 55 (INSTRUCTION) (LOAD/STORE-RESOLVER INSTRUCTION 63 55 "LSTORE unsupported case"))
     [java] ; (DEFINE-RESOLVER (16 17) (INSTRUCTION) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION)) (N (FIRST ARGS))) (DECLARE (TYPE FIXNUM N)) (COND ((<= 0 N 5) (INST (+ N 3))) ((<= -128 N 127) (INST 16 (LOGAND N 255))) (T (INST 17 (S2 N))))))
     [java] ; (DEFINE-RESOLVER 18 (INSTRUCTION) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION))) (UNLESS (= (LENGTH ARGS) 1) (ERROR "Wrong number of args for LDC.")) (IF (> (CAR ARGS) 255) (INST 19 (U2 (CAR ARGS))) (INST 18 ARGS))))
     [java] ; (DEFINE-RESOLVER 19 (INSTRUCTION) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION))) (UNLESS (= (LENGTH ARGS) 1) (ERROR "Wrong number of args for LDC_W.")) (INST 19 (U2 (CAR ARGS)))))
     [java] ; (DEFINE-RESOLVER 20 (INSTRUCTION) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION))) (UNLESS (= (LENGTH ARGS) 1) (ERROR "Wrong number of args for LDC2_W.")) (INST 20 (U2 (CAR ARGS)))))
     [java] ; (DEFINE-RESOLVER 132 (INSTRUCTION) (LET* ((ARGS (INSTRUCTION-ARGS INSTRUCTION)) (REGISTER (FIRST ARGS)) (N (SECOND ARGS))) (WHEN (NOT (<= -128 N 127)) (ERROR "IINC argument ~A out of bounds." N)) (INST 132 (LIST REGISTER (S1 N)))))
     [java] ; (DEFINE-RESOLVER (178 179 180 181 182 183 184 185 192 193 187) (INSTRUCTION) (LET* ((ARG (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (SETF (INSTRUCTION-ARGS INSTRUCTION) (U2 ARG)) INSTRUCTION))
     [java] ; (DEFKNOWN RESOLVE-INSTRUCTION (T) T)
     [java] ; (DEFUN RESOLVE-INSTRUCTION (INSTRUCTION) (DECLARE (OPTIMIZE SPEED)) (LET ((RESOLVER (GETHASH1 (INSTRUCTION-OPCODE INSTRUCTION) +RESOLVERS+))) (IF RESOLVER (FUNCALL RESOLVER INSTRUCTION) INSTRUCTION)))
     [java] ; (DEFUN RESOLVE-INSTRUCTIONS (CODE) (LET* ((LEN (LENGTH CODE)) (VECTOR (MAKE-ARRAY LEN :FILL-POINTER 0 :ADJUSTABLE T))) (DOTIMES (INDEX LEN VECTOR) (DECLARE (TYPE (UNSIGNED-BYTE 16) INDEX)) (LET ((INSTRUCTION (AREF CODE INDEX))) (VECTOR-PUSH-EXTEND (RESOLVE-INSTRUCTION INSTRUCTION) VECTOR)))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T) T) ANALYZE-STACK-PATH))
     [java] ; (DEFUN ANALYZE-STACK-PATH (CODE START-INDEX DEPTH) (DECLARE (OPTIMIZE SPEED)) (DECLARE (TYPE FIXNUM START-INDEX DEPTH)) (DO* ((I START-INDEX (1+ I)) (LIMIT (LENGTH CODE))) ((>= I LIMIT)) (DECLARE (TYPE FIXNUM I LIMIT)) (LET* ((INSTRUCTION (AREF CODE I)) (INSTRUCTION-DEPTH (INSTRUCTION-DEPTH INSTRUCTION)) (INSTRUCTION-STACK (INSTRUCTION-STACK INSTRUCTION))) (DECLARE (TYPE FIXNUM INSTRUCTION-STACK)) (WHEN INSTRUCTION-DEPTH (UNLESS (= (THE FIXNUM INSTRUCTION-DEPTH) (THE FIXNUM (+ DEPTH INSTRUCTION-STACK))) (INTERNAL-COMPILER-ERROR "Stack inconsistency detected ~
     [java]                                     in ~A at index ~D: ~
     [java]                                     found ~S, expected ~S." (IF *CURRENT-COMPILAND* (COMPILAND-NAME *CURRENT-COMPILAND*) "<unknown>") I INSTRUCTION-DEPTH (+ DEPTH INSTRUCTION-STACK))) (RETURN-FROM ANALYZE-STACK-PATH)) (LET ((OPCODE (INSTRUCTION-OPCODE INSTRUCTION))) (SETF DEPTH (+ DEPTH INSTRUCTION-STACK)) (SETF (INSTRUCTION-DEPTH INSTRUCTION) DEPTH) (UNLESS (<= 0 DEPTH) (INTERNAL-COMPILER-ERROR "Stack inconsistency detected ~
     [java]                                     in ~A at index ~D: ~
     [java]                                     negative depth ~S." (IF *CURRENT-COMPILAND* (COMPILAND-NAME *CURRENT-COMPILAND*) "<unknown>") I DEPTH)) (WHEN (BRANCH-P OPCODE) (LET ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (DECLARE (TYPE SYMBOL LABEL)) (ANALYZE-STACK-PATH CODE (SYMBOL-VALUE LABEL) DEPTH))) (WHEN (UNCONDITIONAL-CONTROL-TRANSFER-P OPCODE) (RETURN-FROM ANALYZE-STACK-PATH))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) T) ANALYZE-STACK))
     [java] ; (DEFUN ANALYZE-STACK (CODE EXCEPTION-ENTRY-POINTS) (DECLARE (OPTIMIZE SPEED)) (LET* ((CODE-LENGTH (LENGTH CODE))) (DECLARE (TYPE VECTOR CODE)) (DOTIMES (I CODE-LENGTH) (LET* ((INSTRUCTION (AREF CODE I)) (OPCODE (INSTRUCTION-OPCODE INSTRUCTION))) (WHEN (EQL OPCODE 202) (LET ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (SET LABEL I))) (UNLESS (INSTRUCTION-STACK INSTRUCTION) (SETF (INSTRUCTION-STACK INSTRUCTION) (OPCODE-STACK-EFFECT OPCODE)) (UNLESS (INSTRUCTION-STACK INSTRUCTION) (SYSTEM::%FORMAT T "no stack information for instruction ~D~%" (INSTRUCTION-OPCODE INSTRUCTION)) (AVER NIL))))) (ANALYZE-STACK-PATH CODE 0 0) (DOLIST (ENTRY-POINT EXCEPTION-ENTRY-POINTS) (ANALYZE-STACK-PATH CODE (SYMBOL-VALUE ENTRY-POINT) 1)) (LET ((MAX-STACK 0)) (DECLARE (TYPE FIXNUM MAX-STACK)) (DOTIMES (I CODE-LENGTH) (LET* ((INSTRUCTION (AREF CODE I)) (INSTRUCTION-DEPTH (INSTRUCTION-DEPTH INSTRUCTION))) (WHEN INSTRUCTION-DEPTH (SETF MAX-STACK (MAX MAX-STACK (THE FIXNUM INSTRUCTION-DEPTH)))))) MAX-STACK)))
     [java] ; (DEFUN ANALYZE-LOCALS (CODE) (LET ((CODE-LENGTH (LENGTH CODE)) (MAX-LOCAL 0)) (DOTIMES (I CODE-LENGTH MAX-LOCAL) (LET* ((INSTRUCTION (AREF CODE I)) (OPCODE (INSTRUCTION-OPCODE INSTRUCTION))) (SETF MAX-LOCAL (MAX MAX-LOCAL (OR (LET ((OPCODE-REGISTER (JVM-OPCODE-REGISTER-USED OPCODE))) (IF (EQ T OPCODE-REGISTER) (CAR (INSTRUCTION-ARGS INSTRUCTION)) OPCODE-REGISTER)) 0)))))))
     [java] ; (DEFUN DELETE-UNUSED-LABELS (CODE HANDLER-LABELS) (DECLARE (OPTIMIZE SPEED)) (LET ((CODE (COERCE CODE (QUOTE VECTOR))) (CHANGED NIL) (MARKER (GENSYM))) (DOTIMES (I (LENGTH CODE)) (LET ((INSTRUCTION (AREF CODE I))) (WHEN (BRANCH-P (INSTRUCTION-OPCODE INSTRUCTION)) (LET ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (SET LABEL MARKER))))) (DOLIST (LABEL HANDLER-LABELS) (SET LABEL MARKER)) (DOTIMES (I (LENGTH CODE)) (LET ((INSTRUCTION (AREF CODE I))) (WHEN (= (INSTRUCTION-OPCODE INSTRUCTION) 202) (LET ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (DECLARE (TYPE SYMBOL LABEL)) (UNLESS (EQ (SYMBOL-VALUE LABEL) MARKER) (SETF (AREF CODE I) NIL) (SETF CHANGED T)))))) (VALUES (IF CHANGED (DELETE NIL CODE) CODE) CHANGED)))
     [java] ; (DEFUN DELETE-UNREACHABLE-CODE (CODE) (DECLARE (OPTIMIZE SPEED)) (LET* ((CODE (COERCE CODE (QUOTE VECTOR))) (CHANGED NIL) (AFTER-GOTO/ARETURN NIL)) (DOTIMES (I (LENGTH CODE)) (DECLARE (TYPE (UNSIGNED-BYTE 16) I)) (LET* ((INSTRUCTION (AREF CODE I)) (OPCODE (INSTRUCTION-OPCODE INSTRUCTION))) (COND (AFTER-GOTO/ARETURN (IF (= OPCODE 202) (SETF AFTER-GOTO/ARETURN NIL) (PROGN (SETF (AREF CODE I) NIL) (SETF CHANGED T)))) ((UNCONDITIONAL-CONTROL-TRANSFER-P OPCODE) (SETF AFTER-GOTO/ARETURN T))))) (VALUES (IF CHANGED (DELETE NIL CODE) CODE) CHANGED)))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T) LABEL-TARGET-INSTRUCTIONS) HASH-LABELS))
     [java] ; (DEFUN LABEL-TARGET-INSTRUCTIONS (CODE) (LET ((HT (MAKE-HASH-TABLE :TEST (QUOTE EQ))) (CODE (COERCE CODE (QUOTE VECTOR))) (PENDING-LABELS (QUOTE NIL))) (DOTIMES (I (LENGTH CODE)) (LET ((INSTRUCTION (AREF CODE I))) (COND ((LABEL-P INSTRUCTION) (PUSH (INSTRUCTION-LABEL INSTRUCTION) PENDING-LABELS)) (T (WHEN PENDING-LABELS (DOLIST (LABEL PENDING-LABELS) (SETF (GETHASH LABEL HT) INSTRUCTION)) (SETF PENDING-LABELS NIL)))))) HT))
     [java] ; (DEFUN OPTIMIZE-JUMPS (CODE) (DECLARE (OPTIMIZE SPEED)) (LET* ((CODE (COERCE CODE (QUOTE VECTOR))) (HT (LABEL-TARGET-INSTRUCTIONS CODE)) (CHANGED NIL)) (DOTIMES (I (LENGTH CODE)) (LET* ((INSTRUCTION (AREF CODE I)) (OPCODE (AND INSTRUCTION (INSTRUCTION-OPCODE INSTRUCTION)))) (WHEN (AND OPCODE (BRANCH-P OPCODE)) (LET* ((TARGET-LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION))) (NEXT-INSTRUCTION (GETHASH1 TARGET-LABEL HT))) (WHEN NEXT-INSTRUCTION (CASE (INSTRUCTION-OPCODE NEXT-INSTRUCTION) ((167 200) (SETF (INSTRUCTION-ARGS INSTRUCTION) (INSTRUCTION-ARGS NEXT-INSTRUCTION) CHANGED T)) (176 (WHEN (UNCONDITIONAL-CONTROL-TRANSFER-P OPCODE) (SETF (INSTRUCTION-OPCODE INSTRUCTION) 176 (INSTRUCTION-ARGS INSTRUCTION) NIL CHANGED T))))))))) (VALUES CODE CHANGED)))
     [java] ; (DEFUN OPTIMIZE-INSTRUCTION-SEQUENCES (CODE) (LET* ((CODE (COERCE CODE (QUOTE VECTOR))) (CHANGED NIL)) (DOTIMES (I (1- (LENGTH CODE))) (LET* ((THIS-INSTRUCTION (AREF CODE I)) (THIS-OPCODE (AND THIS-INSTRUCTION (INSTRUCTION-OPCODE THIS-INSTRUCTION))) (LABELS-SKIPPED-P NIL) (NEXT-INSTRUCTION (DO ((J (1+ I) (1+ J))) ((OR (>= J (LENGTH CODE)) (/= 202 (INSTRUCTION-OPCODE (AREF CODE J)))) (WHEN (< J (LENGTH CODE)) (AREF CODE J))) (SETF LABELS-SKIPPED-P T))) (NEXT-OPCODE (AND NEXT-INSTRUCTION (INSTRUCTION-OPCODE NEXT-INSTRUCTION)))) (CASE THIS-OPCODE (205 (WHEN (EQL NEXT-OPCODE 205) (SETF (AREF CODE I) NIL) (SETF CHANGED T))) (178 (WHEN (AND (EQL NEXT-OPCODE 87) (NOT LABELS-SKIPPED-P)) (SETF (AREF CODE I) NIL) (SETF (AREF CODE (1+ I)) NIL) (SETF CHANGED T))) (176 (WHEN (EQL NEXT-OPCODE 176) (SETF (AREF CODE I) NIL) (SETF CHANGED T))) ((200 167) (WHEN (AND (OR (EQL NEXT-OPCODE 202) (EQL NEXT-OPCODE 200) (EQL NEXT-OPCODE 167)) (EQ (CAR (INSTRUCTION-ARGS THIS-INSTRUCTION)) (CAR (INSTRUCTION-ARGS NEXT-INSTRUCTION)))) (SETF (AREF CODE I) NIL) (SETF CHANGED T)))))) (VALUES (IF CHANGED (DELETE NIL CODE) CODE) CHANGED)))
     [java] ; (DEFVAR *ENABLE-OPTIMIZATION* T)
     [java] ; (DEFKNOWN OPTIMIZE-CODE (T T) T)
     [java] ; (DEFUN OPTIMIZE-CODE (CODE HANDLER-LABELS POOL) (UNLESS *ENABLE-OPTIMIZATION* (FORMAT T "optimizations are disabled~%")) (WHEN *ENABLE-OPTIMIZATION* (WHEN *COMPILER-DEBUG* (FORMAT T "----- before optimization -----~%") (PRINT-CODE CODE POOL)) (LOOP (LET ((CHANGED-P NIL)) (MULTIPLE-VALUE-SETQ (CODE CHANGED-P) (DELETE-UNUSED-LABELS CODE HANDLER-LABELS)) (IF CHANGED-P (SETF CODE (OPTIMIZE-INSTRUCTION-SEQUENCES CODE)) (MULTIPLE-VALUE-SETQ (CODE CHANGED-P) (OPTIMIZE-INSTRUCTION-SEQUENCES CODE))) (IF CHANGED-P (SETF CODE (OPTIMIZE-JUMPS CODE)) (MULTIPLE-VALUE-SETQ (CODE CHANGED-P) (OPTIMIZE-JUMPS CODE))) (IF CHANGED-P (SETF CODE (DELETE-UNREACHABLE-CODE CODE)) (MULTIPLE-VALUE-SETQ (CODE CHANGED-P) (DELETE-UNREACHABLE-CODE CODE))) (UNLESS CHANGED-P (RETURN)))) (UNLESS (VECTORP CODE) (SETF CODE (COERCE CODE (QUOTE VECTOR)))) (WHEN *COMPILER-DEBUG* (SYSTEM::%FORMAT T "----- after optimization -----~%") (PRINT-CODE CODE POOL))) CODE)
     [java] ; (DEFUN CODE-BYTES (CODE) (LET ((LENGTH 0) LABELS) (DECLARE (TYPE (UNSIGNED-BYTE 16) LENGTH)) (DOTIMES (I (LENGTH CODE)) (DECLARE (TYPE (UNSIGNED-BYTE 16) I)) (LET* ((INSTRUCTION (AREF CODE I)) (OPCODE (INSTRUCTION-OPCODE INSTRUCTION))) (IF (= OPCODE 202) (LET ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION)))) (SET LABEL LENGTH) (SETF LABELS (ACONS LABEL LENGTH LABELS))) (INCF LENGTH (OPCODE-SIZE OPCODE))))) (LET ((INDEX 0)) (DECLARE (TYPE (UNSIGNED-BYTE 16) INDEX)) (DOTIMES (I (LENGTH CODE)) (DECLARE (TYPE (UNSIGNED-BYTE 16) I)) (LET ((INSTRUCTION (AREF CODE I))) (WHEN (BRANCH-P (INSTRUCTION-OPCODE INSTRUCTION)) (LET* ((LABEL (CAR (INSTRUCTION-ARGS INSTRUCTION))) (OFFSET (- (THE (UNSIGNED-BYTE 16) (SYMBOL-VALUE (THE SYMBOL LABEL))) INDEX))) (ASSERT (<= -32768 OFFSET 32767)) (SETF (INSTRUCTION-ARGS INSTRUCTION) (S2 OFFSET)))) (UNLESS (= (INSTRUCTION-OPCODE INSTRUCTION) 202) (INCF INDEX (OPCODE-SIZE (INSTRUCTION-OPCODE INSTRUCTION))))))) (LET ((BYTES (MAKE-ARRAY LENGTH)) (INDEX 0)) (DECLARE (TYPE (UNSIGNED-BYTE 16) INDEX)) (DOTIMES (I (LENGTH CODE)) (DECLARE (TYPE (UNSIGNED-BYTE 16) I)) (LET ((INSTRUCTION (AREF CODE I))) (UNLESS (= (INSTRUCTION-OPCODE INSTRUCTION) 202) (SETF (SVREF BYTES INDEX) (INSTRUCTION-OPCODE INSTRUCTION)) (INCF INDEX) (DOLIST (BYTE (INSTRUCTION-ARGS INSTRUCTION)) (SETF (SVREF BYTES INDEX) BYTE) (INCF INDEX))))) (VALUES BYTES LABELS))))
     [java] ; (DEFUN FINALIZE-CODE (CODE HANDLER-LABELS OPTIMIZE POOL) (SETF CODE (COERCE (NREVERSE CODE) (QUOTE VECTOR))) (WHEN OPTIMIZE (SETF CODE (OPTIMIZE-CODE CODE HANDLER-LABELS POOL))) (RESOLVE-INSTRUCTIONS (EXPAND-VIRTUAL-INSTRUCTIONS CODE)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-instructions.abcl (5.897 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-instructions.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/jvm-instructions.abcl (0.865 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/setf.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN GET-SETF-METHOD-INVERSE (FORM INVERSE SETF-FUNCTION) (LET ((NEW-VAR (GENSYM)) (VARS NIL) (VALS NIL)) (DOLIST (X (CDR FORM)) (PUSH (GENSYM) VARS) (PUSH X VALS)) (SETQ VALS (NREVERSE VALS)) (VALUES VARS VALS (LIST NEW-VAR) (IF SETF-FUNCTION (BACKQ-APPEND INVERSE (BACKQ-CONS NEW-VAR VARS)) (IF (FUNCTIONP (CAR INVERSE)) (BACKQ-CONS (QUOTE FUNCALL) (BACKQ-APPEND INVERSE VARS (BACKQ-LIST NEW-VAR))) (BACKQ-APPEND INVERSE VARS (BACKQ-LIST NEW-VAR)))) (BACKQ-CONS (CAR FORM) VARS))))
     [java] ; (DEFUN EXPAND-OR-GET-SETF-INVERSE (FORM ENVIRONMENT) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED) (MACROEXPAND-1 FORM ENVIRONMENT) (IF EXPANDED (GET-SETF-EXPANSION EXPANSION ENVIRONMENT) (GET-SETF-METHOD-INVERSE FORM (BACKQ-LIST (QUOTE FUNCALL) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE SETF) (CAR FORM)))) T))))
     [java] ; (DEFUN GET-SETF-EXPANSION (FORM &OPTIONAL ENVIRONMENT) (LET (TEMP) (COND ((SYMBOLP FORM) (MULTIPLE-VALUE-BIND (EXPANSION EXPANDED) (MACROEXPAND-1 FORM ENVIRONMENT) (IF EXPANDED (GET-SETF-EXPANSION EXPANSION ENVIRONMENT) (LET ((NEW-VAR (GENSYM))) (VALUES NIL NIL (LIST NEW-VAR) (BACKQ-LIST (QUOTE SETQ) FORM NEW-VAR) FORM))))) ((SETQ TEMP (GET (CAR FORM) (QUOTE SETF-INVERSE))) (GET-SETF-METHOD-INVERSE FORM (BACKQ-LIST TEMP) NIL)) ((SETQ TEMP (GET (CAR FORM) (QUOTE SETF-EXPANDER))) (FUNCALL TEMP FORM ENVIRONMENT)) (T (EXPAND-OR-GET-SETF-INVERSE FORM ENVIRONMENT)))))
     [java] ; (DEFMACRO SETF (&REST ARGS &ENVIRONMENT ENVIRONMENT) (LET ((NUMARGS (LENGTH ARGS))) (COND ((= NUMARGS 2) (LET ((PLACE (FIRST ARGS)) (VALUE-FORM (SECOND ARGS))) (IF (ATOM PLACE) (BACKQ-LIST (QUOTE SETQ) PLACE VALUE-FORM) (PROGN (MULTIPLE-VALUE-BIND (DUMMIES VALS STORE-VARS SETTER GETTER) (GET-SETF-EXPANSION PLACE ENVIRONMENT) (LET ((INVERSE (GET (CAR PLACE) (QUOTE SETF-INVERSE)))) (IF (AND INVERSE (EQ INVERSE (CAR SETTER))) (IF (FUNCTIONP INVERSE) (BACKQ-LIST* (QUOTE FUNCALL) INVERSE (BACKQ-APPEND (CDR PLACE) (BACKQ-LIST VALUE-FORM))) (BACKQ-CONS INVERSE (BACKQ-APPEND (CDR PLACE) (BACKQ-LIST VALUE-FORM)))) (IF (OR (NULL STORE-VARS) (CDR STORE-VARS)) (BACKQ-LIST (QUOTE LET*) (MAPCAR (FUNCTION LIST) DUMMIES VALS) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) STORE-VARS VALUE-FORM SETTER)) (BACKQ-LIST (QUOTE LET*) (BACKQ-APPEND (MAPCAR (FUNCTION LIST) DUMMIES VALS) (BACKQ-LIST (BACKQ-LIST (CAR STORE-VARS) VALUE-FORM))) SETTER))))))))) ((ODDP NUMARGS) (ERROR "Odd number of arguments to SETF.")) (T (DO ((A ARGS (CDDR A)) (L NIL)) ((NULL A) (BACKQ-CONS (QUOTE PROGN) (NREVERSE L))) (SETQ L (CONS (LIST (QUOTE SETF) (CAR A) (CADR A)) L)))))))
     [java] ; (DEFMACRO INCF (PLACE &OPTIONAL (DELTA 1)) (BACKQ-LIST (QUOTE SETF) PLACE (BACKQ-LIST (QUOTE +) PLACE DELTA)))
     [java] ; (DEFMACRO DECF (PLACE &OPTIONAL (DELTA 1)) (BACKQ-LIST (QUOTE SETF) PLACE (BACKQ-LIST (QUOTE -) PLACE DELTA)))
     [java] ; (DEFUN %SET-SUBSEQ (SEQUENCE START &REST REST) (LET ((END NIL) V) (ECASE (LENGTH REST) (1 (SETQ V (CAR REST))) (2 (SETQ END (CAR REST) V (CADR REST)))) (PROGN (REPLACE SEQUENCE V :START1 START :END1 END) V)))
     [java] ; (DEFUN %DEFINE-SETF-MACRO (NAME EXPANDER INVERSE DOC) (DECLARE (IGNORE DOC)) (WHEN INVERSE (PUT NAME (QUOTE SETF-INVERSE) INVERSE)) (WHEN EXPANDER (PUT NAME (QUOTE SETF-EXPANDER) EXPANDER)) NAME)
     [java] ; (DEFMACRO DEFSETF (ACCESS-FUNCTION UPDATE-FUNCTION) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:LOAD-TOPLEVEL :COMPILE-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FUNCTION) (QUOTE (QUOTE SETF-INVERSE)) (BACKQ-LIST (QUOTE QUOTE) UPDATE-FUNCTION))))
     [java] ; (DEFUN %SET-CAAR (X V) (SET-CAR (CAR X) V))
     [java] ; (DEFUN %SET-CADR (X V) (SET-CAR (CDR X) V))
     [java] ; (DEFUN %SET-CDAR (X V) (SET-CDR (CAR X) V))
     [java] ; (DEFUN %SET-CDDR (X V) (SET-CDR (CDR X) V))
     [java] ; (DEFUN %SET-CAAAR (X V) (SET-CAR (CAAR X) V))
     [java] ; (DEFUN %SET-CADAR (X V) (SET-CAR (CDAR X) V))
     [java] ; (DEFUN %SET-CDAAR (X V) (SET-CDR (CAAR X) V))
     [java] ; (DEFUN %SET-CDDAR (X V) (SET-CDR (CDAR X) V))
     [java] ; (DEFUN %SET-CAADR (X V) (SET-CAR (CADR X) V))
     [java] ; (DEFUN %SET-CADDR (X V) (SET-CAR (CDDR X) V))
     [java] ; (DEFUN %SET-CDADR (X V) (SET-CDR (CADR X) V))
     [java] ; (DEFUN %SET-CDDDR (X V) (SET-CDR (CDDR X) V))
     [java] ; (DEFUN %SET-CAAAAR (X V) (SET-CAR (CAAAR X) V))
     [java] ; (DEFUN %SET-CADAAR (X V) (SET-CAR (CDAAR X) V))
     [java] ; (DEFUN %SET-CDAAAR (X V) (SET-CDR (CAAAR X) V))
     [java] ; (DEFUN %SET-CDDAAR (X V) (SET-CDR (CDAAR X) V))
     [java] ; (DEFUN %SET-CAADAR (X V) (SET-CAR (CADAR X) V))
     [java] ; (DEFUN %SET-CADDAR (X V) (SET-CAR (CDDAR X) V))
     [java] ; (DEFUN %SET-CDADAR (X V) (SET-CDR (CADAR X) V))
     [java] ; (DEFUN %SET-CDDDAR (X V) (SET-CDR (CDDAR X) V))
     [java] ; (DEFUN %SET-CAAADR (X V) (SET-CAR (CAADR X) V))
     [java] ; (DEFUN %SET-CADADR (X V) (SET-CAR (CDADR X) V))
     [java] ; (DEFUN %SET-CDAADR (X V) (SET-CDR (CAADR X) V))
     [java] ; (DEFUN %SET-CDDADR (X V) (SET-CDR (CDADR X) V))
     [java] ; (DEFUN %SET-CAADDR (X V) (SET-CAR (CADDR X) V))
     [java] ; (DEFUN %SET-CADDDR (X V) (SET-CAR (CDDDR X) V))
     [java] ; (DEFUN %SET-CDADDR (X V) (SET-CDR (CADDR X) V))
     [java] ; (DEFUN %SET-CDDDDR (X V) (SET-CDR (CDDDR X) V))
     [java] ; (DEFSETF CAR SET-CAR)
     [java] ; (DEFSETF CDR SET-CDR)
     [java] ; (DEFSETF CAAR %SET-CAAR)
     [java] ; (DEFSETF CADR %SET-CADR)
     [java] ; (DEFSETF CDAR %SET-CDAR)
     [java] ; (DEFSETF CDDR %SET-CDDR)
     [java] ; (DEFSETF CAAAR %SET-CAAAR)
     [java] ; (DEFSETF CADAR %SET-CADAR)
     [java] ; (DEFSETF CDAAR %SET-CDAAR)
     [java] ; (DEFSETF CDDAR %SET-CDDAR)
     [java] ; (DEFSETF CAADR %SET-CAADR)
     [java] ; (DEFSETF CADDR %SET-CADDR)
     [java] ; (DEFSETF CDADR %SET-CDADR)
     [java] ; (DEFSETF CDDDR %SET-CDDDR)
     [java] ; (DEFSETF CAAAAR %SET-CAAAAR)
     [java] ; (DEFSETF CADAAR %SET-CADAAR)
     [java] ; (DEFSETF CDAAAR %SET-CDAAAR)
     [java] ; (DEFSETF CDDAAR %SET-CDDAAR)
     [java] ; (DEFSETF CAADAR %SET-CAADAR)
     [java] ; (DEFSETF CADDAR %SET-CADDAR)
     [java] ; (DEFSETF CDADAR %SET-CDADAR)
     [java] ; (DEFSETF CDDDAR %SET-CDDDAR)
     [java] ; (DEFSETF CAAADR %SET-CAAADR)
     [java] ; (DEFSETF CADADR %SET-CADADR)
     [java] ; (DEFSETF CDAADR %SET-CDAADR)
     [java] ; (DEFSETF CDDADR %SET-CDDADR)
     [java] ; (DEFSETF CAADDR %SET-CAADDR)
     [java] ; (DEFSETF CADDDR %SET-CADDDR)
     [java] ; (DEFSETF CDADDR %SET-CDADDR)
     [java] ; (DEFSETF CDDDDR %SET-CDDDDR)
     [java] ; (DEFSETF FIRST SET-CAR)
     [java] ; (DEFSETF SECOND %SET-CADR)
     [java] ; (DEFSETF THIRD %SET-CADDR)
     [java] ; (DEFSETF FOURTH %SET-CADDDR)
     [java] ; (DEFUN %SET-FIFTH (X V) (SET-CAR (CDDDDR X) V))
     [java] ; (DEFSETF FIFTH %SET-FIFTH)
     [java] ; (DEFUN %SET-SIXTH (X V) (SET-CAR (CDR (CDDDDR X)) V))
     [java] ; (DEFSETF SIXTH %SET-SIXTH)
     [java] ; (DEFUN %SET-SEVENTH (X V) (SET-CAR (CDDR (CDDDDR X)) V))
     [java] ; (DEFSETF SEVENTH %SET-SEVENTH)
     [java] ; (DEFUN %SET-EIGHTH (X V) (SET-CAR (CDDDR (CDDDDR X)) V))
     [java] ; (DEFSETF EIGHTH %SET-EIGHTH)
     [java] ; (DEFUN %SET-NINTH (X V) (SET-CAR (CDDDDR (CDDDDR X)) V))
     [java] ; (DEFSETF NINTH %SET-NINTH)
     [java] ; (DEFUN %SET-TENTH (X V) (SET-CAR (CDR (CDDDDR (CDDDDR X))) V))
     [java] ; (DEFSETF TENTH %SET-TENTH)
     [java] ; (DEFSETF REST SET-CDR)
     [java] ; (DEFSETF ELT %SET-ELT)
     [java] ; (DEFSETF NTH %SET-NTH)
     [java] ; (DEFSETF SVREF SVSET)
     [java] ; (DEFSETF FILL-POINTER %SET-FILL-POINTER)
     [java] ; (DEFSETF SUBSEQ %SET-SUBSEQ)
     [java] ; (DEFSETF SYMBOL-VALUE SET)
     [java] ; (DEFSETF SYMBOL-FUNCTION %SET-SYMBOL-FUNCTION)
     [java] ; (DEFSETF SYMBOL-PLIST %SET-SYMBOL-PLIST)
     [java] ; (DEFSETF GET PUT)
     [java] ; (DEFSETF GETHASH PUTHASH)
     [java] ; (DEFSETF CHAR SET-CHAR)
     [java] ; (DEFSETF SCHAR SET-SCHAR)
     [java] ; (DEFSETF LOGICAL-PATHNAME-TRANSLATIONS %SET-LOGICAL-PATHNAME-TRANSLATIONS)
     [java] ; (DEFSETF READTABLE-CASE %SET-READTABLE-CASE)
     [java] ; (DEFSETF FUNCTION-INFO %SET-FUNCTION-INFO)
     [java] ; (DEFSETF STREAM-EXTERNAL-FORMAT %SET-STREAM-EXTERNAL-FORMAT)
     [java] ; (DEFSETF STRUCTURE-REF STRUCTURE-SET)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/setf.abcl (1.803 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/setf.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/setf.abcl (0.297 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/extensible-sequences-base.lisp ...
     [java] ; (IN-PACKAGE :SEQUENCE)
     [java] ; (DEFMACRO SEQ-DISPATCH (SEQUENCE LIST-FORM ARRAY-FORM &OPTIONAL OTHER-FORM) (SYSTEM::BACKQ-LIST* (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE LISTP) SEQUENCE) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SEQUENCE (SYSTEM::BACKQ-LIST (QUOTE EXTENSIONS:TRULY-THE) (QUOTE LIST) SEQUENCE))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) SEQUENCE)) LIST-FORM) (IF OTHER-FORM (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE ARRAYP) SEQUENCE) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SEQUENCE (SYSTEM::BACKQ-LIST (QUOTE EXTENSIONS:TRULY-THE) (QUOTE VECTOR) SEQUENCE))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) SEQUENCE)) ARRAY-FORM) (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST* (QUOTE TYPEP) SEQUENCE (QUOTE ((QUOTE SEQUENCE)))) OTHER-FORM (SYSTEM::BACKQ-LIST* (QUOTE ERROR) (QUOTE (QUOTE TYPE-ERROR)) (QUOTE :DATUM) SEQUENCE (QUOTE (:EXPECTED-TYPE (QUOTE SEQUENCE))))))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SEQUENCE (SYSTEM::BACKQ-LIST (QUOTE EXTENSIONS:TRULY-THE) (QUOTE VECTOR) SEQUENCE))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) SEQUENCE)) ARRAY-FORM)))))
     [java] ; (DEFUN %CHECK-GENERIC-SEQUENCE-BOUNDS (SEQ START END) (LET ((LENGTH (LENGTH SEQ))) (IF (<= 0 START (OR END LENGTH) LENGTH) (OR END LENGTH) (SEQUENCE-BOUNDING-INDICES-BAD-ERROR SEQ START END))))
     [java] ; (DEFUN SEQUENCE-BOUNDING-INDICES-BAD-ERROR (SEQUENCE START END) (LET ((SIZE (LENGTH SEQUENCE))) (ERROR "The bounding indices ~S and ~S are bad for a sequence of length ~S" START END SIZE)))
     [java] ; (DEFUN %SET-ELT (SEQUENCE INDEX VALUE) (SEQ-DISPATCH SEQUENCE (SYSTEM::%SET-ELT SEQUENCE INDEX VALUE) (SYSTEM::%SET-ELT SEQUENCE INDEX VALUE) (SETF (ELT SEQUENCE INDEX) VALUE)))
     [java] ; (DEFSETF COMMON-LISP:ELT %SET-ELT)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/extensible-sequences-base.abcl (0.35 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/extensible-sequences-base.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/extensible-sequences-base.abcl (0.027 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/require.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN PROVIDE (MODULE-NAME) (PUSHNEW (STRING MODULE-NAME) *MODULES* :TEST (FUNCTION STRING=)) T)
     [java] ; (DEFUN MODULE-PROVIDE-SYSTEM (MODULE) (LET ((*READTABLE* (COPY-READTABLE NIL))) (HANDLER-CASE (PROGN (LOAD-SYSTEM-FILE (STRING-DOWNCASE (STRING MODULE))) (PROVIDE MODULE)) (T (E) (UNLESS (AND (TYPEP E (QUOTE ERROR)) (SEARCH "Failed to find loadable system file" (FORMAT NIL "~A" E))) (FORMAT *ERROR-OUTPUT* "Failed to require  ~A because '~A'~%" MODULE E)) NIL))))
     [java] ; (DEFVAR *MODULE-PROVIDER-FUNCTIONS* NIL)
     [java] ; (DEFUN REQUIRE (MODULE-NAME &OPTIONAL PATHNAMES) (UNLESS (MEMBER (STRING MODULE-NAME) *MODULES* :TEST (FUNCTION STRING=)) (LET ((SAVED-MODULES (COPY-LIST *MODULES*))) (COND (PATHNAMES (UNLESS (LISTP PATHNAMES) (SETF PATHNAMES (LIST PATHNAMES))) (DOLIST (X PATHNAMES) (LOAD X)) (UNLESS (STRING-EQUAL MODULE-NAME "abcl-contrib") (PROVIDE MODULE-NAME))) (T (UNLESS (SOME (LAMBDA (P) (FUNCALL P MODULE-NAME)) (APPEND (LIST (FUNCTION MODULE-PROVIDE-SYSTEM)) *MODULE-PROVIDER-FUNCTIONS*)) (ERROR "Don't know how to ~S ~A." (QUOTE REQUIRE) MODULE-NAME)))) (SET-DIFFERENCE *MODULES* SAVED-MODULES))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/require.abcl (0.494 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/require.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/require.abcl (0.019 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/substitute.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFMACRO REAL-COUNT (COUNT) (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE NULL) COUNT) (QUOTE (MOST-POSITIVE-FIXNUM))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE EXTENSIONS:FIXNUMP) COUNT) (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE MINUSP) COUNT) 0 COUNT)) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE INTEGERP) COUNT) (SYSTEM::BACKQ-LIST* (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE MINUSP) COUNT) (QUOTE (0 MOST-POSITIVE-FIXNUM)))) (SYSTEM::BACKQ-LIST (QUOTE T) COUNT)))
     [java] ; (DEFUN LIST-SUBSTITUTE* (PRED NEW LIST START END COUNT KEY TEST TEST-NOT OLD) (LET* ((RESULT (LIST NIL)) ELT (SPLICE RESULT) (LIST LIST)) (DO ((INDEX 0 (1+ INDEX))) ((= INDEX START)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR LIST))))) (SETQ LIST (CDR LIST))) (DO ((INDEX START (1+ INDEX))) ((OR (= INDEX END) (NULL LIST) (= COUNT 0))) (SETQ ELT (CAR LIST)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (COND ((CASE PRED (NORMAL (IF TEST-NOT (NOT (FUNCALL TEST-NOT OLD (SYSTEM::APPLY-KEY KEY ELT))) (FUNCALL TEST OLD (SYSTEM::APPLY-KEY KEY ELT)))) (IF (FUNCALL TEST (SYSTEM::APPLY-KEY KEY ELT))) (IF-NOT (NOT (FUNCALL TEST (SYSTEM::APPLY-KEY KEY ELT))))) (SETQ COUNT (1- COUNT)) NEW) (T ELT)))))) (SETQ LIST (CDR LIST))) (DO NIL ((NULL LIST)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR LIST))))) (SETQ LIST (CDR LIST))) (CDR RESULT)))
     [java] ; (DEFUN VECTOR-SUBSTITUTE* (PRED NEW SEQUENCE INCREMENTER LEFT RIGHT LENGTH START END COUNT KEY TEST TEST-NOT OLD) (LET ((RESULT (SYSTEM::MAKE-SEQUENCE-LIKE SEQUENCE LENGTH)) (INDEX LEFT)) (DO NIL ((= INDEX START)) (SETF (AREF RESULT INDEX) (AREF SEQUENCE INDEX)) (SETQ INDEX (+ INDEX INCREMENTER))) (DO ((ELT)) ((OR (= INDEX END) (= COUNT 0))) (SETQ ELT (AREF SEQUENCE INDEX)) (SETF (AREF RESULT INDEX) (COND ((CASE PRED (NORMAL (IF TEST-NOT (NOT (FUNCALL TEST-NOT OLD (SYSTEM::APPLY-KEY KEY ELT))) (FUNCALL TEST OLD (SYSTEM::APPLY-KEY KEY ELT)))) (IF (FUNCALL TEST (SYSTEM::APPLY-KEY KEY ELT))) (IF-NOT (NOT (FUNCALL TEST (SYSTEM::APPLY-KEY KEY ELT))))) (SETQ COUNT (1- COUNT)) NEW) (T ELT))) (SETQ INDEX (+ INDEX INCREMENTER))) (DO NIL ((= INDEX RIGHT)) (SETF (AREF RESULT INDEX) (AREF SEQUENCE INDEX)) (SETQ INDEX (+ INDEX INCREMENTER))) RESULT))
     [java] ; (DEFMACRO SUBST-DISPATCH (PRED) (SYSTEM::BACKQ-LIST (QUOTE SEQUENCE::SEQ-DISPATCH) (QUOTE SEQUENCE) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE FROM-END) (SYSTEM::BACKQ-LIST (QUOTE NREVERSE) (SYSTEM::BACKQ-LIST* (QUOTE LIST-SUBSTITUTE*) PRED (QUOTE (NEW (REVERSE SEQUENCE) (- LENGTH END) (- LENGTH START) COUNT KEY TEST TEST-NOT OLD)))) (SYSTEM::BACKQ-LIST* (QUOTE LIST-SUBSTITUTE*) PRED (QUOTE (NEW SEQUENCE START END COUNT KEY TEST TEST-NOT OLD)))) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE FROM-END) (SYSTEM::BACKQ-LIST* (QUOTE VECTOR-SUBSTITUTE*) PRED (QUOTE (NEW SEQUENCE -1 (1- LENGTH) -1 LENGTH (1- END) (1- START) COUNT KEY TEST TEST-NOT OLD))) (SYSTEM::BACKQ-LIST* (QUOTE VECTOR-SUBSTITUTE*) PRED (QUOTE (NEW SEQUENCE 1 0 LENGTH LENGTH START END COUNT KEY TEST TEST-NOT OLD)))) (ECASE (CADR PRED) (NORMAL (QUOTE (APPLY (FUNCTION SEQUENCE:SUBSTITUTE) NEW OLD SEQUENCE ARGS))) (IF (QUOTE (APPLY (FUNCTION SEQUENCE:SUBSTITUTE-IF) NEW TEST SEQUENCE ARGS))) (IF-NOT (QUOTE (APPLY (FUNCTION SEQUENCE:SUBSTITUTE-IF-NOT) NEW TEST SEQUENCE ARGS))))))
     [java] ; (DEFUN SUBSTITUTE (NEW OLD SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START 0) COUNT END KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SUBST-DISPATCH (QUOTE NORMAL))))
     [java] ; (DEFUN SUBSTITUTE-IF (NEW TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT)) TEST-NOT OLD) (SUBST-DISPATCH (QUOTE IF))))
     [java] ; (DEFUN SUBSTITUTE-IF-NOT (NEW TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT)) TEST-NOT OLD) (SUBST-DISPATCH (QUOTE IF-NOT))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/substitute.abcl (1.168 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/substitute.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/substitute.abcl (0.077 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/clos.lisp ...
     [java] ; (IN-PACKAGE #:MOP)
     [java] ; (DEFCONSTANT +THE-STANDARD-CLASS+ (FIND-CLASS (QUOTE STANDARD-CLASS)))
     [java] ; (DEFCONSTANT +THE-FUNCALLABLE-STANDARD-CLASS+ (FIND-CLASS (QUOTE FUNCALLABLE-STANDARD-CLASS)))
     [java] ; (DEFCONSTANT +THE-STANDARD-OBJECT-CLASS+ (FIND-CLASS (QUOTE STANDARD-OBJECT)))
     [java] ; (DEFCONSTANT +THE-FUNCALLABLE-STANDARD-OBJECT-CLASS+ (FIND-CLASS (QUOTE FUNCALLABLE-STANDARD-OBJECT)))
     [java] ; (DEFCONSTANT +THE-STANDARD-METHOD-CLASS+ (FIND-CLASS (QUOTE STANDARD-METHOD)))
     [java] ; (DEFCONSTANT +THE-T-CLASS+ (FIND-CLASS (QUOTE T)))
     [java] ; (DEFCONSTANT +THE-STANDARD-SLOT-DEFINITION-CLASS+ (FIND-CLASS (QUOTE STANDARD-SLOT-DEFINITION)))
     [java] ; (DEFCONSTANT +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+ (FIND-CLASS (QUOTE STANDARD-DIRECT-SLOT-DEFINITION)))
     [java] ; (DEFCONSTANT +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+ (FIND-CLASS (QUOTE STANDARD-EFFECTIVE-SLOT-DEFINITION)))
     [java] ; (DEFPARAMETER *CLOS-BOOTING* T)
     [java] ; (DEFMACRO DEFINE-CLASS->%CLASS-FORWARDER (NAME) (LET* (($NAME (IF (CONSP NAME) (CADR NAME) NAME)) (%NAME (INTERN (CONCATENATE (QUOTE STRING) "%" (IF (CONSP NAME) (SYMBOL-NAME (QUOTE SET-)) "") (SYMBOL-NAME $NAME)) (SYMBOL-PACKAGE $NAME)))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE DECLAIM) (SYSTEM::BACKQ-LIST (QUOTE NOTINLINE) NAME)) (SYSTEM::BACKQ-LIST (QUOTE DEFUN) NAME (QUOTE (&REST ARGS)) (SYSTEM::BACKQ-LIST* (QUOTE APPLY) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) %NAME) (QUOTE (ARGS)))))))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-NAME)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-NAME))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-SLOTS)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-SLOTS))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DIRECT-SLOTS)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DIRECT-SLOTS))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-LAYOUT)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-LAYOUT))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DIRECT-SUPERCLASSES)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DIRECT-SUPERCLASSES))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DIRECT-SUBCLASSES)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DIRECT-SUBCLASSES))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DIRECT-METHODS)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DIRECT-METHODS))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-PRECEDENCE-LIST)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-PRECEDENCE-LIST))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-FINALIZED-P)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-FINALIZED-P))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DEFAULT-INITARGS)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DEFAULT-INITARGS))
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER CLASS-DIRECT-DEFAULT-INITARGS)
     [java] ; (DEFINE-CLASS->%CLASS-FORWARDER (SETF CLASS-DIRECT-DEFAULT-INITARGS))
     [java] ; (DECLAIM (NOTINLINE ADD-DIRECT-SUBCLASS REMOVE-DIRECT-SUBCLASS))
     [java] ; (DEFUN ADD-DIRECT-SUBCLASS (SUPERCLASS SUBCLASS) (SETF (CLASS-DIRECT-SUBCLASSES SUPERCLASS) (ADJOIN SUBCLASS (CLASS-DIRECT-SUBCLASSES SUPERCLASS))))
     [java] ; (DEFUN REMOVE-DIRECT-SUBCLASS (SUPERCLASS SUBCLASS) (SETF (CLASS-DIRECT-SUBCLASSES SUPERCLASS) (REMOVE SUBCLASS (CLASS-DIRECT-SUBCLASSES SUPERCLASS))))
     [java] ; (DEFUN FIXUP-STANDARD-CLASS-HIERARCHY NIL (FLET ((ADD-SUBCLASSES (CLASS SUBCLASSES) (WHEN (ATOM SUBCLASSES) (SETF SUBCLASSES (LIST SUBCLASSES))) (SETF (CLASS-DIRECT-SUBCLASSES (FIND-CLASS CLASS)) (UNION (CLASS-DIRECT-SUBCLASSES (FIND-CLASS CLASS)) (MAPCAR (FUNCTION FIND-CLASS) SUBCLASSES))))) (ADD-SUBCLASSES T (QUOTE STANDARD-OBJECT)) (ADD-SUBCLASSES (QUOTE FUNCTION) (QUOTE FUNCALLABLE-STANDARD-OBJECT)) (ADD-SUBCLASSES (QUOTE STANDARD-OBJECT) (QUOTE (FUNCALLABLE-STANDARD-OBJECT METAOBJECT))) (ADD-SUBCLASSES (QUOTE METAOBJECT) (QUOTE (METHOD SLOT-DEFINITION SPECIALIZER))) (ADD-SUBCLASSES (QUOTE SPECIALIZER) (QUOTE (CLASS))) (ADD-SUBCLASSES (QUOTE METHOD) (QUOTE STANDARD-METHOD)) (ADD-SUBCLASSES (QUOTE SLOT-DEFINITION) (QUOTE (DIRECT-SLOT-DEFINITION EFFECTIVE-SLOT-DEFINITION STANDARD-SLOT-DEFINITION))) (ADD-SUBCLASSES (QUOTE STANDARD-SLOT-DEFINITION) (QUOTE (STANDARD-DIRECT-SLOT-DEFINITION STANDARD-EFFECTIVE-SLOT-DEFINITION))) (ADD-SUBCLASSES (QUOTE DIRECT-SLOT-DEFINITION) (QUOTE STANDARD-DIRECT-SLOT-DEFINITION)) (ADD-SUBCLASSES (QUOTE EFFECTIVE-SLOT-DEFINITION) (QUOTE STANDARD-EFFECTIVE-SLOT-DEFINITION)) (ADD-SUBCLASSES (QUOTE CLASS) (QUOTE (BUILT-IN-CLASS STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS)))))
     [java] ; (DEFUN STD-CLASS-P (CLASS) (LET ((METACLASS (CLASS-OF CLASS))) (OR (EQ METACLASS +THE-STANDARD-CLASS+) (EQ METACLASS +THE-FUNCALLABLE-STANDARD-CLASS+))))
     [java] ; (DEFUN NO-APPLICABLE-METHOD (GENERIC-FUNCTION &REST ARGS) (ERROR "There is no applicable method for the generic function ~S when called with arguments ~S." GENERIC-FUNCTION ARGS))
     [java] ; (DEFUN FUNCTION-KEYWORDS (METHOD) (STD-FUNCTION-KEYWORDS METHOD))
     [java] ; (DECLAIM (NOTINLINE MAP-DEPENDENTS))
     [java] ; (DEFUN MAP-DEPENDENTS (METAOBJECT FUNCTION) (DECLARE (IGNORE METAOBJECT FUNCTION)) NIL)
     [java] ; (DEFMACRO PUSH-ON-END (VALUE LOCATION) (SYSTEM::BACKQ-LIST (QUOTE SETF) LOCATION (SYSTEM::BACKQ-LIST (QUOTE NCONC) LOCATION (SYSTEM::BACKQ-LIST (QUOTE LIST) VALUE))))
     [java] ; (DEFUN (SETF GETF*) (NEW-VALUE PLIST KEY) (BLOCK BODY (DO ((X PLIST (CDDR X))) ((NULL X)) (WHEN (EQ (CAR X) KEY) (SETF (CAR (CDR X)) NEW-VALUE) (RETURN-FROM BODY NEW-VALUE))) (PUSH-ON-END KEY PLIST) (PUSH-ON-END NEW-VALUE PLIST) NEW-VALUE))
     [java] ; (DEFUN MAPAPPEND (FUN &REST ARGS) (IF (SOME (FUNCTION NULL) ARGS) NIL (APPEND (APPLY FUN (MAPCAR (FUNCTION CAR) ARGS)) (APPLY (FUNCTION MAPAPPEND) FUN (MAPCAR (FUNCTION CDR) ARGS)))))
     [java] ; (DEFUN MAPPLIST (FUN X) (IF (NULL X) NIL (CONS (FUNCALL FUN (CAR X) (CADR X)) (MAPPLIST FUN (CDDR X)))))
     [java] ; (DEFSETF STD-SLOT-VALUE SET-STD-SLOT-VALUE)
     [java] ; (DEFSETF STD-INSTANCE-LAYOUT %SET-STD-INSTANCE-LAYOUT)
     [java] ; (DEFSETF STANDARD-INSTANCE-ACCESS %SET-STANDARD-INSTANCE-ACCESS)
     [java] ; (DEFUN FUNCALLABLE-STANDARD-INSTANCE-ACCESS (INSTANCE LOCATION) (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION))
     [java] ; (DEFSETF FUNCALLABLE-STANDARD-INSTANCE-ACCESS %SET-STANDARD-INSTANCE-ACCESS)
     [java] ; (DEFUN (SETF FIND-CLASS) (NEW-VALUE SYMBOL &OPTIONAL ERRORP ENVIRONMENT) (DECLARE (IGNORE ERRORP ENVIRONMENT)) (%SET-FIND-CLASS SYMBOL NEW-VALUE))
     [java] ; (DEFUN CANONICALIZE-DIRECT-SLOTS (DIRECT-SLOTS) (SYSTEM::BACKQ-CONS (QUOTE LIST) (MAPCAR (FUNCTION CANONICALIZE-DIRECT-SLOT) DIRECT-SLOTS)))
     [java] ; (DEFUN CANONICALIZE-DIRECT-SLOT (SPEC) (IF (SYMBOLP SPEC) (SYSTEM::BACKQ-LIST (QUOTE LIST) (QUOTE :NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SPEC)) (LET ((NAME (CAR SPEC)) (INITFUNCTION NIL) (INITFORM NIL) (INITARGS NIL) (TYPE NIL) (ALLOCATION NIL) (DOCUMENTATION NIL) (READERS NIL) (WRITERS NIL) (OTHER-OPTIONS NIL) (NON-STD-OPTIONS NIL)) (DO ((OLIST (CDR SPEC) (CDDR OLIST))) ((NULL OLIST)) (CASE (CAR OLIST) (:INITFORM (WHEN INITFORM (ERROR (QUOTE PROGRAM-ERROR) "duplicate slot option :INITFORM for slot named ~S" NAME)) (SETQ INITFUNCTION T) (SETQ INITFORM (CADR OLIST))) (:INITARG (PUSH-ON-END (CADR OLIST) INITARGS)) (:ALLOCATION (WHEN ALLOCATION (ERROR (QUOTE PROGRAM-ERROR) "duplicate slot option :ALLOCATION for slot named ~S" NAME)) (SETF ALLOCATION (CADR OLIST)) (PUSH-ON-END (CAR OLIST) OTHER-OPTIONS) (PUSH-ON-END (CADR OLIST) OTHER-OPTIONS)) (:TYPE (WHEN TYPE (ERROR (QUOTE PROGRAM-ERROR) "duplicate slot option :TYPE for slot named ~S" NAME)) (SETF TYPE (CADR OLIST))) (:DOCUMENTATION (WHEN DOCUMENTATION (ERROR (QUOTE PROGRAM-ERROR) "duplicate slot option :DOCUMENTATION for slot named ~S" NAME)) (SETF DOCUMENTATION (CADR OLIST))) (:READER (MAYBE-NOTE-NAME-DEFINED (CADR OLIST)) (PUSH-ON-END (CADR OLIST) READERS)) (:WRITER (MAYBE-NOTE-NAME-DEFINED (CADR OLIST)) (PUSH-ON-END (CADR OLIST) WRITERS)) (:ACCESSOR (MAYBE-NOTE-NAME-DEFINED (CADR OLIST)) (PUSH-ON-END (CADR OLIST) READERS) (PUSH-ON-END (SYSTEM::BACKQ-LIST (QUOTE SETF) (CADR OLIST)) WRITERS)) (T (PUSH-ON-END (CADR OLIST) (GETF NON-STD-OPTIONS (CAR OLIST)))))) (SYSTEM::BACKQ-LIST* (QUOTE LIST) (QUOTE :NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (SYSTEM::BACKQ-APPEND (WHEN INITFUNCTION (SYSTEM::BACKQ-LIST (QUOTE :INITFORM) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) INITFORM) (QUOTE :INITFUNCTION) (IF (EQ ALLOCATION :CLASS) (LET ((VAR (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST VAR INITFORM)) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) NIL VAR))) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) NIL INITFORM)))) (WHEN INITARGS (SYSTEM::BACKQ-LIST (QUOTE :INITARGS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) INITARGS))) (WHEN READERS (SYSTEM::BACKQ-LIST (QUOTE :READERS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) READERS))) (WHEN WRITERS (SYSTEM::BACKQ-LIST (QUOTE :WRITERS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) WRITERS))) (WHEN TYPE (SYSTEM::BACKQ-LIST (QUOTE :TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) TYPE))) (WHEN DOCUMENTATION (SYSTEM::BACKQ-LIST (QUOTE :DOCUMENTATION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) DOCUMENTATION))) OTHER-OPTIONS (MAPCAR (FUNCTION (LAMBDA (OPT) (IF (OR (ATOM OPT) (/= 1 (LENGTH OPT))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) OPT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CAR OPT))))) NON-STD-OPTIONS))))))
     [java] ; (DEFUN MAYBE-NOTE-NAME-DEFINED (NAME) (WHEN (FBOUNDP (QUOTE NOTE-NAME-DEFINED)) (NOTE-NAME-DEFINED NAME)))
     [java] ; (DEFUN CANONICALIZE-DEFCLASS-OPTIONS (OPTIONS) (MAPAPPEND (FUNCTION CANONICALIZE-DEFCLASS-OPTION) OPTIONS))
     [java] ; (DEFUN CANONICALIZE-DEFCLASS-OPTION (OPTION) (CASE (CAR OPTION) (:METACLASS (LIST (QUOTE :METACLASS) (SYSTEM::BACKQ-LIST (QUOTE FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR OPTION))))) (:DEFAULT-INITARGS (LIST (QUOTE :DIRECT-DEFAULT-INITARGS) (SYSTEM::BACKQ-CONS (QUOTE LIST) (MAPPLIST (FUNCTION (LAMBDA (KEY VALUE) (SYSTEM::BACKQ-LIST (QUOTE LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) KEY) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VALUE) (MAKE-INITFUNCTION VALUE)))) (CDR OPTION))))) ((:DOCUMENTATION :REPORT) (LIST (CAR OPTION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR OPTION)))) (T (LIST (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CAR OPTION)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CDR OPTION))))))
     [java] ; (DEFUN MAKE-INITFUNCTION (INITFORM) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) NIL INITFORM)))
     [java] ; (DEFUN SLOT-DEFINITION-ALLOCATION (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-ALLOCATION)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-ALLOCATION) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-INITARGS (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-INITARGS)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-INITARGS) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-INITFORM (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-INITFORM)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-INITFORM) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-INITFUNCTION (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-INITFUNCTION)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-INITFUNCTION) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-NAME (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-NAME)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-NAME) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-READERS (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-READERS)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-READERS) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-WRITERS (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-WRITERS)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-WRITERS) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-ALLOCATION-CLASS (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-ALLOCATION-CLASS)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-ALLOCATION-CLASS) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-LOCATION (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-LOCATION-CLASS)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-LOCATION) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-TYPE (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-TYPE)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-TYPE) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)) VALUE))
     [java] ; (DEFUN SLOT-DEFINITION-DOCUMENTATION (SLOT-DEFINITION) (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)))
     [java] ; (DECLAIM (NOTINLINE (SETF SLOT-DEFINITION-DOCUMENTATION)))
     [java] ; (DEFUN (SETF SLOT-DEFINITION-DOCUMENTATION) (VALUE SLOT-DEFINITION) (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)) VALUE))
     [java] ; (DEFUN INIT-SLOT-DEFINITION (SLOT &KEY NAME (INITARGS NIL) (INITFORM NIL) (INITFUNCTION NIL) (READERS NIL) (WRITERS NIL) (ALLOCATION :INSTANCE) (ALLOCATION-CLASS NIL) (TYPE T) (DOCUMENTATION NIL)) (SETF (SLOT-DEFINITION-NAME SLOT) NAME) (SETF (SLOT-DEFINITION-INITARGS SLOT) INITARGS) (SETF (SLOT-DEFINITION-INITFORM SLOT) INITFORM) (SETF (SLOT-DEFINITION-INITFUNCTION SLOT) INITFUNCTION) (SETF (SLOT-DEFINITION-READERS SLOT) READERS) (SETF (SLOT-DEFINITION-WRITERS SLOT) WRITERS) (SETF (SLOT-DEFINITION-ALLOCATION SLOT) ALLOCATION) (SETF (SLOT-DEFINITION-ALLOCATION-CLASS SLOT) ALLOCATION-CLASS) (SETF (SLOT-DEFINITION-TYPE SLOT) TYPE) (SETF (SLOT-DEFINITION-DOCUMENTATION SLOT) DOCUMENTATION) SLOT)
     [java] ; (DECLAIM (NOTINLINE DIRECT-SLOT-DEFINITION-CLASS))
     [java] ; (DEFUN DIRECT-SLOT-DEFINITION-CLASS (CLASS &REST ARGS) (DECLARE (IGNORE CLASS ARGS)) +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+)
     [java] ; (DEFUN MAKE-DIRECT-SLOT-DEFINITION (CLASS &REST ARGS) (LET ((SLOT-CLASS (APPLY (FUNCTION DIRECT-SLOT-DEFINITION-CLASS) CLASS ARGS))) (IF (EQ SLOT-CLASS +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+) (LET ((SLOT (%MAKE-SLOT-DEFINITION +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+))) (APPLY (FUNCTION INIT-SLOT-DEFINITION) SLOT :ALLOCATION-CLASS CLASS ARGS) SLOT) (PROGN (LET ((SLOT (APPLY (FUNCTION MAKE-INSTANCE) SLOT-CLASS :ALLOCATION-CLASS CLASS ARGS))) SLOT)))))
     [java] ; (DECLAIM (NOTINLINE EFFECTIVE-SLOT-DEFINITION-CLASS))
     [java] ; (DEFUN EFFECTIVE-SLOT-DEFINITION-CLASS (CLASS &REST ARGS) (DECLARE (IGNORE CLASS ARGS)) +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+)
     [java] ; (DEFUN MAKE-EFFECTIVE-SLOT-DEFINITION (CLASS &REST ARGS) (LET ((SLOT-CLASS (APPLY (FUNCTION EFFECTIVE-SLOT-DEFINITION-CLASS) CLASS ARGS))) (IF (EQ SLOT-CLASS +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+) (LET ((SLOT (%MAKE-SLOT-DEFINITION +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+))) (APPLY (FUNCTION INIT-SLOT-DEFINITION) SLOT ARGS) SLOT) (PROGN (LET ((SLOT (APPLY (FUNCTION MAKE-INSTANCE) SLOT-CLASS ARGS))) SLOT)))))
     [java] ; (DECLAIM (NOTINLINE COMPUTE-DEFAULT-INITARGS))
     [java] ; (DEFUN COMPUTE-DEFAULT-INITARGS (CLASS) (STD-COMPUTE-DEFAULT-INITARGS CLASS))
     [java] ; (DEFUN STD-COMPUTE-DEFAULT-INITARGS (CLASS) (DELETE-DUPLICATES (MAPCAN (FUNCTION (LAMBDA (C) (COPY-LIST (CLASS-DIRECT-DEFAULT-INITARGS C)))) (CLASS-PRECEDENCE-LIST CLASS)) :KEY (FUNCTION CAR) :FROM-END T))
     [java] ; (DEFUN STD-FINALIZE-INHERITANCE (CLASS) (WHEN (CLASS-FINALIZED-P CLASS) (RETURN-FROM STD-FINALIZE-INHERITANCE)) (SETF (CLASS-PRECEDENCE-LIST CLASS) (FUNCALL (IF (STD-CLASS-P CLASS) (FUNCTION STD-COMPUTE-CLASS-PRECEDENCE-LIST) (FUNCTION COMPUTE-CLASS-PRECEDENCE-LIST)) CLASS)) (SETF (CLASS-SLOTS CLASS) (FUNCALL (IF (STD-CLASS-P CLASS) (FUNCTION STD-COMPUTE-SLOTS) (FUNCTION COMPUTE-SLOTS)) CLASS)) (LET ((OLD-LAYOUT (CLASS-LAYOUT CLASS)) (LENGTH 0) (INSTANCE-SLOTS (QUOTE NIL)) (SHARED-SLOTS (QUOTE NIL))) (DOLIST (SLOT (CLASS-SLOTS CLASS)) (CASE (SLOT-DEFINITION-ALLOCATION SLOT) (:INSTANCE (SETF (SLOT-DEFINITION-LOCATION SLOT) LENGTH) (INCF LENGTH) (PUSH (SLOT-DEFINITION-NAME SLOT) INSTANCE-SLOTS)) (:CLASS (UNLESS (SLOT-DEFINITION-LOCATION SLOT) (LET ((ALLOCATION-CLASS (SLOT-DEFINITION-ALLOCATION-CLASS SLOT))) (IF (EQ ALLOCATION-CLASS CLASS) (LET ((INITFUNCTION (SLOT-DEFINITION-INITFUNCTION SLOT))) (SETF (SLOT-DEFINITION-LOCATION SLOT) (CONS (SLOT-DEFINITION-NAME SLOT) (IF INITFUNCTION (FUNCALL INITFUNCTION) +SLOT-UNBOUND+)))) (SETF (SLOT-DEFINITION-LOCATION SLOT) (SLOT-LOCATION ALLOCATION-CLASS (SLOT-DEFINITION-NAME SLOT)))))) (PUSH (SLOT-DEFINITION-LOCATION SLOT) SHARED-SLOTS)))) (WHEN OLD-LAYOUT (DOLIST (LOCATION SHARED-SLOTS) (LET* ((SLOT-NAME (CAR LOCATION)) (OLD-LOCATION (LAYOUT-SLOT-LOCATION OLD-LAYOUT SLOT-NAME))) (UNLESS OLD-LOCATION (LET* ((SLOT-DEFINITION (FIND SLOT-NAME (CLASS-SLOTS CLASS) :KEY (QUOTE SLOT-DEFINITION-NAME))) (INITFUNCTION (SLOT-DEFINITION-INITFUNCTION SLOT-DEFINITION))) (WHEN INITFUNCTION (SETF (CDR LOCATION) (FUNCALL INITFUNCTION)))))))) (SETF (CLASS-LAYOUT CLASS) (MAKE-LAYOUT CLASS (NREVERSE INSTANCE-SLOTS) (NREVERSE SHARED-SLOTS)))) (SETF (CLASS-DEFAULT-INITARGS CLASS) (COMPUTE-DEFAULT-INITARGS CLASS)) (SETF (CLASS-FINALIZED-P CLASS) T))
     [java] ; (DECLAIM (NOTINLINE FINALIZE-INHERITANCE))
     [java] ; (DEFUN FINALIZE-INHERITANCE (CLASS) (STD-FINALIZE-INHERITANCE CLASS))
     [java] ; (DEFUN STD-COMPUTE-CLASS-PRECEDENCE-LIST (CLASS) (LET ((CLASSES-TO-ORDER (COLLECT-SUPERCLASSES* CLASS))) (DOLIST (SUPER CLASSES-TO-ORDER) (WHEN (TYPEP SUPER (QUOTE FORWARD-REFERENCED-CLASS)) (ERROR "Can't compute class precedence list for class ~A ~
     [java]                 which depends on forward referenced class ~A." CLASS SUPER))) (TOPOLOGICAL-SORT CLASSES-TO-ORDER (REMOVE-DUPLICATES (MAPAPPEND (FUNCTION LOCAL-PRECEDENCE-ORDERING) CLASSES-TO-ORDER)) (FUNCTION STD-TIE-BREAKER-RULE))))
     [java] ; (DEFUN TOPOLOGICAL-SORT (ELEMENTS CONSTRAINTS TIE-BREAKER) (LET ((REMAINING-CONSTRAINTS CONSTRAINTS) (REMAINING-ELEMENTS ELEMENTS) (RESULT NIL)) (LOOP (LET ((MINIMAL-ELEMENTS (REMOVE-IF (FUNCTION (LAMBDA (CLASS) (MEMBER CLASS REMAINING-CONSTRAINTS :KEY (FUNCTION CADR)))) REMAINING-ELEMENTS))) (WHEN (NULL MINIMAL-ELEMENTS) (IF (NULL REMAINING-ELEMENTS) (RETURN-FROM TOPOLOGICAL-SORT RESULT) (ERROR "Inconsistent precedence graph."))) (LET ((CHOICE (IF (NULL (CDR MINIMAL-ELEMENTS)) (CAR MINIMAL-ELEMENTS) (FUNCALL TIE-BREAKER MINIMAL-ELEMENTS RESULT)))) (SETQ RESULT (APPEND RESULT (LIST CHOICE))) (SETQ REMAINING-ELEMENTS (REMOVE CHOICE REMAINING-ELEMENTS)) (SETQ REMAINING-CONSTRAINTS (REMOVE CHOICE REMAINING-CONSTRAINTS :TEST (FUNCTION MEMBER))))))))
     [java] ; (DEFUN STD-TIE-BREAKER-RULE (MINIMAL-ELEMENTS CPL-SO-FAR) (DOLIST (CPL-CONSTITUENT (REVERSE CPL-SO-FAR)) (LET* ((SUPERS (CLASS-DIRECT-SUPERCLASSES CPL-CONSTITUENT)) (COMMON (INTERSECTION MINIMAL-ELEMENTS SUPERS))) (WHEN (NOT (NULL COMMON)) (RETURN-FROM STD-TIE-BREAKER-RULE (CAR COMMON))))))
     [java] ; (DEFUN COLLECT-SUPERCLASSES* (CLASS) (LABELS ((ALL-SUPERCLASSES-LOOP (SEEN SUPERCLASSES) (LET ((TO-BE-PROCESSED (SET-DIFFERENCE SUPERCLASSES SEEN))) (IF (NULL TO-BE-PROCESSED) SUPERCLASSES (LET ((CLASS-TO-PROCESS (CAR TO-BE-PROCESSED))) (ALL-SUPERCLASSES-LOOP (CONS CLASS-TO-PROCESS SEEN) (UNION (CLASS-DIRECT-SUPERCLASSES CLASS-TO-PROCESS) SUPERCLASSES))))))) (ALL-SUPERCLASSES-LOOP NIL (LIST CLASS))))
     [java] ; (DEFUN LOCAL-PRECEDENCE-ORDERING (CLASS) (MAPCAR (FUNCTION LIST) (CONS CLASS (BUTLAST (CLASS-DIRECT-SUPERCLASSES CLASS))) (CLASS-DIRECT-SUPERCLASSES CLASS)))
     [java] ; (DEFUN STD-COMPUTE-SLOTS (CLASS) (LET* ((ALL-SLOTS (MAPAPPEND (FUNCTION (LAMBDA (C) (CLASS-DIRECT-SLOTS C))) (REVERSE (CLASS-PRECEDENCE-LIST CLASS)))) (ALL-NAMES (DELETE-DUPLICATES (MAPCAR (QUOTE SLOT-DEFINITION-NAME) ALL-SLOTS) :FROM-END T))) (MAPCAR (FUNCTION (LAMBDA (NAME) (FUNCALL (IF (STD-CLASS-P CLASS) (FUNCTION STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION) (FUNCTION COMPUTE-EFFECTIVE-SLOT-DEFINITION)) CLASS NAME (NREVERSE (REMOVE NAME ALL-SLOTS :KEY (QUOTE SLOT-DEFINITION-NAME) :TEST-NOT (FUNCTION EQ)))))) ALL-NAMES)))
     [java] ; (DEFUN STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION (CLASS NAME DIRECT-SLOTS) (LET ((INITER (FIND-IF-NOT (FUNCTION NULL) DIRECT-SLOTS :KEY (QUOTE SLOT-DEFINITION-INITFUNCTION))) (DOCUMENTATION-SLOT (FIND-IF-NOT (FUNCTION NULL) DIRECT-SLOTS :KEY (QUOTE SLOT-DEFINITION-DOCUMENTATION))) (TYPES (DELETE-DUPLICATES (DELETE T (MAPCAR (FUNCTION SLOT-DEFINITION-TYPE) DIRECT-SLOTS)) :TEST (FUNCTION EQUAL)))) (MAKE-EFFECTIVE-SLOT-DEFINITION CLASS :NAME NAME :INITFORM (IF INITER (SLOT-DEFINITION-INITFORM INITER) NIL) :INITFUNCTION (IF INITER (SLOT-DEFINITION-INITFUNCTION INITER) NIL) :INITARGS (REMOVE-DUPLICATES (MAPAPPEND (QUOTE SLOT-DEFINITION-INITARGS) DIRECT-SLOTS)) :ALLOCATION (SLOT-DEFINITION-ALLOCATION (CAR DIRECT-SLOTS)) :ALLOCATION-CLASS (WHEN (SLOT-BOUNDP (CAR DIRECT-SLOTS) (QUOTE SYSTEM::ALLOCATION-CLASS)) (SLOT-DEFINITION-ALLOCATION-CLASS (CAR DIRECT-SLOTS))) :TYPE (COND ((NULL TYPES) T) ((= 1 (LENGTH TYPES)) TYPES) (T (LIST* (QUOTE AND) TYPES))) :DOCUMENTATION (IF DOCUMENTATION-SLOT (DOCUMENTATION DOCUMENTATION-SLOT T) NIL))))
     [java] ; (DEFUN FIND-SLOT-DEFINITION (CLASS SLOT-NAME) (DOLIST (SLOT (CLASS-SLOTS CLASS) NIL) (WHEN (EQ SLOT-NAME (SLOT-DEFINITION-NAME SLOT)) (RETURN SLOT))))
     [java] ; (DEFUN SLOT-LOCATION (CLASS SLOT-NAME) (LET ((SLOT (FIND-SLOT-DEFINITION CLASS SLOT-NAME))) (IF SLOT (SLOT-DEFINITION-LOCATION SLOT) NIL)))
     [java] ; (DEFUN INSTANCE-SLOT-LOCATION (INSTANCE SLOT-NAME) (LET ((LAYOUT (STD-INSTANCE-LAYOUT INSTANCE))) (AND LAYOUT (LAYOUT-SLOT-LOCATION LAYOUT SLOT-NAME))))
     [java] ; (DEFUN SLOT-VALUE (OBJECT SLOT-NAME) (LET* ((CLASS (CLASS-OF OBJECT)) (METACLASS (CLASS-OF CLASS))) (IF (OR (EQ METACLASS +THE-STANDARD-CLASS+) (EQ METACLASS +THE-STRUCTURE-CLASS+) (EQ METACLASS +THE-FUNCALLABLE-STANDARD-CLASS+)) (STD-SLOT-VALUE OBJECT SLOT-NAME) (SLOT-VALUE-USING-CLASS CLASS OBJECT (FIND-SLOT-DEFINITION CLASS SLOT-NAME)))))
     [java] ; (DEFUN %SET-SLOT-VALUE (OBJECT SLOT-NAME NEW-VALUE) (LET* ((CLASS (CLASS-OF OBJECT)) (METACLASS (CLASS-OF CLASS))) (IF (OR (EQ METACLASS +THE-STANDARD-CLASS+) (EQ METACLASS +THE-STRUCTURE-CLASS+) (EQ METACLASS +THE-FUNCALLABLE-STANDARD-CLASS+)) (SETF (STD-SLOT-VALUE OBJECT SLOT-NAME) NEW-VALUE) (SETF (SLOT-VALUE-USING-CLASS CLASS OBJECT (FIND-SLOT-DEFINITION CLASS SLOT-NAME)) NEW-VALUE))))
     [java] ; (DEFSETF SLOT-VALUE %SET-SLOT-VALUE)
     [java] ; (DEFUN SLOT-BOUNDP (OBJECT SLOT-NAME) (LET ((CLASS (CLASS-OF OBJECT))) (IF (STD-CLASS-P CLASS) (STD-SLOT-BOUNDP OBJECT SLOT-NAME) (SLOT-BOUNDP-USING-CLASS CLASS OBJECT (FIND-SLOT-DEFINITION CLASS SLOT-NAME)))))
     [java] ; (DEFUN STD-SLOT-MAKUNBOUND (INSTANCE SLOT-NAME) (LET ((LOCATION (INSTANCE-SLOT-LOCATION INSTANCE SLOT-NAME))) (COND ((FIXNUMP LOCATION) (SETF (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) +SLOT-UNBOUND+)) ((CONSP LOCATION) (SETF (CDR LOCATION) +SLOT-UNBOUND+)) (T (SLOT-MISSING (CLASS-OF INSTANCE) INSTANCE SLOT-NAME (QUOTE SLOT-MAKUNBOUND))))) INSTANCE)
     [java] ; (DEFUN SLOT-MAKUNBOUND (OBJECT SLOT-NAME) (LET ((CLASS (CLASS-OF OBJECT))) (IF (STD-CLASS-P CLASS) (STD-SLOT-MAKUNBOUND OBJECT SLOT-NAME) (SLOT-MAKUNBOUND-USING-CLASS CLASS OBJECT (FIND-SLOT-DEFINITION CLASS SLOT-NAME)))))
     [java] ; (DEFUN STD-SLOT-EXISTS-P (INSTANCE SLOT-NAME) (NOT (NULL (FIND SLOT-NAME (CLASS-SLOTS (CLASS-OF INSTANCE)) :KEY (QUOTE SLOT-DEFINITION-NAME)))))
     [java] ; (DEFUN SLOT-EXISTS-P (OBJECT SLOT-NAME) (LET ((CLASS (CLASS-OF OBJECT))) (IF (STD-CLASS-P CLASS) (STD-SLOT-EXISTS-P OBJECT SLOT-NAME) (SLOT-EXISTS-P-USING-CLASS CLASS OBJECT SLOT-NAME))))
     [java] ; (DEFUN INSTANCE-SLOT-P (SLOT) (EQ (SLOT-DEFINITION-ALLOCATION SLOT) :INSTANCE))
     [java] ; (DEFUN STD-ALLOCATE-INSTANCE (CLASS) (%STD-ALLOCATE-INSTANCE CLASS))
     [java] ; (DEFUN ALLOCATE-FUNCALLABLE-INSTANCE (CLASS) (LET ((INSTANCE (%ALLOCATE-FUNCALLABLE-INSTANCE CLASS))) (WHEN (OR (EQ CLASS +THE-STANDARD-GENERIC-FUNCTION-CLASS+) (SUBTYPEP CLASS +THE-STANDARD-GENERIC-FUNCTION-CLASS+)) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::METHOD-CLASS)) +THE-STANDARD-METHOD-CLASS+)) (SET-FUNCALLABLE-INSTANCE-FUNCTION INSTANCE (FUNCTION (LAMBDA (&REST ARGS) (DECLARE (IGNORE ARGS)) (ERROR (QUOTE PROGRAM-ERROR) "Called a funcallable-instance with unset function.")))) INSTANCE))
     [java] ; (DECLAIM (NOTINLINE CLASS-PROTOTYPE))
     [java] ; (DEFUN CLASS-PROTOTYPE (CLASS) (UNLESS (CLASS-FINALIZED-P CLASS) (ERROR "Class ~A not finalized" (CLASS-NAME CLASS))) (STD-ALLOCATE-INSTANCE CLASS))
     [java] ; (DEFUN MAYBE-FINALIZE-CLASS-SUBTREE (CLASS) (WHEN (EVERY (FUNCTION CLASS-FINALIZED-P) (CLASS-DIRECT-SUPERCLASSES CLASS)) (FINALIZE-INHERITANCE CLASS) (DOLIST (SUBCLASS (CLASS-DIRECT-SUBCLASSES CLASS)) (MAYBE-FINALIZE-CLASS-SUBTREE SUBCLASS))))
     [java] ; (DEFUN MAKE-INSTANCE-STANDARD-CLASS (METACLASS &REST INITARGS &KEY NAME DIRECT-SUPERCLASSES DIRECT-SLOTS DIRECT-DEFAULT-INITARGS DOCUMENTATION) (DECLARE (IGNORE METACLASS)) (LET ((CLASS (STD-ALLOCATE-INSTANCE +THE-STANDARD-CLASS+))) (UNLESS *CLOS-BOOTING* (CHECK-INITARGS (LIST (FUNCTION ALLOCATE-INSTANCE) (FUNCTION INITIALIZE-INSTANCE)) (LIST* CLASS INITARGS) CLASS T INITARGS *MAKE-INSTANCE-INITARGS-CACHE* (QUOTE MAKE-INSTANCE))) (%SET-CLASS-NAME NAME CLASS) (UNLESS *CLOS-BOOTING* (%SET-CLASS-LAYOUT NIL CLASS)) (%SET-CLASS-DIRECT-SUBCLASSES NIL CLASS) (%SET-CLASS-DIRECT-METHODS NIL CLASS) (%SET-CLASS-DOCUMENTATION CLASS DOCUMENTATION) (STD-AFTER-INITIALIZATION-FOR-CLASSES CLASS :DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES :DIRECT-SLOTS DIRECT-SLOTS :DIRECT-DEFAULT-INITARGS DIRECT-DEFAULT-INITARGS) CLASS))
     [java] ; (DEFUN MAKE-OR-FIND-INSTANCE-FUNCALLABLE-STANDARD-CLASS (METACLASS &REST INITARGS &KEY NAME DIRECT-SUPERCLASSES DIRECT-SLOTS DIRECT-DEFAULT-INITARGS DOCUMENTATION) (DECLARE (IGNORE METACLASS INITARGS)) (OR (FIND-CLASS NAME NIL) (LET ((CLASS (STD-ALLOCATE-INSTANCE +THE-FUNCALLABLE-STANDARD-CLASS+))) (%SET-CLASS-NAME NAME CLASS) (UNLESS *CLOS-BOOTING* (%SET-CLASS-LAYOUT NIL CLASS)) (%SET-CLASS-DIRECT-SUBCLASSES NIL CLASS) (%SET-CLASS-DIRECT-METHODS NIL CLASS) (%SET-CLASS-DOCUMENTATION CLASS DOCUMENTATION) (STD-AFTER-INITIALIZATION-FOR-CLASSES CLASS :DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES :DIRECT-SLOTS DIRECT-SLOTS :DIRECT-DEFAULT-INITARGS DIRECT-DEFAULT-INITARGS) CLASS)))
     [java] ; (DEFUN CANONICALIZE-DIRECT-SUPERCLASS-LIST (CLASS DIRECT-SUPERCLASSES) (COND (DIRECT-SUPERCLASSES) ((SUBTYPEP (CLASS-OF CLASS) +THE-FUNCALLABLE-STANDARD-CLASS+) (LIST +THE-FUNCALLABLE-STANDARD-OBJECT-CLASS+)) ((SUBTYPEP (CLASS-OF CLASS) +THE-STANDARD-CLASS+) (LIST +THE-STANDARD-OBJECT-CLASS+))))
     [java] ; (DEFUN STD-AFTER-INITIALIZATION-FOR-CLASSES (CLASS &KEY DIRECT-SUPERCLASSES DIRECT-SLOTS DIRECT-DEFAULT-INITARGS &ALLOW-OTHER-KEYS) (LET ((SUPERS (CANONICALIZE-DIRECT-SUPERCLASS-LIST CLASS DIRECT-SUPERCLASSES))) (SETF (CLASS-DIRECT-SUPERCLASSES CLASS) SUPERS) (DOLIST (SUPERCLASS SUPERS) (ADD-DIRECT-SUBCLASS SUPERCLASS CLASS))) (LET ((SLOTS (MAPCAR (FUNCTION (LAMBDA (SLOT-PROPERTIES) (APPLY (FUNCTION MAKE-DIRECT-SLOT-DEFINITION) CLASS SLOT-PROPERTIES))) DIRECT-SLOTS))) (SETF (CLASS-DIRECT-SLOTS CLASS) SLOTS) (DOLIST (DIRECT-SLOT SLOTS) (DOLIST (READER (SLOT-DEFINITION-READERS DIRECT-SLOT)) (ADD-READER-METHOD CLASS READER DIRECT-SLOT)) (DOLIST (WRITER (SLOT-DEFINITION-WRITERS DIRECT-SLOT)) (ADD-WRITER-METHOD CLASS WRITER DIRECT-SLOT)))) (SETF (CLASS-DIRECT-DEFAULT-INITARGS CLASS) DIRECT-DEFAULT-INITARGS) (MAYBE-FINALIZE-CLASS-SUBTREE CLASS) (VALUES))
     [java] ; (DEFMACRO DEFINE-PRIMORDIAL-CLASS (NAME SUPERCLASSES DIRECT-SLOTS) "Primitive class definition tool.
     [java] No non-standard metaclasses, accessor methods, duplicate slots,
     [java] non-existent superclasses, default initargs, or other complicated stuff.
     [java] Handle with care." (LET ((CLASS (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST CLASS (SYSTEM::BACKQ-LIST (QUOTE MAKE-INSTANCE-STANDARD-CLASS) NIL (QUOTE :NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE :DIRECT-SUPERCLASSES) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (MAPCAR (FUNCTION FIND-CLASS) SUPERCLASSES)) (QUOTE :DIRECT-SLOTS) (CANONICALIZE-DIRECT-SLOTS DIRECT-SLOTS)))) (SYSTEM::BACKQ-LIST (QUOTE %SET-FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) CLASS) CLASS)))
     [java] ; (DEFMACRO DEFINE-FUNCALLABLE-PRIMORDIAL-CLASS (NAME SUPERCLASSES DIRECT-SLOTS) "Primitive funcallable class definition tool.
     [java] No non-standard metaclasses, accessor methods, duplicate slots,
     [java] non-existent superclasses, default initargs, or other complicated stuff.
     [java] Handle with care.
     [java] Will not modify existing classes to avoid breaking std-generic-function-p." (LET ((CLASS (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST CLASS (SYSTEM::BACKQ-LIST (QUOTE MAKE-OR-FIND-INSTANCE-FUNCALLABLE-STANDARD-CLASS) NIL (QUOTE :NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE :DIRECT-SUPERCLASSES) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (MAPCAR (FUNCTION FIND-CLASS) SUPERCLASSES)) (QUOTE :DIRECT-SLOTS) (CANONICALIZE-DIRECT-SLOTS DIRECT-SLOTS)))) (SYSTEM::BACKQ-LIST (QUOTE %SET-FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) CLASS) CLASS)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS EQL-SPECIALIZER (SPECIALIZER) ((OBJECT :INITFORM NIL) (DIRECT-METHODS :INITFORM NIL)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS METHOD-COMBINATION (METAOBJECT) ((NAME :INITARG :NAME :INITFORM NIL) (%DOCUMENTATION :INITARG :DOCUMENTATION :INITFORM NIL) (OPTIONS :INITARG :OPTIONS :INITFORM NIL)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS SHORT-METHOD-COMBINATION (METHOD-COMBINATION) ((OPERATOR :INITARG :OPERATOR) (IDENTITY-WITH-ONE-ARGUMENT :INITARG :IDENTITY-WITH-ONE-ARGUMENT)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS LONG-METHOD-COMBINATION (METHOD-COMBINATION) ((SYSTEM::LAMBDA-LIST :INITARG :LAMBDA-LIST) (METHOD-GROUP-SPECS :INITARG :METHOD-GROUP-SPECS) (ARGS-LAMBDA-LIST :INITARG :ARGS-LAMBDA-LIST) (GENERIC-FUNCTION-SYMBOL :INITARG :GENERIC-FUNCTION-SYMBOL) (FUNCTION :INITARG :FUNCTION) (ARGUMENTS :INITARG :ARGUMENTS) (DECLARATIONS :INITARG :DECLARATIONS) (FORMS :INITARG :FORMS)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS STANDARD-ACCESSOR-METHOD (STANDARD-METHOD) ((SYSTEM::%SLOT-DEFINITION :INITARG :SLOT-DEFINITION :INITFORM NIL)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS STANDARD-READER-METHOD (STANDARD-ACCESSOR-METHOD) NIL)
     [java] ; (DEFCONSTANT +THE-STANDARD-READER-METHOD-CLASS+ (FIND-CLASS (QUOTE STANDARD-READER-METHOD)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS STANDARD-WRITER-METHOD (STANDARD-ACCESSOR-METHOD) NIL)
     [java] ; (DEFCONSTANT +THE-STANDARD-WRITER-METHOD-CLASS+ (FIND-CLASS (QUOTE STANDARD-WRITER-METHOD)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS STRUCTURE-CLASS (CLASS) NIL)
     [java] ; (DEFCONSTANT +THE-STRUCTURE-CLASS+ (FIND-CLASS (QUOTE STRUCTURE-CLASS)))
     [java] ; (DEFINE-PRIMORDIAL-CLASS FORWARD-REFERENCED-CLASS (CLASS) ((NAME :INITARG :NAME :INITFORM NIL) (LAYOUT :INITFORM NIL) (DIRECT-SUPERCLASSES :INITFORM NIL) (DIRECT-SUBCLASSES :INITFORM NIL) (PRECEDENCE-LIST :INITFORM NIL) (DIRECT-METHODS :INITFORM NIL) (DIRECT-SLOTS :INITFORM NIL) (SLOTS :INITFORM NIL) (DIRECT-DEFAULT-INITARGS :INITFORM NIL) (DEFAULT-INITARGS :INITFORM NIL) (FINALIZED-P :INITFORM NIL) (%DOCUMENTATION :INITFORM NIL)))
     [java] ; (DEFCONSTANT +THE-FORWARD-REFERENCED-CLASS+ (FIND-CLASS (QUOTE FORWARD-REFERENCED-CLASS)))
     [java] ; (DEFINE-FUNCALLABLE-PRIMORDIAL-CLASS GENERIC-FUNCTION (METAOBJECT FUNCALLABLE-STANDARD-OBJECT) NIL)
     [java] ; (DEFVAR *EXTENSIBLE-BUILT-IN-CLASSES* (LIST (FIND-CLASS (QUOTE SEQUENCE)) (FIND-CLASS (QUOTE JAVA:JAVA-OBJECT))))
     [java] ; (DEFVAR *MAKE-INSTANCE-INITARGS-CACHE* (MAKE-HASH-TABLE :TEST (FUNCTION EQ)) "Cached sets of allowable initargs, keyed on the class they belong to.")
     [java] ; (DEFVAR *REINITIALIZE-INSTANCE-INITARGS-CACHE* (MAKE-HASH-TABLE :TEST (FUNCTION EQ)) "Cached sets of allowable initargs, keyed on the class they belong to.")
     [java] ; (DEFUN EXPAND-LONG-DEFCOMBIN (NAME ARGS) (DESTRUCTURING-BIND (LAMBDA-LIST METHOD-GROUPS &REST BODY) ARGS (SYSTEM::BACKQ-LIST (QUOTE APPLY) (QUOTE (FUNCTION DEFINE-LONG-FORM-METHOD-COMBINATION)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) (SYSTEM::BACKQ-CONS (QUOTE LIST) (MAPCAR (FUNCTION CANONICALIZE-METHOD-GROUP-SPEC) METHOD-GROUPS)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) BODY))))
     [java] ; (DEFUN %MAKE-LONG-METHOD-COMBINATION (&KEY NAME DOCUMENTATION LAMBDA-LIST METHOD-GROUP-SPECS ARGS-LAMBDA-LIST GENERIC-FUNCTION-SYMBOL FUNCTION ARGUMENTS DECLARATIONS FORMS) (LET ((INSTANCE (STD-ALLOCATE-INSTANCE (FIND-CLASS (QUOTE LONG-METHOD-COMBINATION))))) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE NAME)) NAME) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE %DOCUMENTATION)) DOCUMENTATION) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::LAMBDA-LIST)) LAMBDA-LIST) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE METHOD-GROUP-SPECS)) METHOD-GROUP-SPECS) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE ARGS-LAMBDA-LIST)) ARGS-LAMBDA-LIST) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE GENERIC-FUNCTION-SYMBOL)) GENERIC-FUNCTION-SYMBOL) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE FUNCTION)) FUNCTION) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE ARGUMENTS)) ARGUMENTS) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE DECLARATIONS)) DECLARATIONS) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE FORMS)) FORMS) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE OPTIONS)) NIL) INSTANCE))
     [java] ; (DEFUN METHOD-COMBINATION-NAME (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE NAME)))
     [java] ; (DEFUN METHOD-COMBINATION-DOCUMENTATION (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE %DOCUMENTATION)))
     [java] ; (DEFUN SHORT-METHOD-COMBINATION-OPERATOR (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION SHORT-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE OPERATOR)))
     [java] ; (DEFUN SHORT-METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION SHORT-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE IDENTITY-WITH-ONE-ARGUMENT)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-LAMBDA-LIST (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE SYSTEM::LAMBDA-LIST)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-METHOD-GROUP-SPECS (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE METHOD-GROUP-SPECS)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-ARGS-LAMBDA-LIST (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE ARGS-LAMBDA-LIST)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-GENERIC-FUNCTION-SYMBOL (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE GENERIC-FUNCTION-SYMBOL)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-FUNCTION (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE FUNCTION)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-ARGUMENTS (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE ARGUMENTS)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-DECLARATIONS (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE DECLARATIONS)))
     [java] ; (DEFUN LONG-METHOD-COMBINATION-FORMS (METHOD-COMBINATION) (CHECK-TYPE METHOD-COMBINATION LONG-METHOD-COMBINATION) (STD-SLOT-VALUE METHOD-COMBINATION (QUOTE FORMS)))
     [java] ; (DEFUN EXPAND-SHORT-DEFCOMBIN (WHOLE) (LET* ((NAME (CADR WHOLE)) (DOCUMENTATION (GETF (CDDR WHOLE) :DOCUMENTATION "")) (IDENTITY-WITH-ONE-ARG (GETF (CDDR WHOLE) :IDENTITY-WITH-ONE-ARGUMENT NIL)) (OPERATOR (GETF (CDDR WHOLE) :OPERATOR NAME))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE LET) (QUOTE ((INSTANCE (STD-ALLOCATE-INSTANCE (FIND-CLASS (QUOTE SHORT-METHOD-COMBINATION)))))) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (STD-SLOT-VALUE INSTANCE (QUOTE NAME))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME)) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (STD-SLOT-VALUE INSTANCE (QUOTE %DOCUMENTATION))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) DOCUMENTATION)) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (STD-SLOT-VALUE INSTANCE (QUOTE OPERATOR))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) OPERATOR)) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (STD-SLOT-VALUE INSTANCE (QUOTE IDENTITY-WITH-ONE-ARGUMENT))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) IDENTITY-WITH-ONE-ARG)) (QUOTE (SETF (STD-SLOT-VALUE INSTANCE (QUOTE OPTIONS)) NIL)) (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST* (QUOTE GET) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE METHOD-COMBINATION-OBJECT)))) (QUOTE (INSTANCE))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME)))))
     [java] ; (DEFMACRO DEFINE-METHOD-COMBINATION (&WHOLE FORM NAME &REST ARGS) (IF (AND (CDDR FORM) (LISTP (CADDR FORM))) (EXPAND-LONG-DEFCOMBIN NAME ARGS) (EXPAND-SHORT-DEFCOMBIN FORM)))
     [java] ; (DEFINE-METHOD-COMBINATION + :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION AND :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION APPEND :IDENTITY-WITH-ONE-ARGUMENT NIL)
     [java] ; (DEFINE-METHOD-COMBINATION LIST :IDENTITY-WITH-ONE-ARGUMENT NIL)
     [java] ; (DEFINE-METHOD-COMBINATION MAX :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION MIN :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION NCONC :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION OR :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFINE-METHOD-COMBINATION PROGN :IDENTITY-WITH-ONE-ARGUMENT T)
     [java] ; (DEFUN METHOD-GROUP-P (SELECTER QUALIFIERS) (ETYPECASE SELECTER (LIST (OR (EQUAL SELECTER QUALIFIERS) (LET ((LAST (LAST SELECTER))) (WHEN (EQ (QUOTE *) (CDR LAST)) (LET* ((PREFIX (SYSTEM::BACKQ-APPEND (BUTLAST SELECTER) (SYSTEM::BACKQ-LIST (CAR LAST)))) (POS (MISMATCH PREFIX QUALIFIERS))) (OR (NULL POS) (= POS (LENGTH PREFIX)))))))) ((EQL *) T) (SYMBOL (FUNCALL (SYMBOL-FUNCTION SELECTER) QUALIFIERS))))
     [java] ; (DEFUN CHECK-VARIABLE-NAME (NAME) (FLET ((VALID-VARIABLE-NAME-P (NAME) (AND (SYMBOLP NAME) (NOT (CONSTANTP NAME))))) (ASSERT (VALID-VARIABLE-NAME-P NAME))))
     [java] ; (DEFUN CANONICALIZE-METHOD-GROUP-SPEC (SPEC) (LET* ((REST SPEC) (NAME (PROG2 (CHECK-VARIABLE-NAME (CAR REST)) (CAR REST) (SETQ REST (CDR REST)))) (OPTION-NAMES (QUOTE (:DESCRIPTION :ORDER :REQUIRED))) (SELECTERS (LET ((END (OR (POSITION-IF (FUNCTION (LAMBDA (IT) (MEMBER IT OPTION-NAMES))) REST) (LENGTH REST)))) (PROG1 (SUBSEQ REST 0 END) (SETQ REST (SUBSEQ REST END))))) (DESCRIPTION (GETF REST :DESCRIPTION "")) (ORDER (GETF REST :ORDER :MOST-SPECIFIC-FIRST)) (REQUIRED-P (GETF REST :REQUIRED))) (SYSTEM::BACKQ-LIST (QUOTE LIST) (QUOTE :NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE :PREDICATE) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (QUALIFIERS)) (SYSTEM::BACKQ-LIST* (QUOTE LOOP) (QUOTE FOR) (QUOTE ITEM) (QUOTE IN) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SELECTERS) (QUOTE (THEREIS (METHOD-GROUP-P ITEM QUALIFIERS))))) (QUOTE :DESCRIPTION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) DESCRIPTION) (QUOTE :ORDER) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ORDER) (QUOTE :REQUIRED) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) REQUIRED-P) (QUOTE :*-SELECTER) (EQUAL SELECTERS (QUOTE (*))))))
     [java] ; (DEFUN EXTRACT-REQUIRED-PART (LAMBDA-LIST) (FLET ((SKIP (KEY LAMBDA-LIST) (IF (EQ (FIRST LAMBDA-LIST) KEY) (CDDR LAMBDA-LIST) LAMBDA-LIST))) (LET* ((TRIMMED-LAMBDA-LIST (SKIP (QUOTE &ENVIRONMENT) (SKIP (QUOTE &WHOLE) LAMBDA-LIST))) (AFTER-REQUIRED-LAMBDA-LIST (MEMBER-IF (FUNCTION (LAMBDA (IT) (MEMBER IT LAMBDA-LIST-KEYWORDS))) TRIMMED-LAMBDA-LIST))) (IF AFTER-REQUIRED-LAMBDA-LIST (LDIFF TRIMMED-LAMBDA-LIST AFTER-REQUIRED-LAMBDA-LIST) TRIMMED-LAMBDA-LIST))))
     [java] ; (DEFUN EXTRACT-SPECIFIED-PART (KEY LAMBDA-LIST) (CASE KEY ((&EVAL &WHOLE) (LIST (SECOND (MEMBER KEY LAMBDA-LIST)))) (T (LET ((HERE (CDR (MEMBER KEY LAMBDA-LIST)))) (LDIFF HERE (MEMBER-IF (FUNCTION (LAMBDA (IT) (MEMBER IT LAMBDA-LIST-KEYWORDS))) HERE))))))
     [java] ; (DEFUN EXTRACT-OPTIONAL-PART (LAMBDA-LIST) (EXTRACT-SPECIFIED-PART (QUOTE &OPTIONAL) LAMBDA-LIST))
     [java] ; (DEFUN PARSE-DEFINE-METHOD-COMBINATION-ARGS-LAMBDA-LIST (LAMBDA-LIST) (LET ((REQUIRED (EXTRACT-REQUIRED-PART LAMBDA-LIST)) (WHOLE (EXTRACT-SPECIFIED-PART (QUOTE &WHOLE) LAMBDA-LIST)) (OPTIONAL (EXTRACT-SPECIFIED-PART (QUOTE &OPTIONAL) LAMBDA-LIST)) (REST (EXTRACT-SPECIFIED-PART (QUOTE &REST) LAMBDA-LIST)) (KEYS (EXTRACT-SPECIFIED-PART (QUOTE &KEY) LAMBDA-LIST)) (AUX (EXTRACT-SPECIFIED-PART (QUOTE &AUX) LAMBDA-LIST))) (VALUES (FIRST WHOLE) REQUIRED (MAPCAR (FUNCTION (LAMBDA (SPEC) (IF (CONSP SPEC) (SYSTEM::BACKQ-LIST* (FIRST SPEC) (SECOND SPEC) (CDDR SPEC)) (SYSTEM::BACKQ-CONS SPEC (QUOTE (NIL)))))) OPTIONAL) (FIRST REST) (MAPCAR (FUNCTION (LAMBDA (SPEC) (LET ((KEY (IF (CONSP SPEC) (CAR SPEC) SPEC)) (REST (WHEN (CONSP SPEC) (REST SPEC)))) (SYSTEM::BACKQ-LIST* (IF (CONSP KEY) KEY (SYSTEM::BACKQ-LIST (MAKE-KEYWORD KEY) KEY)) (CAR REST) (CDR REST))))) KEYS) (MAPCAR (FUNCTION (LAMBDA (SPEC) (IF (CONSP SPEC) (SYSTEM::BACKQ-LIST (FIRST SPEC) (SECOND SPEC)) (SYSTEM::BACKQ-CONS SPEC (QUOTE (NIL)))))) AUX))))
     [java] ; (DEFUN WRAP-WITH-CALL-METHOD-MACRO (GF ARGS-VAR EMF-FORM) (SYSTEM::BACKQ-LIST (QUOTE MACROLET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE CALL-METHOD) (QUOTE (METHOD &OPTIONAL NEXT-METHOD-LIST)) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE FUNCALL)) (SYSTEM::BACKQ-LIST* (QUOTE COND) (SYSTEM::BACKQ-LIST (QUOTE (LISTP METHOD)) (QUOTE (ASSERT (EQ (FIRST METHOD) (QUOTE MAKE-METHOD)))) (SYSTEM::BACKQ-LIST (QUOTE COMPUTE-METHOD-FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE LAMBDA)) (QUOTE (SYSTEM::BACKQ-LIST (QUOTE &REST) (GENSYM))) (SYSTEM::BACKQ-LIST* (QUOTE WRAP-WITH-CALL-METHOD-MACRO) GF (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR) (QUOTE ((SECOND METHOD))))))) (QUOTE ((T (METHOD-FUNCTION METHOD))))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR) (SYSTEM::BACKQ-LIST (QUOTE UNLESS) (QUOTE (NULL NEXT-METHOD-LIST)) (SYSTEM::BACKQ-LIST* (QUOTE COMPUTE-EFFECTIVE-METHOD) GF (SYSTEM::BACKQ-LIST (QUOTE GENERIC-FUNCTION-METHOD-COMBINATION) GF) (QUOTE ((PROCESS-NEXT-METHOD-LIST NEXT-METHOD-LIST)))))))) EMF-FORM))
     [java] ; (DEFUN ASSERT-UNAMBIGUOUS-METHOD-SORTING (GROUP-NAME METHODS) (LET ((SPECIALIZERS (MAKE-HASH-TABLE :TEST (QUOTE EQUAL)))) (DOLIST (METHOD METHODS) (PUSH METHOD (GETHASH (METHOD-SPECIALIZERS METHOD) SPECIALIZERS))) (LOOP FOR SPECIALIZER-METHODS BEING EACH HASH-VALUE OF SPECIALIZERS USING (HASH-KEY METHOD-SPECIALIZERS) UNLESS (= 1 (LENGTH SPECIALIZER-METHODS)) DO (ERROR "Ambiguous method sorting in method group ~A due to multiple ~
     [java]                   methods with specializers ~S: ~S" GROUP-NAME METHOD-SPECIALIZERS SPECIALIZER-METHODS))))
     [java] ; (DEFMACRO WITH-METHOD-GROUPS (METHOD-GROUP-SPECS METHODS-FORM &BODY FORMS) (FLET ((GROUPING-FORM (SPEC METHODS-VAR) (LET ((PREDICATE (COERCE-TO-FUNCTION (GETF SPEC :PREDICATE))) (GROUP (GENSYM)) (LEFTOVERS (GENSYM)) (METHOD (GENSYM))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS GROUP (QUOTE ((QUOTE NIL)))) (SYSTEM::BACKQ-CONS LEFTOVERS (QUOTE ((QUOTE NIL))))) (SYSTEM::BACKQ-LIST (QUOTE DOLIST) (SYSTEM::BACKQ-LIST METHOD METHODS-VAR) (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) PREDICATE (SYSTEM::BACKQ-LIST (QUOTE METHOD-QUALIFIERS) METHOD)) (SYSTEM::BACKQ-LIST (QUOTE PUSH) METHOD GROUP) (SYSTEM::BACKQ-LIST (QUOTE PUSH) METHOD LEFTOVERS))) (SYSTEM::BACKQ-LIST (QUOTE ECASE) (GETF SPEC :ORDER) (QUOTE (:MOST-SPECIFIC-LAST)) (SYSTEM::BACKQ-LIST (QUOTE :MOST-SPECIFIC-FIRST) (SYSTEM::BACKQ-LIST (QUOTE SETQ) GROUP (SYSTEM::BACKQ-LIST (QUOTE NREVERSE) GROUP)))) (SYSTEM::BACKQ-APPEND (WHEN (GETF SPEC :REQUIRED) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE NULL) GROUP) (SYSTEM::BACKQ-LIST (QUOTE ERROR) "Method group ~S must not be empty." (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (GETF SPEC :NAME)))))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE SETQ) METHODS-VAR (SYSTEM::BACKQ-LIST (QUOTE NREVERSE) LEFTOVERS)) GROUP)))))) (LET ((REST (GENSYM)) (METHOD (GENSYM))) (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST REST METHODS-FORM) (MAPCAR (FUNCTION (LAMBDA (SPEC) (SYSTEM::BACKQ-LIST (GETF SPEC :NAME) (GROUPING-FORM SPEC REST)))) METHOD-GROUP-SPECS)) (SYSTEM::BACKQ-LIST (QUOTE DOLIST) (SYSTEM::BACKQ-LIST METHOD REST) (SYSTEM::BACKQ-LIST (QUOTE INVALID-METHOD-ERROR) METHOD "Method ~S with qualifiers ~S does not belong to any method group." METHOD (SYSTEM::BACKQ-LIST (QUOTE METHOD-QUALIFIERS) METHOD))) (SYSTEM::BACKQ-APPEND (UNLESS (AND (= 1 (LENGTH METHOD-GROUP-SPECS)) (GETF (CAR METHOD-GROUP-SPECS) :*-SELECTER)) (MAPCAR (FUNCTION (LAMBDA (SPEC) (SYSTEM::BACKQ-LIST (QUOTE ASSERT-UNAMBIGUOUS-METHOD-SORTING) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (GETF SPEC :NAME)) (GETF SPEC :NAME)))) METHOD-GROUP-SPECS)) FORMS)))))
     [java] ; (DEFUN METHOD-COMBINATION-TYPE-LAMBDA-WITH-ARGS-EMF (&KEY ARGS-LAMBDA-LIST GENERIC-FUNCTION-SYMBOL FORMS &ALLOW-OTHER-KEYS) (MULTIPLE-VALUE-BIND (WHOLE REQUIRED OPTIONAL REST KEYS AUX) (PARSE-DEFINE-METHOD-COMBINATION-ARGS-LAMBDA-LIST ARGS-LAMBDA-LIST) (UNLESS REST (WHEN KEYS (SETF REST (GENSYM)))) (LET* ((GF-LAMBDA-LIST (GENSYM)) (ARGS-VAR (GENSYM)) (ARGS-LEN-VAR (GENSYM)) (BINDING-FORMS (GENSYM)) (NEEDS-ARGS-LEN-VAR (GENSYM)) (EMF-FORM (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST GF-LAMBDA-LIST (SYSTEM::BACKQ-LIST* (QUOTE SLOT-VALUE) GENERIC-FUNCTION-SYMBOL (QUOTE ((QUOTE SYSTEM::LAMBDA-LIST))))) (SYSTEM::BACKQ-LIST (QUOTE NREQ) (SYSTEM::BACKQ-LIST (QUOTE LENGTH) (SYSTEM::BACKQ-LIST (QUOTE EXTRACT-REQUIRED-PART) GF-LAMBDA-LIST))) (SYSTEM::BACKQ-LIST (QUOTE NOPT) (SYSTEM::BACKQ-LIST (QUOTE LENGTH) (SYSTEM::BACKQ-LIST (QUOTE EXTRACT-OPTIONAL-PART) GF-LAMBDA-LIST))) (SYSTEM::BACKQ-LIST BINDING-FORMS) (SYSTEM::BACKQ-LIST NEEDS-ARGS-LEN-VAR) (SYSTEM::BACKQ-LIST EMF-FORM (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-APPEND (WHEN WHOLE (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST WHOLE (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST WHOLE ARGS-VAR)) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR))))) (WHEN REST (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST REST (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) REST) (SYSTEM::BACKQ-LIST* (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE SUBSEQ)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR) (QUOTE ((+ NREQ NOPT))))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) REST))))) (LOOP FOR VAR IN REQUIRED AND I UPFROM 0 FOR VAR-BINDING = (GENSYM) COLLECT (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST* (QUOTE <) I (QUOTE (NREQ))) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE NTH)) I (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST ARGS-VAR)))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING)))) (LOOP FOR (VAR INITFORM SUPPLIED-VAR) IN OPTIONAL AND I UPFROM 0 FOR SUPPLIED-BINDING = (OR SUPPLIED-VAR (GENSYM)) FOR VAR-BINDING = (GENSYM) COLLECT (SYSTEM::BACKQ-LIST SUPPLIED-BINDING (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST* (QUOTE <) I (QUOTE (NOPT))) (SYSTEM::BACKQ-LIST* (QUOTE SETQ) NEEDS-ARGS-LEN-VAR (QUOTE (T))) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SUPPLIED-BINDING) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE <)) (SYSTEM::BACKQ-LIST* (QUOTE +) I (QUOTE (NREQ))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST ARGS-LEN-VAR)))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SUPPLIED-BINDING))) COLLECT (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST* (QUOTE <) I (QUOTE (NOPT))) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE IF)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SUPPLIED-BINDING) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE NTH)) (SYSTEM::BACKQ-LIST* (QUOTE +) I (QUOTE (NREQ))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST ARGS-VAR))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST INITFORM)))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING)))) (LOOP FOR ((KEY VAR) INITFORM SUPPLIED-VAR) IN KEYS FOR SUPPLIED-BINDING = (OR SUPPLIED-VAR (GENSYM)) FOR VAR-BINDING = (GENSYM) COLLECT (SYSTEM::BACKQ-LIST SUPPLIED-BINDING (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST SUPPLIED-BINDING (SYSTEM::BACKQ-LIST (QUOTE MEMBER) KEY REST))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SUPPLIED-BINDING))) COLLECT (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST VAR-BINDING (SYSTEM::BACKQ-LIST (QUOTE IF) SUPPLIED-BINDING (SYSTEM::BACKQ-LIST (QUOTE CADR) SUPPLIED-BINDING) INITFORM))) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING)))) (LOOP FOR (VAR INITFORM) IN AUX FOR VAR-BINDING = (GENSYM) COLLECT (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST VAR-BINDING INITFORM)) BINDING-FORMS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) VAR-BINDING))))) FORMS))) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE LAMBDA)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST ARGS-VAR)) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE LET*)) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-APPEND) (SYSTEM::BACKQ-LIST (QUOTE WHEN) NEEDS-ARGS-LEN-VAR (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST ARGS-LEN-VAR (SYSTEM::BACKQ-LIST (QUOTE LENGTH) ARGS-VAR))))) (SYSTEM::BACKQ-LIST (QUOTE REVERSE) BINDING-FORMS)) (SYSTEM::BACKQ-LIST (QUOTE WRAP-WITH-CALL-METHOD-MACRO) GENERIC-FUNCTION-SYMBOL (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR) EMF-FORM)))))))
     [java] ; (DEFUN METHOD-COMBINATION-TYPE-LAMBDA (&REST ALL-ARGS &KEY NAME LAMBDA-LIST ARGS-LAMBDA-LIST GENERIC-FUNCTION-SYMBOL METHOD-GROUP-SPECS DECLARATIONS FORMS &ALLOW-OTHER-KEYS) (DECLARE (IGNORE NAME)) (LET ((METHODS (GENSYM)) (ARGS-VAR (GENSYM)) (EMF-FORM (GENSYM))) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST* GENERIC-FUNCTION-SYMBOL METHODS LAMBDA-LIST) (SYSTEM::BACKQ-APPEND DECLARATIONS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE WITH-METHOD-GROUPS) METHOD-GROUP-SPECS METHODS (IF (NULL ARGS-LAMBDA-LIST) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST EMF-FORM (SYSTEM::BACKQ-CONS (QUOTE PROGN) FORMS))) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE LAMBDA)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST ARGS-VAR)) (SYSTEM::BACKQ-LIST (QUOTE WRAP-WITH-CALL-METHOD-MACRO) GENERIC-FUNCTION-SYMBOL (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ARGS-VAR) EMF-FORM))) (APPLY (FUNCTION METHOD-COMBINATION-TYPE-LAMBDA-WITH-ARGS-EMF) ALL-ARGS))))))))
     [java] ; (DEFUN DECLARATIONP (EXPR) (AND (CONSP EXPR) (EQ (CAR EXPR) (QUOTE DECLARE))))
     [java] ; (DEFUN LONG-FORM-METHOD-COMBINATION-ARGS (ARGS) (LET ((REST ARGS)) (LABELS ((NEXTP (KEY) (AND (CONSP (CAR REST)) (EQ KEY (CAAR REST)))) (ARGS-LAMBDA-LIST NIL (WHEN (NEXTP :ARGUMENTS) (PROG1 (CDR (CAR REST)) (SETQ REST (CDR REST))))) (GENERIC-FUNCTION-SYMBOL NIL (IF (NEXTP :GENERIC-FUNCTION) (PROG1 (SECOND (CAR REST)) (SETQ REST (CDR REST))) (GENSYM))) (DECLARATION* NIL (LET ((END (POSITION-IF-NOT (FUNCTION DECLARATIONP) REST))) (WHEN END (PROG1 (SUBSEQ REST 0 END) (SETQ REST (NTHCDR END REST)))))) (DOCUMENTATION? NIL (WHEN (STRINGP (CAR REST)) (PROG1 (CAR REST) (SETQ REST (CDR REST))))) (FORM* NIL REST)) (LET ((DECLARATIONS (QUOTE NIL))) (SYSTEM::BACKQ-LIST (QUOTE :ARGS-LAMBDA-LIST) (ARGS-LAMBDA-LIST) (QUOTE :GENERIC-FUNCTION-SYMBOL) (GENERIC-FUNCTION-SYMBOL) (QUOTE :DOCUMENTATION) (PROG2 (SETQ DECLARATIONS (DECLARATION*)) (DOCUMENTATION?)) (QUOTE :DECLARATIONS) (SYSTEM::BACKQ-APPEND DECLARATIONS (DECLARATION*)) (QUOTE :FORMS) (FORM*))))))
     [java] ; (DEFUN DEFINE-LONG-FORM-METHOD-COMBINATION (NAME LAMBDA-LIST METHOD-GROUP-SPECS &REST ARGS) (LET* ((INITARGS (SYSTEM::BACKQ-LIST* (QUOTE :NAME) NAME (QUOTE :LAMBDA-LIST) LAMBDA-LIST (QUOTE :METHOD-GROUP-SPECS) METHOD-GROUP-SPECS (LONG-FORM-METHOD-COMBINATION-ARGS ARGS))) (LAMBDA-EXPRESSION (APPLY (FUNCTION METHOD-COMBINATION-TYPE-LAMBDA) INITARGS))) (SETF (GET NAME (QUOTE METHOD-COMBINATION-OBJECT)) (APPLY (QUOTE %MAKE-LONG-METHOD-COMBINATION) :FUNCTION (COERCE-TO-FUNCTION LAMBDA-EXPRESSION) INITARGS)) NAME))
     [java] ; (DEFUN STD-FIND-METHOD-COMBINATION (GF NAME OPTIONS) (DECLARE (IGNORE GF)) (WHEN (AND (EQL NAME (QUOTE STANDARD)) OPTIONS) (ERROR "The standard method combination does not accept any arguments.")) (LET ((MC (GET NAME (QUOTE METHOD-COMBINATION-OBJECT)))) (COND ((NULL MC) (ERROR "Method combination ~S not found" NAME)) ((NULL OPTIONS) MC) ((TYPEP MC (QUOTE SHORT-METHOD-COMBINATION)) (MAKE-INSTANCE (QUOTE SHORT-METHOD-COMBINATION) :NAME NAME :DOCUMENTATION (METHOD-COMBINATION-DOCUMENTATION MC) :OPERATOR (SHORT-METHOD-COMBINATION-OPERATOR MC) :IDENTITY-WITH-ONE-ARGUMENT (SHORT-METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT MC) :OPTIONS OPTIONS)) ((TYPEP MC (QUOTE LONG-METHOD-COMBINATION)) (MAKE-INSTANCE (QUOTE LONG-METHOD-COMBINATION) :NAME NAME :DOCUMENTATION (METHOD-COMBINATION-DOCUMENTATION MC) :LAMBDA-LIST (LONG-METHOD-COMBINATION-LAMBDA-LIST MC) :METHOD-GROUP-SPECS (LONG-METHOD-COMBINATION-METHOD-GROUP-SPECS MC) :ARGS-LAMBDA-LIST (LONG-METHOD-COMBINATION-ARGS-LAMBDA-LIST MC) :GENERIC-FUNCTION-SYMBOL (LONG-METHOD-COMBINATION-GENERIC-FUNCTION-SYMBOL MC) :FUNCTION (LONG-METHOD-COMBINATION-FUNCTION MC) :ARGUMENTS (LONG-METHOD-COMBINATION-ARGUMENTS MC) :DECLARATIONS (LONG-METHOD-COMBINATION-DECLARATIONS MC) :FORMS (LONG-METHOD-COMBINATION-FORMS MC) :OPTIONS OPTIONS)))))
     [java] ; (DECLAIM (NOTINLINE FIND-METHOD-COMBINATION))
     [java] ; (DEFUN FIND-METHOD-COMBINATION (GF NAME OPTIONS) (STD-FIND-METHOD-COMBINATION GF NAME OPTIONS))
     [java] ; (DEFCONSTANT +THE-STANDARD-METHOD-COMBINATION+ (LET ((INSTANCE (STD-ALLOCATE-INSTANCE (FIND-CLASS (QUOTE METHOD-COMBINATION))))) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE NAME)) (QUOTE STANDARD)) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE %DOCUMENTATION)) "The standard method combination.") (SETF (STD-SLOT-VALUE INSTANCE (QUOTE OPTIONS)) NIL) INSTANCE) "The standard method combination.
     [java] Do not use this object for identity since it changes between
     [java] compile-time and run-time.  To detect the standard method combination,
     [java] compare the method combination name to the symbol 'standard.")
     [java] ; (SETF (GET (QUOTE STANDARD) (QUOTE METHOD-COMBINATION-OBJECT)) +THE-STANDARD-METHOD-COMBINATION+)
     [java] ; (DEFINE-FUNCALLABLE-PRIMORDIAL-CLASS STANDARD-GENERIC-FUNCTION (GENERIC-FUNCTION) ((NAME :INITARG :NAME :INITFORM NIL) (SYSTEM::LAMBDA-LIST :INITARG :LAMBDA-LIST :INITFORM NIL) (SYSTEM::REQUIRED-ARGS :INITARG :REQUIRED-ARGS :INITFORM NIL) (SYSTEM::OPTIONAL-ARGS :INITARG :OPTIONAL-ARGS :INITFORM NIL) (SYSTEM::INITIAL-METHODS :INITARG :INITIAL-METHODS :INITFORM NIL) (SYSTEM::METHODS :INITARG :METHODS :INITFORM NIL) (SYSTEM::METHOD-CLASS :INITARG :METHOD-CLASS :INITFORM +THE-STANDARD-METHOD-CLASS+) (SYSTEM::%METHOD-COMBINATION :INITARG :METHOD-COMBINATION :INITFORM +THE-STANDARD-METHOD-COMBINATION+) (SYSTEM::ARGUMENT-PRECEDENCE-ORDER :INITARG :ARGUMENT-PRECEDENCE-ORDER :INITFORM NIL) (SYSTEM::DECLARATIONS :INITARG :DECLARATIONS :INITFORM NIL) (%DOCUMENTATION :INITARG :DOCUMENTATION :INITFORM NIL)))
     [java] ; (DEFCONSTANT +THE-STANDARD-GENERIC-FUNCTION-CLASS+ (FIND-CLASS (QUOTE STANDARD-GENERIC-FUNCTION)))
     [java] ; (DEFUN STD-GENERIC-FUNCTION-P (GF) (EQ (CLASS-OF GF) +THE-STANDARD-GENERIC-FUNCTION-CLASS+))
     [java] ; (DEFPARAMETER *EQL-SPECIALIZER-TABLE* (MAKE-HASH-TABLE :TEST (QUOTE EQL)))
     [java] ; (DEFUN INTERN-EQL-SPECIALIZER (OBJECT) (OR (GETHASH OBJECT *EQL-SPECIALIZER-TABLE*) (SETF (GETHASH OBJECT *EQL-SPECIALIZER-TABLE*) (LET ((INSTANCE (STD-ALLOCATE-INSTANCE (FIND-CLASS (QUOTE EQL-SPECIALIZER))))) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE OBJECT)) OBJECT) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE DIRECT-METHODS)) NIL) INSTANCE))))
     [java] ; (DEFUN EQL-SPECIALIZER-OBJECT (EQL-SPECIALIZER) (CHECK-TYPE EQL-SPECIALIZER EQL-SPECIALIZER) (STD-SLOT-VALUE EQL-SPECIALIZER (QUOTE OBJECT)))
     [java] ; (DEFUN STD-METHOD-FUNCTION (METHOD) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%FUNCTION)))
     [java] ; (DEFUN STD-METHOD-GENERIC-FUNCTION (METHOD) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%GENERIC-FUNCTION)))
     [java] ; (DEFUN STD-METHOD-SPECIALIZERS (METHOD) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::SPECIALIZERS)))
     [java] ; (DEFUN STD-METHOD-QUALIFIERS (METHOD) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::QUALIFIERS)))
     [java] ; (DEFUN STD-ACCESSOR-METHOD-SLOT-DEFINITION (ACCESSOR-METHOD) (STD-SLOT-VALUE ACCESSOR-METHOD (QUOTE SYSTEM::%SLOT-DEFINITION)))
     [java] ; (DEFUN STD-METHOD-FAST-FUNCTION (METHOD) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::FAST-FUNCTION)))
     [java] ; (DEFUN STD-FUNCTION-KEYWORDS (METHOD) (VALUES (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::KEYWORDS)) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::OTHER-KEYWORDS-P))))
     [java] ; (DECLAIM (NOTINLINE METHOD-GENERIC-FUNCTION))
     [java] ; (DEFUN METHOD-GENERIC-FUNCTION (METHOD) (STD-METHOD-GENERIC-FUNCTION METHOD))
     [java] ; (DECLAIM (NOTINLINE METHOD-FUNCTION))
     [java] ; (DEFUN METHOD-FUNCTION (METHOD) (STD-METHOD-FUNCTION METHOD))
     [java] ; (DECLAIM (NOTINLINE METHOD-SPECIALIZERS))
     [java] ; (DEFUN METHOD-SPECIALIZERS (METHOD) (STD-METHOD-SPECIALIZERS METHOD))
     [java] ; (DECLAIM (NOTINLINE METHOD-QUALIFIERS))
     [java] ; (DEFUN METHOD-QUALIFIERS (METHOD) (STD-METHOD-QUALIFIERS METHOD))
     [java] ; (DEFUN GENERIC-FUNCTION-NAME (GF) (STD-SLOT-VALUE GF (QUOTE NAME)))
     [java] ; (DEFUN GENERIC-FUNCTION-LAMBDA-LIST (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::LAMBDA-LIST)))
     [java] ; (DEFUN GENERIC-FUNCTION-METHODS (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHODS)))
     [java] ; (DEFUN GENERIC-FUNCTION-METHOD-CLASS (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHOD-CLASS)))
     [java] ; (DEFUN GENERIC-FUNCTION-METHOD-COMBINATION (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::%METHOD-COMBINATION)))
     [java] ; (DEFUN GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::ARGUMENT-PRECEDENCE-ORDER)))
     [java] ; (DEFUN GENERIC-FUNCTION-REQUIRED-ARGUMENTS (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::REQUIRED-ARGS)))
     [java] ; (DEFUN GENERIC-FUNCTION-OPTIONAL-ARGUMENTS (GF) (STD-SLOT-VALUE GF (QUOTE SYSTEM::OPTIONAL-ARGS)))
     [java] ; (DEFUN (SETF METHOD-LAMBDA-LIST) (NEW-VALUE METHOD) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::LAMBDA-LIST)) NEW-VALUE))
     [java] ; (DEFUN (SETF METHOD-QUALIFIERS) (NEW-VALUE METHOD) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::QUALIFIERS)) NEW-VALUE))
     [java] ; (DEFUN METHOD-DOCUMENTATION (METHOD) (STD-SLOT-VALUE METHOD (QUOTE %DOCUMENTATION)))
     [java] ; (DEFUN (SETF METHOD-DOCUMENTATION) (NEW-VALUE METHOD) (SETF (STD-SLOT-VALUE METHOD (QUOTE %DOCUMENTATION)) NEW-VALUE))
     [java] ; (DEFMACRO DEFGENERIC (FUNCTION-NAME LAMBDA-LIST &REST OPTIONS-AND-METHOD-DESCRIPTIONS) (LET ((OPTIONS NIL) (METHODS NIL) (DECLARATIONS NIL) (DOCUMENTATION NIL)) (DOLIST (ITEM OPTIONS-AND-METHOD-DESCRIPTIONS) (CASE (CAR ITEM) (DECLARE (SETF DECLARATIONS (APPEND DECLARATIONS (CDR ITEM)))) (:DOCUMENTATION (WHEN DOCUMENTATION (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Documentation option was specified twice for generic function ~S." :FORMAT-ARGUMENTS (LIST FUNCTION-NAME))) (SETF DOCUMENTATION T) (PUSH ITEM OPTIONS)) (:METHOD (PUSH (SYSTEM::BACKQ-LIST (QUOTE PUSH) (SYSTEM::BACKQ-LIST* (QUOTE DEFMETHOD) FUNCTION-NAME (CDR ITEM)) (SYSTEM::BACKQ-LIST* (QUOTE STD-SLOT-VALUE) (SYSTEM::BACKQ-LIST (QUOTE FDEFINITION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME)) (QUOTE ((QUOTE SYSTEM::INITIAL-METHODS))))) METHODS)) (T (PUSH ITEM OPTIONS)))) (WHEN DECLARATIONS (PUSH (LIST :DECLARATIONS DECLARATIONS) OPTIONS)) (SETF OPTIONS (NREVERSE OPTIONS) METHODS (NREVERSE METHODS)) (WHEN (FIND (QUOTE &AUX) LAMBDA-LIST) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "&AUX is not allowed in a generic function lambda list: ~S" :FORMAT-ARGUMENTS (LIST LAMBDA-LIST))) (SYSTEM::BACKQ-LIST* (QUOTE PROG1) (SYSTEM::BACKQ-LIST* (QUOTE %DEFGENERIC) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME) (QUOTE :LAMBDA-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) (CANONICALIZE-DEFGENERIC-OPTIONS OPTIONS)) (SYSTEM::BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST (QUOTE :GENERIC-FUNCTION) FUNCTION-NAME))) METHODS)))
     [java] ; (DEFUN CANONICALIZE-DEFGENERIC-OPTIONS (OPTIONS) (MAPAPPEND (FUNCTION CANONICALIZE-DEFGENERIC-OPTION) OPTIONS))
     [java] ; (DEFUN CANONICALIZE-DEFGENERIC-OPTION (OPTION) (CASE (CAR OPTION) (:GENERIC-FUNCTION-CLASS (LIST :GENERIC-FUNCTION-CLASS (SYSTEM::BACKQ-LIST (QUOTE FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR OPTION))))) (:METHOD-CLASS (LIST :METHOD-CLASS (SYSTEM::BACKQ-LIST (QUOTE FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR OPTION))))) (:METHOD-COMBINATION (LIST :METHOD-COMBINATION (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CDR OPTION)))) (:ARGUMENT-PRECEDENCE-ORDER (LIST :ARGUMENT-PRECEDENCE-ORDER (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CDR OPTION)))) (T (LIST (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CAR OPTION)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR OPTION))))))
     [java] ; (DEFUN ARGUMENT-PRECEDENCE-ORDER-INDICES (APO REQ) (COND ((EQUAL APO REQ) NIL) ((NOT (EQL (LENGTH APO) (LENGTH REQ))) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Specified argument precedence order ~S does not match lambda list." :FORMAT-ARGUMENTS (LIST APO))) (T (LET ((RES NIL)) (DOLIST (ARG APO (NREVERSE RES)) (LET ((INDEX (POSITION ARG REQ))) (IF (OR (NULL INDEX) (MEMQ INDEX RES)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Specified argument precedence order ~S does not match lambda list." :FORMAT-ARGUMENTS (LIST APO))) (PUSH INDEX RES)))))))
     [java] ; (DEFUN FIND-GENERIC-FUNCTION (NAME &OPTIONAL (ERRORP T)) (LET ((FUNCTION (AND (FBOUNDP NAME) (FDEFINITION NAME)))) (WHEN FUNCTION (WHEN (TYPEP FUNCTION (QUOTE GENERIC-FUNCTION)) (RETURN-FROM FIND-GENERIC-FUNCTION FUNCTION)) (WHEN (AND *TRACED-NAMES* (FIND NAME *TRACED-NAMES* :TEST (FUNCTION EQUAL))) (SETF FUNCTION (UNTRACED-FUNCTION NAME)) (WHEN (TYPEP FUNCTION (QUOTE GENERIC-FUNCTION)) (RETURN-FROM FIND-GENERIC-FUNCTION FUNCTION))))) (IF ERRORP (ERROR "There is no generic function named ~S." NAME) NIL))
     [java] ; (DEFUN LAMBDA-LISTS-CONGRUENT-P (LAMBDA-LIST1 LAMBDA-LIST2) (LET* ((PLIST1 (ANALYZE-LAMBDA-LIST LAMBDA-LIST1)) (ARGS1 (GETF PLIST1 :REQUIRED-ARGS)) (PLIST2 (ANALYZE-LAMBDA-LIST LAMBDA-LIST2)) (ARGS2 (GETF PLIST2 :REQUIRED-ARGS))) (= (LENGTH ARGS1) (LENGTH ARGS2))))
     [java] ; (DEFUN %DEFGENERIC (FUNCTION-NAME &REST ALL-KEYS) (WHEN (FBOUNDP FUNCTION-NAME) (LET ((GF (FDEFINITION FUNCTION-NAME))) (WHEN (TYPEP GF (QUOTE STANDARD-GENERIC-FUNCTION)) (DOLIST (METHOD (STD-SLOT-VALUE GF (QUOTE SYSTEM::INITIAL-METHODS))) (STD-REMOVE-METHOD GF METHOD) (MAP-DEPENDENTS GF (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GF DEP (QUOTE REMOVE-METHOD) METHOD))))) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::INITIAL-METHODS)) (QUOTE NIL))))) (APPLY (QUOTE ENSURE-GENERIC-FUNCTION) FUNCTION-NAME ALL-KEYS))
     [java] ; (DECLAIM (NOTINLINE ENSURE-GENERIC-FUNCTION))
     [java] ; (DEFUN ENSURE-GENERIC-FUNCTION (FUNCTION-NAME &REST ALL-KEYS &KEY (LAMBDA-LIST NIL LAMBDA-LIST-SUPPLIED-P) (GENERIC-FUNCTION-CLASS +THE-STANDARD-GENERIC-FUNCTION-CLASS+) (METHOD-CLASS +THE-STANDARD-METHOD-CLASS+) (METHOD-COMBINATION +THE-STANDARD-METHOD-COMBINATION+ MC-P) ARGUMENT-PRECEDENCE-ORDER (DOCUMENTATION NIL DOCUMENTATION-SUPPLIED-P) &ALLOW-OTHER-KEYS) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :GENERIC-FUNCTION-CLASS) (LET ((GF (FIND-GENERIC-FUNCTION FUNCTION-NAME NIL))) (IF GF (PROGN (WHEN LAMBDA-LIST-SUPPLIED-P (UNLESS (OR (NULL (GENERIC-FUNCTION-METHODS GF)) (LAMBDA-LISTS-CONGRUENT-P LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF))) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "The lambda list ~S is incompatible with the existing methods of ~S." :FORMAT-ARGUMENTS (LIST LAMBDA-LIST GF))) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::LAMBDA-LIST)) LAMBDA-LIST) (LET* ((PLIST (ANALYZE-LAMBDA-LIST LAMBDA-LIST)) (REQUIRED-ARGS (GETF PLIST (QUOTE :REQUIRED-ARGS)))) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::REQUIRED-ARGS)) REQUIRED-ARGS) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::OPTIONAL-ARGS)) (GETF PLIST :OPTIONAL-ARGS)))) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::ARGUMENT-PRECEDENCE-ORDER)) (OR ARGUMENT-PRECEDENCE-ORDER (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF))) (WHEN DOCUMENTATION-SUPPLIED-P (SETF (STD-SLOT-VALUE GF (QUOTE %DOCUMENTATION)) DOCUMENTATION)) (FINALIZE-STANDARD-GENERIC-FUNCTION GF) GF) (PROGN (WHEN (AND (NULL *CLOS-BOOTING*) (AND (FBOUNDP FUNCTION-NAME) (AND (NOT (AUTOLOADP FUNCTION-NAME)) (AND (CONSP FUNCTION-NAME) (EQ (QUOTE SETF) (FIRST FUNCTION-NAME)) (NOT (AUTOLOAD-REF-P (SECOND FUNCTION-NAME))))))) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A already names an ordinary function, macro, or special operator." :FORMAT-ARGUMENTS (LIST FUNCTION-NAME))) (WHEN MC-P (ERROR "Preliminary ensure-method does not support :method-combination argument.")) (APPLY (FUNCTION MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION) GENERIC-FUNCTION-CLASS :NAME FUNCTION-NAME :METHOD-CLASS METHOD-CLASS :METHOD-COMBINATION METHOD-COMBINATION ALL-KEYS)))))
     [java] ; (DEFUN COLLECT-EQL-SPECIALIZER-OBJECTS (GENERIC-FUNCTION) (LET ((RESULT NIL)) (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)) (DOLIST (SPECIALIZER (METHOD-SPECIALIZERS METHOD)) (WHEN (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (PUSHNEW (EQL-SPECIALIZER-OBJECT SPECIALIZER) RESULT :TEST (QUOTE EQL))))) RESULT))
     [java] ; (DEFUN FINALIZE-STANDARD-GENERIC-FUNCTION (GF) (%REINIT-EMF-CACHE GF (COLLECT-EQL-SPECIALIZER-OBJECTS GF)) (SET-FUNCALLABLE-INSTANCE-FUNCTION GF (IF (STD-GENERIC-FUNCTION-P GF) (STD-COMPUTE-DISCRIMINATING-FUNCTION GF) (COMPUTE-DISCRIMINATING-FUNCTION GF))) (LET ((*WARN-ON-REDEFINITION* NIL)) (SETF (FDEFINITION (GENERIC-FUNCTION-NAME GF)) GF)) (VALUES))
     [java] ; (DEFUN MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION (GENERIC-FUNCTION-CLASS &KEY NAME LAMBDA-LIST (METHOD-CLASS +THE-STANDARD-METHOD-CLASS+) (METHOD-COMBINATION +THE-STANDARD-METHOD-COMBINATION+) ARGUMENT-PRECEDENCE-ORDER DECLARATIONS DOCUMENTATION) (DECLARE (IGNORE GENERIC-FUNCTION-CLASS)) (CHECK-ARGUMENT-PRECEDENCE-ORDER LAMBDA-LIST ARGUMENT-PRECEDENCE-ORDER) (LET ((GF (ALLOCATE-FUNCALLABLE-INSTANCE +THE-STANDARD-GENERIC-FUNCTION-CLASS+))) (UNLESS (CLASSP METHOD-CLASS) (SETF METHOD-CLASS (FIND-CLASS METHOD-CLASS))) (UNLESS (TYPEP METHOD-COMBINATION (QUOTE METHOD-COMBINATION)) (SETF METHOD-COMBINATION (FIND-METHOD-COMBINATION GF (CAR METHOD-COMBINATION) (CDR METHOD-COMBINATION)))) (SETF (STD-SLOT-VALUE GF (QUOTE NAME)) NAME) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::LAMBDA-LIST)) LAMBDA-LIST) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::INITIAL-METHODS)) NIL) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHODS)) NIL) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHOD-CLASS)) METHOD-CLASS) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::%METHOD-COMBINATION)) METHOD-COMBINATION) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::DECLARATIONS)) DECLARATIONS) (SETF (STD-SLOT-VALUE GF (QUOTE %DOCUMENTATION)) DOCUMENTATION) (LET* ((PLIST (ANALYZE-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF))) (REQUIRED-ARGS (GETF PLIST (QUOTE :REQUIRED-ARGS)))) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::REQUIRED-ARGS)) REQUIRED-ARGS) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::OPTIONAL-ARGS)) (GETF PLIST :OPTIONAL-ARGS)) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::ARGUMENT-PRECEDENCE-ORDER)) (OR ARGUMENT-PRECEDENCE-ORDER REQUIRED-ARGS))) (FINALIZE-STANDARD-GENERIC-FUNCTION GF) GF))
     [java] ; (DEFUN CANONICALIZE-SPECIALIZERS (SPECIALIZERS) (MAPCAR (FUNCTION CANONICALIZE-SPECIALIZER) SPECIALIZERS))
     [java] ; (DEFUN CANONICALIZE-SPECIALIZER (SPECIALIZER) (COND ((CLASSP SPECIALIZER) SPECIALIZER) ((TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) SPECIALIZER) ((SYMBOLP SPECIALIZER) (FIND-CLASS SPECIALIZER)) ((AND (CONSP SPECIALIZER) (EQ (CAR SPECIALIZER) (QUOTE EQL))) (LET ((OBJECT (CADR SPECIALIZER))) (WHEN (AND (CONSP OBJECT) (EQ (CAR OBJECT) (QUOTE QUOTE))) (SETF OBJECT (CADR OBJECT))) (INTERN-EQL-SPECIALIZER OBJECT))) ((AND (CONSP SPECIALIZER) (EQ (CAR SPECIALIZER) (QUOTE JAVA:JCLASS))) (LET ((JCLASS (EVAL SPECIALIZER))) (JAVA:ENSURE-JAVA-CLASS JCLASS))) (T (ERROR "Unknown specializer: ~S" SPECIALIZER))))
     [java] ; (DEFUN PARSE-DEFMETHOD (ARGS) (LET ((FUNCTION-NAME (CAR ARGS)) (QUALIFIERS NIL) (SPECIALIZED-LAMBDA-LIST NIL) (BODY NIL) (PARSE-STATE :QUALIFIERS)) (DOLIST (ARG (CDR ARGS)) (ECASE PARSE-STATE (:QUALIFIERS (IF (AND (ATOM ARG) (NOT (NULL ARG))) (PUSH ARG QUALIFIERS) (PROGN (SETF SPECIALIZED-LAMBDA-LIST ARG) (SETF PARSE-STATE :BODY)))) (:BODY (PUSH ARG BODY)))) (SETF QUALIFIERS (NREVERSE QUALIFIERS) BODY (NREVERSE BODY)) (MULTIPLE-VALUE-BIND (REAL-BODY DECLARATIONS DOCUMENTATION) (PARSE-BODY BODY) (VALUES FUNCTION-NAME QUALIFIERS (EXTRACT-LAMBDA-LIST SPECIALIZED-LAMBDA-LIST) (EXTRACT-SPECIALIZER-NAMES SPECIALIZED-LAMBDA-LIST) DOCUMENTATION DECLARATIONS (LIST* (QUOTE BLOCK) (FDEFINITION-BLOCK-NAME FUNCTION-NAME) REAL-BODY)))))
     [java] ; (DEFUN REQUIRED-PORTION (GF ARGS) (LET ((NUMBER-REQUIRED (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF)))) (WHEN (< (LENGTH ARGS) NUMBER-REQUIRED) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Not enough arguments for generic function ~S." :FORMAT-ARGUMENTS (LIST (GENERIC-FUNCTION-NAME GF)))) (SUBSEQ ARGS 0 NUMBER-REQUIRED)))
     [java] ; (DEFUN EXTRACT-LAMBDA-LIST (SPECIALIZED-LAMBDA-LIST) (LET* ((PLIST (ANALYZE-LAMBDA-LIST SPECIALIZED-LAMBDA-LIST)) (REQUIREDS (GETF PLIST :REQUIRED-NAMES)) (RV (GETF PLIST :REST-VAR)) (KS (GETF PLIST :KEY-ARGS)) (KEYSP (GETF PLIST :KEYSP)) (AOK (GETF PLIST :ALLOW-OTHER-KEYS)) (OPTS (GETF PLIST :OPTIONAL-ARGS)) (AUXS (GETF PLIST :AUXILIARY-ARGS))) (SYSTEM::BACKQ-APPEND REQUIREDS (IF OPTS (SYSTEM::BACKQ-CONS (QUOTE &OPTIONAL) OPTS) NIL) (IF RV (SYSTEM::BACKQ-LIST (QUOTE &REST) RV) NIL) (IF (OR KS KEYSP AOK) (SYSTEM::BACKQ-CONS (QUOTE &KEY) KS) NIL) (IF AOK (QUOTE (&ALLOW-OTHER-KEYS)) NIL) (IF AUXS (SYSTEM::BACKQ-CONS (QUOTE &AUX) AUXS) NIL))))
     [java] ; (DEFUN EXTRACT-SPECIALIZER-NAMES (SPECIALIZED-LAMBDA-LIST) (LET ((PLIST (ANALYZE-LAMBDA-LIST SPECIALIZED-LAMBDA-LIST))) (GETF PLIST (QUOTE :SPECIALIZERS))))
     [java] ; (DEFUN GET-KEYWORD-FROM-ARG (ARG) (IF (LISTP ARG) (IF (LISTP (CAR ARG)) (CAAR ARG) (MAKE-KEYWORD (CAR ARG))) (MAKE-KEYWORD ARG)))
     [java] ; (DEFUN ANALYZE-LAMBDA-LIST (LAMBDA-LIST) (LET ((KEYS NIL) (KEY-ARGS NIL) (KEYSP NIL) (REQUIRED-NAMES NIL) (REQUIRED-ARGS NIL) (SPECIALIZERS NIL) (REST-VAR NIL) (OPTIONALS NIL) (AUXS NIL) (ALLOW-OTHER-KEYS NIL) (STATE :REQUIRED)) (DOLIST (ARG LAMBDA-LIST) (IF (MEMBER ARG LAMBDA-LIST-KEYWORDS) (ECASE ARG (&OPTIONAL (UNLESS (EQ STATE :REQUIRED) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A followed by &OPTIONAL not allowed ~
     [java]                                        in lambda list ~S" :FORMAT-ARGUMENTS (LIST STATE LAMBDA-LIST))) (SETQ STATE (QUOTE &OPTIONAL))) (&REST (UNLESS (OR (EQ STATE :REQUIRED) (EQ STATE (QUOTE &OPTIONAL))) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A followed by &REST not allowed ~
     [java]                                        in lambda list ~S" :FORMAT-ARGUMENTS (LIST STATE LAMBDA-LIST))) (SETQ STATE (QUOTE &REST))) (&KEY (UNLESS (OR (EQ STATE :REQUIRED) (EQ STATE (QUOTE &OPTIONAL)) (EQ STATE (QUOTE &REST))) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A followed by &KEY not allowed
     [java]                                        in lambda list ~S" :FORMAT-ARGUMENTS (LIST STATE LAMBDA-LIST))) (SETQ KEYSP T) (SETQ STATE (QUOTE &KEY))) (&ALLOW-OTHER-KEYS (UNLESS (EQ STATE (QUOTE &KEY)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "&ALLOW-OTHER-KEYS not allowed while
     [java]                                        parsing ~A in lambda list ~S" :FORMAT-ARGUMENTS (LIST STATE LAMBDA-LIST))) (SETQ ALLOW-OTHER-KEYS (QUOTE T))) (&AUX (SETQ STATE (QUOTE &AUX)))) (CASE STATE (:REQUIRED (PUSH-ON-END ARG REQUIRED-ARGS) (IF (LISTP ARG) (PROGN (PUSH-ON-END (CAR ARG) REQUIRED-NAMES) (PUSH-ON-END (CADR ARG) SPECIALIZERS)) (PROGN (PUSH-ON-END ARG REQUIRED-NAMES) (PUSH-ON-END (QUOTE T) SPECIALIZERS)))) (&OPTIONAL (PUSH-ON-END ARG OPTIONALS)) (&REST (SETQ REST-VAR ARG)) (&KEY (PUSH-ON-END (GET-KEYWORD-FROM-ARG ARG) KEYS) (PUSH-ON-END ARG KEY-ARGS)) (&AUX (PUSH-ON-END ARG AUXS))))) (LIST :REQUIRED-NAMES REQUIRED-NAMES :REQUIRED-ARGS REQUIRED-ARGS :SPECIALIZERS SPECIALIZERS :REST-VAR REST-VAR :KEYWORDS KEYS :KEY-ARGS KEY-ARGS :KEYSP KEYSP :AUXILIARY-ARGS AUXS :OPTIONAL-ARGS OPTIONALS :ALLOW-OTHER-KEYS ALLOW-OTHER-KEYS)))
     [java] ; (DEFUN CHECK-METHOD-LAMBDA-LIST (NAME METHOD-LAMBDA-LIST GF-LAMBDA-LIST) (LET* ((GF-RESTP (NOT (NULL (MEMQ (QUOTE &REST) GF-LAMBDA-LIST)))) (GF-PLIST (ANALYZE-LAMBDA-LIST GF-LAMBDA-LIST)) (GF-KEYSP (GETF GF-PLIST :KEYSP)) (GF-KEYWORDS (GETF GF-PLIST :KEYWORDS)) (METHOD-PLIST (ANALYZE-LAMBDA-LIST METHOD-LAMBDA-LIST)) (METHOD-RESTP (NOT (NULL (MEMQ (QUOTE &REST) METHOD-LAMBDA-LIST)))) (METHOD-KEYSP (GETF METHOD-PLIST :KEYSP)) (METHOD-KEYWORDS (GETF METHOD-PLIST :KEYWORDS)) (METHOD-ALLOW-OTHER-KEYS-P (GETF METHOD-PLIST :ALLOW-OTHER-KEYS))) (UNLESS (= (LENGTH (GETF GF-PLIST :REQUIRED-ARGS)) (LENGTH (GETF METHOD-PLIST :REQUIRED-ARGS))) (ERROR "The method-lambda-list ~S ~
     [java]               has the wrong number of required arguments ~
     [java]               for the generic function ~S." METHOD-LAMBDA-LIST NAME)) (UNLESS (= (LENGTH (GETF GF-PLIST :OPTIONAL-ARGS)) (LENGTH (GETF METHOD-PLIST :OPTIONAL-ARGS))) (ERROR "The method-lambda-list ~S ~
     [java]               has the wrong number of optional arguments ~
     [java]               for the generic function ~S." METHOD-LAMBDA-LIST NAME)) (UNLESS (EQ (OR GF-RESTP GF-KEYSP) (OR METHOD-RESTP METHOD-KEYSP)) (ERROR "The method-lambda-list ~S ~
     [java]               and the generic function ~S ~
     [java]               differ in whether they accept &REST or &KEY arguments." METHOD-LAMBDA-LIST NAME)) (WHEN (CONSP GF-KEYWORDS) (UNLESS (OR (AND METHOD-RESTP (NOT METHOD-KEYSP)) METHOD-ALLOW-OTHER-KEYS-P (EVERY (LAMBDA (K) (MEMQ K METHOD-KEYWORDS)) GF-KEYWORDS)) (ERROR "The method-lambda-list ~S does not accept ~
     [java]                 all of the keyword arguments defined for the ~
     [java]                 generic function." METHOD-LAMBDA-LIST NAME)))))
     [java] ; (DEFUN CHECK-ARGUMENT-PRECEDENCE-ORDER (LAMBDA-LIST ARGUMENT-PRECEDENCE-ORDER) (WHEN ARGUMENT-PRECEDENCE-ORDER (IF LAMBDA-LIST (ARGUMENT-PRECEDENCE-ORDER-INDICES ARGUMENT-PRECEDENCE-ORDER (GETF (ANALYZE-LAMBDA-LIST LAMBDA-LIST) :REQUIRED-ARGS)) (ERROR (QUOTE PROGRAM-ERROR) "argument precedence order specified without lambda list"))))
     [java] ; (DEFVAR *GF-INITIALIZE-INSTANCE* NIL "Cached value of the INITIALIZE-INSTANCE generic function.
     [java] Initialized with the true value near the end of the file.")
     [java] ; (DEFVAR *GF-ALLOCATE-INSTANCE* NIL "Cached value of the ALLOCATE-INSTANCE generic function.
     [java] Initialized with the true value near the end of the file.")
     [java] ; (DEFVAR *GF-SHARED-INITIALIZE* NIL "Cached value of the SHARED-INITIALIZE generic function.
     [java] Initialized with the true value near the end of the file.")
     [java] ; (DEFVAR *GF-REINITIALIZE-INSTANCE* NIL "Cached value of the REINITIALIZE-INSTANCE generic function.
     [java] Initialized with the true value near the end of the file.")
     [java] ; (DECLAIM (FTYPE (FUNCTION * METHOD) ENSURE-METHOD))
     [java] ; (DEFUN ENSURE-METHOD (NAME &REST ALL-KEYS) (LET ((METHOD-LAMBDA-LIST (GETF ALL-KEYS :LAMBDA-LIST)) (GF (FIND-GENERIC-FUNCTION NAME NIL))) (WHEN (OR (EQ GF *GF-INITIALIZE-INSTANCE*) (EQ GF *GF-ALLOCATE-INSTANCE*) (EQ GF *GF-SHARED-INITIALIZE*) (EQ GF *GF-REINITIALIZE-INSTANCE*)) (CLRHASH *MAKE-INSTANCE-INITARGS-CACHE*) (CLRHASH *REINITIALIZE-INSTANCE-INITARGS-CACHE*)) (IF GF (CHECK-METHOD-LAMBDA-LIST NAME METHOD-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (SETF GF (ENSURE-GENERIC-FUNCTION NAME :LAMBDA-LIST METHOD-LAMBDA-LIST))) (LET ((METHOD (IF (EQ (GENERIC-FUNCTION-METHOD-CLASS GF) +THE-STANDARD-METHOD-CLASS+) (APPLY (FUNCTION MAKE-INSTANCE-STANDARD-METHOD) GF ALL-KEYS) (APPLY (FUNCTION MAKE-INSTANCE) (GENERIC-FUNCTION-METHOD-CLASS GF) ALL-KEYS)))) (IF (AND (EQ (GENERIC-FUNCTION-METHOD-CLASS GF) +THE-STANDARD-METHOD-CLASS+) (STD-GENERIC-FUNCTION-P GF)) (PROGN (STD-ADD-METHOD GF METHOD) (MAP-DEPENDENTS GF (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GF DEP (QUOTE ADD-METHOD) METHOD))))) (ADD-METHOD GF METHOD)) METHOD)))
     [java] ; (DEFUN MAKE-INSTANCE-STANDARD-METHOD (GF &KEY LAMBDA-LIST QUALIFIERS SPECIALIZERS DOCUMENTATION FUNCTION FAST-FUNCTION) (DECLARE (IGNORE GF)) (LET ((METHOD (STD-ALLOCATE-INSTANCE +THE-STANDARD-METHOD-CLASS+)) (ANALYZED-ARGS (ANALYZE-LAMBDA-LIST LAMBDA-LIST))) (SETF (METHOD-LAMBDA-LIST METHOD) LAMBDA-LIST) (SETF (METHOD-QUALIFIERS METHOD) QUALIFIERS) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::SPECIALIZERS)) (CANONICALIZE-SPECIALIZERS SPECIALIZERS)) (SETF (METHOD-DOCUMENTATION METHOD) DOCUMENTATION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%GENERIC-FUNCTION)) NIL) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%FUNCTION)) FUNCTION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::FAST-FUNCTION)) FAST-FUNCTION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::KEYWORDS)) (GETF ANALYZED-ARGS :KEYWORDS)) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::OTHER-KEYWORDS-P)) (GETF ANALYZED-ARGS :ALLOW-OTHER-KEYS)) METHOD))
     [java] ; (DECLAIM (NOTINLINE ADD-DIRECT-METHOD))
     [java] ; (DEFUN ADD-DIRECT-METHOD (SPECIALIZER METHOD) (IF (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (PUSHNEW METHOD (STD-SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS))) (PUSHNEW METHOD (CLASS-DIRECT-METHODS SPECIALIZER))))
     [java] ; (DECLAIM (NOTINLINE REMOVE-DIRECT-METHOD))
     [java] ; (DEFUN REMOVE-DIRECT-METHOD (SPECIALIZER METHOD) (IF (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (SETF (STD-SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)) (REMOVE METHOD (STD-SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)))) (SETF (CLASS-DIRECT-METHODS SPECIALIZER) (REMOVE METHOD (CLASS-DIRECT-METHODS SPECIALIZER)))))
     [java] ; (DEFUN STD-ADD-METHOD (GF METHOD) (LET ((OLD-METHOD (%FIND-METHOD GF (STD-METHOD-QUALIFIERS METHOD) (METHOD-SPECIALIZERS METHOD) NIL))) (WHEN OLD-METHOD (IF (AND (STD-GENERIC-FUNCTION-P GF) (EQ (CLASS-OF OLD-METHOD) +THE-STANDARD-METHOD-CLASS+)) (STD-REMOVE-METHOD GF OLD-METHOD) (REMOVE-METHOD GF OLD-METHOD)))) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%GENERIC-FUNCTION)) GF) (PUSH METHOD (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHODS))) (DOLIST (SPECIALIZER (METHOD-SPECIALIZERS METHOD)) (ADD-DIRECT-METHOD SPECIALIZER METHOD)) (FINALIZE-STANDARD-GENERIC-FUNCTION GF) GF)
     [java] ; (DEFUN STD-REMOVE-METHOD (GF METHOD) (SETF (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHODS)) (REMOVE METHOD (GENERIC-FUNCTION-METHODS GF))) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%GENERIC-FUNCTION)) NIL) (DOLIST (SPECIALIZER (METHOD-SPECIALIZERS METHOD)) (REMOVE-DIRECT-METHOD SPECIALIZER METHOD)) (FINALIZE-STANDARD-GENERIC-FUNCTION GF) GF)
     [java] ; (DEFUN %FIND-METHOD (GF QUALIFIERS SPECIALIZERS &OPTIONAL (ERRORP T)) (UNLESS (= (LENGTH SPECIALIZERS) (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF))) (ERROR "The specializers argument has length ~S, but ~S has ~S required parameters." (LENGTH SPECIALIZERS) GF (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF)))) (LET* ((CANONICAL-SPECIALIZERS (CANONICALIZE-SPECIALIZERS SPECIALIZERS)) (METHOD (FIND-IF (FUNCTION (LAMBDA (METHOD) (AND (EQUAL QUALIFIERS (METHOD-QUALIFIERS METHOD)) (EQUAL CANONICAL-SPECIALIZERS (METHOD-SPECIALIZERS METHOD))))) (GENERIC-FUNCTION-METHODS GF)))) (IF (AND (NULL METHOD) ERRORP) (ERROR "No such method for ~S." (GENERIC-FUNCTION-NAME GF)) METHOD)))
     [java] ; (DEFUN FAST-CALLABLE-P (GF) (AND (EQ (METHOD-COMBINATION-NAME (GENERIC-FUNCTION-METHOD-COMBINATION GF)) (QUOTE STANDARD)) (NULL (INTERSECTION (GENERIC-FUNCTION-LAMBDA-LIST GF) (QUOTE (&REST &OPTIONAL &KEY &ALLOW-OTHER-KEYS &AUX))))))
     [java] ; (DEFUN STD-COMPUTE-DISCRIMINATING-FUNCTION (GF) (LET ((METHODS (STD-SLOT-VALUE GF (QUOTE SYSTEM::METHODS)))) (COND ((AND (= (LENGTH METHODS) 1) (EQ (TYPE-OF (CAR METHODS)) (QUOTE STANDARD-READER-METHOD)) (EQ (TYPE-OF (CAR (STD-METHOD-SPECIALIZERS (CAR METHODS)))) (QUOTE STANDARD-CLASS))) (LET* ((METHOD (FIRST METHODS)) (SLOT-DEFINITION (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%SLOT-DEFINITION))) (SLOT-NAME (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME))) (CLASS (CAR (STD-METHOD-SPECIALIZERS METHOD)))) (FUNCTION (LAMBDA (INSTANCE) (UNLESS (TYPEP INSTANCE CLASS) (NO-APPLICABLE-METHOD GF (LIST INSTANCE))) (STD-SLOT-VALUE INSTANCE SLOT-NAME))))) ((AND (= (LENGTH METHODS) 1) (EQ (TYPE-OF (CAR METHODS)) (QUOTE STANDARD-WRITER-METHOD)) (EQ (TYPE-OF (SECOND (STD-METHOD-SPECIALIZERS (CAR METHODS)))) (QUOTE STANDARD-CLASS))) (LET* ((METHOD (FIRST METHODS)) (SLOT-DEFINITION (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%SLOT-DEFINITION))) (SLOT-NAME (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME))) (CLASS (CAR (STD-METHOD-SPECIALIZERS METHOD)))) (FUNCTION (LAMBDA (NEW-VALUE INSTANCE) (UNLESS (TYPEP INSTANCE CLASS) (NO-APPLICABLE-METHOD GF (LIST NEW-VALUE INSTANCE))) (SETF (STD-SLOT-VALUE INSTANCE SLOT-NAME) NEW-VALUE))))) (T (LET* ((NUMBER-REQUIRED (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF))) (LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (EXACT (NULL (INTERSECTION LAMBDA-LIST (QUOTE (&REST &OPTIONAL &KEY &ALLOW-OTHER-KEYS))))) (NO-AUX (NULL (SOME (LAMBDA (METHOD) (FIND (QUOTE &AUX) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::LAMBDA-LIST)))) METHODS)))) (IF (AND EXACT NO-AUX) (COND ((= NUMBER-REQUIRED 1) (COND ((AND (EQ (METHOD-COMBINATION-NAME (STD-SLOT-VALUE GF (QUOTE SYSTEM::%METHOD-COMBINATION))) (QUOTE STANDARD)) (= (LENGTH METHODS) 1) (STD-METHOD-FAST-FUNCTION (%CAR METHODS))) (LET* ((METHOD (%CAR METHODS)) (SPECIALIZER (CAR (STD-METHOD-SPECIALIZERS METHOD))) (FUNCTION (STD-METHOD-FAST-FUNCTION METHOD))) (IF (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (LET ((SPECIALIZER-OBJECT (EQL-SPECIALIZER-OBJECT SPECIALIZER))) (FUNCTION (LAMBDA (ARG) (DECLARE (OPTIMIZE SPEED)) (IF (EQL ARG SPECIALIZER-OBJECT) (FUNCALL FUNCTION ARG) (NO-APPLICABLE-METHOD GF (LIST ARG)))))) (FUNCTION (LAMBDA (ARG) (DECLARE (OPTIMIZE SPEED)) (UNLESS (SIMPLE-TYPEP ARG SPECIALIZER) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM ARG :EXPECTED-TYPE SPECIALIZER)) (FUNCALL FUNCTION ARG)))))) (T (FUNCTION (LAMBDA (ARG) (DECLARE (OPTIMIZE SPEED)) (LET* ((ARGS (LIST ARG)) (EMFUN (GET-CACHED-EMF GF ARGS))) (IF EMFUN (FUNCALL EMFUN ARGS) (SLOW-METHOD-LOOKUP GF ARGS)))))))) ((= NUMBER-REQUIRED 2) (FUNCTION (LAMBDA (ARG1 ARG2) (DECLARE (OPTIMIZE SPEED)) (LET* ((ARGS (LIST ARG1 ARG2)) (EMFUN (GET-CACHED-EMF GF ARGS))) (IF EMFUN (FUNCALL EMFUN ARGS) (SLOW-METHOD-LOOKUP GF ARGS)))))) ((= NUMBER-REQUIRED 3) (FUNCTION (LAMBDA (ARG1 ARG2 ARG3) (DECLARE (OPTIMIZE SPEED)) (LET* ((ARGS (LIST ARG1 ARG2 ARG3)) (EMFUN (GET-CACHED-EMF GF ARGS))) (IF EMFUN (FUNCALL EMFUN ARGS) (SLOW-METHOD-LOOKUP GF ARGS)))))) (T (FUNCTION (LAMBDA (&REST ARGS) (DECLARE (OPTIMIZE SPEED)) (LET ((LEN (LENGTH ARGS))) (UNLESS (= LEN NUMBER-REQUIRED) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Not enough arguments for generic function ~S." :FORMAT-ARGUMENTS (LIST (GENERIC-FUNCTION-NAME GF))))) (LET ((EMFUN (GET-CACHED-EMF GF ARGS))) (IF EMFUN (FUNCALL EMFUN ARGS) (SLOW-METHOD-LOOKUP GF ARGS))))))) (FUNCTION (LAMBDA (&REST ARGS) (DECLARE (OPTIMIZE SPEED)) (LET ((LEN (LENGTH ARGS))) (UNLESS (>= LEN NUMBER-REQUIRED) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Not enough arguments for generic function ~S." :FORMAT-ARGUMENTS (LIST (GENERIC-FUNCTION-NAME GF))))) (LET ((EMFUN (GET-CACHED-EMF GF ARGS))) (IF EMFUN (FUNCALL EMFUN ARGS) (SLOW-METHOD-LOOKUP GF ARGS)))))))))))
     [java] ; (DEFUN SORT-METHODS (METHODS GF REQUIRED-CLASSES) (IF (OR (NULL METHODS) (NULL (%CDR METHODS))) METHODS (SORT METHODS (IF (STD-GENERIC-FUNCTION-P GF) (LET ((METHOD-INDICES (ARGUMENT-PRECEDENCE-ORDER-INDICES (GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER GF) (GETF (ANALYZE-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (QUOTE :REQUIRED-ARGS))))) (FUNCTION (LAMBDA (M1 M2) (STD-METHOD-MORE-SPECIFIC-P M1 M2 REQUIRED-CLASSES METHOD-INDICES)))) (FUNCTION (LAMBDA (M1 M2) (METHOD-MORE-SPECIFIC-P GF M1 M2 REQUIRED-CLASSES)))))))
     [java] ; (DEFUN METHOD-APPLICABLE-P (METHOD ARGS) (DO* ((SPECIALIZERS (METHOD-SPECIALIZERS METHOD) (CDR SPECIALIZERS)) (ARGS ARGS (CDR ARGS))) ((NULL SPECIALIZERS) T) (LET ((SPECIALIZER (CAR SPECIALIZERS))) (IF (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (UNLESS (EQL (CAR ARGS) (EQL-SPECIALIZER-OBJECT SPECIALIZER)) (RETURN NIL)) (UNLESS (SUBCLASSP (CLASS-OF (CAR ARGS)) SPECIALIZER) (RETURN NIL))))))
     [java] ; (DEFUN STD-COMPUTE-APPLICABLE-METHODS (GF ARGS) (LET ((REQUIRED-CLASSES (MAPCAR (FUNCTION CLASS-OF) (REQUIRED-PORTION GF ARGS))) (METHODS (QUOTE NIL))) (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GF)) (WHEN (METHOD-APPLICABLE-P METHOD ARGS) (PUSH METHOD METHODS))) (SORT-METHODS METHODS GF REQUIRED-CLASSES)))
     [java] ; (DECLAIM (NOTINLINE COMPUTE-APPLICABLE-METHODS))
     [java] ; (DEFUN COMPUTE-APPLICABLE-METHODS (GF ARGS) (STD-COMPUTE-APPLICABLE-METHODS GF ARGS))
     [java] ; (DEFUN METHOD-APPLICABLE-USING-CLASSES-P (METHOD CLASSES) (DO* ((SPECIALIZERS (METHOD-SPECIALIZERS METHOD) (CDR SPECIALIZERS)) (CLASSES CLASSES (CDR CLASSES)) (KNOWNP T)) ((NULL SPECIALIZERS) (IF KNOWNP (VALUES T T) (VALUES NIL NIL))) (LET ((SPECIALIZER (CAR SPECIALIZERS))) (IF (TYPEP SPECIALIZER (QUOTE EQL-SPECIALIZER)) (IF (EQL (CLASS-OF (EQL-SPECIALIZER-OBJECT SPECIALIZER)) (CAR CLASSES)) (SETF KNOWNP NIL) (RETURN (VALUES NIL T))) (UNLESS (SUBCLASSP (CAR CLASSES) SPECIALIZER) (RETURN (VALUES NIL T)))))))
     [java] ; (DEFUN CHECK-APPLICABLE-METHOD-KEYWORD-ARGS (GF ARGS KEYWORD-ARGS APPLICABLE-KEYWORDS) (WHEN (ODDP (LENGTH KEYWORD-ARGS)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of keyword arguments in call to ~S ~
     [java] with arguments list ~S" :FORMAT-ARGUMENTS (LIST GF ARGS))) (UNLESS (GETF KEYWORD-ARGS :ALLOW-OTHER-KEYS) (LOOP FOR KEY IN KEYWORD-ARGS BY (FUNCTION CDDR) UNLESS (OR (MEMBER KEY APPLICABLE-KEYWORDS) (EQ KEY :ALLOW-OTHER-KEYS)) DO (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Invalid keyword argument ~S in call ~
     [java] to ~S with argument list ~S." :FORMAT-ARGUMENTS (LIST KEY GF ARGS)))))
     [java] ; (DEFUN COMPUTE-APPLICABLE-KEYWORDS (GF APPLICABLE-METHODS) (LET ((APPLICABLE-KEYWORDS (GETF (ANALYZE-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) :KEYWORDS))) (LOOP FOR METHOD IN APPLICABLE-METHODS DO (MULTIPLE-VALUE-BIND (KEYWORDS ALLOW-OTHER-KEYS) (FUNCTION-KEYWORDS METHOD) (WHEN ALLOW-OTHER-KEYS (SETF APPLICABLE-KEYWORDS :ANY) (RETURN)) (SETF APPLICABLE-KEYWORDS (UNION APPLICABLE-KEYWORDS KEYWORDS)))) APPLICABLE-KEYWORDS))
     [java] ; (DEFUN WRAP-EMFUN-FOR-KEYWORD-ARGS-CHECK (GF EMFUN NON-KEYWORD-ARGS APPLICABLE-KEYWORDS) (FUNCTION (LAMBDA (ARGS) (CHECK-APPLICABLE-METHOD-KEYWORD-ARGS GF ARGS (NTHCDR NON-KEYWORD-ARGS ARGS) APPLICABLE-KEYWORDS) (FUNCALL EMFUN ARGS))))
     [java] ; (DEFUN SLOW-METHOD-LOOKUP (GF ARGS) (LET ((APPLICABLE-METHODS (IF (STD-GENERIC-FUNCTION-P GF) (STD-COMPUTE-APPLICABLE-METHODS GF ARGS) (OR (COMPUTE-APPLICABLE-METHODS-USING-CLASSES GF (MAPCAR (FUNCTION CLASS-OF) ARGS)) (COMPUTE-APPLICABLE-METHODS GF ARGS))))) (IF APPLICABLE-METHODS (LET* ((EMFUN (FUNCALL (IF (STD-GENERIC-FUNCTION-P GF) (FUNCTION STD-COMPUTE-EFFECTIVE-METHOD) (FUNCTION COMPUTE-EFFECTIVE-METHOD)) GF (GENERIC-FUNCTION-METHOD-COMBINATION GF) APPLICABLE-METHODS)) (NON-KEYWORD-ARGS (+ (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF)) (LENGTH (GENERIC-FUNCTION-OPTIONAL-ARGUMENTS GF)))) (GF-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (CHECKS-REQUIRED (AND (MEMBER (QUOTE &KEY) GF-LAMBDA-LIST) (NOT (MEMBER (QUOTE &ALLOW-OTHER-KEYS) GF-LAMBDA-LIST)))) (APPLICABLE-KEYWORDS (WHEN CHECKS-REQUIRED (COMPUTE-APPLICABLE-KEYWORDS GF APPLICABLE-METHODS)))) (WHEN (AND CHECKS-REQUIRED (NOT (EQ APPLICABLE-KEYWORDS :ANY))) (SETF EMFUN (WRAP-EMFUN-FOR-KEYWORD-ARGS-CHECK GF EMFUN NON-KEYWORD-ARGS APPLICABLE-KEYWORDS))) (CACHE-EMF GF ARGS EMFUN) (FUNCALL EMFUN ARGS)) (APPLY (FUNCTION NO-APPLICABLE-METHOD) GF ARGS))))
     [java] ; (DEFUN SUB-SPECIALIZER-P (C1 C2 C-ARG) (FIND C2 (CDR (MEMQ C1 (%CLASS-PRECEDENCE-LIST C-ARG)))))
     [java] ; (DEFUN STD-METHOD-MORE-SPECIFIC-P (METHOD1 METHOD2 REQUIRED-CLASSES ARGUMENT-PRECEDENCE-ORDER) (IF ARGUMENT-PRECEDENCE-ORDER (LET ((SPECIALIZERS-1 (STD-METHOD-SPECIALIZERS METHOD1)) (SPECIALIZERS-2 (STD-METHOD-SPECIALIZERS METHOD2))) (DOLIST (INDEX ARGUMENT-PRECEDENCE-ORDER) (LET ((SPEC1 (NTH INDEX SPECIALIZERS-1)) (SPEC2 (NTH INDEX SPECIALIZERS-2))) (UNLESS (EQ SPEC1 SPEC2) (COND ((TYPEP SPEC1 (QUOTE EQL-SPECIALIZER)) (RETURN T)) ((TYPEP SPEC2 (QUOTE EQL-SPECIALIZER)) (RETURN NIL)) (T (RETURN (SUB-SPECIALIZER-P SPEC1 SPEC2 (NTH INDEX REQUIRED-CLASSES))))))))) (DO ((SPECIALIZERS-1 (STD-METHOD-SPECIALIZERS METHOD1) (CDR SPECIALIZERS-1)) (SPECIALIZERS-2 (STD-METHOD-SPECIALIZERS METHOD2) (CDR SPECIALIZERS-2)) (CLASSES REQUIRED-CLASSES (CDR CLASSES))) ((NULL SPECIALIZERS-1) NIL) (LET ((SPEC1 (CAR SPECIALIZERS-1)) (SPEC2 (CAR SPECIALIZERS-2))) (UNLESS (EQ SPEC1 SPEC2) (COND ((TYPEP SPEC1 (QUOTE EQL-SPECIALIZER)) (RETURN T)) ((TYPEP SPEC2 (QUOTE EQL-SPECIALIZER)) (RETURN NIL)) (T (RETURN (SUB-SPECIALIZER-P SPEC1 SPEC2 (CAR CLASSES))))))))))
     [java] ; (DEFUN PRIMARY-METHOD-P (METHOD) (NULL (INTERSECTION (QUOTE (:BEFORE :AFTER :AROUND)) (METHOD-QUALIFIERS METHOD))))
     [java] ; (DEFUN BEFORE-METHOD-P (METHOD) (EQUAL (QUOTE (:BEFORE)) (METHOD-QUALIFIERS METHOD)))
     [java] ; (DEFUN AFTER-METHOD-P (METHOD) (EQUAL (QUOTE (:AFTER)) (METHOD-QUALIFIERS METHOD)))
     [java] ; (DEFUN AROUND-METHOD-P (METHOD) (EQUAL (QUOTE (:AROUND)) (METHOD-QUALIFIERS METHOD)))
     [java] ; (DEFUN PROCESS-NEXT-METHOD-LIST (NEXT-METHOD-LIST) (MAPCAR (FUNCTION (LAMBDA (NEXT-METHOD-FORM) (COND ((LISTP NEXT-METHOD-FORM) (ASSERT (EQ (FIRST NEXT-METHOD-FORM) (QUOTE MAKE-METHOD))) (LET* ((REST-SYM (GENSYM))) (MAKE-INSTANCE-STANDARD-METHOD NIL :LAMBDA-LIST (LIST (QUOTE &REST) REST-SYM) :FUNCTION (COMPUTE-METHOD-FUNCTION (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST (QUOTE &REST) REST-SYM) (SECOND NEXT-METHOD-FORM)))))) (T (ASSERT (TYPEP NEXT-METHOD-FORM (QUOTE METHOD))) NEXT-METHOD-FORM)))) NEXT-METHOD-LIST))
     [java] ; (DEFUN STD-COMPUTE-EFFECTIVE-METHOD (GF METHOD-COMBINATION METHODS) (ASSERT (TYPEP METHOD-COMBINATION (QUOTE METHOD-COMBINATION))) (LET* ((MC-NAME (METHOD-COMBINATION-NAME METHOD-COMBINATION)) (OPTIONS (SLOT-VALUE METHOD-COMBINATION (QUOTE OPTIONS))) (ORDER (CAR OPTIONS)) (PRIMARIES (QUOTE NIL)) (AROUNDS (QUOTE NIL)) AROUND EMF-FORM (LONG-METHOD-COMBINATION-P (TYPEP METHOD-COMBINATION (QUOTE LONG-METHOD-COMBINATION)))) (UNLESS LONG-METHOD-COMBINATION-P (DOLIST (M METHODS) (LET ((QUALIFIERS (METHOD-QUALIFIERS M))) (COND ((NULL QUALIFIERS) (IF (EQ MC-NAME (QUOTE STANDARD)) (PUSH M PRIMARIES) (ERROR "Method combination type mismatch: missing qualifier for method combination ~S." METHOD-COMBINATION))) ((CDR QUALIFIERS) (ERROR "Invalid method qualifiers.")) ((EQ (CAR QUALIFIERS) :AROUND) (PUSH M AROUNDS)) ((EQ (CAR QUALIFIERS) MC-NAME) (PUSH M PRIMARIES)) ((MEMQ (CAR QUALIFIERS) (QUOTE (:BEFORE :AFTER)))) (T (ERROR "Invalid method qualifiers.")))))) (UNLESS (EQ ORDER :MOST-SPECIFIC-LAST) (SETF PRIMARIES (NREVERSE PRIMARIES))) (SETF AROUNDS (NREVERSE AROUNDS)) (SETF AROUND (CAR AROUNDS)) (WHEN (AND (NULL PRIMARIES) (NOT LONG-METHOD-COMBINATION-P)) (ERROR "No primary methods for the generic function ~S." GF)) (COND (AROUND (LET ((NEXT-EMFUN (FUNCALL (IF (STD-GENERIC-FUNCTION-P GF) (FUNCTION STD-COMPUTE-EFFECTIVE-METHOD) (FUNCTION COMPUTE-EFFECTIVE-METHOD)) GF METHOD-COMBINATION (REMOVE AROUND METHODS)))) (SETF EMF-FORM (GENERATE-EMF-LAMBDA (METHOD-FUNCTION AROUND) NEXT-EMFUN)))) ((EQ MC-NAME (QUOTE STANDARD)) (LET* ((NEXT-EMFUN (COMPUTE-PRIMARY-EMFUN (CDR PRIMARIES))) (BEFORES (REMOVE-IF-NOT (FUNCTION BEFORE-METHOD-P) METHODS)) (REVERSE-AFTERS (REVERSE (REMOVE-IF-NOT (FUNCTION AFTER-METHOD-P) METHODS)))) (SETF EMF-FORM (COND ((AND (NULL BEFORES) (NULL REVERSE-AFTERS)) (LET ((FAST-FUNCTION (STD-METHOD-FAST-FUNCTION (CAR PRIMARIES)))) (IF FAST-FUNCTION (ECASE (LENGTH (GENERIC-FUNCTION-REQUIRED-ARGUMENTS GF)) (1 (FUNCTION (LAMBDA (ARGS) (DECLARE (OPTIMIZE SPEED)) (FUNCALL FAST-FUNCTION (CAR ARGS))))) (2 (FUNCTION (LAMBDA (ARGS) (DECLARE (OPTIMIZE SPEED)) (FUNCALL FAST-FUNCTION (CAR ARGS) (CADR ARGS)))))) (GENERATE-EMF-LAMBDA (STD-METHOD-FUNCTION (CAR PRIMARIES)) NEXT-EMFUN)))) (T (LET ((METHOD-FUNCTION (METHOD-FUNCTION (CAR PRIMARIES)))) (FUNCTION (LAMBDA (ARGS) (DECLARE (OPTIMIZE SPEED)) (DOLIST (BEFORE BEFORES) (FUNCALL (METHOD-FUNCTION BEFORE) ARGS NIL)) (MULTIPLE-VALUE-PROG1 (FUNCALL METHOD-FUNCTION ARGS NEXT-EMFUN) (DOLIST (AFTER REVERSE-AFTERS) (FUNCALL (METHOD-FUNCTION AFTER) ARGS NIL))))))))))) (LONG-METHOD-COMBINATION-P (LET ((FUNCTION (LONG-METHOD-COMBINATION-FUNCTION METHOD-COMBINATION)) (ARGUMENTS (SLOT-VALUE METHOD-COMBINATION (QUOTE OPTIONS)))) (ASSERT FUNCTION) (SETF EMF-FORM (IF ARGUMENTS (APPLY FUNCTION GF METHODS ARGUMENTS) (FUNCALL FUNCTION GF METHODS))))) (T (UNLESS (TYPEP METHOD-COMBINATION (QUOTE SHORT-METHOD-COMBINATION)) (ERROR "Unsupported method combination type ~A." MC-NAME)) (LET ((OPERATOR (SHORT-METHOD-COMBINATION-OPERATOR METHOD-COMBINATION)) (IOA (SHORT-METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT METHOD-COMBINATION))) (SETF EMF-FORM (IF (AND IOA (NULL (CDR PRIMARIES))) (GENERATE-EMF-LAMBDA (METHOD-FUNCTION (CAR PRIMARIES)) NIL) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS)) (SYSTEM::BACKQ-CONS OPERATOR (MAPCAR (LAMBDA (PRIMARY) (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (METHOD-FUNCTION PRIMARY) (QUOTE (ARGS NIL)))) PRIMARIES)))))))) (ASSERT (NOT (NULL EMF-FORM))) (OR (COERCE-TO-FUNCTION EMF-FORM))))
     [java] ; (DEFUN GENERATE-EMF-LAMBDA (METHOD-FUNCTION NEXT-EMFUN) (FUNCTION (LAMBDA (ARGS) (DECLARE (OPTIMIZE SPEED)) (FUNCALL METHOD-FUNCTION ARGS NEXT-EMFUN))))
     [java] ; (DEFUN COMPUTE-PRIMARY-EMFUN (METHODS) (IF (NULL METHODS) NIL (LET ((NEXT-EMFUN (COMPUTE-PRIMARY-EMFUN (CDR METHODS)))) (FUNCTION (LAMBDA (ARGS) (FUNCALL (STD-METHOD-FUNCTION (CAR METHODS)) ARGS NEXT-EMFUN))))))
     [java] ; (DEFVAR *CALL-NEXT-METHOD-P*)
     [java] ; (DEFVAR *NEXT-METHOD-P-P*)
     [java] ; (DEFUN WALK-FORM (FORM) (COND ((ATOM FORM) (COND ((EQ FORM (QUOTE CALL-NEXT-METHOD)) (SETF *CALL-NEXT-METHOD-P* T)) ((EQ FORM (QUOTE NEXT-METHOD-P)) (SETF *NEXT-METHOD-P-P* T)))) (T (WALK-FORM (%CAR FORM)) (WALK-FORM (%CDR FORM)))))
     [java] ; (DEFUN COMPUTE-METHOD-FUNCTION (LAMBDA-EXPRESSION) (LET ((LAMBDA-LIST (ALLOW-OTHER-KEYS (CADR LAMBDA-EXPRESSION))) (BODY (CDDR LAMBDA-EXPRESSION)) (*CALL-NEXT-METHOD-P* NIL) (*NEXT-METHOD-P-P* NIL)) (MULTIPLE-VALUE-BIND (BODY DECLARATIONS) (PARSE-BODY BODY) (LET ((IGNORABLE-VARS (QUOTE NIL))) (DOLIST (VAR LAMBDA-LIST) (IF (MEMQ VAR LAMBDA-LIST-KEYWORDS) (RETURN) (PUSH VAR IGNORABLE-VARS))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-CONS (QUOTE IGNORABLE) IGNORABLE-VARS)) DECLARATIONS)) (WALK-FORM BODY) (COND ((OR *CALL-NEXT-METHOD-P* *NEXT-METHOD-P-P*) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (SYSTEM::BACKQ-LIST (QUOTE FLET) (QUOTE ((CALL-NEXT-METHOD (&REST CNM-ARGS) (IF (NULL NEXT-EMFUN) (ERROR "No next method for generic function.") (FUNCALL NEXT-EMFUN (OR CNM-ARGS ARGS)))) (NEXT-METHOD-P NIL (NOT (NULL NEXT-EMFUN))))) (QUOTE (DECLARE (IGNORABLE (FUNCTION CALL-NEXT-METHOD) (FUNCTION NEXT-METHOD-P)))) (SYSTEM::BACKQ-LIST* (QUOTE APPLY) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLARATIONS BODY))) (QUOTE (ARGS)))))) ((NULL (INTERSECTION LAMBDA-LIST (QUOTE (&REST &OPTIONAL &KEY &ALLOW-OTHER-KEYS &AUX)))) (CASE (LENGTH LAMBDA-LIST) (1 (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (QUOTE (DECLARE (IGNORE NEXT-EMFUN))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (%CAR LAMBDA-LIST) (QUOTE ((%CAR ARGS))))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) (%CAR LAMBDA-LIST))) (SYSTEM::BACKQ-APPEND DECLARATIONS BODY)))) (2 (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (QUOTE (DECLARE (IGNORE NEXT-EMFUN))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (%CAR LAMBDA-LIST) (QUOTE ((%CAR ARGS)))) (SYSTEM::BACKQ-CONS (%CADR LAMBDA-LIST) (QUOTE ((%CADR ARGS))))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) (%CAR LAMBDA-LIST) (%CADR LAMBDA-LIST))) (SYSTEM::BACKQ-APPEND DECLARATIONS BODY)))) (3 (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (QUOTE (DECLARE (IGNORE NEXT-EMFUN))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (%CAR LAMBDA-LIST) (QUOTE ((%CAR ARGS)))) (SYSTEM::BACKQ-CONS (%CADR LAMBDA-LIST) (QUOTE ((%CADR ARGS)))) (SYSTEM::BACKQ-CONS (%CADDR LAMBDA-LIST) (QUOTE ((%CADDR ARGS))))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) (%CAR LAMBDA-LIST) (%CADR LAMBDA-LIST) (%CADDR LAMBDA-LIST))) (SYSTEM::BACKQ-APPEND DECLARATIONS BODY)))) (T (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (QUOTE (DECLARE (IGNORE NEXT-EMFUN))) (SYSTEM::BACKQ-LIST* (QUOTE APPLY) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLARATIONS BODY))) (QUOTE (ARGS))))))) (T (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (ARGS NEXT-EMFUN)) (QUOTE (DECLARE (IGNORE NEXT-EMFUN))) (SYSTEM::BACKQ-LIST* (QUOTE APPLY) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLARATIONS BODY))) (QUOTE (ARGS)))))))))
     [java] ; (DEFUN COMPUTE-METHOD-FAST-FUNCTION (LAMBDA-EXPRESSION) (LET ((LAMBDA-LIST (ALLOW-OTHER-KEYS (CADR LAMBDA-EXPRESSION)))) (WHEN (INTERSECTION LAMBDA-LIST (QUOTE (&REST &OPTIONAL &KEY &ALLOW-OTHER-KEYS &AUX))) (RETURN-FROM COMPUTE-METHOD-FAST-FUNCTION NIL)) (LET ((BODY (CDDR LAMBDA-EXPRESSION)) (*CALL-NEXT-METHOD-P* NIL) (*NEXT-METHOD-P-P* NIL)) (MULTIPLE-VALUE-BIND (BODY DECLARATIONS) (PARSE-BODY BODY) (WALK-FORM BODY) (WHEN (OR *CALL-NEXT-METHOD-P* *NEXT-METHOD-P-P*) (RETURN-FROM COMPUTE-METHOD-FAST-FUNCTION NIL)) (LET ((DECLS (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-CONS (QUOTE IGNORABLE) LAMBDA-LIST)))) (SETF LAMBDA-EXPRESSION (LIST* (CAR LAMBDA-EXPRESSION) (CADR LAMBDA-EXPRESSION) DECLS (CDDR LAMBDA-EXPRESSION)))) (CASE (LENGTH LAMBDA-LIST) (1 LAMBDA-EXPRESSION) (2 LAMBDA-EXPRESSION) (T NIL))))))
     [java] ; (DECLAIM (NOTINLINE MAKE-METHOD-LAMBDA))
     [java] ; (DEFUN MAKE-METHOD-LAMBDA (GENERIC-FUNCTION METHOD LAMBDA-EXPRESSION ENV) (DECLARE (IGNORE GENERIC-FUNCTION METHOD ENV)) (VALUES (COMPUTE-METHOD-FUNCTION LAMBDA-EXPRESSION) NIL))
     [java] ; (DEFUN ALLOW-OTHER-KEYS (LAMBDA-LIST) (IF (AND (MEMBER (QUOTE &KEY) LAMBDA-LIST) (NOT (MEMBER (QUOTE &ALLOW-OTHER-KEYS) LAMBDA-LIST))) (LET* ((KEY-END (OR (POSITION (QUOTE &AUX) LAMBDA-LIST) (LENGTH LAMBDA-LIST))) (AUX-PART (SUBSEQ LAMBDA-LIST KEY-END))) (SYSTEM::BACKQ-APPEND (SUBSEQ LAMBDA-LIST 0 KEY-END) (SYSTEM::BACKQ-CONS (QUOTE &ALLOW-OTHER-KEYS) AUX-PART))) LAMBDA-LIST))
     [java] ; (DEFMACRO DEFMETHOD (&REST ARGS &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (FUNCTION-NAME QUALIFIERS LAMBDA-LIST SPECIALIZERS DOCUMENTATION DECLARATIONS BODY) (PARSE-DEFMETHOD ARGS) (LET* ((SPECIALIZERS-FORM (QUOTE NIL)) (LAMBDA-EXPRESSION (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) LAMBDA-LIST (SYSTEM::BACKQ-APPEND DECLARATIONS (SYSTEM::BACKQ-LIST BODY)))) (GF (OR (FIND-GENERIC-FUNCTION FUNCTION-NAME NIL) (CLASS-PROTOTYPE (FIND-CLASS (QUOTE STANDARD-GENERIC-FUNCTION))))) (METHOD-FUNCTION (MAKE-METHOD-LAMBDA GF (CLASS-PROTOTYPE (GENERIC-FUNCTION-METHOD-CLASS GF)) LAMBDA-EXPRESSION ENV)) (FAST-FUNCTION (COMPUTE-METHOD-FAST-FUNCTION LAMBDA-EXPRESSION))) (DOLIST (SPECIALIZER SPECIALIZERS) (COND ((AND (CONSP SPECIALIZER) (EQ (CAR SPECIALIZER) (QUOTE EQL))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE LIST) (QUOTE (QUOTE EQL)) (CADR SPECIALIZER)) SPECIALIZERS-FORM)) (T (PUSH (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SPECIALIZER) SPECIALIZERS-FORM)))) (SETF SPECIALIZERS-FORM (SYSTEM::BACKQ-CONS (QUOTE LIST) (NREVERSE SPECIALIZERS-FORM))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST (QUOTE :METHOD) FUNCTION-NAME QUALIFIERS SPECIALIZERS))) (SYSTEM::BACKQ-LIST* (QUOTE ENSURE-METHOD) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME) (QUOTE :LAMBDA-LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) (QUOTE :QUALIFIERS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) QUALIFIERS) (QUOTE :SPECIALIZERS) (SYSTEM::BACKQ-LIST (QUOTE CANONICALIZE-SPECIALIZERS) SPECIALIZERS-FORM) (SYSTEM::BACKQ-APPEND (IF DOCUMENTATION (SYSTEM::BACKQ-LIST (QUOTE :DOCUMENTATION) DOCUMENTATION)) (SYSTEM::BACKQ-LIST* (QUOTE :FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) METHOD-FUNCTION) (IF FAST-FUNCTION (SYSTEM::BACKQ-LIST (QUOTE :FAST-FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) FAST-FUNCTION))))))))))
     [java] ; (DEFUN MAKE-INSTANCE-STANDARD-ACCESSOR-METHOD (METHOD-CLASS &KEY LAMBDA-LIST QUALIFIERS SPECIALIZERS DOCUMENTATION FUNCTION FAST-FUNCTION SLOT-DEFINITION) (LET ((METHOD (STD-ALLOCATE-INSTANCE METHOD-CLASS))) (SETF (METHOD-LAMBDA-LIST METHOD) LAMBDA-LIST) (SETF (METHOD-QUALIFIERS METHOD) QUALIFIERS) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::SPECIALIZERS)) (CANONICALIZE-SPECIALIZERS SPECIALIZERS)) (SETF (METHOD-DOCUMENTATION METHOD) DOCUMENTATION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%GENERIC-FUNCTION)) NIL) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%FUNCTION)) FUNCTION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::FAST-FUNCTION)) FAST-FUNCTION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::%SLOT-DEFINITION)) SLOT-DEFINITION) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::KEYWORDS)) NIL) (SETF (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::OTHER-KEYWORDS-P)) NIL) METHOD))
     [java] ; (DEFUN ADD-READER-METHOD (CLASS FUNCTION-NAME SLOT-DEFINITION) (LET* ((SLOT-NAME (SLOT-DEFINITION-NAME SLOT-DEFINITION)) (LAMBDA-EXPRESSION (IF (STD-CLASS-P CLASS) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (OBJECT)) (SYSTEM::BACKQ-LIST (QUOTE STD-SLOT-VALUE) (QUOTE OBJECT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT-NAME))) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (OBJECT)) (SYSTEM::BACKQ-LIST (QUOTE SLOT-VALUE) (QUOTE OBJECT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT-NAME))))) (METHOD-FUNCTION (COMPUTE-METHOD-FUNCTION LAMBDA-EXPRESSION)) (FAST-FUNCTION (COMPUTE-METHOD-FAST-FUNCTION LAMBDA-EXPRESSION)) (METHOD-LAMBDA-LIST (QUOTE (OBJECT))) (GF (FIND-GENERIC-FUNCTION FUNCTION-NAME NIL)) (INITARGS (SYSTEM::BACKQ-LIST (QUOTE :LAMBDA-LIST) METHOD-LAMBDA-LIST (QUOTE :QUALIFIERS) NIL (QUOTE :SPECIALIZERS) (SYSTEM::BACKQ-LIST CLASS) (QUOTE :FUNCTION) (IF (AUTOLOADP (QUOTE COMPILE)) METHOD-FUNCTION (AUTOCOMPILE METHOD-FUNCTION)) (QUOTE :FAST-FUNCTION) (IF (AUTOLOADP (QUOTE COMPILE)) FAST-FUNCTION (AUTOCOMPILE FAST-FUNCTION)) (QUOTE :SLOT-DEFINITION) SLOT-DEFINITION)) (METHOD-CLASS (IF (STD-CLASS-P CLASS) +THE-STANDARD-READER-METHOD-CLASS+ (APPLY (FUNCTION READER-METHOD-CLASS) CLASS SLOT-DEFINITION INITARGS)))) (ASSERT (SUBTYPEP METHOD-CLASS +THE-STANDARD-READER-METHOD-CLASS+)) (IF GF (CHECK-METHOD-LAMBDA-LIST FUNCTION-NAME METHOD-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (SETF GF (ENSURE-GENERIC-FUNCTION FUNCTION-NAME :LAMBDA-LIST METHOD-LAMBDA-LIST))) (LET ((METHOD (IF (EQ METHOD-CLASS +THE-STANDARD-READER-METHOD-CLASS+) (APPLY (FUNCTION MAKE-INSTANCE-STANDARD-ACCESSOR-METHOD) METHOD-CLASS INITARGS) (APPLY (FUNCTION MAKE-INSTANCE) METHOD-CLASS :GENERIC-FUNCTION NIL INITARGS)))) (IF (STD-GENERIC-FUNCTION-P GF) (PROGN (STD-ADD-METHOD GF METHOD) (MAP-DEPENDENTS GF (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GF DEP (QUOTE ADD-METHOD) METHOD))))) (ADD-METHOD GF METHOD)) METHOD)))
     [java] ; (DEFUN ADD-WRITER-METHOD (CLASS FUNCTION-NAME SLOT-DEFINITION) (LET* ((SLOT-NAME (SLOT-DEFINITION-NAME SLOT-DEFINITION)) (LAMBDA-EXPRESSION (IF (STD-CLASS-P CLASS) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (NEW-VALUE OBJECT)) (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE STD-SLOT-VALUE) (QUOTE OBJECT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT-NAME)) (QUOTE (NEW-VALUE)))) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (NEW-VALUE OBJECT)) (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE SLOT-VALUE) (QUOTE OBJECT) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT-NAME)) (QUOTE (NEW-VALUE)))))) (METHOD-FUNCTION (COMPUTE-METHOD-FUNCTION LAMBDA-EXPRESSION)) (FAST-FUNCTION (COMPUTE-METHOD-FAST-FUNCTION LAMBDA-EXPRESSION)) (METHOD-LAMBDA-LIST (QUOTE (NEW-VALUE OBJECT))) (GF (FIND-GENERIC-FUNCTION FUNCTION-NAME NIL)) (INITARGS (SYSTEM::BACKQ-LIST (QUOTE :LAMBDA-LIST) METHOD-LAMBDA-LIST (QUOTE :QUALIFIERS) NIL (QUOTE :SPECIALIZERS) (SYSTEM::BACKQ-LIST +THE-T-CLASS+ CLASS) (QUOTE :FUNCTION) (IF (AUTOLOADP (QUOTE COMPILE)) METHOD-FUNCTION (AUTOCOMPILE METHOD-FUNCTION)) (QUOTE :FAST-FUNCTION) (IF (AUTOLOADP (QUOTE COMPILE)) FAST-FUNCTION (AUTOCOMPILE FAST-FUNCTION)) (QUOTE :SLOT-DEFINITION) SLOT-DEFINITION)) (METHOD-CLASS (IF (STD-CLASS-P CLASS) +THE-STANDARD-WRITER-METHOD-CLASS+ (APPLY (FUNCTION WRITER-METHOD-CLASS) CLASS SLOT-DEFINITION INITARGS)))) (ASSERT (SUBTYPEP METHOD-CLASS +THE-STANDARD-WRITER-METHOD-CLASS+)) (IF GF (CHECK-METHOD-LAMBDA-LIST FUNCTION-NAME METHOD-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (SETF GF (ENSURE-GENERIC-FUNCTION FUNCTION-NAME :LAMBDA-LIST METHOD-LAMBDA-LIST))) (LET ((METHOD (IF (EQ METHOD-CLASS +THE-STANDARD-WRITER-METHOD-CLASS+) (APPLY (FUNCTION MAKE-INSTANCE-STANDARD-ACCESSOR-METHOD) METHOD-CLASS INITARGS) (APPLY (FUNCTION MAKE-INSTANCE) METHOD-CLASS :GENERIC-FUNCTION NIL INITARGS)))) (IF (STD-GENERIC-FUNCTION-P GF) (PROGN (STD-ADD-METHOD GF METHOD) (MAP-DEPENDENTS GF (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GF DEP (QUOTE ADD-METHOD) METHOD))))) (ADD-METHOD GF METHOD)) METHOD)))
     [java] ; (DEFMACRO ATOMIC-DEFGENERIC (FUNCTION-NAME &REST REST) "Macro to define a generic function and 'swap it into place' after
     [java] it's been fully defined with all its methods.
     [java]
     [java] Note: the user should really use the (:method ..) method description
     [java] way of defining methods; there's not much use in atomically defining
     [java] generic functions without providing sensible behaviour." (LET ((TEMP-SYM (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE DEFGENERIC) TEMP-SYM REST) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE GF) (SYSTEM::BACKQ-LIST (QUOTE SYMBOL-FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) TEMP-SYM)))) (SYSTEM::BACKQ-LIST* (QUOTE FSET) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME) (QUOTE (GF))) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE (STD-SLOT-VALUE GF (QUOTE NAME))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) FUNCTION-NAME)) (SYSTEM::BACKQ-LIST (QUOTE FMAKUNBOUND) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) TEMP-SYM)) (QUOTE (GF))))))
     [java] ; (DEFMACRO REDEFINE-CLASS-FORWARDER (NAME SLOT &OPTIONAL BODY-ALIST) "Define a generic function on a temporary symbol as an accessor
     [java] for the slot `slot'. Then, when definition is complete (including
     [java] allocation of methods), swap the definition in place.
     [java]
     [java] `body-alist' can be used to override the default method bodies for given
     [java] metaclasses.  In substitute method bodies, `class' names the class
     [java] instance and, for setters, `new-value' the new value." (LET* ((SETTERP (CONSP NAME)) (%NAME (INTERN (CONCATENATE (QUOTE STRING) "%" (IF SETTERP (SYMBOL-NAME (QUOTE SET-)) "") (SYMBOL-NAME (IF SETTERP (CADR NAME) NAME))) (FIND-PACKAGE "SYS"))) (BODIES (APPEND BODY-ALIST (IF SETTERP (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE BUILT-IN-CLASS) %NAME (QUOTE (NEW-VALUE CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE FORWARD-REFERENCED-CLASS) %NAME (QUOTE (NEW-VALUE CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE STRUCTURE-CLASS) %NAME (QUOTE (NEW-VALUE CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE STANDARD-CLASS) (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE SLOT-VALUE) (QUOTE CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT)) (QUOTE (NEW-VALUE))) (SYSTEM::BACKQ-LIST* (QUOTE FUNCALLABLE-STANDARD-CLASS) (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE SLOT-VALUE) (QUOTE CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT)) (QUOTE (NEW-VALUE)))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE BUILT-IN-CLASS) %NAME (QUOTE (CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE FORWARD-REFERENCED-CLASS) %NAME (QUOTE (CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE STRUCTURE-CLASS) %NAME (QUOTE (CLASS))) (SYSTEM::BACKQ-LIST (QUOTE STANDARD-CLASS) (QUOTE SLOT-VALUE) (QUOTE CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT)) (SYSTEM::BACKQ-LIST (QUOTE FUNCALLABLE-STANDARD-CLASS) (QUOTE SLOT-VALUE) (QUOTE CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT))))))) (SYSTEM::BACKQ-LIST* (QUOTE ATOMIC-DEFGENERIC) NAME (SYSTEM::BACKQ-APPEND (WHEN SETTERP (LIST (QUOTE NEW-VALUE))) (QUOTE (CLASS))) (MAPCAR (FUNCTION (LAMBDA (CLASS-NAME) (SYSTEM::BACKQ-LIST (QUOTE :METHOD) (SYSTEM::BACKQ-APPEND (WHEN SETTERP (LIST (QUOTE NEW-VALUE))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE CLASS) CLASS-NAME))) (CDR (ASSOC CLASS-NAME BODIES))))) (QUOTE (BUILT-IN-CLASS FORWARD-REFERENCED-CLASS STRUCTURE-CLASS STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS))))))
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-NAME NAME)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-NAME) NAME ((STANDARD-CLASS PROGN (REINITIALIZE-INSTANCE CLASS :NAME NEW-VALUE) NEW-VALUE) (FUNCALLABLE-STANDARD-CLASS PROGN (REINITIALIZE-INSTANCE CLASS :NAME NEW-VALUE) NEW-VALUE)))
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-SLOTS SLOTS)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-SLOTS) SLOTS)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DIRECT-SLOTS DIRECT-SLOTS)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DIRECT-SLOTS) DIRECT-SLOTS)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-LAYOUT LAYOUT)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-LAYOUT) LAYOUT)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DIRECT-SUPERCLASSES) DIRECT-SUPERCLASSES)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DIRECT-SUBCLASSES DIRECT-SUBCLASSES)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DIRECT-SUBCLASSES) DIRECT-SUBCLASSES)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DIRECT-METHODS DIRECT-METHODS)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DIRECT-METHODS) DIRECT-METHODS)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-PRECEDENCE-LIST PRECEDENCE-LIST)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-PRECEDENCE-LIST) PRECEDENCE-LIST)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-FINALIZED-P FINALIZED-P)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-FINALIZED-P) FINALIZED-P)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DEFAULT-INITARGS DEFAULT-INITARGS)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DEFAULT-INITARGS) DEFAULT-INITARGS)
     [java] ; (REDEFINE-CLASS-FORWARDER CLASS-DIRECT-DEFAULT-INITARGS DIRECT-DEFAULT-INITARGS)
     [java] ; (REDEFINE-CLASS-FORWARDER (SETF CLASS-DIRECT-DEFAULT-INITARGS) DIRECT-DEFAULT-INITARGS)
     [java] ; (DEFUN CHECK-DUPLICATE-SLOTS (SLOTS) (FLET ((CANONICAL-SLOT-NAME (CANONICAL-SLOT) (GETF CANONICAL-SLOT :NAME))) (DOLIST (S1 SLOTS) (LET ((NAME1 (CANONICAL-SLOT-NAME S1))) (DOLIST (S2 (CDR (MEMQ S1 SLOTS))) (WHEN (EQ NAME1 (CANONICAL-SLOT-NAME S2)) (ERROR (QUOTE PROGRAM-ERROR) "Duplicate slot ~S" NAME1)))))))
     [java] ; (DEFUN CHECK-DUPLICATE-DEFAULT-INITARGS (INITARGS) (LET ((NAMES NIL)) (DOLIST (INITARG INITARGS) (PUSH (CAR INITARG) NAMES)) (DO* ((NAMES NAMES (CDR NAMES)) (NAME (CAR NAMES) (CAR NAMES))) ((NULL NAMES)) (WHEN (MEMQ NAME (CDR NAMES)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Duplicate initialization argument name ~S in :DEFAULT-INITARGS." :FORMAT-ARGUMENTS (LIST NAME))))))
     [java] ; (DEFUN CANONICALIZE-DIRECT-SUPERCLASSES (DIRECT-SUPERCLASSES) (LET ((CLASSES (QUOTE NIL))) (DOLIST (CLASS-SPECIFIER DIRECT-SUPERCLASSES) (LET ((CLASS (IF (CLASSP CLASS-SPECIFIER) CLASS-SPECIFIER (FIND-CLASS CLASS-SPECIFIER NIL)))) (UNLESS CLASS (SETF CLASS (MAKE-INSTANCE +THE-FORWARD-REFERENCED-CLASS+ :NAME CLASS-SPECIFIER)) (SETF (FIND-CLASS CLASS-SPECIFIER) CLASS)) (WHEN (AND (TYPEP CLASS (QUOTE BUILT-IN-CLASS)) (NOT (MEMBER CLASS *EXTENSIBLE-BUILT-IN-CLASSES*))) (ERROR "Attempt to define a subclass of built-in-class ~S." CLASS-SPECIFIER)) (PUSH CLASS CLASSES))) (NREVERSE CLASSES)))
     [java] ; (ATOMIC-DEFGENERIC ADD-DIRECT-SUBCLASS (SUPERCLASS SUBCLASS) (:METHOD ((SUPERCLASS CLASS) (SUBCLASS CLASS)) (SETF (CLASS-DIRECT-SUBCLASSES SUPERCLASS) (ADJOIN SUBCLASS (CLASS-DIRECT-SUBCLASSES SUPERCLASS)))))
     [java] ; (ATOMIC-DEFGENERIC REMOVE-DIRECT-SUBCLASS (SUPERCLASS SUBCLASS) (:METHOD ((SUPERCLASS CLASS) (SUBCLASS CLASS)) (SETF (CLASS-DIRECT-SUBCLASSES SUPERCLASS) (REMOVE SUBCLASS (CLASS-DIRECT-SUBCLASSES SUPERCLASS)))))
     [java] ; (DEFUN ENSURE-CLASS (NAME &REST ALL-KEYS &KEY &ALLOW-OTHER-KEYS) (LET ((CLASS (FIND-CLASS NAME NIL))) (IF (AND CLASS (EQL (CLASS-NAME CLASS) NAME)) (APPLY (FUNCTION ENSURE-CLASS-USING-CLASS) CLASS NAME ALL-KEYS) (APPLY (FUNCTION ENSURE-CLASS-USING-CLASS) NIL NAME ALL-KEYS))))
     [java] ; (DEFGENERIC ENSURE-CLASS-USING-CLASS (CLASS NAME &KEY DIRECT-DEFAULT-INITARGS DIRECT-SLOTS DIRECT-SUPERCLASSES METACLASS &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD ENSURE-CLASS-USING-CLASS :BEFORE (CLASS NAME &KEY DIRECT-SLOTS DIRECT-DEFAULT-INITARGS &ALLOW-OTHER-KEYS) (CHECK-DUPLICATE-SLOTS DIRECT-SLOTS) (CHECK-DUPLICATE-DEFAULT-INITARGS DIRECT-DEFAULT-INITARGS))
     [java] ; (DEFMETHOD ENSURE-CLASS-USING-CLASS ((CLASS NULL) NAME &REST ALL-KEYS &KEY (METACLASS +THE-STANDARD-CLASS+) DIRECT-SUPERCLASSES &ALLOW-OTHER-KEYS) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :METACLASS) (UNLESS (CLASSP METACLASS) (SETF METACLASS (FIND-CLASS METACLASS))) (LET ((CLASS (APPLY (IF (EQ METACLASS +THE-STANDARD-CLASS+) (FUNCTION MAKE-INSTANCE-STANDARD-CLASS) (FUNCTION MAKE-INSTANCE)) METACLASS :NAME NAME :DIRECT-SUPERCLASSES (CANONICALIZE-DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES) ALL-KEYS))) (%SET-FIND-CLASS NAME CLASS) CLASS))
     [java] ; (DEFMETHOD ENSURE-CLASS-USING-CLASS ((CLASS BUILT-IN-CLASS) NAME &REST ALL-KEYS &KEY &ALLOW-OTHER-KEYS) (DECLARE (IGNORE ALL-KEYS)) (ERROR "The symbol ~S names a built-in class." NAME))
     [java] ; (DEFMETHOD ENSURE-CLASS-USING-CLASS ((CLASS FORWARD-REFERENCED-CLASS) NAME &REST ALL-KEYS &KEY (METACLASS +THE-STANDARD-CLASS+) DIRECT-SUPERCLASSES &ALLOW-OTHER-KEYS) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :METACLASS) (UNLESS (CLASSP METACLASS) (SETF METACLASS (FIND-CLASS METACLASS))) (APPLY (FUNCTION CHANGE-CLASS) CLASS METACLASS ALL-KEYS) (APPLY (FUNCTION REINITIALIZE-INSTANCE) CLASS :NAME NAME :DIRECT-SUPERCLASSES (CANONICALIZE-DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES) ALL-KEYS) CLASS)
     [java] ; (DEFMETHOD ENSURE-CLASS-USING-CLASS ((CLASS CLASS) NAME &REST ALL-KEYS &KEY (METACLASS +THE-STANDARD-CLASS+ METACLASSP) DIRECT-SUPERCLASSES &ALLOW-OTHER-KEYS) (DECLARE (IGNORE NAME)) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :METACLASS) (UNLESS (CLASSP METACLASS) (SETF METACLASS (FIND-CLASS METACLASS))) (WHEN (AND METACLASSP (NOT (EQ (CLASS-OF CLASS) METACLASS))) (ERROR (QUOTE PROGRAM-ERROR) "Trying to redefine class ~S with different metaclass." (CLASS-NAME CLASS))) (APPLY (FUNCTION REINITIALIZE-INSTANCE) CLASS :DIRECT-SUPERCLASSES (CANONICALIZE-DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES) ALL-KEYS) CLASS)
     [java] ; (DEFMACRO DEFCLASS (&WHOLE FORM NAME DIRECT-SUPERCLASSES DIRECT-SLOTS &REST OPTIONS) (UNLESS (>= (LENGTH FORM) 3) (ERROR (QUOTE PROGRAM-ERROR) "Wrong number of arguments for DEFCLASS.")) (CHECK-DECLARATION-TYPE NAME) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:CLASS))) (SYSTEM::BACKQ-LIST* (QUOTE ENSURE-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE :DIRECT-SUPERCLASSES) (SYSTEM::BACKQ-LIST (QUOTE CANONICALIZE-DIRECT-SUPERCLASSES) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) DIRECT-SUPERCLASSES)) (QUOTE :DIRECT-SLOTS) (CANONICALIZE-DIRECT-SLOTS DIRECT-SLOTS) (CANONICALIZE-DEFCLASS-OPTIONS OPTIONS))))
     [java] ; (DEFGENERIC DIRECT-SLOT-DEFINITION-CLASS (CLASS &REST INITARGS))
     [java] ; (DEFMETHOD DIRECT-SLOT-DEFINITION-CLASS ((CLASS CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+)
     [java] ; (DEFGENERIC EFFECTIVE-SLOT-DEFINITION-CLASS (CLASS &REST INITARGS))
     [java] ; (DEFMETHOD EFFECTIVE-SLOT-DEFINITION-CLASS ((CLASS CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+)
     [java] ; (DEFGENERIC READER-METHOD-CLASS (CLASS DIRECT-SLOT &REST INITARGS))
     [java] ; (DEFMETHOD READER-METHOD-CLASS ((CLASS STANDARD-CLASS) (DIRECT-SLOT STANDARD-DIRECT-SLOT-DEFINITION) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-READER-METHOD-CLASS+)
     [java] ; (DEFMETHOD READER-METHOD-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) (DIRECT-SLOT STANDARD-DIRECT-SLOT-DEFINITION) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-READER-METHOD-CLASS+)
     [java] ; (DEFGENERIC WRITER-METHOD-CLASS (CLASS DIRECT-SLOT &REST INITARGS))
     [java] ; (DEFMETHOD WRITER-METHOD-CLASS ((CLASS STANDARD-CLASS) (DIRECT-SLOT STANDARD-DIRECT-SLOT-DEFINITION) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-WRITER-METHOD-CLASS+)
     [java] ; (DEFMETHOD WRITER-METHOD-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) (DIRECT-SLOT STANDARD-DIRECT-SLOT-DEFINITION) &REST INITARGS) (DECLARE (IGNORE INITARGS)) +THE-STANDARD-WRITER-METHOD-CLASS+)
     [java] ; (ATOMIC-DEFGENERIC COMPUTE-APPLICABLE-METHODS (GF ARGS) (:METHOD ((GF STANDARD-GENERIC-FUNCTION) ARGS) (STD-COMPUTE-APPLICABLE-METHODS GF ARGS)))
     [java] ; (DEFGENERIC COMPUTE-APPLICABLE-METHODS-USING-CLASSES (GF CLASSES) (:METHOD ((GF STANDARD-GENERIC-FUNCTION) CLASSES) (LET ((METHODS (QUOTE NIL))) (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GF)) (MULTIPLE-VALUE-BIND (APPLICABLE KNOWNP) (METHOD-APPLICABLE-USING-CLASSES-P METHOD CLASSES) (COND (APPLICABLE (PUSH METHOD METHODS)) ((NOT KNOWNP) (RETURN-FROM COMPUTE-APPLICABLE-METHODS-USING-CLASSES (VALUES NIL NIL)))))) (VALUES (SORT-METHODS METHODS GF CLASSES) T))))
     [java] ; (DEFGENERIC SLOT-VALUE-USING-CLASS (CLASS INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-VALUE INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET* ((LOCATION (SLOT-DEFINITION-LOCATION SLOT)) (VALUE (IF (CONSP LOCATION) (CDR LOCATION) (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION)))) (IF (EQ VALUE +SLOT-UNBOUND+) (NTH-VALUE 0 (SLOT-UNBOUND CLASS INSTANCE (SLOT-DEFINITION-NAME SLOT))) VALUE)))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-VALUE INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET* ((LOCATION (SLOT-DEFINITION-LOCATION SLOT)) (VALUE (IF (CONSP LOCATION) (CDR LOCATION) (FUNCALLABLE-STANDARD-INSTANCE-ACCESS INSTANCE LOCATION)))) (IF (EQ VALUE +SLOT-UNBOUND+) (NTH-VALUE 0 (SLOT-UNBOUND CLASS INSTANCE (SLOT-DEFINITION-NAME SLOT))) VALUE)))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-VALUE INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-VALUE-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (STD-SLOT-VALUE INSTANCE (SLOT-DEFINITION-NAME SLOT)))
     [java] ; (DEFGENERIC (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE CLASS INSTANCE SLOT))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (SETF (STD-SLOT-VALUE INSTANCE SLOT) NEW-VALUE))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (SETF (CDR LOCATION) NEW-VALUE) (SETF (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) NEW-VALUE))))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (SETF (STD-SLOT-VALUE INSTANCE SLOT) NEW-VALUE))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (SETF (CDR LOCATION) NEW-VALUE) (SETF (FUNCALLABLE-STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) NEW-VALUE))))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS STRUCTURE-CLASS) INSTANCE (SLOT SYMBOL)) (SETF (STD-SLOT-VALUE INSTANCE SLOT) NEW-VALUE))
     [java] ; (DEFMETHOD (SETF SLOT-VALUE-USING-CLASS) (NEW-VALUE (CLASS STRUCTURE-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (SETF (STD-SLOT-VALUE INSTANCE (SLOT-DEFINITION-NAME SLOT)) NEW-VALUE))
     [java] ; (DEFGENERIC SLOT-EXISTS-P-USING-CLASS (CLASS INSTANCE SLOT-NAME))
     [java] ; (DEFMETHOD SLOT-EXISTS-P-USING-CLASS (CLASS INSTANCE SLOT-NAME) NIL)
     [java] ; (DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE SLOT-NAME) (STD-SLOT-EXISTS-P INSTANCE SLOT-NAME))
     [java] ; (DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE SLOT-NAME) (STD-SLOT-EXISTS-P INSTANCE SLOT-NAME))
     [java] ; (DEFMETHOD SLOT-EXISTS-P-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE SLOT-NAME) (DOLIST (DSD (CLASS-SLOTS CLASS)) (WHEN (EQ (SYSTEM::DSD-NAME DSD) SLOT-NAME) (RETURN-FROM SLOT-EXISTS-P-USING-CLASS T))) NIL)
     [java] ; (DEFGENERIC SLOT-BOUNDP-USING-CLASS (CLASS INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-BOUNDP INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (NOT (EQ (CDR LOCATION) +SLOT-UNBOUND+)) (NOT (EQ (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) +SLOT-UNBOUND+)))))
     [java] ; (DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-BOUNDP INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (NOT (EQ (CDR LOCATION) +SLOT-UNBOUND+)) (NOT (EQ (FUNCALLABLE-STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) +SLOT-UNBOUND+)))))
     [java] ; (DEFMETHOD SLOT-BOUNDP-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE SLOT) "Structure slots can't be unbound, so this method always returns T." (DECLARE (IGNORE CLASS INSTANCE SLOT)) T)
     [java] ; (DEFGENERIC SLOT-MAKUNBOUND-USING-CLASS (CLASS INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-MAKUNBOUND INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE (SLOT STANDARD-EFFECTIVE-SLOT-DEFINITION)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (SETF (CDR LOCATION) +SLOT-UNBOUND+) (SETF (STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) +SLOT-UNBOUND+))))
     [java] ; (DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (STD-SLOT-MAKUNBOUND INSTANCE SLOT))
     [java] ; (DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE (SLOT SYMBOL)) (LET ((LOCATION (SLOT-DEFINITION-LOCATION SLOT))) (IF (CONSP LOCATION) (SETF (CDR LOCATION) +SLOT-UNBOUND+) (SETF (FUNCALLABLE-STANDARD-INSTANCE-ACCESS INSTANCE LOCATION) +SLOT-UNBOUND+))))
     [java] ; (DEFMETHOD SLOT-MAKUNBOUND-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE SLOT) (DECLARE (IGNORE CLASS INSTANCE SLOT)) (ERROR "Structure slots can't be unbound"))
     [java] ; (DEFGENERIC SLOT-MISSING (CLASS INSTANCE SLOT-NAME OPERATION &OPTIONAL NEW-VALUE))
     [java] ; (DEFMETHOD SLOT-MISSING ((CLASS T) INSTANCE SLOT-NAME OPERATION &OPTIONAL NEW-VALUE) (DECLARE (IGNORE NEW-VALUE)) (ERROR "The slot ~S is missing from the class ~S." SLOT-NAME CLASS))
     [java] ; (DEFGENERIC SLOT-UNBOUND (CLASS INSTANCE SLOT-NAME))
     [java] ; (DEFMETHOD SLOT-UNBOUND ((CLASS T) INSTANCE SLOT-NAME) (ERROR (QUOTE UNBOUND-SLOT) :INSTANCE INSTANCE :NAME SLOT-NAME))
     [java] ; (DEFGENERIC ALLOCATE-INSTANCE (CLASS &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD ALLOCATE-INSTANCE ((CLASS STANDARD-CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) (STD-ALLOCATE-INSTANCE CLASS))
     [java] ; (DEFMETHOD ALLOCATE-INSTANCE ((CLASS FUNCALLABLE-STANDARD-CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) (ALLOCATE-FUNCALLABLE-INSTANCE CLASS))
     [java] ; (DEFMETHOD ALLOCATE-INSTANCE ((CLASS STRUCTURE-CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) (%MAKE-STRUCTURE (CLASS-NAME CLASS) (MAKE-LIST (LENGTH (CLASS-SLOTS CLASS)) :INITIAL-ELEMENT +SLOT-UNBOUND+)))
     [java] ; (DEFMETHOD ALLOCATE-INSTANCE ((CLASS BUILT-IN-CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) (ERROR "Cannot allocate instances of a built-in class: ~S" CLASS))
     [java] ; (DEFMETHOD ALLOCATE-INSTANCE :BEFORE ((CLASS CLASS) &REST INITARGS) (DECLARE (IGNORE INITARGS)) (UNLESS (CLASS-FINALIZED-P CLASS) (FINALIZE-INHERITANCE CLASS)))
     [java] ; (DEFUN CALCULATE-ALLOWABLE-INITARGS (GF-LIST ARGS INSTANCE SHARED-INITIALIZE-PARAM INITARGS) (LET* ((METHODS (NCONC (STD-COMPUTE-APPLICABLE-METHODS (FUNCTION SHARED-INITIALIZE) (LIST* INSTANCE SHARED-INITIALIZE-PARAM INITARGS)) (MAPCAN (FUNCTION (LAMBDA (GF) (IF (STD-GENERIC-FUNCTION-P GF) (STD-COMPUTE-APPLICABLE-METHODS GF ARGS) (COMPUTE-APPLICABLE-METHODS GF ARGS)))) GF-LIST))) (METHOD-KEYWORD-ARGS (REDUCE (FUNCTION MERGE-INITARGS-SETS) (MAPCAR (FUNCTION METHOD-LAMBDA-LIST) METHODS) :KEY (FUNCTION EXTRACT-LAMBDA-LIST-KEYWORDS) :INITIAL-VALUE NIL)) (SLOTS-INITARGS (MAPAPPEND (FUNCTION SLOT-DEFINITION-INITARGS) (CLASS-SLOTS (CLASS-OF INSTANCE))))) (MERGE-INITARGS-SETS (MERGE-INITARGS-SETS SLOTS-INITARGS METHOD-KEYWORD-ARGS) (QUOTE (:ALLOW-OTHER-KEYS)))))
     [java] ; (DEFUN CHECK-INITARGS (GF-LIST ARGS INSTANCE SHARED-INITIALIZE-PARAM INITARGS CACHE CALL-SITE) "Checks the validity of `initargs' for the generic functions in `gf-list'
     [java] when called with `args' by calculating the applicable methods for each gf.
     [java] The applicable methods for SHARED-INITIALIZE based on `instance',
     [java] `shared-initialize-param' and `initargs' are added to the list of
     [java] applicable methods." (WHEN (ODDP (LENGTH INITARGS)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of keyword arguments.")) (UNLESS (GETF INITARGS :ALLOW-OTHER-KEYS) (MULTIPLE-VALUE-BIND (ALLOWABLE-INITARGS PRESENT-P) (WHEN CACHE (GETHASH (CLASS-OF INSTANCE) CACHE)) (UNLESS PRESENT-P (SETF ALLOWABLE-INITARGS (CALCULATE-ALLOWABLE-INITARGS GF-LIST ARGS INSTANCE SHARED-INITIALIZE-PARAM INITARGS)) (WHEN CACHE (SETF (GETHASH (CLASS-OF INSTANCE) CACHE) ALLOWABLE-INITARGS))) (UNLESS (EQ T ALLOWABLE-INITARGS) (DO* ((TAIL INITARGS (CDDR TAIL)) (INITARG (CAR TAIL) (CAR TAIL))) ((NULL TAIL)) (UNLESS (MEMQ INITARG ALLOWABLE-INITARGS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Invalid initarg ~S in call to ~S with arglist ~S." :FORMAT-ARGUMENTS (LIST INITARG CALL-SITE ARGS))))))))
     [java] ; (DEFUN MERGE-INITARGS-SETS (LIST1 LIST2) (COND ((EQ LIST1 T) T) ((EQ LIST2 T) T) (T (UNION LIST1 LIST2))))
     [java] ; (DEFUN EXTRACT-LAMBDA-LIST-KEYWORDS (LAMBDA-LIST) "Returns a list of keywords acceptable as keyword arguments,
     [java] or T when any keyword is acceptable due to presence of
     [java] &allow-other-keys." (WHEN (MEMBER (QUOTE &ALLOW-OTHER-KEYS) LAMBDA-LIST) (RETURN-FROM EXTRACT-LAMBDA-LIST-KEYWORDS T)) (LOOP WITH KEYWORD-ARGS = (CDR (MEMQ (QUOTE &KEY) LAMBDA-LIST)) FOR KEY IN KEYWORD-ARGS WHEN (EQ KEY (QUOTE &AUX)) DO (LOOP-FINISH) WHEN (EQ KEY (QUOTE &ALLOW-OTHER-KEYS)) DO (RETURN T) WHEN (LISTP KEY) DO (SETQ KEY (CAR KEY)) COLLECT (IF (SYMBOLP KEY) (MAKE-KEYWORD KEY) (CAR KEY))))
     [java] ; (DEFGENERIC MAKE-INSTANCE (CLASS &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD MAKE-INSTANCE :BEFORE ((CLASS CLASS) &REST INITARGS) (WHEN (ODDP (LENGTH INITARGS)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of keyword arguments.")) (UNLESS (CLASS-FINALIZED-P CLASS) (FINALIZE-INHERITANCE CLASS)))
     [java] ; (DEFUN AUGMENT-INITARGS-WITH-DEFAULTS (CLASS INITARGS) (LET ((DEFAULT-INITARGS (QUOTE NIL))) (DOLIST (INITARG (CLASS-DEFAULT-INITARGS CLASS)) (LET ((KEY (FIRST INITARG)) (FN (THIRD INITARG))) (WHEN (EQ (GETF INITARGS KEY +SLOT-UNBOUND+) +SLOT-UNBOUND+) (PUSH KEY DEFAULT-INITARGS) (PUSH (FUNCALL FN) DEFAULT-INITARGS)))) (APPEND INITARGS (NREVERSE DEFAULT-INITARGS))))
     [java] ; (DEFMETHOD MAKE-INSTANCE ((CLASS STANDARD-CLASS) &REST INITARGS) (SETF INITARGS (AUGMENT-INITARGS-WITH-DEFAULTS CLASS INITARGS)) (LET ((INSTANCE (STD-ALLOCATE-INSTANCE CLASS))) (CHECK-INITARGS (LIST (FUNCTION ALLOCATE-INSTANCE) (FUNCTION INITIALIZE-INSTANCE)) (LIST* INSTANCE INITARGS) INSTANCE T INITARGS *MAKE-INSTANCE-INITARGS-CACHE* (QUOTE MAKE-INSTANCE)) (APPLY (FUNCTION INITIALIZE-INSTANCE) INSTANCE INITARGS) INSTANCE))
     [java] ; (DEFMETHOD MAKE-INSTANCE ((CLASS FUNCALLABLE-STANDARD-CLASS) &REST INITARGS) (SETF INITARGS (AUGMENT-INITARGS-WITH-DEFAULTS CLASS INITARGS)) (LET ((INSTANCE (ALLOCATE-FUNCALLABLE-INSTANCE CLASS))) (CHECK-INITARGS (LIST (FUNCTION ALLOCATE-INSTANCE) (FUNCTION INITIALIZE-INSTANCE)) (LIST* INSTANCE INITARGS) INSTANCE T INITARGS *MAKE-INSTANCE-INITARGS-CACHE* (QUOTE MAKE-INSTANCE)) (APPLY (FUNCTION INITIALIZE-INSTANCE) INSTANCE INITARGS) INSTANCE))
     [java] ; (DEFMETHOD MAKE-INSTANCE ((CLASS SYMBOL) &REST INITARGS) (APPLY (FUNCTION MAKE-INSTANCE) (FIND-CLASS CLASS) INITARGS))
     [java] ; (DEFGENERIC INITIALIZE-INSTANCE (INSTANCE &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD INITIALIZE-INSTANCE ((INSTANCE STANDARD-OBJECT) &REST INITARGS) (APPLY (FUNCTION SHARED-INITIALIZE) INSTANCE T INITARGS))
     [java] ; (DEFGENERIC REINITIALIZE-INSTANCE (INSTANCE &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE ((INSTANCE STANDARD-OBJECT) &REST INITARGS) (CHECK-INITARGS (LIST (FUNCTION REINITIALIZE-INSTANCE)) (LIST* INSTANCE INITARGS) INSTANCE NIL INITARGS *REINITIALIZE-INSTANCE-INITARGS-CACHE* (QUOTE REINITIALIZE-INSTANCE)) (APPLY (FUNCTION SHARED-INITIALIZE) INSTANCE NIL INITARGS))
     [java] ; (DEFUN STD-SHARED-INITIALIZE (INSTANCE SLOT-NAMES ALL-KEYS) (WHEN (ODDP (LENGTH ALL-KEYS)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of keyword arguments.")) (DO* ((TAIL ALL-KEYS (CDDR TAIL)) (INITARG (CAR TAIL) (CAR TAIL))) ((NULL TAIL)) (UNLESS (SYMBOLP INITARG) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Initarg ~S not a symbol." :FORMAT-ARGUMENTS (LIST INITARG)))) (DOLIST (SLOT (CLASS-SLOTS (CLASS-OF INSTANCE))) (LET ((SLOT-NAME (SLOT-DEFINITION-NAME SLOT))) (MULTIPLE-VALUE-BIND (INIT-KEY INIT-VALUE FOUNDP) (GET-PROPERTIES ALL-KEYS (SLOT-DEFINITION-INITARGS SLOT)) (IF FOUNDP (SETF (STD-SLOT-VALUE INSTANCE SLOT-NAME) INIT-VALUE) (UNLESS (STD-SLOT-BOUNDP INSTANCE SLOT-NAME) (LET ((INITFUNCTION (SLOT-DEFINITION-INITFUNCTION SLOT))) (WHEN (AND INITFUNCTION (OR (EQ SLOT-NAMES T) (MEMQ SLOT-NAME SLOT-NAMES))) (SETF (STD-SLOT-VALUE INSTANCE SLOT-NAME) (FUNCALL INITFUNCTION))))))))) INSTANCE)
     [java] ; (DEFGENERIC SHARED-INITIALIZE (INSTANCE SLOT-NAMES &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD SHARED-INITIALIZE ((INSTANCE STANDARD-OBJECT) SLOT-NAMES &REST INITARGS) (STD-SHARED-INITIALIZE INSTANCE SLOT-NAMES INITARGS))
     [java] ; (DEFMETHOD SHARED-INITIALIZE ((SLOT SLOT-DEFINITION) SLOT-NAMES &REST ARGS &KEY NAME INITARGS INITFORM INITFUNCTION READERS WRITERS ALLOCATION &ALLOW-OTHER-KEYS) (DECLARE (IGNORE SLOT-NAMES)) (DECLARE (IGNORE NAME INITARGS INITFORM INITFUNCTION READERS WRITERS ALLOCATION)) (APPLY (FUNCTION INIT-SLOT-DEFINITION) SLOT :ALLOW-OTHER-KEYS T ARGS) (CALL-NEXT-METHOD))
     [java] ; (DEFGENERIC CHANGE-CLASS (INSTANCE NEW-CLASS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD CHANGE-CLASS ((OLD-INSTANCE STANDARD-OBJECT) (NEW-CLASS STANDARD-CLASS) &REST INITARGS) (LET ((OLD-SLOTS (CLASS-SLOTS (CLASS-OF OLD-INSTANCE))) (NEW-SLOTS (CLASS-SLOTS NEW-CLASS)) (NEW-INSTANCE (ALLOCATE-INSTANCE NEW-CLASS))) (DOLIST (NEW-SLOT NEW-SLOTS) (WHEN (INSTANCE-SLOT-P NEW-SLOT) (LET* ((SLOT-NAME (SLOT-DEFINITION-NAME NEW-SLOT)) (OLD-SLOT (FIND SLOT-NAME OLD-SLOTS :KEY (QUOTE SLOT-DEFINITION-NAME)))) (WHEN (AND OLD-SLOT (SLOT-BOUNDP OLD-INSTANCE SLOT-NAME)) (SETF (SLOT-VALUE NEW-INSTANCE SLOT-NAME) (SLOT-VALUE OLD-INSTANCE SLOT-NAME)))))) (SWAP-SLOTS OLD-INSTANCE NEW-INSTANCE) (ROTATEF (STD-INSTANCE-LAYOUT NEW-INSTANCE) (STD-INSTANCE-LAYOUT OLD-INSTANCE)) (APPLY (FUNCTION UPDATE-INSTANCE-FOR-DIFFERENT-CLASS) NEW-INSTANCE OLD-INSTANCE INITARGS) OLD-INSTANCE))
     [java] ; (DEFMETHOD CHANGE-CLASS ((INSTANCE STANDARD-OBJECT) (NEW-CLASS SYMBOL) &REST INITARGS) (APPLY (FUNCTION CHANGE-CLASS) INSTANCE (FIND-CLASS NEW-CLASS) INITARGS))
     [java] ; (DEFGENERIC UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (OLD NEW &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS ((OLD STANDARD-OBJECT) (NEW STANDARD-OBJECT) &REST INITARGS) (LET ((ADDED-SLOTS (REMOVE-IF (FUNCTION (LAMBDA (SLOT-NAME) (SLOT-EXISTS-P OLD SLOT-NAME))) (MAPCAR (QUOTE SLOT-DEFINITION-NAME) (CLASS-SLOTS (CLASS-OF NEW)))))) (CHECK-INITARGS (LIST (FUNCTION UPDATE-INSTANCE-FOR-DIFFERENT-CLASS)) (LIST OLD NEW INITARGS) NEW ADDED-SLOTS INITARGS NIL (QUOTE UPDATE-INSTANCE-FOR-DIFFERENT-CLASS)) (APPLY (FUNCTION SHARED-INITIALIZE) NEW ADDED-SLOTS INITARGS)))
     [java] ; (DEFGENERIC MAKE-INSTANCES-OBSOLETE (CLASS))
     [java] ; (DEFMETHOD MAKE-INSTANCES-OBSOLETE ((CLASS STANDARD-CLASS)) (%MAKE-INSTANCES-OBSOLETE CLASS))
     [java] ; (DEFMETHOD MAKE-INSTANCES-OBSOLETE ((CLASS FUNCALLABLE-STANDARD-CLASS)) (%MAKE-INSTANCES-OBSOLETE CLASS))
     [java] ; (DEFMETHOD MAKE-INSTANCES-OBSOLETE ((CLASS SYMBOL)) (MAKE-INSTANCES-OBSOLETE (FIND-CLASS CLASS)) CLASS)
     [java] ; (DEFGENERIC UPDATE-INSTANCE-FOR-REDEFINED-CLASS (INSTANCE ADDED-SLOTS DISCARDED-SLOTS PROPERTY-LIST &REST INITARGS &KEY &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS ((INSTANCE STANDARD-OBJECT) ADDED-SLOTS DISCARDED-SLOTS PROPERTY-LIST &REST INITARGS) (CHECK-INITARGS (LIST (FUNCTION UPDATE-INSTANCE-FOR-REDEFINED-CLASS)) (LIST* INSTANCE ADDED-SLOTS DISCARDED-SLOTS PROPERTY-LIST INITARGS) INSTANCE ADDED-SLOTS INITARGS NIL (QUOTE UPDATE-INSTANCE-FOR-REDEFINED-CLASS)) (APPLY (FUNCTION SHARED-INITIALIZE) INSTANCE ADDED-SLOTS INITARGS))
     [java] ; (DEFMETHOD INITIALIZE-INSTANCE :AFTER ((CLASS STANDARD-CLASS) &REST ARGS) (APPLY (FUNCTION STD-AFTER-INITIALIZATION-FOR-CLASSES) CLASS ARGS))
     [java] ; (DEFMETHOD INITIALIZE-INSTANCE :AFTER ((CLASS FUNCALLABLE-STANDARD-CLASS) &REST ARGS) (APPLY (FUNCTION STD-AFTER-INITIALIZATION-FOR-CLASSES) CLASS ARGS))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :BEFORE ((CLASS STANDARD-CLASS) &REST ALL-KEYS &KEY DIRECT-SUPERCLASSES) (CHECK-INITARGS (LIST (FUNCTION ALLOCATE-INSTANCE) (FUNCTION INITIALIZE-INSTANCE)) (LIST* CLASS ALL-KEYS) CLASS T ALL-KEYS NIL (QUOTE REINITIALIZE-INSTANCE)) (DOLIST (SUPERCLASS (SET-DIFFERENCE (CLASS-DIRECT-SUPERCLASSES CLASS) DIRECT-SUPERCLASSES)) (REMOVE-DIRECT-SUBCLASS SUPERCLASS CLASS)) (DOLIST (SUPERCLASS (SET-DIFFERENCE DIRECT-SUPERCLASSES (CLASS-DIRECT-SUPERCLASSES CLASS))) (ADD-DIRECT-SUBCLASS SUPERCLASS CLASS)))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :BEFORE ((CLASS FUNCALLABLE-STANDARD-CLASS) &REST ALL-KEYS &KEY DIRECT-SUPERCLASSES) (CHECK-INITARGS (LIST (FUNCTION ALLOCATE-INSTANCE) (FUNCTION INITIALIZE-INSTANCE)) (LIST* CLASS ALL-KEYS) CLASS T ALL-KEYS NIL (QUOTE REINITIALIZE-INSTANCE)) (DOLIST (SUPERCLASS (SET-DIFFERENCE (CLASS-DIRECT-SUPERCLASSES CLASS) DIRECT-SUPERCLASSES)) (REMOVE-DIRECT-SUBCLASS SUPERCLASS CLASS)) (DOLIST (SUPERCLASS (SET-DIFFERENCE DIRECT-SUPERCLASSES (CLASS-DIRECT-SUPERCLASSES CLASS))) (ADD-DIRECT-SUBCLASS SUPERCLASS CLASS)))
     [java] ; (DEFUN STD-AFTER-REINITIALIZATION-FOR-CLASSES (CLASS &REST ALL-KEYS &KEY (DIRECT-SUPERCLASSES NIL DIRECT-SUPERCLASSES-P) (DIRECT-SLOTS NIL DIRECT-SLOTS-P) (DIRECT-DEFAULT-INITARGS NIL DIRECT-DEFAULT-INITARGS-P) &ALLOW-OTHER-KEYS) (REMHASH CLASS *MAKE-INSTANCE-INITARGS-CACHE*) (REMHASH CLASS *REINITIALIZE-INSTANCE-INITARGS-CACHE*) (%MAKE-INSTANCES-OBSOLETE CLASS) (SETF (CLASS-FINALIZED-P CLASS) NIL) (WHEN DIRECT-SUPERCLASSES-P (LET* ((OLD-SUPERS (CLASS-DIRECT-SUPERCLASSES CLASS)) (NEW-SUPERS (CANONICALIZE-DIRECT-SUPERCLASS-LIST CLASS DIRECT-SUPERCLASSES))) (SETF (CLASS-DIRECT-SUPERCLASSES CLASS) NEW-SUPERS) (DOLIST (OLD-SUPERCLASS (SET-DIFFERENCE OLD-SUPERS NEW-SUPERS)) (REMOVE-DIRECT-SUBCLASS OLD-SUPERCLASS CLASS)) (DOLIST (NEW-SUPERCLASS (SET-DIFFERENCE NEW-SUPERS OLD-SUPERS)) (ADD-DIRECT-SUBCLASS NEW-SUPERCLASS CLASS)))) (WHEN DIRECT-SLOTS-P (LET ((SLOTS (MAPCAR (FUNCTION (LAMBDA (SLOT-PROPERTIES) (APPLY (FUNCTION MAKE-DIRECT-SLOT-DEFINITION) CLASS SLOT-PROPERTIES))) DIRECT-SLOTS))) (SETF (CLASS-DIRECT-SLOTS CLASS) SLOTS) (DOLIST (DIRECT-SLOT SLOTS) (DOLIST (READER (SLOT-DEFINITION-READERS DIRECT-SLOT)) (ADD-READER-METHOD CLASS READER DIRECT-SLOT)) (DOLIST (WRITER (SLOT-DEFINITION-WRITERS DIRECT-SLOT)) (ADD-WRITER-METHOD CLASS WRITER DIRECT-SLOT))))) (WHEN DIRECT-DEFAULT-INITARGS-P (SETF (CLASS-DIRECT-DEFAULT-INITARGS CLASS) DIRECT-DEFAULT-INITARGS)) (MAYBE-FINALIZE-CLASS-SUBTREE CLASS) (MAP-DEPENDENTS CLASS (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT CLASS DEP ALL-KEYS)))))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :AFTER ((CLASS STANDARD-CLASS) &REST ALL-KEYS) (APPLY (FUNCTION STD-AFTER-REINITIALIZATION-FOR-CLASSES) CLASS ALL-KEYS))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :AFTER ((CLASS FUNCALLABLE-STANDARD-CLASS) &REST ALL-KEYS) (APPLY (FUNCTION STD-AFTER-REINITIALIZATION-FOR-CLASSES) CLASS ALL-KEYS))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :BEFORE ((GF STANDARD-GENERIC-FUNCTION) &KEY (LAMBDA-LIST NIL LAMBDA-LIST-SUPPLIED-P) &ALLOW-OTHER-KEYS) (WHEN LAMBDA-LIST-SUPPLIED-P (UNLESS (OR (NULL (GENERIC-FUNCTION-METHODS GF)) (LAMBDA-LISTS-CONGRUENT-P LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF))) (ERROR "The lambda list ~S is incompatible with the existing methods of ~S." LAMBDA-LIST GF))))
     [java] ; (DEFMETHOD REINITIALIZE-INSTANCE :AFTER ((GF STANDARD-GENERIC-FUNCTION) &REST ALL-KEYS) (MAP-DEPENDENTS GF (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GF DEP ALL-KEYS)))))
     [java] ; (ATOMIC-DEFGENERIC FINALIZE-INHERITANCE (CLASS) (:METHOD ((CLASS STANDARD-CLASS)) (STD-FINALIZE-INHERITANCE CLASS)) (:METHOD ((CLASS FUNCALLABLE-STANDARD-CLASS)) (STD-FINALIZE-INHERITANCE CLASS)))
     [java] ; (ATOMIC-DEFGENERIC COMPUTE-DEFAULT-INITARGS (CLASS) (:METHOD ((CLASS STANDARD-CLASS)) (STD-COMPUTE-DEFAULT-INITARGS CLASS)) (:METHOD ((CLASS FUNCALLABLE-STANDARD-CLASS)) (STD-COMPUTE-DEFAULT-INITARGS CLASS)))
     [java] ; (DEFGENERIC COMPUTE-CLASS-PRECEDENCE-LIST (CLASS))
     [java] ; (DEFMETHOD COMPUTE-CLASS-PRECEDENCE-LIST ((CLASS STANDARD-CLASS)) (STD-COMPUTE-CLASS-PRECEDENCE-LIST CLASS))
     [java] ; (DEFMETHOD COMPUTE-CLASS-PRECEDENCE-LIST ((CLASS FUNCALLABLE-STANDARD-CLASS)) (STD-COMPUTE-CLASS-PRECEDENCE-LIST CLASS))
     [java] ; (DEFGENERIC COMPUTE-SLOTS (CLASS))
     [java] ; (DEFMETHOD COMPUTE-SLOTS ((CLASS STANDARD-CLASS)) (STD-COMPUTE-SLOTS CLASS))
     [java] ; (DEFMETHOD COMPUTE-SLOTS ((CLASS FUNCALLABLE-STANDARD-CLASS)) (STD-COMPUTE-SLOTS CLASS))
     [java] ; (DEFGENERIC COMPUTE-EFFECTIVE-SLOT-DEFINITION (CLASS NAME DIRECT-SLOTS))
     [java] ; (DEFMETHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION ((CLASS STANDARD-CLASS) NAME DIRECT-SLOTS) (STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION CLASS NAME DIRECT-SLOTS))
     [java] ; (DEFMETHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION ((CLASS FUNCALLABLE-STANDARD-CLASS) NAME DIRECT-SLOTS) (STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION CLASS NAME DIRECT-SLOTS))
     [java] ; (DEFGENERIC COMPUTE-DISCRIMINATING-FUNCTION (GF))
     [java] ; (DEFMETHOD COMPUTE-DISCRIMINATING-FUNCTION ((GF STANDARD-GENERIC-FUNCTION)) (STD-COMPUTE-DISCRIMINATING-FUNCTION GF))
     [java] ; (DEFGENERIC METHOD-MORE-SPECIFIC-P (GF METHOD1 METHOD2 REQUIRED-CLASSES))
     [java] ; (DEFMETHOD METHOD-MORE-SPECIFIC-P ((GF STANDARD-GENERIC-FUNCTION) METHOD1 METHOD2 REQUIRED-CLASSES) (LET ((METHOD-INDICES (ARGUMENT-PRECEDENCE-ORDER-INDICES (GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER GF) (GETF (ANALYZE-LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GF)) (QUOTE :REQUIRED-ARGS))))) (STD-METHOD-MORE-SPECIFIC-P METHOD1 METHOD2 REQUIRED-CLASSES METHOD-INDICES)))
     [java] ; (DEFGENERIC COMPUTE-EFFECTIVE-METHOD (GF METHOD-COMBINATION METHODS))
     [java] ; (DEFMETHOD COMPUTE-EFFECTIVE-METHOD ((GF STANDARD-GENERIC-FUNCTION) METHOD-COMBINATION METHODS) (STD-COMPUTE-EFFECTIVE-METHOD GF METHOD-COMBINATION METHODS))
     [java] ; (DEFGENERIC COMPUTE-APPLICABLE-METHODS (GF ARGS))
     [java] ; (DEFMETHOD COMPUTE-APPLICABLE-METHODS ((GF STANDARD-GENERIC-FUNCTION) ARGS) (STD-COMPUTE-APPLICABLE-METHODS GF ARGS))
     [java] ; (ATOMIC-DEFGENERIC MAKE-METHOD-LAMBDA (GENERIC-FUNCTION METHOD LAMBDA-EXPRESSION ENVIRONMENT) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) (METHOD STANDARD-METHOD) LAMBDA-EXPRESSION ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (VALUES (COMPUTE-METHOD-FUNCTION LAMBDA-EXPRESSION) NIL)))
     [java] ; (DEFMACRO SLOT-DEFINITION-DISPATCH (SLOT-DEFINITION STD-FORM GENERIC-FORM) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE $CL) (SYSTEM::BACKQ-LIST (QUOTE CLASS-OF) SLOT-DEFINITION))) (SYSTEM::BACKQ-LIST (QUOTE CASE) (QUOTE $CL) (SYSTEM::BACKQ-LIST (QUOTE (+THE-STANDARD-SLOT-DEFINITION-CLASS+ +THE-STANDARD-DIRECT-SLOT-DEFINITION-CLASS+ +THE-STANDARD-EFFECTIVE-SLOT-DEFINITION-CLASS+)) STD-FORM) (SYSTEM::BACKQ-LIST (QUOTE T) GENERIC-FORM))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-ALLOCATION (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-ALLOCATION) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-INITARGS (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-INITARGS) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITARGS)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-INITFORM (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-INITFORM) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFORM)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-INITFUNCTION (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-INITFUNCTION) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::INITFUNCTION)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-NAME (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)) (SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-NAME) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE NAME)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-READERS (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-READERS) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::READERS)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-WRITERS (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-WRITERS) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::WRITERS)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-ALLOCATION-CLASS (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-ALLOCATION-CLASS) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::ALLOCATION-CLASS)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-LOCATION (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-LOCATION) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::LOCATION)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-TYPE (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)) (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-TYPE) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE SYSTEM::%TYPE)) VALUE))))
     [java] ; (ATOMIC-DEFGENERIC SLOT-DEFINITION-DOCUMENTATION (SLOT-DEFINITION) (:METHOD ((SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)) (SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)))))
     [java] ; (ATOMIC-DEFGENERIC (SETF SLOT-DEFINITION-DOCUMENTATION) (VALUE SLOT-DEFINITION) (:METHOD (VALUE (SLOT-DEFINITION SLOT-DEFINITION)) (SLOT-DEFINITION-DISPATCH SLOT-DEFINITION (SETF (STD-SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)) VALUE) (SETF (SLOT-VALUE SLOT-DEFINITION (QUOTE %DOCUMENTATION)) VALUE))))
     [java] ; (DEFMACRO DEFINE-CONDITION (NAME (&REST PARENT-TYPES) (&REST SLOT-SPECS) &BODY OPTIONS) (LET ((PARENT-TYPES (OR PARENT-TYPES (QUOTE (CONDITION)))) (REPORT NIL)) (DOLIST (OPTION OPTIONS) (WHEN (EQ (CAR OPTION) :REPORT) (SETF REPORT (CADR OPTION)) (SETF OPTIONS (DELETE OPTION OPTIONS :TEST (FUNCTION EQUAL))) (RETURN))) (TYPECASE REPORT (NULL (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:CONDITION))) (SYSTEM::BACKQ-LIST* (QUOTE DEFCLASS) NAME PARENT-TYPES SLOT-SPECS OPTIONS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME))) (STRING (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:CONDITION))) (SYSTEM::BACKQ-LIST* (QUOTE DEFCLASS) NAME PARENT-TYPES SLOT-SPECS OPTIONS) (SYSTEM::BACKQ-LIST (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE CONDITION) NAME) (QUOTE (STREAM))) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE *PRINT-ESCAPE*) (QUOTE (CALL-NEXT-METHOD)) (SYSTEM::BACKQ-LIST* (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE WRITE-STRING) REPORT (QUOTE (STREAM))) (QUOTE (CONDITION))))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME))) (T (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:CONDITION))) (SYSTEM::BACKQ-LIST* (QUOTE DEFCLASS) NAME PARENT-TYPES SLOT-SPECS OPTIONS) (SYSTEM::BACKQ-LIST (QUOTE DEFMETHOD) (QUOTE PRINT-OBJECT) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE CONDITION) NAME) (QUOTE (STREAM))) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE *PRINT-ESCAPE*) (QUOTE (CALL-NEXT-METHOD)) (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) REPORT) (QUOTE (CONDITION STREAM))))) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME))))))
     [java] ; (DEFUN MAKE-CONDITION (TYPE &REST INITARGS) (OR (%MAKE-CONDITION TYPE INITARGS) (LET ((CLASS (IF (SYMBOLP TYPE) (FIND-CLASS TYPE) TYPE))) (APPLY (FUNCTION MAKE-INSTANCE) CLASS INITARGS))))
     [java] ; (DEFUN COERCE-TO-CONDITION (DATUM ARGUMENTS DEFAULT-TYPE FUN-NAME) (COND ((TYPEP DATUM (QUOTE CONDITION)) (WHEN ARGUMENTS (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM ARGUMENTS :EXPECTED-TYPE (QUOTE NULL) :FORMAT-CONTROL "You may not supply additional arguments when giving ~S to ~S." :FORMAT-ARGUMENTS (LIST DATUM FUN-NAME))) DATUM) ((SYMBOLP DATUM) (APPLY (FUNCTION MAKE-CONDITION) DATUM ARGUMENTS)) ((OR (STRINGP DATUM) (FUNCTIONP DATUM)) (MAKE-CONDITION DEFAULT-TYPE :FORMAT-CONTROL DATUM :FORMAT-ARGUMENTS ARGUMENTS)) (T (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM DATUM :EXPECTED-TYPE (QUOTE (OR SYMBOL STRING)) :FORMAT-CONTROL "Bad argument to ~S: ~S." :FORMAT-ARGUMENTS (LIST FUN-NAME DATUM)))))
     [java] ; (DEFGENERIC MAKE-LOAD-FORM (OBJECT &OPTIONAL ENVIRONMENT))
     [java] ; (DEFMETHOD MAKE-LOAD-FORM ((OBJECT T) &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (APPLY (FUNCTION NO-APPLICABLE-METHOD) (FUNCTION MAKE-LOAD-FORM) (LIST OBJECT)))
     [java] ; (DEFMETHOD MAKE-LOAD-FORM ((CLASS CLASS) &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (LET ((NAME (CLASS-NAME CLASS))) (UNLESS (AND NAME (EQ (FIND-CLASS NAME NIL) CLASS)) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "Can't use anonymous or undefined class as a constant: ~S." :FORMAT-ARGUMENTS (LIST CLASS))) (SYSTEM::BACKQ-LIST (QUOTE FIND-CLASS) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) NAME))))
     [java] ; (DEFUN INVALID-METHOD-ERROR (METHOD FORMAT-CONTROL &REST ARGS) (LET ((MESSAGE (APPLY (FUNCTION FORMAT) NIL FORMAT-CONTROL ARGS))) (ERROR "Invalid method error for ~S:~%    ~A" METHOD MESSAGE)))
     [java] ; (DEFUN METHOD-COMBINATION-ERROR (FORMAT-CONTROL &REST ARGS) (LET ((MESSAGE (APPLY (FUNCTION FORMAT) NIL FORMAT-CONTROL ARGS))) (ERROR "Method combination error in CLOS dispatch:~%    ~A" MESSAGE)))
     [java] ; (ATOMIC-DEFGENERIC NO-APPLICABLE-METHOD (GENERIC-FUNCTION &REST ARGS) (:METHOD (GENERIC-FUNCTION &REST ARGS) (ERROR "There is no applicable method for the generic function ~S ~
     [java]               when called with arguments ~S." GENERIC-FUNCTION ARGS)))
     [java] ; (DEFGENERIC FIND-METHOD (GENERIC-FUNCTION QUALIFIERS SPECIALIZERS &OPTIONAL ERRORP))
     [java] ; (DEFMETHOD FIND-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) QUALIFIERS SPECIALIZERS &OPTIONAL (ERRORP T)) (%FIND-METHOD GENERIC-FUNCTION QUALIFIERS SPECIALIZERS ERRORP))
     [java] ; (DEFGENERIC FIND-METHOD ((GENERIC-FUNCTION SYMBOL) QUALIFIERS SPECIALIZERS &OPTIONAL (ERRORP T)) (FIND-METHOD (FIND-GENERIC-FUNCTION GENERIC-FUNCTION ERRORP) QUALIFIERS SPECIALIZERS ERRORP))
     [java] ; (DEFGENERIC ADD-METHOD (GENERIC-FUNCTION METHOD))
     [java] ; (DEFMETHOD ADD-METHOD :BEFORE ((GENERIC-FUNCTION GENERIC-FUNCTION) (METHOD METHOD)) (WHEN (AND (METHOD-GENERIC-FUNCTION METHOD) (NOT (EQL GENERIC-FUNCTION (METHOD-GENERIC-FUNCTION METHOD)))) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "~S is already a method of ~S, cannot add to ~S." :FORMAT-ARGUMENTS (LIST METHOD (METHOD-GENERIC-FUNCTION METHOD) GENERIC-FUNCTION))) (CHECK-METHOD-LAMBDA-LIST (GENERIC-FUNCTION-NAME GENERIC-FUNCTION) (METHOD-LAMBDA-LIST METHOD) (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)))
     [java] ; (DEFMETHOD ADD-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) (METHOD STANDARD-METHOD)) (STD-ADD-METHOD GENERIC-FUNCTION METHOD))
     [java] ; (DEFMETHOD ADD-METHOD :AFTER ((GENERIC-FUNCTION GENERIC-FUNCTION) (METHOD METHOD)) (MAP-DEPENDENTS GENERIC-FUNCTION (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GENERIC-FUNCTION DEP (QUOTE ADD-METHOD) METHOD)))))
     [java] ; (DEFGENERIC REMOVE-METHOD (GENERIC-FUNCTION METHOD))
     [java] ; (DEFMETHOD REMOVE-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION) (METHOD STANDARD-METHOD)) (STD-REMOVE-METHOD GENERIC-FUNCTION METHOD))
     [java] ; (DEFMETHOD REMOVE-METHOD :AFTER ((GENERIC-FUNCTION GENERIC-FUNCTION) (METHOD METHOD)) (MAP-DEPENDENTS GENERIC-FUNCTION (FUNCTION (LAMBDA (DEP) (UPDATE-DEPENDENT GENERIC-FUNCTION DEP (QUOTE REMOVE-METHOD) METHOD)))))
     [java] ; (DEFGENERIC DESCRIBE-OBJECT (OBJECT STREAM))
     [java] ; (DEFGENERIC NO-NEXT-METHOD (GENERIC-FUNCTION METHOD &REST ARGS))
     [java] ; (ATOMIC-DEFGENERIC FUNCTION-KEYWORDS (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-FUNCTION-KEYWORDS METHOD)))
     [java] ; (SETF *GF-INITIALIZE-INSTANCE* (SYMBOL-FUNCTION (QUOTE INITIALIZE-INSTANCE)))
     [java] ; (SETF *GF-ALLOCATE-INSTANCE* (SYMBOL-FUNCTION (QUOTE ALLOCATE-INSTANCE)))
     [java] ; (SETF *GF-SHARED-INITIALIZE* (SYMBOL-FUNCTION (QUOTE SHARED-INITIALIZE)))
     [java] ; (SETF *GF-REINITIALIZE-INSTANCE* (SYMBOL-FUNCTION (QUOTE REINITIALIZE-INSTANCE)))
     [java] ; (SETF *CLOS-BOOTING* NIL)
     [java] ; (ATOMIC-DEFGENERIC CLASS-PROTOTYPE (CLASS) (:METHOD ((CLASS STANDARD-CLASS)) (ALLOCATE-INSTANCE CLASS)) (:METHOD ((CLASS FUNCALLABLE-STANDARD-CLASS)) (ALLOCATE-INSTANCE CLASS)) (:METHOD ((CLASS STRUCTURE-CLASS)) (ALLOCATE-INSTANCE CLASS)) (:METHOD :BEFORE (CLASS) (UNLESS (CLASS-FINALIZED-P CLASS) (ERROR "~@<~S is not finalized.~:@>" CLASS))))
     [java] ; (DEFMETHOD SHARED-INITIALIZE :BEFORE ((INSTANCE GENERIC-FUNCTION) SLOT-NAMES &KEY LAMBDA-LIST ARGUMENT-PRECEDENCE-ORDER &ALLOW-OTHER-KEYS) (CHECK-ARGUMENT-PRECEDENCE-ORDER LAMBDA-LIST ARGUMENT-PRECEDENCE-ORDER))
     [java] ; (DEFMETHOD SHARED-INITIALIZE :AFTER ((INSTANCE STANDARD-GENERIC-FUNCTION) SLOT-NAMES &KEY LAMBDA-LIST ARGUMENT-PRECEDENCE-ORDER (METHOD-COMBINATION (QUOTE (STANDARD))) &ALLOW-OTHER-KEYS) (LET* ((PLIST (ANALYZE-LAMBDA-LIST LAMBDA-LIST)) (REQUIRED-ARGS (GETF PLIST (QUOTE :REQUIRED-ARGS)))) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::REQUIRED-ARGS)) REQUIRED-ARGS) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::OPTIONAL-ARGS)) (GETF PLIST :OPTIONAL-ARGS)) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::ARGUMENT-PRECEDENCE-ORDER)) (OR ARGUMENT-PRECEDENCE-ORDER REQUIRED-ARGS))) (UNLESS (TYPEP (GENERIC-FUNCTION-METHOD-COMBINATION INSTANCE) (QUOTE METHOD-COMBINATION)) (SETF (STD-SLOT-VALUE INSTANCE (QUOTE SYSTEM::%METHOD-COMBINATION)) (FIND-METHOD-COMBINATION INSTANCE (CAR METHOD-COMBINATION) (CDR METHOD-COMBINATION)))) (FINALIZE-STANDARD-GENERIC-FUNCTION INSTANCE))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::ARGUMENT-PRECEDENCE-ORDER))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-DECLARATIONS (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::DECLARATIONS))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::LAMBDA-LIST))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-METHOD-CLASS (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::METHOD-CLASS))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-METHOD-COMBINATION (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::%METHOD-COMBINATION))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-METHODS (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::METHODS))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-NAME (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (SLOT-VALUE GENERIC-FUNCTION (QUOTE NAME))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-REQUIRED-ARGUMENTS (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::REQUIRED-ARGS))))
     [java] ; (ATOMIC-DEFGENERIC GENERIC-FUNCTION-OPTIONAL-ARGUMENTS (GENERIC-FUNCTION) (:METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)) (STD-SLOT-VALUE GENERIC-FUNCTION (QUOTE SYSTEM::OPTIONAL-ARGS))))
     [java] ; (DEFGENERIC (SETF GENERIC-FUNCTION-NAME) (NEW-VALUE GF) (:METHOD (NEW-VALUE (GF GENERIC-FUNCTION)) (REINITIALIZE-INSTANCE GF :NAME NEW-VALUE)))
     [java] ; (ATOMIC-DEFGENERIC METHOD-FUNCTION (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-METHOD-FUNCTION METHOD)))
     [java] ; (ATOMIC-DEFGENERIC METHOD-GENERIC-FUNCTION (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-METHOD-GENERIC-FUNCTION METHOD)))
     [java] ; (ATOMIC-DEFGENERIC METHOD-LAMBDA-LIST (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-SLOT-VALUE METHOD (QUOTE SYSTEM::LAMBDA-LIST))))
     [java] ; (ATOMIC-DEFGENERIC METHOD-SPECIALIZERS (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-METHOD-SPECIALIZERS METHOD)))
     [java] ; (ATOMIC-DEFGENERIC METHOD-QUALIFIERS (METHOD) (:METHOD ((METHOD STANDARD-METHOD)) (STD-METHOD-QUALIFIERS METHOD)))
     [java] ; (ATOMIC-DEFGENERIC ACCESSOR-METHOD-SLOT-DEFINITION (METHOD) (:METHOD ((METHOD STANDARD-ACCESSOR-METHOD)) (STD-ACCESSOR-METHOD-SLOT-DEFINITION METHOD)))
     [java] ; (ATOMIC-DEFGENERIC FIND-METHOD-COMBINATION (GF NAME OPTIONS) (:METHOD (GF (NAME SYMBOL) OPTIONS) (STD-FIND-METHOD-COMBINATION GF NAME OPTIONS)))
     [java] ; (DEFGENERIC SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (SPECIALIZER))
     [java] ; (DEFMETHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS ((SPECIALIZER CLASS)) (DELETE-DUPLICATES (MAPCAR (FUNCTION METHOD-GENERIC-FUNCTION) (CLASS-DIRECT-METHODS SPECIALIZER))))
     [java] ; (DEFMETHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS ((SPECIALIZER EQL-SPECIALIZER)) (DELETE-DUPLICATES (MAPCAR (FUNCTION METHOD-GENERIC-FUNCTION) (SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)))))
     [java] ; (DEFGENERIC SPECIALIZER-DIRECT-METHODS (SPECIALIZER))
     [java] ; (DEFMETHOD SPECIALIZER-DIRECT-METHODS ((SPECIALIZER CLASS)) (CLASS-DIRECT-METHODS SPECIALIZER))
     [java] ; (DEFMETHOD SPECIALIZER-DIRECT-METHODS ((SPECIALIZER EQL-SPECIALIZER)) (SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)))
     [java] ; (ATOMIC-DEFGENERIC ADD-DIRECT-METHOD (SPECIALIZER METHOD) (:METHOD ((SPECIALIZER CLASS) (METHOD METHOD)) (PUSHNEW METHOD (CLASS-DIRECT-METHODS SPECIALIZER))) (:METHOD ((SPECIALIZER EQL-SPECIALIZER) (METHOD METHOD)) (PUSHNEW METHOD (SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)))))
     [java] ; (ATOMIC-DEFGENERIC REMOVE-DIRECT-METHOD (SPECIALIZER METHOD) (:METHOD ((SPECIALIZER CLASS) (METHOD METHOD)) (SETF (CLASS-DIRECT-METHODS SPECIALIZER) (REMOVE METHOD (CLASS-DIRECT-METHODS SPECIALIZER)))) (:METHOD ((SPECIALIZER EQL-SPECIALIZER) (METHOD METHOD)) (SETF (SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS)) (REMOVE METHOD (SLOT-VALUE SPECIALIZER (QUOTE DIRECT-METHODS))))))
     [java] ; (DEFVAR *DEPENDENTS* (MAKE-HASH-TABLE :TEST (QUOTE EQ) :WEAKNESS :KEY))
     [java] ; (DEFGENERIC ADD-DEPENDENT (METAOBJECT DEPENDENT))
     [java] ; (DEFMETHOD ADD-DEPENDENT ((METAOBJECT STANDARD-CLASS) DEPENDENT) (PUSHNEW DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)))
     [java] ; (DEFMETHOD ADD-DEPENDENT ((METAOBJECT FUNCALLABLE-STANDARD-CLASS) DEPENDENT) (PUSHNEW DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)))
     [java] ; (DEFMETHOD ADD-DEPENDENT ((METAOBJECT STANDARD-GENERIC-FUNCTION) DEPENDENT) (PUSHNEW DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)))
     [java] ; (DEFGENERIC REMOVE-DEPENDENT (METAOBJECT DEPENDENT))
     [java] ; (DEFMETHOD REMOVE-DEPENDENT ((METAOBJECT STANDARD-CLASS) DEPENDENT) (SETF (GETHASH METAOBJECT *DEPENDENTS*) (DELETE DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL) :TEST (FUNCTION EQ))))
     [java] ; (DEFMETHOD REMOVE-DEPENDENT ((METAOBJECT FUNCALLABLE-STANDARD-CLASS) DEPENDENT) (SETF (GETHASH METAOBJECT *DEPENDENTS*) (DELETE DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL) :TEST (FUNCTION EQ))))
     [java] ; (DEFMETHOD REMOVE-DEPENDENT ((METAOBJECT STANDARD-GENERIC-FUNCTION) DEPENDENT) (SETF (GETHASH METAOBJECT *DEPENDENTS*) (DELETE DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL) :TEST (FUNCTION EQ))))
     [java] ; (ATOMIC-DEFGENERIC MAP-DEPENDENTS (METAOBJECT FUNCTION) (:METHOD ((METAOBJECT STANDARD-CLASS) FUNCTION) (DOLIST (DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)) (FUNCALL FUNCTION DEPENDENT))) (:METHOD ((METAOBJECT FUNCALLABLE-STANDARD-CLASS) FUNCTION) (DOLIST (DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)) (FUNCALL FUNCTION DEPENDENT))) (:METHOD ((METAOBJECT STANDARD-GENERIC-FUNCTION) FUNCTION) (DOLIST (DEPENDENT (GETHASH METAOBJECT *DEPENDENTS* NIL)) (FUNCALL FUNCTION DEPENDENT))))
     [java] ; (DEFGENERIC UPDATE-DEPENDENT (METAOBJECT DEPENDENT &REST INITARGS))
     [java] ; (DEFGENERIC ENSURE-GENERIC-FUNCTION-USING-CLASS (GENERIC-FUNCTION FUNCTION-NAME &KEY ARGUMENT-PRECEDENCE-ORDER DECLARATIONS DOCUMENTATION GENERIC-FUNCTION-CLASS LAMBDA-LIST METHOD-CLASS METHOD-COMBINATION NAME &ALLOW-OTHER-KEYS))
     [java] ; (DEFMETHOD ENSURE-GENERIC-FUNCTION-USING-CLASS ((GENERIC-FUNCTION GENERIC-FUNCTION) FUNCTION-NAME &REST ALL-KEYS &KEY (GENERIC-FUNCTION-CLASS (CLASS-OF GENERIC-FUNCTION)) (METHOD-CLASS (GENERIC-FUNCTION-METHOD-CLASS GENERIC-FUNCTION)) (METHOD-COMBINATION (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION)) &ALLOW-OTHER-KEYS) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :GENERIC-FUNCTION-CLASS) (UNLESS (CLASSP GENERIC-FUNCTION-CLASS) (SETF GENERIC-FUNCTION-CLASS (FIND-CLASS GENERIC-FUNCTION-CLASS))) (UNLESS (CLASSP METHOD-CLASS) (SETF METHOD-CLASS (FIND-CLASS METHOD-CLASS))) (UNLESS (EQ GENERIC-FUNCTION-CLASS (CLASS-OF GENERIC-FUNCTION)) (ERROR "The class ~S is incompatible with the existing class (~S) of ~S." GENERIC-FUNCTION-CLASS (CLASS-OF GENERIC-FUNCTION) GENERIC-FUNCTION)) (UNLESS (TYPEP METHOD-COMBINATION (QUOTE METHOD-COMBINATION)) (SETF METHOD-COMBINATION (FIND-METHOD-COMBINATION GENERIC-FUNCTION (CAR METHOD-COMBINATION) (CDR METHOD-COMBINATION)))) (APPLY (FUNCTION REINITIALIZE-INSTANCE) GENERIC-FUNCTION :METHOD-COMBINATION METHOD-COMBINATION :METHOD-CLASS METHOD-CLASS ALL-KEYS) GENERIC-FUNCTION)
     [java] ; (DEFMETHOD ENSURE-GENERIC-FUNCTION-USING-CLASS ((GENERIC-FUNCTION NULL) FUNCTION-NAME &REST ALL-KEYS &KEY (GENERIC-FUNCTION-CLASS +THE-STANDARD-GENERIC-FUNCTION-CLASS+) &ALLOW-OTHER-KEYS) (SETF ALL-KEYS (COPY-LIST ALL-KEYS)) (REMF ALL-KEYS :GENERIC-FUNCTION-CLASS) (UNLESS (CLASSP GENERIC-FUNCTION-CLASS) (SETF GENERIC-FUNCTION-CLASS (FIND-CLASS GENERIC-FUNCTION-CLASS))) (WHEN (AND (NULL *CLOS-BOOTING*) (FBOUNDP FUNCTION-NAME)) (IF (OR (AUTOLOADP FUNCTION-NAME) (AND (CONSP FUNCTION-NAME) (EQ (QUOTE SETF) (FIRST FUNCTION-NAME)) (AUTOLOAD-REF-P (SECOND FUNCTION-NAME)))) (FMAKUNBOUND FUNCTION-NAME) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~A already names an ordinary function, macro, or special operator." :FORMAT-ARGUMENTS (LIST FUNCTION-NAME)))) (APPLY (IF (EQ GENERIC-FUNCTION-CLASS +THE-STANDARD-GENERIC-FUNCTION-CLASS+) (FUNCTION MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION) (FUNCTION MAKE-INSTANCE)) GENERIC-FUNCTION-CLASS :NAME FUNCTION-NAME ALL-KEYS))
     [java] ; (DEFUN ENSURE-GENERIC-FUNCTION (FUNCTION-NAME &REST ALL-KEYS &KEY LAMBDA-LIST GENERIC-FUNCTION-CLASS METHOD-CLASS METHOD-COMBINATION ARGUMENT-PRECEDENCE-ORDER DECLARATIONS DOCUMENTATION &ALLOW-OTHER-KEYS) (DECLARE (IGNORE LAMBDA-LIST GENERIC-FUNCTION-CLASS METHOD-CLASS METHOD-COMBINATION ARGUMENT-PRECEDENCE-ORDER DECLARATIONS DOCUMENTATION)) (APPLY (FUNCTION ENSURE-GENERIC-FUNCTION-USING-CLASS) (FIND-GENERIC-FUNCTION FUNCTION-NAME NIL) FUNCTION-NAME ALL-KEYS))
     [java] ; (DEFUN %METHOD-GENERIC-FUNCTION (METHOD) (METHOD-GENERIC-FUNCTION METHOD))
     [java] ; (DEFUN %METHOD-FUNCTION (METHOD) (METHOD-FUNCTION METHOD))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/clos.abcl (43.489 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/clos.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/clos.abcl (5.37 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/mop.lisp ...
     [java] ; (IN-PACKAGE #:MOP)
     [java] ; (DEFGENERIC VALIDATE-SUPERCLASS (CLASS SUPERCLASS) (:DOCUMENTATION "This generic function is called to determine whether the class
     [java]   superclass is suitable for use as a superclass of class."))
     [java] ; (DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS) (SUPERCLASS CLASS)) (OR (EQL SUPERCLASS +THE-T-CLASS+) (EQL (CLASS-OF CLASS) (CLASS-OF SUPERCLASS)) (OR (AND (EQL (CLASS-OF CLASS) +THE-STANDARD-CLASS+) (EQL (CLASS-OF SUPERCLASS) +THE-FUNCALLABLE-STANDARD-CLASS+)) (AND (EQL (CLASS-OF CLASS) +THE-FUNCALLABLE-STANDARD-CLASS+) (EQL (CLASS-OF SUPERCLASS) +THE-STANDARD-CLASS+)))))
     [java] ; (DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS) (SUPERCLASS FORWARD-REFERENCED-CLASS)) T)
     [java] ; (DEFMETHOD SHARED-INITIALIZE :BEFORE ((INSTANCE CLASS) SLOT-NAMES &KEY DIRECT-SUPERCLASSES &ALLOW-OTHER-KEYS) (DECLARE (IGNORE SLOT-NAMES)) (DOLIST (SUPERCLASS DIRECT-SUPERCLASSES) (ASSERT (VALIDATE-SUPERCLASS INSTANCE SUPERCLASS) (INSTANCE SUPERCLASS) "Class ~S is not compatible with superclass ~S" INSTANCE SUPERCLASS)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/mop.abcl (0.228 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/mop.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/mop.abcl (0.033 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/collect.lisp ...
     [java] ; (IN-PACKAGE "EXT")
     [java] ; (DEFUN COLLECT-NORMAL-EXPANDER (N-VALUE FUN FORMS) (SYSTEM::BACKQ-CONS (QUOTE PROGN) (SYSTEM::BACKQ-APPEND (MAPCAR (FUNCTION (LAMBDA (FORM) (SYSTEM::BACKQ-LIST (QUOTE SETQ) N-VALUE (SYSTEM::BACKQ-LIST FUN FORM N-VALUE)))) FORMS) (SYSTEM::BACKQ-LIST N-VALUE))))
     [java] ; (DEFUN COLLECT-LIST-EXPANDER (N-VALUE N-TAIL FORMS) (LET ((N-RES (GENSYM))) (SYSTEM::BACKQ-CONS (QUOTE PROGN) (SYSTEM::BACKQ-APPEND (MAPCAR (FUNCTION (LAMBDA (FORM) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST N-RES (SYSTEM::BACKQ-LIST* (QUOTE CONS) FORM (QUOTE (NIL))))) (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-LIST N-TAIL (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE CDR) N-TAIL) N-RES) (SYSTEM::BACKQ-LIST (QUOTE SETQ) N-TAIL N-RES)) (SYSTEM::BACKQ-LIST (QUOTE T) (SYSTEM::BACKQ-LIST (QUOTE SETQ) N-TAIL N-RES N-VALUE N-RES)))))) FORMS) (SYSTEM::BACKQ-LIST N-VALUE)))))
     [java] ; (DEFMACRO COLLECT (COLLECTIONS &BODY BODY) "Collect ({(Name [Initial-Value] [Function])}*) {Form}*
     [java]   Collect some values somehow.  Each of the collections specifies a bunch of
     [java]   things which collected during the evaluation of the body of the form.  The
     [java]   name of the collection is used to define a local macro, a la MACROLET.
     [java]   Within the body, this macro will evaluate each of its arguments and collect
     [java]   the result, returning the current value after the collection is done.  The
     [java]   body is evaluated as a PROGN; to get the final values when you are done, just
     [java]   call the collection macro with no arguments.
     [java]
     [java]   Initial-Value is the value that the collection starts out with, which
     [java]   defaults to NIL.  Function is the function which does the collection.  It is
     [java]   a function which will accept two arguments: the value to be collected and the
     [java]   current collection.  The result of the function is made the new value for the
     [java]   collection.  As a totally magical special-case, the Function may be Collect,
     [java]   which tells us to build a list in forward order; this is the default.  If an
     [java]   Initial-Value is supplied for Collect, the stuff will be rplacd'd onto the
     [java]   end.  Note that Function may be anything that can appear in the functional
     [java]   position, including macros and lambdas." (LET ((MACROS NIL) (BINDS NIL)) (DOLIST (SPEC COLLECTIONS) (UNLESS (<= 1 (LENGTH SPEC) 3) (ERROR "Malformed collection specifier: ~S." SPEC)) (LET ((N-VALUE (GENSYM)) (NAME (FIRST SPEC)) (DEFAULT (SECOND SPEC)) (KIND (OR (THIRD SPEC) (QUOTE COLLECT)))) (PUSH (SYSTEM::BACKQ-LIST N-VALUE DEFAULT) BINDS) (IF (EQ KIND (QUOTE COLLECT)) (LET ((N-TAIL (GENSYM))) (IF DEFAULT (PUSH (SYSTEM::BACKQ-LIST N-TAIL (SYSTEM::BACKQ-LIST (QUOTE LAST) N-VALUE)) BINDS) (PUSH N-TAIL BINDS)) (PUSH (SYSTEM::BACKQ-LIST NAME (QUOTE (&REST ARGS)) (SYSTEM::BACKQ-LIST* (QUOTE COLLECT-LIST-EXPANDER) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) N-VALUE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) N-TAIL) (QUOTE (ARGS)))) MACROS)) (PUSH (SYSTEM::BACKQ-LIST NAME (QUOTE (&REST ARGS)) (SYSTEM::BACKQ-LIST* (QUOTE COLLECT-NORMAL-EXPANDER) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) N-VALUE) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) KIND) (QUOTE (ARGS)))) MACROS)))) (SYSTEM::BACKQ-LIST (QUOTE MACROLET) MACROS (SYSTEM::BACKQ-LIST* (QUOTE LET*) (NREVERSE BINDS) BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/collect.abcl (0.389 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/macros.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO IN-PACKAGE (NAME) (BACKQ-LIST (QUOTE %IN-PACKAGE) (STRING NAME)))
     [java] ; (DEFMACRO WHEN (TEST-FORM &REST BODY) (IF (CDR BODY) (BACKQ-LIST (QUOTE IF) TEST-FORM (BACKQ-CONS (QUOTE PROGN) BODY)) (BACKQ-LIST (QUOTE IF) TEST-FORM (CAR BODY))))
     [java] ; (DEFMACRO UNLESS (TEST-FORM &REST BODY) (IF (CDR BODY) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE NOT) TEST-FORM) (BACKQ-CONS (QUOTE PROGN) BODY)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE NOT) TEST-FORM) (CAR BODY))))
     [java] ; (DEFMACRO RETURN (&OPTIONAL RESULT) (BACKQ-LIST (QUOTE RETURN-FROM) NIL RESULT))
     [java] ; (DEFMACRO DEFCONSTANT (NAME INITIAL-VALUE &OPTIONAL DOCSTRING) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:CONSTANT))) (BACKQ-LIST (QUOTE %DEFCONSTANT) (BACKQ-LIST (QUOTE QUOTE) NAME) INITIAL-VALUE DOCSTRING)))
     [java] ; (DEFMACRO DEFPARAMETER (NAME INITIAL-VALUE &OPTIONAL DOCSTRING) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:VARIABLE))) (BACKQ-LIST (QUOTE %DEFPARAMETER) (BACKQ-LIST (QUOTE QUOTE) NAME) INITIAL-VALUE DOCSTRING)))
     [java] ; (DEFMACRO TRULY-THE (TYPE VALUE) (BACKQ-LIST (QUOTE THE) TYPE VALUE))
     [java] ; (DEFMACRO %CAR (X) (BACKQ-LIST (QUOTE CAR) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE CONS) X)))
     [java] ; (DEFMACRO %CDR (X) (BACKQ-LIST (QUOTE CDR) (BACKQ-LIST (QUOTE TRULY-THE) (QUOTE CONS) X)))
     [java] ; (DEFMACRO %CADR (X) (BACKQ-LIST (QUOTE %CAR) (BACKQ-LIST (QUOTE %CDR) X)))
     [java] ; (DEFMACRO %CADDR (X) (BACKQ-LIST (QUOTE %CAR) (BACKQ-LIST (QUOTE %CDR) (BACKQ-LIST (QUOTE %CDR) X))))
     [java] ; (DEFMACRO PROG1 (FIRST-FORM &REST FORMS) (LET ((RESULT (GENSYM))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST RESULT FIRST-FORM)) (BACKQ-APPEND FORMS (BACKQ-LIST RESULT)))))
     [java] ; (DEFMACRO PROG2 (FIRST-FORM SECOND-FORM &REST FORMS) (BACKQ-LIST* (QUOTE PROG1) (BACKQ-LIST (QUOTE PROGN) FIRST-FORM SECOND-FORM) FORMS))
     [java] ; (DEFMACRO PUSH (&ENVIRONMENT ENV ITEM PLACE) (IF (AND (SYMBOLP PLACE) (EQ PLACE (MACROEXPAND PLACE ENV))) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE CONS) ITEM PLACE)) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (LET ((G (GENSYM))) (BACKQ-LIST (QUOTE LET*) (BACKQ-CONS (BACKQ-LIST G ITEM) (BACKQ-APPEND (MAPCAR (FUNCTION LIST) DUMMIES VALS) (BACKQ-LIST (BACKQ-LIST (CAR NEWVAL) (BACKQ-LIST (QUOTE CONS) G GETTER))))) SETTER)))))
     [java] ; (DEFMACRO PUSHNEW (&ENVIRONMENT ENV ITEM PLACE &REST KEYS) (IF (AND (SYMBOLP PLACE) (EQ PLACE (MACROEXPAND PLACE ENV))) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST* (QUOTE ADJOIN) ITEM PLACE KEYS)) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (LET ((G (GENSYM))) (BACKQ-LIST (QUOTE LET*) (BACKQ-CONS (BACKQ-LIST G ITEM) (BACKQ-APPEND (MAPCAR (FUNCTION LIST) DUMMIES VALS) (BACKQ-LIST (BACKQ-LIST (CAR NEWVAL) (BACKQ-LIST* (QUOTE ADJOIN) G GETTER KEYS))))) SETTER)))))
     [java] ; (DEFMACRO POP (&ENVIRONMENT ENV PLACE) (IF (AND (SYMBOLP PLACE) (EQ PLACE (MACROEXPAND PLACE ENV))) (BACKQ-LIST (QUOTE PROG1) (BACKQ-LIST (QUOTE CAR) PLACE) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE CDR) PLACE))) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (DO* ((D DUMMIES (CDR D)) (V VALS (CDR V)) (LET-LIST NIL)) ((NULL D) (PUSH (LIST (CAR NEWVAL) GETTER) LET-LIST) (BACKQ-LIST (QUOTE LET*) (NREVERSE LET-LIST) (BACKQ-LIST (QUOTE PROG1) (BACKQ-LIST (QUOTE CAR) (CAR NEWVAL)) (BACKQ-LIST (QUOTE SETQ) (CAR NEWVAL) (BACKQ-LIST (QUOTE CDR) (CAR NEWVAL))) SETTER))) (PUSH (LIST (CAR D) (CAR V)) LET-LIST)))))
     [java] ; (DEFMACRO PSETQ (&ENVIRONMENT ENV &REST ARGS) (DO ((L ARGS (CDDR L)) (FORMS NIL) (BINDINGS NIL)) ((ENDP L) (LIST* (QUOTE LET*) (REVERSE BINDINGS) (REVERSE (CONS NIL FORMS)))) (IF (AND (SYMBOLP (CAR L)) (EQ (CAR L) (MACROEXPAND-1 (CAR L) ENV))) (LET ((SYM (GENSYM))) (PUSH (LIST SYM (CADR L)) BINDINGS) (PUSH (LIST (QUOTE SETQ) (CAR L) SYM) FORMS)) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION (MACROEXPAND-1 (CAR L) ENV) ENV) (DECLARE (IGNORE GETTER)) (DO ((D DUMMIES (CDR D)) (V VALS (CDR V))) ((NULL D)) (PUSH (LIST (CAR D) (CAR V)) BINDINGS)) (PUSH (LIST (CAR NEWVAL) (CADR L)) BINDINGS) (PUSH SETTER FORMS)))))
     [java] ; (DEFMACRO TIME (FORM) (BACKQ-LIST (QUOTE %TIME) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) NIL FORM))))
     [java] ; (DEFMACRO WITH-OPEN-STREAM (&REST ARGS) (LET ((VAR (CAAR ARGS)) (STREAM (CADAR ARGS)) (FORMS (CDR ARGS)) (ABORTP (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR STREAM) (BACKQ-CONS ABORTP (QUOTE (T)))) (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-PROG1) (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-LIST* (QUOTE SETQ) ABORTP (QUOTE (NIL)))) (BACKQ-LIST (QUOTE WHEN) VAR (BACKQ-LIST (QUOTE CLOSE) VAR (QUOTE :ABORT) ABORTP))))))
     [java] ; (DEFUN ANSI-LOOP (EXPS) (LET ((*WARN-ON-REDEFINITION* NIL)) (REQUIRE (QUOTE LOOP))) (FMAKUNBOUND (QUOTE ANSI-LOOP)) (BACKQ-CONS (QUOTE LOOP) EXPS))
     [java] ; (DEFMACRO LOOP (&REST EXPS) (DOLIST (EXP EXPS) (WHEN (ATOM EXP) (RETURN-FROM LOOP (ANSI-LOOP EXPS)))) (LET ((TAG (GENSYM))) (BACKQ-LIST (QUOTE BLOCK) NIL (BACKQ-LIST* (QUOTE TAGBODY) TAG (BACKQ-APPEND EXPS (BACKQ-LIST (BACKQ-LIST (QUOTE GO) TAG)))))))
     [java] ; (DEFMACRO DEFVAR (VAR &OPTIONAL (VAL NIL VALP) (DOC NIL DOCP)) (BACKQ-LIST* (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) VAR) (QUOTE (:VARIABLE))) (BACKQ-LIST (QUOTE %DEFVAR) (BACKQ-LIST (QUOTE QUOTE) VAR)) (BACKQ-APPEND (WHEN VALP (BACKQ-LIST (BACKQ-LIST (QUOTE UNLESS) (BACKQ-LIST (QUOTE BOUNDP) (BACKQ-LIST (QUOTE QUOTE) VAR)) (BACKQ-LIST (QUOTE SETQ) VAR VAL)))) (WHEN DOCP (BACKQ-LIST (BACKQ-LIST (QUOTE %SET-DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) VAR) (QUOTE (QUOTE VARIABLE)) (BACKQ-LIST (QUOTE QUOTE) DOC)))) (BACKQ-LIST (BACKQ-LIST (QUOTE QUOTE) VAR)))))
     [java] ; (DEFMACRO DEFCONST (NAME VALUE) (BACKQ-LIST (QUOTE DEFCONSTANT) NAME (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE BOUNDP) (BACKQ-LIST (QUOTE QUOTE) NAME)) (BACKQ-LIST (QUOTE SYMBOL-VALUE) (BACKQ-LIST (QUOTE QUOTE) NAME)) VALUE)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/macros.abcl (1.407 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/loop.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFPACKAGE "LOOP" (:USE "COMMON-LISP"))
     [java] ; (IN-PACKAGE "LOOP")
     [java] ; (DEFMACRO WITH-LOOP-LIST-COLLECTION-HEAD ((HEAD-VAR TAIL-VAR &OPTIONAL USER-HEAD-VAR) &BODY BODY) (LET ((L (AND USER-HEAD-VAR (LIST (LIST USER-HEAD-VAR NIL))))) (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-CONS HEAD-VAR (QUOTE ((LIST NIL)))) (SYSTEM::BACKQ-LIST TAIL-VAR HEAD-VAR) L) BODY)))
     [java] ; (DEFMACRO LOOP-COLLECT-RPLACD (&ENVIRONMENT ENV (HEAD-VAR TAIL-VAR &OPTIONAL USER-HEAD-VAR) FORM) (SETQ FORM (MACROEXPAND FORM ENV)) (FLET ((CDR-WRAP (FORM N) (DECLARE (FIXNUM N)) (DO NIL ((<= N 4) (SETQ FORM (SYSTEM::BACKQ-LIST (CASE N (1 (QUOTE CDR)) (2 (QUOTE CDDR)) (3 (QUOTE CDDDR)) (4 (QUOTE CDDDDR))) FORM))) (SETQ FORM (SYSTEM::BACKQ-LIST (QUOTE CDDDDR) FORM) N (- N 4))))) (LET ((TAIL-FORM FORM) (NCDRS NIL)) (WHEN (CONSP FORM) (COND ((EQ (CAR FORM) (QUOTE LIST)) (SETQ NCDRS (1- (LENGTH (CDR FORM))))) ((MEMBER (CAR FORM) (QUOTE (LIST* CONS))) (WHEN (AND (CDDR FORM) (MEMBER (CAR (LAST FORM)) (QUOTE (NIL (QUOTE NIL))))) (SETQ NCDRS (- (LENGTH (CDR FORM)) 2)))))) (LET ((ANSWER (COND ((NULL NCDRS) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE CDR) TAIL-VAR) TAIL-FORM) (SYSTEM::BACKQ-LIST (QUOTE SETQ) TAIL-VAR (SYSTEM::BACKQ-LIST (QUOTE LAST) (SYSTEM::BACKQ-LIST (QUOTE CDR) TAIL-VAR))))) ((< NCDRS 0) (RETURN-FROM LOOP-COLLECT-RPLACD NIL)) ((= NCDRS 0) (SYSTEM::BACKQ-LIST (QUOTE RPLACD) TAIL-VAR (SYSTEM::BACKQ-LIST (QUOTE SETQ) TAIL-VAR TAIL-FORM))) (T (SYSTEM::BACKQ-LIST (QUOTE SETQ) TAIL-VAR (CDR-WRAP (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE CDR) TAIL-VAR) TAIL-FORM) NCDRS)))))) (WHEN USER-HEAD-VAR (SETQ ANSWER (SYSTEM::BACKQ-LIST (QUOTE PROGN) ANSWER (SYSTEM::BACKQ-LIST (QUOTE SETQ) USER-HEAD-VAR (SYSTEM::BACKQ-LIST (QUOTE CDR) HEAD-VAR))))) ANSWER))))
     [java] ; (DEFMACRO LOOP-COLLECT-ANSWER (HEAD-VAR &OPTIONAL USER-HEAD-VAR) (OR USER-HEAD-VAR (SYSTEM::BACKQ-LIST (QUOTE CDR) HEAD-VAR)))
     [java] ; (DEFSTRUCT (LOOP-MINIMAX (:CONSTRUCTOR MAKE-LOOP-MINIMAX-INTERNAL) (:COPIER NIL) (:PREDICATE NIL)) ANSWER-VARIABLE TYPE TEMP-VARIABLE FLAG-VARIABLE OPERATIONS INFINITY-DATA)
     [java] ; (DEFVAR *LOOP-MINIMAX-TYPE-INFINITIES-ALIST* (QUOTE ((FIXNUM MOST-POSITIVE-FIXNUM MOST-NEGATIVE-FIXNUM))))
     [java] ; (DEFUN MAKE-LOOP-MINIMAX (ANSWER-VARIABLE TYPE) (LET ((INFINITY-DATA (CDR (ASSOC TYPE *LOOP-MINIMAX-TYPE-INFINITIES-ALIST* :TEST (FUNCTION SUBTYPEP))))) (MAKE-LOOP-MINIMAX-INTERNAL :ANSWER-VARIABLE ANSWER-VARIABLE :TYPE TYPE :TEMP-VARIABLE (GENSYM "LOOP-MAXMIN-TEMP-") :FLAG-VARIABLE (AND (NOT INFINITY-DATA) (GENSYM "LOOP-MAXMIN-FLAG-")) :OPERATIONS NIL :INFINITY-DATA INFINITY-DATA)))
     [java] ; (DEFUN LOOP-NOTE-MINIMAX-OPERATION (OPERATION MINIMAX) (PUSHNEW (THE SYMBOL OPERATION) (LOOP-MINIMAX-OPERATIONS MINIMAX)) (WHEN (AND (CDR (LOOP-MINIMAX-OPERATIONS MINIMAX)) (NOT (LOOP-MINIMAX-FLAG-VARIABLE MINIMAX))) (SETF (LOOP-MINIMAX-FLAG-VARIABLE MINIMAX) (GENSYM "LOOP-MAXMIN-FLAG-"))) OPERATION)
     [java] ; (DEFMACRO WITH-MINIMAX-VALUE (LM &BODY BODY) (LET ((INIT (LOOP-TYPED-INIT (LOOP-MINIMAX-TYPE LM))) (WHICH (CAR (LOOP-MINIMAX-OPERATIONS LM))) (INFINITY-DATA (LOOP-MINIMAX-INFINITY-DATA LM)) (ANSWER-VAR (LOOP-MINIMAX-ANSWER-VARIABLE LM)) (TEMP-VAR (LOOP-MINIMAX-TEMP-VARIABLE LM)) (FLAG-VAR (LOOP-MINIMAX-FLAG-VARIABLE LM)) (TYPE (LOOP-MINIMAX-TYPE LM))) (IF FLAG-VAR (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST ANSWER-VAR INIT) (SYSTEM::BACKQ-LIST TEMP-VAR INIT) (SYSTEM::BACKQ-CONS FLAG-VAR (QUOTE (NIL)))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) TYPE ANSWER-VAR TEMP-VAR)) BODY) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST ANSWER-VAR (IF (EQ WHICH (QUOTE MIN)) (FIRST INFINITY-DATA) (SECOND INFINITY-DATA))) (SYSTEM::BACKQ-LIST TEMP-VAR INIT)) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) TYPE ANSWER-VAR TEMP-VAR)) BODY))))
     [java] ; (DEFMACRO LOOP-ACCUMULATE-MINIMAX-VALUE (LM OPERATION FORM) (LET* ((ANSWER-VAR (LOOP-MINIMAX-ANSWER-VARIABLE LM)) (TEMP-VAR (LOOP-MINIMAX-TEMP-VARIABLE LM)) (FLAG-VAR (LOOP-MINIMAX-FLAG-VARIABLE LM)) (TEST (SYSTEM::BACKQ-LIST (ECASE OPERATION (MIN (QUOTE <)) (MAX (QUOTE >))) TEMP-VAR ANSWER-VAR))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE SETQ) TEMP-VAR FORM) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (IF FLAG-VAR (SYSTEM::BACKQ-LIST (QUOTE OR) (SYSTEM::BACKQ-LIST (QUOTE NOT) FLAG-VAR) TEST) TEST) (SYSTEM::BACKQ-CONS (QUOTE SETQ) (SYSTEM::BACKQ-APPEND (AND FLAG-VAR (SYSTEM::BACKQ-CONS FLAG-VAR (QUOTE (T)))) (SYSTEM::BACKQ-LIST ANSWER-VAR TEMP-VAR)))))))
     [java] ; (DEFUN LOOP-TEQUAL (X1 X2) (AND (SYMBOLP X1) (STRING= X1 X2)))
     [java] ; (DEFUN LOOP-TASSOC (KWD ALIST) (AND (SYMBOLP KWD) (ASSOC KWD ALIST :TEST (FUNCTION STRING=))))
     [java] ; (DEFUN LOOP-TMEMBER (KWD LIST) (AND (SYMBOLP KWD) (MEMBER KWD LIST :TEST (FUNCTION STRING=))))
     [java] ; (DEFUN LOOP-LOOKUP-KEYWORD (LOOP-TOKEN TABLE) (AND (SYMBOLP LOOP-TOKEN) (VALUES (GETHASH (SYMBOL-NAME (THE SYMBOL LOOP-TOKEN)) TABLE))))
     [java] ; (DEFMACRO LOOP-STORE-TABLE-DATA (SYMBOL TABLE DATUM) (SYSTEM::BACKQ-LIST (QUOTE SETF) (SYSTEM::BACKQ-LIST (QUOTE GETHASH) (SYSTEM::BACKQ-LIST (QUOTE SYMBOL-NAME) SYMBOL) TABLE) DATUM))
     [java] ; (DEFSTRUCT (LOOP-UNIVERSE (:COPIER NIL) (:PREDICATE NIL)) KEYWORDS ITERATION-KEYWORDS FOR-KEYWORDS PATH-KEYWORDS TYPE-SYMBOLS TYPE-KEYWORDS ANSI IMPLICIT-FOR-REQUIRED)
     [java] ; (DEFVAR *LOOP-UNIVERSE*)
     [java] ; (DEFUN MAKE-STANDARD-LOOP-UNIVERSE (&KEY KEYWORDS FOR-KEYWORDS ITERATION-KEYWORDS PATH-KEYWORDS TYPE-KEYWORDS TYPE-SYMBOLS ANSI) (DECLARE (TYPE (MEMBER NIL T :EXTENDED) ANSI)) (FLET ((MAKETABLE (ENTRIES) (LET* ((SIZE (LENGTH ENTRIES)) (HT (MAKE-HASH-TABLE :SIZE (IF (< SIZE 10) 10 SIZE) :TEST (QUOTE EQUAL)))) (DOLIST (X ENTRIES) (SETF (GETHASH (SYMBOL-NAME (CAR X)) HT) (CADR X))) HT))) (MAKE-LOOP-UNIVERSE :KEYWORDS (MAKETABLE KEYWORDS) :FOR-KEYWORDS (MAKETABLE FOR-KEYWORDS) :ITERATION-KEYWORDS (MAKETABLE ITERATION-KEYWORDS) :PATH-KEYWORDS (MAKETABLE PATH-KEYWORDS) :ANSI ANSI :IMPLICIT-FOR-REQUIRED (NOT (NULL ANSI)) :TYPE-KEYWORDS (MAKETABLE TYPE-KEYWORDS) :TYPE-SYMBOLS (LET* ((SIZE (LENGTH TYPE-SYMBOLS)) (HT (MAKE-HASH-TABLE :SIZE (IF (< SIZE 10) 10 SIZE) :TEST (QUOTE EQ)))) (DOLIST (X TYPE-SYMBOLS) (IF (ATOM X) (SETF (GETHASH X HT) X) (SETF (GETHASH (CAR X) HT) (CADR X)))) HT))))
     [java] ; (DEFUN LOOP-MAKE-PSETQ (FROBS) (AND FROBS (LOOP-MAKE-DESETQ (LIST (CAR FROBS) (IF (NULL (CDDR FROBS)) (CADR FROBS) (SYSTEM::BACKQ-LIST (QUOTE PROG1) (CADR FROBS) (LOOP-MAKE-PSETQ (CDDR FROBS))))))))
     [java] ; (DEFUN LOOP-MAKE-DESETQ (VAR-VAL-PAIRS) (IF (NULL VAR-VAL-PAIRS) NIL (CONS (QUOTE LOOP-REALLY-DESETQ) VAR-VAL-PAIRS)))
     [java] ; (DEFVAR *LOOP-DESETQ-TEMPORARY* (MAKE-SYMBOL "LOOP-DESETQ-TEMP"))
     [java] ; (DEFMACRO LOOP-REALLY-DESETQ (&ENVIRONMENT ENV &REST VAR-VAL-PAIRS) (LABELS ((FIND-NON-NULL (VAR) (DO ((TAIL VAR)) ((NOT (CONSP TAIL)) TAIL) (WHEN (FIND-NON-NULL (POP TAIL)) (RETURN T)))) (LOOP-DESETQ-INTERNAL (VAR VAL &OPTIONAL TEMP) (TYPECASE VAR (NULL (WHEN (CONSP VAL) (IF (EQ (CAR VAL) (QUOTE PROG1)) (MAPCAN (LAMBDA (X) (AND (CONSP X) (OR (NOT (EQ (CAR X) (QUOTE CAR))) (NOT (SYMBOLP (CADR X))) (NOT (SYMBOLP (SETQ X (MACROEXPAND X ENV))))) (CONS X NIL))) (CDR VAL)) (SYSTEM::BACKQ-LIST VAL)))) (CONS (LET* ((CAR (CAR VAR)) (CDR (CDR VAR)) (CAR-NON-NULL (FIND-NON-NULL CAR)) (CDR-NON-NULL (FIND-NON-NULL CDR))) (WHEN (OR CAR-NON-NULL CDR-NON-NULL) (IF CDR-NON-NULL (LET* ((TEMP-P TEMP) (TEMP (OR TEMP *LOOP-DESETQ-TEMPORARY*)) (BODY (SYSTEM::BACKQ-APPEND (LOOP-DESETQ-INTERNAL CAR (SYSTEM::BACKQ-LIST (QUOTE CAR) TEMP)) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE SETQ) TEMP (SYSTEM::BACKQ-LIST (QUOTE CDR) TEMP)) (LOOP-DESETQ-INTERNAL CDR TEMP TEMP))))) (IF TEMP-P (SYSTEM::BACKQ-APPEND (UNLESS (EQ TEMP VAL) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE SETQ) TEMP VAL))) BODY) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST TEMP VAL)) BODY)))) (LOOP-DESETQ-INTERNAL CAR (SYSTEM::BACKQ-LIST (QUOTE CAR) VAL) TEMP))))) (OTHERWISE (UNLESS (EQ VAR VAL) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE SETQ) VAR VAL))))))) (DO ((ACTIONS)) ((NULL VAR-VAL-PAIRS) (IF (NULL (CDR ACTIONS)) (CAR ACTIONS) (SYSTEM::BACKQ-CONS (QUOTE PROGN) (NREVERSE ACTIONS)))) (SETQ ACTIONS (REVAPPEND (LOOP-DESETQ-INTERNAL (POP VAR-VAL-PAIRS) (POP VAR-VAL-PAIRS)) ACTIONS)))))
     [java] ; (DEFVAR *LOOP-SOURCE-CODE*)
     [java] ; (DEFVAR *LOOP-ORIGINAL-SOURCE-CODE*)
     [java] ; (DEFVAR *LOOP-SOURCE-CONTEXT*)
     [java] ; (DEFVAR *LOOP-NAMES*)
     [java] ; (DEFVAR *LOOP-MACRO-ENVIRONMENT*)
     [java] ; (DEFVAR *LOOP-NAMED-VARS*)
     [java] ; (DEFVAR *LOOP-VARS*)
     [java] ; (DEFVAR *LOOP-DECLARATIONS*)
     [java] ; (DEFVAR *LOOP-DESETQ-CROCKS*)
     [java] ; (DEFVAR *LOOP-WRAPPERS*)
     [java] ; (DEFVAR *LOOP-BIND-STACK*)
     [java] ; (DEFVAR *LOOP-ITERATION-VARS*)
     [java] ; (DEFVAR *LOOP-PROLOGUE*)
     [java] ; (DEFVAR *LOOP-BEFORE-LOOP*)
     [java] ; (DEFVAR *LOOP-BODY*)
     [java] ; (DEFVAR *LOOP-AFTER-BODY*)
     [java] ; (DEFVAR *LOOP-EMITTED-BODY*)
     [java] ; (DEFVAR *LOOP-EPILOGUE*)
     [java] ; (DEFVAR *LOOP-AFTER-EPILOGUE*)
     [java] ; (DEFVAR *LOOP-FINAL-VALUE-CULPRIT*)
     [java] ; (DEFVAR *LOOP-INSIDE-CONDITIONAL*)
     [java] ; (DEFVAR *LOOP-WHEN-IT-VAR*)
     [java] ; (DEFVAR *LOOP-NEVER-STEPPED-VAR*)
     [java] ; (DEFVAR *LOOP-COLLECTION-CRUFT*)
     [java] ; (DEFUN LOOP-CONSTANT-FOLD-IF-POSSIBLE (FORM &OPTIONAL EXPECTED-TYPE) (LET ((NEW-FORM FORM) (CONSTANTP NIL) (CONSTANT-VALUE NIL)) (WHEN (SETQ CONSTANTP (CONSTANTP NEW-FORM)) (SETQ CONSTANT-VALUE (EVAL NEW-FORM))) (WHEN (AND CONSTANTP EXPECTED-TYPE) (UNLESS (TYPEP CONSTANT-VALUE EXPECTED-TYPE) (LOOP-WARN "~@<The form ~S evaluated to ~S, which was not of ~
     [java]                     the anticipated type ~S.~:@>" FORM CONSTANT-VALUE EXPECTED-TYPE) (SETQ CONSTANTP NIL CONSTANT-VALUE NIL))) (VALUES NEW-FORM CONSTANTP CONSTANT-VALUE)))
     [java] ; (DEFUN LOOP-CONSTANTP (FORM) (CONSTANTP FORM))
     [java] ; (DEFVAR *LOOP-DUPLICATE-CODE* NIL)
     [java] ; (DEFVAR *LOOP-ITERATION-FLAG-VAR* (MAKE-SYMBOL "LOOP-NOT-FIRST-TIME"))
     [java] ; (DEFUN LOOP-CODE-DUPLICATION-THRESHOLD (ENV) (DECLARE (IGNORE ENV)) (LET ((SPEED 1) (SPACE 1)) (+ 40 (* (- SPEED SPACE) 10))))
     [java] ; (DEFMACRO LOOP-BODY (&ENVIRONMENT ENV PROLOGUE BEFORE-LOOP MAIN-BODY AFTER-LOOP EPILOGUE &AUX RBEFORE RAFTER FLAGVAR) (UNLESS (= (LENGTH BEFORE-LOOP) (LENGTH AFTER-LOOP)) (ERROR "LOOP-BODY called with non-synched before- and after-loop lists")) (SETQ RBEFORE (REVERSE BEFORE-LOOP) RAFTER (REVERSE AFTER-LOOP)) (LABELS ((PSIMP (L) (LET ((ANS NIL)) (DOLIST (X L) (WHEN X (PUSH X ANS) (WHEN (AND (CONSP X) (MEMBER (CAR X) (QUOTE (GO RETURN RETURN-FROM)))) (RETURN NIL)))) (NREVERSE ANS))) (PIFY (L) (IF (NULL (CDR L)) (CAR L) (SYSTEM::BACKQ-CONS (QUOTE PROGN) L))) (MAKEBODY NIL (LET ((FORM (SYSTEM::BACKQ-CONS (QUOTE TAGBODY) (SYSTEM::BACKQ-APPEND (PSIMP (APPEND PROLOGUE (NREVERSE RBEFORE))) (SYSTEM::BACKQ-CONS (QUOTE NEXT-LOOP) (SYSTEM::BACKQ-APPEND (PSIMP (APPEND MAIN-BODY (NRECONC RAFTER (QUOTE ((GO NEXT-LOOP)))))) (SYSTEM::BACKQ-CONS (QUOTE END-LOOP) (PSIMP EPILOGUE)))))))) (IF FLAGVAR (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS FLAGVAR (QUOTE (NIL)))) FORM) FORM)))) (WHEN (OR *LOOP-DUPLICATE-CODE* (NOT RBEFORE)) (RETURN-FROM LOOP-BODY (MAKEBODY))) (DO ((THRESHOLD (LOOP-CODE-DUPLICATION-THRESHOLD ENV))) (NIL) (DECLARE (FIXNUM THRESHOLD)) (DO NIL ((OR (NULL RBEFORE) (NOT (EQUAL (CAR RBEFORE) (CAR RAFTER))))) (PUSH (POP RBEFORE) MAIN-BODY) (POP RAFTER)) (UNLESS RBEFORE (RETURN (MAKEBODY))) (DO ((BB RBEFORE (CDR BB)) (AA RAFTER (CDR AA)) (LASTDIFF NIL) (COUNT 0) (INC NIL)) ((NULL BB) (RETURN-FROM LOOP-BODY (MAKEBODY))) (COND ((NOT (EQUAL (CAR BB) (CAR AA))) (SETQ LASTDIFF BB COUNT 0)) ((OR (NOT (SETQ INC (ESTIMATE-CODE-SIZE (CAR BB) ENV))) (> (INCF COUNT INC) THRESHOLD)) (LET ((THEN NIL) (ELSE NIL)) (DO NIL (NIL) (PUSH (POP RBEFORE) ELSE) (PUSH (POP RAFTER) THEN) (WHEN (EQ RBEFORE (CDR LASTDIFF)) (RETURN))) (UNLESS FLAGVAR (PUSH (SYSTEM::BACKQ-LIST* (QUOTE SETQ) (SETQ FLAGVAR *LOOP-ITERATION-FLAG-VAR*) (QUOTE (T))) ELSE)) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IF) FLAGVAR (PIFY (PSIMP THEN)) (PIFY (PSIMP ELSE))) MAIN-BODY)) (DO NIL (NIL) (POP RAFTER) (PUSH (POP RBEFORE) MAIN-BODY) (WHEN (EQ RBEFORE (CDR BB)) (RETURN))) (RETURN)))))))
     [java] ; (DEFUN DUPLICATABLE-CODE-P (EXPR ENV) (IF (NULL EXPR) 0 (LET ((ANS (ESTIMATE-CODE-SIZE EXPR ENV))) (DECLARE (FIXNUM ANS)) ANS)))
     [java] ; (DEFVAR *SPECIAL-CODE-SIZES* (QUOTE ((RETURN 0) (PROGN 0) (NULL 1) (NOT 1) (EQ 1) (CAR 1) (CDR 1) (WHEN 1) (UNLESS 1) (IF 1) (CAAR 2) (CADR 2) (CDAR 2) (CDDR 2) (CAAAR 3) (CAADR 3) (CADAR 3) (CADDR 3) (CDAAR 3) (CDADR 3) (CDDAR 3) (CDDDR 3) (CAAAAR 4) (CAAADR 4) (CAADAR 4) (CAADDR 4) (CADAAR 4) (CADADR 4) (CADDAR 4) (CADDDR 4) (CDAAAR 4) (CDAADR 4) (CDADAR 4) (CDADDR 4) (CDDAAR 4) (CDDADR 4) (CDDDAR 4) (CDDDDR 4))))
     [java] ; (DEFVAR *ESTIMATE-CODE-SIZE-PUNT* (QUOTE (BLOCK DO DO* DOLIST FLET LABELS LAMBDA LET LET* LOCALLY MACROLET MULTIPLE-VALUE-BIND PROG PROG* SYMBOL-MACROLET TAGBODY UNWIND-PROTECT WITH-OPEN-FILE)))
     [java] ; (DEFUN DESTRUCTURING-SIZE (X) (DO ((X X (CDR X)) (N 0 (+ (DESTRUCTURING-SIZE (CAR X)) N))) ((ATOM X) (+ N (IF (NULL X) 0 1)))))
     [java] ; (DEFUN ESTIMATE-CODE-SIZE (X ENV) (CATCH (QUOTE ESTIMATE-CODE-SIZE) (ESTIMATE-CODE-SIZE-1 X ENV)))
     [java] ; (DEFUN ESTIMATE-CODE-SIZE-1 (X ENV) (FLET ((LIST-SIZE (L) (LET ((N 0)) (DECLARE (FIXNUM N)) (DOLIST (X L N) (INCF N (ESTIMATE-CODE-SIZE-1 X ENV)))))) (COND ((CONSTANTP X) 1) ((SYMBOLP X) (MULTIPLE-VALUE-BIND (NEW-FORM EXPANDED-P) (MACROEXPAND-1 X ENV) (IF EXPANDED-P (ESTIMATE-CODE-SIZE-1 NEW-FORM ENV) 1))) ((ATOM X) 1) ((SYMBOLP (CAR X)) (LET ((FN (CAR X)) (TEM NIL) (N 0)) (DECLARE (SYMBOL FN) (FIXNUM N)) (MACROLET ((F (OVERHEAD &OPTIONAL (ARGS NIL ARGS-P)) (SYSTEM::BACKQ-LIST (QUOTE THE) (QUOTE FIXNUM) (SYSTEM::BACKQ-LIST (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE THE) (QUOTE FIXNUM) OVERHEAD) (SYSTEM::BACKQ-LIST (QUOTE THE) (QUOTE FIXNUM) (SYSTEM::BACKQ-LIST (QUOTE LIST-SIZE) (IF ARGS-P ARGS (QUOTE (CDR X))))))))) (COND ((SETQ TEM (GET FN (QUOTE ESTIMATE-CODE-SIZE))) (TYPECASE TEM (FIXNUM (F TEM)) (T (FUNCALL TEM X ENV)))) ((SETQ TEM (ASSOC FN *SPECIAL-CODE-SIZES*)) (F (SECOND TEM))) ((EQ FN (QUOTE COND)) (DOLIST (CLAUSE (CDR X) N) (INCF N (LIST-SIZE CLAUSE)) (INCF N))) ((EQ FN (QUOTE DESETQ)) (DO ((L (CDR X) (CDR L))) ((NULL L) N) (SETQ N (+ N (DESTRUCTURING-SIZE (CAR L)) (ESTIMATE-CODE-SIZE-1 (CADR L) ENV))))) ((MEMBER FN (QUOTE (SETQ PSETQ))) (DO ((L (CDR X) (CDR L))) ((NULL L) N) (SETQ N (+ N (ESTIMATE-CODE-SIZE-1 (CADR L) ENV) 1)))) ((EQ FN (QUOTE GO)) 1) ((EQ FN (QUOTE FUNCTION)) (IF (OR (SYMBOLP (CADR X)) (AND (CONSP (CADR X)) (EQ (CAADR X) (QUOTE SETF)))) 1 (THROW (QUOTE DUPLICATABLE-CODE-P) NIL))) ((EQ FN (QUOTE MULTIPLE-VALUE-SETQ)) (F (LENGTH (SECOND X)) (CDDR X))) ((EQ FN (QUOTE RETURN-FROM)) (1+ (ESTIMATE-CODE-SIZE-1 (THIRD X) ENV))) ((OR (SPECIAL-OPERATOR-P FN) (MEMBER FN *ESTIMATE-CODE-SIZE-PUNT*)) (THROW (QUOTE ESTIMATE-CODE-SIZE) NIL)) (T (MULTIPLE-VALUE-BIND (NEW-FORM EXPANDED-P) (MACROEXPAND-1 X ENV) (IF EXPANDED-P (ESTIMATE-CODE-SIZE-1 NEW-FORM ENV) (F 3)))))))) (T (THROW (QUOTE ESTIMATE-CODE-SIZE) NIL)))))
     [java] ; (DEFUN LOOP-CONTEXT NIL (DO ((L *LOOP-SOURCE-CONTEXT* (CDR L)) (NEW NIL (CONS (CAR L) NEW))) ((EQ L (CDR *LOOP-SOURCE-CODE*)) (NREVERSE NEW))))
     [java] ; (DEFUN LOOP-ERROR (FORMAT-STRING &REST FORMAT-ARGS) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "~?~%Current LOOP context:~{ ~S~}." :FORMAT-ARGUMENTS (LIST FORMAT-STRING FORMAT-ARGS (LOOP-CONTEXT))))
     [java] ; (DEFUN LOOP-WARN (FORMAT-STRING &REST FORMAT-ARGS) (WARN "~?~%Current LOOP context:~{ ~S~}." FORMAT-STRING FORMAT-ARGS (LOOP-CONTEXT)))
     [java] ; (DEFUN LOOP-CHECK-DATA-TYPE (SPECIFIED-TYPE REQUIRED-TYPE &OPTIONAL (DEFAULT-TYPE REQUIRED-TYPE)) (IF (NULL SPECIFIED-TYPE) DEFAULT-TYPE (MULTIPLE-VALUE-BIND (A B) (SUBTYPEP SPECIFIED-TYPE REQUIRED-TYPE) (COND ((NOT B) (LOOP-WARN "LOOP couldn't verify that ~S is a subtype of the required type ~S." SPECIFIED-TYPE REQUIRED-TYPE)) ((NOT A) (LOOP-ERROR "The specified data type ~S is not a subtype of ~S." SPECIFIED-TYPE REQUIRED-TYPE))) SPECIFIED-TYPE)))
     [java] ; (DEFUN SUBST-GENSYMS-FOR-NIL (TREE) (DECLARE (SPECIAL *IGNORES*)) (COND ((NULL TREE) (CAR (PUSH (GENSYM "LOOP-IGNORED-VAR-") *IGNORES*))) ((ATOM TREE) TREE) (T (CONS (SUBST-GENSYMS-FOR-NIL (CAR TREE)) (SUBST-GENSYMS-FOR-NIL (CDR TREE))))))
     [java] ; (DEFMACRO LOOP-DESTRUCTURING-BIND (LAMBDA-LIST ARG-LIST &REST BODY) (LET ((*IGNORES* NIL)) (DECLARE (SPECIAL *IGNORES*)) (LET ((D-VAR-LAMBDA-LIST (SUBST-GENSYMS-FOR-NIL LAMBDA-LIST))) (SYSTEM::BACKQ-LIST* (QUOTE DESTRUCTURING-BIND) D-VAR-LAMBDA-LIST ARG-LIST (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-CONS (QUOTE IGNORE) *IGNORES*)) BODY))))
     [java] ; (DEFUN LOOP-BUILD-DESTRUCTURING-BINDINGS (CROCKS FORMS) (IF CROCKS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE LOOP-DESTRUCTURING-BIND) (CAR CROCKS) (CADR CROCKS) (LOOP-BUILD-DESTRUCTURING-BINDINGS (CDDR CROCKS) FORMS))) FORMS))
     [java] ; (DEFUN LOOP-TRANSLATE (*LOOP-SOURCE-CODE* *LOOP-MACRO-ENVIRONMENT* *LOOP-UNIVERSE*) (LET ((*LOOP-ORIGINAL-SOURCE-CODE* *LOOP-SOURCE-CODE*) (*LOOP-SOURCE-CONTEXT* NIL) (*LOOP-ITERATION-VARS* NIL) (*LOOP-VARS* NIL) (*LOOP-NAMED-VARS* NIL) (*LOOP-DECLARATIONS* NIL) (*LOOP-DESETQ-CROCKS* NIL) (*LOOP-BIND-STACK* NIL) (*LOOP-PROLOGUE* NIL) (*LOOP-WRAPPERS* NIL) (*LOOP-BEFORE-LOOP* NIL) (*LOOP-BODY* NIL) (*LOOP-EMITTED-BODY* NIL) (*LOOP-AFTER-BODY* NIL) (*LOOP-EPILOGUE* NIL) (*LOOP-AFTER-EPILOGUE* NIL) (*LOOP-FINAL-VALUE-CULPRIT* NIL) (*LOOP-INSIDE-CONDITIONAL* NIL) (*LOOP-WHEN-IT-VAR* NIL) (*LOOP-NEVER-STEPPED-VAR* NIL) (*LOOP-NAMES* NIL) (*LOOP-COLLECTION-CRUFT* NIL)) (LOOP-ITERATION-DRIVER) (LOOP-BIND-BLOCK) (LET ((ANSWER (SYSTEM::BACKQ-LIST (QUOTE LOOP-BODY) (NREVERSE *LOOP-PROLOGUE*) (NREVERSE *LOOP-BEFORE-LOOP*) (NREVERSE *LOOP-BODY*) (NREVERSE *LOOP-AFTER-BODY*) (NRECONC *LOOP-EPILOGUE* (NREVERSE *LOOP-AFTER-EPILOGUE*))))) (DOLIST (ENTRY *LOOP-BIND-STACK*) (LET ((VARS (FIRST ENTRY)) (DCLS (SECOND ENTRY)) (CROCKS (THIRD ENTRY)) (WRAPPERS (FOURTH ENTRY))) (DOLIST (W WRAPPERS) (SETQ ANSWER (APPEND W (LIST ANSWER)))) (WHEN (OR VARS DCLS CROCKS) (LET ((FORMS (LIST ANSWER))) (WHEN DCLS (PUSH (SYSTEM::BACKQ-CONS (QUOTE DECLARE) DCLS) FORMS)) (SETQ ANSWER (SYSTEM::BACKQ-LIST* (IF VARS (QUOTE LET) (QUOTE LOCALLY)) VARS (LOOP-BUILD-DESTRUCTURING-BINDINGS CROCKS FORMS))))))) (DO NIL (NIL) (SETQ ANSWER (SYSTEM::BACKQ-LIST (QUOTE BLOCK) (POP *LOOP-NAMES*) ANSWER)) (UNLESS *LOOP-NAMES* (RETURN NIL))) ANSWER)))
     [java] ; (DEFUN LOOP-ITERATION-DRIVER NIL (DO NIL ((NULL *LOOP-SOURCE-CODE*)) (LET ((KEYWORD (CAR *LOOP-SOURCE-CODE*)) (TEM NIL)) (COND ((NOT (SYMBOLP KEYWORD)) (LOOP-ERROR "~S found where LOOP keyword expected" KEYWORD)) (T (SETQ *LOOP-SOURCE-CONTEXT* *LOOP-SOURCE-CODE*) (LOOP-POP-SOURCE) (COND ((SETQ TEM (LOOP-LOOKUP-KEYWORD KEYWORD (LOOP-UNIVERSE-KEYWORDS *LOOP-UNIVERSE*))) (APPLY (SYMBOL-FUNCTION (FIRST TEM)) (REST TEM))) ((SETQ TEM (LOOP-LOOKUP-KEYWORD KEYWORD (LOOP-UNIVERSE-ITERATION-KEYWORDS *LOOP-UNIVERSE*))) (LOOP-HACK-ITERATION TEM)) ((LOOP-TMEMBER KEYWORD (QUOTE (AND ELSE))) (LOOP-ERROR "secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..." KEYWORD (CAR *LOOP-SOURCE-CODE*) (CADR *LOOP-SOURCE-CODE*))) (T (LOOP-ERROR "unknown LOOP keyword: ~S" KEYWORD))))))))
     [java] ; (DEFUN LOOP-POP-SOURCE NIL (IF *LOOP-SOURCE-CODE* (POP *LOOP-SOURCE-CODE*) (LOOP-ERROR "LOOP source code ran out when another token was expected.")))
     [java] ; (DEFUN LOOP-GET-FORM NIL (IF *LOOP-SOURCE-CODE* (LOOP-POP-SOURCE) (LOOP-ERROR "LOOP code ran out where a form was expected.")))
     [java] ; (DEFUN LOOP-GET-COMPOUND-FORM NIL (LET ((FORM (LOOP-GET-FORM))) (UNLESS (CONSP FORM) (LOOP-ERROR "A compound form was expected, but ~S found." FORM)) FORM))
     [java] ; (DEFUN LOOP-GET-PROGN NIL (DO ((FORMS (LIST (LOOP-GET-COMPOUND-FORM)) (CONS (LOOP-GET-COMPOUND-FORM) FORMS)) (NEXTFORM (CAR *LOOP-SOURCE-CODE*) (CAR *LOOP-SOURCE-CODE*))) ((ATOM NEXTFORM) (IF (NULL (CDR FORMS)) (CAR FORMS) (CONS (QUOTE PROGN) (NREVERSE FORMS))))))
     [java] ; (DEFUN LOOP-CONSTRUCT-RETURN (FORM) (SYSTEM::BACKQ-LIST (QUOTE RETURN-FROM) (CAR *LOOP-NAMES*) FORM))
     [java] ; (DEFUN LOOP-PSEUDO-BODY (FORM) (COND ((OR *LOOP-EMITTED-BODY* *LOOP-INSIDE-CONDITIONAL*) (PUSH FORM *LOOP-BODY*)) (T (PUSH FORM *LOOP-BEFORE-LOOP*) (PUSH FORM *LOOP-AFTER-BODY*))))
     [java] ; (DEFUN LOOP-EMIT-BODY (FORM) (SETQ *LOOP-EMITTED-BODY* T) (LOOP-PSEUDO-BODY FORM))
     [java] ; (DEFUN LOOP-EMIT-FINAL-VALUE (&OPTIONAL (FORM NIL FORM-SUPPLIED-P)) (WHEN FORM-SUPPLIED-P (PUSH (LOOP-CONSTRUCT-RETURN FORM) *LOOP-AFTER-EPILOGUE*)) (WHEN *LOOP-FINAL-VALUE-CULPRIT* (LOOP-WARN "The LOOP clause is providing a value for the iteration;~@
     [java]             however, one was already established by a ~S clause." *LOOP-FINAL-VALUE-CULPRIT*)) (SETQ *LOOP-FINAL-VALUE-CULPRIT* (CAR *LOOP-SOURCE-CONTEXT*)))
     [java] ; (DEFUN LOOP-DISALLOW-CONDITIONAL (&OPTIONAL KWD) (WHEN *LOOP-INSIDE-CONDITIONAL* (LOOP-ERROR "~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a conditional." KWD)))
     [java] ; (DEFUN LOOP-DISALLOW-ANONYMOUS-COLLECTORS NIL (WHEN (FIND-IF-NOT (QUOTE LOOP-COLLECTOR-NAME) *LOOP-COLLECTION-CRUFT*) (LOOP-ERROR "This LOOP clause is not permitted with anonymous collectors.")))
     [java] ; (DEFUN LOOP-DISALLOW-AGGREGATE-BOOLEANS NIL (WHEN (LOOP-TMEMBER *LOOP-FINAL-VALUE-CULPRIT* (QUOTE (ALWAYS NEVER THEREIS))) (LOOP-ERROR "This anonymous collection LOOP clause is not permitted with aggregate booleans.")))
     [java] ; (DEFUN LOOP-TYPED-INIT (DATA-TYPE &OPTIONAL STEP-VAR-P) (WHEN (AND DATA-TYPE (SUBTYPEP DATA-TYPE (QUOTE NUMBER))) (LET ((INIT (IF STEP-VAR-P 1 0))) (FLET ((LIKE (&REST TYPES) (COERCE INIT (FIND-IF (LAMBDA (TYPE) (SUBTYPEP DATA-TYPE TYPE)) TYPES)))) (COND ((SUBTYPEP DATA-TYPE (QUOTE FLOAT)) (LIKE (QUOTE SINGLE-FLOAT) (QUOTE DOUBLE-FLOAT) (QUOTE SHORT-FLOAT) (QUOTE LONG-FLOAT) (QUOTE FLOAT))) ((SUBTYPEP DATA-TYPE (QUOTE (COMPLEX FLOAT))) (LIKE (QUOTE (COMPLEX SINGLE-FLOAT)) (QUOTE (COMPLEX DOUBLE-FLOAT)) (QUOTE (COMPLEX SHORT-FLOAT)) (QUOTE (COMPLEX LONG-FLOAT)) (QUOTE (COMPLEX FLOAT)))) (T INIT))))))
     [java] ; (DEFUN LOOP-OPTIONAL-TYPE (&OPTIONAL VARIABLE) (AND *LOOP-SOURCE-CODE* (LET ((Z (CAR *LOOP-SOURCE-CODE*))) (COND ((LOOP-TEQUAL Z (QUOTE OF-TYPE)) (LOOP-POP-SOURCE) (LOOP-POP-SOURCE)) ((SYMBOLP Z) (LET ((TYPE-SPEC (OR (GETHASH Z (LOOP-UNIVERSE-TYPE-SYMBOLS *LOOP-UNIVERSE*)) (GETHASH (SYMBOL-NAME Z) (LOOP-UNIVERSE-TYPE-KEYWORDS *LOOP-UNIVERSE*))))) (WHEN TYPE-SPEC (LOOP-POP-SOURCE) TYPE-SPEC))) (T (IF (CONSP VARIABLE) (UNLESS (CONSP Z) (LOOP-ERROR "~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern expected" Z)) (LOOP-ERROR "~S found where a LOOP keyword or LOOP type keyword expected" Z)) (LOOP-POP-SOURCE) (LABELS ((TRANSLATE (K V) (COND ((NULL K) NIL) ((ATOM K) (REPLICATE (OR (GETHASH K (LOOP-UNIVERSE-TYPE-SYMBOLS *LOOP-UNIVERSE*)) (GETHASH (SYMBOL-NAME K) (LOOP-UNIVERSE-TYPE-KEYWORDS *LOOP-UNIVERSE*)) (LOOP-ERROR "The destructuring type pattern ~S contains the unrecognized type keyword ~S." Z K)) V)) ((ATOM V) (LOOP-ERROR "The destructuring type pattern ~S doesn't match the variable pattern ~S." Z VARIABLE)) (T (CONS (TRANSLATE (CAR K) (CAR V)) (TRANSLATE (CDR K) (CDR V)))))) (REPLICATE (TYP V) (IF (ATOM V) TYP (CONS (REPLICATE TYP (CAR V)) (REPLICATE TYP (CDR V)))))) (TRANSLATE Z VARIABLE)))))))
     [java] ; (DEFUN LOOP-BIND-BLOCK NIL (WHEN (OR *LOOP-VARS* *LOOP-DECLARATIONS* *LOOP-WRAPPERS*) (PUSH (LIST (NREVERSE *LOOP-VARS*) *LOOP-DECLARATIONS* *LOOP-DESETQ-CROCKS* *LOOP-WRAPPERS*) *LOOP-BIND-STACK*) (SETQ *LOOP-VARS* NIL *LOOP-DECLARATIONS* NIL *LOOP-DESETQ-CROCKS* NIL *LOOP-WRAPPERS* NIL)))
     [java] ; (DEFUN LOOP-VAR-P (NAME) (DO ((ENTRY *LOOP-BIND-STACK* (CDR ENTRY))) (NIL) (COND ((NULL ENTRY) (RETURN NIL)) ((ASSOC NAME (CAAR ENTRY) :TEST (FUNCTION EQ)) (RETURN T)))))
     [java] ; (DEFUN LOOP-MAKE-VAR (NAME INITIALIZATION DTYPE &OPTIONAL ITERATION-VAR-P STEP-VAR-P) (COND ((NULL NAME) (SETQ NAME (GENSYM "LOOP-IGNORE-")) (PUSH (LIST NAME INITIALIZATION) *LOOP-VARS*) (IF (NULL INITIALIZATION) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IGNORE) NAME) *LOOP-DECLARATIONS*) (LOOP-DECLARE-VAR NAME DTYPE))) ((ATOM NAME) (COND (ITERATION-VAR-P (IF (MEMBER NAME *LOOP-ITERATION-VARS*) (LOOP-ERROR "duplicated LOOP iteration variable ~S" NAME) (PUSH NAME *LOOP-ITERATION-VARS*))) ((ASSOC NAME *LOOP-VARS*) (LOOP-ERROR "duplicated variable ~S in LOOP parallel binding" NAME))) (UNLESS (SYMBOLP NAME) (LOOP-ERROR "bad variable ~S somewhere in LOOP" NAME)) (LOOP-DECLARE-VAR NAME DTYPE STEP-VAR-P) (PUSH (LIST NAME (OR INITIALIZATION (LOOP-TYPED-INIT DTYPE STEP-VAR-P))) *LOOP-VARS*)) (INITIALIZATION (LET ((NEWVAR (GENSYM "LOOP-DESTRUCTURE-"))) (LOOP-DECLARE-VAR NAME DTYPE) (PUSH (LIST NEWVAR INITIALIZATION) *LOOP-VARS*) (SETQ *LOOP-DESETQ-CROCKS* (LIST* NAME NEWVAR *LOOP-DESETQ-CROCKS*)))) (T (LET ((TCAR NIL) (TCDR NIL)) (IF (ATOM DTYPE) (SETQ TCAR (SETQ TCDR DTYPE)) (SETQ TCAR (CAR DTYPE) TCDR (CDR DTYPE))) (LOOP-MAKE-VAR (CAR NAME) NIL TCAR ITERATION-VAR-P) (LOOP-MAKE-VAR (CDR NAME) NIL TCDR ITERATION-VAR-P)))) NAME)
     [java] ; (DEFUN LOOP-MAKE-ITERATION-VAR (NAME INITIALIZATION DTYPE) (WHEN (AND NAME (LOOP-VAR-P NAME)) (LOOP-ERROR "Variable ~S has already been used." NAME)) (LOOP-MAKE-VAR NAME INITIALIZATION DTYPE T))
     [java] ; (DEFUN LOOP-DECLARE-VAR (NAME DTYPE &OPTIONAL STEP-VAR-P) (COND ((OR (NULL NAME) (NULL DTYPE) (EQ DTYPE T)) NIL) ((SYMBOLP NAME) (UNLESS (SUBTYPEP T DTYPE) (LET ((DTYPE (LET ((INIT (LOOP-TYPED-INIT DTYPE STEP-VAR-P))) (IF (TYPEP INIT DTYPE) DTYPE (SYSTEM::BACKQ-LIST (QUOTE OR) (SYSTEM::BACKQ-LIST (QUOTE MEMBER) INIT) DTYPE))))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE TYPE) DTYPE NAME) *LOOP-DECLARATIONS*)))) ((CONSP NAME) (COND ((CONSP DTYPE) (LOOP-DECLARE-VAR (CAR NAME) (CAR DTYPE)) (LOOP-DECLARE-VAR (CDR NAME) (CDR DTYPE))) (T (LOOP-DECLARE-VAR (CAR NAME) DTYPE) (LOOP-DECLARE-VAR (CDR NAME) DTYPE)))) (T (ERROR "invalid LOOP variable passed in: ~S" NAME))))
     [java] ; (DEFUN LOOP-MAYBE-BIND-FORM (FORM DATA-TYPE) (IF (LOOP-CONSTANTP FORM) FORM (LOOP-MAKE-VAR (GENSYM "LOOP-BIND-") FORM DATA-TYPE)))
     [java] ; (DEFUN LOOP-DO-IF (FOR NEGATEP) (LET ((FORM (LOOP-GET-FORM)) (*LOOP-INSIDE-CONDITIONAL* T) (IT-P NIL) (FIRST-CLAUSE-P T)) (FLET ((GET-CLAUSE (FOR) (DO ((BODY NIL)) (NIL) (LET ((KEY (CAR *LOOP-SOURCE-CODE*)) (*LOOP-BODY* NIL) DATA) (COND ((NOT (SYMBOLP KEY)) (LOOP-ERROR "~S found where keyword expected getting LOOP clause after ~S" KEY FOR)) (T (SETQ *LOOP-SOURCE-CONTEXT* *LOOP-SOURCE-CODE*) (LOOP-POP-SOURCE) (WHEN (AND (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) (QUOTE IT)) FIRST-CLAUSE-P) (SETQ *LOOP-SOURCE-CODE* (CONS (OR IT-P (SETQ IT-P (LOOP-WHEN-IT-VAR))) (CDR *LOOP-SOURCE-CODE*)))) (COND ((OR (NOT (SETQ DATA (LOOP-LOOKUP-KEYWORD KEY (LOOP-UNIVERSE-KEYWORDS *LOOP-UNIVERSE*)))) (PROGN (APPLY (SYMBOL-FUNCTION (CAR DATA)) (CDR DATA)) (NULL *LOOP-BODY*))) (LOOP-ERROR "~S does not introduce a LOOP clause that can follow ~S." KEY FOR)) (T (SETQ BODY (NRECONC *LOOP-BODY* BODY))))))) (SETQ FIRST-CLAUSE-P NIL) (IF (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :AND) (LOOP-POP-SOURCE) (RETURN (IF (CDR BODY) (SYSTEM::BACKQ-CONS (QUOTE PROGN) (NREVERSE BODY)) (CAR BODY))))))) (LET ((THEN (GET-CLAUSE FOR)) (ELSE (WHEN (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :ELSE) (LOOP-POP-SOURCE) (LIST (GET-CLAUSE :ELSE))))) (WHEN (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :END) (LOOP-POP-SOURCE)) (WHEN IT-P (SETQ FORM (SYSTEM::BACKQ-LIST (QUOTE SETQ) IT-P FORM))) (LOOP-PSEUDO-BODY (SYSTEM::BACKQ-LIST* (QUOTE IF) (IF NEGATEP (SYSTEM::BACKQ-LIST (QUOTE NOT) FORM) FORM) THEN ELSE))))))
     [java] ; (DEFUN LOOP-DO-INITIALLY NIL (LOOP-DISALLOW-CONDITIONAL :INITIALLY) (PUSH (LOOP-GET-PROGN) *LOOP-PROLOGUE*))
     [java] ; (DEFUN LOOP-DO-FINALLY NIL (LOOP-DISALLOW-CONDITIONAL :FINALLY) (PUSH (LOOP-GET-PROGN) *LOOP-EPILOGUE*))
     [java] ; (DEFUN LOOP-DO-DO NIL (LOOP-EMIT-BODY (LOOP-GET-PROGN)))
     [java] ; (DEFUN LOOP-DO-NAMED NIL (LET ((NAME (LOOP-POP-SOURCE))) (UNLESS (SYMBOLP NAME) (LOOP-ERROR "~S is an invalid name for your LOOP" NAME)) (WHEN (OR *LOOP-BEFORE-LOOP* *LOOP-BODY* *LOOP-AFTER-EPILOGUE* *LOOP-INSIDE-CONDITIONAL*) (LOOP-ERROR "The NAMED ~S clause occurs too late." NAME)) (WHEN *LOOP-NAMES* (LOOP-ERROR "You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S." (CAR *LOOP-NAMES*) NAME)) (SETQ *LOOP-NAMES* (LIST NAME))))
     [java] ; (DEFUN LOOP-DO-RETURN NIL (LOOP-EMIT-BODY (LOOP-CONSTRUCT-RETURN (LOOP-GET-FORM))))
     [java] ; (DEFSTRUCT (LOOP-COLLECTOR (:COPIER NIL) (:PREDICATE NIL)) NAME CLASS (HISTORY NIL) (TEMPVARS NIL) DTYPE (DATA NIL))
     [java] ; (DEFUN LOOP-GET-COLLECTION-INFO (COLLECTOR CLASS DEFAULT-TYPE) (LET ((FORM (LOOP-GET-FORM)) (DTYPE (AND (NOT (LOOP-UNIVERSE-ANSI *LOOP-UNIVERSE*)) (LOOP-OPTIONAL-TYPE))) (NAME (WHEN (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) (QUOTE INTO)) (LOOP-POP-SOURCE) (LOOP-POP-SOURCE)))) (WHEN (NOT (SYMBOLP NAME)) (LOOP-ERROR "The value accumulation recipient name, ~S, is not a symbol." NAME)) (UNLESS NAME (LOOP-DISALLOW-AGGREGATE-BOOLEANS)) (UNLESS DTYPE (SETQ DTYPE (OR (LOOP-OPTIONAL-TYPE) DEFAULT-TYPE))) (LET ((CRUFT (FIND (THE SYMBOL NAME) *LOOP-COLLECTION-CRUFT* :KEY (FUNCTION LOOP-COLLECTOR-NAME)))) (COND ((NOT CRUFT) (WHEN (AND NAME (LOOP-VAR-P NAME)) (LOOP-ERROR "Variable ~S in INTO clause is a duplicate" NAME)) (PUSH (SETQ CRUFT (MAKE-LOOP-COLLECTOR :NAME NAME :CLASS CLASS :HISTORY (LIST COLLECTOR) :DTYPE DTYPE)) *LOOP-COLLECTION-CRUFT*)) (T (UNLESS (EQ (LOOP-COLLECTOR-CLASS CRUFT) CLASS) (LOOP-ERROR "incompatible kinds of LOOP value accumulation specified for collecting~@
     [java]                 ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S" NAME (CAR (LOOP-COLLECTOR-HISTORY CRUFT)) COLLECTOR)) (UNLESS (EQUAL DTYPE (LOOP-COLLECTOR-DTYPE CRUFT)) (LOOP-WARN "unequal datatypes specified in different LOOP value accumulations~@
     [java]                into ~S: ~S and ~S" NAME DTYPE (LOOP-COLLECTOR-DTYPE CRUFT)) (WHEN (EQ (LOOP-COLLECTOR-DTYPE CRUFT) T) (SETF (LOOP-COLLECTOR-DTYPE CRUFT) DTYPE))) (PUSH COLLECTOR (LOOP-COLLECTOR-HISTORY CRUFT)))) (VALUES CRUFT FORM))))
     [java] ; (DEFUN LOOP-LIST-COLLECTION (SPECIFICALLY) (MULTIPLE-VALUE-BIND (LC FORM) (LOOP-GET-COLLECTION-INFO SPECIFICALLY (QUOTE LIST) (QUOTE LIST)) (LET ((TEMPVARS (LOOP-COLLECTOR-TEMPVARS LC))) (UNLESS TEMPVARS (SETF (LOOP-COLLECTOR-TEMPVARS LC) (SETQ TEMPVARS (LIST* (GENSYM "LOOP-LIST-HEAD-") (GENSYM "LOOP-LIST-TAIL-") (AND (LOOP-COLLECTOR-NAME LC) (LIST (LOOP-COLLECTOR-NAME LC)))))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE WITH-LOOP-LIST-COLLECTION-HEAD) TEMPVARS) *LOOP-WRAPPERS*) (UNLESS (LOOP-COLLECTOR-NAME LC) (LOOP-EMIT-FINAL-VALUE (SYSTEM::BACKQ-LIST* (QUOTE LOOP-COLLECT-ANSWER) (CAR TEMPVARS) (CDDR TEMPVARS))))) (ECASE SPECIFICALLY (LIST (SETQ FORM (SYSTEM::BACKQ-LIST (QUOTE LIST) FORM))) (NCONC NIL) (APPEND (UNLESS (AND (CONSP FORM) (EQ (CAR FORM) (QUOTE LIST))) (SETQ FORM (SYSTEM::BACKQ-LIST (QUOTE COPY-LIST) FORM))))) (LOOP-EMIT-BODY (SYSTEM::BACKQ-LIST (QUOTE LOOP-COLLECT-RPLACD) TEMPVARS FORM)))))
     [java] ; (DEFUN LOOP-SUM-COLLECTION (SPECIFICALLY REQUIRED-TYPE DEFAULT-TYPE) (MULTIPLE-VALUE-BIND (LC FORM) (LOOP-GET-COLLECTION-INFO SPECIFICALLY (QUOTE SUM) DEFAULT-TYPE) (LOOP-CHECK-DATA-TYPE (LOOP-COLLECTOR-DTYPE LC) REQUIRED-TYPE) (LET ((TEMPVARS (LOOP-COLLECTOR-TEMPVARS LC))) (UNLESS TEMPVARS (SETF (LOOP-COLLECTOR-TEMPVARS LC) (SETQ TEMPVARS (LIST (LOOP-MAKE-VAR (OR (LOOP-COLLECTOR-NAME LC) (GENSYM "LOOP-SUM-")) NIL (LOOP-COLLECTOR-DTYPE LC))))) (UNLESS (LOOP-COLLECTOR-NAME LC) (LOOP-EMIT-FINAL-VALUE (CAR (LOOP-COLLECTOR-TEMPVARS LC))))) (LOOP-EMIT-BODY (IF (EQ SPECIFICALLY (QUOTE COUNT)) (SYSTEM::BACKQ-LIST (QUOTE WHEN) FORM (SYSTEM::BACKQ-LIST (QUOTE SETQ) (CAR TEMPVARS) (SYSTEM::BACKQ-LIST (QUOTE 1+) (CAR TEMPVARS)))) (SYSTEM::BACKQ-LIST (QUOTE SETQ) (CAR TEMPVARS) (SYSTEM::BACKQ-LIST (QUOTE +) (CAR TEMPVARS) FORM)))))))
     [java] ; (DEFUN LOOP-MAXMIN-COLLECTION (SPECIFICALLY) (MULTIPLE-VALUE-BIND (LC FORM) (LOOP-GET-COLLECTION-INFO SPECIFICALLY (QUOTE MAXMIN) (QUOTE REAL)) (LOOP-CHECK-DATA-TYPE (LOOP-COLLECTOR-DTYPE LC) (QUOTE REAL)) (LET ((DATA (LOOP-COLLECTOR-DATA LC))) (UNLESS DATA (SETF (LOOP-COLLECTOR-DATA LC) (SETQ DATA (MAKE-LOOP-MINIMAX (OR (LOOP-COLLECTOR-NAME LC) (GENSYM "LOOP-MAXMIN-")) (LOOP-COLLECTOR-DTYPE LC)))) (UNLESS (LOOP-COLLECTOR-NAME LC) (LOOP-EMIT-FINAL-VALUE (LOOP-MINIMAX-ANSWER-VARIABLE DATA)))) (LOOP-NOTE-MINIMAX-OPERATION SPECIFICALLY DATA) (PUSH (SYSTEM::BACKQ-LIST (QUOTE WITH-MINIMAX-VALUE) DATA) *LOOP-WRAPPERS*) (LOOP-EMIT-BODY (SYSTEM::BACKQ-LIST (QUOTE LOOP-ACCUMULATE-MINIMAX-VALUE) DATA SPECIFICALLY FORM)))))
     [java] ; (DEFUN LOOP-DO-ALWAYS (RESTRICTIVE NEGATE) (LET ((FORM (LOOP-GET-FORM))) (WHEN RESTRICTIVE (LOOP-DISALLOW-CONDITIONAL)) (LOOP-DISALLOW-ANONYMOUS-COLLECTORS) (LOOP-EMIT-BODY (SYSTEM::BACKQ-LIST (IF NEGATE (QUOTE WHEN) (QUOTE UNLESS)) FORM (LOOP-CONSTRUCT-RETURN NIL))) (LOOP-EMIT-FINAL-VALUE T)))
     [java] ; (DEFUN LOOP-DO-THEREIS (RESTRICTIVE) (WHEN RESTRICTIVE (LOOP-DISALLOW-CONDITIONAL)) (LOOP-DISALLOW-ANONYMOUS-COLLECTORS) (LOOP-EMIT-FINAL-VALUE) (LOOP-EMIT-BODY (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE SETQ) (LOOP-WHEN-IT-VAR) (LOOP-GET-FORM)) (LOOP-CONSTRUCT-RETURN *LOOP-WHEN-IT-VAR*))))
     [java] ; (DEFUN LOOP-DO-WHILE (NEGATE KWD &AUX (FORM (LOOP-GET-FORM))) (LOOP-DISALLOW-CONDITIONAL KWD) (LOOP-PSEUDO-BODY (SYSTEM::BACKQ-LIST* (IF NEGATE (QUOTE WHEN) (QUOTE UNLESS)) FORM (QUOTE ((GO END-LOOP))))))
     [java] ; (DEFUN LOOP-DO-REPEAT NIL (LOOP-DISALLOW-CONDITIONAL :REPEAT) (LET ((FORM (LOOP-GET-FORM)) (TYPE (QUOTE INTEGER))) (LET ((VAR (LOOP-MAKE-VAR (GENSYM "LOOP-REPEAT-") (SYSTEM::BACKQ-LIST (QUOTE CEILING) FORM) TYPE))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST* (QUOTE <=) VAR (QUOTE (0))) (QUOTE (GO END-LOOP)) (SYSTEM::BACKQ-LIST (QUOTE DECF) VAR)) *LOOP-BEFORE-LOOP*) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST* (QUOTE <=) VAR (QUOTE (0))) (QUOTE (GO END-LOOP)) (SYSTEM::BACKQ-LIST (QUOTE DECF) VAR)) *LOOP-AFTER-BODY*))))
     [java] ; (DEFUN LOOP-DO-WITH NIL (LOOP-DISALLOW-CONDITIONAL :WITH) (DO ((VAR) (VAL) (DTYPE)) (NIL) (SETQ VAR (LOOP-POP-SOURCE) DTYPE (LOOP-OPTIONAL-TYPE VAR) VAL (COND ((LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :=) (LOOP-POP-SOURCE) (LOOP-GET-FORM)) (T NIL))) (WHEN (AND VAR (LOOP-VAR-P VAR)) (LOOP-ERROR "Variable ~S has already been used" VAR)) (LOOP-MAKE-VAR VAR VAL DTYPE) (IF (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :AND) (LOOP-POP-SOURCE) (RETURN (LOOP-BIND-BLOCK)))))
     [java] ; (DEFUN LOOP-HACK-ITERATION (ENTRY) (FLET ((MAKE-ENDTEST (LIST-OF-FORMS) (COND ((NULL LIST-OF-FORMS) NIL) ((MEMBER T LIST-OF-FORMS) (QUOTE (GO END-LOOP))) (T (SYSTEM::BACKQ-LIST* (QUOTE WHEN) (IF (NULL (CDR (SETQ LIST-OF-FORMS (NREVERSE LIST-OF-FORMS)))) (CAR LIST-OF-FORMS) (CONS (QUOTE OR) LIST-OF-FORMS)) (QUOTE ((GO END-LOOP)))))))) (DO ((PRE-STEP-TESTS NIL) (STEPS NIL) (POST-STEP-TESTS NIL) (PSEUDO-STEPS NIL) (PRE-LOOP-PRE-STEP-TESTS NIL) (PRE-LOOP-STEPS NIL) (PRE-LOOP-POST-STEP-TESTS NIL) (PRE-LOOP-PSEUDO-STEPS NIL) (TEM) (DATA)) (NIL) (SETQ TEM (SETQ DATA (APPLY (SYMBOL-FUNCTION (FIRST ENTRY)) (REST ENTRY)))) (AND (CAR TEM) (PUSH (CAR TEM) PRE-STEP-TESTS)) (SETQ STEPS (NCONC STEPS (COPY-LIST (CAR (SETQ TEM (CDR TEM)))))) (AND (CAR (SETQ TEM (CDR TEM))) (PUSH (CAR TEM) POST-STEP-TESTS)) (SETQ PSEUDO-STEPS (NCONC PSEUDO-STEPS (COPY-LIST (CAR (SETQ TEM (CDR TEM)))))) (SETQ TEM (CDR TEM)) (WHEN *LOOP-EMITTED-BODY* (LOOP-ERROR "iteration in LOOP follows body code")) (UNLESS TEM (SETQ TEM DATA)) (WHEN (CAR TEM) (PUSH (CAR TEM) PRE-LOOP-PRE-STEP-TESTS)) (SETQ PRE-LOOP-STEPS (NCONC PRE-LOOP-STEPS (COPY-LIST (CAR (SETQ TEM (CDR TEM)))))) (WHEN (CAR (SETQ TEM (CDR TEM))) (PUSH (CAR TEM) PRE-LOOP-POST-STEP-TESTS)) (SETQ PRE-LOOP-PSEUDO-STEPS (NCONC PRE-LOOP-PSEUDO-STEPS (COPY-LIST (CADR TEM)))) (UNLESS (LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :AND) (SETQ *LOOP-BEFORE-LOOP* (LIST* (LOOP-MAKE-DESETQ PRE-LOOP-PSEUDO-STEPS) (MAKE-ENDTEST PRE-LOOP-POST-STEP-TESTS) (LOOP-MAKE-PSETQ PRE-LOOP-STEPS) (MAKE-ENDTEST PRE-LOOP-PRE-STEP-TESTS) *LOOP-BEFORE-LOOP*)) (SETQ *LOOP-AFTER-BODY* (LIST* (LOOP-MAKE-DESETQ PSEUDO-STEPS) (MAKE-ENDTEST POST-STEP-TESTS) (LOOP-MAKE-PSETQ STEPS) (MAKE-ENDTEST PRE-STEP-TESTS) *LOOP-AFTER-BODY*)) (LOOP-BIND-BLOCK) (RETURN NIL)) (LOOP-POP-SOURCE) (WHEN (AND (NOT (LOOP-UNIVERSE-IMPLICIT-FOR-REQUIRED *LOOP-UNIVERSE*)) (SETQ TEM (LOOP-LOOKUP-KEYWORD (CAR *LOOP-SOURCE-CODE*) (LOOP-UNIVERSE-ITERATION-KEYWORDS *LOOP-UNIVERSE*)))) (LOOP-POP-SOURCE) (SETQ ENTRY TEM)))))
     [java] ; (DEFUN LOOP-DO-FOR NIL (LET* ((VAR (LOOP-POP-SOURCE)) (DATA-TYPE (LOOP-OPTIONAL-TYPE VAR)) (KEYWORD (LOOP-POP-SOURCE)) (FIRST-ARG NIL) (TEM NIL)) (SETQ FIRST-ARG (LOOP-GET-FORM)) (UNLESS (AND (SYMBOLP KEYWORD) (SETQ TEM (LOOP-LOOKUP-KEYWORD KEYWORD (LOOP-UNIVERSE-FOR-KEYWORDS *LOOP-UNIVERSE*)))) (LOOP-ERROR "~S is an unknown keyword in FOR or AS clause in LOOP." KEYWORD)) (APPLY (CAR TEM) VAR FIRST-ARG DATA-TYPE (CDR TEM))))
     [java] ; (DEFUN LOOP-WHEN-IT-VAR NIL (OR *LOOP-WHEN-IT-VAR* (SETQ *LOOP-WHEN-IT-VAR* (LOOP-MAKE-VAR (GENSYM "LOOP-IT-") NIL NIL))))
     [java] ; (DEFUN LOOP-ANSI-FOR-EQUALS (VAR VAL DATA-TYPE) (LOOP-MAKE-ITERATION-VAR VAR NIL DATA-TYPE) (COND ((LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :THEN) (LOOP-POP-SOURCE) (SYSTEM::BACKQ-LIST* NIL (SYSTEM::BACKQ-LIST VAR (LOOP-GET-FORM)) NIL NIL NIL (SYSTEM::BACKQ-LIST VAR VAL) (QUOTE (NIL NIL)))) (T (SYSTEM::BACKQ-LIST* NIL (SYSTEM::BACKQ-LIST VAR VAL) (QUOTE (NIL NIL))))))
     [java] ; (DEFUN LOOP-FOR-ACROSS (VAR VAL DATA-TYPE) (LOOP-MAKE-ITERATION-VAR VAR NIL DATA-TYPE) (LET ((VECTOR-VAR (GENSYM "LOOP-ACROSS-VECTOR-")) (INDEX-VAR (GENSYM "LOOP-ACROSS-INDEX-"))) (MULTIPLE-VALUE-BIND (VECTOR-FORM CONSTANTP VECTOR-VALUE) (LOOP-CONSTANT-FOLD-IF-POSSIBLE VAL (QUOTE VECTOR)) (LOOP-MAKE-VAR VECTOR-VAR VECTOR-FORM (IF (AND (CONSP VECTOR-FORM) (EQ (CAR VECTOR-FORM) (QUOTE THE))) (CADR VECTOR-FORM) (QUOTE VECTOR))) (LOOP-MAKE-VAR INDEX-VAR 0 (QUOTE FIXNUM)) (LET* ((LENGTH 0) (LENGTH-FORM (COND ((NOT CONSTANTP) (LET ((V (GENSYM "LOOP-ACROSS-LIMIT-"))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE SETQ) V (SYSTEM::BACKQ-LIST (QUOTE LENGTH) VECTOR-VAR)) *LOOP-PROLOGUE*) (LOOP-MAKE-VAR V 0 (QUOTE FIXNUM)))) (T (SETQ LENGTH (LENGTH VECTOR-VALUE))))) (FIRST-TEST (SYSTEM::BACKQ-LIST (QUOTE >=) INDEX-VAR LENGTH-FORM)) (OTHER-TEST FIRST-TEST) (STEP (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE AREF) VECTOR-VAR INDEX-VAR))) (PSTEP (SYSTEM::BACKQ-LIST INDEX-VAR (SYSTEM::BACKQ-LIST (QUOTE 1+) INDEX-VAR)))) (DECLARE (FIXNUM LENGTH)) (WHEN CONSTANTP (SETQ FIRST-TEST (= LENGTH 0)) (WHEN (<= LENGTH 1) (SETQ OTHER-TEST T))) (SYSTEM::BACKQ-LIST* OTHER-TEST STEP NIL PSTEP (AND (NOT (EQ FIRST-TEST OTHER-TEST)) (SYSTEM::BACKQ-LIST FIRST-TEST STEP NIL PSTEP)))))))
     [java] ; (DEFUN LOOP-LIST-STEP (LISTVAR) (LET ((STEPPER (COND ((LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :BY) (LOOP-POP-SOURCE) (LOOP-GET-FORM)) (T (QUOTE (FUNCTION CDR)))))) (COND ((AND (CONSP STEPPER) (EQ (CAR STEPPER) (QUOTE QUOTE))) (LOOP-WARN "Use of QUOTE around stepping function in LOOP will be left verbatim.") (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) STEPPER LISTVAR)) ((AND (CONSP STEPPER) (EQ (CAR STEPPER) (QUOTE FUNCTION))) (LIST (CADR STEPPER) LISTVAR)) (T (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) (LOOP-MAKE-VAR (GENSYM "LOOP-FN-") STEPPER (QUOTE FUNCTION)) LISTVAR)))))
     [java] ; (DEFUN LOOP-FOR-ON (VAR VAL DATA-TYPE) (MULTIPLE-VALUE-BIND (LIST CONSTANTP LIST-VALUE) (LOOP-CONSTANT-FOLD-IF-POSSIBLE VAL) (LET ((LISTVAR VAR)) (COND ((AND VAR (SYMBOLP VAR)) (LOOP-MAKE-ITERATION-VAR VAR LIST DATA-TYPE)) (T (LOOP-MAKE-VAR (SETQ LISTVAR (GENSYM)) LIST (QUOTE LIST)) (LOOP-MAKE-ITERATION-VAR VAR NIL DATA-TYPE))) (LET ((LIST-STEP (LOOP-LIST-STEP LISTVAR))) (LET* ((FIRST-ENDTEST (SYSTEM::BACKQ-LIST (QUOTE ATOM) LISTVAR)) (OTHER-ENDTEST FIRST-ENDTEST)) (WHEN (AND CONSTANTP (LISTP LIST-VALUE)) (SETQ FIRST-ENDTEST (NULL LIST-VALUE))) (COND ((EQ VAR LISTVAR) (SYSTEM::BACKQ-LIST* NIL (SYSTEM::BACKQ-LIST LISTVAR LIST-STEP) OTHER-ENDTEST NIL NIL NIL FIRST-ENDTEST (QUOTE (NIL)))) (T (LET ((STEP (SYSTEM::BACKQ-LIST VAR LISTVAR)) (PSEUDO (SYSTEM::BACKQ-LIST LISTVAR LIST-STEP))) (SYSTEM::BACKQ-LIST* OTHER-ENDTEST STEP NIL PSEUDO (AND (NOT (EQ FIRST-ENDTEST OTHER-ENDTEST)) (SYSTEM::BACKQ-LIST FIRST-ENDTEST STEP NIL PSEUDO)))))))))))
     [java] ; (DEFUN LOOP-FOR-IN (VAR VAL DATA-TYPE) (MULTIPLE-VALUE-BIND (LIST CONSTANTP LIST-VALUE) (LOOP-CONSTANT-FOLD-IF-POSSIBLE VAL) (LET ((LISTVAR (GENSYM "LOOP-LIST-"))) (LOOP-MAKE-ITERATION-VAR VAR NIL DATA-TYPE) (LOOP-MAKE-VAR LISTVAR LIST (QUOTE LIST)) (LET ((LIST-STEP (LOOP-LIST-STEP LISTVAR))) (LET* ((FIRST-ENDTEST (SYSTEM::BACKQ-LIST (QUOTE ENDP) LISTVAR)) (OTHER-ENDTEST FIRST-ENDTEST) (STEP (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE CAR) LISTVAR))) (PSEUDO-STEP (SYSTEM::BACKQ-LIST LISTVAR LIST-STEP))) (WHEN (AND CONSTANTP (LISTP LIST-VALUE)) (SETQ FIRST-ENDTEST (NULL LIST-VALUE))) (SYSTEM::BACKQ-LIST* OTHER-ENDTEST STEP NIL PSEUDO-STEP (AND (NOT (EQ FIRST-ENDTEST OTHER-ENDTEST)) (SYSTEM::BACKQ-LIST FIRST-ENDTEST STEP NIL PSEUDO-STEP))))))))
     [java] ; (DEFSTRUCT (LOOP-PATH (:COPIER NIL) (:PREDICATE NIL)) NAMES PREPOSITION-GROUPS INCLUSIVE-PERMITTED FUNCTION USER-DATA)
     [java] ; (DEFUN ADD-LOOP-PATH (NAMES FUNCTION UNIVERSE &KEY PREPOSITION-GROUPS INCLUSIVE-PERMITTED USER-DATA) (DECLARE (TYPE LOOP-UNIVERSE UNIVERSE)) (UNLESS (LISTP NAMES) (SETQ NAMES (LIST NAMES))) (LET ((HT (LOOP-UNIVERSE-PATH-KEYWORDS UNIVERSE)) (LP (MAKE-LOOP-PATH :NAMES (MAPCAR (FUNCTION SYMBOL-NAME) NAMES) :FUNCTION FUNCTION :USER-DATA USER-DATA :PREPOSITION-GROUPS (MAPCAR (LAMBDA (X) (IF (LISTP X) X (LIST X))) PREPOSITION-GROUPS) :INCLUSIVE-PERMITTED INCLUSIVE-PERMITTED))) (DOLIST (NAME NAMES) (SETF (GETHASH (SYMBOL-NAME NAME) HT) LP)) LP))
     [java] ; (DEFUN LOOP-FOR-BEING (VAR VAL DATA-TYPE) (LET ((PATH NIL) (DATA NIL) (INCLUSIVE NIL) (STUFF NIL) (INITIAL-PREPOSITIONS NIL)) (COND ((LOOP-TMEMBER VAL (QUOTE (:EACH :THE))) (SETQ PATH (LOOP-POP-SOURCE))) ((LOOP-TEQUAL (CAR *LOOP-SOURCE-CODE*) :AND) (LOOP-POP-SOURCE) (SETQ INCLUSIVE T) (UNLESS (LOOP-TMEMBER (CAR *LOOP-SOURCE-CODE*) (QUOTE (:ITS :EACH :HIS :HER))) (LOOP-ERROR "~S was found where ITS or EACH expected in LOOP iteration path syntax." (CAR *LOOP-SOURCE-CODE*))) (LOOP-POP-SOURCE) (SETQ PATH (LOOP-POP-SOURCE)) (SETQ INITIAL-PREPOSITIONS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE :IN) VAL)))) (T (LOOP-ERROR "unrecognizable LOOP iteration path syntax: missing EACH or THE?"))) (COND ((NOT (SYMBOLP PATH)) (LOOP-ERROR "~S was found where a LOOP iteration path name was expected." PATH)) ((NOT (SETQ DATA (LOOP-LOOKUP-KEYWORD PATH (LOOP-UNIVERSE-PATH-KEYWORDS *LOOP-UNIVERSE*)))) (LOOP-ERROR "~S is not the name of a LOOP iteration path." PATH)) ((AND INCLUSIVE (NOT (LOOP-PATH-INCLUSIVE-PERMITTED DATA))) (LOOP-ERROR "\"Inclusive\" iteration is not possible with the ~S LOOP iteration path." PATH))) (LET ((FUN (LOOP-PATH-FUNCTION DATA)) (PREPS (NCONC INITIAL-PREPOSITIONS (LOOP-COLLECT-PREPOSITIONAL-PHRASES (LOOP-PATH-PREPOSITION-GROUPS DATA) T))) (USER-DATA (LOOP-PATH-USER-DATA DATA))) (WHEN (SYMBOLP FUN) (SETQ FUN (SYMBOL-FUNCTION FUN))) (SETQ STUFF (IF INCLUSIVE (APPLY FUN VAR DATA-TYPE PREPS :INCLUSIVE T USER-DATA) (APPLY FUN VAR DATA-TYPE PREPS USER-DATA)))) (WHEN *LOOP-NAMED-VARS* (LOOP-ERROR "Unused USING vars: ~S." *LOOP-NAMED-VARS*)) (UNLESS (MEMBER (LENGTH STUFF) (QUOTE (6 10))) (LOOP-ERROR "Value passed back by LOOP iteration path function for path ~S has invalid length." PATH)) (DO ((L (CAR STUFF) (CDR L)) (X)) ((NULL L)) (IF (ATOM (SETQ X (CAR L))) (LOOP-MAKE-ITERATION-VAR X NIL NIL) (LOOP-MAKE-ITERATION-VAR (CAR X) (CADR X) (CADDR X)))) (SETQ *LOOP-PROLOGUE* (NCONC (REVERSE (CADR STUFF)) *LOOP-PROLOGUE*)) (CDDR STUFF)))
     [java] ; (DEFUN LOOP-NAMED-VAR (NAME) (LET ((TEM (LOOP-TASSOC NAME *LOOP-NAMED-VARS*))) (DECLARE (LIST TEM)) (COND ((NULL TEM) (VALUES (GENSYM) NIL)) (T (SETQ *LOOP-NAMED-VARS* (DELETE TEM *LOOP-NAMED-VARS*)) (VALUES (CDR TEM) T)))))
     [java] ; (DEFUN LOOP-COLLECT-PREPOSITIONAL-PHRASES (PREPOSITION-GROUPS &OPTIONAL USING-ALLOWED INITIAL-PHRASES) (FLET ((IN-GROUP-P (X GROUP) (CAR (LOOP-TMEMBER X GROUP)))) (DO ((TOKEN NIL) (PREPOSITIONAL-PHRASES INITIAL-PHRASES) (THIS-GROUP NIL NIL) (THIS-PREP NIL NIL) (DISALLOWED-PREPOSITIONS (MAPCAN (LAMBDA (X) (COPY-LIST (FIND (CAR X) PREPOSITION-GROUPS :TEST (FUNCTION IN-GROUP-P)))) INITIAL-PHRASES)) (USED-PREPOSITIONS (MAPCAR (FUNCTION CAR) INITIAL-PHRASES))) ((NULL *LOOP-SOURCE-CODE*) (NREVERSE PREPOSITIONAL-PHRASES)) (DECLARE (SYMBOL THIS-PREP)) (SETQ TOKEN (CAR *LOOP-SOURCE-CODE*)) (DOLIST (GROUP PREPOSITION-GROUPS) (WHEN (SETQ THIS-PREP (IN-GROUP-P TOKEN GROUP)) (RETURN (SETQ THIS-GROUP GROUP)))) (COND (THIS-GROUP (WHEN (MEMBER THIS-PREP DISALLOWED-PREPOSITIONS) (LOOP-ERROR (IF (MEMBER THIS-PREP USED-PREPOSITIONS) "A ~S prepositional phrase occurs multiply for some LOOP clause." "Preposition ~S was used when some other preposition has subsumed it.") TOKEN)) (SETQ USED-PREPOSITIONS (IF (LISTP THIS-GROUP) (APPEND THIS-GROUP USED-PREPOSITIONS) (CONS THIS-GROUP USED-PREPOSITIONS))) (LOOP-POP-SOURCE) (PUSH (LIST THIS-PREP (LOOP-GET-FORM)) PREPOSITIONAL-PHRASES)) ((AND USING-ALLOWED (LOOP-TEQUAL TOKEN (QUOTE USING))) (LOOP-POP-SOURCE) (DO ((Z (LOOP-POP-SOURCE) (LOOP-POP-SOURCE)) (TEM)) (NIL) (WHEN (CADR Z) (IF (SETQ TEM (LOOP-TASSOC (CAR Z) *LOOP-NAMED-VARS*)) (LOOP-ERROR "The variable substitution for ~S occurs twice in a USING phrase,~@
     [java]                     with ~S and ~S." (CAR Z) (CADR Z) (CADR TEM)) (PUSH (CONS (CAR Z) (CADR Z)) *LOOP-NAMED-VARS*))) (WHEN (OR (NULL *LOOP-SOURCE-CODE*) (SYMBOLP (CAR *LOOP-SOURCE-CODE*))) (RETURN NIL)))) (T (RETURN (NREVERSE PREPOSITIONAL-PHRASES)))))))
     [java] ; (DEFUN LOOP-SEQUENCER (INDEXV INDEXV-TYPE VARIABLE VARIABLE-TYPE SEQUENCE-VARIABLE SEQUENCE-TYPE STEP-HACK DEFAULT-TOP PREP-PHRASES) (LET ((ENDFORM NIL) (SEQUENCEP NIL) (TESTFN NIL) (TEST NIL) (STEPBY (1+ (OR (LOOP-TYPED-INIT INDEXV-TYPE) 0))) (STEPBY-CONSTANTP T) (STEP NIL) (DIR NIL) (INCLUSIVE-ITERATION NIL) (START-GIVEN NIL) (START-VALUE NIL) (START-CONSTANTP NIL) (LIMIT-GIVEN NIL) (LIMIT-CONSTANTP NIL) (LIMIT-VALUE NIL)) (FLET ((ASSERT-INDEX-FOR-ARITHMETIC (INDEX) (UNLESS (ATOM INDEX) (LOOP-ERROR "Arithmetic index must be an atom.")))) (WHEN VARIABLE (LOOP-MAKE-ITERATION-VAR VARIABLE NIL VARIABLE-TYPE)) (DO ((L PREP-PHRASES (CDR L)) (PREP) (FORM) (ODIR)) ((NULL L)) (SETQ PREP (CAAR L) FORM (CADAR L)) (CASE PREP ((:OF :IN) (SETQ SEQUENCEP T) (LOOP-MAKE-VAR SEQUENCE-VARIABLE FORM SEQUENCE-TYPE)) ((:FROM :DOWNFROM :UPFROM) (SETQ START-GIVEN T) (COND ((EQ PREP :DOWNFROM) (SETQ DIR (QUOTE :DOWN))) ((EQ PREP :UPFROM) (SETQ DIR (QUOTE :UP)))) (MULTIPLE-VALUE-SETQ (FORM START-CONSTANTP START-VALUE) (LOOP-CONSTANT-FOLD-IF-POSSIBLE FORM INDEXV-TYPE)) (ASSERT-INDEX-FOR-ARITHMETIC INDEXV) (SETQ INDEXV (LOOP-MAKE-ITERATION-VAR INDEXV FORM INDEXV-TYPE))) ((:UPTO :TO :DOWNTO :ABOVE :BELOW) (COND ((LOOP-TEQUAL PREP :UPTO) (SETQ INCLUSIVE-ITERATION (SETQ DIR (QUOTE :UP)))) ((LOOP-TEQUAL PREP :TO) (SETQ INCLUSIVE-ITERATION T)) ((LOOP-TEQUAL PREP :DOWNTO) (SETQ INCLUSIVE-ITERATION (SETQ DIR (QUOTE :DOWN)))) ((LOOP-TEQUAL PREP :ABOVE) (SETQ DIR (QUOTE :DOWN))) ((LOOP-TEQUAL PREP :BELOW) (SETQ DIR (QUOTE :UP)))) (SETQ LIMIT-GIVEN T) (MULTIPLE-VALUE-SETQ (FORM LIMIT-CONSTANTP LIMIT-VALUE) (LOOP-CONSTANT-FOLD-IF-POSSIBLE FORM (SYSTEM::BACKQ-LIST* (QUOTE AND) INDEXV-TYPE (QUOTE (REAL))))) (SETQ ENDFORM (IF LIMIT-CONSTANTP (SYSTEM::BACKQ-LIST (QUOTE QUOTE) LIMIT-VALUE) (LOOP-MAKE-VAR (GENSYM "LOOP-LIMIT-") FORM (SYSTEM::BACKQ-LIST* (QUOTE AND) INDEXV-TYPE (QUOTE (REAL))))))) (:BY (MULTIPLE-VALUE-SETQ (FORM STEPBY-CONSTANTP STEPBY) (LOOP-CONSTANT-FOLD-IF-POSSIBLE FORM (SYSTEM::BACKQ-LIST* (QUOTE AND) INDEXV-TYPE (QUOTE ((REAL (0))))))) (UNLESS STEPBY-CONSTANTP (LOOP-MAKE-VAR (SETQ STEPBY (GENSYM "LOOP-STEP-BY-")) FORM (SYSTEM::BACKQ-LIST* (QUOTE AND) INDEXV-TYPE (QUOTE ((REAL (0))))) NIL T))) (T (LOOP-ERROR "~S invalid preposition in sequencing or sequence path;~@
     [java]           maybe invalid prepositions were specified in iteration path descriptor?" PREP))) (WHEN (AND ODIR DIR (NOT (EQ DIR ODIR))) (LOOP-ERROR "conflicting stepping directions in LOOP sequencing path")) (SETQ ODIR DIR)) (WHEN (AND SEQUENCE-VARIABLE (NOT SEQUENCEP)) (LOOP-ERROR "missing OF or IN phrase in sequence path")) (IF START-GIVEN (WHEN LIMIT-GIVEN (FLET ((TYPE-DECLARATION-OF (X) (AND (EQ (CAR X) (QUOTE TYPE)) (CADDR X)))) (LET ((DECL (FIND INDEXV *LOOP-DECLARATIONS* :KEY (FUNCTION TYPE-DECLARATION-OF))) (%DECL (FIND INDEXV *LOOP-DECLARATIONS* :KEY (FUNCTION TYPE-DECLARATION-OF) :FROM-END T))) (DECLARE (IGNORE %DECL)) (SETF (CADR DECL) (SYSTEM::BACKQ-LIST (QUOTE AND) (QUOTE REAL) (CADR DECL)))))) (PROGN (ASSERT-INDEX-FOR-ARITHMETIC INDEXV) (SETQ INDEXV (LOOP-MAKE-ITERATION-VAR INDEXV (SETQ START-CONSTANTP T START-VALUE (OR (LOOP-TYPED-INIT INDEXV-TYPE) 0)) (SYSTEM::BACKQ-LIST* (QUOTE AND) INDEXV-TYPE (QUOTE (REAL))))))) (COND ((MEMBER DIR (QUOTE (NIL :UP))) (WHEN (OR LIMIT-GIVEN DEFAULT-TOP) (UNLESS LIMIT-GIVEN (LOOP-MAKE-VAR (SETQ ENDFORM (GENSYM "LOOP-SEQ-LIMIT-")) NIL INDEXV-TYPE) (PUSH (SYSTEM::BACKQ-LIST (QUOTE SETQ) ENDFORM DEFAULT-TOP) *LOOP-PROLOGUE*)) (SETQ TESTFN (IF INCLUSIVE-ITERATION (QUOTE >) (QUOTE >=)))) (SETQ STEP (IF (EQL STEPBY 1) (SYSTEM::BACKQ-LIST (QUOTE 1+) INDEXV) (SYSTEM::BACKQ-LIST (QUOTE +) INDEXV STEPBY)))) (T (UNLESS START-GIVEN (UNLESS DEFAULT-TOP (LOOP-ERROR "don't know where to start stepping")) (PUSH (SYSTEM::BACKQ-LIST (QUOTE SETQ) INDEXV (SYSTEM::BACKQ-LIST (QUOTE 1-) DEFAULT-TOP)) *LOOP-PROLOGUE*)) (WHEN (AND DEFAULT-TOP (NOT ENDFORM)) (SETQ ENDFORM (LOOP-TYPED-INIT INDEXV-TYPE) INCLUSIVE-ITERATION T)) (WHEN ENDFORM (SETQ TESTFN (IF INCLUSIVE-ITERATION (QUOTE <) (QUOTE <=)))) (SETQ STEP (IF (EQL STEPBY 1) (SYSTEM::BACKQ-LIST (QUOTE 1-) INDEXV) (SYSTEM::BACKQ-LIST (QUOTE -) INDEXV STEPBY))))) (WHEN TESTFN (SETQ TEST (SYSTEM::BACKQ-LIST TESTFN INDEXV ENDFORM))) (WHEN STEP-HACK (SETQ STEP-HACK (SYSTEM::BACKQ-LIST VARIABLE STEP-HACK))) (LET ((FIRST-TEST TEST) (REMAINING-TESTS TEST)) (WHEN (AND STEPBY-CONSTANTP START-CONSTANTP LIMIT-CONSTANTP (REALP START-VALUE) (REALP LIMIT-VALUE)) (WHEN (SETQ FIRST-TEST (FUNCALL (SYMBOL-FUNCTION TESTFN) START-VALUE LIMIT-VALUE)) (SETQ REMAINING-TESTS T))) (SYSTEM::BACKQ-LIST NIL (SYSTEM::BACKQ-LIST INDEXV STEP) REMAINING-TESTS STEP-HACK NIL NIL FIRST-TEST STEP-HACK)))))
     [java] ; (DEFUN LOOP-FOR-ARITHMETIC (VAR VAL DATA-TYPE KWD) (LOOP-SEQUENCER VAR (LOOP-CHECK-DATA-TYPE DATA-TYPE (QUOTE NUMBER)) NIL NIL NIL NIL NIL NIL (LOOP-COLLECT-PREPOSITIONAL-PHRASES (QUOTE ((:FROM :UPFROM :DOWNFROM) (:TO :UPTO :DOWNTO :ABOVE :BELOW) (:BY))) NIL (LIST (LIST KWD VAL)))))
     [java] ; (DEFUN LOOP-SEQUENCE-ELEMENTS-PATH (VARIABLE DATA-TYPE PREP-PHRASES &KEY FETCH-FUNCTION SIZE-FUNCTION SEQUENCE-TYPE ELEMENT-TYPE) (MULTIPLE-VALUE-BIND (INDEXV) (LOOP-NAMED-VAR (QUOTE INDEX)) (LET ((SEQUENCEV (LOOP-NAMED-VAR (QUOTE SEQUENCE)))) (LIST* NIL NIL (LOOP-SEQUENCER INDEXV (QUOTE FIXNUM) VARIABLE (OR DATA-TYPE ELEMENT-TYPE) SEQUENCEV SEQUENCE-TYPE (SYSTEM::BACKQ-LIST FETCH-FUNCTION SEQUENCEV INDEXV) (SYSTEM::BACKQ-LIST SIZE-FUNCTION SEQUENCEV) PREP-PHRASES)))))
     [java] ; (DEFUN LOOP-HASH-TABLE-ITERATION-PATH (VARIABLE DATA-TYPE PREP-PHRASES &KEY WHICH) (DECLARE (TYPE (MEMBER :HASH-KEY :HASH-VALUE) WHICH)) (COND ((OR (CDR PREP-PHRASES) (NOT (MEMBER (CAAR PREP-PHRASES) (QUOTE (:IN :OF))))) (LOOP-ERROR "too many prepositions!")) ((NULL PREP-PHRASES) (LOOP-ERROR "missing OF or IN in ~S iteration path"))) (LET ((HT-VAR (GENSYM "LOOP-HASHTAB-")) (NEXT-FN (GENSYM "LOOP-HASHTAB-NEXT-")) (DUMMY-PREDICATE-VAR NIL) (POST-STEPS NIL)) (MULTIPLE-VALUE-BIND (OTHER-VAR OTHER-P) (LOOP-NAMED-VAR (ECASE WHICH (:HASH-KEY (QUOTE HASH-VALUE)) (:HASH-VALUE (QUOTE HASH-KEY)))) (UNLESS OTHER-P (PUSH (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) OTHER-VAR) *LOOP-DECLARATIONS*)) (SETQ OTHER-P T DUMMY-PREDICATE-VAR (LOOP-WHEN-IT-VAR)) (LET* ((KEY-VAR NIL) (VAL-VAR NIL) (VARIABLE (OR VARIABLE (GENSYM "LOOP-HASH-VAR-TEMP-"))) (BINDINGS (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-LIST VARIABLE NIL DATA-TYPE) (SYSTEM::BACKQ-LIST HT-VAR (CADAR PREP-PHRASES)) (AND OTHER-P OTHER-VAR (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS OTHER-VAR (QUOTE (NIL)))))))) (ECASE WHICH (:HASH-KEY (SETQ KEY-VAR VARIABLE VAL-VAR (AND OTHER-P OTHER-VAR))) (:HASH-VALUE (SETQ KEY-VAR (AND OTHER-P OTHER-VAR) VAL-VAR VARIABLE))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE WITH-HASH-TABLE-ITERATOR) (SYSTEM::BACKQ-LIST NEXT-FN HT-VAR)) *LOOP-WRAPPERS*) (WHEN (OR (CONSP KEY-VAR) DATA-TYPE) (SETQ POST-STEPS (SYSTEM::BACKQ-LIST* KEY-VAR (SETQ KEY-VAR (GENSYM "LOOP-HASH-KEY-TEMP-")) POST-STEPS)) (PUSH (SYSTEM::BACKQ-CONS KEY-VAR (QUOTE (NIL))) BINDINGS)) (WHEN (OR (CONSP VAL-VAR) DATA-TYPE) (SETQ POST-STEPS (SYSTEM::BACKQ-LIST* VAL-VAR (SETQ VAL-VAR (GENSYM "LOOP-HASH-VAL-TEMP-")) POST-STEPS)) (PUSH (SYSTEM::BACKQ-CONS VAL-VAR (QUOTE (NIL))) BINDINGS)) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) DUMMY-PREDICATE-VAR) *LOOP-DECLARATIONS*) (SYSTEM::BACKQ-LIST BINDINGS NIL NIL NIL (SYSTEM::BACKQ-LIST (QUOTE NOT) (SYSTEM::BACKQ-LIST (QUOTE MULTIPLE-VALUE-SETQ) (SYSTEM::BACKQ-LIST DUMMY-PREDICATE-VAR KEY-VAR VAL-VAR) (SYSTEM::BACKQ-LIST NEXT-FN))) POST-STEPS)))))
     [java] ; (DEFUN LOOP-PACKAGE-SYMBOLS-ITERATION-PATH (VARIABLE DATA-TYPE PREP-PHRASES &KEY SYMBOL-TYPES) (COND ((AND PREP-PHRASES (CDR PREP-PHRASES)) (LOOP-ERROR "Too many prepositions!")) ((AND PREP-PHRASES (NOT (MEMBER (CAAR PREP-PHRASES) (QUOTE (:IN :OF))))) (LOOP-ERROR "Unknown preposition ~S." (CAAR PREP-PHRASES)))) (UNLESS (SYMBOLP VARIABLE) (LOOP-ERROR "Destructuring is not valid for package symbol iteration.")) (LET ((PKG-VAR (GENSYM "LOOP-PKGSYM-")) (NEXT-FN (GENSYM "LOOP-PKGSYM-NEXT-")) (VARIABLE (OR VARIABLE (GENSYM "LOOP-PKGSYM-VAR-"))) (PACKAGE (OR (CADAR PREP-PHRASES) (QUOTE *PACKAGE*)))) (PUSH (SYSTEM::BACKQ-LIST (QUOTE WITH-PACKAGE-ITERATOR) (SYSTEM::BACKQ-LIST* NEXT-FN PKG-VAR SYMBOL-TYPES)) *LOOP-WRAPPERS*) (PUSH (SYSTEM::BACKQ-LIST (QUOTE IGNORABLE) (LOOP-WHEN-IT-VAR)) *LOOP-DECLARATIONS*) (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST VARIABLE NIL DATA-TYPE) (SYSTEM::BACKQ-LIST PKG-VAR PACKAGE)) NIL NIL NIL (SYSTEM::BACKQ-LIST (QUOTE NOT) (SYSTEM::BACKQ-LIST (QUOTE MULTIPLE-VALUE-SETQ) (SYSTEM::BACKQ-LIST (LOOP-WHEN-IT-VAR) VARIABLE) (SYSTEM::BACKQ-LIST NEXT-FN))) (QUOTE (NIL)))))
     [java] ; (DEFUN MAKE-ANSI-LOOP-UNIVERSE (EXTENDED-P) (LET ((W (MAKE-STANDARD-LOOP-UNIVERSE :KEYWORDS (QUOTE ((NAMED (LOOP-DO-NAMED)) (INITIALLY (LOOP-DO-INITIALLY)) (FINALLY (LOOP-DO-FINALLY)) (DO (LOOP-DO-DO)) (DOING (LOOP-DO-DO)) (RETURN (LOOP-DO-RETURN)) (COLLECT (LOOP-LIST-COLLECTION LIST)) (COLLECTING (LOOP-LIST-COLLECTION LIST)) (APPEND (LOOP-LIST-COLLECTION APPEND)) (APPENDING (LOOP-LIST-COLLECTION APPEND)) (NCONC (LOOP-LIST-COLLECTION NCONC)) (NCONCING (LOOP-LIST-COLLECTION NCONC)) (COUNT (LOOP-SUM-COLLECTION COUNT REAL FIXNUM)) (COUNTING (LOOP-SUM-COLLECTION COUNT REAL FIXNUM)) (SUM (LOOP-SUM-COLLECTION SUM NUMBER NUMBER)) (SUMMING (LOOP-SUM-COLLECTION SUM NUMBER NUMBER)) (MAXIMIZE (LOOP-MAXMIN-COLLECTION MAX)) (MINIMIZE (LOOP-MAXMIN-COLLECTION MIN)) (MAXIMIZING (LOOP-MAXMIN-COLLECTION MAX)) (MINIMIZING (LOOP-MAXMIN-COLLECTION MIN)) (ALWAYS (LOOP-DO-ALWAYS T NIL)) (NEVER (LOOP-DO-ALWAYS T T)) (THEREIS (LOOP-DO-THEREIS T)) (WHILE (LOOP-DO-WHILE NIL :WHILE)) (UNTIL (LOOP-DO-WHILE T :UNTIL)) (WHEN (LOOP-DO-IF WHEN NIL)) (IF (LOOP-DO-IF IF NIL)) (UNLESS (LOOP-DO-IF UNLESS T)) (WITH (LOOP-DO-WITH)) (REPEAT (LOOP-DO-REPEAT)))) :FOR-KEYWORDS (QUOTE ((= (LOOP-ANSI-FOR-EQUALS)) (ACROSS (LOOP-FOR-ACROSS)) (IN (LOOP-FOR-IN)) (ON (LOOP-FOR-ON)) (FROM (LOOP-FOR-ARITHMETIC :FROM)) (DOWNFROM (LOOP-FOR-ARITHMETIC :DOWNFROM)) (UPFROM (LOOP-FOR-ARITHMETIC :UPFROM)) (BELOW (LOOP-FOR-ARITHMETIC :BELOW)) (ABOVE (LOOP-FOR-ARITHMETIC :ABOVE)) (TO (LOOP-FOR-ARITHMETIC :TO)) (UPTO (LOOP-FOR-ARITHMETIC :UPTO)) (DOWNTO (LOOP-FOR-ARITHMETIC :DOWNTO)) (BY (LOOP-FOR-ARITHMETIC :BY)) (BEING (LOOP-FOR-BEING)))) :ITERATION-KEYWORDS (QUOTE ((FOR (LOOP-DO-FOR)) (AS (LOOP-DO-FOR)))) :TYPE-SYMBOLS (QUOTE (ARRAY ATOM BIGNUM BIT BIT-VECTOR CHARACTER COMPILED-FUNCTION COMPLEX CONS DOUBLE-FLOAT FIXNUM FLOAT FUNCTION HASH-TABLE INTEGER KEYWORD LIST LONG-FLOAT NIL NULL NUMBER PACKAGE PATHNAME RANDOM-STATE RATIO RATIONAL READTABLE SEQUENCE SHORT-FLOAT SIMPLE-ARRAY SIMPLE-BIT-VECTOR SIMPLE-STRING SIMPLE-VECTOR SINGLE-FLOAT STANDARD-CHAR STREAM STRING BASE-CHAR SYMBOL T VECTOR)) :TYPE-KEYWORDS NIL :ANSI (IF EXTENDED-P :EXTENDED T)))) (ADD-LOOP-PATH (QUOTE (HASH-KEY HASH-KEYS)) (QUOTE LOOP-HASH-TABLE-ITERATION-PATH) W :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL :USER-DATA (QUOTE (:WHICH :HASH-KEY))) (ADD-LOOP-PATH (QUOTE (HASH-VALUE HASH-VALUES)) (QUOTE LOOP-HASH-TABLE-ITERATION-PATH) W :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL :USER-DATA (QUOTE (:WHICH :HASH-VALUE))) (ADD-LOOP-PATH (QUOTE (SYMBOL SYMBOLS)) (QUOTE LOOP-PACKAGE-SYMBOLS-ITERATION-PATH) W :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL :USER-DATA (QUOTE (:SYMBOL-TYPES (:INTERNAL :EXTERNAL :INHERITED)))) (ADD-LOOP-PATH (QUOTE (EXTERNAL-SYMBOL EXTERNAL-SYMBOLS)) (QUOTE LOOP-PACKAGE-SYMBOLS-ITERATION-PATH) W :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL :USER-DATA (QUOTE (:SYMBOL-TYPES (:EXTERNAL)))) (ADD-LOOP-PATH (QUOTE (PRESENT-SYMBOL PRESENT-SYMBOLS)) (QUOTE LOOP-PACKAGE-SYMBOLS-ITERATION-PATH) W :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL :USER-DATA (QUOTE (:SYMBOL-TYPES (:INTERNAL :EXTERNAL)))) W))
     [java] ; (DEFPARAMETER *LOOP-ANSI-UNIVERSE* (MAKE-ANSI-LOOP-UNIVERSE NIL))
     [java] ; (DEFUN LOOP-STANDARD-EXPANSION (KEYWORDS-AND-FORMS ENVIRONMENT UNIVERSE) (IF (AND KEYWORDS-AND-FORMS (SYMBOLP (CAR KEYWORDS-AND-FORMS))) (LOOP-TRANSLATE KEYWORDS-AND-FORMS ENVIRONMENT UNIVERSE) (LET ((TAG (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE BLOCK) NIL (SYSTEM::BACKQ-LIST (QUOTE TAGBODY) TAG (SYSTEM::BACKQ-CONS (QUOTE PROGN) KEYWORDS-AND-FORMS) (SYSTEM::BACKQ-LIST (QUOTE GO) TAG))))))
     [java] ; (DEFMACRO LOOP (&ENVIRONMENT ENV &REST KEYWORDS-AND-FORMS) (LOOP-STANDARD-EXPANSION KEYWORDS-AND-FORMS ENV *LOOP-ANSI-UNIVERSE*))
     [java] ; (DEFMACRO LOOP-FINISH NIL "Cause the iteration to terminate \"normally\", the same as implicit
     [java] termination by an iteration driving clause, or by use of WHILE or
     [java] UNTIL -- the epilogue code (if any) will be run, and any implicitly
     [java] collected result will be returned as the value of the LOOP." (QUOTE (GO END-LOOP)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/loop.abcl (13.662 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/backquote.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (%DEFVAR (QUOTE *BQ-COMMA-FLAG*) (QUOTE (|,|)))
     [java] ; (%DEFVAR (QUOTE *BQ-AT-FLAG*) (QUOTE (|,@|)))
     [java] ; (%DEFVAR (QUOTE *BQ-DOT-FLAG*) (QUOTE (|,.|)))
     [java] ; (DEFUN BACKQUOTE-MACRO (STREAM IGNORE) (DECLARE (IGNORE IGNORE)) (LET ((*BACKQUOTE-COUNT* (1+ *BACKQUOTE-COUNT*))) (MULTIPLE-VALUE-BIND (FLAG THING) (BACKQUOTIFY STREAM (READ STREAM T NIL T)) (WHEN (EQ FLAG *BQ-AT-FLAG*) (%READER-ERROR STREAM ",@ after backquote in ~S" THING)) (WHEN (EQ FLAG *BQ-DOT-FLAG*) (%READER-ERROR STREAM ",. after backquote in ~S" THING)) (BACKQUOTIFY-1 FLAG THING))))
     [java] ; (DEFUN COMMA-MACRO (STREAM IGNORE) (DECLARE (IGNORE IGNORE)) (UNLESS (> *BACKQUOTE-COUNT* 0) (WHEN *READ-SUPPRESS* (RETURN-FROM COMMA-MACRO NIL)) (%READER-ERROR STREAM "Comma not inside a backquote.")) (LET ((C (READ-CHAR STREAM)) (*BACKQUOTE-COUNT* (1- *BACKQUOTE-COUNT*))) (COND ((CHAR= C #\@) (CONS *BQ-AT-FLAG* (READ STREAM T NIL T))) ((CHAR= C #\.) (CONS *BQ-DOT-FLAG* (READ STREAM T NIL T))) (T (UNREAD-CHAR C STREAM) (CONS *BQ-COMMA-FLAG* (READ STREAM T NIL T))))))
     [java] ; (DEFUN EXPANDABLE-BACKQ-EXPRESSION-P (OBJECT) (AND (CONSP OBJECT) (LET ((FLAG (%CAR OBJECT))) (OR (EQ FLAG *BQ-AT-FLAG*) (EQ FLAG *BQ-DOT-FLAG*)))))
     [java] ; (DEFUN BACKQUOTIFY (STREAM CODE) (COND ((ATOM CODE) (COND ((NULL CODE) (VALUES NIL NIL)) ((OR (CONSP CODE) (SYMBOLP CODE)) (VALUES (QUOTE QUOTE) CODE)) (T (VALUES T CODE)))) ((OR (EQ (CAR CODE) *BQ-AT-FLAG*) (EQ (CAR CODE) *BQ-DOT-FLAG*)) (VALUES (CAR CODE) (CDR CODE))) ((EQ (CAR CODE) *BQ-COMMA-FLAG*) (COMMA (CDR CODE))) ((EQ (CAR CODE) *BQ-VECTOR-FLAG*) (MULTIPLE-VALUE-BIND (DFLAG D) (BACKQUOTIFY STREAM (CDR CODE)) (VALUES (QUOTE VECTOR) (BACKQUOTIFY-1 DFLAG D)))) (T (MULTIPLE-VALUE-BIND (AFLAG A) (BACKQUOTIFY STREAM (CAR CODE)) (MULTIPLE-VALUE-BIND (DFLAG D) (BACKQUOTIFY STREAM (CDR CODE)) (WHEN (EQ DFLAG *BQ-AT-FLAG*) (%READER-ERROR STREAM ",@ after dot in ~S" CODE)) (WHEN (EQ DFLAG *BQ-DOT-FLAG*) (%READER-ERROR STREAM ",. after dot in ~S" CODE)) (COND ((EQ AFLAG *BQ-AT-FLAG*) (IF (NULL DFLAG) (IF (EXPANDABLE-BACKQ-EXPRESSION-P A) (VALUES (QUOTE APPEND) (LIST A)) (COMMA A)) (VALUES (QUOTE APPEND) (COND ((EQ DFLAG (QUOTE APPEND)) (CONS A D)) (T (LIST A (BACKQUOTIFY-1 DFLAG D))))))) ((EQ AFLAG *BQ-DOT-FLAG*) (IF (NULL DFLAG) (IF (EXPANDABLE-BACKQ-EXPRESSION-P A) (VALUES (QUOTE NCONC) (LIST A)) (COMMA A)) (VALUES (QUOTE NCONC) (COND ((EQ DFLAG (QUOTE NCONC)) (CONS A D)) (T (LIST A (BACKQUOTIFY-1 DFLAG D))))))) ((NULL DFLAG) (IF (MEMQ AFLAG (QUOTE (QUOTE T NIL))) (VALUES (QUOTE QUOTE) (LIST A)) (VALUES (QUOTE LIST) (LIST (BACKQUOTIFY-1 AFLAG A))))) ((MEMQ DFLAG (QUOTE (QUOTE T))) (IF (MEMQ AFLAG (QUOTE (QUOTE T NIL))) (VALUES (QUOTE QUOTE) (CONS A D)) (VALUES (QUOTE LIST*) (LIST (BACKQUOTIFY-1 AFLAG A) (BACKQUOTIFY-1 DFLAG D))))) (T (SETQ A (BACKQUOTIFY-1 AFLAG A)) (IF (MEMQ DFLAG (QUOTE (LIST LIST*))) (VALUES DFLAG (CONS A D)) (VALUES (QUOTE LIST*) (LIST A (BACKQUOTIFY-1 DFLAG D)))))))))))
     [java] ; (DEFUN COMMA (CODE) (COND ((ATOM CODE) (COND ((NULL CODE) (VALUES NIL NIL)) ((OR (NUMBERP CODE) (EQ CODE T)) (VALUES T CODE)) (T (VALUES *BQ-COMMA-FLAG* CODE)))) ((AND (EQ (CAR CODE) (QUOTE QUOTE)) (NOT (EXPANDABLE-BACKQ-EXPRESSION-P (CADR CODE)))) (VALUES (CAR CODE) (CADR CODE))) ((MEMQ (CAR CODE) (QUOTE (APPEND LIST LIST* NCONC))) (VALUES (CAR CODE) (CDR CODE))) ((EQ (CAR CODE) (QUOTE CONS)) (VALUES (QUOTE LIST*) (CDR CODE))) (T (VALUES *BQ-COMMA-FLAG* CODE))))
     [java] ; (DEFUN BACKQUOTIFY-1 (FLAG THING) (COND ((OR (EQ FLAG *BQ-COMMA-FLAG*) (MEMQ FLAG (QUOTE (T NIL)))) THING) ((EQ FLAG (QUOTE QUOTE)) (LIST (QUOTE QUOTE) THING)) ((EQ FLAG (QUOTE LIST*)) (COND ((AND (NULL (CDDR THING)) (NOT (EXPANDABLE-BACKQ-EXPRESSION-P (CADR THING)))) (CONS (QUOTE BACKQ-CONS) THING)) ((EXPANDABLE-BACKQ-EXPRESSION-P (CAR (LAST THING))) (LIST (QUOTE BACKQ-APPEND) (CONS (QUOTE BACKQ-LIST) (BUTLAST THING)) (CAR (LAST THING)))) (T (CONS (QUOTE BACKQ-LIST*) THING)))) ((EQ FLAG (QUOTE VECTOR)) (LIST (QUOTE BACKQ-VECTOR) THING)) (T (CONS (ECASE FLAG ((LIST) (QUOTE BACKQ-LIST)) ((APPEND) (QUOTE BACKQ-APPEND)) ((NCONC) (QUOTE BACKQ-NCONC))) THING))))
     [java] ; (DEFUN BACKQ-LIST (&REST ARGS) (APPLY (FUNCTION LIST) ARGS))
     [java] ; (DEFUN BACKQ-LIST* (&REST ARGS) (APPLY (FUNCTION LIST*) ARGS))
     [java] ; (DEFUN BACKQ-APPEND (&REST ARGS) (APPLY (FUNCTION APPEND) ARGS))
     [java] ; (DEFUN BACKQ-NCONC (&REST ARGS) (APPLY (FUNCTION NCONC) ARGS))
     [java] ; (DEFUN BACKQ-CONS (&REST ARGS) (APPLY (FUNCTION CONS) ARGS))
     [java] ; (DEFUN BACKQ-VECTOR (LIST) (DECLARE (LIST LIST)) (COERCE LIST (QUOTE SIMPLE-VECTOR)))
     [java] ; (%DEFVAR (QUOTE *BACKQ-TOKENS*) (QUOTE (BACKQ-COMMA BACKQ-COMMA-AT BACKQ-COMMA-DOT BACKQ-LIST BACKQ-LIST* BACKQ-APPEND BACKQ-NCONC BACKQ-CONS BACKQ-VECTOR)))
     [java] ; (DEFUN %READER-ERROR (STREAM CONTROL &REST ARGS) (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL CONTROL :FORMAT-ARGUMENTS ARGS))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/backquote.abcl (0.791 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/backquote.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/backquote.abcl (0.07 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/early-defuns.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN %TYPE-ERROR (DATUM EXPECTED-TYPE) (ERROR (QUOTE TYPE-ERROR) :DATUM DATUM :EXPECTED-TYPE EXPECTED-TYPE))
     [java] ; (DEFUN CHECK-SEQUENCE-BOUNDS (SEQUENCE START END) (DECLARE (OPTIMIZE SPEED)) (UNLESS (FIXNUMP START) (%TYPE-ERROR START (QUOTE FIXNUM))) (IF END (UNLESS (FIXNUMP END) (%TYPE-ERROR END (QUOTE FIXNUM))) (SETF END (LENGTH SEQUENCE))) END)
     [java] ; (DEFUN REQUIRE-TYPE (ARG TYPE) (IF (TYPEP ARG TYPE) ARG (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM ARG :EXPECTED-TYPE TYPE)))
     [java] ; (DEFUN NORMALIZE-TYPE (TYPE) (COND ((SYMBOLP TYPE) (CASE TYPE (BIT (RETURN-FROM NORMALIZE-TYPE (QUOTE (INTEGER 0 1)))) (CONS (RETURN-FROM NORMALIZE-TYPE (QUOTE (CONS T T)))) (FIXNUM (RETURN-FROM NORMALIZE-TYPE (QUOTE (INTEGER -2147483648 2147483647)))) (SIGNED-BYTE (RETURN-FROM NORMALIZE-TYPE (QUOTE INTEGER))) (UNSIGNED-BYTE (RETURN-FROM NORMALIZE-TYPE (QUOTE (INTEGER 0 *)))) (BASE-CHAR (RETURN-FROM NORMALIZE-TYPE (QUOTE CHARACTER))) (SHORT-FLOAT (RETURN-FROM NORMALIZE-TYPE (QUOTE SINGLE-FLOAT))) (LONG-FLOAT (RETURN-FROM NORMALIZE-TYPE (QUOTE DOUBLE-FLOAT))) (COMPLEX (RETURN-FROM NORMALIZE-TYPE (QUOTE (COMPLEX *)))) (ARRAY (RETURN-FROM NORMALIZE-TYPE (QUOTE (ARRAY * *)))) (SIMPLE-ARRAY (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-ARRAY * *)))) (VECTOR (RETURN-FROM NORMALIZE-TYPE (QUOTE (ARRAY * (*))))) (SIMPLE-VECTOR (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-ARRAY T (*))))) (BIT-VECTOR (RETURN-FROM NORMALIZE-TYPE (QUOTE (BIT-VECTOR *)))) (SIMPLE-BIT-VECTOR (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-BIT-VECTOR *)))) (BASE-STRING (RETURN-FROM NORMALIZE-TYPE (QUOTE (ARRAY BASE-CHAR (*))))) (SIMPLE-BASE-STRING (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-ARRAY BASE-CHAR (*))))) (STRING (RETURN-FROM NORMALIZE-TYPE (QUOTE (STRING *)))) (SIMPLE-STRING (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-STRING *)))) ((NIL) (RETURN-FROM NORMALIZE-TYPE NIL)) (T (UNLESS (GET TYPE (QUOTE DEFTYPE-DEFINITION)) (RETURN-FROM NORMALIZE-TYPE TYPE))))) ((CLASSP TYPE) (RETURN-FROM NORMALIZE-TYPE (IF (EQ (%CLASS-NAME TYPE) (QUOTE FIXNUM)) (QUOTE (INTEGER -2147483648 2147483647)) TYPE))) ((AND (CONSP TYPE) (MEMQ (%CAR TYPE) (QUOTE (AND OR NOT EQL MEMBER SATISFIES MOD VALUES)))) (COND ((OR (EQUAL TYPE (QUOTE (AND FIXNUM UNSIGNED-BYTE))) (EQUAL TYPE (QUOTE (AND UNSIGNED-BYTE FIXNUM)))) (RETURN-FROM NORMALIZE-TYPE (QUOTE (INTEGER 0 2147483647)))) (T (RETURN-FROM NORMALIZE-TYPE TYPE))))) (LET (TP I) (LOOP (IF (CONSP TYPE) (SETF TP (%CAR TYPE) I (%CDR TYPE)) (SETF TP TYPE I NIL)) (IF (AND (SYMBOLP TP) (GET TP (QUOTE DEFTYPE-DEFINITION))) (SETF TYPE (APPLY (GET TP (QUOTE DEFTYPE-DEFINITION)) I)) (RETURN))) (CASE TP (INTEGER (RETURN-FROM NORMALIZE-TYPE (IF I (CONS TP I) TP))) (CONS (LET* ((LEN (LENGTH I)) (CAR-TYPESPEC (IF (> LEN 0) (CAR I) T)) (CDR-TYPESPEC (IF (> LEN 1) (CADR I) T))) (UNLESS (AND CAR-TYPESPEC CDR-TYPESPEC) (RETURN-FROM NORMALIZE-TYPE NIL)) (WHEN (EQ CAR-TYPESPEC (QUOTE *)) (SETF CAR-TYPESPEC T)) (WHEN (EQ CDR-TYPESPEC (QUOTE *)) (SETF CDR-TYPESPEC T)) (RETURN-FROM NORMALIZE-TYPE (CONS TP (LIST CAR-TYPESPEC CDR-TYPESPEC))))) (SIGNED-BYTE (IF (OR (NULL I) (EQ (CAR I) (QUOTE *))) (RETURN-FROM NORMALIZE-TYPE (QUOTE INTEGER)) (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE INTEGER) (- (EXPT 2 (1- (CAR I)))) (1- (EXPT 2 (1- (CAR I)))))))) (UNSIGNED-BYTE (IF (OR (NULL I) (EQ (CAR I) (QUOTE *))) (RETURN-FROM NORMALIZE-TYPE (QUOTE (INTEGER 0 *)))) (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE INTEGER) 0 (1- (EXPT 2 (CAR I)))))) ((ARRAY SIMPLE-ARRAY) (UNLESS I (RETURN-FROM NORMALIZE-TYPE (LIST TP (QUOTE *) (QUOTE *)))) (WHEN (= (LENGTH I) 1) (SETF I (APPEND I (QUOTE (*))))) (SETF (CAR I) (NORMALIZE-TYPE (CAR I))) (RETURN-FROM NORMALIZE-TYPE (CONS TP I))) (VECTOR (CASE (LENGTH I) (0 (RETURN-FROM NORMALIZE-TYPE (QUOTE (ARRAY * (*))))) (1 (SETF (CAR I) (NORMALIZE-TYPE (CAR I))) (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE ARRAY) (CAR I) (QUOTE (*))))) (2 (SETF (CAR I) (NORMALIZE-TYPE (CAR I))) (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE ARRAY) (CAR I) (LIST (CADR I))))) (T (ERROR "Invalid type specifier ~S." TYPE)))) (SIMPLE-VECTOR (CASE (LENGTH I) (0 (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-ARRAY T (*))))) (1 (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE SIMPLE-ARRAY) T (LIST (CAR I))))) (T (ERROR "Invalid type specifier ~S." TYPE)))) (BIT-VECTOR (CASE (LENGTH I) (0 (RETURN-FROM NORMALIZE-TYPE (QUOTE (BIT-VECTOR *)))) (1 (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE BIT-VECTOR) (CAR I)))) (T (ERROR "Invalid type specifier ~S." TYPE)))) (SIMPLE-BIT-VECTOR (CASE (LENGTH I) (0 (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-BIT-VECTOR *)))) (1 (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE SIMPLE-BIT-VECTOR) (CAR I)))) (T (ERROR "Invalid type specifier ~S." TYPE)))) (BASE-STRING (IF I (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE ARRAY) (QUOTE BASE-CHAR) (LIST (CAR I)))) (RETURN-FROM NORMALIZE-TYPE (QUOTE (ARRAY BASE-CHAR (*)))))) (SIMPLE-BASE-STRING (IF I (RETURN-FROM NORMALIZE-TYPE (LIST (QUOTE SIMPLE-ARRAY) (QUOTE BASE-CHAR) (LIST (CAR I)))) (RETURN-FROM NORMALIZE-TYPE (QUOTE (SIMPLE-ARRAY BASE-CHAR (*)))))) (SHORT-FLOAT (SETF TP (QUOTE SINGLE-FLOAT))) (LONG-FLOAT (SETF TP (QUOTE DOUBLE-FLOAT))) (COMPLEX (COND ((NULL I) (RETURN-FROM NORMALIZE-TYPE (QUOTE (COMPLEX *)))) ((EQ (CAR I) (QUOTE SHORT-FLOAT)) (RETURN-FROM NORMALIZE-TYPE (QUOTE (COMPLEX SINGLE-FLOAT)))) ((EQ (CAR I) (QUOTE LONG-FLOAT)) (RETURN-FROM NORMALIZE-TYPE (QUOTE (COMPLEX DOUBLE-FLOAT))))))) (IF I (CONS TP I) TP)))
     [java] ; (DEFUN CAAAAR (LIST) (CAR (CAR (CAR (CAR LIST)))))
     [java] ; (DEFUN CAAADR (LIST) (CAR (CAR (CAR (CDR LIST)))))
     [java] ; (DEFUN CAADDR (LIST) (CAR (CAR (CDR (CDR LIST)))))
     [java] ; (DEFUN CADDDR (LIST) (CAR (CDR (CDR (CDR LIST)))))
     [java] ; (DEFUN CDDDDR (LIST) (CDR (CDR (CDR (CDR LIST)))))
     [java] ; (DEFUN CDAAAR (LIST) (CDR (CAR (CAR (CAR LIST)))))
     [java] ; (DEFUN CDDAAR (LIST) (CDR (CDR (CAR (CAR LIST)))))
     [java] ; (DEFUN CDDDAR (LIST) (CDR (CDR (CDR (CAR LIST)))))
     [java] ; (DEFUN CAADAR (LIST) (CAR (CAR (CDR (CAR LIST)))))
     [java] ; (DEFUN CADAAR (LIST) (CAR (CDR (CAR (CAR LIST)))))
     [java] ; (DEFUN CADADR (LIST) (CAR (CDR (CAR (CDR LIST)))))
     [java] ; (DEFUN CADDAR (LIST) (CAR (CDR (CDR (CAR LIST)))))
     [java] ; (DEFUN CDAADR (LIST) (CDR (CAR (CAR (CDR LIST)))))
     [java] ; (DEFUN CDADAR (LIST) (CDR (CAR (CDR (CAR LIST)))))
     [java] ; (DEFUN CDADDR (LIST) (CDR (CAR (CDR (CDR LIST)))))
     [java] ; (DEFUN CDDADR (LIST) (CDR (CDR (CAR (CDR LIST)))))
     [java] ; (DEFUN SOME (PREDICATE SEQUENCE &REST MORE-SEQUENCES) (SETQ MORE-SEQUENCES (CONS SEQUENCE MORE-SEQUENCES)) (DO ((I 0 (1+ I)) (L (APPLY (FUNCTION MIN) (MAPCAR (FUNCTION LENGTH) MORE-SEQUENCES)))) ((>= I L) NIL) (LET ((THAT-VALUE (APPLY PREDICATE (MAPCAR (FUNCTION (LAMBDA (Z) (ELT Z I))) MORE-SEQUENCES)))) (WHEN THAT-VALUE (RETURN THAT-VALUE)))))
     [java] ; (DEFUN EVERY (PREDICATE SEQUENCE &REST MORE-SEQUENCES) (DECLARE (OPTIMIZE SPEED)) (COND ((NULL MORE-SEQUENCES) (COND ((LISTP SEQUENCE) (DOLIST (X SEQUENCE T) (UNLESS (FUNCALL PREDICATE X) (RETURN NIL)))) (T (DOTIMES (I (LENGTH SEQUENCE) T) (DECLARE (TYPE INDEX I)) (UNLESS (FUNCALL PREDICATE (ELT SEQUENCE I)) (RETURN NIL)))))) (T (SETQ MORE-SEQUENCES (CONS SEQUENCE MORE-SEQUENCES)) (DO ((I 0 (1+ I)) (L (APPLY (FUNCTION MIN) (MAPCAR (FUNCTION LENGTH) MORE-SEQUENCES)))) ((>= I L) T) (UNLESS (APPLY PREDICATE (MAPCAR (FUNCTION (LAMBDA (Z) (ELT Z I))) MORE-SEQUENCES)) (RETURN NIL))))))
     [java] ; (DEFUN NOTANY (PREDICATE SEQUENCE &REST MORE-SEQUENCES) (NOT (APPLY (FUNCTION SOME) PREDICATE SEQUENCE MORE-SEQUENCES)))
     [java] ; (DEFUN NOTEVERY (PREDICATE SEQUENCE &REST MORE-SEQUENCES) (NOT (APPLY (FUNCTION EVERY) PREDICATE SEQUENCE MORE-SEQUENCES)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/early-defuns.abcl (1.331 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/early-defuns.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/early-defuns.abcl (0.156 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/typep.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN SIMPLE-ARRAY-P (OBJECT) (AND (ARRAYP OBJECT) (NOT (ARRAY-HAS-FILL-POINTER-P OBJECT)) (MULTIPLE-VALUE-BIND (DISPLACED-TO OFFSET) (ARRAY-DISPLACEMENT OBJECT) (AND (NULL DISPLACED-TO) (ZEROP OFFSET)))))
     [java] ; (DEFUN IN-INTERVAL-P (X INTERVAL) (IF (ENDP INTERVAL) T (LET ((LOW (%CAR INTERVAL)) (HIGH (IF (ENDP (%CDR INTERVAL)) (QUOTE *) (%CADR INTERVAL)))) (COND ((EQ LOW (QUOTE *))) ((CONSP LOW) (WHEN (<= X (%CAR LOW)) (RETURN-FROM IN-INTERVAL-P NIL))) ((WHEN (< X LOW) (RETURN-FROM IN-INTERVAL-P NIL)))) (COND ((EQ HIGH (QUOTE *))) ((CONSP HIGH) (WHEN (>= X (%CAR HIGH)) (RETURN-FROM IN-INTERVAL-P NIL))) ((WHEN (> X HIGH) (RETURN-FROM IN-INTERVAL-P NIL)))) T)))
     [java] ; (DEFUN MATCH-DIMENSIONS (DIM PAT) (IF (NULL DIM) (NULL PAT) (AND (OR (EQ (CAR PAT) (QUOTE *)) (EQL (CAR DIM) (CAR PAT))) (MATCH-DIMENSIONS (CDR DIM) (CDR PAT)))))
     [java] ; (DEFUN %TYPEP (OBJECT TYPE) (WHEN (ATOM TYPE) (WHEN (EQ TYPE (QUOTE VALUES)) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "The symbol ~S is not valid as a type specifier." :FORMAT-ARGUMENTS (LIST TYPE))) (UNLESS (AND (SYMBOLP TYPE) (GET TYPE (QUOTE DEFTYPE-DEFINITION))) (RETURN-FROM %TYPEP (SIMPLE-TYPEP OBJECT TYPE)))) (SETF TYPE (NORMALIZE-TYPE TYPE)) (WHEN (ATOM TYPE) (RETURN-FROM %TYPEP (SIMPLE-TYPEP OBJECT TYPE))) (LET ((TP (%CAR TYPE)) (I (%CDR TYPE))) (CASE TP (INTEGER (AND (INTEGERP OBJECT) (IN-INTERVAL-P OBJECT I))) (RATIONAL (AND (RATIONALP OBJECT) (IN-INTERVAL-P OBJECT I))) ((FLOAT SINGLE-FLOAT DOUBLE-FLOAT SHORT-FLOAT LONG-FLOAT) (AND (FLOATP OBJECT) (IN-INTERVAL-P OBJECT I))) (REAL (AND (REALP OBJECT) (IN-INTERVAL-P OBJECT I))) (COMPLEX (AND (COMPLEXP OBJECT) (OR (NULL I) (AND (TYPEP (REALPART OBJECT) I) (TYPEP (IMAGPART OBJECT) I))))) (CONS (AND (CONSP OBJECT) (OR (NULL (CAR I)) (EQ (CAR I) (QUOTE *)) (%TYPEP (%CAR OBJECT) (CAR I))) (OR (NULL (CADR I)) (EQ (CADR I) (QUOTE *)) (%TYPEP (%CDR OBJECT) (CADR I))))) (SIMPLE-BIT-VECTOR (AND (SIMPLE-BIT-VECTOR-P OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQL (%CAR I) (ARRAY-DIMENSION OBJECT 0))))) (BIT-VECTOR (AND (BIT-VECTOR-P OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQL (%CAR I) (ARRAY-DIMENSION OBJECT 0))))) (SIMPLE-STRING (AND (SIMPLE-STRING-P OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQL (%CAR I) (ARRAY-DIMENSION OBJECT 0))))) (STRING (AND (STRINGP OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQL (%CAR I) (ARRAY-DIMENSION OBJECT 0))))) (SIMPLE-VECTOR (AND (SIMPLE-VECTOR-P OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQL (%CAR I) (ARRAY-DIMENSION OBJECT 0))))) (VECTOR (AND (VECTORP OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (AND (EQ (%CAR I) T) (NOT (STRINGP OBJECT)) (NOT (BIT-VECTOR-P OBJECT))) (AND (STRINGP OBJECT) (%SUBTYPEP (%CAR I) (QUOTE CHARACTER))) (EQUAL (ARRAY-ELEMENT-TYPE OBJECT) (%CAR I))) (OR (ENDP (CDR I)) (EQ (%CADR I) (QUOTE *)) (EQL (%CADR I) (ARRAY-DIMENSION OBJECT 0))))) (SIMPLE-ARRAY (AND (SIMPLE-ARRAY-P OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQUAL (ARRAY-ELEMENT-TYPE OBJECT) (UPGRADED-ARRAY-ELEMENT-TYPE (%CAR I)))) (OR (ENDP (CDR I)) (EQ (%CADR I) (QUOTE *)) (IF (LISTP (%CADR I)) (MATCH-DIMENSIONS (ARRAY-DIMENSIONS OBJECT) (%CADR I)) (EQL (ARRAY-RANK OBJECT) (%CADR I)))))) (ARRAY (AND (ARRAYP OBJECT) (OR (ENDP I) (EQ (%CAR I) (QUOTE *)) (EQUAL (ARRAY-ELEMENT-TYPE OBJECT) (UPGRADED-ARRAY-ELEMENT-TYPE (%CAR I)))) (OR (ENDP (CDR I)) (EQ (%CADR I) (QUOTE *)) (IF (LISTP (%CADR I)) (MATCH-DIMENSIONS (ARRAY-DIMENSIONS OBJECT) (%CADR I)) (EQL (ARRAY-RANK OBJECT) (%CADR I)))))) (AND (DOLIST (TYPE I) (UNLESS (%TYPEP OBJECT TYPE) (RETURN-FROM %TYPEP NIL))) T) (OR (DOLIST (TYPE I) (WHEN (%TYPEP OBJECT TYPE) (RETURN-FROM %TYPEP T))) NIL) (NOT (NOT (%TYPEP OBJECT (CAR I)))) (MEMBER (MEMBER OBJECT I)) (EQL (EQL OBJECT (CAR I))) (SATISFIES (UNLESS (SYMBOLP (CAR I)) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM (CAR I) :EXPECTED-TYPE (QUOTE SYMBOL) :FORMAT-CONTROL "The SATISFIES predicate name is not a symbol: ~S" :FORMAT-ARGUMENTS (LIST (CAR I)))) (FUNCALL (CAR I) OBJECT)) (NIL-VECTOR (AND (SIMPLE-TYPEP OBJECT (QUOTE NIL-VECTOR)) (OR (ENDP I) (EQL (%CAR I) (LENGTH OBJECT))))) (MOD (AND (INTEGERP OBJECT) (OR (ZEROP OBJECT) (AND (PLUSP OBJECT) (< OBJECT (SECOND TYPE)))))) ((FUNCTION VALUES) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "~S types are not a legal argument to TYPEP: ~S" :FORMAT-ARGUMENTS (LIST TP TYPE))) (T NIL))))
     [java] ; (DEFUN TYPEP (OBJECT TYPE &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (%TYPEP OBJECT TYPE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/typep.abcl (0.716 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/typep.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/typep.abcl (0.036 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/subtypep.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFPARAMETER *KNOWN-TYPES* (MAKE-HASH-TABLE :TEST (QUOTE EQ)))
     [java] ; (DEFUN INITIALIZE-KNOWN-TYPES NIL (LET ((HT (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (DOLIST (I (QUOTE ((ARITHMETIC-ERROR ERROR) (ARRAY) (BASE-STRING STRING) (BIGNUM INTEGER) (BIT FIXNUM) (BIT-VECTOR VECTOR) (BOOLEAN SYMBOL) (BUILT-IN-CLASS CLASS) (CELL-ERROR ERROR) (CHARACTER) (CLASS STANDARD-OBJECT) (COMPILED-FUNCTION FUNCTION) (COMPLEX NUMBER) (CONDITION) (CONS LIST) (CONTROL-ERROR ERROR) (DIVISION-BY-ZERO ARITHMETIC-ERROR) (DOUBLE-FLOAT FLOAT) (END-OF-FILE STREAM-ERROR) (ERROR SERIOUS-CONDITION) (EXTENDED-CHAR CHARACTER NIL) (FILE-ERROR ERROR) (FIXNUM INTEGER) (FLOAT REAL) (FLOATING-POINT-INEXACT ARITHMETIC-ERROR) (FLOATING-POINT-INVALID-OPERATION ARITHMETIC-ERROR) (FLOATING-POINT-OVERFLOW ARITHMETIC-ERROR) (FLOATING-POINT-UNDERFLOW ARITHMETIC-ERROR) (FUNCTION) (GENERIC-FUNCTION FUNCTION) (HASH-TABLE) (INTEGER RATIONAL) (KEYWORD SYMBOL) (LIST SEQUENCE) (LONG-FLOAT FLOAT) (NIL-VECTOR SIMPLE-STRING) (NULL BOOLEAN LIST) (NUMBER) (PACKAGE) (PACKAGE-ERROR ERROR) (PARSE-ERROR ERROR) (PATHNAME) (PRINT-NOT-READABLE ERROR) (PROGRAM-ERROR ERROR) (RANDOM-STATE) (RATIO RATIONAL) (RATIONAL REAL) (READER-ERROR PARSE-ERROR STREAM-ERROR) (READTABLE) (REAL NUMBER) (RESTART) (SERIOUS-CONDITION CONDITION) (SHORT-FLOAT FLOAT) (SIMPLE-ARRAY ARRAY) (SIMPLE-BASE-STRING SIMPLE-STRING BASE-STRING) (SIMPLE-BIT-VECTOR BIT-VECTOR SIMPLE-ARRAY) (SIMPLE-CONDITION CONDITION) (SIMPLE-ERROR SIMPLE-CONDITION ERROR) (SIMPLE-STRING BASE-STRING STRING SIMPLE-ARRAY) (SIMPLE-TYPE-ERROR SIMPLE-CONDITION TYPE-ERROR) (SIMPLE-VECTOR VECTOR SIMPLE-ARRAY) (SIMPLE-WARNING SIMPLE-CONDITION WARNING) (SINGLE-FLOAT FLOAT) (STANDARD-CHAR CHARACTER) (STANDARD-CLASS CLASS) (STANDARD-GENERIC-FUNCTION GENERIC-FUNCTION) (STANDARD-OBJECT) (STORAGE-CONDITION SERIOUS-CONDITION) (STREAM) (STREAM-ERROR ERROR) (STRING VECTOR) (STRUCTURE-CLASS CLASS STANDARD-OBJECT) (STYLE-WARNING WARNING) (SYMBOL) (TWO-WAY-STREAM STREAM) (TYPE-ERROR ERROR) (UNBOUND-SLOT CELL-ERROR) (UNBOUND-VARIABLE CELL-ERROR) (UNDEFINED-FUNCTION CELL-ERROR) (VECTOR ARRAY SEQUENCE) (WARNING CONDITION)))) (SETF (GETHASH (%CAR I) HT) (%CDR I))) (SETF *KNOWN-TYPES* HT)))
     [java] ; (DEFUN KNOWN-TYPE-P (TYPE) (MULTIPLE-VALUE-BIND (VALUE PRESENT-P) (GETHASH TYPE *KNOWN-TYPES*) PRESENT-P))
     [java] ; (DEFUN SUB-INTERVAL-P (I1 I2) (LET (LOW1 HIGH1 LOW2 HIGH2) (IF (NULL I1) (SETQ LOW1 (QUOTE *) HIGH1 (QUOTE *)) (IF (NULL (CDR I1)) (SETQ LOW1 (CAR I1) HIGH1 (QUOTE *)) (SETQ LOW1 (CAR I1) HIGH1 (CADR I1)))) (IF (NULL I2) (SETQ LOW2 (QUOTE *) HIGH2 (QUOTE *)) (IF (NULL (CDR I2)) (SETQ LOW2 (CAR I2) HIGH2 (QUOTE *)) (SETQ LOW2 (CAR I2) HIGH2 (CADR I2)))) (WHEN (AND (CONSP LOW1) (INTEGERP (%CAR LOW1))) (SETQ LOW1 (1+ (CAR LOW1)))) (WHEN (AND (CONSP LOW2) (INTEGERP (%CAR LOW2))) (SETQ LOW2 (1+ (CAR LOW2)))) (WHEN (AND (CONSP HIGH1) (INTEGERP (%CAR HIGH1))) (SETQ HIGH1 (1- (CAR HIGH1)))) (WHEN (AND (CONSP HIGH2) (INTEGERP (%CAR HIGH2))) (SETQ HIGH2 (1- (CAR HIGH2)))) (COND ((EQ LOW1 (QUOTE *)) (UNLESS (EQ LOW2 (QUOTE *)) (RETURN-FROM SUB-INTERVAL-P NIL))) ((EQ LOW2 (QUOTE *))) ((CONSP LOW1) (IF (CONSP LOW2) (WHEN (< (%CAR LOW1) (%CAR LOW2)) (RETURN-FROM SUB-INTERVAL-P NIL)) (WHEN (< (%CAR LOW1) LOW2) (RETURN-FROM SUB-INTERVAL-P NIL)))) ((IF (CONSP LOW2) (WHEN (<= LOW1 (%CAR LOW2)) (RETURN-FROM SUB-INTERVAL-P NIL)) (WHEN (< LOW1 LOW2) (RETURN-FROM SUB-INTERVAL-P NIL))))) (COND ((EQ HIGH1 (QUOTE *)) (UNLESS (EQ HIGH2 (QUOTE *)) (RETURN-FROM SUB-INTERVAL-P NIL))) ((EQ HIGH2 (QUOTE *))) ((CONSP HIGH1) (IF (CONSP HIGH2) (WHEN (> (%CAR HIGH1) (%CAR HIGH2)) (RETURN-FROM SUB-INTERVAL-P NIL)) (WHEN (> (%CAR HIGH1) HIGH2) (RETURN-FROM SUB-INTERVAL-P NIL)))) ((IF (CONSP HIGH2) (WHEN (>= HIGH1 (%CAR HIGH2)) (RETURN-FROM SUB-INTERVAL-P NIL)) (WHEN (> HIGH1 HIGH2) (RETURN-FROM SUB-INTERVAL-P NIL))))) (RETURN-FROM SUB-INTERVAL-P T)))
     [java] ; (DEFUN DIMENSION-SUBTYPEP (DIM1 DIM2) (COND ((EQ DIM2 (QUOTE *)) T) ((EQUAL DIM1 DIM2) T) ((INTEGERP DIM2) (AND (LISTP DIM1) (= (LENGTH DIM1) DIM2))) ((EQL DIM1 0) (NULL DIM2)) ((INTEGERP DIM1) (AND (CONSP DIM2) (= (LENGTH DIM2) DIM1) (EQUAL DIM2 (MAKE-LIST DIM1 :INITIAL-ELEMENT (QUOTE *))))) ((AND (CONSP DIM1) (CONSP DIM2) (= (LENGTH DIM1) (LENGTH DIM2))) (DO* ((LIST1 DIM1 (CDR LIST1)) (LIST2 DIM2 (CDR LIST2)) (E1 (CAR LIST1) (CAR LIST1)) (E2 (CAR LIST2) (CAR LIST2))) ((NULL LIST1) T) (UNLESS (OR (EQ E2 (QUOTE *)) (EQL E1 E2)) (RETURN NIL)))) (T NIL)))
     [java] ; (DEFUN SIMPLE-SUBTYPEP (TYPE1 TYPE2) (IF (EQ TYPE1 TYPE2) T (MULTIPLE-VALUE-BIND (TYPE1-SUPERTYPES TYPE1-KNOWN-P) (GETHASH TYPE1 *KNOWN-TYPES*) (IF TYPE1-KNOWN-P (IF (MEMQ TYPE2 TYPE1-SUPERTYPES) T (DOLIST (SUPERTYPE TYPE1-SUPERTYPES) (WHEN (SIMPLE-SUBTYPEP SUPERTYPE TYPE2) (RETURN T)))) NIL))))
     [java] ; (DEFUN MAKE-CTYPE (SUPER TYPE) (CONS SUPER TYPE))
     [java] ; (DEFUN CTYPE-SUPER (CTYPE) (CAR CTYPE))
     [java] ; (DEFUN CTYPE-TYPE (CTYPE) (CDR CTYPE))
     [java] ; (DEFUN CTYPE (TYPE) (COND ((CLASSP TYPE) NIL) (T (LET ((TP (IF (ATOM TYPE) TYPE (CAR TYPE)))) (CASE TP ((ARRAY VECTOR STRING SIMPLE-ARRAY SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING BIT-VECTOR SIMPLE-BIT-VECTOR NIL-VECTOR) (MAKE-CTYPE (QUOTE ARRAY) TYPE)) ((REAL INTEGER BIT FIXNUM SIGNED-BYTE UNSIGNED-BYTE BIGNUM RATIO FLOAT SINGLE-FLOAT DOUBLE-FLOAT SHORT-FLOAT LONG-FLOAT) (MAKE-CTYPE (QUOTE REAL) TYPE)) (COMPLEX (MAKE-CTYPE (QUOTE COMPLEX) (IF (ATOM TYPE) (QUOTE *) (CADR TYPE)))) (FUNCTION (MAKE-CTYPE (QUOTE FUNCTION) TYPE)))))))
     [java] ; (DEFUN CSUBTYPEP-ARRAY (CT1 CT2) (LET ((TYPE1 (NORMALIZE-TYPE (CTYPE-TYPE CT1))) (TYPE2 (NORMALIZE-TYPE (CTYPE-TYPE CT2)))) (WHEN (EQ TYPE1 TYPE2) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T))) (LET (T1 T2 I1 I2) (IF (ATOM TYPE1) (SETF T1 TYPE1 I1 NIL) (SETF T1 (CAR TYPE1) I1 (CDR TYPE1))) (IF (ATOM TYPE2) (SETF T2 TYPE2 I2 NIL) (SETF T2 (CAR TYPE2) I2 (CDR TYPE2))) (COND ((AND (CLASSP T1) (EQ (%CLASS-NAME T1) (QUOTE ARRAY)) (EQ T2 (QUOTE ARRAY))) (VALUES (EQUAL I2 (QUOTE (* *))) T)) ((AND (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (EQ T2 (QUOTE ARRAY))) (LET ((E1 (CAR I1)) (E2 (CAR I2)) (D1 (CADR I1)) (D2 (CADR I2))) (COND ((AND (EQ E2 (QUOTE *)) (EQ D2 (QUOTE *))) (VALUES T T)) ((OR (EQ E2 (QUOTE *)) (EQUAL E1 E2) (EQUAL (UPGRADED-ARRAY-ELEMENT-TYPE E1) (UPGRADED-ARRAY-ELEMENT-TYPE E2))) (VALUES (DIMENSION-SUBTYPEP D1 D2) T)) (T (VALUES NIL T))))) ((AND (MEMQ T1 (QUOTE (SIMPLE-BASE-STRING BASE-STRING SIMPLE-STRING STRING NIL-VECTOR))) (MEMQ T2 (QUOTE (SIMPLE-BASE-STRING BASE-STRING SIMPLE-STRING STRING NIL-VECTOR)))) (IF (AND (SIMPLE-SUBTYPEP T1 T2) (OR (EQL (CAR I1) (CAR I2)) (EQ (CAR I2) (QUOTE *)))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) ((AND (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (EQ T2 (QUOTE STRING))) (LET ((ELEMENT-TYPE (CAR I1)) (DIM (CADR I1)) (SIZE (CAR I2))) (UNLESS (%SUBTYPEP ELEMENT-TYPE (QUOTE CHARACTER)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))))) ((AND (EQ T1 (QUOTE SIMPLE-ARRAY)) (EQ T2 (QUOTE SIMPLE-STRING))) (LET ((ELEMENT-TYPE (CAR I1)) (DIM (CADR I1)) (SIZE (CAR I2))) (UNLESS (%SUBTYPEP ELEMENT-TYPE (QUOTE CHARACTER)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))))) ((AND (MEMQ T1 (QUOTE (STRING SIMPLE-STRING NIL-VECTOR))) (EQ T2 (QUOTE ARRAY))) (LET ((ELEMENT-TYPE (CAR I2)) (DIM (CADR I2)) (SIZE (CAR I1))) (UNLESS (EQ ELEMENT-TYPE (QUOTE *)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1) (OR (EQ (%CAR DIM) (QUOTE *)) (EQL (%CAR DIM) SIZE)))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))))) ((AND (MEMQ T1 (QUOTE (BIT-VECTOR SIMPLE-BIT-VECTOR))) (EQ T2 (QUOTE ARRAY))) (LET ((ELEMENT-TYPE (CAR I2)) (DIM (CADR I2)) (SIZE (CAR I1))) (UNLESS (OR (MEMQ ELEMENT-TYPE (QUOTE (BIT *))) (EQUAL ELEMENT-TYPE (QUOTE (INTEGER 0 1)))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1) (OR (EQ (%CAR DIM) (QUOTE *)) (EQL (%CAR DIM) SIZE)))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))))) ((EQ T2 (QUOTE SIMPLE-ARRAY)) (CASE T1 (SIMPLE-ARRAY (LET ((E1 (CAR I1)) (E2 (CAR I2)) (D1 (CADR I1)) (D2 (CADR I2))) (COND ((AND (EQ E2 (QUOTE *)) (EQ D2 (QUOTE *))) (VALUES T T)) ((OR (EQ E2 (QUOTE *)) (EQUAL E1 E2) (EQUAL (UPGRADED-ARRAY-ELEMENT-TYPE E1) (UPGRADED-ARRAY-ELEMENT-TYPE E2))) (VALUES (DIMENSION-SUBTYPEP D1 D2) T)) (T (VALUES NIL T))))) ((SIMPLE-STRING SIMPLE-BIT-VECTOR NIL-VECTOR) (LET ((ELEMENT-TYPE (CAR I2)) (DIM (CADR I2)) (SIZE (CAR I1))) (UNLESS (EQ ELEMENT-TYPE (QUOTE *)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (OR (EQ DIM (QUOTE *)) (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES T T)) (RETURN-FROM CSUBTYPEP-ARRAY (VALUES NIL T)))))) (T (VALUES NIL T)))) ((EQ T2 (QUOTE BIT-VECTOR)) (LET ((SIZE1 (CAR I1)) (SIZE2 (CAR I2))) (CASE T1 ((BIT-VECTOR SIMPLE-BIT-VECTOR) (VALUES (IF (OR (EQ SIZE2 (QUOTE *)) (EQL SIZE1 SIZE2)) T NIL) T)) (T (VALUES NIL T))))) ((EQ T2 (QUOTE SIMPLE-BIT-VECTOR)) (LET ((SIZE1 (CAR I1)) (SIZE2 (CAR I2))) (IF (AND (EQ T1 (QUOTE SIMPLE-BIT-VECTOR)) (OR (EQ SIZE2 (QUOTE *)) (EQL SIZE1 SIZE2))) (VALUES T T) (VALUES NIL T)))) ((CLASSP T2) (LET ((CLASS-NAME (%CLASS-NAME T2))) (COND ((EQ CLASS-NAME T1) (VALUES T T)) ((AND (EQ CLASS-NAME (QUOTE ARRAY)) (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY VECTOR SIMPLE-VECTOR STRING SIMPLE-STRING SIMPLE-BASE-STRING BIT-VECTOR SIMPLE-BIT-VECTOR)))) (VALUES T T)) ((EQ CLASS-NAME (QUOTE VECTOR)) (COND ((MEMQ T1 (QUOTE (STRING SIMPLE-STRING))) (VALUES T T)) ((EQ T1 (QUOTE ARRAY)) (LET ((DIM (CADR I1))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (VALUES T T) (VALUES NIL T)))) (T (VALUES NIL T)))) ((AND (EQ CLASS-NAME (QUOTE SIMPLE-VECTOR)) (EQ T1 (QUOTE SIMPLE-ARRAY))) (LET ((DIM (CADR I1))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (VALUES T T) (VALUES NIL T)))) ((AND (EQ CLASS-NAME (QUOTE BIT-VECTOR)) (EQ T1 (QUOTE SIMPLE-BIT-VECTOR))) (VALUES T T)) ((AND (EQ CLASS-NAME (QUOTE STRING)) (MEMQ T1 (QUOTE (STRING SIMPLE-STRING)))) (VALUES T T)) (T (VALUES NIL NIL))))) (T (VALUES NIL NIL))))))
     [java] ; (DEFUN CSUBTYPEP-FUNCTION (CT1 CT2) (LET ((TYPE1 (CTYPE-TYPE CT1)) (TYPE2 (CTYPE-TYPE CT2))) (COND ((AND (LISTP TYPE1) (ATOM TYPE2)) (VALUES T T)) (T (VALUES NIL NIL)))))
     [java] ; (DEFUN CSUBTYPEP-COMPLEX (CT1 CT2) (LET ((TYPE1 (CDR CT1)) (TYPE2 (CDR CT2))) (COND ((OR (NULL TYPE2) (EQ TYPE2 (QUOTE *))) (VALUES T T)) ((EQ TYPE1 (QUOTE *)) (VALUES NIL T)) (T (SUBTYPEP TYPE1 TYPE2)))))
     [java] ; (DEFUN CSUBTYPEP (CTYPE1 CTYPE2) (COND ((NULL (AND CTYPE1 CTYPE2)) (VALUES NIL NIL)) ((NEQ (CTYPE-SUPER CTYPE1) (CTYPE-SUPER CTYPE2)) (VALUES NIL T)) ((EQ (CTYPE-SUPER CTYPE1) (QUOTE ARRAY)) (CSUBTYPEP-ARRAY CTYPE1 CTYPE2)) ((EQ (CTYPE-SUPER CTYPE1) (QUOTE FUNCTION)) (CSUBTYPEP-FUNCTION CTYPE1 CTYPE2)) ((EQ (CTYPE-SUPER CTYPE1) (QUOTE COMPLEX)) (CSUBTYPEP-COMPLEX CTYPE1 CTYPE2)) (T (VALUES NIL NIL))))
     [java] ; (DEFUN PROPERLY-NAMED-CLASS-P (THING ENVIRONMENT) (AND (CLASSP THING) (CLASS-NAME THING) (EQ THING (FIND-CLASS (CLASS-NAME THING) NIL ENVIRONMENT))))
     [java] ; (DEFCONSTANT +THE-T-CLASS+ (FIND-CLASS (QUOTE T)))
     [java] ; (DEFUN %SUBTYPEP (TYPE1 TYPE2 &OPTIONAL ENVIRONMENT) (WHEN (OR (EQ TYPE1 TYPE2) (NULL TYPE1) (EQ TYPE2 T) (EQ TYPE2 +THE-T-CLASS+) (AND (CLASSP TYPE2) (LET ((TAPE1 (IF (CONSP TYPE1) (CAR TYPE1) TYPE1))) (AND (SYMBOLP TAPE1) (EQ TYPE2 (FIND-CLASS TAPE1 NIL)))))) (RETURN-FROM %SUBTYPEP (VALUES T T))) (WHEN (PROPERLY-NAMED-CLASS-P TYPE1 ENVIRONMENT) (SETF TYPE1 (CLASS-NAME TYPE1))) (WHEN (PROPERLY-NAMED-CLASS-P TYPE2 ENVIRONMENT) (SETF TYPE2 (CLASS-NAME TYPE2))) (LET ((CT1 (CTYPE TYPE1)) (CT2 (CTYPE TYPE2))) (MULTIPLE-VALUE-BIND (SUBTYPE-P VALID-P) (CSUBTYPEP CT1 CT2) (WHEN VALID-P (RETURN-FROM %SUBTYPEP (VALUES SUBTYPE-P VALID-P))))) (WHEN (AND (ATOM TYPE1) (ATOM TYPE2)) (LET* ((CLASSP-1 (CLASSP TYPE1)) (CLASSP-2 (CLASSP TYPE2)) CLASS1 CLASS2) (WHEN (AND (SETF CLASS1 (IF CLASSP-1 TYPE1 (AND (SYMBOLP TYPE1) (FIND-CLASS TYPE1 NIL)))) (SETF CLASS2 (IF CLASSP-2 TYPE2 (AND (SYMBOLP TYPE2) (FIND-CLASS TYPE2 NIL))))) (RETURN-FROM %SUBTYPEP (VALUES (SUBCLASSP CLASS1 CLASS2) T))) (WHEN (OR CLASSP-1 CLASSP-2) (LET ((T1 (IF CLASSP-1 (CLASS-NAME TYPE1) TYPE1)) (T2 (IF CLASSP-2 (CLASS-NAME TYPE2) TYPE2))) (RETURN-FROM %SUBTYPEP (VALUES (SIMPLE-SUBTYPEP T1 T2) T)))))) (SETF TYPE1 (NORMALIZE-TYPE TYPE1) TYPE2 (NORMALIZE-TYPE TYPE2)) (WHEN (EQ TYPE1 TYPE2) (RETURN-FROM %SUBTYPEP (VALUES T T))) (LET (T1 T2 I1 I2) (IF (ATOM TYPE1) (SETF T1 TYPE1 I1 NIL) (SETF T1 (%CAR TYPE1) I1 (%CDR TYPE1))) (IF (ATOM TYPE2) (SETF T2 TYPE2 I2 NIL) (SETF T2 (%CAR TYPE2) I2 (%CDR TYPE2))) (COND ((NULL T1) (RETURN-FROM %SUBTYPEP (VALUES T T))) ((EQ T1 (QUOTE ATOM)) (RETURN-FROM %SUBTYPEP (VALUES (EQ T2 T) T))) ((EQ T2 (QUOTE ATOM)) (RETURN-FROM %SUBTYPEP (COND ((MEMQ T1 (QUOTE (CONS LIST SEQUENCE))) (VALUES NIL T)) (T (VALUES T T))))) ((EQ T1 (QUOTE MEMBER)) (DOLIST (E I1) (UNLESS (TYPEP E TYPE2) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))) (RETURN-FROM %SUBTYPEP (VALUES T T))) ((EQ T1 (QUOTE EQL)) (CASE T2 (EQL (RETURN-FROM %SUBTYPEP (VALUES (EQL (CAR I1) (CAR I2)) T))) (SATISFIES (RETURN-FROM %SUBTYPEP (VALUES (FUNCALL (CAR I2) (CAR I1)) T))) (T (RETURN-FROM %SUBTYPEP (VALUES (TYPEP (CAR I1) TYPE2) T))))) ((EQ T1 (QUOTE OR)) (DOLIST (TT I1) (MULTIPLE-VALUE-BIND (TV FLAG) (%SUBTYPEP TT TYPE2) (UNLESS TV (RETURN-FROM %SUBTYPEP (VALUES TV FLAG))))) (RETURN-FROM %SUBTYPEP (VALUES T T))) ((EQ T1 (QUOTE AND)) (DOLIST (TT I1) (LET ((TV (%SUBTYPEP TT TYPE2))) (WHEN TV (RETURN-FROM %SUBTYPEP (VALUES T T))))) (RETURN-FROM %SUBTYPEP (VALUES NIL NIL))) ((EQ T1 (QUOTE CONS)) (CASE T2 ((LIST SEQUENCE) (RETURN-FROM %SUBTYPEP (VALUES T T))) (CONS (WHEN (AND (%SUBTYPEP (CAR I1) (CAR I2)) (%SUBTYPEP (CADR I1) (CADR I2))) (RETURN-FROM %SUBTYPEP (VALUES T T))))) (RETURN-FROM %SUBTYPEP (VALUES NIL (KNOWN-TYPE-P T2)))) ((EQ T2 (QUOTE OR)) (DOLIST (TT I2) (LET ((TV (%SUBTYPEP TYPE1 TT))) (WHEN TV (RETURN-FROM %SUBTYPEP (VALUES T T))))) (RETURN-FROM %SUBTYPEP (VALUES NIL NIL))) ((EQ T2 (QUOTE AND)) (DOLIST (TT I2) (MULTIPLE-VALUE-BIND (TV FLAG) (%SUBTYPEP TYPE1 TT) (UNLESS TV (RETURN-FROM %SUBTYPEP (VALUES TV FLAG))))) (RETURN-FROM %SUBTYPEP (VALUES T T))) ((NULL (OR I1 I2)) (RETURN-FROM %SUBTYPEP (VALUES (SIMPLE-SUBTYPEP T1 T2) T))) ((EQ T2 (QUOTE SEQUENCE)) (COND ((MEMQ T1 (QUOTE (NULL CONS LIST))) (VALUES T T)) ((MEMQ T1 (QUOTE (SIMPLE-BASE-STRING BASE-STRING SIMPLE-STRING STRING NIL-VECTOR))) (VALUES T T)) ((MEMQ T1 (QUOTE (BIT-VECTOR SIMPLE-BIT-VECTOR))) (VALUES T T)) ((MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (COND ((AND (CDR I1) (CONSP (CADR I1)) (NULL (CDADR I1))) (VALUES T T)) ((AND (CDR I1) (EQL (CADR I1) 1)) (VALUES T T)) (T (VALUES NIL T)))) (T (VALUES NIL (KNOWN-TYPE-P T1))))) ((EQ T1 (QUOTE INTEGER)) (COND ((MEMQ T2 (QUOTE (INTEGER RATIONAL REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T)) ((OR (EQ T2 (QUOTE BIGNUM)) (AND (CLASSP T2) (EQ (CLASS-NAME T2) (QUOTE BIGNUM)))) (VALUES (OR (SUB-INTERVAL-P I1 (LIST (QUOTE *) (LIST MOST-NEGATIVE-FIXNUM))) (SUB-INTERVAL-P I1 (LIST (LIST MOST-POSITIVE-FIXNUM) (QUOTE *)))) T)) (T (VALUES NIL (KNOWN-TYPE-P T2))))) ((EQ T1 (QUOTE RATIONAL)) (IF (MEMQ T2 (QUOTE (RATIONAL REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T) (VALUES NIL (KNOWN-TYPE-P T2)))) ((EQ T1 (QUOTE FLOAT)) (IF (MEMQ T2 (QUOTE (FLOAT REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T) (VALUES NIL (KNOWN-TYPE-P T2)))) ((MEMQ T1 (QUOTE (SINGLE-FLOAT SHORT-FLOAT))) (IF (MEMQ T2 (QUOTE (SINGLE-FLOAT SHORT-FLOAT FLOAT REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T) (VALUES NIL (KNOWN-TYPE-P T2)))) ((MEMQ T1 (QUOTE (DOUBLE-FLOAT LONG-FLOAT))) (IF (MEMQ T2 (QUOTE (DOUBLE-FLOAT LONG-FLOAT FLOAT REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T) (VALUES NIL (KNOWN-TYPE-P T2)))) ((EQ T1 (QUOTE REAL)) (IF (MEMQ T2 (QUOTE (REAL NUMBER))) (VALUES (SUB-INTERVAL-P I1 I2) T) (VALUES NIL (KNOWN-TYPE-P T2)))) ((EQ T1 (QUOTE COMPLEX)) (COND ((EQ T2 (QUOTE NUMBER)) (VALUES T T)) ((EQ T2 (QUOTE COMPLEX)) (COND ((EQUAL I2 (QUOTE (*))) (VALUES T T)) ((EQUAL I1 (QUOTE (*))) (VALUES NIL T)) (T (VALUES (SUBTYPEP (CAR I1) (CAR I2)) T)))))) ((AND (CLASSP T1) (EQ (CLASS-NAME T1) (QUOTE ARRAY)) (EQ T2 (QUOTE ARRAY))) (VALUES (EQUAL I2 (QUOTE (* *))) T)) ((AND (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (EQ T2 (QUOTE ARRAY))) (LET ((E1 (CAR I1)) (E2 (CAR I2)) (D1 (CADR I1)) (D2 (CADR I2))) (COND ((AND (EQ E2 (QUOTE *)) (EQ D2 (QUOTE *))) (VALUES T T)) ((OR (EQ E2 (QUOTE *)) (EQUAL E1 E2) (EQUAL (UPGRADED-ARRAY-ELEMENT-TYPE E1) (UPGRADED-ARRAY-ELEMENT-TYPE E2))) (VALUES (DIMENSION-SUBTYPEP D1 D2) T)) (T (VALUES NIL T))))) ((AND (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (EQ T2 (QUOTE STRING))) (LET ((ELEMENT-TYPE (CAR I1)) (DIM (CADR I1)) (SIZE (CAR I2))) (UNLESS (%SUBTYPEP ELEMENT-TYPE (QUOTE CHARACTER)) (RETURN-FROM %SUBTYPEP (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE)) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))))) ((AND (EQ T1 (QUOTE SIMPLE-ARRAY)) (EQ T2 (QUOTE SIMPLE-STRING))) (LET ((ELEMENT-TYPE (CAR I1)) (DIM (CADR I1)) (SIZE (CAR I2))) (UNLESS (%SUBTYPEP ELEMENT-TYPE (QUOTE CHARACTER)) (RETURN-FROM %SUBTYPEP (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE)) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))))) ((AND (MEMQ T1 (QUOTE (STRING SIMPLE-STRING))) (EQ T2 (QUOTE ARRAY))) (LET ((ELEMENT-TYPE (CAR I2)) (DIM (CADR I2)) (SIZE (CAR I1))) (UNLESS (EQ ELEMENT-TYPE (QUOTE *)) (RETURN-FROM %SUBTYPEP (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (OR (EQ DIM (QUOTE *)) (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))))) ((EQ T2 (QUOTE SIMPLE-ARRAY)) (CASE T1 (SIMPLE-ARRAY (LET ((E1 (CAR I1)) (E2 (CAR I2)) (D1 (CADR I1)) (D2 (CADR I2))) (COND ((AND (EQ E2 (QUOTE *)) (EQ D2 (QUOTE *))) (VALUES T T)) ((OR (EQ E2 (QUOTE *)) (EQUAL E1 E2) (EQUAL (UPGRADED-ARRAY-ELEMENT-TYPE E1) (UPGRADED-ARRAY-ELEMENT-TYPE E2))) (VALUES (DIMENSION-SUBTYPEP D1 D2) T)) (T (VALUES NIL T))))) ((SIMPLE-STRING SIMPLE-BIT-VECTOR) (LET ((ELEMENT-TYPE (CAR I2)) (DIM (CADR I2)) (SIZE (CAR I1))) (UNLESS (EQ ELEMENT-TYPE (QUOTE *)) (RETURN-FROM %SUBTYPEP (VALUES NIL T))) (WHEN (INTEGERP SIZE) (IF (OR (EQ DIM (QUOTE *)) (AND (CONSP DIM) (= (LENGTH DIM) 1) (EQL (%CAR DIM) SIZE))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))) (WHEN (OR (NULL SIZE) (EQL SIZE (QUOTE *))) (IF (OR (EQ DIM (QUOTE *)) (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (RETURN-FROM %SUBTYPEP (VALUES T T)) (RETURN-FROM %SUBTYPEP (VALUES NIL T)))))) (T (VALUES NIL T)))) ((EQ T2 (QUOTE BIT-VECTOR)) (LET ((SIZE1 (CAR I1)) (SIZE2 (CAR I2))) (CASE T1 ((BIT-VECTOR SIMPLE-BIT-VECTOR) (VALUES (IF (OR (EQ SIZE2 (QUOTE *)) (EQL SIZE1 SIZE2)) T NIL) T)) (T (VALUES NIL T))))) ((CLASSP T2) (LET ((CLASS-NAME (CLASS-NAME T2))) (COND ((EQ CLASS-NAME T1) (VALUES T T)) ((AND (EQ CLASS-NAME (QUOTE ARRAY)) (MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY VECTOR SIMPLE-VECTOR STRING SIMPLE-STRING SIMPLE-BASE-STRING BIT-VECTOR SIMPLE-BIT-VECTOR)))) (VALUES T T)) ((EQ CLASS-NAME (QUOTE VECTOR)) (COND ((MEMQ T1 (QUOTE (STRING SIMPLE-STRING))) (VALUES T T)) ((MEMQ T1 (QUOTE (ARRAY SIMPLE-ARRAY))) (LET ((DIM (CADR I1))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (VALUES T T) (VALUES NIL T)))) (T (VALUES NIL T)))) ((AND (EQ CLASS-NAME (QUOTE SIMPLE-VECTOR)) (EQ T1 (QUOTE SIMPLE-ARRAY))) (LET ((DIM (CADR I1))) (IF (OR (EQL DIM 1) (AND (CONSP DIM) (= (LENGTH DIM) 1))) (VALUES T T) (VALUES NIL T)))) ((AND (EQ CLASS-NAME (QUOTE BIT-VECTOR)) (EQ T1 (QUOTE SIMPLE-BIT-VECTOR))) (VALUES T T)) ((AND (EQ CLASS-NAME (QUOTE STRING)) (MEMQ T1 (QUOTE (STRING SIMPLE-STRING)))) (VALUES T T)) (T (VALUES NIL NIL))))) (T (VALUES NIL NIL)))))
     [java] ; (DEFUN SUBTYPEP (TYPE1 TYPE2 &OPTIONAL ENVIRONMENT) (%SUBTYPEP TYPE1 TYPE2 ENVIRONMENT))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/subtypep.abcl (0.97 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/subtypep.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/subtypep.abcl (0.145 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/find.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO VECTOR-LOCATER-MACRO (SEQUENCE BODY-FORM RETURN-TYPE) (BACKQ-LIST (QUOTE LET) (QUOTE ((INCREMENTER (IF FROM-END -1 1)) (START (IF FROM-END (1- (THE FIXNUM END)) START)) (END (IF FROM-END (1- (THE FIXNUM START)) END)))) (QUOTE (DECLARE (FIXNUM START END INCREMENTER))) (BACKQ-LIST* (QUOTE DO) (BACKQ-CONS (QUOTE (INDEX START (+ INDEX INCREMENTER))) (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (QUOTE (CURRENT))))) (QUOTE ((= INDEX END) NIL)) (QUOTE (DECLARE (FIXNUM INDEX))) (BACKQ-APPEND (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (QUOTE CURRENT) (BACKQ-LIST* (QUOTE AREF) SEQUENCE (QUOTE (INDEX))))))) (BACKQ-LIST BODY-FORM)))))
     [java] ; (DEFMACRO LOCATER-TEST-NOT (ITEM SEQUENCE SEQ-TYPE RETURN-TYPE) (LET ((SEQ-REF (CASE RETURN-TYPE (:POSITION (CASE SEQ-TYPE (:VECTOR (BACKQ-LIST* (QUOTE AREF) SEQUENCE (QUOTE (INDEX)))) (:LIST (BACKQ-LIST (QUOTE POP) SEQUENCE)))) (:ELEMENT (QUOTE CURRENT)))) (RETURN (CASE RETURN-TYPE (:POSITION (QUOTE INDEX)) (:ELEMENT (QUOTE CURRENT))))) (BACKQ-LIST (QUOTE IF) (QUOTE TEST-NOT) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE NOT) (BACKQ-LIST (QUOTE FUNCALL) (QUOTE TEST-NOT) ITEM (BACKQ-LIST (QUOTE APPLY-KEY) (QUOTE KEY) SEQ-REF))) (BACKQ-LIST (QUOTE RETURN) RETURN)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE FUNCALL) (QUOTE TEST) ITEM (BACKQ-LIST (QUOTE APPLY-KEY) (QUOTE KEY) SEQ-REF)) (BACKQ-LIST (QUOTE RETURN) RETURN)))))
     [java] ; (DEFMACRO VECTOR-LOCATER (ITEM SEQUENCE RETURN-TYPE) (BACKQ-LIST (QUOTE VECTOR-LOCATER-MACRO) SEQUENCE (BACKQ-LIST (QUOTE LOCATER-TEST-NOT) ITEM SEQUENCE (QUOTE :VECTOR) RETURN-TYPE) RETURN-TYPE))
     [java] ; (DEFMACRO LOCATER-IF-TEST (TEST SEQUENCE SEQ-TYPE RETURN-TYPE SENSE) (LET ((SEQ-REF (CASE RETURN-TYPE (:POSITION (CASE SEQ-TYPE (:VECTOR (BACKQ-LIST* (QUOTE AREF) SEQUENCE (QUOTE (INDEX)))) (:LIST (BACKQ-LIST (QUOTE POP) SEQUENCE)))) (:ELEMENT (QUOTE CURRENT)))) (RETURN (CASE RETURN-TYPE (:POSITION (QUOTE INDEX)) (:ELEMENT (QUOTE CURRENT))))) (IF SENSE (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE FUNCALL) TEST (BACKQ-LIST (QUOTE APPLY-KEY) (QUOTE KEY) SEQ-REF)) (BACKQ-LIST (QUOTE RETURN) RETURN)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE NOT) (BACKQ-LIST (QUOTE FUNCALL) TEST (BACKQ-LIST (QUOTE APPLY-KEY) (QUOTE KEY) SEQ-REF))) (BACKQ-LIST (QUOTE RETURN) RETURN)))))
     [java] ; (DEFMACRO VECTOR-LOCATER-IF-MACRO (TEST SEQUENCE RETURN-TYPE SENSE) (BACKQ-LIST (QUOTE VECTOR-LOCATER-MACRO) SEQUENCE (BACKQ-LIST (QUOTE LOCATER-IF-TEST) TEST SEQUENCE (QUOTE :VECTOR) RETURN-TYPE SENSE) RETURN-TYPE))
     [java] ; (DEFMACRO VECTOR-LOCATER-IF (TEST SEQUENCE RETURN-TYPE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF-MACRO) TEST SEQUENCE RETURN-TYPE (QUOTE (T))))
     [java] ; (DEFMACRO VECTOR-LOCATER-IF-NOT (TEST SEQUENCE RETURN-TYPE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF-MACRO) TEST SEQUENCE RETURN-TYPE (QUOTE (NIL))))
     [java] ; (DEFMACRO LIST-LOCATER-MACRO (SEQUENCE BODY-FORM RETURN-TYPE) (BACKQ-LIST (QUOTE IF) (QUOTE FROM-END) (BACKQ-LIST* (QUOTE DO) (BACKQ-LIST* (BACKQ-LIST (QUOTE SEQUENCE) (BACKQ-LIST (QUOTE NTHCDR) (QUOTE (- (THE FIXNUM (LENGTH SEQUENCE)) (THE FIXNUM END))) (BACKQ-LIST (QUOTE REVERSE) (BACKQ-LIST (QUOTE THE) (QUOTE LIST) SEQUENCE)))) (QUOTE (INDEX (1- (THE FIXNUM END)) (1- INDEX))) (QUOTE (TERMINUS (1- (THE FIXNUM START)))) (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (QUOTE (CURRENT))))) (QUOTE ((OR (= INDEX TERMINUS) (NULL SEQUENCE)) NIL)) (QUOTE (DECLARE (FIXNUM INDEX TERMINUS))) (BACKQ-APPEND (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (QUOTE CURRENT) (BACKQ-LIST (QUOTE POP) SEQUENCE))))) (BACKQ-LIST BODY-FORM))) (BACKQ-LIST* (QUOTE DO) (BACKQ-LIST* (BACKQ-LIST (QUOTE SEQUENCE) (BACKQ-LIST (QUOTE NTHCDR) (QUOTE START) SEQUENCE)) (QUOTE (INDEX START (1+ INDEX))) (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (QUOTE (CURRENT))))) (QUOTE ((OR (= INDEX (THE FIXNUM END)) (NULL SEQUENCE)) NIL)) (QUOTE (DECLARE (FIXNUM INDEX))) (BACKQ-APPEND (CASE RETURN-TYPE (:POSITION NIL) (:ELEMENT (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (QUOTE CURRENT) (BACKQ-LIST (QUOTE POP) SEQUENCE))))) (BACKQ-LIST BODY-FORM)))))
     [java] ; (DEFMACRO LIST-LOCATER (ITEM SEQUENCE RETURN-TYPE) (BACKQ-LIST (QUOTE LIST-LOCATER-MACRO) SEQUENCE (BACKQ-LIST (QUOTE LOCATER-TEST-NOT) ITEM SEQUENCE (QUOTE :LIST) RETURN-TYPE) RETURN-TYPE))
     [java] ; (DEFMACRO LIST-LOCATER-IF-MACRO (TEST SEQUENCE RETURN-TYPE SENSE) (BACKQ-LIST (QUOTE LIST-LOCATER-MACRO) SEQUENCE (BACKQ-LIST (QUOTE LOCATER-IF-TEST) TEST SEQUENCE (QUOTE :LIST) RETURN-TYPE SENSE) RETURN-TYPE))
     [java] ; (DEFMACRO LIST-LOCATER-IF (TEST SEQUENCE RETURN-TYPE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF-MACRO) TEST SEQUENCE RETURN-TYPE (QUOTE (T))))
     [java] ; (DEFMACRO LIST-LOCATER-IF-NOT (TEST SEQUENCE RETURN-TYPE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF-MACRO) TEST SEQUENCE RETURN-TYPE (QUOTE (NIL))))
     [java] ; (DEFMACRO VECTOR-POSITION (ITEM SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER) ITEM SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFMACRO LIST-POSITION (ITEM SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER) ITEM SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFUN POSITION (ITEM SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START 0) END KEY) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-POSITION* ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (VECTOR-POSITION* ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (APPLY (FUNCTION SEQUENCE:POSITION) ITEM SEQUENCE ARGS)))
     [java] ; (DEFUN LIST-POSITION* (ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (DECLARE (TYPE FIXNUM START)) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (LIST-POSITION ITEM SEQUENCE)))
     [java] ; (DEFUN VECTOR-POSITION* (ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (DECLARE (TYPE FIXNUM START)) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (VECTOR-POSITION ITEM SEQUENCE)))
     [java] ; (DEFMACRO VECTOR-POSITION-IF (TEST SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF) TEST SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFMACRO LIST-POSITION-IF (TEST SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF) TEST SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFUN POSITION-IF (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) KEY END) (DECLARE (TYPE FIXNUM START)) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-POSITION-IF TEST SEQUENCE) (VECTOR-POSITION-IF TEST SEQUENCE) (APPLY (FUNCTION SEQUENCE:POSITION-IF) TEST SEQUENCE ARGS))))
     [java] ; (DEFMACRO VECTOR-POSITION-IF-NOT (TEST SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF-NOT) TEST SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFMACRO LIST-POSITION-IF-NOT (TEST SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF-NOT) TEST SEQUENCE (QUOTE (:POSITION))))
     [java] ; (DEFUN POSITION-IF-NOT (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) KEY END) (DECLARE (TYPE FIXNUM START)) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-POSITION-IF-NOT TEST SEQUENCE) (VECTOR-POSITION-IF-NOT TEST SEQUENCE) (APPLY (FUNCTION SEQUENCE:POSITION-IF-NOT) TEST SEQUENCE ARGS))))
     [java] ; (DEFMACRO VECTOR-FIND (ITEM SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER) ITEM SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFMACRO LIST-FIND (ITEM SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER) ITEM SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFUN LIST-FIND* (ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (DECLARE (TYPE FIXNUM START END)) (UNLESS (OR TEST TEST-NOT) (SETF TEST (QUOTE EQL))) (LIST-FIND ITEM SEQUENCE))
     [java] ; (DEFUN VECTOR-FIND* (ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (DECLARE (TYPE FIXNUM START END)) (UNLESS (OR TEST TEST-NOT) (SETF TEST (QUOTE EQL))) (VECTOR-FIND ITEM SEQUENCE))
     [java] ; (DEFUN FIND (ITEM SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START 0) END KEY) (LET ((END (CHECK-SEQUENCE-BOUNDS SEQUENCE START END))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-FIND* ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (VECTOR-FIND* ITEM SEQUENCE FROM-END TEST TEST-NOT START END KEY) (APPLY (FUNCTION SEQUENCE:FIND) ITEM SEQUENCE ARGS))))
     [java] ; (DEFMACRO VECTOR-FIND-IF (TEST SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF) TEST SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFMACRO LIST-FIND-IF (TEST SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF) TEST SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFUN FIND-IF (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END KEY) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-FIND-IF TEST SEQUENCE) (VECTOR-FIND-IF TEST SEQUENCE) (APPLY (FUNCTION SEQUENCE:FIND-IF) TEST SEQUENCE ARGS))))
     [java] ; (DEFMACRO VECTOR-FIND-IF-NOT (TEST SEQUENCE) (BACKQ-LIST* (QUOTE VECTOR-LOCATER-IF-NOT) TEST SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFMACRO LIST-FIND-IF-NOT (TEST SEQUENCE) (BACKQ-LIST* (QUOTE LIST-LOCATER-IF-NOT) TEST SEQUENCE (QUOTE (:ELEMENT))))
     [java] ; (DEFUN FIND-IF-NOT (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END KEY) (LET ((END (OR END (LENGTH SEQUENCE)))) (DECLARE (TYPE FIXNUM END)) (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-FIND-IF-NOT TEST SEQUENCE) (VECTOR-FIND-IF-NOT TEST SEQUENCE) (APPLY (FUNCTION SEQUENCE:FIND-IF-NOT) TEST SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/find.abcl (1.145 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/find.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/find.abcl (0.219 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN COMPOUND-OBJECT-P (X) (OR (CONSP X) (TYPEP X (QUOTE STRUCTURE-OBJECT)) (TYPEP X (QUOTE STANDARD-OBJECT)) (TYPEP X (QUOTE (ARRAY T *)))))
     [java] ; (DEFMACRO PUNT-PRINT-IF-TOO-LONG (INDEX STREAM) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST (QUOTE AND) (QUOTE (NOT *PRINT-READABLY*)) (QUOTE *PRINT-LENGTH*) (BACKQ-LIST* (QUOTE >=) INDEX (QUOTE (*PRINT-LENGTH*)))) (BACKQ-LIST (QUOTE WRITE-STRING) "..." STREAM) (QUOTE ((RETURN)))))
     [java] ; (DEFUN OUTPUT-INTEGER (INTEGER STREAM) (IF (XP::XP-STRUCTURE-P STREAM) (LET ((S (%WRITE-TO-STRING INTEGER))) (XP::WRITE-STRING++ S STREAM 0 (LENGTH S))) (%OUTPUT-OBJECT INTEGER STREAM)))
     [java] ; (DEFUN OUTPUT-LIST (LIST STREAM) (COND ((AND (NULL *PRINT-READABLY*) *PRINT-LEVEL* (>= *CURRENT-PRINT-LEVEL* *PRINT-LEVEL*)) (WRITE-CHAR #\# STREAM)) (T (LET ((*CURRENT-PRINT-LEVEL* (1+ *CURRENT-PRINT-LEVEL*))) (WRITE-CHAR #\( STREAM) (LET ((*CURRENT-PRINT-LENGTH* 0) (LIST LIST)) (LOOP (PUNT-PRINT-IF-TOO-LONG *CURRENT-PRINT-LENGTH* STREAM) (OUTPUT-OBJECT (POP LIST) STREAM) (UNLESS LIST (RETURN)) (WHEN (OR (ATOM LIST) (CHECK-FOR-CIRCULARITY LIST)) (WRITE-STRING " . " STREAM) (OUTPUT-OBJECT LIST STREAM) (RETURN)) (WRITE-CHAR #\  STREAM) (INCF *CURRENT-PRINT-LENGTH*))) (WRITE-CHAR #\) STREAM)))) LIST)
     [java] ; (DEFUN OUTPUT-TERSE-ARRAY (ARRAY STREAM) (LET ((*PRINT-LEVEL* NIL) (*PRINT-LENGTH* NIL)) (PRINT-UNREADABLE-OBJECT (ARRAY STREAM :TYPE T :IDENTITY T))))
     [java] ; (DEFUN ARRAY-READABLY-PRINTABLE-P (ARRAY) (AND (EQ (ARRAY-ELEMENT-TYPE ARRAY) T) (LET ((ZERO (POSITION 0 (ARRAY-DIMENSIONS ARRAY))) (NUMBER (POSITION 0 (ARRAY-DIMENSIONS ARRAY) :TEST (COMPLEMENT (FUNCTION EQL)) :FROM-END T))) (OR (NULL ZERO) (NULL NUMBER) (> ZERO NUMBER)))))
     [java] ; (DEFUN OUTPUT-VECTOR (VECTOR STREAM) (DECLARE (VECTOR VECTOR)) (COND ((STRINGP VECTOR) (ASSERT NIL) (%OUTPUT-OBJECT VECTOR STREAM)) ((NOT (OR *PRINT-ARRAY* *PRINT-READABLY*)) (OUTPUT-TERSE-ARRAY VECTOR STREAM)) ((BIT-VECTOR-P VECTOR) (ASSERT NIL) (%OUTPUT-OBJECT VECTOR STREAM)) (T (WHEN (AND *PRINT-READABLY* (NOT (ARRAY-READABLY-PRINTABLE-P VECTOR))) (ERROR (QUOTE PRINT-NOT-READABLE) :OBJECT VECTOR)) (COND ((AND (NULL *PRINT-READABLY*) *PRINT-LEVEL* (>= *CURRENT-PRINT-LEVEL* *PRINT-LEVEL*)) (WRITE-CHAR #\# STREAM)) (T (LET ((*CURRENT-PRINT-LEVEL* (1+ *CURRENT-PRINT-LEVEL*))) (WRITE-STRING "#(" STREAM) (DOTIMES (I (LENGTH VECTOR)) (UNLESS (ZEROP I) (WRITE-CHAR #\  STREAM)) (PUNT-PRINT-IF-TOO-LONG I STREAM) (OUTPUT-OBJECT (AREF VECTOR I) STREAM)) (WRITE-STRING ")" STREAM)))))) VECTOR)
     [java] ; (DEFUN OUTPUT-UGLY-OBJECT (OBJECT STREAM) (COND ((CONSP OBJECT) (OUTPUT-LIST OBJECT STREAM)) ((AND (VECTORP OBJECT) (NOT (STRINGP OBJECT)) (NOT (BIT-VECTOR-P OBJECT))) (OUTPUT-VECTOR OBJECT STREAM)) ((STRUCTURE-OBJECT-P OBJECT) (COND ((AND (NULL *PRINT-READABLY*) *PRINT-LEVEL* (>= *CURRENT-PRINT-LEVEL* *PRINT-LEVEL*)) (WRITE-CHAR #\# STREAM)) (T (PRINT-OBJECT OBJECT STREAM)))) ((STANDARD-OBJECT-P OBJECT) (PRINT-OBJECT OBJECT STREAM)) ((JAVA:JAVA-OBJECT-P OBJECT) (PRINT-OBJECT OBJECT STREAM)) ((XP::XP-STRUCTURE-P STREAM) (LET ((S (%WRITE-TO-STRING OBJECT))) (XP::WRITE-STRING++ S STREAM 0 (LENGTH S)))) (T (%OUTPUT-OBJECT OBJECT STREAM))))
     [java] ; (DEFVAR *CIRCULARITY-HASH-TABLE* NIL)
     [java] ; (DEFVAR *CIRCULARITY-COUNTER* NIL)
     [java] ; (DEFUN CHECK-FOR-CIRCULARITY (OBJECT &OPTIONAL ASSIGN) (COND ((NULL *PRINT-CIRCLE*) NIL) ((NULL *CIRCULARITY-HASH-TABLE*) (VALUES NIL :INITIATE)) ((NULL *CIRCULARITY-COUNTER*) (ECASE (GETHASH OBJECT *CIRCULARITY-HASH-TABLE*) ((NIL) (SETF (GETHASH OBJECT *CIRCULARITY-HASH-TABLE*) T) NIL) ((T) (SETF (GETHASH OBJECT *CIRCULARITY-HASH-TABLE*) 0) T) (0 T))) (T (LET ((VALUE (GETHASH OBJECT *CIRCULARITY-HASH-TABLE*))) (CASE VALUE ((NIL T) NIL) (0 (IF ASSIGN (LET ((VALUE (INCF *CIRCULARITY-COUNTER*))) (SETF (GETHASH OBJECT *CIRCULARITY-HASH-TABLE*) VALUE) VALUE) T)) (T (- VALUE)))))))
     [java] ; (DEFUN HANDLE-CIRCULARITY (MARKER STREAM) (CASE MARKER (:INITIATE (LET ((*PRINT-CIRCLE* NIL)) (ERROR "trying to use CHECK-FOR-CIRCULARITY when ~
     [java]        circularity checking isn't initiated"))) ((T) NIL) (T (COND ((MINUSP MARKER) (PRINT-REFERENCE MARKER STREAM) NIL) (T (PRINT-LABEL MARKER STREAM) T)))))
     [java] ; (DEFUN PRINT-LABEL (MARKER STREAM) (WRITE-CHAR #\# STREAM) (LET ((*PRINT-BASE* 10) (*PRINT-RADIX* NIL)) (OUTPUT-INTEGER MARKER STREAM)) (WRITE-CHAR #\= STREAM))
     [java] ; (DEFUN PRINT-REFERENCE (MARKER STREAM) (WRITE-CHAR #\# STREAM) (LET ((*PRINT-BASE* 10) (*PRINT-RADIX* NIL)) (OUTPUT-INTEGER (- MARKER) STREAM)) (WRITE-CHAR #\# STREAM))
     [java] ; (DEFUN UNIQUELY-IDENTIFIED-BY-PRINT-P (X) (OR (NUMBERP X) (CHARACTERP X) (AND (SYMBOLP X) (SYMBOL-PACKAGE X))))
     [java] ; (DEFUN %PRINT-OBJECT (OBJECT STREAM) (IF *PRINT-PRETTY* (XP::OUTPUT-PRETTY-OBJECT OBJECT STREAM) (OUTPUT-UGLY-OBJECT OBJECT STREAM)))
     [java] ; (DEFUN %CHECK-OBJECT (OBJECT STREAM) (MULTIPLE-VALUE-BIND (MARKER INITIATE) (CHECK-FOR-CIRCULARITY OBJECT T) (IF (EQ INITIATE :INITIATE) (LET ((*CIRCULARITY-HASH-TABLE* (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (%CHECK-OBJECT OBJECT (MAKE-BROADCAST-STREAM)) (LET ((*CIRCULARITY-COUNTER* 0)) (%CHECK-OBJECT OBJECT STREAM))) (IF MARKER (WHEN (HANDLE-CIRCULARITY MARKER STREAM) (%PRINT-OBJECT OBJECT STREAM)) (%PRINT-OBJECT OBJECT STREAM)))))
     [java] ; (DEFUN OUTPUT-OBJECT (OBJECT STREAM) (COND ((OR (NOT *PRINT-CIRCLE*) (UNIQUELY-IDENTIFIED-BY-PRINT-P OBJECT)) (%PRINT-OBJECT OBJECT STREAM)) ((OR *CIRCULARITY-HASH-TABLE* (COMPOUND-OBJECT-P OBJECT)) (%CHECK-OBJECT OBJECT STREAM)) (T (%PRINT-OBJECT OBJECT STREAM))) OBJECT)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/print.abcl (0.407 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/print.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/print.abcl (0.196 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint-dispatch.lisp ...
     [java] ; (IN-PACKAGE #:XP)
     [java] ; (DEFVAR *IPD* NIL "initial print dispatch table.")
     [java] ; (DEFSTRUCT (PPRINT-DISPATCH-TABLE (:CONC-NAME NIL) (:COPIER NIL)) (CONSES-WITH-CARS (MAKE-HASH-TABLE :TEST (FUNCTION EQ)) :TYPE HASH-TABLE) (STRUCTURES (MAKE-HASH-TABLE :TEST (FUNCTION EQ)) :TYPE HASH-TABLE) (OTHERS NIL :TYPE LIST))
     [java] ; (DEFSTRUCT (ENTRY (:CONC-NAME NIL)) (TEST NIL) (FN NIL) (FULL-SPEC NIL))
     [java] ; (DEFUN COPY-PPRINT-DISPATCH (&OPTIONAL (TABLE *PRINT-PPRINT-DISPATCH*)) (UNLESS TABLE (SETF TABLE *IPD*)) (SYSTEM:REQUIRE-TYPE TABLE (QUOTE PPRINT-DISPATCH-TABLE)) (LET* ((NEW-CONSES-WITH-CARS (MAKE-HASH-TABLE :TEST (FUNCTION EQ) :SIZE (MAX (HASH-TABLE-COUNT (CONSES-WITH-CARS TABLE)) 32))) (NEW-STRUCTURES (MAKE-HASH-TABLE :TEST (FUNCTION EQ) :SIZE (MAX (HASH-TABLE-COUNT (STRUCTURES TABLE)) 32)))) (MAPHASH (FUNCTION (LAMBDA (KEY VALUE) (SETF (GETHASH KEY NEW-CONSES-WITH-CARS) (COPY-ENTRY VALUE)))) (CONSES-WITH-CARS TABLE)) (MAPHASH (FUNCTION (LAMBDA (KEY VALUE) (SETF (GETHASH KEY NEW-STRUCTURES) (COPY-ENTRY VALUE)))) (STRUCTURES TABLE)) (MAKE-PPRINT-DISPATCH-TABLE :CONSES-WITH-CARS NEW-CONSES-WITH-CARS :STRUCTURES NEW-STRUCTURES :OTHERS (COPY-LIST (OTHERS TABLE)))))
     [java] ; (DEFUN SET-PPRINT-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0) (TABLE *PRINT-PPRINT-DISPATCH*)) (WHEN (OR (NOT (NUMBERP PRIORITY)) (COMPLEXP PRIORITY)) (ERROR "invalid PRIORITY argument ~A to SET-PPRINT-DISPATCH" PRIORITY)) (SET-PPRINT-DISPATCH+ TYPE-SPECIFIER FUNCTION PRIORITY TABLE))
     [java] ; (DEFUN SET-PPRINT-DISPATCH+ (TYPE-SPECIFIER FUNCTION PRIORITY TABLE) (LET* ((CATEGORY (SPECIFIER-CATEGORY TYPE-SPECIFIER)) (PRED (IF (NOT (EQ CATEGORY (QUOTE OTHER))) NIL (LET ((PRED (SPECIFIER-FN TYPE-SPECIFIER))) (IF (AND (CONSP (CADDR PRED)) (SYMBOLP (CAADDR PRED)) (EQUAL (CDADDR PRED) (QUOTE (X)))) (SYMBOL-FUNCTION (CAADDR PRED)) PRED)))) (ENTRY (IF FUNCTION (MAKE-ENTRY :TEST PRED :FN FUNCTION :FULL-SPEC (LIST PRIORITY TYPE-SPECIFIER))))) (CASE CATEGORY (CONS-WITH-CAR (COND ((NULL ENTRY) (REMHASH (CADADR TYPE-SPECIFIER) (CONSES-WITH-CARS TABLE))) (T (SETF (TEST ENTRY) (COUNT-IF (FUNCTION (LAMBDA (E) (PRIORITY-> (CAR (FULL-SPEC E)) PRIORITY))) (OTHERS TABLE))) (SETF (GETHASH (CADADR TYPE-SPECIFIER) (CONSES-WITH-CARS TABLE)) ENTRY)))) (STRUCTURE-TYPE (COND ((NULL ENTRY) (REMHASH TYPE-SPECIFIER (STRUCTURES TABLE))) (T (SETF (TEST ENTRY) (COUNT-IF (FUNCTION (LAMBDA (E) (PRIORITY-> (CAR (FULL-SPEC E)) PRIORITY))) (OTHERS TABLE))) (SETF (GETHASH TYPE-SPECIFIER (STRUCTURES TABLE)) ENTRY)))) (T (LET ((OLD (CAR (MEMBER TYPE-SPECIFIER (OTHERS TABLE) :TEST (FUNCTION EQUAL) :KEY (FUNCTION (LAMBDA (E) (CADR (FULL-SPEC E)))))))) (WHEN OLD (SETF (OTHERS TABLE) (DELETE OLD (OTHERS TABLE))) (ADJUST-COUNTS TABLE (CAR (FULL-SPEC OLD)) -1))) (WHEN ENTRY (LET ((OTHERS (CONS NIL (OTHERS TABLE)))) (DO ((L OTHERS (CDR L))) ((NULL (CDR L)) (RPLACD L (LIST ENTRY))) (WHEN (PRIORITY-> PRIORITY (CAR (FULL-SPEC (CADR L)))) (RPLACD L (CONS ENTRY (CDR L))) (RETURN NIL))) (SETF (OTHERS TABLE) (CDR OTHERS))) (ADJUST-COUNTS TABLE PRIORITY 1))))) NIL)
     [java] ; (DEFUN PRIORITY-> (X Y) (IF (CONSP X) (IF (CONSP Y) (> (CAR X) (CAR Y)) NIL) (IF (CONSP Y) T (> X Y))))
     [java] ; (DEFUN ADJUST-COUNTS (TABLE PRIORITY DELTA) (MAPHASH (FUNCTION (LAMBDA (KEY VALUE) (DECLARE (IGNORE KEY)) (IF (PRIORITY-> PRIORITY (CAR (FULL-SPEC VALUE))) (INCF (TEST VALUE) DELTA)))) (CONSES-WITH-CARS TABLE)) (MAPHASH (FUNCTION (LAMBDA (KEY VALUE) (DECLARE (IGNORE KEY)) (IF (PRIORITY-> PRIORITY (CAR (FULL-SPEC VALUE))) (INCF (TEST VALUE) DELTA)))) (STRUCTURES TABLE)))
     [java] ; (DEFUN PPRINT-DISPATCH (OBJECT &OPTIONAL (TABLE *PRINT-PPRINT-DISPATCH*)) (UNLESS TABLE (SETF TABLE *IPD*)) (LET ((FN (GET-PRINTER OBJECT TABLE))) (VALUES (OR FN (FUNCTION NON-PRETTY-PRINT)) (NOT (NULL FN)))))
     [java] ; (DEFUN GET-PRINTER (OBJECT TABLE) (LET* ((ENTRY (IF (CONSP OBJECT) (GETHASH (CAR OBJECT) (CONSES-WITH-CARS TABLE)) (GETHASH (TYPE-OF OBJECT) (STRUCTURES TABLE))))) (IF (NOT ENTRY) (SETQ ENTRY (FIND OBJECT (OTHERS TABLE) :TEST (FUNCTION FITS))) (DO ((I (TEST ENTRY) (1- I)) (L (OTHERS TABLE) (CDR L))) ((ZEROP I)) (WHEN (FITS OBJECT (CAR L)) (SETQ ENTRY (CAR L)) (RETURN NIL)))) (WHEN ENTRY (FN ENTRY))))
     [java] ; (DEFUN FITS (OBJ ENTRY) (FUNCALL (TEST ENTRY) OBJ))
     [java] ; (DEFUN SPECIFIER-CATEGORY (SPEC) (COND ((AND (CONSP SPEC) (EQ (CAR SPEC) (QUOTE CONS)) (CONSP (CDR SPEC)) (NULL (CDDR SPEC)) (CONSP (CADR SPEC)) (EQ (CAADR SPEC) (QUOTE MEMBER)) (CONSP (CDADR SPEC)) (NULL (CDDADR SPEC))) (QUOTE CONS-WITH-CAR)) ((AND (SYMBOLP SPEC) (GET SPEC (QUOTE STRUCTURE-PRINTER))) (QUOTE STRUCTURE-TYPE)) (T (QUOTE OTHER))))
     [java] ; (DEFVAR *PREDS-FOR-SPECS* (QUOTE ((T ALWAYS-TRUE) (CONS CONSP) (SIMPLE-ATOM SIMPLE-ATOM-P) (OTHER OTHERP) (NULL NULL) (SYMBOL SYMBOLP) (ATOM ATOM) (CONS CONSP) (LIST LISTP) (NUMBER NUMBERP) (INTEGER INTEGERP) (RATIONAL RATIONALP) (FLOAT FLOATP) (COMPLEX COMPLEXP) (CHARACTER CHARACTERP) (STRING STRINGP) (BIT-VECTOR BIT-VECTOR-P) (VECTOR VECTORP) (SIMPLE-VECTOR SIMPLE-VECTOR-P) (SIMPLE-STRING SIMPLE-STRING-P) (SIMPLE-BIT-VECTOR SIMPLE-BIT-VECTOR-P) (ARRAY ARRAYP) (PACKAGE PACKAGEP) (FUNCTION FUNCTIONP) (COMPILED-FUNCTION COMPILED-FUNCTION-P) (COMMON COMMONP))))
     [java] ; (DEFUN ALWAYS-TRUE (X) (DECLARE (IGNORE X)) T)
     [java] ; (DEFUN SPECIFIER-FN (SPEC) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (X)) (CONVERT-BODY SPEC)))
     [java] ; (DEFUN CONVERT-BODY (SPEC) (COND ((ATOM SPEC) (LET ((PRED (CADR (ASSOC SPEC *PREDS-FOR-SPECS*)))) (IF PRED (SYSTEM::BACKQ-CONS PRED (QUOTE (X))) (SYSTEM::BACKQ-LIST (QUOTE TYPEP) (QUOTE X) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SPEC))))) ((MEMBER (CAR SPEC) (QUOTE (AND OR NOT))) (CONS (CAR SPEC) (MAPCAR (FUNCTION CONVERT-BODY) (CDR SPEC)))) ((EQ (CAR SPEC) (QUOTE MEMBER)) (SYSTEM::BACKQ-LIST (QUOTE MEMBER) (QUOTE X) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (COPY-LIST (CDR SPEC))))) ((EQ (CAR SPEC) (QUOTE CONS)) (SYSTEM::BACKQ-LIST* (QUOTE AND) (QUOTE (CONSP X)) (SYSTEM::BACKQ-APPEND (IF (CDR SPEC) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE LET) (QUOTE ((X (CAR X)))) (CONVERT-BODY (CADR SPEC))))) (IF (CDDR SPEC) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE LET) (QUOTE ((X (CDR X)))) (CONVERT-BODY (CADDR SPEC)))))))) ((EQ (CAR SPEC) (QUOTE SATISFIES)) (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (CADR SPEC)) (QUOTE (X)))) ((EQ (CAR SPEC) (QUOTE EQL)) (SYSTEM::BACKQ-LIST (QUOTE EQL) (QUOTE X) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (CADR SPEC)))) (T (SYSTEM::BACKQ-LIST (QUOTE TYPEP) (QUOTE X) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (COPY-TREE SPEC))))))
     [java] ; (DEFUN FUNCTION-CALL-P (X) (AND (CONSP X) (SYMBOLP (CAR X)) (FBOUNDP (CAR X))))
     [java] ; (SETQ *IPD* (MAKE-PPRINT-DISPATCH-TABLE))
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (SATISFIES FUNCTION-CALL-P)) (QUOTE FN-CALL) (QUOTE (-5)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE CONS) (QUOTE PPRINT-FILL) (QUOTE (-10)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER BLOCK))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER CASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER CATCH))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER CCASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER COMPILER-LET))) (QUOTE LET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER COND))) (QUOTE COND-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER CTYPECASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFCONSTANT))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFINE-SETF-METHOD))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFMACRO))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFINE-MODIFY-MACRO))) (QUOTE DMM-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFPARAMETER))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFSETF))) (QUOTE DEFSETF-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFINE-SETF-METHOD))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFSTRUCT))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFTYPE))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFUN))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DEFVAR))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DO))) (QUOTE DO-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DO*))) (QUOTE DO-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DO-ALL-SYMBOLS))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DO-EXTERNAL-SYMBOLS))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DO-SYMBOLS))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DOLIST))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER DOTIMES))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER ECASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER ETYPECASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER EVAL-WHEN))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER FLET))) (QUOTE FLET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER FUNCTION))) (QUOTE FUNCTION-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LABELS))) (QUOTE FLET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LAMBDA))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LET))) (QUOTE LET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LET*))) (QUOTE LET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LOCALLY))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER LOOP))) (QUOTE PRETTY-LOOP) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER MACROLET))) (QUOTE FLET-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER MULTIPLE-VALUE-BIND))) (QUOTE MVB-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER MULTIPLE-VALUE-SETQ))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER PROG))) (QUOTE PROG-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER PROG*))) (QUOTE PROG-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER PROGV))) (QUOTE DEFUN-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER PSETF))) (QUOTE SETQ-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER PSETQ))) (QUOTE SETQ-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER QUOTE))) (QUOTE QUOTE-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER RETURN-FROM))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER SETF))) (QUOTE SETQ-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER SETQ))) (QUOTE SETQ-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER TAGBODY))) (QUOTE TAGBODY-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER THROW))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER TYPECASE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER UNLESS))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER UNWIND-PROTECT))) (QUOTE UP-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER WHEN))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER WITH-INPUT-FROM-STRING))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER WITH-OPEN-FILE))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER WITH-OPEN-STREAM))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE (CONS (MEMBER WITH-OUTPUT-TO-STRING))) (QUOTE BLOCK-LIKE) (QUOTE (0)) *IPD*)
     [java] ; (DEFUN PPRINT-DISPATCH-PRINT (XP TABLE) (LET ((STUFF (COPY-LIST (OTHERS TABLE)))) (MAPHASH (FUNCTION (LAMBDA (KEY VAL) (DECLARE (IGNORE KEY)) (PUSH VAL STUFF))) (CONSES-WITH-CARS TABLE)) (MAPHASH (FUNCTION (LAMBDA (KEY VAL) (DECLARE (IGNORE KEY)) (PUSH VAL STUFF))) (STRUCTURES TABLE)) (SETQ STUFF (SORT STUFF (FUNCTION PRIORITY->) :KEY (FUNCTION (LAMBDA (X) (CAR (FULL-SPEC X)))))) (PPRINT-LOGICAL-BLOCK (XP STUFF :PREFIX "#<" :SUFFIX ">") (FORMAT XP (FORMATTER "pprint dispatch table containing ~A entries: ") (LENGTH STUFF)) (LOOP (PPRINT-EXIT-IF-LIST-EXHAUSTED) (LET ((ENTRY (PPRINT-POP))) (FORMAT XP (FORMATTER "~{~_P=~4D ~W~} F=~W ") (FULL-SPEC ENTRY) (FN ENTRY)))))))
     [java] ; (SETF (GET (QUOTE PPRINT-DISPATCH-TABLE) (QUOTE STRUCTURE-PRINTER)) (FUNCTION PPRINT-DISPATCH-PRINT))
     [java] ; (SET-PPRINT-DISPATCH+ (QUOTE PPRINT-DISPATCH-TABLE) (FUNCTION PPRINT-DISPATCH-PRINT) (QUOTE (0)) *IPD*)
     [java] ; (SETF *PRINT-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint-dispatch.abcl (1.388 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint-dispatch.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint-dispatch.abcl (0.304 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pprint.lisp ...
     [java] ; (IN-PACKAGE #:XP)
     [java] ; (DEFVAR *PRINT-SHARED* NIL)
     [java] ; (DEFVAR *DEFAULT-RIGHT-MARGIN* 70 "controls default line length; must be a non-negative integer")
     [java] ; (DEFVAR *CURRENT-LEVEL* 0 "current depth in logical blocks.")
     [java] ; (DEFVAR *ABBREVIATION-HAPPENED* NIL "t if current thing being printed has been abbreviated.")
     [java] ; (DEFVAR *RESULT* NIL "used to pass back a value")
     [java] ; (DEFUN STRUCTURE-TYPE-P (X) (AND (SYMBOLP X) (GET X (QUOTE STRUCTURE-PRINTER))))
     [java] ; (DEFUN OUTPUT-WIDTH (&OPTIONAL (S *STANDARD-OUTPUT*)) (DECLARE (IGNORE S)) NIL)
     [java] ; (DEFVAR *LOCATING-CIRCULARITIES* NIL "Integer if making a first pass over things to identify circularities.
     [java]    Integer used as counter for #n= syntax.")
     [java] ; (DEFVAR BLOCK-STACK-ENTRY-SIZE 1)
     [java] ; (DEFVAR PREFIX-STACK-ENTRY-SIZE 5)
     [java] ; (DEFVAR QUEUE-ENTRY-SIZE 7)
     [java] ; (DEFVAR BUFFER-ENTRY-SIZE 1)
     [java] ; (DEFVAR PREFIX-ENTRY-SIZE 1)
     [java] ; (DEFVAR SUFFIX-ENTRY-SIZE 1)
     [java] ; (DEFVAR BLOCK-STACK-MIN-SIZE 35)
     [java] ; (DEFVAR PREFIX-STACK-MIN-SIZE 150)
     [java] ; (DEFVAR QUEUE-MIN-SIZE 525)
     [java] ; (DEFVAR BUFFER-MIN-SIZE 256)
     [java] ; (DEFVAR PREFIX-MIN-SIZE 256)
     [java] ; (DEFVAR SUFFIX-MIN-SIZE 256)
     [java] ; (DEFSTRUCT (XP-STRUCTURE (:CONC-NAME NIL)) (BASE-STREAM NIL) LINE-LENGTH LINE-LIMIT LINE-NO DEPTH-IN-BLOCKS (BLOCK-STACK (MAKE-ARRAY 35)) BLOCK-STACK-PTR (BUFFER (MAKE-ARRAY 256 :ELEMENT-TYPE (QUOTE CHARACTER))) CHARPOS BUFFER-PTR BUFFER-OFFSET (QUEUE (MAKE-ARRAY 525)) QLEFT QRIGHT (PREFIX (MAKE-ARRAY 256 :ELEMENT-TYPE (QUOTE CHARACTER))) (PREFIX-STACK (MAKE-ARRAY 150)) PREFIX-STACK-PTR (SUFFIX (MAKE-ARRAY 256 :ELEMENT-TYPE (QUOTE CHARACTER))))
     [java] ; (DEFUN EXTENSIONS:CHARPOS (STREAM) (COND ((XP-STRUCTURE-P STREAM) (CHARPOS STREAM)) ((STREAMP STREAM) (SYSTEM::STREAM-CHARPOS STREAM))))
     [java] ; (DEFUN (SETF EXTENSIONS:CHARPOS) (NEW-VALUE STREAM) (COND ((XP-STRUCTURE-P STREAM) (SETF (CHARPOS STREAM) NEW-VALUE)) ((STREAMP STREAM) (SYSTEM::STREAM-%SET-CHARPOS STREAM NEW-VALUE))))
     [java] ; (DEFMACRO LP<-BP (XP &OPTIONAL (PTR NIL)) (IF (NULL PTR) (SETQ PTR (SYSTEM::BACKQ-LIST (QUOTE BUFFER-PTR) XP))) (SYSTEM::BACKQ-LIST (QUOTE +) PTR (SYSTEM::BACKQ-LIST (QUOTE CHARPOS) XP)))
     [java] ; (DEFMACRO TP<-BP (XP) (SYSTEM::BACKQ-LIST (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE BUFFER-PTR) XP) (SYSTEM::BACKQ-LIST (QUOTE BUFFER-OFFSET) XP)))
     [java] ; (DEFMACRO BP<-LP (XP PTR) (SYSTEM::BACKQ-LIST (QUOTE -) PTR (SYSTEM::BACKQ-LIST (QUOTE CHARPOS) XP)))
     [java] ; (DEFMACRO BP<-TP (XP PTR) (SYSTEM::BACKQ-LIST (QUOTE -) PTR (SYSTEM::BACKQ-LIST (QUOTE BUFFER-OFFSET) XP)))
     [java] ; (DEFMACRO LP<-TP (XP PTR) (SYSTEM::BACKQ-LIST (QUOTE LP<-BP) XP (SYSTEM::BACKQ-LIST (QUOTE BP<-TP) XP PTR)))
     [java] ; (DEFMACRO CHECK-SIZE (XP VECT PTR) (LET* ((MIN-SIZE (SYMBOL-VALUE (INTERN (CONCATENATE (QUOTE STRING) (STRING VECT) "-MIN-SIZE") (FIND-PACKAGE "XP")))) (ENTRY-SIZE (SYMBOL-VALUE (INTERN (CONCATENATE (QUOTE STRING) (STRING VECT) "-ENTRY-SIZE") (FIND-PACKAGE "XP"))))) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE AND) (SYSTEM::BACKQ-LIST (QUOTE >) PTR (- MIN-SIZE ENTRY-SIZE)) (SYSTEM::BACKQ-LIST (QUOTE >) PTR (SYSTEM::BACKQ-LIST (QUOTE -) (SYSTEM::BACKQ-LIST (QUOTE LENGTH) (SYSTEM::BACKQ-LIST VECT XP)) ENTRY-SIZE))) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE OLD) (SYSTEM::BACKQ-LIST VECT XP)) (SYSTEM::BACKQ-LIST (QUOTE NEW) (SYSTEM::BACKQ-LIST* (QUOTE MAKE-ARRAY) (SYSTEM::BACKQ-LIST (QUOTE +) PTR (IF (= ENTRY-SIZE 1) 50 (* 10 ENTRY-SIZE))) (QUOTE (:ELEMENT-TYPE (ARRAY-ELEMENT-TYPE OLD)))))) (QUOTE (REPLACE NEW OLD)) (SYSTEM::BACKQ-LIST* (QUOTE SETF) (SYSTEM::BACKQ-LIST VECT XP) (QUOTE (NEW)))))))
     [java] ; (DEFMACRO SECTION-START (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE BLOCK-STACK) XP) (SYSTEM::BACKQ-LIST (QUOTE BLOCK-STACK-PTR) XP)))
     [java] ; (DEFUN PUSH-BLOCK-STACK (XP) (INCF (BLOCK-STACK-PTR XP) 1) (CHECK-SIZE XP BLOCK-STACK (BLOCK-STACK-PTR XP)))
     [java] ; (DEFUN POP-BLOCK-STACK (XP) (DECF (BLOCK-STACK-PTR XP) 1))
     [java] ; (DEFMACRO PREFIX-PTR (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK) XP) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP)))
     [java] ; (DEFMACRO SUFFIX-PTR (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP) (QUOTE (1)))))
     [java] ; (DEFMACRO NON-BLANK-PREFIX-PTR (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP) (QUOTE (2)))))
     [java] ; (DEFMACRO INITIAL-PREFIX-PTR (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP) (QUOTE (3)))))
     [java] ; (DEFMACRO SECTION-START-LINE (XP) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP) (QUOTE (4)))))
     [java] ; (DEFUN PUSH-PREFIX-STACK (XP) (LET ((OLD-PREFIX 0) (OLD-SUFFIX 0) (OLD-NON-BLANK 0)) (WHEN (NOT (MINUSP (PREFIX-STACK-PTR XP))) (SETQ OLD-PREFIX (PREFIX-PTR XP) OLD-SUFFIX (SUFFIX-PTR XP) OLD-NON-BLANK (NON-BLANK-PREFIX-PTR XP))) (INCF (PREFIX-STACK-PTR XP) 5) (CHECK-SIZE XP PREFIX-STACK (PREFIX-STACK-PTR XP)) (SETF (PREFIX-PTR XP) OLD-PREFIX) (SETF (SUFFIX-PTR XP) OLD-SUFFIX) (SETF (NON-BLANK-PREFIX-PTR XP) OLD-NON-BLANK)))
     [java] ; (DEFUN POP-PREFIX-STACK (XP) (DECF (PREFIX-STACK-PTR XP) 5))
     [java] ; (DEFMACRO QTYPE (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) INDEX))
     [java] ; (DEFMACRO QKIND (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST (QUOTE 1+) INDEX)))
     [java] ; (DEFMACRO QPOS (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (2)))))
     [java] ; (DEFMACRO QDEPTH (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (3)))))
     [java] ; (DEFMACRO QEND (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (4)))))
     [java] ; (DEFMACRO QOFFSET (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (5)))))
     [java] ; (DEFMACRO QARG (XP INDEX) (SYSTEM::BACKQ-LIST (QUOTE AREF) (SYSTEM::BACKQ-LIST (QUOTE QUEUE) XP) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (6)))))
     [java] ; (DEFUN ENQUEUE (XP TYPE KIND &OPTIONAL ARG) (INCF (QRIGHT XP) 7) (WHEN (> (QRIGHT XP) 518) (REPLACE (QUEUE XP) (QUEUE XP) :START2 (QLEFT XP) :END2 (QRIGHT XP)) (SETF (QRIGHT XP) (- (QRIGHT XP) (QLEFT XP))) (SETF (QLEFT XP) 0)) (CHECK-SIZE XP QUEUE (QRIGHT XP)) (SETF (QTYPE XP (QRIGHT XP)) TYPE) (SETF (QKIND XP (QRIGHT XP)) KIND) (SETF (QPOS XP (QRIGHT XP)) (TP<-BP XP)) (SETF (QDEPTH XP (QRIGHT XP)) (DEPTH-IN-BLOCKS XP)) (SETF (QEND XP (QRIGHT XP)) NIL) (SETF (QOFFSET XP (QRIGHT XP)) NIL) (SETF (QARG XP (QRIGHT XP)) ARG))
     [java] ; (DEFMACRO QNEXT (INDEX) (SYSTEM::BACKQ-LIST* (QUOTE +) INDEX (QUOTE (7))))
     [java] ; (DEFUN INITIALIZE-XP (XP STREAM) (SETF (BASE-STREAM XP) STREAM) (SETF (LINE-LENGTH XP) (MAX 0 (COND (*PRINT-RIGHT-MARGIN*) ((OUTPUT-WIDTH STREAM)) (T *DEFAULT-RIGHT-MARGIN*)))) (SETF (LINE-LIMIT XP) *PRINT-LINES*) (SETF (LINE-NO XP) 1) (SETF (DEPTH-IN-BLOCKS XP) 0) (SETF (BLOCK-STACK-PTR XP) 0) (SETF (CHARPOS XP) (COND ((EXTENSIONS:CHARPOS STREAM)) (T 0))) (SETF (SECTION-START XP) 0) (SETF (BUFFER-PTR XP) 0) (SETF (BUFFER-OFFSET XP) (CHARPOS XP)) (SETF (QLEFT XP) 0) (SETF (QRIGHT XP) -7) (SETF (PREFIX-STACK-PTR XP) -5) XP)
     [java] ; (DEFUN WRITE-CHAR+ (CHAR XP) (IF (EQL CHAR #\Newline) (PPRINT-NEWLINE+ :UNCONDITIONAL XP) (WRITE-CHAR++ CHAR XP)))
     [java] ; (DEFUN WRITE-STRING+ (STRING XP START END) (LET ((SUB-END NIL) NEXT-NEWLINE) (LOOP (SETQ NEXT-NEWLINE (POSITION #\Newline STRING :TEST (FUNCTION CHAR=) :START START :END END)) (SETQ SUB-END (IF NEXT-NEWLINE NEXT-NEWLINE END)) (WRITE-STRING++ STRING XP START SUB-END) (WHEN (NULL NEXT-NEWLINE) (RETURN NIL)) (PPRINT-NEWLINE+ :UNCONDITIONAL XP) (SETQ START (1+ SUB-END)))))
     [java] ; (DEFUN WRITE-CHAR++ (CHAR XP) (WHEN (> (BUFFER-PTR XP) (LINE-LENGTH XP)) (FORCE-SOME-OUTPUT XP)) (LET ((NEW-BUFFER-END (1+ (BUFFER-PTR XP)))) (CHECK-SIZE XP BUFFER NEW-BUFFER-END) (SETF (CHAR (BUFFER XP) (BUFFER-PTR XP)) CHAR) (SETF (BUFFER-PTR XP) NEW-BUFFER-END)))
     [java] ; (DEFUN FORCE-SOME-OUTPUT (XP) (ATTEMPT-TO-OUTPUT XP NIL NIL) (WHEN (> (BUFFER-PTR XP) (LINE-LENGTH XP)) (ATTEMPT-TO-OUTPUT XP T T)))
     [java] ; (DEFUN WRITE-STRING++ (STRING XP START END) (WHEN (> (BUFFER-PTR XP) (LINE-LENGTH XP)) (FORCE-SOME-OUTPUT XP)) (WRITE-STRING+++ STRING XP START END))
     [java] ; (DEFUN WRITE-STRING+++ (STRING XP START END) (LET ((NEW-BUFFER-END (+ (BUFFER-PTR XP) (- END START)))) (CHECK-SIZE XP BUFFER NEW-BUFFER-END) (DO ((BUFFER (BUFFER XP)) (I (BUFFER-PTR XP) (1+ I)) (J START (1+ J))) ((= J END)) (LET ((CHAR (CHAR STRING J))) (SETF (CHAR BUFFER I) CHAR))) (SETF (BUFFER-PTR XP) NEW-BUFFER-END)))
     [java] ; (DEFUN PPRINT-TAB+ (KIND COLNUM COLINC XP) (LET ((INDENTED? NIL) (RELATIVE? NIL)) (CASE KIND (:SECTION (SETQ INDENTED? T)) (:LINE-RELATIVE (SETQ RELATIVE? T)) (:SECTION-RELATIVE (SETQ INDENTED? T RELATIVE? T))) (LET* ((CURRENT (IF (NOT INDENTED?) (LP<-BP XP) (- (TP<-BP XP) (SECTION-START XP)))) (NEW (IF (ZEROP COLINC) (IF RELATIVE? (+ CURRENT COLNUM) (MAX COLNUM CURRENT)) (COND (RELATIVE? (* COLINC (FLOOR (+ CURRENT COLNUM COLINC -1) COLINC))) ((> COLNUM CURRENT) COLNUM) (T (+ COLNUM (* COLINC (FLOOR (+ CURRENT (- COLNUM) COLINC) COLINC))))))) (LENGTH (- NEW CURRENT))) (WHEN (PLUSP LENGTH) (LET ((END (+ (BUFFER-PTR XP) LENGTH))) (CHECK-SIZE XP BUFFER END) (FILL (BUFFER XP) #\  :START (BUFFER-PTR XP) :END END) (SETF (BUFFER-PTR XP) END))))))
     [java] ; (DEFUN PPRINT-NEWLINE+ (KIND XP) (ENQUEUE XP :NEWLINE KIND) (DO ((PTR (QLEFT XP) (QNEXT PTR))) ((NOT (< PTR (QRIGHT XP)))) (WHEN (AND (NULL (QEND XP PTR)) (NOT (> (DEPTH-IN-BLOCKS XP) (QDEPTH XP PTR))) (MEMBER (QTYPE XP PTR) (QUOTE (:NEWLINE :START-BLOCK)))) (SETF (QEND XP PTR) (- (QRIGHT XP) PTR)))) (SETF (SECTION-START XP) (TP<-BP XP)) (WHEN (MEMBER KIND (QUOTE (:FRESH :UNCONDITIONAL :MANDATORY))) (ATTEMPT-TO-OUTPUT XP T NIL)))
     [java] ; (DEFUN START-BLOCK (XP PREFIX ON-EACH-LINE? SUFFIX) (UNLESS (STRINGP PREFIX) (ERROR (QUOTE TYPE-ERROR) :DATUM PREFIX :EXPECTED-TYPE (QUOTE STRING))) (UNLESS (STRINGP SUFFIX) (ERROR (QUOTE TYPE-ERROR) :DATUM SUFFIX :EXPECTED-TYPE (QUOTE STRING))) (WHEN PREFIX (WRITE-STRING++ PREFIX XP 0 (LENGTH PREFIX))) (PUSH-BLOCK-STACK XP) (ENQUEUE XP :START-BLOCK NIL (IF ON-EACH-LINE? (CONS SUFFIX PREFIX) SUFFIX)) (INCF (DEPTH-IN-BLOCKS XP)) (SETF (SECTION-START XP) (TP<-BP XP)))
     [java] ; (DEFUN END-BLOCK (XP SUFFIX) (UNLESS (EQ *ABBREVIATION-HAPPENED* (QUOTE *PRINT-LINES*)) (WHEN SUFFIX (WRITE-STRING+ SUFFIX XP 0 (LENGTH SUFFIX))) (DECF (DEPTH-IN-BLOCKS XP)) (ENQUEUE XP :END-BLOCK NIL SUFFIX) (DO ((PTR (QLEFT XP) (QNEXT PTR))) ((NOT (< PTR (QRIGHT XP)))) (WHEN (AND (= (DEPTH-IN-BLOCKS XP) (QDEPTH XP PTR)) (EQ (QTYPE XP PTR) :START-BLOCK) (NULL (QOFFSET XP PTR))) (SETF (QOFFSET XP PTR) (- (QRIGHT XP) PTR)) (RETURN NIL))) (POP-BLOCK-STACK XP)))
     [java] ; (DEFUN PPRINT-INDENT+ (KIND N XP) (ENQUEUE XP :IND KIND N))
     [java] ; (DEFMACRO MAYBE-TOO-LARGE (XP QENTRY) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE LIMIT) (SYSTEM::BACKQ-LIST (QUOTE LINE-LENGTH) XP))) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE EQL) (SYSTEM::BACKQ-LIST (QUOTE LINE-LIMIT) XP) (SYSTEM::BACKQ-LIST (QUOTE LINE-NO) XP)) (QUOTE (DECF LIMIT 2)) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE NOT) (SYSTEM::BACKQ-LIST (QUOTE MINUSP) (SYSTEM::BACKQ-LIST (QUOTE PREFIX-STACK-PTR) XP))) (SYSTEM::BACKQ-LIST (QUOTE DECF) (QUOTE LIMIT) (SYSTEM::BACKQ-LIST (QUOTE SUFFIX-PTR) XP)))) (SYSTEM::BACKQ-LIST* (QUOTE COND) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE QEND) XP QENTRY) (SYSTEM::BACKQ-LIST* (QUOTE >) (SYSTEM::BACKQ-LIST (QUOTE LP<-TP) XP (SYSTEM::BACKQ-LIST (QUOTE QPOS) XP (SYSTEM::BACKQ-LIST (QUOTE +) QENTRY (SYSTEM::BACKQ-LIST (QUOTE QEND) XP QENTRY)))) (QUOTE (LIMIT)))) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE OR) (QUOTE FORCE-NEWLINES?) (SYSTEM::BACKQ-LIST* (QUOTE >) (SYSTEM::BACKQ-LIST (QUOTE LP<-BP) XP) (QUOTE (LIMIT)))) (QUOTE (T))) (QUOTE ((T (RETURN NIL)))))))
     [java] ; (DEFMACRO MISERING? (XP) (SYSTEM::BACKQ-LIST (QUOTE AND) (QUOTE *PRINT-MISER-WIDTH*) (SYSTEM::BACKQ-LIST* (QUOTE <=) (SYSTEM::BACKQ-LIST (QUOTE -) (SYSTEM::BACKQ-LIST (QUOTE LINE-LENGTH) XP) (SYSTEM::BACKQ-LIST (QUOTE INITIAL-PREFIX-PTR) XP)) (QUOTE (*PRINT-MISER-WIDTH*)))))
     [java] ; (DEFUN ATTEMPT-TO-OUTPUT (XP FORCE-NEWLINES? FLUSH-OUT?) (DO NIL ((> (QLEFT XP) (QRIGHT XP)) (SETF (QLEFT XP) 0) (SETF (QRIGHT XP) -7)) (CASE (QTYPE XP (QLEFT XP)) (:IND (UNLESS (MISERING? XP) (SET-INDENTATION-PREFIX XP (CASE (QKIND XP (QLEFT XP)) (:BLOCK (+ (INITIAL-PREFIX-PTR XP) (QARG XP (QLEFT XP)))) (T (+ (LP<-TP XP (QPOS XP (QLEFT XP))) (QARG XP (QLEFT XP))))))) (SETF (QLEFT XP) (QNEXT (QLEFT XP)))) (:START-BLOCK (COND ((MAYBE-TOO-LARGE XP (QLEFT XP)) (PUSH-PREFIX-STACK XP) (SETF (INITIAL-PREFIX-PTR XP) (PREFIX-PTR XP)) (SET-INDENTATION-PREFIX XP (LP<-TP XP (QPOS XP (QLEFT XP)))) (LET ((ARG (QARG XP (QLEFT XP)))) (WHEN (CONSP ARG) (SET-PREFIX XP (CDR ARG))) (SETF (INITIAL-PREFIX-PTR XP) (PREFIX-PTR XP)) (COND ((NOT (LISTP ARG)) (SET-SUFFIX XP ARG)) ((CAR ARG) (SET-SUFFIX XP (CAR ARG))))) (SETF (SECTION-START-LINE XP) (LINE-NO XP))) (T (INCF (QLEFT XP) (QOFFSET XP (QLEFT XP))))) (SETF (QLEFT XP) (QNEXT (QLEFT XP)))) (:END-BLOCK (POP-PREFIX-STACK XP) (SETF (QLEFT XP) (QNEXT (QLEFT XP)))) (T (WHEN (CASE (QKIND XP (QLEFT XP)) (:FRESH (NOT (ZEROP (LP<-BP XP)))) (:MISER (MISERING? XP)) (:FILL (OR (MISERING? XP) (> (LINE-NO XP) (SECTION-START-LINE XP)) (MAYBE-TOO-LARGE XP (QLEFT XP)))) (T T)) (OUTPUT-LINE XP (QLEFT XP)) (SETUP-FOR-NEXT-LINE XP (QLEFT XP))) (SETF (QLEFT XP) (QNEXT (QLEFT XP)))))) (WHEN FLUSH-OUT? (FLUSH XP)))
     [java] ; (DEFUN FLUSH (XP) (UNLESS *LOCATING-CIRCULARITIES* (WRITE-STRING (BUFFER XP) (BASE-STREAM XP) :END (BUFFER-PTR XP))) (INCF (BUFFER-OFFSET XP) (BUFFER-PTR XP)) (INCF (CHARPOS XP) (BUFFER-PTR XP)) (SETF (BUFFER-PTR XP) 0))
     [java] ; (DEFUN OUTPUT-LINE (XP QENTRY) (LET* ((OUT-POINT (BP<-TP XP (QPOS XP QENTRY))) (LAST-NON-BLANK (POSITION #\  (BUFFER XP) :TEST-NOT (FUNCTION CHAR=) :FROM-END T :END OUT-POINT)) (END (COND ((MEMBER (QKIND XP QENTRY) (QUOTE (:FRESH :UNCONDITIONAL))) OUT-POINT) (LAST-NON-BLANK (1+ LAST-NON-BLANK)) (T 0))) (LINE-LIMIT-EXIT (AND (LINE-LIMIT XP) (NOT *PRINT-READABLY*) (NOT (> (LINE-LIMIT XP) (LINE-NO XP)))))) (WHEN LINE-LIMIT-EXIT (SETF (BUFFER-PTR XP) END) (WRITE-STRING+++ " .." XP 0 3) (REVERSE-STRING-IN-PLACE (SUFFIX XP) 0 (SUFFIX-PTR XP)) (WRITE-STRING+++ (SUFFIX XP) XP 0 (SUFFIX-PTR XP)) (SETF (QLEFT XP) (QNEXT (QRIGHT XP))) (SETF *ABBREVIATION-HAPPENED* (QUOTE *PRINT-LINES*)) (THROW (QUOTE LINE-LIMIT-ABBREVIATION-EXIT) T)) (INCF (LINE-NO XP)) (UNLESS *LOCATING-CIRCULARITIES* (LET ((STREAM (BASE-STREAM XP))) (SYSTEM::%WRITE-STRING (BUFFER XP) STREAM 0 END) (SYSTEM::%TERPRI STREAM)))))
     [java] ; (DEFUN SETUP-FOR-NEXT-LINE (XP QENTRY) (LET* ((OUT-POINT (BP<-TP XP (QPOS XP QENTRY))) (PREFIX-END (COND ((MEMBER (QKIND XP QENTRY) (QUOTE (:UNCONDITIONAL :FRESH))) (NON-BLANK-PREFIX-PTR XP)) (T (PREFIX-PTR XP)))) (CHANGE (- PREFIX-END OUT-POINT))) (SETF (CHARPOS XP) 0) (WHEN (PLUSP CHANGE) (CHECK-SIZE XP BUFFER (+ (BUFFER-PTR XP) CHANGE))) (REPLACE (BUFFER XP) (BUFFER XP) :START1 PREFIX-END :START2 OUT-POINT :END2 (BUFFER-PTR XP)) (REPLACE (BUFFER XP) (PREFIX XP) :END2 PREFIX-END) (INCF (BUFFER-PTR XP) CHANGE) (DECF (BUFFER-OFFSET XP) CHANGE) (WHEN (NOT (MEMBER (QKIND XP QENTRY) (QUOTE (:UNCONDITIONAL :FRESH)))) (SETF (SECTION-START-LINE XP) (LINE-NO XP)))))
     [java] ; (DEFUN SET-INDENTATION-PREFIX (XP NEW-POSITION) (LET ((NEW-IND (MAX (NON-BLANK-PREFIX-PTR XP) NEW-POSITION))) (SETF (PREFIX-PTR XP) (INITIAL-PREFIX-PTR XP)) (CHECK-SIZE XP PREFIX NEW-IND) (WHEN (> NEW-IND (PREFIX-PTR XP)) (FILL (PREFIX XP) #\  :START (PREFIX-PTR XP) :END NEW-IND)) (SETF (PREFIX-PTR XP) NEW-IND)))
     [java] ; (DEFUN SET-PREFIX (XP PREFIX-STRING) (REPLACE (PREFIX XP) PREFIX-STRING :START1 (- (PREFIX-PTR XP) (LENGTH PREFIX-STRING))) (SETF (NON-BLANK-PREFIX-PTR XP) (PREFIX-PTR XP)))
     [java] ; (DEFUN SET-SUFFIX (XP SUFFIX-STRING) (LET* ((END (LENGTH SUFFIX-STRING)) (NEW-END (+ (SUFFIX-PTR XP) END))) (CHECK-SIZE XP SUFFIX NEW-END) (DO ((I (1- NEW-END) (1- I)) (J 0 (1+ J))) ((= J END)) (SETF (CHAR (SUFFIX XP) I) (CHAR SUFFIX-STRING J))) (SETF (SUFFIX-PTR XP) NEW-END)))
     [java] ; (DEFUN REVERSE-STRING-IN-PLACE (STRING START END) (DO ((I START (1+ I)) (J (1- END) (1- J))) ((NOT (< I J)) STRING) (LET ((C (CHAR STRING I))) (SETF (CHAR STRING I) (CHAR STRING J)) (SETF (CHAR STRING J) C))))
     [java] ; (DEFUN WRITE (OBJECT &KEY ((:STREAM STREAM) *STANDARD-OUTPUT*) ((:ESCAPE *PRINT-ESCAPE*) *PRINT-ESCAPE*) ((:RADIX *PRINT-RADIX*) *PRINT-RADIX*) ((:BASE *PRINT-BASE*) *PRINT-BASE*) ((:CIRCLE *PRINT-CIRCLE*) *PRINT-CIRCLE*) ((:PRETTY *PRINT-PRETTY*) *PRINT-PRETTY*) ((:LEVEL *PRINT-LEVEL*) *PRINT-LEVEL*) ((:LENGTH *PRINT-LENGTH*) *PRINT-LENGTH*) ((:CASE *PRINT-CASE*) *PRINT-CASE*) ((:ARRAY *PRINT-ARRAY*) *PRINT-ARRAY*) ((:GENSYM *PRINT-GENSYM*) *PRINT-GENSYM*) ((:READABLY *PRINT-READABLY*) *PRINT-READABLY*) ((:RIGHT-MARGIN *PRINT-RIGHT-MARGIN*) *PRINT-RIGHT-MARGIN*) ((:MISER-WIDTH *PRINT-MISER-WIDTH*) *PRINT-MISER-WIDTH*) ((:LINES *PRINT-LINES*) *PRINT-LINES*) ((:PPRINT-DISPATCH *PRINT-PPRINT-DISPATCH*) *PRINT-PPRINT-DISPATCH*)) (SYSTEM:OUTPUT-OBJECT OBJECT (SYSTEM:OUT-SYNONYM-OF STREAM)) OBJECT)
     [java] ; (DEFUN MAYBE-INITIATE-XP-PRINTING (OBJECT FN STREAM &REST ARGS) (IF (XP-STRUCTURE-P STREAM) (APPLY FN STREAM ARGS) (LET ((*ABBREVIATION-HAPPENED* NIL) (*RESULT* NIL)) (IF (AND *PRINT-CIRCLE* (NULL SYSTEM::*CIRCULARITY-HASH-TABLE*)) (LET ((SYSTEM::*CIRCULARITY-HASH-TABLE* (MAKE-HASH-TABLE :TEST (QUOTE EQ)))) (SETF (GETHASH OBJECT SYSTEM::*CIRCULARITY-HASH-TABLE*) T) (XP-PRINT FN (MAKE-BROADCAST-STREAM) ARGS) (LET ((SYSTEM::*CIRCULARITY-COUNTER* 0)) (WHEN (EQL 0 (GETHASH OBJECT SYSTEM::*CIRCULARITY-HASH-TABLE*)) (SETF (GETHASH OBJECT SYSTEM::*CIRCULARITY-HASH-TABLE*) (INCF SYSTEM::*CIRCULARITY-COUNTER*)) (SYSTEM::PRINT-LABEL (GETHASH OBJECT SYSTEM::*CIRCULARITY-HASH-TABLE*) (SYSTEM:OUT-SYNONYM-OF STREAM))) (XP-PRINT FN (SYSTEM:OUT-SYNONYM-OF STREAM) ARGS))) (XP-PRINT FN (SYSTEM:OUT-SYNONYM-OF STREAM) ARGS)) *RESULT*)))
     [java] ; (DEFUN XP-PRINT (FN STREAM ARGS) (SETQ *RESULT* (DO-XP-PRINTING FN STREAM ARGS)) (WHEN *LOCATING-CIRCULARITIES* (SETQ *LOCATING-CIRCULARITIES* NIL) (SETQ *ABBREVIATION-HAPPENED* NIL) (SETQ *RESULT* (DO-XP-PRINTING FN STREAM ARGS))))
     [java] ; (DEFUN DO-XP-PRINTING (FN STREAM ARGS) (LET ((XP (INITIALIZE-XP (MAKE-XP-STRUCTURE) STREAM)) (*CURRENT-LEVEL* 0) (RESULT NIL)) (CATCH (QUOTE LINE-LIMIT-ABBREVIATION-EXIT) (START-BLOCK XP "" NIL "") (SETQ RESULT (APPLY FN XP ARGS)) (END-BLOCK XP NIL)) (WHEN (AND *LOCATING-CIRCULARITIES* (ZEROP *LOCATING-CIRCULARITIES*) (= (LINE-NO XP) 1) (ZEROP (BUFFER-OFFSET XP))) (SETQ *LOCATING-CIRCULARITIES* NIL)) (WHEN (CATCH (QUOTE LINE-LIMIT-ABBREVIATION-EXIT) (ATTEMPT-TO-OUTPUT XP NIL T) NIL) (ATTEMPT-TO-OUTPUT XP T T)) RESULT))
     [java] ; (DEFUN WRITE+ (OBJECT XP) (LET ((PRINTER (IF *PRINT-PRETTY* (GET-PRINTER OBJECT *PRINT-PPRINT-DISPATCH*) NIL)) TYPE) (COND (PRINTER (FUNCALL PRINTER XP OBJECT)) ((MAYBE-PRINT-FAST OBJECT XP)) ((AND *PRINT-PRETTY* (SYMBOLP (SETQ TYPE (TYPE-OF OBJECT))) (SETQ PRINTER (GET TYPE (QUOTE STRUCTURE-PRINTER))) (NOT (EQ PRINTER :NONE))) (FUNCALL PRINTER XP OBJECT)) ((AND *PRINT-PRETTY* *PRINT-ARRAY* (ARRAYP OBJECT) (NOT (STRINGP OBJECT)) (NOT (BIT-VECTOR-P OBJECT)) (NOT (STRUCTURE-TYPE-P (TYPE-OF OBJECT)))) (PRETTY-ARRAY XP OBJECT)) (T (LET ((STUFF (WITH-OUTPUT-TO-STRING (S) (NON-PRETTY-PRINT OBJECT S)))) (WRITE-STRING+ STUFF XP 0 (LENGTH STUFF)))))))
     [java] ; (DEFUN NON-PRETTY-PRINT (OBJECT S) (SYSTEM::OUTPUT-UGLY-OBJECT OBJECT S))
     [java] ; (DEFUN MAYBE-PRINT-FAST (OBJECT XP) (COND ((STRINGP OBJECT) (LET ((S (SYSTEM::%WRITE-TO-STRING OBJECT))) (WRITE-STRING++ S XP 0 (LENGTH S)) T)) ((EXTENSIONS:FIXNUMP OBJECT) (PRINT-FIXNUM XP OBJECT) T) ((AND (SYMBOLP OBJECT) (OR (SYMBOL-PACKAGE OBJECT) (NULL *PRINT-CIRCLE*))) (LET ((S (SYSTEM::%WRITE-TO-STRING OBJECT))) (WRITE-STRING++ S XP 0 (LENGTH S)) T))))
     [java] ; (DEFUN PRINT-FIXNUM (XP FIXNUM) (LET ((S (SYSTEM::%WRITE-TO-STRING FIXNUM))) (WRITE-STRING++ S XP 0 (LENGTH S))))
     [java] ; (DEFUN PRINT (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (TERPRI STREAM) (LET ((*PRINT-ESCAPE* T)) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM)) (WRITE-CHAR #\  STREAM) OBJECT)
     [java] ; (DEFUN PRIN1 (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (LET ((*PRINT-ESCAPE* T)) (SYSTEM:OUTPUT-OBJECT OBJECT (SYSTEM:OUT-SYNONYM-OF STREAM))) OBJECT)
     [java] ; (DEFUN PRINC (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (LET ((*PRINT-ESCAPE* NIL) (*PRINT-READABLY* NIL)) (SYSTEM:OUTPUT-OBJECT OBJECT (SYSTEM:OUT-SYNONYM-OF STREAM))) OBJECT)
     [java] ; (DEFUN PPRINT (OBJECT &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETQ STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (TERPRI STREAM) (LET ((*PRINT-ESCAPE* T) (*PRINT-PRETTY* T)) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM)) (VALUES))
     [java] ; (DEFUN WRITE-TO-STRING (OBJECT &KEY ((:ESCAPE *PRINT-ESCAPE*) *PRINT-ESCAPE*) ((:RADIX *PRINT-RADIX*) *PRINT-RADIX*) ((:BASE *PRINT-BASE*) *PRINT-BASE*) ((:CIRCLE *PRINT-CIRCLE*) *PRINT-CIRCLE*) ((:PRETTY *PRINT-PRETTY*) *PRINT-PRETTY*) ((:LEVEL *PRINT-LEVEL*) *PRINT-LEVEL*) ((:LENGTH *PRINT-LENGTH*) *PRINT-LENGTH*) ((:CASE *PRINT-CASE*) *PRINT-CASE*) ((:ARRAY *PRINT-ARRAY*) *PRINT-ARRAY*) ((:GENSYM *PRINT-GENSYM*) *PRINT-GENSYM*) ((:READABLY *PRINT-READABLY*) *PRINT-READABLY*) ((:RIGHT-MARGIN *PRINT-RIGHT-MARGIN*) *PRINT-RIGHT-MARGIN*) ((:MISER-WIDTH *PRINT-MISER-WIDTH*) *PRINT-MISER-WIDTH*) ((:LINES *PRINT-LINES*) *PRINT-LINES*) ((:PPRINT-DISPATCH *PRINT-PPRINT-DISPATCH*) *PRINT-PPRINT-DISPATCH*)) (LET ((STREAM (MAKE-STRING-OUTPUT-STREAM))) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM) (GET-OUTPUT-STREAM-STRING STREAM)))
     [java] ; (DEFUN PRIN1-TO-STRING (OBJECT) (WITH-OUTPUT-TO-STRING (STREAM) (LET ((*PRINT-ESCAPE* T)) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM))))
     [java] ; (DEFUN PRINC-TO-STRING (OBJECT) (WITH-OUTPUT-TO-STRING (STREAM) (LET ((*PRINT-ESCAPE* NIL) (*PRINT-READABLY* NIL)) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM))))
     [java] ; (DEFUN WRITE-CHAR (CHAR &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (IF (XP-STRUCTURE-P STREAM) (WRITE-CHAR+ CHAR STREAM) (SYSTEM:%STREAM-WRITE-CHAR CHAR STREAM)) CHAR)
     [java] ; (DEFUN WRITE-STRING (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) END) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (SETF END (OR END (LENGTH STRING))) (IF (XP-STRUCTURE-P STREAM) (WRITE-STRING+ STRING STREAM START END) (PROGN (UNLESS START (SETF START 0)) (IF END (SETF END (MIN END (LENGTH STRING))) (SETF END (LENGTH STRING))) (SYSTEM::%WRITE-STRING STRING STREAM START END))) STRING)
     [java] ; (DEFUN WRITE-LINE (STRING &OPTIONAL (STREAM *STANDARD-OUTPUT*) &KEY (START 0) END) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (SETF END (OR END (LENGTH STRING))) (COND ((XP-STRUCTURE-P STREAM) (WRITE-STRING+ STRING STREAM START END) (PPRINT-NEWLINE+ :UNCONDITIONAL STREAM)) (T (SYSTEM::%WRITE-STRING STRING STREAM START END) (SYSTEM::%TERPRI STREAM))) STRING)
     [java] ; (DEFUN TERPRI (&OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (IF (XP-STRUCTURE-P STREAM) (PPRINT-NEWLINE+ :UNCONDITIONAL STREAM) (SYSTEM:%STREAM-TERPRI STREAM)) NIL)
     [java] ; (DEFUN FRESH-LINE (&OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (COND ((XP-STRUCTURE-P STREAM) (ATTEMPT-TO-OUTPUT STREAM T T) (WHEN (NOT (ZEROP (LP<-BP STREAM))) (PPRINT-NEWLINE+ :FRESH STREAM) T)) (T (SYSTEM::%FRESH-LINE STREAM))))
     [java] ; (DEFUN FINISH-OUTPUT (&OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (XP-STRUCTURE-P STREAM) (ATTEMPT-TO-OUTPUT STREAM T T) (SETF STREAM (BASE-STREAM STREAM))) (SYSTEM::%FINISH-OUTPUT STREAM) NIL)
     [java] ; (DEFUN FORCE-OUTPUT (&OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (XP-STRUCTURE-P STREAM) (ATTEMPT-TO-OUTPUT STREAM T T) (SETF STREAM (BASE-STREAM STREAM))) (SYSTEM::%FORCE-OUTPUT STREAM) NIL)
     [java] ; (DEFUN CLEAR-OUTPUT (&OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETF STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (XP-STRUCTURE-P STREAM) (LET ((*LOCATING-CIRCULARITIES* 0)) (ATTEMPT-TO-OUTPUT STREAM T T) (SETF STREAM (BASE-STREAM STREAM)))) (SYSTEM::%CLEAR-OUTPUT STREAM) NIL)
     [java] ; (DEFMACRO PPRINT-LOGICAL-BLOCK ((STREAM-SYMBOL OBJECT &KEY (PREFIX "" PREFIX-P) (PER-LINE-PREFIX "" PER-LINE-PREFIX-P) (SUFFIX "")) &BODY BODY) (COND ((EQ STREAM-SYMBOL NIL) (SETF STREAM-SYMBOL (QUOTE *STANDARD-OUTPUT*))) ((EQ STREAM-SYMBOL T) (SETF STREAM-SYMBOL (QUOTE *TERMINAL-IO*)))) (UNLESS (SYMBOLP STREAM-SYMBOL) (WARN "STREAM-SYMBOL arg ~S to PPRINT-LOGICAL-BLOCK is not a bindable symbol." STREAM-SYMBOL) (SETF STREAM-SYMBOL (QUOTE *STANDARD-OUTPUT*))) (WHEN (AND PREFIX-P PER-LINE-PREFIX-P) (ERROR "Cannot specify values for both PREFIX and PER-LINE-PREFIX.")) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE +L) OBJECT)) (SYSTEM::BACKQ-LIST (QUOTE MAYBE-INITIATE-XP-PRINTING) (QUOTE +L) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST STREAM-SYMBOL) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (QUOTE (+L +L)) (SYSTEM::BACKQ-LIST (QUOTE +P) (COND (PREFIX-P PREFIX) (PER-LINE-PREFIX-P PER-LINE-PREFIX) (T ""))) (SYSTEM::BACKQ-LIST (QUOTE +S) SUFFIX)) (SYSTEM::BACKQ-LIST* (QUOTE PPRINT-LOGICAL-BLOCK+) (SYSTEM::BACKQ-LIST* STREAM-SYMBOL (QUOTE +L) (QUOTE +P) (QUOTE +S) PER-LINE-PREFIX-P (QUOTE (T NIL))) (SYSTEM::BACKQ-APPEND BODY (QUOTE (NIL))))))) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM:OUT-SYNONYM-OF) STREAM-SYMBOL))))
     [java] ; (DEFMACRO PPRINT-LOGICAL-BLOCK+ ((VAR ARGS PREFIX SUFFIX PER-LINE? CIRCLE-CHECK? ATSIGN?) &BODY BODY) (DECLARE (IGNORE ATSIGN?)) (SYSTEM::BACKQ-LIST (QUOTE LET) (QUOTE ((*CURRENT-LEVEL* (1+ *CURRENT-LEVEL*)) (SYSTEM:*CURRENT-PRINT-LENGTH* -1))) (SYSTEM::BACKQ-LIST (QUOTE UNLESS) (SYSTEM::BACKQ-LIST (QUOTE CHECK-BLOCK-ABBREVIATION) VAR ARGS CIRCLE-CHECK?) (SYSTEM::BACKQ-LIST (QUOTE BLOCK) (QUOTE LOGICAL-BLOCK) (SYSTEM::BACKQ-LIST (QUOTE START-BLOCK) VAR PREFIX PER-LINE? SUFFIX) (SYSTEM::BACKQ-LIST (QUOTE UNWIND-PROTECT) (SYSTEM::BACKQ-LIST* (QUOTE MACROLET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE PPRINT-POP) NIL (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST (QUOTE PPRINT-POP+) ARGS VAR))) (SYSTEM::BACKQ-LIST (QUOTE PPRINT-EXIT-IF-LIST-EXHAUSTED) NIL (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (SYSTEM::BACKQ-LIST* (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE NULL) ARGS) (QUOTE ((RETURN-FROM LOGICAL-BLOCK NIL))))))) BODY) (SYSTEM::BACKQ-LIST (QUOTE END-BLOCK) VAR SUFFIX))))))
     [java] ; (DEFUN PPRINT-NEWLINE (KIND &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SYSTEM:REQUIRE-TYPE KIND (QUOTE (MEMBER :LINEAR :MISER :FILL :MANDATORY))) (SETQ STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (NOT (MEMBER KIND (QUOTE (:LINEAR :MISER :FILL :MANDATORY)))) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "Invalid KIND argument ~A to PPRINT-NEWLINE." :FORMAT-ARGUMENTS (LIST KIND))) (WHEN (AND (XP-STRUCTURE-P STREAM) *PRINT-PRETTY*) (PPRINT-NEWLINE+ KIND STREAM)) NIL)
     [java] ; (DEFUN PPRINT-INDENT (RELATIVE-TO N &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETQ STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (NOT (MEMBER RELATIVE-TO (QUOTE (:BLOCK :CURRENT)))) (ERROR "Invalid KIND argument ~A to PPRINT-INDENT" RELATIVE-TO)) (WHEN (AND (XP-STRUCTURE-P STREAM) *PRINT-PRETTY*) (PPRINT-INDENT+ RELATIVE-TO (TRUNCATE N) STREAM)) NIL)
     [java] ; (DEFUN PPRINT-TAB (KIND COLNUM COLINC &OPTIONAL (STREAM *STANDARD-OUTPUT*)) (SETQ STREAM (SYSTEM:OUT-SYNONYM-OF STREAM)) (WHEN (NOT (MEMBER KIND (QUOTE (:LINE :SECTION :LINE-RELATIVE :SECTION-RELATIVE)))) (ERROR "Invalid KIND argument ~A to PPRINT-TAB" KIND)) (WHEN (AND (XP-STRUCTURE-P STREAM) *PRINT-PRETTY*) (PPRINT-TAB+ KIND COLNUM COLINC STREAM)) NIL)
     [java] ; (DEFMACRO PPRINT-POP+ (ARGS XP) (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST (QUOTE PPRINT-POP-CHECK+) ARGS XP) (QUOTE (RETURN-FROM LOGICAL-BLOCK NIL)) (SYSTEM::BACKQ-LIST (QUOTE POP) ARGS)))
     [java] ; (DEFUN PPRINT-POP-CHECK+ (ARGS XP) (INCF SYSTEM:*CURRENT-PRINT-LENGTH*) (COND ((NOT (LISTP ARGS)) (WRITE-STRING++ ". " XP 0 2) (SYSTEM:OUTPUT-OBJECT ARGS XP) T) ((AND *PRINT-LENGTH* (NOT *PRINT-READABLY*) (NOT (< SYSTEM:*CURRENT-PRINT-LENGTH* *PRINT-LENGTH*))) (WRITE-STRING++ "..." XP 0 3) T) ((OR (NOT *PRINT-CIRCLE*) (SYSTEM::UNIQUELY-IDENTIFIED-BY-PRINT-P ARGS)) NIL) ((AND (PLUSP SYSTEM:*CURRENT-PRINT-LENGTH*) (SYSTEM::CHECK-FOR-CIRCULARITY ARGS)) (WRITE-STRING++ ". " XP 0 2) (SYSTEM:OUTPUT-OBJECT ARGS XP) T)))
     [java] ; (DEFUN CHECK-BLOCK-ABBREVIATION (XP ARGS CIRCLE-CHECK?) (DECLARE (IGNORE CIRCLE-CHECK?)) (COND ((NOT (LISTP ARGS)) (SYSTEM:OUTPUT-OBJECT ARGS XP) T) ((AND *PRINT-LEVEL* (NOT *PRINT-READABLY*) (> *CURRENT-LEVEL* *PRINT-LEVEL*)) (WRITE-CHAR++ #\# XP) (SETF *ABBREVIATION-HAPPENED* T) T) (T NIL)))
     [java] ; (DEFUN PRETTY-ARRAY (XP ARRAY) (COND ((VECTORP ARRAY) (PRETTY-VECTOR XP ARRAY)) ((ZEROP (ARRAY-RANK ARRAY)) (WHEN *PRINT-READABLY* (UNLESS (EQ (ARRAY-ELEMENT-TYPE ARRAY) T) (ERROR (QUOTE PRINT-NOT-READABLE) :OBJECT ARRAY))) (WRITE-STRING++ "#0A" XP 0 3) (SYSTEM:OUTPUT-OBJECT (AREF ARRAY) XP)) (T (PRETTY-NON-VECTOR XP ARRAY))))
     [java] ; (DEFUN PRETTY-VECTOR (XP V) (PPRINT-LOGICAL-BLOCK (XP NIL :PREFIX "#(" :SUFFIX ")") (LET ((END (LENGTH V)) (I 0)) (WHEN (PLUSP END) (LOOP (PPRINT-POP) (SYSTEM:OUTPUT-OBJECT (AREF V I) XP) (WHEN (= (INCF I) END) (RETURN NIL)) (WRITE-CHAR++ #\  XP) (PPRINT-NEWLINE+ :FILL XP))))))
     [java] ; (DECLAIM (SPECIAL *PREFIX*))
     [java] ; (DEFUN PRETTY-NON-VECTOR (XP ARRAY) (WHEN (AND *PRINT-READABLY* (NOT (ARRAY-READABLY-PRINTABLE-P ARRAY))) (ERROR (QUOTE PRINT-NOT-READABLE) :OBJECT ARRAY)) (LET* ((BOTTOM (1- (ARRAY-RANK ARRAY))) (INDICES (MAKE-LIST (1+ BOTTOM) :INITIAL-ELEMENT 0)) (DIMS (ARRAY-DIMENSIONS ARRAY)) (*PREFIX* (FORMAT NIL "#~DA(" (1+ BOTTOM)))) (LABELS ((PRETTY-SLICE (SLICE) (PPRINT-LOGICAL-BLOCK (XP NIL :PREFIX *PREFIX* :SUFFIX ")") (LET ((END (NTH SLICE DIMS)) (SPOT (NTHCDR SLICE INDICES)) (I 0) (*PREFIX* "(")) (WHEN (PLUSP END) (LOOP (PPRINT-POP) (SETF (CAR SPOT) I) (IF (= SLICE BOTTOM) (SYSTEM:OUTPUT-OBJECT (APPLY (FUNCTION AREF) ARRAY INDICES) XP) (PRETTY-SLICE (1+ SLICE))) (IF (= (INCF I) END) (RETURN NIL)) (WRITE-CHAR++ #\  XP) (PPRINT-NEWLINE+ (IF (= SLICE BOTTOM) :FILL :LINEAR) XP))))))) (PRETTY-SLICE 0))))
     [java] ; (DEFUN ARRAY-READABLY-PRINTABLE-P (ARRAY) (AND (EQ (ARRAY-ELEMENT-TYPE ARRAY) T) (LET ((ZERO (POSITION 0 (ARRAY-DIMENSIONS ARRAY))) (NUMBER (POSITION 0 (ARRAY-DIMENSIONS ARRAY) :TEST (COMPLEMENT (FUNCTION EQL)) :FROM-END T))) (OR (NULL ZERO) (NULL NUMBER) (> ZERO NUMBER)))))
     [java] ; (DEFUN PPRINT-LINEAR (S LIST &OPTIONAL (COLON? T) ATSIGN?) (DECLARE (IGNORE ATSIGN?)) (PPRINT-LOGICAL-BLOCK (S LIST :PREFIX (IF COLON? "(" "") :SUFFIX (IF COLON? ")" "")) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (LOOP (SYSTEM:OUTPUT-OBJECT (PPRINT-POP) S) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (WRITE-CHAR++ #\  S) (PPRINT-NEWLINE+ :LINEAR S))))
     [java] ; (DEFUN PPRINT-FILL (STREAM OBJECT &OPTIONAL (COLON-P T) AT-SIGN-P) (DECLARE (IGNORE AT-SIGN-P)) (PPRINT-LOGICAL-BLOCK (STREAM OBJECT :PREFIX (IF COLON-P "(" "") :SUFFIX (IF COLON-P ")" "")) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (LOOP (SYSTEM:OUTPUT-OBJECT (PPRINT-POP) STREAM) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (WRITE-CHAR++ #\  STREAM) (PPRINT-NEWLINE+ :FILL STREAM))))
     [java] ; (DEFUN PPRINT-TABULAR (STREAM LIST &OPTIONAL (COLON-P T) AT-SIGN-P (TABSIZE NIL)) (DECLARE (IGNORE AT-SIGN-P)) (WHEN (NULL TABSIZE) (SETQ TABSIZE 16)) (PPRINT-LOGICAL-BLOCK (STREAM LIST :PREFIX (IF COLON-P "(" "") :SUFFIX (IF COLON-P ")" "")) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (LOOP (SYSTEM:OUTPUT-OBJECT (PPRINT-POP) STREAM) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (WRITE-CHAR++ #\  STREAM) (PPRINT-TAB+ :SECTION-RELATIVE 0 TABSIZE STREAM) (PPRINT-NEWLINE+ :FILL STREAM))))
     [java] ; (DEFUN FN-CALL (XP LIST) (FUNCALL (FORMATTER "~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>") XP LIST))
     [java] ; (DEFUN ALTERNATIVE-FN-CALL (XP LIST) (IF (> (LENGTH (SYMBOL-NAME (CAR LIST))) 12) (FUNCALL (FORMATTER "~:<~1I~@{~W~^ ~_~}~:>") XP LIST) (FUNCALL (FORMATTER "~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>") XP LIST)))
     [java] ; (DEFUN BIND-LIST (XP LIST &REST ARGS) (DECLARE (IGNORE ARGS)) (IF (DO ((I 50 (1- I)) (LS LIST (CDR LS))) ((NULL LS) T) (WHEN (OR (NOT (CONSP LS)) (NOT (SYMBOLP (CAR LS))) (MINUSP I)) (RETURN NIL))) (PPRINT-FILL XP LIST) (FUNCALL (FORMATTER "~:<~@{~:/xp:pprint-fill/~^ ~_~}~:>") XP LIST)))
     [java] ; (DEFUN BLOCK-LIKE (XP LIST &REST ARGS) (DECLARE (IGNORE ARGS)) (FUNCALL (FORMATTER "~:<~1I~^~W~^ ~@_~W~^~@{ ~_~W~^~}~:>") XP LIST))
     [java] ; (DEFUN DEFUN-LIKE (XP LIST &REST ARGS) (DECLARE (IGNORE ARGS)) (FUNCALL (FORMATTER "~:<~1I~W~^ ~@_~W~^ ~@_~:/xp:pprint-fill/~^~@{ ~_~W~^~}~:>") XP LIST))
     [java] ; (DEFUN PRINT-FANCY-FN-CALL (XP LIST TEMPLATE) (LET ((I 0) (IN-FIRST-SECTION T)) (PPRINT-LOGICAL-BLOCK+ (XP LIST "(" ")" NIL T NIL) (SYSTEM:OUTPUT-OBJECT (PPRINT-POP) XP) (PPRINT-INDENT+ :CURRENT 1 XP) (LOOP (PPRINT-EXIT-IF-LIST-EXHAUSTED) (WRITE-CHAR++ #\  XP) (WHEN (EQ I (CAR TEMPLATE)) (PPRINT-INDENT+ :BLOCK (CADR TEMPLATE) XP) (SETQ TEMPLATE (CDDR TEMPLATE)) (SETQ IN-FIRST-SECTION NIL)) (PPRINT-NEWLINE (COND ((AND (ZEROP I) IN-FIRST-SECTION) :MISER) (IN-FIRST-SECTION :FILL) (T :LINEAR)) XP) (SYSTEM:OUTPUT-OBJECT (PPRINT-POP) XP) (INCF I)))))
     [java] ; (DEFUN LET-PRINT (XP OBJ) (FUNCALL (FORMATTER "~:<~^~W~^ ~@_~:<~@{~:<~^~W~@{ ~_~W~}~:>~^ ~_~}~:>~1I~:@_~@{~W~^ ~_~}~:>") XP OBJ))
     [java] ; (DEFUN COND-PRINT (XP OBJ) (FUNCALL (FORMATTER "~:<~W~^ ~:I~@_~@{~:/xp:pprint-linear/~^ ~_~}~:>") XP OBJ))
     [java] ; (DEFUN DMM-PRINT (XP LIST) (PRINT-FANCY-FN-CALL XP LIST (QUOTE (3 1))))
     [java] ; (DEFUN DEFSETF-PRINT (XP LIST) (PRINT-FANCY-FN-CALL XP LIST (QUOTE (3 1))))
     [java] ; (DEFUN DO-PRINT (XP OBJ) (FUNCALL (FORMATTER "~:<~W~^ ~:I~@_~/xp:bind-list/~^ ~_~:/xp:pprint-linear/ ~1I~^~@{ ~_~W~^~}~:>") XP OBJ))
     [java] ; (DEFUN FLET-PRINT (XP OBJ) (FUNCALL (FORMATTER "~:<~1I~W~^ ~@_~:<~@{~/xp:block-like/~^ ~_~}~:>~^~@{ ~_~W~^~}~:>") XP OBJ))
     [java] ; (DEFUN FUNCTION-PRINT (XP LIST) (IF (AND (CONSP (CDR LIST)) (NULL (CDDR LIST))) (FUNCALL (FORMATTER "#'~W") XP (CADR LIST)) (FN-CALL XP LIST)))
     [java] ; (DEFUN MVB-PRINT (XP LIST) (PRINT-FANCY-FN-CALL XP LIST (QUOTE (1 3 2 1))))
     [java] ; (DEFUN MAYBELAB (XP ITEM &REST ARGS) (DECLARE (IGNORE ARGS) (SPECIAL NEED-NEWLINE INDENTATION)) (WHEN NEED-NEWLINE (PPRINT-NEWLINE+ :MANDATORY XP)) (COND ((AND ITEM (SYMBOLP ITEM)) (WRITE+ ITEM XP) (SETQ NEED-NEWLINE NIL)) (T (PPRINT-TAB+ :SECTION INDENTATION 0 XP) (WRITE+ ITEM XP) (SETQ NEED-NEWLINE T))))
     [java] ; (DEFUN PROG-PRINT (XP LIST) (LET ((NEED-NEWLINE T) (INDENTATION (1+ (LENGTH (SYMBOL-NAME (CAR LIST)))))) (DECLARE (SPECIAL NEED-NEWLINE INDENTATION)) (FUNCALL (FORMATTER "~:<~W~^ ~:/xp:pprint-fill/~^ ~@{~/xp:maybelab/~^ ~}~:>") XP LIST)))
     [java] ; (DEFUN TAGBODY-PRINT (XP LIST) (LET ((NEED-NEWLINE (AND (CONSP (CDR LIST)) (SYMBOLP (CADR LIST)) (CADR LIST))) (INDENTATION (1+ (LENGTH (SYMBOL-NAME (CAR LIST)))))) (DECLARE (SPECIAL NEED-NEWLINE INDENTATION)) (FUNCALL (FORMATTER "~:<~W~^ ~@{~/xp:maybelab/~^ ~}~:>") XP LIST)))
     [java] ; (DEFUN SETQ-PRINT (XP OBJ) (FUNCALL (FORMATTER "~:<~W~^ ~:I~@_~@{~W~^ ~:_~W~^ ~_~}~:>") XP OBJ))
     [java] ; (DEFUN QUOTE-PRINT (XP LIST) (IF (AND (CONSP (CDR LIST)) (NULL (CDDR LIST))) (FUNCALL (FORMATTER "'~W") XP (CADR LIST)) (PPRINT-FILL XP LIST)))
     [java] ; (DEFUN UP-PRINT (XP LIST) (PRINT-FANCY-FN-CALL XP LIST (QUOTE (0 3 1 1))))
     [java] ; (DEFUN TOKEN-TYPE (TOKEN &AUX STRING) (COND ((NOT (SYMBOLP TOKEN)) :EXPR) ((STRING= (SETQ STRING (STRING TOKEN)) "FINALLY") :FINALLY) ((MEMBER STRING (QUOTE ("IF" "WHEN" "UNLESS")) :TEST (FUNCTION STRING=)) :COND-HEAD) ((MEMBER STRING (QUOTE ("DO" "DOING" "INITIALLY")) :TEST (FUNCTION STRING=)) :LINEAR-HEAD) ((MEMBER STRING (QUOTE ("FOR" "AS" "WITH" "AND" "END" "ELSE" "REPEAT" "NAMED" "WHILE" "UNTIL" "ALWAYS" "NEVER" "THEREIS" "RETURN" "COLLECT" "COLLECTING" "APPEND" "APPENDING" "NCONC" "NCONCING" "COUNT" "COUNTING" "SUM" "SUMMING" "MAXIMIZE" "MAXIMIZING" "MINIMIZE" "MINIMIZING")) :TEST (FUNCTION STRING=)) :BLOCK-HEAD) (T :EXPR)))
     [java] ; (DEFUN PRETTY-LOOP (XP LOOP) (IF (NOT (AND (CONSP (CDR LOOP)) (SYMBOLP (CADR LOOP)))) (FN-CALL XP LOOP) (PPRINT-LOGICAL-BLOCK (XP LOOP :PREFIX "(" :SUFFIX ")") (LET (TOKEN TYPE) (LABELS ((NEXT-TOKEN NIL (PPRINT-EXIT-IF-LIST-EXHAUSTED) (SETQ TOKEN (PPRINT-POP)) (SETQ TYPE (TOKEN-TYPE TOKEN))) (PRINT-CLAUSE (XP) (CASE TYPE (:LINEAR-HEAD (PRINT-EXPRS XP NIL :MANDATORY)) (:COND-HEAD (PRINT-COND XP)) (:FINALLY (PRINT-EXPRS XP T :MANDATORY)) (OTHERWISE (PRINT-EXPRS XP NIL :FILL)))) (PRINT-EXPRS (XP SKIP-FIRST-NON-EXPR NEWLINE-TYPE) (LET ((FIRST TOKEN)) (NEXT-TOKEN) (PPRINT-LOGICAL-BLOCK (XP NIL) (WRITE FIRST :STREAM XP) (WHEN (AND SKIP-FIRST-NON-EXPR (NOT (EQ TYPE :EXPR))) (WRITE-CHAR #\  XP) (WRITE TOKEN :STREAM XP) (NEXT-TOKEN)) (WHEN (EQ TYPE :EXPR) (WRITE-CHAR #\  XP) (PPRINT-INDENT :CURRENT 0 XP) (LOOP (WRITE TOKEN :STREAM XP) (NEXT-TOKEN) (WHEN (NOT (EQ TYPE :EXPR)) (RETURN NIL)) (WRITE-CHAR #\  XP) (PPRINT-NEWLINE NEWLINE-TYPE XP)))))) (PRINT-COND (XP) (LET ((FIRST TOKEN)) (NEXT-TOKEN) (PPRINT-LOGICAL-BLOCK (XP NIL) (WRITE FIRST :STREAM XP) (WHEN (EQ TYPE :EXPR) (WRITE-CHAR #\  XP) (WRITE TOKEN :STREAM XP) (NEXT-TOKEN)) (WRITE-CHAR #\  XP) (PPRINT-INDENT :BLOCK 2 XP) (PPRINT-NEWLINE :LINEAR XP) (PRINT-CLAUSE XP) (PRINT-AND-LIST XP) (WHEN (AND (SYMBOLP TOKEN) (STRING= (STRING TOKEN) "ELSE")) (PRINT-ELSE-OR-END XP) (WRITE-CHAR #\  XP) (PPRINT-NEWLINE :LINEAR XP) (PRINT-CLAUSE XP) (PRINT-AND-LIST XP)) (WHEN (AND (SYMBOLP TOKEN) (STRING= (STRING TOKEN) "END")) (PRINT-ELSE-OR-END XP))))) (PRINT-AND-LIST (XP) (LOOP (WHEN (NOT (AND (SYMBOLP TOKEN) (STRING= (STRING TOKEN) "AND"))) (RETURN NIL)) (WRITE-CHAR #\  XP) (PPRINT-NEWLINE :MANDATORY XP) (WRITE TOKEN :STREAM XP) (NEXT-TOKEN) (WRITE-CHAR #\  XP) (PRINT-CLAUSE XP))) (PRINT-ELSE-OR-END (XP) (WRITE-CHAR #\  XP) (PPRINT-INDENT :BLOCK 0 XP) (PPRINT-NEWLINE :LINEAR XP) (WRITE TOKEN :STREAM XP) (NEXT-TOKEN) (PPRINT-INDENT :BLOCK 2 XP))) (PPRINT-EXIT-IF-LIST-EXHAUSTED) (WRITE (PPRINT-POP) :STREAM XP) (NEXT-TOKEN) (WRITE-CHAR #\  XP) (PPRINT-INDENT :CURRENT 0 XP) (LOOP (PRINT-CLAUSE XP) (WRITE-CHAR #\  XP) (PPRINT-NEWLINE :LINEAR XP)))))))
     [java] ; (DEFUN OUTPUT-PRETTY-OBJECT (OBJECT STREAM) (COND ((XP-STRUCTURE-P STREAM) (WRITE+ OBJECT STREAM)) (*PRINT-PRETTY* (MAYBE-INITIATE-XP-PRINTING OBJECT (FUNCTION (LAMBDA (S O) (WRITE+ O S))) STREAM OBJECT)) (T (ASSERT NIL) (SYSTEM:OUTPUT-OBJECT OBJECT STREAM))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint.abcl (6.535 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pprint.abcl (1.469 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/format.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE FORMAT)) (FUNCTION %FORMAT))
     [java] ; (DEFUN SYMBOLICATE (&REST THINGS) (LET ((NAME (APPLY (FUNCTION CONCATENATE) (QUOTE STRING) (MAPCAR (FUNCTION STRING) THINGS)))) (VALUES (INTERN NAME))))
     [java] ; (DEFUN PROPER-LIST-OF-LENGTH-P (X MIN &OPTIONAL (MAX MIN)) (COND ((MINUSP MAX) NIL) ((NULL X) (ZEROP MIN)) ((CONSP X) (AND (PLUSP MAX) (PROPER-LIST-OF-LENGTH-P (CDR X) (IF (PLUSP (1- MIN)) (1- MIN) 0) (1- MAX)))) (T NIL)))
     [java] ; (DEFCONSTANT FORM-FEED-CHAR-CODE 12)
     [java] ; (DEFMACRO NAMED-LET (NAME BINDS &BODY BODY) (DOLIST (X BINDS) (UNLESS (PROPER-LIST-OF-LENGTH-P X 2) (ERROR "malformed NAMED-LET variable spec: ~S" X))) (BACKQ-LIST (QUOTE LABELS) (BACKQ-LIST (BACKQ-LIST* NAME (MAPCAR (FUNCTION FIRST) BINDS) BODY)) (BACKQ-CONS NAME (MAPCAR (FUNCTION SECOND) BINDS))))
     [java] ; (DEFMACRO ONCE-ONLY (SPECS &BODY BODY) (NAMED-LET FROB ((SPECS SPECS) (BODY BODY)) (IF (NULL SPECS) (BACKQ-CONS (QUOTE PROGN) BODY) (LET ((SPEC (FIRST SPECS))) (UNLESS (PROPER-LIST-OF-LENGTH-P SPEC 2) (ERROR "malformed ONCE-ONLY binding spec: ~S" SPEC)) (LET* ((NAME (FIRST SPEC)) (EXP-TEMP (GENSYM (SYMBOL-NAME NAME)))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST EXP-TEMP (SECOND SPEC)) (BACKQ-CONS NAME (QUOTE ((GENSYM "ONCE-ONLY-"))))) (BACKQ-LIST (QUOTE BACKQ-LIST) (QUOTE (QUOTE LET)) (BACKQ-LIST (QUOTE BACKQ-LIST) (BACKQ-LIST (QUOTE BACKQ-LIST) NAME EXP-TEMP)) (FROB (REST SPECS) BODY))))))))
     [java] ; (DEFPARAMETER *DIGITS* "0123456789")
     [java] ; (DEFUN FLOAT-TO-DIGITS* (DIGITS NUMBER POSITION RELATIVEP) "Does what float-to-digits, but also detects if result is zero." (MULTIPLE-VALUE-BIND (EXP STRING) (FLOAT-TO-DIGITS DIGITS NUMBER POSITION RELATIVEP) (VALUES EXP STRING (AND POSITION (< EXP (- (ABS POSITION)))))))
     [java] ; (DEFUN FLONUM-TO-STRING-OLD (X &OPTIONAL WIDTH FDIGITS (SCALE 0) (FMIN 0)) (DECLARE (TYPE FLOAT X)) (IF (ZEROP X) (COND ((NULL FDIGITS) (VALUES ".0" 2 T NIL 0)) ((ZEROP FDIGITS) (VALUES "0." 2 NIL T 1)) (T (LET ((S (MAKE-STRING (1+ FDIGITS) :INITIAL-ELEMENT #\0))) (SETF (SCHAR S 0) #\.) (VALUES S (LENGTH S) T NIL 0)))) (MULTIPLE-VALUE-BIND (E STRING ZERO?) (COND (FDIGITS (FLOAT-TO-DIGITS* NIL X (MIN (- (+ FDIGITS SCALE)) (- FMIN)) NIL)) ((NULL WIDTH) (FLOAT-TO-DIGITS* NIL X NIL NIL)) (T (WHEN (NULL SCALE) (SETQ SCALE -1)) (LET ((W (MULTIPLE-VALUE-LIST (FLOAT-TO-DIGITS* NIL X (MAX 0 (+ (- WIDTH 2) (IF (MINUSP SCALE) SCALE 0))) T))) (F (MULTIPLE-VALUE-LIST (FLOAT-TO-DIGITS* NIL X (- (+ FMIN SCALE)) NIL)))) (IF (>= (LENGTH (CADR W)) (LENGTH (CADR F))) (VALUES-LIST W) (VALUES-LIST F))))) (LET* ((EXP (+ E SCALE)) (STREAM (MAKE-STRING-OUTPUT-STREAM)) (LENGTH (LENGTH STRING))) (WHEN (PLUSP EXP) (WRITE-STRING STRING STREAM :END (MIN LENGTH EXP)) (DOTIMES (I (- EXP LENGTH)) (WRITE-CHAR #\0 STREAM))) (WRITE-CHAR #\. STREAM) (COND ((AND ZERO? FDIGITS) (DOTIMES (I FDIGITS) (WRITE-CHAR #\0 STREAM))) (FDIGITS (LET ((CHARACTERS-USED 0)) (DOTIMES (I (MIN (- EXP) FDIGITS)) (INCF CHARACTERS-USED) (WRITE-CHAR #\0 STREAM)) (LET* ((START (MAX 0 (MIN LENGTH EXP))) (END (MAX START (MIN LENGTH (+ START (- FDIGITS CHARACTERS-USED)))))) (WRITE-STRING STRING STREAM :START START :END END) (INCF CHARACTERS-USED (- END START)) (DOTIMES (I (- FDIGITS CHARACTERS-USED)) (WRITE-CHAR #\0 STREAM))))) (ZERO? (WRITE-CHAR #\0 STREAM)) (T (DOTIMES (I (- EXP)) (WRITE-CHAR #\0 STREAM)) (LET ((START (MAX 0 (MIN LENGTH EXP)))) (WRITE-STRING STRING STREAM :START START)))) (LET* ((STRING (GET-OUTPUT-STREAM-STRING STREAM)) (LENGTH (LENGTH STRING)) (POSITION (POSITION #\. STRING))) (VALUES STRING LENGTH (= POSITION 0) (= POSITION (1- LENGTH)) POSITION))))))
     [java] ; (DEFUN SCALE-EXPONENT (ORIGINAL-X) (DECLARE (OPTIMIZE (DEBUG 0) (SAFETY 0))) (LET* ((X (COERCE ORIGINAL-X (QUOTE LONG-FLOAT))) (DELTA 0)) (DECLARE (LONG-FLOAT X) (FIXNUM DELTA)) (MULTIPLE-VALUE-BIND (SIG EXPONENT) (DECODE-FLOAT X) (DECLARE (IGNORE SIG) (FIXNUM EXPONENT) (LONG-FLOAT SIG)) (WHEN (ZEROP X) (RETURN-FROM SCALE-EXPONENT (VALUES (FLOAT 0.0d0 ORIGINAL-X) 1))) (WHEN (AND (MINUSP EXPONENT) (< LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT X LEAST-POSITIVE-NORMALIZED-LONG-FLOAT)) (SETF X (* X 1.0d16) DELTA -16)) (LET ((EX (- (ROUND (* EXPONENT 0.3010299956639812d0)) DELTA))) (DECLARE (FIXNUM EX)) (IF (MINUSP EX) (LOOP FOR Y OF-TYPE LONG-FLOAT = (* X (THE LONG-FLOAT (EXPT 10.0d0 (- EX)))) WHILE (< Y 0.1d0) DO (DECF EX) FINALLY (RETURN (VALUES Y (THE FIXNUM (+ DELTA EX))))) (LOOP FOR Y OF-TYPE LONG-FLOAT = (/ X (THE LONG-FLOAT (EXPT 10.0d0 EX))) WHILE (>= Y 1.0d0) DO (INCF EX) FINALLY (RETURN (VALUES Y (THE FIXNUM (+ DELTA EX))))))))))
     [java] ; (DEFUN FLONUM-TO-STRING-OLD (X &OPTIONAL WIDTH FDIGITS SCALE FMIN) (DECLARE (IGNORE FMIN)) (COND ((ZEROP X) (IF FDIGITS (LET ((S (MAKE-STRING (1+ FDIGITS) :INITIAL-ELEMENT #\0))) (SETF (SCHAR S 0) #\.) (VALUES S (LENGTH S) T (ZEROP FDIGITS) 0)) (VALUES "." 1 T T 0))) (T (WHEN SCALE (SETF X (* X (EXPT 10 SCALE)))) (LET* ((S (FLOAT-STRING X)) (LENGTH (LENGTH S)) (INDEX (POSITION #\. S))) (WHEN (AND (< X 1) (> LENGTH 0) (EQL (SCHAR S 0) #\0)) (SETF S (SUBSEQ S 1) LENGTH (LENGTH S) INDEX (POSITION #\. S))) (WHEN FDIGITS (LET ((ACTUAL-FDIGITS (- LENGTH INDEX 1))) (COND ((< ACTUAL-FDIGITS FDIGITS) (SETF S (CONCATENATE (QUOTE STRING) S (MAKE-STRING (- FDIGITS ACTUAL-FDIGITS) :INITIAL-ELEMENT #\0)) LENGTH (LENGTH S))) ((> ACTUAL-FDIGITS FDIGITS) (LET* ((DESIRED-LENGTH (+ INDEX 1 FDIGITS)) (C (SCHAR S DESIRED-LENGTH))) (SETF S (SUBSEQ S 0 (+ INDEX 1 FDIGITS)) LENGTH (LENGTH S) INDEX (POSITION #\. S)) (WHEN (CHAR>= C #\5) (SETF S (ROUND-UP S) LENGTH (LENGTH S) INDEX (POSITION #\. S)))))))) (WHEN (AND WIDTH (> LENGTH WIDTH)) (LET ((MINIMUM-WIDTH (+ (1+ INDEX) (OR FDIGITS 0)))) (WHEN (< MINIMUM-WIDTH WIDTH) (SETF MINIMUM-WIDTH WIDTH)) (WHEN (> LENGTH MINIMUM-WIDTH) (WHEN (EVERY (FUNCTION DIGIT-CHAR-P) (SUBSEQ S (1+ INDEX))) (LET ((C (SCHAR S MINIMUM-WIDTH))) (SETF S (SUBSEQ S 0 MINIMUM-WIDTH) LENGTH MINIMUM-WIDTH) (WHEN (CHAR>= C #\5) (SETF S (ROUND-UP S) LENGTH (LENGTH S) INDEX (POSITION #\. S)))))))) (VALUES S LENGTH (EQL INDEX 0) (EQL INDEX (1- LENGTH)) INDEX)))))
     [java] ; (DEFUN ROUND-UP (STRING) (LET* ((INDEX (POSITION #\. STRING)) (N (READ-FROM-STRING (SETF STRING (REMOVE #\. STRING)))) (S (PRINC-TO-STRING (INCF N)))) (LOOP FOR CHAR ACROSS STRING WHILE (EQUAL CHAR #\0) DO (SETF S (CONCATENATE (QUOTE STRING) "0" S))) (COND ((NULL INDEX) S) (T (WHEN (> (LENGTH S) (LENGTH STRING)) (SETF S (SUBSEQ S 0 (1- (LENGTH S)))) (INCF INDEX)) (CONCATENATE (QUOTE STRING) (SUBSEQ S 0 INDEX) "." (SUBSEQ S INDEX))))))
     [java] ; (DEFUN SCALE-EXPONENT-OLD (ORIGINAL-X) (LET* ((X (COERCE ORIGINAL-X (QUOTE LONG-FLOAT)))) (MULTIPLE-VALUE-BIND (SIG EXPONENT) (DECODE-FLOAT X) (DECLARE (IGNORE SIG)) (IF (= X 0.0d0) (VALUES (FLOAT 0.0d0 ORIGINAL-X) 1) (LET* ((EX (LOCALLY (DECLARE (OPTIMIZE (SAFETY 0))) (THE FIXNUM (ROUND (* EXPONENT (LOG 2.0d0 10)))))) (X (IF (MINUSP EX) (IF (FLOAT-DENORMALIZED-P X) (* X 1.0d16 (EXPT 10.0d0 (- (- EX) 16))) (* X 10.0d0 (EXPT 10.0d0 (- (- EX) 1)))) (/ X 10.0d0 (EXPT 10.0d0 (1- EX)))))) (DO ((D 10.0d0 (* D 10.0d0)) (Y X (/ X D)) (EX EX (1+ EX))) ((< Y 1.0d0) (DO ((M 10.0d0 (* M 10.0d0)) (Z Y (* Y M)) (EX EX (1- EX))) ((>= Z 0.1d0) (VALUES (FLOAT Z ORIGINAL-X) EX)) (DECLARE (LONG-FLOAT M) (INTEGER EX)))) (DECLARE (LONG-FLOAT D))))))))
     [java] ; (DEFCONSTANT DOUBLE-FLOAT-EXPONENT-BYTE (BYTE 11 20))
     [java] ; (DEFUN FLOAT-DENORMALIZED-P (X) "Return true if the double-float X is denormalized." (AND (ZEROP (LDB DOUBLE-FLOAT-EXPONENT-BYTE (DOUBLE-FLOAT-HIGH-BITS X))) (NOT (ZEROP X))))
     [java] ; (DEFUN FLOAT-TO-DIGITS-OLD (F E P CUTOFF-MODE CUTOFF-PLACE) (WHEN (ZEROP F) (RETURN-FROM FLOAT-TO-DIGITS-OLD (VALUES (QUOTE (0)) 0))) (LET* ((ROUND-UP-P NIL) (R (ASH F (MAX (- E P) 0))) (S (ASH 1 (MAX 0 (- P E)))) (M- (ASH 1 (MAX 0 (- E P)))) (M+ M-) (K 0)) (WHEN (= F (ASH 1 (1- P))) (SETQ M+ (ASH M+ 1)) (SETQ R (ASH R 1)) (SETQ S (ASH S 1))) (LET ((S/B (CEILING S 10))) (LOOP (UNLESS (< R S/B) (RETURN)) (DECF K) (SETQ R (* R 10)) (SETQ M- (* M- 10)) (SETQ M+ (* M+ 10)))) (LOOP (LOOP (UNLESS (>= (+ (* 2 R) M+) (* 2 S)) (RETURN)) (SETQ S (* S 10)) (INCF K)) (ECASE CUTOFF-MODE ((:ABSOLUTE)) ((:NORMAL) (SETQ CUTOFF-PLACE K)) ((:RELATIVE) (INCF CUTOFF-PLACE K)) ((:VARIABLE) (SETQ CUTOFF-PLACE (IF (MINUSP K) (- 1 CUTOFF-PLACE) (1+ (- K CUTOFF-PLACE)))))) (WHEN (OR (EQ CUTOFF-MODE :RELATIVE) (EQ CUTOFF-MODE :ABSOLUTE)) (LET ((A (- CUTOFF-PLACE K)) (Y S)) (IF (>= A 0) (DOTIMES (J A) (SETQ Y (* Y 10))) (DOTIMES (J (- A)) (SETQ Y (CEILING Y 10)))) (SETQ M- (MAX Y M-)) (SETQ M+ (MAX Y M+)) (IF (= M+ Y) (SETQ ROUND-UP-P T)))) (UNLESS (>= (+ (* 2 R) M+) (* 2 S)) (RETURN))) (LET ((RESULT (QUOTE NIL)) (EXPT (1- K)) LOW-P HIGH-P U) (LOOP (DECF K) (MULTIPLE-VALUE-SETQ (U R) (FLOOR (* R 10) S)) (SETQ M- (* M- 10)) (SETQ M+ (* M+ 10)) (SETQ LOW-P (< (* 2 R) M-)) (SETQ HIGH-P (IF ROUND-UP-P (>= (* 2 R) (- (* 2 S) M+)) (> (* 2 R) (- (* 2 S) M+)))) (UNLESS (AND (NOT LOW-P) (NOT HIGH-P) (/= K CUTOFF-PLACE)) (RETURN)) (PUSH U RESULT)) (PUSH (COND ((AND LOW-P (NOT HIGH-P)) U) ((AND HIGH-P (NOT LOW-P)) (1+ U)) ((<= (* 2 R) S) U) (T (1+ U))) RESULT) (VALUES (NREVERSE RESULT) EXPT))))
     [java] ; (DEFUN FLOAT-TO-DIGITS (F E MIN-E P) (LABELS ((GENERATE (R S M+ M- LOW-OK? HIGH-OK?) (MULTIPLE-VALUE-BIND (D R) (TRUNCATE (* R 10) S) (LET* ((M+ (* M+ 10)) (M- (* M- 10)) (TC1 (IF LOW-OK? (<= R M-) (< R M-))) (TC2 (IF HIGH-OK? (>= (+ R M+) S) (> (+ R M+) S)))) (IF (NOT TC1) (IF (NOT TC2) (CONS D (GENERATE R S M+ M- LOW-OK? HIGH-OK?)) (LIST (+ D 1))) (IF (NOT TC2) (LIST D) (IF (< (* R 2) S) (LIST D) (LIST (+ D 1)))))))) (SCALE (R S M+ M- K LOW-OK? HIGH-OK?) (COND ((IF HIGH-OK? (>= (+ R M+) S) (> (+ R M+) S)) (SCALE R (* S 10) M+ M- (+ K 1) LOW-OK? HIGH-OK?)) ((IF HIGH-OK? (< (* (+ R M+) 10) S) (<= (* (+ R M+) 10) S)) (SCALE (* R 10) S (* M+ 10) (* M- 10) (- K 1) LOW-OK? HIGH-OK?)) (T (VALUES (GENERATE R S M+ M- LOW-OK? HIGH-OK?) K))))) (LET ((ROUND? (ZEROP (MOD F 2)))) (IF (>= E 0) (IF (NOT (= F (EXPT 2 (- P 1)))) (LET ((BE (EXPT 2 E))) (SCALE (* F BE 2) 2 BE BE 0 ROUND? ROUND?)) (LET* ((BE (EXPT 2 E)) (BE1 (* BE 2))) (SCALE (* F BE1 2) (* 2 2) BE1 BE 0 ROUND? ROUND?))) (IF (OR (= E MIN-E) (NOT (= F (EXPT 2 (- P 1))))) (SCALE (* F 2) (* (EXPT 2 (- E)) 2) 1 1 0 ROUND? ROUND?) (SCALE (* F 4) (* (EXPT 2 (- 1 E)) 2) 2 1 0 ROUND? ROUND?))))))
     [java] ; (IN-PACKAGE #:FORMAT)
     [java] ; (DEFPARAMETER *FORMAT-WHITESPACE-CHARS* (VECTOR #\  #\Newline #\Tab))
     [java] ; (DEFVAR *FORMAT-DIRECTIVE-EXPANDERS* (MAKE-HASH-TABLE :TEST (FUNCTION EQ)))
     [java] ; (DEFVAR *FORMAT-DIRECTIVE-INTERPRETERS* (MAKE-HASH-TABLE :TEST (FUNCTION EQ)))
     [java] ; (DEFVAR *DEFAULT-FORMAT-ERROR-CONTROL-STRING* NIL)
     [java] ; (DEFVAR *DEFAULT-FORMAT-ERROR-OFFSET* NIL)
     [java] ; (DEFVAR *UP-UP-AND-OUT-ALLOWED* NIL)
     [java] ; (DECLAIM (TYPE (OR NULL FUNCTION) *LOGICAL-BLOCK-POPPER*))
     [java] ; (DEFVAR *LOGICAL-BLOCK-POPPER* NIL)
     [java] ; (DEFVAR *EXPANDER-NEXT-ARG-MACRO* (QUOTE EXPANDER-NEXT-ARG))
     [java] ; (DEFVAR *ONLY-SIMPLE-ARGS*)
     [java] ; (DEFVAR *ORIG-ARGS-AVAILABLE* NIL)
     [java] ; (DEFVAR *SIMPLE-ARGS*)
     [java] ; (IN-PACKAGE #:FORMAT)
     [java] ; (DEFINE-CONDITION FORMAT-ERROR (ERROR) ((COMPLAINT :READER FORMAT-ERROR-COMPLAINT :INITARG :COMPLAINT) (ARGS :READER FORMAT-ERROR-ARGS :INITARG :ARGS :INITFORM NIL) (CONTROL-STRING :READER FORMAT-ERROR-CONTROL-STRING :INITARG :CONTROL-STRING :INITFORM *DEFAULT-FORMAT-ERROR-CONTROL-STRING*) (OFFSET :READER FORMAT-ERROR-OFFSET :INITARG :OFFSET :INITFORM *DEFAULT-FORMAT-ERROR-OFFSET*) (PRINT-BANNER :READER FORMAT-ERROR-PRINT-BANNER :INITARG :PRINT-BANNER :INITFORM T)) (:REPORT %PRINT-FORMAT-ERROR))
     [java] ; (DEFUN %PRINT-FORMAT-ERROR (CONDITION STREAM) (FORMAT STREAM "~:[~;error in format: ~]~
     [java]            ~?~@[~%  ~A~%  ~V@T^~]" (FORMAT-ERROR-PRINT-BANNER CONDITION) (FORMAT-ERROR-COMPLAINT CONDITION) (FORMAT-ERROR-ARGS CONDITION) (FORMAT-ERROR-CONTROL-STRING CONDITION) (FORMAT-ERROR-OFFSET CONDITION)))
     [java] ; (DEFUN MISSING-ARG NIL (ERROR "Missing argument in format directive"))
     [java] ; (DEFSTRUCT FORMAT-DIRECTIVE (STRING (MISSING-ARG) :TYPE SIMPLE-STRING) (START (MISSING-ARG) :TYPE (AND UNSIGNED-BYTE FIXNUM)) (END (MISSING-ARG) :TYPE (AND UNSIGNED-BYTE FIXNUM)) (CHARACTER (MISSING-ARG) :TYPE BASE-CHAR) (COLONP NIL :TYPE (MEMBER T NIL)) (ATSIGNP NIL :TYPE (MEMBER T NIL)) (PARAMS NIL :TYPE LIST))
     [java] ; (DEFMETHOD PRINT-OBJECT ((X FORMAT-DIRECTIVE) STREAM) (PRINT-UNREADABLE-OBJECT (X STREAM) (WRITE-STRING (FORMAT-DIRECTIVE-STRING X) STREAM :START (FORMAT-DIRECTIVE-START X) :END (FORMAT-DIRECTIVE-END X))))
     [java] ; (DEFUN TOKENIZE-CONTROL-STRING (STRING) (DECLARE (SIMPLE-STRING STRING)) (LET ((INDEX 0) (END (LENGTH STRING)) (RESULT NIL) (IN-BLOCK NIL) (PPRINT NIL) (SEMI NIL) (JUSTIFICATION-SEMI 0)) (DECLARE (TYPE INDEX FIXNUM)) (LOOP (LET ((NEXT-DIRECTIVE (OR (POSITION #\~ STRING :START INDEX) END))) (DECLARE (TYPE INDEX NEXT-DIRECTIVE)) (WHEN (> NEXT-DIRECTIVE INDEX) (PUSH (SUBSEQ STRING INDEX NEXT-DIRECTIVE) RESULT)) (WHEN (= NEXT-DIRECTIVE END) (RETURN)) (LET* ((DIRECTIVE (PARSE-DIRECTIVE STRING NEXT-DIRECTIVE)) (DIRECTIVE-CHAR (FORMAT-DIRECTIVE-CHARACTER DIRECTIVE))) (DECLARE (TYPE CHARACTER DIRECTIVE-CHAR)) (COND ((CHAR= #\< DIRECTIVE-CHAR) (SETF IN-BLOCK T)) ((AND IN-BLOCK (CHAR= #\; DIRECTIVE-CHAR)) (SETF SEMI T)) ((CHAR= #\> DIRECTIVE-CHAR) (SETF IN-BLOCK NIL) (COND ((FORMAT-DIRECTIVE-COLONP DIRECTIVE) (SETF PPRINT T) (SETF SEMI NIL)) (SEMI (INCF JUSTIFICATION-SEMI)))) ((AND (NOT IN-BLOCK) (OR (AND (CHAR= #\T DIRECTIVE-CHAR) (FORMAT-DIRECTIVE-COLONP DIRECTIVE)) (CHAR= #\W DIRECTIVE-CHAR) (CHAR= #\_ DIRECTIVE-CHAR) (CHAR= #\I DIRECTIVE-CHAR))) (SETF PPRINT T))) (PUSH DIRECTIVE RESULT) (SETF INDEX (FORMAT-DIRECTIVE-END DIRECTIVE))))) (WHEN (AND PPRINT (PLUSP JUSTIFICATION-SEMI)) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "A justification directive cannot be in the same format string~%~
     [java]              as ~~W, ~~I, ~~:T, or a logical-block directive." :CONTROL-STRING STRING :OFFSET 0)) (NREVERSE RESULT)))
     [java] ; (DEFUN PARSE-DIRECTIVE (STRING START) (LET ((POSN (1+ START)) (PARAMS NIL) (COLONP NIL) (ATSIGNP NIL) (END (LENGTH STRING))) (FLET ((GET-CHAR NIL (IF (= POSN END) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "String ended before directive was found." :CONTROL-STRING STRING :OFFSET START) (SCHAR STRING POSN))) (CHECK-ORDERING NIL (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "parameters found after #\\: or #\\@ modifier" :CONTROL-STRING STRING :OFFSET POSN)))) (LOOP (LET ((CHAR (GET-CHAR))) (COND ((OR (CHAR<= #\0 CHAR #\9) (CHAR= CHAR #\+) (CHAR= CHAR #\-)) (CHECK-ORDERING) (MULTIPLE-VALUE-BIND (PARAM NEW-POSN) (PARSE-INTEGER STRING :START POSN :JUNK-ALLOWED T) (PUSH (CONS POSN PARAM) PARAMS) (SETF POSN NEW-POSN) (CASE (GET-CHAR) (#\,) ((#\: #\@) (DECF POSN)) (T (RETURN))))) ((OR (CHAR= CHAR #\v) (CHAR= CHAR #\V)) (CHECK-ORDERING) (PUSH (CONS POSN :ARG) PARAMS) (INCF POSN) (CASE (GET-CHAR) (#\,) ((#\: #\@) (DECF POSN)) (T (RETURN)))) ((CHAR= CHAR #\#) (CHECK-ORDERING) (PUSH (CONS POSN :REMAINING) PARAMS) (INCF POSN) (CASE (GET-CHAR) (#\,) ((#\: #\@) (DECF POSN)) (T (RETURN)))) ((CHAR= CHAR #\') (CHECK-ORDERING) (INCF POSN) (PUSH (CONS POSN (GET-CHAR)) PARAMS) (INCF POSN) (UNLESS (CHAR= (GET-CHAR) #\,) (DECF POSN))) ((CHAR= CHAR #\,) (CHECK-ORDERING) (PUSH (CONS POSN NIL) PARAMS)) ((CHAR= CHAR #\:) (IF COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "too many colons supplied" :CONTROL-STRING STRING :OFFSET POSN) (SETF COLONP T))) ((CHAR= CHAR #\@) (IF ATSIGNP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "too many #\\@ characters supplied" :CONTROL-STRING STRING :OFFSET POSN) (SETF ATSIGNP T))) (T (WHEN (AND (CHAR= (SCHAR STRING (1- POSN)) #\,) (OR (< POSN 2) (CHAR/= (SCHAR STRING (- POSN 2)) #\'))) (CHECK-ORDERING) (PUSH (CONS (1- POSN) NIL) PARAMS)) (RETURN)))) (INCF POSN)) (LET ((CHAR (GET-CHAR))) (WHEN (CHAR= CHAR #\/) (LET ((CLOSING-SLASH (POSITION #\/ STRING :START (1+ POSN)))) (IF CLOSING-SLASH (SETF POSN CLOSING-SLASH) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no matching closing slash" :CONTROL-STRING STRING :OFFSET POSN)))) (MAKE-FORMAT-DIRECTIVE :STRING STRING :START START :END (1+ POSN) :CHARACTER (CHAR-UPCASE CHAR) :COLONP COLONP :ATSIGNP ATSIGNP :PARAMS (NREVERSE PARAMS))))))
     [java] ; (DEFMACRO FORMATTER (CONTROL-STRING) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) (%FORMATTER CONTROL-STRING)))
     [java] ; (DEFUN %FORMATTER (CONTROL-STRING) (BLOCK NIL (CATCH (QUOTE NEED-ORIG-ARGS) (LET* ((*SIMPLE-ARGS* NIL) (*ONLY-SIMPLE-ARGS* T) (GUTS (EXPAND-CONTROL-STRING CONTROL-STRING)) (ARGS NIL)) (DOLIST (ARG *SIMPLE-ARGS*) (PUSH (SYSTEM::BACKQ-LIST (CAR ARG) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "required argument missing" (QUOTE :CONTROL-STRING) CONTROL-STRING (QUOTE :OFFSET) (CDR ARG))) ARGS)) (RETURN (SYSTEM::BACKQ-LIST* (QUOTE LAMBDA) (SYSTEM::BACKQ-LIST* (QUOTE STREAM) (QUOTE &OPTIONAL) (SYSTEM::BACKQ-APPEND ARGS (QUOTE (&REST ARGS)))) GUTS (QUOTE (ARGS)))))) (LET ((*ORIG-ARGS-AVAILABLE* T) (*ONLY-SIMPLE-ARGS* NIL)) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (STREAM &REST ORIG-ARGS)) (SYSTEM::BACKQ-LIST* (QUOTE LET) (QUOTE ((ARGS ORIG-ARGS))) (EXPAND-CONTROL-STRING CONTROL-STRING) (QUOTE (ARGS)))))))
     [java] ; (DEFUN EXPAND-CONTROL-STRING (STRING) (LET* ((STRING (ETYPECASE STRING (SIMPLE-STRING STRING) (STRING (COERCE STRING (QUOTE SIMPLE-STRING))))) (*DEFAULT-FORMAT-ERROR-CONTROL-STRING* STRING) (DIRECTIVES (TOKENIZE-CONTROL-STRING STRING))) (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NIL (EXPAND-DIRECTIVE-LIST DIRECTIVES))))
     [java] ; (DEFUN EXPAND-DIRECTIVE-LIST (DIRECTIVES) (LET ((RESULTS NIL) (REMAINING-DIRECTIVES DIRECTIVES)) (LOOP (UNLESS REMAINING-DIRECTIVES (RETURN)) (MULTIPLE-VALUE-BIND (FORM NEW-DIRECTIVES) (EXPAND-DIRECTIVE (CAR REMAINING-DIRECTIVES) (CDR REMAINING-DIRECTIVES)) (PUSH FORM RESULTS) (SETF REMAINING-DIRECTIVES NEW-DIRECTIVES))) (REVERSE RESULTS)))
     [java] ; (DEFUN EXPAND-DIRECTIVE (DIRECTIVE MORE-DIRECTIVES) (ETYPECASE DIRECTIVE (FORMAT-DIRECTIVE (LET ((EXPANDER (GETHASH (FORMAT-DIRECTIVE-CHARACTER DIRECTIVE) *FORMAT-DIRECTIVE-EXPANDERS*)) (*DEFAULT-FORMAT-ERROR-OFFSET* (1- (FORMAT-DIRECTIVE-END DIRECTIVE)))) (DECLARE (TYPE (OR NULL FUNCTION) EXPANDER)) (IF EXPANDER (FUNCALL EXPANDER DIRECTIVE MORE-DIRECTIVES) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "unknown directive ~@[(character: ~A)~]" :ARGS (LIST (CHAR-NAME (FORMAT-DIRECTIVE-CHARACTER DIRECTIVE))))))) (SIMPLE-STRING (VALUES (SYSTEM::BACKQ-LIST* (QUOTE WRITE-STRING) DIRECTIVE (QUOTE (STREAM))) MORE-DIRECTIVES))))
     [java] ; (DEFMACRO EXPANDER-NEXT-ARG (STRING OFFSET) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE ARGS) (QUOTE (POP ARGS)) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "no more arguments" (QUOTE :CONTROL-STRING) STRING (QUOTE :OFFSET) OFFSET)))
     [java] ; (DEFUN EXPAND-NEXT-ARG (&OPTIONAL OFFSET) (IF (OR *ORIG-ARGS-AVAILABLE* (NOT *ONLY-SIMPLE-ARGS*)) (SYSTEM::BACKQ-LIST *EXPANDER-NEXT-ARG-MACRO* *DEFAULT-FORMAT-ERROR-CONTROL-STRING* (OR OFFSET *DEFAULT-FORMAT-ERROR-OFFSET*)) (LET ((SYMBOL (GENSYM "FORMAT-ARG-"))) (PUSH (CONS SYMBOL (OR OFFSET *DEFAULT-FORMAT-ERROR-OFFSET*)) *SIMPLE-ARGS*) SYMBOL)))
     [java] ; (DEFMACRO EXPAND-BIND-DEFAULTS (SPECS PARAMS &BODY BODY) (SYSTEM::ONCE-ONLY ((PARAMS PARAMS)) (IF SPECS (COLLECT ((EXPANDER-BINDINGS) (RUNTIME-BINDINGS)) (DOLIST (SPEC SPECS) (DESTRUCTURING-BIND (VAR DEFAULT) SPEC (LET ((SYMBOL (GENSYM))) (EXPANDER-BINDINGS (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SYMBOL))) (RUNTIME-BINDINGS (SYSTEM::BACKQ-LIST (QUOTE LIST) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SYMBOL) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE PARAM-AND-OFFSET) (SYSTEM::BACKQ-LIST (QUOTE POP) PARAMS)) (QUOTE ((OFFSET (CAR PARAM-AND-OFFSET)) (PARAM (CDR PARAM-AND-OFFSET))))) (SYSTEM::BACKQ-LIST* (QUOTE CASE) (QUOTE PARAM) (SYSTEM::BACKQ-LIST (QUOTE :ARG) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST) (QUOTE (QUOTE OR)) (QUOTE (EXPAND-NEXT-ARG OFFSET)) DEFAULT)) (QUOTE (:REMAINING (SETF *ONLY-SIMPLE-ARGS* NIL) (QUOTE (LENGTH ARGS)))) (SYSTEM::BACKQ-LIST (QUOTE (NIL)) DEFAULT) (QUOTE ((T PARAM)))))))))) (SYSTEM::BACKQ-LIST (QUOTE LET) (EXPANDER-BINDINGS) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE LET)) (SYSTEM::BACKQ-CONS (QUOTE SYSTEM::BACKQ-LIST) (RUNTIME-BINDINGS)) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-APPEND) (SYSTEM::BACKQ-LIST (QUOTE IF) PARAMS (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "too many parameters, expected no more than ~W" (QUOTE :ARGS) (SYSTEM::BACKQ-LIST (QUOTE LIST) (LENGTH SPECS)) (QUOTE :OFFSET) (SYSTEM::BACKQ-LIST (QUOTE CAAR) PARAMS))) (SYSTEM::BACKQ-CONS (QUOTE SYSTEM::BACKQ-LIST) BODY))))) (SYSTEM::BACKQ-LIST* (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE WHEN) PARAMS (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "too many parameters, expected none" (QUOTE :OFFSET) (SYSTEM::BACKQ-LIST (QUOTE CAAR) PARAMS))) BODY))))
     [java] ; (DEFMACRO DEF-COMPLEX-FORMAT-DIRECTIVE (CHAR LAMBDA-LIST &BODY BODY) (LET ((DEFUN-NAME (INTERN (CONCATENATE (QUOTE STRING) (LET ((NAME (CHAR-NAME CHAR))) (COND (NAME (STRING-CAPITALIZE NAME)) (T (STRING CHAR)))) "-FORMAT-DIRECTIVE-EXPANDER"))) (DIRECTIVE (GENSYM)) (DIRECTIVES (IF LAMBDA-LIST (CAR (LAST LAMBDA-LIST)) (GENSYM)))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST* (QUOTE DEFUN) DEFUN-NAME (SYSTEM::BACKQ-LIST DIRECTIVE DIRECTIVES) (IF LAMBDA-LIST (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE LET) (MAPCAR (LAMBDA (VAR) (SYSTEM::BACKQ-LIST VAR (SYSTEM::BACKQ-LIST (SYSTEM::SYMBOLICATE "FORMAT-DIRECTIVE-" VAR) DIRECTIVE))) (BUTLAST LAMBDA-LIST)) BODY)) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE IGNORE) DIRECTIVE DIRECTIVES)) BODY))) (SYSTEM::BACKQ-LIST (QUOTE %SET-FORMAT-DIRECTIVE-EXPANDER) CHAR (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) DEFUN-NAME)))))
     [java] ; (DEFMACRO DEF-FORMAT-DIRECTIVE (CHAR LAMBDA-LIST &BODY BODY) (LET ((DIRECTIVES (GENSYM)) (DECLARATIONS NIL) (BODY-WITHOUT-DECLS BODY)) (LOOP (LET ((FORM (CAR BODY-WITHOUT-DECLS))) (UNLESS (AND (CONSP FORM) (EQ (CAR FORM) (QUOTE DECLARE))) (RETURN)) (PUSH (POP BODY-WITHOUT-DECLS) DECLARATIONS))) (SETF DECLARATIONS (REVERSE DECLARATIONS)) (SYSTEM::BACKQ-LIST* (QUOTE DEF-COMPLEX-FORMAT-DIRECTIVE) CHAR (SYSTEM::BACKQ-APPEND LAMBDA-LIST (SYSTEM::BACKQ-LIST DIRECTIVES)) (SYSTEM::BACKQ-APPEND DECLARATIONS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE VALUES) (SYSTEM::BACKQ-CONS (QUOTE PROGN) BODY-WITHOUT-DECLS) DIRECTIVES))))))
     [java] ; (DEFUN %SET-FORMAT-DIRECTIVE-EXPANDER (CHAR FN) (SETF (GETHASH (CHAR-UPCASE CHAR) *FORMAT-DIRECTIVE-EXPANDERS*) FN) CHAR)
     [java] ; (DEFUN %SET-FORMAT-DIRECTIVE-INTERPRETER (CHAR FN) (SETF (GETHASH (CHAR-UPCASE CHAR) *FORMAT-DIRECTIVE-INTERPRETERS*) FN) CHAR)
     [java] ; (DEFUN FIND-DIRECTIVE (DIRECTIVES KIND STOP-AT-SEMI) (IF DIRECTIVES (LET ((NEXT (CAR DIRECTIVES))) (IF (FORMAT-DIRECTIVE-P NEXT) (LET ((CHAR (FORMAT-DIRECTIVE-CHARACTER NEXT))) (IF (OR (CHAR= KIND CHAR) (AND STOP-AT-SEMI (CHAR= CHAR #\;))) (CAR DIRECTIVES) (FIND-DIRECTIVE (CDR (FLET ((AFTER (CHAR) (MEMBER (FIND-DIRECTIVE (CDR DIRECTIVES) CHAR NIL) DIRECTIVES))) (CASE CHAR (#\( (AFTER #\))) (#\< (AFTER #\>)) (#\[ (AFTER #\])) (#\{ (AFTER #\})) (T DIRECTIVES)))) KIND STOP-AT-SEMI))) (FIND-DIRECTIVE (CDR DIRECTIVES) KIND STOP-AT-SEMI)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\A (COLONP ATSIGNP PARAMS) (IF PARAMS (EXPAND-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINC) (QUOTE STREAM) (EXPAND-NEXT-ARG) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) COLONP) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) ATSIGNP) MINCOL COLINC MINPAD PADCHAR)) (SYSTEM::BACKQ-LIST* (QUOTE PRINC) (IF COLONP (SYSTEM::BACKQ-LIST* (QUOTE OR) (EXPAND-NEXT-ARG) (QUOTE ("()"))) (EXPAND-NEXT-ARG)) (QUOTE (STREAM)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\S (COLONP ATSIGNP PARAMS) (COND (PARAMS (EXPAND-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRIN1) (QUOTE STREAM) (EXPAND-NEXT-ARG) COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR))) (COLONP (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE ARG) (EXPAND-NEXT-ARG))) (QUOTE ((IF ARG (PRIN1 ARG STREAM) (PRINC "()" STREAM)))))) (T (SYSTEM::BACKQ-LIST* (QUOTE PRIN1) (EXPAND-NEXT-ARG) (QUOTE (STREAM))))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\C (COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS NIL PARAMS (IF COLONP (SYSTEM::BACKQ-LIST* (QUOTE FORMAT-PRINT-NAMED-CHARACTER) (EXPAND-NEXT-ARG) (QUOTE (STREAM))) (IF ATSIGNP (SYSTEM::BACKQ-LIST* (QUOTE PRIN1) (EXPAND-NEXT-ARG) (QUOTE (STREAM))) (SYSTEM::BACKQ-LIST* (QUOTE WRITE-CHAR) (EXPAND-NEXT-ARG) (QUOTE (STREAM)))))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\W (COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS NIL PARAMS (IF (OR COLONP ATSIGNP) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-APPEND (WHEN COLONP (QUOTE ((*PRINT-PRETTY* T)))) (WHEN ATSIGNP (QUOTE ((*PRINT-LEVEL* NIL) (*PRINT-LENGTH* NIL))))) (SYSTEM::BACKQ-LIST* (QUOTE SYSTEM:OUTPUT-OBJECT) (EXPAND-NEXT-ARG) (QUOTE (STREAM)))) (SYSTEM::BACKQ-LIST* (QUOTE SYSTEM:OUTPUT-OBJECT) (EXPAND-NEXT-ARG) (QUOTE (STREAM))))))
     [java] ; (DEFUN EXPAND-FORMAT-INTEGER (BASE COLONP ATSIGNP PARAMS) (IF (OR COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS ((MINCOL 0) (PADCHAR #\ ) (COMMACHAR #\,) (COMMAINTERVAL 3)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-INTEGER) (QUOTE STREAM) (EXPAND-NEXT-ARG) COLONP ATSIGNP BASE MINCOL PADCHAR COMMACHAR COMMAINTERVAL)) (SYSTEM::BACKQ-LIST* (QUOTE WRITE) (EXPAND-NEXT-ARG) (QUOTE :STREAM) (QUOTE STREAM) (QUOTE :BASE) BASE (QUOTE (:RADIX NIL :ESCAPE NIL)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\D (COLONP ATSIGNP PARAMS) (EXPAND-FORMAT-INTEGER 10 COLONP ATSIGNP PARAMS))
     [java] ; (DEF-FORMAT-DIRECTIVE #\B (COLONP ATSIGNP PARAMS) (EXPAND-FORMAT-INTEGER 2 COLONP ATSIGNP PARAMS))
     [java] ; (DEF-FORMAT-DIRECTIVE #\O (COLONP ATSIGNP PARAMS) (EXPAND-FORMAT-INTEGER 8 COLONP ATSIGNP PARAMS))
     [java] ; (DEF-FORMAT-DIRECTIVE #\X (COLONP ATSIGNP PARAMS) (EXPAND-FORMAT-INTEGER 16 COLONP ATSIGNP PARAMS))
     [java] ; (DEF-FORMAT-DIRECTIVE #\R (COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS ((BASE NIL) (MINCOL 0) (PADCHAR #\ ) (COMMACHAR #\,) (COMMAINTERVAL 3)) PARAMS (LET ((N-ARG (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST N-ARG (EXPAND-NEXT-ARG))) (SYSTEM::BACKQ-LIST (QUOTE IF) BASE (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-INTEGER) (QUOTE STREAM) N-ARG COLONP ATSIGNP BASE MINCOL PADCHAR COMMACHAR COMMAINTERVAL) (IF ATSIGNP (IF COLONP (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-OLD-ROMAN) (QUOTE STREAM) N-ARG) (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-ROMAN) (QUOTE STREAM) N-ARG)) (IF COLONP (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-ORDINAL) (QUOTE STREAM) N-ARG) (SYSTEM::BACKQ-LIST (QUOTE FORMAT-PRINT-CARDINAL) (QUOTE STREAM) N-ARG))))))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\P (COLONP ATSIGNP PARAMS END) (EXPAND-BIND-DEFAULTS NIL PARAMS (LET ((ARG (COND ((NOT COLONP) (EXPAND-NEXT-ARG)) (*ORIG-ARGS-AVAILABLE* (SYSTEM::BACKQ-LIST* (QUOTE IF) (QUOTE (EQ ORIG-ARGS ARGS)) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "no previous argument" (QUOTE :OFFSET) (1- END)) (QUOTE ((DO ((ARG-PTR ORIG-ARGS (CDR ARG-PTR))) ((EQ (CDR ARG-PTR) ARGS) (CAR ARG-PTR))))))) (*ONLY-SIMPLE-ARGS* (UNLESS *SIMPLE-ARGS* (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no previous argument")) (CAAR *SIMPLE-ARGS*)) (T (THROW (QUOTE NEED-ORIG-ARGS) NIL))))) (IF ATSIGNP (SYSTEM::BACKQ-LIST* (QUOTE WRITE-STRING) (SYSTEM::BACKQ-LIST* (QUOTE IF) (SYSTEM::BACKQ-LIST* (QUOTE EQL) ARG (QUOTE (1))) (QUOTE ("y" "ies"))) (QUOTE (STREAM))) (SYSTEM::BACKQ-LIST* (QUOTE UNLESS) (SYSTEM::BACKQ-LIST* (QUOTE EQL) ARG (QUOTE (1))) (QUOTE ((WRITE-CHAR #\s STREAM))))))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\F (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon modifier cannot be used with this directive.")) (EXPAND-BIND-DEFAULTS ((W NIL) (D NIL) (K NIL) (OVF NIL) (PAD #\ )) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-FIXED) (QUOTE STREAM) (EXPAND-NEXT-ARG) W D K OVF PAD ATSIGNP)))
     [java] ; (DEF-FORMAT-DIRECTIVE #\E (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon modifier cannot be used with this directive.")) (EXPAND-BIND-DEFAULTS ((W NIL) (D NIL) (E NIL) (K 1) (OVF NIL) (PAD #\ ) (MARK NIL)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-EXPONENTIAL) (QUOTE STREAM) (EXPAND-NEXT-ARG) W D E K OVF PAD MARK ATSIGNP)))
     [java] ; (DEF-FORMAT-DIRECTIVE #\G (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon modifier cannot be used with this directive.")) (EXPAND-BIND-DEFAULTS ((W NIL) (D NIL) (E NIL) (K NIL) (OVF NIL) (PAD #\ ) (MARK NIL)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-GENERAL) (QUOTE STREAM) (EXPAND-NEXT-ARG) W D E K OVF PAD MARK ATSIGNP)))
     [java] ; (DEF-FORMAT-DIRECTIVE #\$ (COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS ((D 2) (N 1) (W 0) (PAD #\ )) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-DOLLARS) (QUOTE STREAM) (EXPAND-NEXT-ARG) D N W PAD COLONP ATSIGNP)))
     [java] ; (DEF-FORMAT-DIRECTIVE #\% (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon and atsign modifiers cannot be used with this directive.")) (IF PARAMS (EXPAND-BIND-DEFAULTS ((COUNT 1)) PARAMS (SYSTEM::BACKQ-LIST* (QUOTE DOTIMES) (SYSTEM::BACKQ-LIST (QUOTE I) COUNT) (QUOTE ((TERPRI STREAM))))) (QUOTE (TERPRI STREAM))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\& (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon and atsign modifiers cannot be used with this directive.")) (IF PARAMS (EXPAND-BIND-DEFAULTS ((COUNT 1)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE PROGN) (QUOTE (FRESH-LINE STREAM)) (SYSTEM::BACKQ-LIST* (QUOTE DOTIMES) (SYSTEM::BACKQ-LIST (QUOTE I) (SYSTEM::BACKQ-LIST (QUOTE 1-) COUNT)) (QUOTE ((TERPRI STREAM)))))) (QUOTE (FRESH-LINE STREAM))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\| (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon and atsign modifiers cannot be used with this directive.")) (IF PARAMS (EXPAND-BIND-DEFAULTS ((COUNT 1)) PARAMS (SYSTEM::BACKQ-LIST* (QUOTE DOTIMES) (SYSTEM::BACKQ-LIST (QUOTE I) COUNT) (QUOTE ((WRITE-CHAR (CODE-CHAR SYSTEM::FORM-FEED-CHAR-CODE) STREAM))))) (QUOTE (WRITE-CHAR (CODE-CHAR SYSTEM::FORM-FEED-CHAR-CODE) STREAM))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\~ (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "The colon and atsign modifiers cannot be used with this directive.")) (IF PARAMS (EXPAND-BIND-DEFAULTS ((COUNT 1)) PARAMS (SYSTEM::BACKQ-LIST* (QUOTE DOTIMES) (SYSTEM::BACKQ-LIST (QUOTE I) COUNT) (QUOTE ((WRITE-CHAR #\~ STREAM))))) (QUOTE (WRITE-CHAR #\~ STREAM))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\Newline (COLONP ATSIGNP PARAMS DIRECTIVES) (WHEN (AND COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "both colon and atsign modifiers used simultaneously")) (VALUES (EXPAND-BIND-DEFAULTS NIL PARAMS (IF ATSIGNP (QUOTE (WRITE-CHAR #\Newline STREAM)) NIL)) (IF (AND (NOT COLONP) DIRECTIVES (SIMPLE-STRING-P (CAR DIRECTIVES))) (CONS (STRING-LEFT-TRIM *FORMAT-WHITESPACE-CHARS* (CAR DIRECTIVES)) (CDR DIRECTIVES)) DIRECTIVES)))
     [java] ; (DEF-FORMAT-DIRECTIVE #\T (COLONP ATSIGNP PARAMS) (IF COLONP (EXPAND-BIND-DEFAULTS ((N 1) (M 1)) PARAMS (SYSTEM::BACKQ-LIST* (QUOTE PPRINT-TAB) (IF ATSIGNP :SECTION-RELATIVE :SECTION) N M (QUOTE (STREAM)))) (IF ATSIGNP (EXPAND-BIND-DEFAULTS ((COLREL 1) (COLINC 1)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-RELATIVE-TAB) (QUOTE STREAM) COLREL COLINC)) (EXPAND-BIND-DEFAULTS ((COLNUM 1) (COLINC 1)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE FORMAT-ABSOLUTE-TAB) (QUOTE STREAM) COLNUM COLINC)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\_ (COLONP ATSIGNP PARAMS) (EXPAND-BIND-DEFAULTS NIL PARAMS (SYSTEM::BACKQ-LIST* (QUOTE PPRINT-NEWLINE) (IF COLONP (IF ATSIGNP :MANDATORY :FILL) (IF ATSIGNP :MISER :LINEAR)) (QUOTE (STREAM)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\I (COLONP ATSIGNP PARAMS) (WHEN ATSIGNP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot use the at-sign modifier with this directive")) (EXPAND-BIND-DEFAULTS ((N 0)) PARAMS (SYSTEM::BACKQ-LIST* (QUOTE PPRINT-INDENT) (IF COLONP :CURRENT :BLOCK) N (QUOTE (STREAM)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\* (COLONP ATSIGNP PARAMS END) (IF ATSIGNP (IF COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "both colon and atsign modifiers used simultaneously") (EXPAND-BIND-DEFAULTS ((POSN 0)) PARAMS (UNLESS *ORIG-ARGS-AVAILABLE* (THROW (QUOTE NEED-ORIG-ARGS) NIL)) (SYSTEM::BACKQ-LIST (QUOTE IF) (SYSTEM::BACKQ-LIST* (QUOTE <=) 0 POSN (QUOTE ((LENGTH ORIG-ARGS)))) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE ARGS) (SYSTEM::BACKQ-LIST* (QUOTE NTHCDR) POSN (QUOTE (ORIG-ARGS)))) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "Index ~W out of bounds. Should have been ~
     [java]                                             between 0 and ~W." (QUOTE :ARGS) (SYSTEM::BACKQ-LIST* (QUOTE LIST) POSN (QUOTE ((LENGTH ORIG-ARGS)))) (QUOTE :OFFSET) (1- END))))) (IF COLONP (EXPAND-BIND-DEFAULTS ((N 1)) PARAMS (UNLESS *ORIG-ARGS-AVAILABLE* (THROW (QUOTE NEED-ORIG-ARGS) NIL)) (SYSTEM::BACKQ-LIST (QUOTE DO) (QUOTE ((CUR-POSN 0 (1+ CUR-POSN)) (ARG-PTR ORIG-ARGS (CDR ARG-PTR)))) (SYSTEM::BACKQ-LIST (QUOTE (EQ ARG-PTR ARGS)) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE NEW-POSN) (SYSTEM::BACKQ-LIST (QUOTE -) (QUOTE CUR-POSN) N))) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE (<= 0 NEW-POSN (LENGTH ORIG-ARGS))) (QUOTE (SETF ARGS (NTHCDR NEW-POSN ORIG-ARGS))) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "Index ~W is out of bounds; should have been ~
     [java]                                                     between 0 and ~W." (QUOTE :ARGS) (QUOTE (LIST NEW-POSN (LENGTH ORIG-ARGS))) (QUOTE :OFFSET) (1- END))))))) (IF PARAMS (EXPAND-BIND-DEFAULTS ((N 1)) PARAMS (SETF *ONLY-SIMPLE-ARGS* NIL) (SYSTEM::BACKQ-LIST (QUOTE DOTIMES) (SYSTEM::BACKQ-LIST (QUOTE I) N) (EXPAND-NEXT-ARG))) (EXPAND-NEXT-ARG)))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\? (COLONP ATSIGNP PARAMS STRING END) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot use the colon modifier with this directive")) (EXPAND-BIND-DEFAULTS NIL PARAMS (SYSTEM::BACKQ-LIST (QUOTE HANDLER-BIND) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE FORMAT-ERROR) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (CONDITION)) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "~A~%while processing indirect format string:" (QUOTE :ARGS) (QUOTE (LIST CONDITION)) (QUOTE :PRINT-BANNER) NIL (QUOTE :CONTROL-STRING) STRING (QUOTE :OFFSET) (1- END))))) (IF ATSIGNP (IF *ORIG-ARGS-AVAILABLE* (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE ARGS) (SYSTEM::BACKQ-LIST* (QUOTE %FORMAT) (QUOTE STREAM) (EXPAND-NEXT-ARG) (QUOTE (ORIG-ARGS ARGS)))) (THROW (QUOTE NEED-ORIG-ARGS) NIL)) (SYSTEM::BACKQ-LIST (QUOTE %FORMAT) (QUOTE STREAM) (EXPAND-NEXT-ARG) (EXPAND-NEXT-ARG))))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\( (COLONP ATSIGNP PARAMS DIRECTIVES) (LET ((CLOSE (FIND-DIRECTIVE DIRECTIVES #\) NIL))) (UNLESS CLOSE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close parenthesis")) (LET* ((POSN (POSITION CLOSE DIRECTIVES)) (BEFORE (SUBSEQ DIRECTIVES 0 POSN)) (AFTER (NTHCDR (1+ POSN) DIRECTIVES))) (VALUES (EXPAND-BIND-DEFAULTS NIL PARAMS (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE STREAM) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::MAKE-CASE-FROB-STREAM) (QUOTE (IF (TYPEP STREAM (QUOTE XP::XP-STRUCTURE)) (XP::BASE-STREAM STREAM) STREAM)) (IF COLONP (IF ATSIGNP :UPCASE :CAPITALIZE) (IF ATSIGNP :CAPITALIZE-FIRST :DOWNCASE))))) (EXPAND-DIRECTIVE-LIST BEFORE))) AFTER))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\) NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open parenthesis"))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\[ (COLONP ATSIGNP PARAMS DIRECTIVES) (MULTIPLE-VALUE-BIND (SUBLISTS LAST-SEMI-WITH-COLON-P REMAINING) (PARSE-CONDITIONAL-DIRECTIVE DIRECTIVES) (VALUES (IF ATSIGNP (IF COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "both colon and atsign modifiers used simultaneously") (IF (CDR SUBLISTS) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "Can only specify one section") (EXPAND-BIND-DEFAULTS NIL PARAMS (EXPAND-MAYBE-CONDITIONAL (CAR SUBLISTS))))) (IF COLONP (IF (= (LENGTH SUBLISTS) 2) (EXPAND-BIND-DEFAULTS NIL PARAMS (EXPAND-TRUE-FALSE-CONDITIONAL (CAR SUBLISTS) (CADR SUBLISTS))) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "must specify exactly two sections")) (EXPAND-BIND-DEFAULTS ((INDEX NIL)) PARAMS (SETF *ONLY-SIMPLE-ARGS* NIL) (LET ((CLAUSES NIL) (CASE (SYSTEM::BACKQ-LIST (QUOTE OR) INDEX (EXPAND-NEXT-ARG)))) (WHEN LAST-SEMI-WITH-COLON-P (PUSH (SYSTEM::BACKQ-CONS (QUOTE T) (EXPAND-DIRECTIVE-LIST (POP SUBLISTS))) CLAUSES)) (LET ((COUNT (LENGTH SUBLISTS))) (DOLIST (SUBLIST SUBLISTS) (PUSH (SYSTEM::BACKQ-CONS (DECF COUNT) (EXPAND-DIRECTIVE-LIST SUBLIST)) CLAUSES))) (SYSTEM::BACKQ-LIST* (QUOTE CASE) CASE CLAUSES))))) REMAINING)))
     [java] ; (DEFUN PARSE-CONDITIONAL-DIRECTIVE (DIRECTIVES) (LET ((SUBLISTS NIL) (LAST-SEMI-WITH-COLON-P NIL) (REMAINING DIRECTIVES)) (LOOP (LET ((CLOSE-OR-SEMI (FIND-DIRECTIVE REMAINING #\] T))) (UNLESS CLOSE-OR-SEMI (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close bracket")) (LET ((POSN (POSITION CLOSE-OR-SEMI REMAINING))) (PUSH (SUBSEQ REMAINING 0 POSN) SUBLISTS) (SETF REMAINING (NTHCDR (1+ POSN) REMAINING)) (WHEN (CHAR= (FORMAT-DIRECTIVE-CHARACTER CLOSE-OR-SEMI) #\]) (RETURN)) (SETF LAST-SEMI-WITH-COLON-P (FORMAT-DIRECTIVE-COLONP CLOSE-OR-SEMI))))) (VALUES SUBLISTS LAST-SEMI-WITH-COLON-P REMAINING)))
     [java] ; (DEFUN EXPAND-MAYBE-CONDITIONAL (SUBLIST) (FLET ((HAIRY NIL (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (QUOTE (PREV-ARGS ARGS)) (SYSTEM::BACKQ-LIST (QUOTE ARG) (EXPAND-NEXT-ARG))) (SYSTEM::BACKQ-LIST* (QUOTE WHEN) (QUOTE ARG) (QUOTE (SETF ARGS PREV-ARGS)) (EXPAND-DIRECTIVE-LIST SUBLIST))))) (IF *ONLY-SIMPLE-ARGS* (MULTIPLE-VALUE-BIND (GUTS NEW-ARGS) (LET ((*SIMPLE-ARGS* *SIMPLE-ARGS*)) (VALUES (EXPAND-DIRECTIVE-LIST SUBLIST) *SIMPLE-ARGS*)) (COND ((AND NEW-ARGS (EQ *SIMPLE-ARGS* (CDR NEW-ARGS))) (SETF *SIMPLE-ARGS* NEW-ARGS) (SYSTEM::BACKQ-LIST* (QUOTE WHEN) (CAAR NEW-ARGS) GUTS)) (T (SETF *ONLY-SIMPLE-ARGS* NIL) (HAIRY)))) (HAIRY))))
     [java] ; (DEFUN EXPAND-TRUE-FALSE-CONDITIONAL (TRUE FALSE) (LET ((ARG (EXPAND-NEXT-ARG))) (FLET ((HAIRY NIL (SYSTEM::BACKQ-LIST (QUOTE IF) ARG (SYSTEM::BACKQ-CONS (QUOTE PROGN) (EXPAND-DIRECTIVE-LIST TRUE)) (SYSTEM::BACKQ-CONS (QUOTE PROGN) (EXPAND-DIRECTIVE-LIST FALSE))))) (IF *ONLY-SIMPLE-ARGS* (MULTIPLE-VALUE-BIND (TRUE-GUTS TRUE-ARGS TRUE-SIMPLE) (LET ((*SIMPLE-ARGS* *SIMPLE-ARGS*) (*ONLY-SIMPLE-ARGS* T)) (VALUES (EXPAND-DIRECTIVE-LIST TRUE) *SIMPLE-ARGS* *ONLY-SIMPLE-ARGS*)) (MULTIPLE-VALUE-BIND (FALSE-GUTS FALSE-ARGS FALSE-SIMPLE) (LET ((*SIMPLE-ARGS* *SIMPLE-ARGS*) (*ONLY-SIMPLE-ARGS* T)) (VALUES (EXPAND-DIRECTIVE-LIST FALSE) *SIMPLE-ARGS* *ONLY-SIMPLE-ARGS*)) (IF (= (LENGTH TRUE-ARGS) (LENGTH FALSE-ARGS)) (SYSTEM::BACKQ-LIST (QUOTE IF) ARG (SYSTEM::BACKQ-CONS (QUOTE PROGN) TRUE-GUTS) (DO ((FALSE FALSE-ARGS (CDR FALSE)) (TRUE TRUE-ARGS (CDR TRUE)) (BINDINGS NIL (CONS (SYSTEM::BACKQ-LIST (CAAR FALSE) (CAAR TRUE)) BINDINGS))) ((EQ TRUE *SIMPLE-ARGS*) (SETF *SIMPLE-ARGS* TRUE-ARGS) (SETF *ONLY-SIMPLE-ARGS* (AND TRUE-SIMPLE FALSE-SIMPLE)) (IF BINDINGS (SYSTEM::BACKQ-LIST* (QUOTE LET) BINDINGS FALSE-GUTS) (SYSTEM::BACKQ-CONS (QUOTE PROGN) FALSE-GUTS))))) (PROGN (SETF *ONLY-SIMPLE-ARGS* NIL) (HAIRY))))) (HAIRY)))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\; NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~~; directive not contained within either ~~[...~~] or ~~<...~~>"))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\] NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open bracket"))
     [java] ; (DEF-FORMAT-DIRECTIVE #\^ (COLONP ATSIGNP PARAMS) (WHEN ATSIGNP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot use the at-sign modifier with this directive")) (WHEN (AND COLONP (NOT *UP-UP-AND-OUT-ALLOWED*)) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "attempt to use ~~:^ outside a ~~:{...~~} construct")) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (EXPAND-BIND-DEFAULTS ((ARG1 NIL) (ARG2 NIL) (ARG3 NIL)) PARAMS (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-LIST ARG3 (SYSTEM::BACKQ-LIST (QUOTE <=) ARG1 ARG2 ARG3)) (SYSTEM::BACKQ-LIST ARG2 (SYSTEM::BACKQ-LIST (QUOTE EQL) ARG1 ARG2)) (SYSTEM::BACKQ-LIST ARG1 (SYSTEM::BACKQ-LIST* (QUOTE EQL) ARG1 (QUOTE (0)))) (SYSTEM::BACKQ-LIST (QUOTE T) (IF COLONP (QUOTE (NULL OUTSIDE-ARGS)) (PROGN (SETF *ONLY-SIMPLE-ARGS* NIL) (QUOTE (NULL ARGS))))))) (IF COLONP (QUOTE (RETURN-FROM OUTSIDE-LOOP NIL)) (QUOTE (RETURN)))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\{ (COLONP ATSIGNP PARAMS STRING END DIRECTIVES) (LET ((CLOSE (FIND-DIRECTIVE DIRECTIVES #\} NIL))) (UNLESS CLOSE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close brace")) (LET* ((CLOSED-WITH-COLON (FORMAT-DIRECTIVE-COLONP CLOSE)) (POSN (POSITION CLOSE DIRECTIVES))) (LABELS ((COMPUTE-INSIDES NIL (IF (ZEROP POSN) (IF *ORIG-ARGS-AVAILABLE* (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE HANDLER-BIND) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE FORMAT-ERROR) (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) (QUOTE (CONDITION)) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "~A~%while processing indirect format string:" (QUOTE :ARGS) (QUOTE (LIST CONDITION)) (QUOTE :PRINT-BANNER) NIL (QUOTE :CONTROL-STRING) STRING (QUOTE :OFFSET) (1- END))))) (QUOTE ((SETF ARGS (%FORMAT STREAM INSIDE-STRING ORIG-ARGS ARGS)))))) (THROW (QUOTE NEED-ORIG-ARGS) NIL)) (LET ((*UP-UP-AND-OUT-ALLOWED* COLONP)) (EXPAND-DIRECTIVE-LIST (SUBSEQ DIRECTIVES 0 POSN))))) (COMPUTE-LOOP (COUNT) (WHEN ATSIGNP (SETF *ONLY-SIMPLE-ARGS* NIL)) (SYSTEM::BACKQ-CONS (QUOTE LOOP) (SYSTEM::BACKQ-APPEND (UNLESS CLOSED-WITH-COLON (QUOTE ((WHEN (NULL ARGS) (RETURN))))) (WHEN COUNT (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE AND) COUNT (SYSTEM::BACKQ-LIST (QUOTE MINUSP) (SYSTEM::BACKQ-LIST (QUOTE DECF) COUNT))) (QUOTE ((RETURN)))))) (IF COLONP (LET ((*EXPANDER-NEXT-ARG-MACRO* (QUOTE EXPANDER-NEXT-ARG)) (*ONLY-SIMPLE-ARGS* NIL) (*ORIG-ARGS-AVAILABLE* T)) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE ORIG-ARGS) (EXPAND-NEXT-ARG)) (QUOTE ((OUTSIDE-ARGS ARGS) (ARGS ORIG-ARGS)))) (QUOTE (DECLARE (IGNORABLE ORIG-ARGS OUTSIDE-ARGS ARGS))) (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NIL (COMPUTE-INSIDES))))) (COMPUTE-INSIDES)) (WHEN CLOSED-WITH-COLON (QUOTE ((WHEN (NULL ARGS) (RETURN)))))))) (COMPUTE-BLOCK (COUNT) (IF COLONP (SYSTEM::BACKQ-LIST (QUOTE BLOCK) (QUOTE OUTSIDE-LOOP) (COMPUTE-LOOP COUNT)) (COMPUTE-LOOP COUNT))) (COMPUTE-BINDINGS (COUNT) (IF ATSIGNP (COMPUTE-BLOCK COUNT) (SYSTEM::BACKQ-LIST (QUOTE LET*) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE ORIG-ARGS) (EXPAND-NEXT-ARG)) (QUOTE ((ARGS ORIG-ARGS)))) (QUOTE (DECLARE (IGNORABLE ORIG-ARGS ARGS))) (LET ((*EXPANDER-NEXT-ARG-MACRO* (QUOTE EXPANDER-NEXT-ARG)) (*ONLY-SIMPLE-ARGS* NIL) (*ORIG-ARGS-AVAILABLE* T)) (COMPUTE-BLOCK COUNT)))))) (VALUES (IF PARAMS (EXPAND-BIND-DEFAULTS ((COUNT NIL)) PARAMS (IF (ZEROP POSN) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE INSIDE-STRING) (EXPAND-NEXT-ARG))) (COMPUTE-BINDINGS COUNT)) (COMPUTE-BINDINGS COUNT))) (IF (ZEROP POSN) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE INSIDE-STRING) (EXPAND-NEXT-ARG))) (COMPUTE-BINDINGS NIL)) (COMPUTE-BINDINGS NIL))) (NTHCDR (1+ POSN) DIRECTIVES))))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\} NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open brace"))
     [java] ; (DEFPARAMETER *ILLEGAL-INSIDE-JUSTIFICATION* (MAPCAR (LAMBDA (X) (PARSE-DIRECTIVE X 0)) (QUOTE ("~W" "~:W" "~@W" "~:@W" "~_" "~:_" "~@_" "~:@_" "~:>" "~:@>" "~I" "~:I" "~@I" "~:@I" "~:T" "~:@T"))))
     [java] ; (DEFUN ILLEGAL-INSIDE-JUSTIFICATION-P (DIRECTIVE) (MEMBER DIRECTIVE *ILLEGAL-INSIDE-JUSTIFICATION* :TEST (LAMBDA (X Y) (AND (FORMAT-DIRECTIVE-P X) (FORMAT-DIRECTIVE-P Y) (EQL (FORMAT-DIRECTIVE-CHARACTER X) (FORMAT-DIRECTIVE-CHARACTER Y)) (EQL (FORMAT-DIRECTIVE-COLONP X) (FORMAT-DIRECTIVE-COLONP Y)) (EQL (FORMAT-DIRECTIVE-ATSIGNP X) (FORMAT-DIRECTIVE-ATSIGNP Y))))))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\< (COLONP ATSIGNP PARAMS STRING END DIRECTIVES) (MULTIPLE-VALUE-BIND (SEGMENTS FIRST-SEMI CLOSE REMAINING) (PARSE-FORMAT-JUSTIFICATION DIRECTIVES) (VALUES (IF (FORMAT-DIRECTIVE-COLONP CLOSE) (MULTIPLE-VALUE-BIND (PREFIX PER-LINE-P INSIDES SUFFIX) (PARSE-FORMAT-LOGICAL-BLOCK SEGMENTS COLONP FIRST-SEMI CLOSE PARAMS STRING END) (EXPAND-FORMAT-LOGICAL-BLOCK PREFIX PER-LINE-P INSIDES SUFFIX ATSIGNP)) (LET ((COUNT (REDUCE (FUNCTION +) (MAPCAR (LAMBDA (X) (COUNT-IF (FUNCTION ILLEGAL-INSIDE-JUSTIFICATION-P) X)) SEGMENTS)))) (WHEN (> COUNT 0) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~D illegal directive~:P found inside justification block" :ARGS (LIST COUNT))) (EXPAND-FORMAT-JUSTIFICATION SEGMENTS COLONP ATSIGNP FIRST-SEMI PARAMS))) REMAINING)))
     [java] ; (DEF-COMPLEX-FORMAT-DIRECTIVE #\> NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open bracket"))
     [java] ; (DEFUN PARSE-FORMAT-LOGICAL-BLOCK (SEGMENTS COLONP FIRST-SEMI CLOSE PARAMS STRING END) (WHEN PARAMS (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "No parameters can be supplied with ~~<...~~:>." :OFFSET (CAAR PARAMS))) (MULTIPLE-VALUE-BIND (PREFIX INSIDES SUFFIX) (MULTIPLE-VALUE-BIND (PREFIX-DEFAULT SUFFIX-DEFAULT) (IF COLONP (VALUES "(" ")") (VALUES "" "")) (FLET ((EXTRACT-STRING (LIST PREFIX-P) (LET ((DIRECTIVE (FIND-IF (FUNCTION FORMAT-DIRECTIVE-P) LIST))) (IF DIRECTIVE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot include format directives inside the ~
     [java]                                            ~:[suffix~;prefix~] segment of ~~<...~~:>" :ARGS (LIST PREFIX-P) :OFFSET (1- (FORMAT-DIRECTIVE-END DIRECTIVE))) (APPLY (FUNCTION CONCATENATE) (QUOTE STRING) LIST))))) (CASE (LENGTH SEGMENTS) (0 (VALUES PREFIX-DEFAULT NIL SUFFIX-DEFAULT)) (1 (VALUES PREFIX-DEFAULT (CAR SEGMENTS) SUFFIX-DEFAULT)) (2 (VALUES (EXTRACT-STRING (CAR SEGMENTS) T) (CADR SEGMENTS) SUFFIX-DEFAULT)) (3 (VALUES (EXTRACT-STRING (CAR SEGMENTS) T) (CADR SEGMENTS) (EXTRACT-STRING (CADDR SEGMENTS) NIL))) (T (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "too many segments for ~~<...~~:>"))))) (WHEN (FORMAT-DIRECTIVE-ATSIGNP CLOSE) (SETF INSIDES (ADD-FILL-STYLE-NEWLINES INSIDES STRING (IF FIRST-SEMI (FORMAT-DIRECTIVE-END FIRST-SEMI) END)))) (VALUES PREFIX (AND FIRST-SEMI (FORMAT-DIRECTIVE-ATSIGNP FIRST-SEMI)) INSIDES SUFFIX)))
     [java] ; (DEFUN ADD-FILL-STYLE-NEWLINES (LIST STRING OFFSET &OPTIONAL LAST-DIRECTIVE) (COND (LIST (LET ((DIRECTIVE (CAR LIST))) (COND ((SIMPLE-STRING-P DIRECTIVE) (LET* ((NON-SPACE (POSITION #\  DIRECTIVE :TEST (FUNCTION CHAR/=))) (NEWLINEP (AND LAST-DIRECTIVE (CHAR= (FORMAT-DIRECTIVE-CHARACTER LAST-DIRECTIVE) #\Newline)))) (COND ((AND NEWLINEP NON-SPACE) (NCONC (LIST (SUBSEQ DIRECTIVE 0 NON-SPACE)) (ADD-FILL-STYLE-NEWLINES-AUX (SUBSEQ DIRECTIVE NON-SPACE) STRING (+ OFFSET NON-SPACE)) (ADD-FILL-STYLE-NEWLINES (CDR LIST) STRING (+ OFFSET (LENGTH DIRECTIVE))))) (NEWLINEP (CONS DIRECTIVE (ADD-FILL-STYLE-NEWLINES (CDR LIST) STRING (+ OFFSET (LENGTH DIRECTIVE))))) (T (NCONC (ADD-FILL-STYLE-NEWLINES-AUX DIRECTIVE STRING OFFSET) (ADD-FILL-STYLE-NEWLINES (CDR LIST) STRING (+ OFFSET (LENGTH DIRECTIVE)))))))) (T (CONS DIRECTIVE (ADD-FILL-STYLE-NEWLINES (CDR LIST) STRING (FORMAT-DIRECTIVE-END DIRECTIVE) DIRECTIVE)))))) (T NIL)))
     [java] ; (DEFUN ADD-FILL-STYLE-NEWLINES-AUX (LITERAL STRING OFFSET) (LET ((END (LENGTH LITERAL)) (POSN 0)) (COLLECT ((RESULTS)) (LOOP (LET ((BLANK (POSITION #\  LITERAL :START POSN))) (WHEN (NULL BLANK) (RESULTS (SUBSEQ LITERAL POSN)) (RETURN)) (LET ((NON-BLANK (OR (POSITION #\  LITERAL :START BLANK :TEST (FUNCTION CHAR/=)) END))) (RESULTS (SUBSEQ LITERAL POSN NON-BLANK)) (RESULTS (MAKE-FORMAT-DIRECTIVE :STRING STRING :CHARACTER #\_ :START (+ OFFSET NON-BLANK) :END (+ OFFSET NON-BLANK) :COLONP T :ATSIGNP NIL :PARAMS NIL)) (SETF POSN NON-BLANK)) (WHEN (= POSN END) (RETURN)))) (RESULTS))))
     [java] ; (DEFUN PARSE-FORMAT-JUSTIFICATION (DIRECTIVES) (LET ((FIRST-SEMI NIL) (CLOSE NIL) (REMAINING DIRECTIVES)) (COLLECT ((SEGMENTS)) (LOOP (LET ((CLOSE-OR-SEMI (FIND-DIRECTIVE REMAINING #\> T))) (UNLESS CLOSE-OR-SEMI (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close bracket")) (LET ((POSN (POSITION CLOSE-OR-SEMI REMAINING))) (SEGMENTS (SUBSEQ REMAINING 0 POSN)) (SETF REMAINING (NTHCDR (1+ POSN) REMAINING))) (WHEN (CHAR= (FORMAT-DIRECTIVE-CHARACTER CLOSE-OR-SEMI) #\>) (SETF CLOSE CLOSE-OR-SEMI) (RETURN)) (UNLESS FIRST-SEMI (SETF FIRST-SEMI CLOSE-OR-SEMI)))) (VALUES (SEGMENTS) FIRST-SEMI CLOSE REMAINING))))
     [java] ; (DEFMACRO EXPANDER-PPRINT-NEXT-ARG (STRING OFFSET) (SYSTEM::BACKQ-LIST* (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (QUOTE (NULL ARGS)) (SYSTEM::BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE FORMAT-ERROR)) (QUOTE :COMPLAINT) "no more arguments" (QUOTE :CONTROL-STRING) STRING (QUOTE :OFFSET) OFFSET)) (QUOTE ((PPRINT-POP) (POP ARGS)))))
     [java] ; (DEFUN EXPAND-FORMAT-LOGICAL-BLOCK (PREFIX PER-LINE-P INSIDES SUFFIX ATSIGNP) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE ARG) (IF ATSIGNP (QUOTE ARGS) (EXPAND-NEXT-ARG)))) (SYSTEM::BACKQ-APPEND (WHEN ATSIGNP (SETF *ONLY-SIMPLE-ARGS* NIL) (QUOTE ((SETF ARGS NIL)))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE PPRINT-LOGICAL-BLOCK) (SYSTEM::BACKQ-LIST (QUOTE STREAM) (QUOTE ARG) (IF PER-LINE-P :PER-LINE-PREFIX :PREFIX) PREFIX (QUOTE :SUFFIX) SUFFIX) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-CONS (QUOTE (ARGS ARG)) (UNLESS ATSIGNP (QUOTE ((ORIG-ARGS ARG))))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST* (QUOTE IGNORABLE) (QUOTE ARGS) (UNLESS ATSIGNP (QUOTE (ORIG-ARGS))))) (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NIL (LET ((*EXPANDER-NEXT-ARG-MACRO* (QUOTE EXPANDER-PPRINT-NEXT-ARG)) (*ONLY-SIMPLE-ARGS* NIL) (*ORIG-ARGS-AVAILABLE* (IF ATSIGNP *ORIG-ARGS-AVAILABLE* T))) (EXPAND-DIRECTIVE-LIST INSIDES)))))))))
     [java] ; (DEFUN EXPAND-FORMAT-JUSTIFICATION (SEGMENTS COLONP ATSIGNP FIRST-SEMI PARAMS) (LET ((NEWLINE-SEGMENT-P (AND FIRST-SEMI (FORMAT-DIRECTIVE-COLONP FIRST-SEMI)))) (EXPAND-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-CONS (QUOTE (SEGMENTS NIL)) (WHEN NEWLINE-SEGMENT-P (QUOTE ((NEWLINE-SEGMENT NIL) (EXTRA-SPACE 0) (LINE-LEN 72))))) (SYSTEM::BACKQ-LIST* (QUOTE BLOCK) NIL (SYSTEM::BACKQ-APPEND (WHEN NEWLINE-SEGMENT-P (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE NEWLINE-SEGMENT) (SYSTEM::BACKQ-LIST* (QUOTE WITH-OUTPUT-TO-STRING) (QUOTE (STREAM)) (EXPAND-DIRECTIVE-LIST (POP SEGMENTS)))) (EXPAND-BIND-DEFAULTS ((EXTRA 0) (LINE-LEN (QUOTE (OR 72)))) (FORMAT-DIRECTIVE-PARAMS FIRST-SEMI) (SYSTEM::BACKQ-LIST (QUOTE SETF) (QUOTE EXTRA-SPACE) EXTRA (QUOTE LINE-LEN) LINE-LEN)))) (MAPCAR (LAMBDA (SEGMENT) (SYSTEM::BACKQ-LIST* (QUOTE PUSH) (SYSTEM::BACKQ-LIST* (QUOTE WITH-OUTPUT-TO-STRING) (QUOTE (STREAM)) (EXPAND-DIRECTIVE-LIST SEGMENT)) (QUOTE (SEGMENTS)))) SEGMENTS))) (SYSTEM::BACKQ-LIST* (QUOTE FORMAT-JUSTIFICATION) (QUOTE STREAM) (SYSTEM::BACKQ-APPEND (IF NEWLINE-SEGMENT-P (QUOTE (NEWLINE-SEGMENT EXTRA-SPACE LINE-LEN)) (QUOTE (NIL 0 0))) (SYSTEM::BACKQ-LIST (QUOTE SEGMENTS) COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR)))))))
     [java] ; (DEF-FORMAT-DIRECTIVE #\/ (STRING START END COLONP ATSIGNP PARAMS) (LET ((SYMBOL (EXTRACT-USER-FUN-NAME STRING START END))) (COLLECT ((PARAM-NAMES) (BINDINGS)) (DOLIST (PARAM-AND-OFFSET PARAMS) (LET ((PARAM (CDR PARAM-AND-OFFSET))) (LET ((PARAM-NAME (GENSYM))) (PARAM-NAMES PARAM-NAME) (BINDINGS (SYSTEM::BACKQ-LIST PARAM-NAME (CASE PARAM (:ARG (EXPAND-NEXT-ARG)) (:REMAINING (QUOTE (LENGTH ARGS))) (T PARAM))))))) (SYSTEM::BACKQ-LIST (QUOTE LET) (BINDINGS) (SYSTEM::BACKQ-LIST* SYMBOL (QUOTE STREAM) (EXPAND-NEXT-ARG) COLONP ATSIGNP (PARAM-NAMES))))))
     [java] ; (DEFUN EXTRACT-USER-FUN-NAME (STRING START END) (LET ((SLASH (POSITION #\/ STRING :START START :END (1- END) :FROM-END T))) (UNLESS SLASH (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "malformed ~~/ directive")) (LET* ((NAME (STRING-UPCASE (LET ((FOO STRING)) (SUBSEQ FOO (1+ SLASH) (1- END))))) (FIRST-COLON (POSITION #\: NAME)) (SECOND-COLON (IF FIRST-COLON (POSITION #\: NAME :START (1+ FIRST-COLON)))) (PACKAGE-NAME (IF FIRST-COLON (SUBSEQ NAME 0 FIRST-COLON) "COMMON-LISP-USER")) (PACKAGE (FIND-PACKAGE PACKAGE-NAME))) (UNLESS PACKAGE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no package named ~S" :ARGS (LIST PACKAGE-NAME))) (INTERN (COND ((AND SECOND-COLON (= SECOND-COLON (1+ FIRST-COLON))) (SUBSEQ NAME (1+ SECOND-COLON))) (FIRST-COLON (SUBSEQ NAME (1+ FIRST-COLON))) (T NAME)) PACKAGE))))
     [java] ; (DEFUN %COMPILER-WALK-FORMAT-STRING (STRING ARGS) (DECLARE (TYPE SIMPLE-STRING STRING)) (LET ((*DEFAULT-FORMAT-ERROR-CONTROL-STRING* STRING)) (MACROLET ((INCF-BOTH (&OPTIONAL (INCREMENT 1)) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE INCF) (QUOTE MIN) INCREMENT) (SYSTEM::BACKQ-LIST (QUOTE INCF) (QUOTE MAX) INCREMENT))) (WALK-COMPLEX-DIRECTIVE (FUNCTION) (SYSTEM::BACKQ-LIST* (QUOTE MULTIPLE-VALUE-BIND) (QUOTE (MIN-INC MAX-INC REMAINING)) (SYSTEM::BACKQ-CONS FUNCTION (QUOTE (DIRECTIVE DIRECTIVES ARGS))) (QUOTE ((INCF MIN MIN-INC) (INCF MAX MAX-INC) (SETQ DIRECTIVES REMAINING)))))) (LABELS ((WALK-JUSTIFICATION (JUSTIFICATION DIRECTIVES ARGS) (DECLARE (IGNORE ARGS)) (LET ((*DEFAULT-FORMAT-ERROR-OFFSET* (1- (FORMAT-DIRECTIVE-END JUSTIFICATION)))) (MULTIPLE-VALUE-BIND (SEGMENTS FIRST-SEMI CLOSE REMAINING) (PARSE-FORMAT-JUSTIFICATION DIRECTIVES) (DECLARE (IGNORE SEGMENTS FIRST-SEMI)) (COND ((NOT (FORMAT-DIRECTIVE-COLONP CLOSE)) (VALUES 0 0 DIRECTIVES)) ((FORMAT-DIRECTIVE-ATSIGNP JUSTIFICATION) (VALUES 0 CALL-ARGUMENTS-LIMIT DIRECTIVES)) (T (VALUES 1 1 REMAINING)))))) (WALK-CONDITIONAL (CONDITIONAL DIRECTIVES ARGS) (LET ((*DEFAULT-FORMAT-ERROR-OFFSET* (1- (FORMAT-DIRECTIVE-END CONDITIONAL)))) (MULTIPLE-VALUE-BIND (SUBLISTS LAST-SEMI-WITH-COLON-P REMAINING) (PARSE-CONDITIONAL-DIRECTIVE DIRECTIVES) (DECLARE (IGNORE LAST-SEMI-WITH-COLON-P)) (LET ((SUB-MAX (LOOP FOR S IN SUBLISTS MAXIMIZE (NTH-VALUE 1 (WALK-DIRECTIVE-LIST S ARGS))))) (COND ((FORMAT-DIRECTIVE-ATSIGNP CONDITIONAL) (VALUES 1 (MAX 1 SUB-MAX) REMAINING)) ((LOOP FOR P IN (FORMAT-DIRECTIVE-PARAMS CONDITIONAL) THEREIS (OR (INTEGERP (CDR P)) (MEMQ (CDR P) (QUOTE (:REMAINING :ARG))))) (VALUES 0 SUB-MAX REMAINING)) (T (VALUES 1 (1+ SUB-MAX) REMAINING))))))) (WALK-ITERATION (ITERATION DIRECTIVES ARGS) (DECLARE (IGNORE ARGS)) (LET ((*DEFAULT-FORMAT-ERROR-OFFSET* (1- (FORMAT-DIRECTIVE-END ITERATION)))) (LET* ((CLOSE (FIND-DIRECTIVE DIRECTIVES #\} NIL)) (POSN (OR (POSITION CLOSE DIRECTIVES) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close brace"))) (REMAINING (NTHCDR (1+ POSN) DIRECTIVES))) (IF (FORMAT-DIRECTIVE-ATSIGNP ITERATION) (VALUES (IF (ZEROP POSN) 1 0) CALL-ARGUMENTS-LIMIT REMAINING) (LET ((NREQ (IF (ZEROP POSN) 2 1))) (VALUES NREQ NREQ REMAINING)))))) (WALK-DIRECTIVE-LIST (DIRECTIVES ARGS) (LET ((MIN 0) (MAX 0)) (LOOP (LET ((DIRECTIVE (POP DIRECTIVES))) (WHEN (NULL DIRECTIVE) (RETURN (VALUES MIN (MIN MAX CALL-ARGUMENTS-LIMIT)))) (WHEN (FORMAT-DIRECTIVE-P DIRECTIVE) (INCF-BOTH (COUNT :ARG (FORMAT-DIRECTIVE-PARAMS DIRECTIVE) :KEY (FUNCTION CDR))) (LET ((C (FORMAT-DIRECTIVE-CHARACTER DIRECTIVE))) (COND ((FIND C "ABCDEFGORSWX$/") (INCF-BOTH)) ((CHAR= C #\P) (UNLESS (FORMAT-DIRECTIVE-COLONP DIRECTIVE) (INCF-BOTH))) ((OR (FIND C "IT%&|_();>") (CHAR= C #\Newline))) ((CHAR= C #\<) (WALK-COMPLEX-DIRECTIVE WALK-JUSTIFICATION)) ((CHAR= C #\[) (WALK-COMPLEX-DIRECTIVE WALK-CONDITIONAL)) ((CHAR= C #\{) (WALK-COMPLEX-DIRECTIVE WALK-ITERATION)) ((CHAR= C #\?) (COND ((FORMAT-DIRECTIVE-ATSIGNP DIRECTIVE) (INCF MIN) (SETQ MAX CALL-ARGUMENTS-LIMIT)) (T (INCF-BOTH 2)))) (T (THROW (QUOTE GIVE-UP-FORMAT-STRING-WALK) NIL)))))))))) (CATCH (QUOTE GIVE-UP-FORMAT-STRING-WALK) (LET ((DIRECTIVES (TOKENIZE-CONTROL-STRING STRING))) (WALK-DIRECTIVE-LIST DIRECTIVES ARGS)))))))
     [java] ; (IN-PACKAGE #:FORMAT)
     [java] ; (DEFUN FORMAT (DESTINATION CONTROL-STRING &REST FORMAT-ARGUMENTS) (ETYPECASE DESTINATION (NULL (WITH-OUTPUT-TO-STRING (STREAM) (%FORMAT STREAM CONTROL-STRING FORMAT-ARGUMENTS))) (STRING (WITH-OUTPUT-TO-STRING (STREAM DESTINATION) (%FORMAT STREAM CONTROL-STRING FORMAT-ARGUMENTS))) ((MEMBER T) (%FORMAT *STANDARD-OUTPUT* CONTROL-STRING FORMAT-ARGUMENTS) NIL) ((OR STREAM XP::XP-STRUCTURE) (%FORMAT DESTINATION CONTROL-STRING FORMAT-ARGUMENTS) NIL)))
     [java] ; (DEFUN %FORMAT (STREAM STRING-OR-FUN ORIG-ARGS &OPTIONAL (ARGS ORIG-ARGS)) (IF (FUNCTIONP STRING-OR-FUN) (APPLY STRING-OR-FUN STREAM ARGS) (CATCH (QUOTE UP-AND-OUT) (LET* ((STRING (ETYPECASE STRING-OR-FUN (SIMPLE-STRING STRING-OR-FUN) (STRING (COERCE STRING-OR-FUN (QUOTE SIMPLE-STRING))))) (*DEFAULT-FORMAT-ERROR-CONTROL-STRING* STRING) (*LOGICAL-BLOCK-POPPER* NIL)) (INTERPRET-DIRECTIVE-LIST STREAM (TOKENIZE-CONTROL-STRING STRING) ORIG-ARGS ARGS)))))
     [java] ; (DEFUN INTERPRET-DIRECTIVE-LIST (STREAM DIRECTIVES ORIG-ARGS ARGS) (IF DIRECTIVES (LET ((DIRECTIVE (CAR DIRECTIVES))) (ETYPECASE DIRECTIVE (SIMPLE-STRING (WRITE-STRING DIRECTIVE STREAM) (INTERPRET-DIRECTIVE-LIST STREAM (CDR DIRECTIVES) ORIG-ARGS ARGS)) (FORMAT-DIRECTIVE (MULTIPLE-VALUE-BIND (NEW-DIRECTIVES NEW-ARGS) (LET* ((CHARACTER (FORMAT-DIRECTIVE-CHARACTER DIRECTIVE)) (FUNCTION (GETHASH CHARACTER *FORMAT-DIRECTIVE-INTERPRETERS*)) (*DEFAULT-FORMAT-ERROR-OFFSET* (1- (FORMAT-DIRECTIVE-END DIRECTIVE)))) (UNLESS FUNCTION (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "unknown format directive ~@[(character: ~A)~]" :ARGS (LIST (CHAR-NAME CHARACTER)))) (MULTIPLE-VALUE-BIND (NEW-DIRECTIVES NEW-ARGS) (FUNCALL FUNCTION STREAM DIRECTIVE (CDR DIRECTIVES) ORIG-ARGS ARGS) (VALUES NEW-DIRECTIVES NEW-ARGS))) (INTERPRET-DIRECTIVE-LIST STREAM NEW-DIRECTIVES ORIG-ARGS NEW-ARGS))))) ARGS))
     [java] ; (DEFUN FORMAT-WRITE-FIELD (STREAM STRING MINCOL COLINC MINPAD PADCHAR PADLEFT) (UNLESS PADLEFT (WRITE-STRING STRING STREAM)) (DOTIMES (I MINPAD) (WRITE-CHAR PADCHAR STREAM)) (WHEN (AND MINCOL COLINC) (DO ((CHARS (+ (LENGTH STRING) (MAX MINPAD 0)) (+ CHARS COLINC))) ((>= CHARS MINCOL)) (DOTIMES (I COLINC) (WRITE-CHAR PADCHAR STREAM)))) (WHEN PADLEFT (WRITE-STRING STRING STREAM)))
     [java] ; (DEFUN FORMAT-PRINC (STREAM ARG COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR) (FORMAT-WRITE-FIELD STREAM (IF (OR ARG (NOT COLONP)) (PRINC-TO-STRING ARG) "()") MINCOL COLINC MINPAD PADCHAR ATSIGNP))
     [java] ; (DEF-FORMAT-INTERPRETER #\A (COLONP ATSIGNP PARAMS) (IF PARAMS (INTERPRET-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (FORMAT-PRINC STREAM (NEXT-ARG) COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR)) (PRINC (IF COLONP (OR (NEXT-ARG) "()") (NEXT-ARG)) STREAM)))
     [java] ; (DEFUN FORMAT-PRIN1 (STREAM ARG COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR) (FORMAT-WRITE-FIELD STREAM (IF (OR ARG (NOT COLONP)) (PRIN1-TO-STRING ARG) "()") MINCOL COLINC MINPAD PADCHAR ATSIGNP))
     [java] ; (DEF-FORMAT-INTERPRETER #\S (COLONP ATSIGNP PARAMS) (COND (PARAMS (INTERPRET-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (FORMAT-PRIN1 STREAM (NEXT-ARG) COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR))) (COLONP (LET ((ARG (NEXT-ARG))) (IF ARG (PRIN1 ARG STREAM) (PRINC "()" STREAM)))) (T (PRIN1 (NEXT-ARG) STREAM))))
     [java] ; (DEF-FORMAT-INTERPRETER #\C (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS NIL PARAMS (IF COLONP (FORMAT-PRINT-NAMED-CHARACTER (NEXT-ARG) STREAM) (IF ATSIGNP (PRIN1 (NEXT-ARG) STREAM) (WRITE-CHAR (NEXT-ARG) STREAM)))))
     [java] ; (DEFUN FORMAT-PRINT-NAMED-CHARACTER (CHAR STREAM) (LET* ((NAME (CHAR-NAME CHAR))) (COND ((AND NAME (NOT (EQ 160 (CHAR-CODE CHAR)))) (WRITE-STRING (STRING-CAPITALIZE NAME) STREAM)) (T (WRITE-CHAR CHAR STREAM)))))
     [java] ; (DEF-FORMAT-INTERPRETER #\W (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS NIL PARAMS (LET ((*PRINT-PRETTY* (OR COLONP *PRINT-PRETTY*)) (*PRINT-LEVEL* (UNLESS ATSIGNP *PRINT-LEVEL*)) (*PRINT-LENGTH* (UNLESS ATSIGNP *PRINT-LENGTH*))) (SYSTEM:OUTPUT-OBJECT (NEXT-ARG) STREAM))))
     [java] ; (DEFUN FORMAT-PRINT-INTEGER (STREAM NUMBER PRINT-COMMAS-P PRINT-SIGN-P RADIX MINCOL PADCHAR COMMACHAR COMMAINTERVAL) (LET ((*PRINT-BASE* RADIX) (*PRINT-RADIX* NIL)) (IF (INTEGERP NUMBER) (LET* ((TEXT (PRINC-TO-STRING (ABS NUMBER))) (COMMAED (IF PRINT-COMMAS-P (FORMAT-ADD-COMMAS TEXT COMMACHAR COMMAINTERVAL) TEXT)) (SIGNED (COND ((MINUSP NUMBER) (CONCATENATE (QUOTE STRING) "-" COMMAED)) (PRINT-SIGN-P (CONCATENATE (QUOTE STRING) "+" COMMAED)) (T COMMAED)))) (FORMAT-WRITE-FIELD STREAM SIGNED MINCOL 1 0 PADCHAR T)) (PRINC NUMBER STREAM))))
     [java] ; (DEFUN FORMAT-ADD-COMMAS (STRING COMMACHAR COMMAINTERVAL) (LET ((LENGTH (LENGTH STRING))) (MULTIPLE-VALUE-BIND (COMMAS EXTRA) (TRUNCATE (1- LENGTH) COMMAINTERVAL) (LET ((NEW-STRING (MAKE-STRING (+ LENGTH COMMAS))) (FIRST-COMMA (1+ EXTRA))) (REPLACE NEW-STRING STRING :END1 FIRST-COMMA :END2 FIRST-COMMA) (DO ((SRC FIRST-COMMA (+ SRC COMMAINTERVAL)) (DST FIRST-COMMA (+ DST COMMAINTERVAL 1))) ((= SRC LENGTH)) (SETF (SCHAR NEW-STRING DST) COMMACHAR) (REPLACE NEW-STRING STRING :START1 (1+ DST) :START2 SRC :END2 (+ SRC COMMAINTERVAL))) NEW-STRING))))
     [java] ; (DEFMACRO INTERPRET-FORMAT-INTEGER (BASE) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE (OR COLONP ATSIGNP PARAMS)) (SYSTEM::BACKQ-LIST (QUOTE INTERPRET-BIND-DEFAULTS) (QUOTE ((MINCOL 0) (PADCHAR #\ ) (COMMACHAR #\,) (COMMAINTERVAL 3))) (QUOTE PARAMS) (SYSTEM::BACKQ-LIST* (QUOTE FORMAT-PRINT-INTEGER) (QUOTE STREAM) (QUOTE (NEXT-ARG)) (QUOTE COLONP) (QUOTE ATSIGNP) BASE (QUOTE (MINCOL PADCHAR COMMACHAR COMMAINTERVAL)))) (SYSTEM::BACKQ-LIST* (QUOTE WRITE) (QUOTE (NEXT-ARG)) (QUOTE :STREAM) (QUOTE STREAM) (QUOTE :BASE) BASE (QUOTE (:RADIX NIL :ESCAPE NIL)))))
     [java] ; (DEF-FORMAT-INTERPRETER #\D (COLONP ATSIGNP PARAMS) (INTERPRET-FORMAT-INTEGER 10))
     [java] ; (DEF-FORMAT-INTERPRETER #\B (COLONP ATSIGNP PARAMS) (INTERPRET-FORMAT-INTEGER 2))
     [java] ; (DEF-FORMAT-INTERPRETER #\O (COLONP ATSIGNP PARAMS) (INTERPRET-FORMAT-INTEGER 8))
     [java] ; (DEF-FORMAT-INTERPRETER #\X (COLONP ATSIGNP PARAMS) (INTERPRET-FORMAT-INTEGER 16))
     [java] ; (DEF-FORMAT-INTERPRETER #\R (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS ((BASE NIL) (MINCOL 0) (PADCHAR #\ ) (COMMACHAR #\,) (COMMAINTERVAL 3)) PARAMS (LET ((ARG (NEXT-ARG))) (IF BASE (FORMAT-PRINT-INTEGER STREAM ARG COLONP ATSIGNP BASE MINCOL PADCHAR COMMACHAR COMMAINTERVAL) (IF ATSIGNP (IF COLONP (FORMAT-PRINT-OLD-ROMAN STREAM ARG) (FORMAT-PRINT-ROMAN STREAM ARG)) (IF COLONP (FORMAT-PRINT-ORDINAL STREAM ARG) (FORMAT-PRINT-CARDINAL STREAM ARG)))))))
     [java] ; (DEFPARAMETER *CARDINAL-ONES* #(NIL "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))
     [java] ; (DEFPARAMETER *CARDINAL-TENS* #(NIL NIL "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))
     [java] ; (DEFPARAMETER *CARDINAL-TEENS* #("ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))
     [java] ; (DEFPARAMETER *CARDINAL-PERIODS* #("" " thousand" " million" " billion" " trillion" " quadrillion" " quintillion" " sextillion" " septillion" " octillion" " nonillion" " decillion" " undecillion" " duodecillion" " tredecillion" " quattuordecillion" " quindecillion" " sexdecillion" " septendecillion" " octodecillion" " novemdecillion" " vigintillion"))
     [java] ; (DEFPARAMETER *ORDINAL-ONES* #(NIL "first" "second" "third" "fourth" "fifth" "sixth" "seventh" "eighth" "ninth"))
     [java] ; (DEFPARAMETER *ORDINAL-TENS* #(NIL "tenth" "twentieth" "thirtieth" "fortieth" "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth"))
     [java] ; (DEFUN FORMAT-PRINT-SMALL-CARDINAL (STREAM N) (MULTIPLE-VALUE-BIND (HUNDREDS REM) (TRUNCATE N 100) (WHEN (PLUSP HUNDREDS) (WRITE-STRING (SVREF *CARDINAL-ONES* HUNDREDS) STREAM) (WRITE-STRING " hundred" STREAM) (WHEN (PLUSP REM) (WRITE-CHAR #\  STREAM))) (WHEN (PLUSP REM) (MULTIPLE-VALUE-BIND (TENS ONES) (TRUNCATE REM 10) (COND ((< 1 TENS) (WRITE-STRING (SVREF *CARDINAL-TENS* TENS) STREAM) (WHEN (PLUSP ONES) (WRITE-CHAR #\- STREAM) (WRITE-STRING (SVREF *CARDINAL-ONES* ONES) STREAM))) ((= TENS 1) (WRITE-STRING (SVREF *CARDINAL-TEENS* ONES) STREAM)) ((PLUSP ONES) (WRITE-STRING (SVREF *CARDINAL-ONES* ONES) STREAM)))))))
     [java] ; (DEFUN FORMAT-PRINT-CARDINAL (STREAM N) (COND ((MINUSP N) (WRITE-STRING "negative " STREAM) (FORMAT-PRINT-CARDINAL-AUX STREAM (- N) 0 N)) ((ZEROP N) (WRITE-STRING "zero" STREAM)) (T (FORMAT-PRINT-CARDINAL-AUX STREAM N 0 N))))
     [java] ; (DEFUN FORMAT-PRINT-CARDINAL-AUX (STREAM N PERIOD ERR) (MULTIPLE-VALUE-BIND (BEYOND HERE) (TRUNCATE N 1000) (UNLESS (<= PERIOD 20) (ERROR "number too large to print in English: ~:D" ERR)) (UNLESS (ZEROP BEYOND) (FORMAT-PRINT-CARDINAL-AUX STREAM BEYOND (1+ PERIOD) ERR)) (UNLESS (ZEROP HERE) (UNLESS (ZEROP BEYOND) (WRITE-CHAR #\  STREAM)) (FORMAT-PRINT-SMALL-CARDINAL STREAM HERE) (WRITE-STRING (SVREF *CARDINAL-PERIODS* PERIOD) STREAM))))
     [java] ; (DEFUN FORMAT-PRINT-ORDINAL (STREAM N) (WHEN (MINUSP N) (WRITE-STRING "negative " STREAM)) (LET ((NUMBER (ABS N))) (MULTIPLE-VALUE-BIND (TOP BOT) (TRUNCATE NUMBER 100) (UNLESS (ZEROP TOP) (FORMAT-PRINT-CARDINAL STREAM (- NUMBER BOT))) (WHEN (AND (PLUSP TOP) (PLUSP BOT)) (WRITE-CHAR #\  STREAM)) (MULTIPLE-VALUE-BIND (TENS ONES) (TRUNCATE BOT 10) (COND ((= BOT 12) (WRITE-STRING "twelfth" STREAM)) ((= TENS 1) (WRITE-STRING (SVREF *CARDINAL-TEENS* ONES) STREAM) (WRITE-STRING "th" STREAM)) ((AND (ZEROP TENS) (PLUSP ONES)) (WRITE-STRING (SVREF *ORDINAL-ONES* ONES) STREAM)) ((AND (ZEROP ONES) (PLUSP TENS)) (WRITE-STRING (SVREF *ORDINAL-TENS* TENS) STREAM)) ((PLUSP BOT) (WRITE-STRING (SVREF *CARDINAL-TENS* TENS) STREAM) (WRITE-CHAR #\- STREAM) (WRITE-STRING (SVREF *ORDINAL-ONES* ONES) STREAM)) ((PLUSP NUMBER) (WRITE-STRING "th" STREAM)) (T (WRITE-STRING "zeroth" STREAM)))))))
     [java] ; (DEFUN FORMAT-PRINT-OLD-ROMAN (STREAM N) (UNLESS (< 0 N 5000) (ERROR "Number too large to print in old Roman numerals: ~:D" N)) (DO ((CHAR-LIST (QUOTE (#\D #\C #\L #\X #\V #\I)) (CDR CHAR-LIST)) (VAL-LIST (QUOTE (500 100 50 10 5 1)) (CDR VAL-LIST)) (CUR-CHAR #\M (CAR CHAR-LIST)) (CUR-VAL 1000 (CAR VAL-LIST)) (START N (DO ((I START (PROGN (WRITE-CHAR CUR-CHAR STREAM) (- I CUR-VAL)))) ((< I CUR-VAL) I)))) ((ZEROP START))))
     [java] ; (DEFUN FORMAT-PRINT-ROMAN (STREAM N) (UNLESS (< 0 N 4000) (ERROR "Number too large to print in Roman numerals: ~:D" N)) (DO ((CHAR-LIST (QUOTE (#\D #\C #\L #\X #\V #\I)) (CDR CHAR-LIST)) (VAL-LIST (QUOTE (500 100 50 10 5 1)) (CDR VAL-LIST)) (SUB-CHARS (QUOTE (#\C #\X #\X #\I #\I)) (CDR SUB-CHARS)) (SUB-VAL (QUOTE (100 10 10 1 1 0)) (CDR SUB-VAL)) (CUR-CHAR #\M (CAR CHAR-LIST)) (CUR-VAL 1000 (CAR VAL-LIST)) (CUR-SUB-CHAR #\C (CAR SUB-CHARS)) (CUR-SUB-VAL 100 (CAR SUB-VAL)) (START N (DO ((I START (PROGN (WRITE-CHAR CUR-CHAR STREAM) (- I CUR-VAL)))) ((< I CUR-VAL) (COND ((<= (- CUR-VAL CUR-SUB-VAL) I) (WRITE-CHAR CUR-SUB-CHAR STREAM) (WRITE-CHAR CUR-CHAR STREAM) (- I (- CUR-VAL CUR-SUB-VAL))) (T I)))))) ((ZEROP START))))
     [java] ; (DEF-FORMAT-INTERPRETER #\P (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS NIL PARAMS (LET ((ARG (IF COLONP (IF (EQ ORIG-ARGS ARGS) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no previous argument") (DO ((ARG-PTR ORIG-ARGS (CDR ARG-PTR))) ((EQ (CDR ARG-PTR) ARGS) (CAR ARG-PTR)))) (NEXT-ARG)))) (IF ATSIGNP (WRITE-STRING (IF (EQL ARG 1) "y" "ies") STREAM) (UNLESS (EQL ARG 1) (WRITE-CHAR #\s STREAM))))))
     [java] ; (DEFUN DECIMAL-STRING (N) (WRITE-TO-STRING N :BASE 10 :RADIX NIL :ESCAPE NIL))
     [java] ; (DEF-FORMAT-INTERPRETER #\F (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the colon modifier with this directive")) (INTERPRET-BIND-DEFAULTS ((W NIL) (D NIL) (K NIL) (OVF NIL) (PAD #\ )) PARAMS (FORMAT-FIXED STREAM (NEXT-ARG) W D K OVF PAD ATSIGNP)))
     [java] ; (DEFUN FORMAT-FIXED (STREAM NUMBER W D K OVF PAD ATSIGN) (IF (NUMBERP NUMBER) (IF (FLOATP NUMBER) (FORMAT-FIXED-AUX STREAM NUMBER W D K OVF PAD ATSIGN) (IF (RATIONALP NUMBER) (FORMAT-FIXED-AUX STREAM (COERCE NUMBER (QUOTE SINGLE-FLOAT)) W D K OVF PAD ATSIGN) (FORMAT-WRITE-FIELD STREAM (DECIMAL-STRING NUMBER) W 1 0 #\  T))) (FORMAT-PRINC STREAM NUMBER NIL NIL W 1 0 PAD)))
     [java] ; (DEFUN FORMAT-FIXED-AUX (STREAM NUMBER W D K OVF PAD ATSIGN) (COND ((AND (FLOATP NUMBER) (OR (SYSTEM:FLOAT-INFINITY-P NUMBER) (SYSTEM:FLOAT-NAN-P NUMBER))) (PRIN1 NUMBER STREAM) NIL) (T (LET ((SPACELEFT W)) (WHEN (AND W (OR ATSIGN (MINUSP (FLOAT-SIGN NUMBER)))) (DECF SPACELEFT)) (MULTIPLE-VALUE-BIND (STR LEN LPOINT TPOINT) (SYSTEM::FLONUM-TO-STRING (ABS NUMBER) SPACELEFT D K) (WHEN (AND D (ZEROP D)) (SETF TPOINT NIL)) (WHEN W (DECF SPACELEFT LEN) (WHEN LPOINT (IF (OR (> SPACELEFT 0) TPOINT) (DECF SPACELEFT) (SETQ LPOINT NIL))) (WHEN TPOINT (IF (> SPACELEFT 0) (DECF SPACELEFT) (SETQ TPOINT NIL)))) (COND ((AND W (< SPACELEFT 0) OVF) (DOTIMES (I W) (WRITE-CHAR OVF STREAM)) T) (T (WHEN W (DOTIMES (I SPACELEFT) (WRITE-CHAR PAD STREAM))) (COND ((MINUSP (FLOAT-SIGN NUMBER)) (WRITE-CHAR #\- STREAM)) (ATSIGN (WRITE-CHAR #\+ STREAM))) (WHEN LPOINT (WRITE-CHAR #\0 STREAM)) (WRITE-STRING STR STREAM) (WHEN TPOINT (WRITE-CHAR #\0 STREAM)) NIL)))))))
     [java] ; (DEF-FORMAT-INTERPRETER #\E (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the colon modifier with this directive")) (INTERPRET-BIND-DEFAULTS ((W NIL) (D NIL) (E NIL) (K 1) (OVF NIL) (PAD #\ ) (MARK NIL)) PARAMS (FORMAT-EXPONENTIAL STREAM (NEXT-ARG) W D E K OVF PAD MARK ATSIGNP)))
     [java] ; (DEFUN FORMAT-EXPONENTIAL (STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (NUMBERP NUMBER) (IF (FLOATP NUMBER) (FORMAT-EXP-AUX STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (RATIONALP NUMBER) (FORMAT-EXP-AUX STREAM (COERCE NUMBER (QUOTE SINGLE-FLOAT)) W D E K OVF PAD MARKER ATSIGN) (FORMAT-WRITE-FIELD STREAM (DECIMAL-STRING NUMBER) W 1 0 #\  T))) (FORMAT-PRINC STREAM NUMBER NIL NIL W 1 0 PAD)))
     [java] ; (DEFUN FORMAT-EXPONENT-MARKER (NUMBER) (IF (TYPEP NUMBER *READ-DEFAULT-FLOAT-FORMAT*) #\e (TYPECASE NUMBER (SINGLE-FLOAT #\f) (DOUBLE-FLOAT #\d) (SHORT-FLOAT #\s) (LONG-FLOAT #\l))))
     [java] ; (DEFUN FORMAT-EXP-AUX (STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (AND (FLOATP NUMBER) (OR (SYSTEM:FLOAT-INFINITY-P NUMBER) (SYSTEM:FLOAT-NAN-P NUMBER))) (PRIN1 NUMBER STREAM) (MULTIPLE-VALUE-BIND (NUM EXPT) (SYSTEM::SCALE-EXPONENT (ABS NUMBER)) (LET* ((EXPT (- EXPT K)) (ESTR (DECIMAL-STRING (ABS EXPT))) (ELEN (IF E (MAX (LENGTH ESTR) E) (LENGTH ESTR))) (FDIG (IF D (IF (PLUSP K) (1+ (- D K)) D) NIL)) (FMIN (IF (MINUSP K) (- 1 K) NIL)) (SPACELEFT (IF W (- W 2 ELEN (IF (OR ATSIGN (MINUSP NUMBER)) 1 0)) NIL))) (IF (AND W OVF E (> ELEN E)) (DOTIMES (I W) (WRITE-CHAR OVF STREAM)) (MULTIPLE-VALUE-BIND (FSTR FLEN LPOINT) (SYSTEM::FLONUM-TO-STRING NUM SPACELEFT FDIG K FMIN) (WHEN W (DECF SPACELEFT FLEN) (WHEN LPOINT (IF (> SPACELEFT 0) (DECF SPACELEFT) (SETQ LPOINT NIL)))) (COND ((AND W (< SPACELEFT 0) OVF) (DOTIMES (I W) (WRITE-CHAR OVF STREAM))) (T (WHEN W (DOTIMES (I SPACELEFT) (WRITE-CHAR PAD STREAM))) (IF (MINUSP NUMBER) (WRITE-CHAR #\- STREAM) (IF ATSIGN (WRITE-CHAR #\+ STREAM))) (WHEN LPOINT (WRITE-CHAR #\0 STREAM)) (WRITE-STRING FSTR STREAM) (WRITE-CHAR (IF MARKER MARKER (FORMAT-EXPONENT-MARKER NUMBER)) STREAM) (WRITE-CHAR (IF (MINUSP EXPT) #\- #\+) STREAM) (WHEN E (DOTIMES (I (- E (LENGTH ESTR))) (WRITE-CHAR #\0 STREAM))) (WRITE-STRING ESTR STREAM)))))))))
     [java] ; (DEF-FORMAT-INTERPRETER #\G (COLONP ATSIGNP PARAMS) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the colon modifier with this directive")) (INTERPRET-BIND-DEFAULTS ((W NIL) (D NIL) (E NIL) (K NIL) (OVF NIL) (PAD #\ ) (MARK NIL)) PARAMS (FORMAT-GENERAL STREAM (NEXT-ARG) W D E K OVF PAD MARK ATSIGNP)))
     [java] ; (DEFUN FORMAT-GENERAL (STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (NUMBERP NUMBER) (IF (FLOATP NUMBER) (FORMAT-GENERAL-AUX STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (RATIONALP NUMBER) (FORMAT-GENERAL-AUX STREAM (COERCE NUMBER (QUOTE SINGLE-FLOAT)) W D E K OVF PAD MARKER ATSIGN) (FORMAT-WRITE-FIELD STREAM (DECIMAL-STRING NUMBER) W 1 0 #\  T))) (FORMAT-PRINC STREAM NUMBER NIL NIL W 1 0 PAD)))
     [java] ; (DEFUN FORMAT-GENERAL-AUX (STREAM NUMBER W D E K OVF PAD MARKER ATSIGN) (IF (AND (FLOATP NUMBER) (OR (SYSTEM:FLOAT-INFINITY-P NUMBER) (SYSTEM:FLOAT-NAN-P NUMBER))) (PRIN1 NUMBER STREAM) (MULTIPLE-VALUE-BIND (IGNORE N) (SYSTEM::SCALE-EXPONENT (ABS NUMBER)) (DECLARE (IGNORE IGNORE)) (UNLESS D (MULTIPLE-VALUE-BIND (STR LEN) (SYSTEM::FLONUM-TO-STRING (ABS NUMBER)) (DECLARE (IGNORE STR)) (LET ((Q (IF (= LEN 1) 1 (1- LEN)))) (SETQ D (MAX Q (MIN N 7)))))) (LET* ((EE (IF E (+ E 2) 4)) (WW (IF W (- W EE) NIL)) (DD (- D N))) (COND ((<= 0 DD D) (LET ((CHAR (IF (FORMAT-FIXED-AUX STREAM NUMBER WW DD NIL OVF PAD ATSIGN) OVF #\ ))) (DOTIMES (I EE) (WRITE-CHAR CHAR STREAM)))) (T (FORMAT-EXP-AUX STREAM NUMBER W D E (OR K 1) OVF PAD MARKER ATSIGN)))))))
     [java] ; (DEF-FORMAT-INTERPRETER #\$ (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS ((D 2) (N 1) (W 0) (PAD #\ )) PARAMS (FORMAT-DOLLARS STREAM (NEXT-ARG) D N W PAD COLONP ATSIGNP)))
     [java] ; (DEFUN FORMAT-DOLLARS (STREAM NUMBER D N W PAD COLON ATSIGN) (WHEN (RATIONALP NUMBER) (SETQ NUMBER (COERCE NUMBER (QUOTE SINGLE-FLOAT)))) (IF (FLOATP NUMBER) (LET* ((SIGNSTR (IF (MINUSP NUMBER) "-" (IF ATSIGN "+" ""))) (SIGNLEN (LENGTH SIGNSTR))) (MULTIPLE-VALUE-BIND (STR STRLEN IG2 IG3 POINTPLACE) (SYSTEM::FLONUM-TO-STRING NUMBER NIL D NIL) (DECLARE (IGNORE IG2 IG3 STRLEN)) (WHEN COLON (WRITE-STRING SIGNSTR STREAM)) (DOTIMES (I (- W SIGNLEN (MAX N POINTPLACE) 1 D)) (WRITE-CHAR PAD STREAM)) (UNLESS COLON (WRITE-STRING SIGNSTR STREAM)) (DOTIMES (I (- N POINTPLACE)) (WRITE-CHAR #\0 STREAM)) (WRITE-STRING STR STREAM))) (FORMAT-WRITE-FIELD STREAM (DECIMAL-STRING NUMBER) W 1 0 #\  T)))
     [java] ; (DEF-FORMAT-INTERPRETER #\% (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify either colon or atsign for this directive")) (INTERPRET-BIND-DEFAULTS ((COUNT 1)) PARAMS (DOTIMES (I COUNT) (TERPRI STREAM))))
     [java] ; (DEF-FORMAT-INTERPRETER #\& (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify either colon or atsign for this directive")) (INTERPRET-BIND-DEFAULTS ((COUNT 1)) PARAMS (FRESH-LINE STREAM) (DOTIMES (I (1- COUNT)) (TERPRI STREAM))))
     [java] ; (DEF-FORMAT-INTERPRETER #\| (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify either colon or atsign for this directive")) (INTERPRET-BIND-DEFAULTS ((COUNT 1)) PARAMS (DOTIMES (I COUNT) (WRITE-CHAR (CODE-CHAR SYSTEM::FORM-FEED-CHAR-CODE) STREAM))))
     [java] ; (DEF-FORMAT-INTERPRETER #\~ (COLONP ATSIGNP PARAMS) (WHEN (OR COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify either colon or atsign for this directive")) (INTERPRET-BIND-DEFAULTS ((COUNT 1)) PARAMS (DOTIMES (I COUNT) (WRITE-CHAR #\~ STREAM))))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\Newline (COLONP ATSIGNP PARAMS DIRECTIVES) (WHEN (AND COLONP ATSIGNP) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify both colon and atsign for this directive")) (INTERPRET-BIND-DEFAULTS NIL PARAMS (WHEN ATSIGNP (WRITE-CHAR #\Newline STREAM))) (IF (AND (NOT COLONP) DIRECTIVES (SIMPLE-STRING-P (CAR DIRECTIVES))) (CONS (STRING-LEFT-TRIM *FORMAT-WHITESPACE-CHARS* (CAR DIRECTIVES)) (CDR DIRECTIVES)) DIRECTIVES))
     [java] ; (DEF-FORMAT-INTERPRETER #\T (COLONP ATSIGNP PARAMS) (IF COLONP (INTERPRET-BIND-DEFAULTS ((N 1) (M 1)) PARAMS (PPRINT-TAB (IF ATSIGNP :SECTION-RELATIVE :SECTION) N M STREAM)) (IF ATSIGNP (INTERPRET-BIND-DEFAULTS ((COLREL 1) (COLINC 1)) PARAMS (FORMAT-RELATIVE-TAB STREAM COLREL COLINC)) (INTERPRET-BIND-DEFAULTS ((COLNUM 1) (COLINC 1)) PARAMS (FORMAT-ABSOLUTE-TAB STREAM COLNUM COLINC)))))
     [java] ; (DEFUN OUTPUT-SPACES (STREAM N) (LET ((SPACES "                                                                                                    ")) (LOOP (WHEN (< N (LENGTH SPACES)) (RETURN)) (WRITE-STRING SPACES STREAM) (DECF N (LENGTH SPACES))) (WRITE-STRING SPACES STREAM :END N)))
     [java] ; (DEFUN FORMAT-RELATIVE-TAB (STREAM COLREL COLINC) (IF (XP::XP-STRUCTURE-P STREAM) (PPRINT-TAB :LINE-RELATIVE COLREL COLINC STREAM) (LET* ((CUR (CHARPOS STREAM)) (SPACES (IF (AND CUR (PLUSP COLINC)) (- (* (CEILING (+ CUR COLREL) COLINC) COLINC) CUR) COLREL))) (OUTPUT-SPACES STREAM SPACES))))
     [java] ; (DEFUN FORMAT-ABSOLUTE-TAB (STREAM COLNUM COLINC) (IF (XP::XP-STRUCTURE-P STREAM) (PPRINT-TAB :LINE COLNUM COLINC STREAM) (LET ((CUR (CHARPOS STREAM))) (COND ((NULL CUR) (WRITE-STRING "  " STREAM)) ((< CUR COLNUM) (OUTPUT-SPACES STREAM (- COLNUM CUR))) (T (UNLESS (ZEROP COLINC) (OUTPUT-SPACES STREAM (- COLINC (REM (- CUR COLNUM) COLINC)))))))))
     [java] ; (DEF-FORMAT-INTERPRETER #\_ (COLONP ATSIGNP PARAMS) (INTERPRET-BIND-DEFAULTS NIL PARAMS (PPRINT-NEWLINE (IF COLONP (IF ATSIGNP :MANDATORY :FILL) (IF ATSIGNP :MISER :LINEAR)) STREAM)))
     [java] ; (DEF-FORMAT-INTERPRETER #\I (COLONP ATSIGNP PARAMS) (WHEN ATSIGNP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the at-sign modifier")) (INTERPRET-BIND-DEFAULTS ((N 0)) PARAMS (PPRINT-INDENT (IF COLONP :CURRENT :BLOCK) N STREAM)))
     [java] ; (DEF-FORMAT-INTERPRETER #\* (COLONP ATSIGNP PARAMS) (IF ATSIGNP (IF COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify both colon and at-sign") (INTERPRET-BIND-DEFAULTS ((POSN 0)) PARAMS (IF (<= 0 POSN (LENGTH ORIG-ARGS)) (SETF ARGS (NTHCDR POSN ORIG-ARGS)) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "Index ~W is out of bounds. (It should ~
     [java]                                               have been between 0 and ~W.)" :ARGS (LIST POSN (LENGTH ORIG-ARGS)))))) (IF COLONP (INTERPRET-BIND-DEFAULTS ((N 1)) PARAMS (DO ((CUR-POSN 0 (1+ CUR-POSN)) (ARG-PTR ORIG-ARGS (CDR ARG-PTR))) ((EQ ARG-PTR ARGS) (LET ((NEW-POSN (- CUR-POSN N))) (IF (<= 0 NEW-POSN (LENGTH ORIG-ARGS)) (SETF ARGS (NTHCDR NEW-POSN ORIG-ARGS)) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "Index ~W is out of bounds. (It should
     [java]                                                       have been between 0 and ~W.)" :ARGS (LIST NEW-POSN (LENGTH ORIG-ARGS)))))))) (INTERPRET-BIND-DEFAULTS ((N 1)) PARAMS (DOTIMES (I N) (NEXT-ARG))))))
     [java] ; (DEF-FORMAT-INTERPRETER #\? (COLONP ATSIGNP PARAMS STRING END) (WHEN COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the colon modifier")) (INTERPRET-BIND-DEFAULTS NIL PARAMS (HANDLER-BIND ((FORMAT-ERROR (LAMBDA (CONDITION) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~A~%while processing indirect format string:" :ARGS (LIST CONDITION) :PRINT-BANNER NIL :CONTROL-STRING STRING :OFFSET (1- END))))) (IF ATSIGNP (SETF ARGS (%FORMAT STREAM (NEXT-ARG) ORIG-ARGS ARGS)) (%FORMAT STREAM (NEXT-ARG) (NEXT-ARG))))))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\( (COLONP ATSIGNP PARAMS DIRECTIVES) (LET ((CLOSE (FIND-DIRECTIVE DIRECTIVES #\) NIL))) (UNLESS CLOSE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close paren")) (INTERPRET-BIND-DEFAULTS NIL PARAMS (LET* ((POSN (POSITION CLOSE DIRECTIVES)) (BEFORE (SUBSEQ DIRECTIVES 0 POSN)) (AFTER (NTHCDR (1+ POSN) DIRECTIVES)) (STREAM (SYSTEM::MAKE-CASE-FROB-STREAM (IF (TYPEP STREAM (QUOTE XP::XP-STRUCTURE)) (XP::BASE-STREAM STREAM) STREAM) (IF COLONP (IF ATSIGNP :UPCASE :CAPITALIZE) (IF ATSIGNP :CAPITALIZE-FIRST :DOWNCASE))))) (SETF ARGS (INTERPRET-DIRECTIVE-LIST STREAM BEFORE ORIG-ARGS ARGS)) AFTER))))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\) NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open paren"))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\[ (COLONP ATSIGNP PARAMS DIRECTIVES) (MULTIPLE-VALUE-BIND (SUBLISTS LAST-SEMI-WITH-COLON-P REMAINING) (PARSE-CONDITIONAL-DIRECTIVE DIRECTIVES) (SETF ARGS (IF ATSIGNP (IF COLONP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify both the colon and at-sign modifiers") (IF (CDR SUBLISTS) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "can only specify one section") (INTERPRET-BIND-DEFAULTS NIL PARAMS (LET ((PREV-ARGS ARGS) (ARG (NEXT-ARG))) (IF ARG (INTERPRET-DIRECTIVE-LIST STREAM (CAR SUBLISTS) ORIG-ARGS PREV-ARGS) ARGS))))) (IF COLONP (IF (= (LENGTH SUBLISTS) 2) (INTERPRET-BIND-DEFAULTS NIL PARAMS (IF (NEXT-ARG) (INTERPRET-DIRECTIVE-LIST STREAM (CAR SUBLISTS) ORIG-ARGS ARGS) (INTERPRET-DIRECTIVE-LIST STREAM (CADR SUBLISTS) ORIG-ARGS ARGS))) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "must specify exactly two sections")) (INTERPRET-BIND-DEFAULTS ((INDEX (NEXT-ARG))) PARAMS (LET* ((DEFAULT (AND LAST-SEMI-WITH-COLON-P (POP SUBLISTS))) (LAST (1- (LENGTH SUBLISTS))) (SUBLIST (IF (<= 0 INDEX LAST) (NTH (- LAST INDEX) SUBLISTS) DEFAULT))) (INTERPRET-DIRECTIVE-LIST STREAM SUBLIST ORIG-ARGS ARGS)))))) REMAINING))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\; NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~~; not contained within either ~~[...~~] or ~~<...~~>"))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\] NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open bracket"))
     [java] ; (DEFVAR *OUTSIDE-ARGS*)
     [java] ; (DEF-FORMAT-INTERPRETER #\^ (COLONP ATSIGNP PARAMS) (WHEN ATSIGNP (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "cannot specify the at-sign modifier")) (WHEN (AND COLONP (NOT *UP-UP-AND-OUT-ALLOWED*)) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "attempt to use ~~:^ outside a ~~:{...~~} construct")) (WHEN (INTERPRET-BIND-DEFAULTS ((ARG1 NIL) (ARG2 NIL) (ARG3 NIL)) PARAMS (COND (ARG3 (<= ARG1 ARG2 ARG3)) (ARG2 (EQL ARG1 ARG2)) (ARG1 (EQL ARG1 0)) (T (IF COLONP (NULL *OUTSIDE-ARGS*) (NULL ARGS))))) (THROW (IF COLONP (QUOTE UP-UP-AND-OUT) (QUOTE UP-AND-OUT)) ARGS)))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\{ (COLONP ATSIGNP PARAMS STRING END DIRECTIVES) (LET ((CLOSE (FIND-DIRECTIVE DIRECTIVES #\} NIL))) (UNLESS CLOSE (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding close brace")) (INTERPRET-BIND-DEFAULTS ((MAX-COUNT NIL)) PARAMS (LET* ((CLOSED-WITH-COLON (FORMAT-DIRECTIVE-COLONP CLOSE)) (POSN (POSITION CLOSE DIRECTIVES)) (INSIDES (IF (ZEROP POSN) (NEXT-ARG) (SUBSEQ DIRECTIVES 0 POSN))) (*UP-UP-AND-OUT-ALLOWED* COLONP)) (LABELS ((DO-GUTS (ORIG-ARGS ARGS) (IF (ZEROP POSN) (HANDLER-BIND ((FORMAT-ERROR (LAMBDA (CONDITION) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~A~%while processing indirect format string:" :ARGS (LIST CONDITION) :PRINT-BANNER NIL :CONTROL-STRING STRING :OFFSET (1- END))))) (%FORMAT STREAM INSIDES ORIG-ARGS ARGS)) (INTERPRET-DIRECTIVE-LIST STREAM INSIDES ORIG-ARGS ARGS))) (BIND-ARGS (ORIG-ARGS ARGS) (IF COLONP (LET* ((ARG (NEXT-ARG)) (*LOGICAL-BLOCK-POPPER* NIL) (*OUTSIDE-ARGS* ARGS)) (CATCH (QUOTE UP-AND-OUT) (DO-GUTS ARG ARG)) ARGS) (DO-GUTS ORIG-ARGS ARGS))) (DO-LOOP (ORIG-ARGS ARGS) (CATCH (IF COLONP (QUOTE UP-UP-AND-OUT) (QUOTE UP-AND-OUT)) (LOOP (WHEN (AND (NOT CLOSED-WITH-COLON) (NULL ARGS)) (RETURN)) (WHEN (AND MAX-COUNT (MINUSP (DECF MAX-COUNT))) (RETURN)) (SETF ARGS (BIND-ARGS ORIG-ARGS ARGS)) (WHEN (AND CLOSED-WITH-COLON (NULL ARGS)) (RETURN))) ARGS))) (IF ATSIGNP (SETF ARGS (DO-LOOP ORIG-ARGS ARGS)) (LET ((ARG (NEXT-ARG)) (*LOGICAL-BLOCK-POPPER* NIL)) (DO-LOOP ARG ARG))) (NTHCDR (1+ POSN) DIRECTIVES))))))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\} NIL (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "no corresponding open brace"))
     [java] ; (DEF-COMPLEX-FORMAT-INTERPRETER #\< (COLONP ATSIGNP PARAMS STRING END DIRECTIVES) (MULTIPLE-VALUE-BIND (SEGMENTS FIRST-SEMI CLOSE REMAINING) (PARSE-FORMAT-JUSTIFICATION DIRECTIVES) (SETF ARGS (IF (FORMAT-DIRECTIVE-COLONP CLOSE) (MULTIPLE-VALUE-BIND (PREFIX PER-LINE-P INSIDES SUFFIX) (PARSE-FORMAT-LOGICAL-BLOCK SEGMENTS COLONP FIRST-SEMI CLOSE PARAMS STRING END) (INTERPRET-FORMAT-LOGICAL-BLOCK STREAM ORIG-ARGS ARGS PREFIX PER-LINE-P INSIDES SUFFIX ATSIGNP)) (LET ((COUNT (REDUCE (FUNCTION +) (MAPCAR (LAMBDA (X) (COUNT-IF (FUNCTION ILLEGAL-INSIDE-JUSTIFICATION-P) X)) SEGMENTS)))) (WHEN (> COUNT 0) (ERROR (QUOTE FORMAT-ERROR) :COMPLAINT "~D illegal directive~:P found inside justification block" :ARGS (LIST COUNT))) (INTERPRET-FORMAT-JUSTIFICATION STREAM ORIG-ARGS ARGS SEGMENTS COLONP ATSIGNP FIRST-SEMI PARAMS)))) REMAINING))
     [java] ; (DEFUN INTERPRET-FORMAT-JUSTIFICATION (STREAM ORIG-ARGS ARGS SEGMENTS COLONP ATSIGNP FIRST-SEMI PARAMS) (INTERPRET-BIND-DEFAULTS ((MINCOL 0) (COLINC 1) (MINPAD 0) (PADCHAR #\ )) PARAMS (LET ((NEWLINE-STRING NIL) (STRINGS NIL) (EXTRA-SPACE 0) (LINE-LEN 0)) (SETF ARGS (CATCH (QUOTE UP-AND-OUT) (WHEN (AND FIRST-SEMI (FORMAT-DIRECTIVE-COLONP FIRST-SEMI)) (INTERPRET-BIND-DEFAULTS ((EXTRA 0) (LEN (OR 72))) (FORMAT-DIRECTIVE-PARAMS FIRST-SEMI) (SETF NEWLINE-STRING (WITH-OUTPUT-TO-STRING (STREAM) (SETF ARGS (INTERPRET-DIRECTIVE-LIST STREAM (POP SEGMENTS) ORIG-ARGS ARGS)))) (SETF EXTRA-SPACE EXTRA) (SETF LINE-LEN LEN))) (DOLIST (SEGMENT SEGMENTS) (PUSH (WITH-OUTPUT-TO-STRING (STREAM) (SETF ARGS (INTERPRET-DIRECTIVE-LIST STREAM SEGMENT ORIG-ARGS ARGS))) STRINGS)) ARGS)) (FORMAT-JUSTIFICATION STREAM NEWLINE-STRING EXTRA-SPACE LINE-LEN STRINGS COLONP ATSIGNP MINCOL COLINC MINPAD PADCHAR))) ARGS)
     [java] ; (DEFUN FORMAT-JUSTIFICATION (STREAM NEWLINE-PREFIX EXTRA-SPACE LINE-LEN STRINGS PAD-LEFT PAD-RIGHT MINCOL COLINC MINPAD PADCHAR) (SETF STRINGS (REVERSE STRINGS)) (LET* ((NUM-GAPS (+ (1- (LENGTH STRINGS)) (IF PAD-LEFT 1 0) (IF PAD-RIGHT 1 0))) (CHARS (+ (* NUM-GAPS MINPAD) (LOOP FOR STRING IN STRINGS SUMMING (LENGTH STRING)))) (LENGTH (IF (> CHARS MINCOL) (+ MINCOL (* (CEILING (- CHARS MINCOL) COLINC) COLINC)) MINCOL)) (PADDING (+ (- LENGTH CHARS) (* NUM-GAPS MINPAD)))) (WHEN (AND NEWLINE-PREFIX (> (+ (OR (CHARPOS STREAM) 0) LENGTH EXTRA-SPACE) LINE-LEN)) (WRITE-STRING NEWLINE-PREFIX STREAM)) (FLET ((DO-PADDING NIL (LET ((PAD-LEN (IF (ZEROP NUM-GAPS) PADDING (TRUNCATE PADDING NUM-GAPS)))) (DECF PADDING PAD-LEN) (DECF NUM-GAPS) (DOTIMES (I PAD-LEN) (WRITE-CHAR PADCHAR STREAM))))) (WHEN (OR PAD-LEFT (AND (NOT PAD-RIGHT) (NULL (CDR STRINGS)))) (DO-PADDING)) (WHEN STRINGS (WRITE-STRING (CAR STRINGS) STREAM) (DOLIST (STRING (CDR STRINGS)) (DO-PADDING) (WRITE-STRING STRING STREAM))) (WHEN PAD-RIGHT (DO-PADDING)))))
     [java] ; (DEFUN INTERPRET-FORMAT-LOGICAL-BLOCK (STREAM ORIG-ARGS ARGS PREFIX PER-LINE-P INSIDES SUFFIX ATSIGNP) (LET ((ARG (IF ATSIGNP ARGS (NEXT-ARG)))) (IF PER-LINE-P (PPRINT-LOGICAL-BLOCK (STREAM ARG :PER-LINE-PREFIX PREFIX :SUFFIX SUFFIX) (LET ((*LOGICAL-BLOCK-POPPER* (LAMBDA NIL (PPRINT-POP)))) (CATCH (QUOTE UP-AND-OUT) (INTERPRET-DIRECTIVE-LIST STREAM INSIDES (IF ATSIGNP ORIG-ARGS ARG) ARG)))) (PPRINT-LOGICAL-BLOCK (STREAM ARG :PREFIX PREFIX :SUFFIX SUFFIX) (LET ((*LOGICAL-BLOCK-POPPER* (LAMBDA NIL (PPRINT-POP)))) (CATCH (QUOTE UP-AND-OUT) (INTERPRET-DIRECTIVE-LIST STREAM INSIDES (IF ATSIGNP ORIG-ARGS ARG) ARG)))))) (IF ATSIGNP NIL ARGS))
     [java] ; (DEF-FORMAT-INTERPRETER #\/ (STRING START END COLONP ATSIGNP PARAMS) (LET ((SYMBOL (EXTRACT-USER-FUN-NAME STRING START END))) (COLLECT ((ARGS)) (DOLIST (PARAM-AND-OFFSET PARAMS) (LET ((PARAM (CDR PARAM-AND-OFFSET))) (CASE PARAM (:ARG (ARGS (NEXT-ARG))) (:REMAINING (ARGS (LENGTH ARGS))) (T (ARGS PARAM))))) (APPLY (FDEFINITION SYMBOL) STREAM (NEXT-ARG) COLONP ATSIGNP (ARGS)))))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE SYSTEM:SIMPLE-FORMAT)) (FUNCTION FORMAT))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/format.abcl (8.482 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/format.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/format.abcl (2.0 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/delete.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO REAL-COUNT (COUNT) (BACKQ-LIST (QUOTE COND) (BACKQ-CONS (BACKQ-LIST (QUOTE NULL) COUNT) (QUOTE (MOST-POSITIVE-FIXNUM))) (BACKQ-LIST (BACKQ-LIST (QUOTE FIXNUMP) COUNT) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) 0 COUNT)) (BACKQ-LIST (BACKQ-LIST (QUOTE INTEGERP) COUNT) (BACKQ-LIST* (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) (QUOTE (0 MOST-POSITIVE-FIXNUM)))) (BACKQ-LIST (QUOTE T) COUNT)))
     [java] ; (DEFMACRO MUMBLE-DELETE (PRED) (BACKQ-LIST (QUOTE DO) (QUOTE ((INDEX START (1+ INDEX)) (JNDEX START) (NUMBER-ZAPPED 0))) (QUOTE ((OR (= INDEX END) (= NUMBER-ZAPPED COUNT)) (DO ((INDEX INDEX (1+ INDEX)) (JNDEX JNDEX (1+ JNDEX))) ((= INDEX LENGTH) (SHRINK-VECTOR SEQUENCE JNDEX)) (ASET SEQUENCE JNDEX (AREF SEQUENCE INDEX))))) (QUOTE (ASET SEQUENCE JNDEX (AREF SEQUENCE INDEX))) (BACKQ-LIST* (QUOTE IF) PRED (QUOTE ((SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED)) (SETQ JNDEX (1+ JNDEX)))))))
     [java] ; (DEFMACRO MUMBLE-DELETE-FROM-END (PRED) (BACKQ-LIST (QUOTE DO) (QUOTE ((INDEX (1- END) (1- INDEX)) (NUMBER-ZAPPED 0) (LOSERS NIL) THIS-ELEMENT (TERMINUS (1- START)))) (QUOTE ((OR (= INDEX TERMINUS) (= NUMBER-ZAPPED COUNT)) (DO ((LOSERS LOSERS) (INDEX START (1+ INDEX)) (JNDEX START)) ((OR (NULL LOSERS) (= INDEX END)) (DO ((INDEX INDEX (1+ INDEX)) (JNDEX JNDEX (1+ JNDEX))) ((= INDEX LENGTH) (SHRINK-VECTOR SEQUENCE JNDEX)) (ASET SEQUENCE JNDEX (AREF SEQUENCE INDEX)))) (ASET SEQUENCE JNDEX (AREF SEQUENCE INDEX)) (IF (= INDEX (CAR LOSERS)) (POP LOSERS) (SETQ JNDEX (1+ JNDEX)))))) (QUOTE (SETQ THIS-ELEMENT (AREF SEQUENCE INDEX))) (BACKQ-LIST* (QUOTE WHEN) PRED (QUOTE ((SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED)) (PUSH INDEX LOSERS))))))
     [java] ; (DEFMACRO NORMAL-MUMBLE-DELETE NIL (QUOTE (MUMBLE-DELETE (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (FUNCALL-KEY KEY (AREF SEQUENCE INDEX)))) (FUNCALL TEST ITEM (FUNCALL-KEY KEY (AREF SEQUENCE INDEX)))))))
     [java] ; (DEFMACRO NORMAL-MUMBLE-DELETE-FROM-END NIL (QUOTE (MUMBLE-DELETE-FROM-END (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (FUNCALL-KEY KEY THIS-ELEMENT))) (FUNCALL TEST ITEM (FUNCALL-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO LIST-DELETE (PRED) (BACKQ-LIST (QUOTE LET) (QUOTE ((HANDLE (CONS NIL SEQUENCE)))) (BACKQ-LIST (QUOTE DO) (QUOTE ((CURRENT (NTHCDR START SEQUENCE) (CDR CURRENT)) (PREVIOUS (NTHCDR START HANDLE)) (INDEX START (1+ INDEX)) (NUMBER-ZAPPED 0))) (QUOTE ((OR (= INDEX END) (= NUMBER-ZAPPED COUNT)) (CDR HANDLE))) (BACKQ-LIST* (QUOTE COND) (BACKQ-CONS PRED (QUOTE ((RPLACD PREVIOUS (CDR CURRENT)) (SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED))))) (QUOTE ((T (SETQ PREVIOUS (CDR PREVIOUS)))))))))
     [java] ; (DEFMACRO LIST-DELETE-FROM-END (PRED) (BACKQ-LIST (QUOTE LET*) (QUOTE ((REVERSE (NREVERSE SEQUENCE)) (HANDLE (CONS NIL REVERSE)))) (BACKQ-LIST (QUOTE DO) (QUOTE ((CURRENT (NTHCDR (- LENGTH END) REVERSE) (CDR CURRENT)) (PREVIOUS (NTHCDR (- LENGTH END) HANDLE)) (INDEX START (1+ INDEX)) (NUMBER-ZAPPED 0))) (QUOTE ((OR (= INDEX END) (= NUMBER-ZAPPED COUNT)) (NREVERSE (CDR HANDLE)))) (BACKQ-LIST* (QUOTE COND) (BACKQ-CONS PRED (QUOTE ((RPLACD PREVIOUS (CDR CURRENT)) (SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED))))) (QUOTE ((T (SETQ PREVIOUS (CDR PREVIOUS)))))))))
     [java] ; (DEFMACRO NORMAL-LIST-DELETE NIL (QUOTE (LIST-DELETE (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (FUNCALL-KEY KEY (CAR CURRENT)))) (FUNCALL TEST ITEM (FUNCALL-KEY KEY (CAR CURRENT)))))))
     [java] ; (DEFMACRO NORMAL-LIST-DELETE-FROM-END NIL (QUOTE (LIST-DELETE-FROM-END (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (FUNCALL-KEY KEY (CAR CURRENT)))) (FUNCALL TEST ITEM (FUNCALL-KEY KEY (CAR CURRENT)))))))
     [java] ; (DEFUN DELETE (ITEM SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START 0) END COUNT KEY) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (NORMAL-LIST-DELETE-FROM-END) (NORMAL-LIST-DELETE)) (IF FROM-END (NORMAL-MUMBLE-DELETE-FROM-END) (NORMAL-MUMBLE-DELETE)) (APPLY (FUNCTION SEQUENCE:DELETE) ITEM SEQUENCE ARGS))))
     [java] ; (DEFMACRO IF-MUMBLE-DELETE NIL (QUOTE (MUMBLE-DELETE (FUNCALL PREDICATE (FUNCALL-KEY KEY (AREF SEQUENCE INDEX))))))
     [java] ; (DEFMACRO IF-MUMBLE-DELETE-FROM-END NIL (QUOTE (MUMBLE-DELETE-FROM-END (FUNCALL PREDICATE (FUNCALL-KEY KEY THIS-ELEMENT)))))
     [java] ; (DEFMACRO IF-LIST-DELETE NIL (QUOTE (LIST-DELETE (FUNCALL PREDICATE (FUNCALL-KEY KEY (CAR CURRENT))))))
     [java] ; (DEFMACRO IF-LIST-DELETE-FROM-END NIL (QUOTE (LIST-DELETE-FROM-END (FUNCALL PREDICATE (FUNCALL-KEY KEY (CAR CURRENT))))))
     [java] ; (DEFUN DELETE-IF (PREDICATE SEQUENCE &REST ARGS &KEY FROM-END (START 0) KEY END COUNT) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (IF-LIST-DELETE-FROM-END) (IF-LIST-DELETE)) (IF FROM-END (IF-MUMBLE-DELETE-FROM-END) (IF-MUMBLE-DELETE)) (APPLY (FUNCTION SEQUENCE:DELETE-IF) PREDICATE SEQUENCE ARGS))))
     [java] ; (DEFMACRO IF-NOT-MUMBLE-DELETE NIL (QUOTE (MUMBLE-DELETE (NOT (FUNCALL PREDICATE (FUNCALL-KEY KEY (AREF SEQUENCE INDEX)))))))
     [java] ; (DEFMACRO IF-NOT-MUMBLE-DELETE-FROM-END NIL (QUOTE (MUMBLE-DELETE-FROM-END (NOT (FUNCALL PREDICATE (FUNCALL-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO IF-NOT-LIST-DELETE NIL (QUOTE (LIST-DELETE (NOT (FUNCALL PREDICATE (FUNCALL-KEY KEY (CAR CURRENT)))))))
     [java] ; (DEFMACRO IF-NOT-LIST-DELETE-FROM-END NIL (QUOTE (LIST-DELETE-FROM-END (NOT (FUNCALL PREDICATE (FUNCALL-KEY KEY (CAR CURRENT)))))))
     [java] ; (DEFUN DELETE-IF-NOT (PREDICATE SEQUENCE &REST ARGS &KEY FROM-END (START 0) END KEY COUNT) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (IF-NOT-LIST-DELETE-FROM-END) (IF-NOT-LIST-DELETE)) (IF FROM-END (IF-NOT-MUMBLE-DELETE-FROM-END) (IF-NOT-MUMBLE-DELETE)) (APPLY (FUNCTION SEQUENCE:DELETE-IF-NOT) PREDICATE SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/delete.abcl (0.632 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/delete.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/delete.abcl (0.137 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/concatenate.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN CONCATENATE-TO-STRING (SEQUENCES) (DECLARE (OPTIMIZE SPEED (SAFETY 0))) (LET ((LENGTH 0)) (DECLARE (TYPE FIXNUM LENGTH)) (DOLIST (SEQ SEQUENCES) (INCF LENGTH (LENGTH SEQ))) (LET ((RESULT (MAKE-STRING LENGTH)) (I 0)) (DECLARE (TYPE INDEX I)) (DOLIST (SEQ SEQUENCES RESULT) (IF (STRINGP SEQ) (DOTIMES (J (LENGTH SEQ)) (DECLARE (TYPE INDEX J)) (SETF (SCHAR RESULT I) (CHAR (TRULY-THE STRING SEQ) J)) (INCF I)) (DOTIMES (J (LENGTH SEQ)) (DECLARE (TYPE INDEX J)) (SETF (SCHAR RESULT I) (ELT SEQ J)) (INCF I)))))))
     [java] ; (DEFUN CONCATENATE (RESULT-TYPE &REST SEQUENCES) (CASE RESULT-TYPE (LIST (LET ((RESULT NIL)) (DOLIST (SEQ SEQUENCES (NREVERSE RESULT)) (DOTIMES (I (LENGTH SEQ)) (PUSH (ELT SEQ I) RESULT))))) ((STRING SIMPLE-STRING) (CONCATENATE-TO-STRING SEQUENCES)) (T (LET* ((LENGTH (APPLY (QUOTE +) (MAPCAR (QUOTE LENGTH) SEQUENCES))) (RESULT (MAKE-SEQUENCE RESULT-TYPE LENGTH)) (I 0)) (DECLARE (TYPE INDEX I)) (DOLIST (SEQ SEQUENCES RESULT) (DOTIMES (J (LENGTH SEQ)) (SETF (ELT RESULT I) (ELT SEQ J)) (INCF I)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/concatenate.abcl (0.094 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/concatenate.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/concatenate.abcl (0.024 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/ldb.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN BYTE (SIZE POSITION) (CONS SIZE POSITION))
     [java] ; (DEFUN BYTE-SIZE (BYTESPEC) (CAR BYTESPEC))
     [java] ; (DEFUN BYTE-POSITION (BYTESPEC) (CDR BYTESPEC))
     [java] ; (DEFUN LDB (BYTESPEC INTEGER) (LOGAND (ASH INTEGER (- (BYTE-POSITION BYTESPEC))) (1- (ASH 1 (BYTE-SIZE BYTESPEC)))))
     [java] ; (DEFUN LDB-TEST (BYTESPEC INTEGER) (NOT (ZEROP (LDB BYTESPEC INTEGER))))
     [java] ; (DEFUN DPB (NEWBYTE BYTESPEC INTEGER) (LET* ((SIZE (BYTE-SIZE BYTESPEC)) (POSITION (BYTE-POSITION BYTESPEC)) (MASK (1- (ASH 1 SIZE)))) (LOGIOR (LOGAND INTEGER (LOGNOT (ASH MASK POSITION))) (ASH (LOGAND NEWBYTE MASK) POSITION))))
     [java] ; (DEFINE-SETF-EXPANDER LDB (BYTESPEC PLACE &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (IF (AND (CONSP BYTESPEC) (EQ (CAR BYTESPEC) (QUOTE BYTE))) (LET ((N-SIZE (GENSYM)) (N-POS (GENSYM)) (N-NEW (GENSYM))) (VALUES (LIST* N-SIZE N-POS DUMMIES) (LIST* (SECOND BYTESPEC) (THIRD BYTESPEC) VALS) (LIST N-NEW) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAR NEWVAL) (BACKQ-LIST (QUOTE DPB) N-NEW (BACKQ-LIST (QUOTE BYTE) N-SIZE N-POS) GETTER))) SETTER N-NEW) (BACKQ-LIST (QUOTE LDB) (BACKQ-LIST (QUOTE BYTE) N-SIZE N-POS) GETTER))) (LET ((BTEMP (GENSYM)) (GNUVAL (GENSYM))) (VALUES (CONS BTEMP DUMMIES) (CONS BYTESPEC VALS) (LIST GNUVAL) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAR NEWVAL) (BACKQ-LIST (QUOTE DPB) GNUVAL BTEMP GETTER))) SETTER GNUVAL) (BACKQ-LIST (QUOTE LDB) BTEMP GETTER))))))
     [java] ; (DEFUN %LDB (SIZE POSITION INTEGER) (LOGAND (ASH INTEGER (- POSITION)) (1- (ASH 1 SIZE))))
     [java] ; (DEFINE-SETF-EXPANDER %LDB (SIZE POSITION PLACE &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (LET ((N-SIZE (GENSYM)) (N-POS (GENSYM)) (N-NEW (GENSYM))) (VALUES (LIST* N-SIZE N-POS DUMMIES) (LIST* SIZE POSITION VALS) (LIST N-NEW) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAR NEWVAL) (BACKQ-LIST (QUOTE DPB) N-NEW (BACKQ-LIST (QUOTE BYTE) N-SIZE N-POS) GETTER))) SETTER N-NEW) (BACKQ-LIST (QUOTE LDB) (BACKQ-LIST (QUOTE BYTE) N-SIZE N-POS) GETTER)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ldb.abcl (0.147 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ldb.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ldb.abcl (0.044 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/destructuring-bind.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN PARSE-BODY (BODY &OPTIONAL (DOC-STRING-ALLOWED T)) (LET ((DECLS NIL) (DOC NIL)) (DO ((TAIL BODY (CDR TAIL))) ((ENDP TAIL) (VALUES TAIL (NREVERSE DECLS) DOC)) (LET ((FORM (CAR TAIL))) (COND ((AND (STRINGP FORM) (CDR TAIL)) (IF DOC-STRING-ALLOWED (SETQ DOC FORM DOC-STRING-ALLOWED NIL) (RETURN (VALUES TAIL (NREVERSE DECLS) DOC)))) ((NOT (AND (CONSP FORM) (SYMBOLP (CAR FORM)))) (RETURN (VALUES TAIL (NREVERSE DECLS) DOC))) ((EQ (CAR FORM) (QUOTE DECLARE)) (PUSH FORM DECLS)) (T (RETURN (VALUES TAIL (NREVERSE DECLS) DOC))))))))
     [java] ; (%DEFVAR (QUOTE *ARG-TESTS*) NIL)
     [java] ; (%DEFVAR (QUOTE *SYSTEM-LETS*) NIL)
     [java] ; (%DEFVAR (QUOTE *USER-LETS*) NIL)
     [java] ; (%DEFVAR (QUOTE *IGNORABLE-VARS*) NIL)
     [java] ; (%DEFVAR (QUOTE *ENV-VAR*) NIL)
     [java] ; (DEFUN ARG-COUNT-ERROR (ERROR-KIND NAME ARG LAMBDA-LIST MINIMUM MAXIMUM) (DECLARE (IGNORE ERROR-KIND ARG LAMBDA-LIST MINIMUM MAXIMUM)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Wrong number of arguments for ~S." :FORMAT-ARGUMENTS (LIST NAME)))
     [java] ; (DEFUN BOGUS-SUBLIST-ERROR (&KEY KIND NAME OBJECT LAMBDA-LIST) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Error while parsing arguments to ~A ~S:~%Bogus sublist:~%  ~S~%to satisfy lambda-list:~%  ~:S~%" :FORMAT-ARGUMENTS (LIST KIND NAME OBJECT LAMBDA-LIST)))
     [java] ; (DEFUN LAMBDA-LIST-BROKEN-KEY-LIST-ERROR (&KEY KIND NAME PROBLEM INFO) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL (CONCATENATE (QUOTE STRING) "Error while parsing arguments to ~A ~S:~%" (ECASE PROBLEM (:DOTTED-LIST "Keyword/value list is dotted: ~S") (:ODD-LENGTH "Odd number of elements in keyword/value list: ~S") (:DUPLICATE "Duplicate keyword: ~S") (:UNKNOWN-KEYWORD "~{Unknown keyword: ~S ; expected one of ~{~S~^, ~}~}"))) :FORMAT-ARGUMENTS (LIST KIND NAME INFO)))
     [java] ; (DEFUN PARSE-DEFMACRO (LAMBDA-LIST ARG-LIST-NAME BODY NAME CONTEXT &KEY (ANONYMOUSP NIL) (DOC-STRING-ALLOWED T) ((:ENVIRONMENT ENV-ARG-NAME)) (ERROR-FUN (QUOTE ERROR)) (WRAP-BLOCK T)) (MULTIPLE-VALUE-BIND (FORMS DECLARATIONS DOCUMENTATION) (PARSE-BODY BODY DOC-STRING-ALLOWED) (LET ((*ARG-TESTS* NIL) (*USER-LETS* NIL) (*SYSTEM-LETS* NIL) (*IGNORABLE-VARS* NIL) (*ENV-VAR* NIL)) (MULTIPLE-VALUE-BIND (ENV-ARG-USED MINIMUM MAXIMUM) (PARSE-DEFMACRO-LAMBDA-LIST LAMBDA-LIST ARG-LIST-NAME NAME CONTEXT ERROR-FUN (NOT ANONYMOUSP) NIL) (VALUES (BACKQ-LIST* (QUOTE LET*) (BACKQ-APPEND (WHEN ENV-ARG-USED (BACKQ-LIST (BACKQ-LIST *ENV-VAR* ENV-ARG-NAME))) (NREVERSE *SYSTEM-LETS*)) (BACKQ-APPEND (WHEN *IGNORABLE-VARS* (BACKQ-LIST (BACKQ-LIST (QUOTE DECLARE) (BACKQ-CONS (QUOTE IGNORABLE) *IGNORABLE-VARS*)))) *ARG-TESTS* (BACKQ-LIST (BACKQ-LIST* (QUOTE LET*) (NREVERSE *USER-LETS*) (BACKQ-APPEND DECLARATIONS (IF WRAP-BLOCK (BACKQ-LIST (BACKQ-LIST* (QUOTE BLOCK) (FDEFINITION-BLOCK-NAME NAME) FORMS)) FORMS)))))) (WHEN (AND ENV-ARG-NAME (NOT ENV-ARG-USED)) (BACKQ-LIST (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORE) ENV-ARG-NAME)))) DOCUMENTATION MINIMUM MAXIMUM)))))
     [java] ; (DEFUN DEFMACRO-ERROR (PROBLEM NAME) (ERROR (QUOTE TYPE-ERROR) "~S is not of type ~S~%" PROBLEM NAME))
     [java] ; (DEFUN VERIFY-KEYWORDS (KEY-LIST VALID-KEYS ALLOW-OTHER-KEYS) (DO ((ALREADY-PROCESSED NIL) (UNKNOWN-KEYWORD NIL) (REMAINING KEY-LIST (CDDR REMAINING))) ((NULL REMAINING) (IF (AND UNKNOWN-KEYWORD (NOT ALLOW-OTHER-KEYS) (NOT (LOOKUP-KEYWORD :ALLOW-OTHER-KEYS KEY-LIST))) (VALUES :UNKNOWN-KEYWORD (LIST UNKNOWN-KEYWORD VALID-KEYS)) (VALUES NIL NIL))) (COND ((NOT (AND (CONSP REMAINING) (LISTP (CDR REMAINING)))) (RETURN (VALUES :DOTTED-LIST KEY-LIST))) ((NULL (CDR REMAINING)) (RETURN (VALUES :ODD-LENGTH KEY-LIST))) ((OR (EQ (CAR REMAINING) :ALLOW-OTHER-KEYS) (MEMQL (CAR REMAINING) VALID-KEYS)) (PUSH (CAR REMAINING) ALREADY-PROCESSED)) (T (SETQ UNKNOWN-KEYWORD (CAR REMAINING))))))
     [java] ; (DEFUN LOOKUP-KEYWORD (KEYWORD KEY-LIST) (DO ((REMAINING KEY-LIST (CDDR REMAINING))) ((ENDP REMAINING)) (WHEN (EQ KEYWORD (CAR REMAINING)) (RETURN (CADR REMAINING)))))
     [java] ; (DEFUN KEYWORD-SUPPLIED-P (KEYWORD KEY-LIST) (DO ((REMAINING KEY-LIST (CDDR REMAINING))) ((ENDP REMAINING)) (WHEN (EQ KEYWORD (CAR REMAINING)) (RETURN T))))
     [java] ; (DEFUN DOT-LENGTH (CONS) (DO ((REST CONS (CDR REST)) (LENGTH 0 (1+ LENGTH))) ((OR (NULL REST) (ATOM REST)) LENGTH)))
     [java] ; (DEFUN PARSE-DEFMACRO-LAMBDA-LIST (LAMBDA-LIST ARG-LIST-NAME NAME ERROR-KIND ERROR-FUN &OPTIONAL TOP-LEVEL ENV-ILLEGAL) (LET* ((PATH-0 (IF TOP-LEVEL (BACKQ-LIST (QUOTE CDR) ARG-LIST-NAME) ARG-LIST-NAME)) (PATH PATH-0) (NOW-PROCESSING :REQUIRED) (MAXIMUM 0) (MINIMUM 0) (KEYS NIL) REST-NAME RESTP ALLOW-OTHER-KEYS-P ENV-ARG-USED) (WHEN (AND (DO ((LIST LAMBDA-LIST (CDR LIST))) ((ATOM LIST) NIL) (WHEN (EQ (CAR LIST) (QUOTE &WHOLE)) (RETURN T))) (NOT (EQ (CAR LAMBDA-LIST) (QUOTE &WHOLE)))) (ERROR "&Whole must appear first in ~S lambda-list." ERROR-KIND)) (DO ((REST-OF-ARGS LAMBDA-LIST (CDR REST-OF-ARGS))) ((ATOM REST-OF-ARGS) (COND ((NULL REST-OF-ARGS) NIL) (T (PUSH-LET-BINDING REST-OF-ARGS PATH NIL) (SETQ RESTP T)))) (LET ((VAR (CAR REST-OF-ARGS))) (COND ((EQ VAR (QUOTE &WHOLE)) (COND ((AND (CDR REST-OF-ARGS) (SYMBOLP (CADR REST-OF-ARGS))) (SETQ REST-OF-ARGS (CDR REST-OF-ARGS)) (PUSH-LET-BINDING (CAR REST-OF-ARGS) ARG-LIST-NAME NIL)) ((AND (CDR REST-OF-ARGS) (CONSP (CADR REST-OF-ARGS))) (POP REST-OF-ARGS) (LET* ((DESTRUCTURING-LAMBDA-LIST (CAR REST-OF-ARGS)) (SUB (GENSYM "WHOLE-SUBLIST"))) (PUSH-SUB-LIST-BINDING SUB ARG-LIST-NAME DESTRUCTURING-LAMBDA-LIST NAME ERROR-KIND ERROR-FUN) (PARSE-DEFMACRO-LAMBDA-LIST DESTRUCTURING-LAMBDA-LIST SUB NAME ERROR-KIND ERROR-FUN))) (T (DEFMACRO-ERROR "&WHOLE" NAME)))) ((EQ VAR (QUOTE &ENVIRONMENT)) (COND (ENV-ILLEGAL (ERROR "&ENVIRONMENT is not valid with ~S." ERROR-KIND)) ((NOT TOP-LEVEL) (ERROR "&ENVIRONMENT is only valid at top level of lambda list."))) (COND ((AND (CDR REST-OF-ARGS) (SYMBOLP (CADR REST-OF-ARGS))) (SETQ REST-OF-ARGS (CDR REST-OF-ARGS)) (SETQ *ENV-VAR* (CAR REST-OF-ARGS) ENV-ARG-USED T)) (T (DEFMACRO-ERROR "&ENVIRONMENT" ERROR-KIND NAME)))) ((OR (EQ VAR (QUOTE &REST)) (EQ VAR (QUOTE &BODY))) (COND ((AND (CDR REST-OF-ARGS) (SYMBOLP (CADR REST-OF-ARGS))) (SETQ REST-OF-ARGS (CDR REST-OF-ARGS)) (SETQ RESTP T) (PUSH-LET-BINDING (CAR REST-OF-ARGS) PATH NIL)) ((AND (CDR REST-OF-ARGS) (CONSP (CADR REST-OF-ARGS))) (POP REST-OF-ARGS) (SETQ RESTP T) (LET* ((DESTRUCTURING-LAMBDA-LIST (CAR REST-OF-ARGS)) (SUB (GENSYM "REST-SUBLIST"))) (PUSH-SUB-LIST-BINDING SUB PATH DESTRUCTURING-LAMBDA-LIST NAME ERROR-KIND ERROR-FUN) (PARSE-DEFMACRO-LAMBDA-LIST DESTRUCTURING-LAMBDA-LIST SUB NAME ERROR-KIND ERROR-FUN))) (T (DEFMACRO-ERROR (SYMBOL-NAME VAR) ERROR-KIND NAME)))) ((EQ VAR (QUOTE &OPTIONAL)) (SETQ NOW-PROCESSING :OPTIONALS)) ((EQ VAR (QUOTE &KEY)) (SETQ NOW-PROCESSING :KEYWORDS) (SETQ REST-NAME (GENSYM "KEYWORDS-")) (PUSH REST-NAME *IGNORABLE-VARS*) (SETQ RESTP T) (PUSH-LET-BINDING REST-NAME PATH T)) ((EQ VAR (QUOTE &ALLOW-OTHER-KEYS)) (SETQ ALLOW-OTHER-KEYS-P T)) ((EQ VAR (QUOTE &AUX)) (SETQ NOW-PROCESSING :AUXS)) ((LISTP VAR) (CASE NOW-PROCESSING (:REQUIRED (LET ((SUB-LIST-NAME (GENSYM "SUBLIST-"))) (PUSH-SUB-LIST-BINDING SUB-LIST-NAME (BACKQ-LIST (QUOTE CAR) PATH) VAR NAME ERROR-KIND ERROR-FUN) (PARSE-DEFMACRO-LAMBDA-LIST VAR SUB-LIST-NAME NAME ERROR-KIND ERROR-FUN)) (SETQ PATH (BACKQ-LIST (QUOTE CDR) PATH)) (INCF MINIMUM) (INCF MAXIMUM)) (:OPTIONALS (WHEN (> (LENGTH VAR) 3) (ERROR "more than variable, initform, and suppliedp in &optional binding ~S" VAR)) (PUSH-OPTIONAL-BINDING (CAR VAR) (CADR VAR) (CADDR VAR) (BACKQ-LIST (QUOTE NOT) (BACKQ-LIST (QUOTE NULL) PATH)) (BACKQ-LIST (QUOTE CAR) PATH) NAME ERROR-KIND ERROR-FUN) (SETQ PATH (BACKQ-LIST (QUOTE CDR) PATH)) (INCF MAXIMUM)) (:KEYWORDS (LET* ((KEYWORD-GIVEN (CONSP (CAR VAR))) (VARIABLE (IF KEYWORD-GIVEN (CADAR VAR) (CAR VAR))) (KEYWORD (IF KEYWORD-GIVEN (CAAR VAR) (MAKE-KEYWORD VARIABLE))) (SUPPLIED-P (CADDR VAR))) (PUSH-OPTIONAL-BINDING VARIABLE (CADR VAR) SUPPLIED-P (BACKQ-LIST (QUOTE KEYWORD-SUPPLIED-P) (BACKQ-LIST (QUOTE QUOTE) KEYWORD) REST-NAME) (BACKQ-LIST (QUOTE LOOKUP-KEYWORD) (BACKQ-LIST (QUOTE QUOTE) KEYWORD) REST-NAME) NAME ERROR-KIND ERROR-FUN) (PUSH KEYWORD KEYS))) (:AUXS (PUSH-LET-BINDING (CAR VAR) (CADR VAR) NIL)))) ((SYMBOLP VAR) (CASE NOW-PROCESSING (:REQUIRED (INCF MINIMUM) (INCF MAXIMUM) (PUSH-LET-BINDING VAR (BACKQ-LIST (QUOTE CAR) PATH) NIL) (SETQ PATH (BACKQ-LIST (QUOTE CDR) PATH))) (:OPTIONALS (INCF MAXIMUM) (PUSH-LET-BINDING VAR (BACKQ-LIST (QUOTE CAR) PATH) NIL (BACKQ-LIST (QUOTE NOT) (BACKQ-LIST (QUOTE NULL) PATH))) (SETQ PATH (BACKQ-LIST (QUOTE CDR) PATH))) (:KEYWORDS (LET ((KEY (MAKE-KEYWORD VAR))) (PUSH-LET-BINDING VAR (BACKQ-LIST (QUOTE LOOKUP-KEYWORD) KEY REST-NAME) NIL) (PUSH KEY KEYS))) (:AUXS (PUSH-LET-BINDING VAR NIL NIL)))) (T (ERROR "non-symbol in lambda-list: ~S" VAR))))) (UNLESS RESTP (PUSH (BACKQ-LIST (QUOTE UNLESS) (BACKQ-LIST* (QUOTE <=) MINIMUM (BACKQ-LIST (QUOTE LENGTH) PATH-0) (UNLESS RESTP (LIST MAXIMUM))) (IF (EQ ERROR-FUN (QUOTE ERROR)) (BACKQ-LIST (QUOTE ARG-COUNT-ERROR) (BACKQ-LIST (QUOTE QUOTE) ERROR-KIND) (BACKQ-LIST (QUOTE QUOTE) NAME) PATH-0 (BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) MINIMUM (UNLESS RESTP MAXIMUM)) (BACKQ-LIST* ERROR-FUN (QUOTE (QUOTE ARG-COUNT-ERROR)) (QUOTE :KIND) (BACKQ-LIST (QUOTE QUOTE) ERROR-KIND) (BACKQ-APPEND (WHEN NAME (BACKQ-LIST (QUOTE :NAME) (BACKQ-LIST (QUOTE QUOTE) NAME))) (BACKQ-LIST* (QUOTE :ARGUMENT) PATH-0 (QUOTE :LAMBDA-LIST) (BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST) (QUOTE :MINIMUM) MINIMUM (UNLESS RESTP (BACKQ-LIST (QUOTE :MAXIMUM) MAXIMUM))))))) *ARG-TESTS*)) (IF KEYS (LET ((PROBLEM (GENSYM "KEY-PROBLEM-")) (INFO (GENSYM "INFO-"))) (PUSH (BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) (BACKQ-LIST PROBLEM INFO) (BACKQ-LIST (QUOTE VERIFY-KEYWORDS) REST-NAME (BACKQ-LIST (QUOTE QUOTE) KEYS) (BACKQ-LIST (QUOTE QUOTE) ALLOW-OTHER-KEYS-P)) (BACKQ-LIST (QUOTE WHEN) PROBLEM (IF (EQ ERROR-FUN (QUOTE ERROR)) (BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE PROGRAM-ERROR)) "Unrecognized keyword argument ~S" (BACKQ-LIST (QUOTE CAR) INFO)) (BACKQ-LIST* ERROR-FUN (QUOTE (QUOTE DEFMACRO-LAMBDA-LIST-BROKEN-KEY-LIST-ERROR)) (QUOTE :KIND) (BACKQ-LIST (QUOTE QUOTE) ERROR-KIND) (BACKQ-APPEND (WHEN NAME (BACKQ-LIST (QUOTE :NAME) (BACKQ-LIST (QUOTE QUOTE) NAME))) (BACKQ-LIST (QUOTE :PROBLEM) PROBLEM (QUOTE :INFO) INFO)))))) *ARG-TESTS*))) (VALUES ENV-ARG-USED MINIMUM (IF (NULL RESTP) MAXIMUM NIL))))
     [java] ; (DEFUN PUSH-SUB-LIST-BINDING (VARIABLE PATH OBJECT NAME ERROR-KIND ERROR-FUN) (LET ((VAR (GENSYM "TEMP-"))) (PUSH (BACKQ-LIST VARIABLE (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR PATH)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE LISTP) VAR) VAR (BACKQ-LIST* ERROR-FUN (QUOTE (QUOTE DEFMACRO-BOGUS-SUBLIST-ERROR)) (QUOTE :KIND) (BACKQ-LIST (QUOTE QUOTE) ERROR-KIND) (BACKQ-APPEND (WHEN NAME (BACKQ-LIST (QUOTE :NAME) (BACKQ-LIST (QUOTE QUOTE) NAME))) (BACKQ-LIST (QUOTE :OBJECT) VAR (QUOTE :LAMBDA-LIST) (BACKQ-LIST (QUOTE QUOTE) OBJECT))))))) *SYSTEM-LETS*)))
     [java] ; (DEFUN PUSH-LET-BINDING (VARIABLE PATH SYSTEMP &OPTIONAL CONDITION (INIT-FORM NIL)) (LET ((LET-FORM (IF CONDITION (BACKQ-LIST VARIABLE (BACKQ-LIST (QUOTE IF) CONDITION PATH INIT-FORM)) (BACKQ-LIST VARIABLE PATH)))) (IF SYSTEMP (PUSH LET-FORM *SYSTEM-LETS*) (PUSH LET-FORM *USER-LETS*))))
     [java] ; (DEFUN PUSH-OPTIONAL-BINDING (VALUE-VAR INIT-FORM SUPPLIED-VAR CONDITION PATH NAME ERROR-KIND ERROR-FUN) (UNLESS SUPPLIED-VAR (SETQ SUPPLIED-VAR (GENSYM "SUPPLIEDP-"))) (PUSH-LET-BINDING SUPPLIED-VAR CONDITION T) (COND ((CONSP VALUE-VAR) (LET ((WHOLE-THING (GENSYM "OPTIONAL-SUBLIST-"))) (PUSH-SUB-LIST-BINDING WHOLE-THING (BACKQ-LIST (QUOTE IF) SUPPLIED-VAR PATH INIT-FORM) VALUE-VAR NAME ERROR-KIND ERROR-FUN) (PARSE-DEFMACRO-LAMBDA-LIST VALUE-VAR WHOLE-THING NAME ERROR-KIND ERROR-FUN))) ((SYMBOLP VALUE-VAR) (PUSH-LET-BINDING VALUE-VAR PATH NIL SUPPLIED-VAR INIT-FORM)) (T (ERROR "Illegal optional variable name: ~S" VALUE-VAR))))
     [java] ; (DEFMACRO DESTRUCTURING-BIND (LAMBDA-LIST ARG-LIST &REST BODY) (LET* ((ARG-LIST-NAME (GENSYM "ARG-LIST-"))) (MULTIPLE-VALUE-BIND (BODY LOCAL-DECLS) (PARSE-DEFMACRO LAMBDA-LIST ARG-LIST-NAME BODY NIL (QUOTE DESTRUCTURING-BIND) :ANONYMOUSP T :DOC-STRING-ALLOWED NIL :WRAP-BLOCK NIL) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST ARG-LIST-NAME ARG-LIST)) (BACKQ-APPEND LOCAL-DECLS (BACKQ-LIST BODY))))))
     [java] ; (DEFUN MAKE-MACRO-EXPANDER (DEFINITION) (LET* ((NAME (CAR DEFINITION)) (LAMBDA-LIST (CADR DEFINITION)) (FORM (GENSYM "WHOLE-")) (ENV (GENSYM "ENVIRONMENT-")) (BODY (PARSE-DEFMACRO LAMBDA-LIST FORM (CDDR DEFINITION) NAME (QUOTE DEFMACRO) :ENVIRONMENT ENV))) (BACKQ-LIST (QUOTE LAMBDA) (BACKQ-LIST FORM ENV) (BACKQ-LIST (QUOTE BLOCK) NAME BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/destructuring-bind.abcl (0.57 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/destructuring-bind.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/destructuring-bind.abcl (0.091 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/featurep.lisp ...
     [java] ; (IN-PACKAGE #:EXTENSIONS)
     [java] ; (DEFUN FEATUREP (FORM) (IF (ATOM FORM) (NOT (NULL (MEMQ FORM *FEATURES*))) (CASE (CAR FORM) ((:NOT NOT) (IF (CDDR FORM) (ERROR "Too many subexpressions in feature expression: ~S" FORM) (NOT (FEATUREP (CADR FORM))))) ((:AND AND) (DOLIST (SUBFORM (CDR FORM) T) (UNLESS (FEATUREP SUBFORM) (RETURN)))) ((:OR OR) (DOLIST (SUBFORM (CDR FORM) NIL) (WHEN (FEATUREP SUBFORM) (RETURN T)))) (T (ERROR "Unknown operator in feature expression: ~S" FORM)))))
     [java] ; (DEFUN OS-MACOSX-P NIL "Is the underlying operating system MacOS X?" (FEATUREP (QUOTE (:OR :DARWIN (:AND :ALLEGRO :MACOSX) (:AND :CLISP :MACOS)))))
     [java] ; (DEFUN OS-UNIX-P NIL "Is the underlying operating system some Unix variant?" (OR (FEATUREP (QUOTE (:OR :UNIX :CYGWIN))) (OS-MACOSX-P)))
     [java] ; (DEFUN OS-WINDOWS-P NIL "Is the underlying operating system Microsoft Windows?" (AND (NOT (OS-UNIX-P)) (FEATUREP (QUOTE (:OR :WIN32 :WINDOWS :MSWINDOWS :MINGW32 :MINGW64)))))
     [java] ; (DEFUN OS-GENERA-P NIL "Is the underlying operating system Genera (running on a Symbolics Lisp Machine)?" (FEATUREP :GENERA))
     [java] ; (DEFUN OS-OLDMAC-P NIL "Is the underlying operating system an (emulated?) MacOS 9 or earlier?" (FEATUREP :MCL))
     [java] ; (DEFUN OS-HAIKU-P NIL "Is the underlying operating system Haiku?" (FEATUREP :HAIKU))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/featurep.abcl (0.181 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/featurep.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/featurep.abcl (0.049 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/adjoin.lisp ...
     [java] ; (DEFUN ADJOIN (ITEM LIST &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) "Add `item' to `list' unless it is already a member (as determined by
     [java] the test function `test'." (WHEN (AND TESTP NOTP) (ERROR "test and test-not both supplied")) (IF (LET ((KEY-VAL (SYSTEM::APPLY-KEY KEY ITEM))) (IF NOTP (MEMBER KEY-VAL LIST :TEST-NOT TEST-NOT :KEY KEY) (MEMBER KEY-VAL LIST :TEST TEST :KEY KEY))) LIST (CONS ITEM LIST)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/adjoin.abcl (0.05 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/and.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO AND (&REST FORMS) (COND ((ENDP FORMS) T) ((ENDP (REST FORMS)) (FIRST FORMS)) (T (BACKQ-LIST* (QUOTE IF) (FIRST FORMS) (BACKQ-CONS (QUOTE AND) (REST FORMS)) (QUOTE (NIL))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/and.abcl (0.039 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/apropos.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN APROPOS-LIST (STRING-DESIGNATOR &OPTIONAL PACKAGE-DESIGNATOR &KEYS (EXTERNAL-ONLY NIL EXTERNAL-ONLY-SUPPLIED-P)) (APROPOS-LIST-EO STRING-DESIGNATOR PACKAGE-DESIGNATOR (AND EXTERNAL-ONLY-SUPPLIED-P EXTERNAL-ONLY)))
     [java] ; in (DEFUN APROPOS-LIST (STRING-DESIGNATOR &OPTIONAL PACKAGE-DESIGNATOR &KEYS (EXTERNAL-ONLY NIL EXTERNAL-ONLY-SUPPLIED-P)) (APROPOS-LIST-EO STRING-DESIGNATOR PACKAGE-DESIGNATOR (AND EXTERNAL-ONLY-SUPPLIED-P EXTERNAL-ONLY)))
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   The variable &KEYS is defined but never used.
     [java]
     [java] ; (DEFUN APROPOS (STRING-DESIGNATOR &OPTIONAL PACKAGE-DESIGNATOR &KEYS (EXTERNAL-ONLY NIL EXTERNAL-ONLY-SUPPLIED-P)) (APROPOS-EO STRING-DESIGNATOR PACKAGE-DESIGNATOR (AND EXTERNAL-ONLY-SUPPLIED-P EXTERNAL-ONLY)))
     [java] ; in (DEFUN APROPOS (STRING-DESIGNATOR &OPTIONAL PACKAGE-DESIGNATOR &KEYS (EXTERNAL-ONLY NIL EXTERNAL-ONLY-SUPPLIED-P)) (APROPOS-EO STRING-DESIGNATOR PACKAGE-DESIGNATOR (AND EXTERNAL-ONLY-SUPPLIED-P EXTERNAL-ONLY)))
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   The variable &KEYS is defined but never used.
     [java]
     [java] ; (DEFUN APROPOS-LIST-EO (STRING-DESIGNATOR PACKAGE-DESIGNATOR EXTERNAL-ONLY) (IF PACKAGE-DESIGNATOR (LET ((PACKAGE (FIND-PACKAGE PACKAGE-DESIGNATOR)) (STRING (STRING STRING-DESIGNATOR)) (RESULT NIL)) (DOLIST (SYMBOL (PACKAGE-EXTERNAL-SYMBOLS PACKAGE)) (DECLARE (TYPE SYMBOL SYMBOL)) (WHEN (SEARCH STRING (SYMBOL-NAME SYMBOL) :TEST (FUNCTION CHAR-EQUAL)) (PUSH SYMBOL RESULT))) (UNLESS EXTERNAL-ONLY (DOLIST (SYMBOL (PACKAGE-INTERNAL-SYMBOLS PACKAGE)) (DECLARE (TYPE SYMBOL SYMBOL)) (WHEN (SEARCH STRING (SYMBOL-NAME SYMBOL) :TEST (FUNCTION CHAR-EQUAL)) (PUSH SYMBOL RESULT)))) RESULT) (MAPCAN (LAMBDA (PACKAGE) (APROPOS-LIST-EO STRING-DESIGNATOR PACKAGE EXTERNAL-ONLY)) (LIST-ALL-PACKAGES))))
     [java] ; (DEFUN APROPOS-EO (STRING-DESIGNATOR PACKAGE-DESIGNATOR EXTERNAL-ONLY) (DOLIST (SYMBOL (REMOVE-DUPLICATES (APROPOS-LIST-EO STRING-DESIGNATOR PACKAGE-DESIGNATOR EXTERNAL-ONLY))) (FRESH-LINE) (PRIN1 SYMBOL) (WHEN (BOUNDP SYMBOL) (WRITE-STRING " (bound)")) (WHEN (FBOUNDP SYMBOL) (WRITE-STRING " (fbound)"))) (VALUES))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/apropos.abcl (0.136 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/arrays.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFCONSTANT ARRAY-TOTAL-SIZE-LIMIT MOST-POSITIVE-FIXNUM)
     [java] ; (DEFCONSTANT ARRAY-RANK-LIMIT 8)
     [java] ; (DEFUN MAKE-ARRAY (DIMENSIONS &KEY (ELEMENT-TYPE T) (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P) INITIAL-CONTENTS ADJUSTABLE FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET) (SETF ELEMENT-TYPE (NORMALIZE-TYPE ELEMENT-TYPE)) (%MAKE-ARRAY DIMENSIONS ELEMENT-TYPE INITIAL-ELEMENT INITIAL-ELEMENT-P INITIAL-CONTENTS ADJUSTABLE FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET))
     [java] ; (DEFUN ADJUST-ARRAY (ARRAY NEW-DIMENSIONS &KEY (ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ARRAY)) (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P) (INITIAL-CONTENTS NIL INITIAL-CONTENTS-P) FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET) (%ADJUST-ARRAY ARRAY NEW-DIMENSIONS ELEMENT-TYPE INITIAL-ELEMENT INITIAL-ELEMENT-P INITIAL-CONTENTS INITIAL-CONTENTS-P FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET))
     [java] ; (DEFUN ARRAY-ROW-MAJOR-INDEX (ARRAY &REST SUBSCRIPTS) (%ARRAY-ROW-MAJOR-INDEX ARRAY SUBSCRIPTS))
     [java] ; (DEFUN BIT (BIT-ARRAY &REST SUBSCRIPTS) (ROW-MAJOR-AREF BIT-ARRAY (%ARRAY-ROW-MAJOR-INDEX BIT-ARRAY SUBSCRIPTS)))
     [java] ; (DEFUN SBIT (SIMPLE-BIT-ARRAY &REST SUBSCRIPTS) (ROW-MAJOR-AREF SIMPLE-BIT-ARRAY (%ARRAY-ROW-MAJOR-INDEX SIMPLE-BIT-ARRAY SUBSCRIPTS)))
     [java] ; (DEFSETF ROW-MAJOR-AREF ASET)
     [java] ; (DEFSETF AREF ASET)
     [java] ; (DEFSETF BIT ASET)
     [java] ; (DEFSETF SBIT ASET)
     [java] ; (DEFUN (SETF AREF) (NEW-VALUE ARRAY &REST SUBSCRIPTS) (ASET ARRAY (%ARRAY-ROW-MAJOR-INDEX ARRAY SUBSCRIPTS) NEW-VALUE))
     [java] ; (DEFUN (SETF BIT) (NEW-VALUE ARRAY &REST SUBSCRIPTS) (ASET ARRAY (%ARRAY-ROW-MAJOR-INDEX ARRAY SUBSCRIPTS) NEW-VALUE))
     [java] ; (DEFUN (SETF SBIT) (NEW-VALUE ARRAY &REST SUBSCRIPTS) (ASET ARRAY (%ARRAY-ROW-MAJOR-INDEX ARRAY SUBSCRIPTS) NEW-VALUE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/arrays.abcl (0.173 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/assert.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO ASSERT (TEST-FORM &OPTIONAL PLACES DATUM &REST ARGUMENTS) "Signals an error if the value of test-form is nil.  Continuing from this
     [java]    error using the CONTINUE restart will allow the user to alter the value of
     [java]    some locations known to SETF and start over with test-form.  Returns nil." (BACKQ-LIST* (QUOTE LOOP) (BACKQ-LIST* (QUOTE WHEN) TEST-FORM (QUOTE ((RETURN NIL)))) (BACKQ-LIST* (QUOTE ASSERT-ERROR) (BACKQ-LIST (QUOTE QUOTE) TEST-FORM) (BACKQ-LIST (QUOTE QUOTE) PLACES) DATUM ARGUMENTS) (MAPCAR (FUNCTION (LAMBDA (PLACE) (BACKQ-LIST (QUOTE SETF) PLACE (BACKQ-LIST (QUOTE ASSERT-PROMPT) (BACKQ-LIST (QUOTE QUOTE) PLACE) PLACE)))) PLACES)))
     [java] ; (DEFUN ASSERT-ERROR (ASSERTION PLACES DATUM &REST ARGUMENTS) (DECLARE (IGNORE PLACES)) (LET ((C (IF DATUM (COERCE-TO-CONDITION DATUM ARGUMENTS (QUOTE SIMPLE-ERROR) (QUOTE ERROR)) (MAKE-CONDITION (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "The assertion ~S failed." :FORMAT-ARGUMENTS (LIST ASSERTION))))) (RESTART-CASE (ERROR C) (CONTINUE NIL :REPORT (LAMBDA (STREAM) (FORMAT STREAM "Retry assertion.")) NIL))))
     [java] ; (DEFUN ASSERT-PROMPT (NAME VALUE) (COND ((Y-OR-N-P "The old value of ~S is ~S.~%Do you want to supply a new value? " NAME VALUE) (FRESH-LINE *QUERY-IO*) (FORMAT *QUERY-IO* "Type a form to be evaluated:~%") (FLET ((READ-IT NIL (EVAL (READ *QUERY-IO*)))) (IF (SYMBOLP NAME) (PROGV (LIST NAME) (LIST VALUE) (READ-IT)) (READ-IT)))) (T VALUE)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/assert.abcl (0.212 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/assoc.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO ASSOC-GUTS (TEST-GUY) (BACKQ-LIST (QUOTE DO) (QUOTE ((ALIST ALIST (CDR ALIST)))) (QUOTE ((ENDP ALIST))) (BACKQ-LIST (QUOTE IF) (QUOTE (CAR ALIST)) (BACKQ-LIST* (QUOTE IF) TEST-GUY (QUOTE ((RETURN (CAR ALIST))))))))
     [java] ; (DEFUN ASSOC (ITEM ALIST &KEY KEY TEST TEST-NOT) (COND (TEST (IF KEY (ASSOC-GUTS (FUNCALL TEST ITEM (FUNCALL KEY (CAAR ALIST)))) (ASSOC-GUTS (FUNCALL TEST ITEM (CAAR ALIST))))) (TEST-NOT (IF KEY (ASSOC-GUTS (NOT (FUNCALL TEST-NOT ITEM (FUNCALL KEY (CAAR ALIST))))) (ASSOC-GUTS (NOT (FUNCALL TEST-NOT ITEM (CAAR ALIST)))))) (T (IF KEY (ASSOC-GUTS (EQL ITEM (FUNCALL KEY (CAAR ALIST)))) (ASSOC-GUTS (EQL ITEM (CAAR ALIST)))))))
     [java] ; (DEFUN ASSOC-IF (PREDICATE ALIST &KEY KEY) (IF KEY (ASSOC-GUTS (FUNCALL PREDICATE (FUNCALL KEY (CAAR ALIST)))) (ASSOC-GUTS (FUNCALL PREDICATE (CAAR ALIST)))))
     [java] ; (DEFUN ASSOC-IF-NOT (PREDICATE ALIST &KEY KEY) (IF KEY (ASSOC-GUTS (NOT (FUNCALL PREDICATE (FUNCALL KEY (CAAR ALIST))))) (ASSOC-GUTS (NOT (FUNCALL PREDICATE (CAAR ALIST))))))
     [java] ; (DEFUN RASSOC (ITEM ALIST &KEY KEY TEST TEST-NOT) (COND (TEST (IF KEY (ASSOC-GUTS (FUNCALL TEST ITEM (FUNCALL KEY (CDAR ALIST)))) (ASSOC-GUTS (FUNCALL TEST ITEM (CDAR ALIST))))) (TEST-NOT (IF KEY (ASSOC-GUTS (NOT (FUNCALL TEST-NOT ITEM (FUNCALL KEY (CDAR ALIST))))) (ASSOC-GUTS (NOT (FUNCALL TEST-NOT ITEM (CDAR ALIST)))))) (T (IF KEY (ASSOC-GUTS (EQL ITEM (FUNCALL KEY (CDAR ALIST)))) (ASSOC-GUTS (EQL ITEM (CDAR ALIST)))))))
     [java] ; (DEFUN RASSOC-IF (PREDICATE ALIST &KEY KEY) (IF KEY (ASSOC-GUTS (FUNCALL PREDICATE (FUNCALL KEY (CDAR ALIST)))) (ASSOC-GUTS (FUNCALL PREDICATE (CDAR ALIST)))))
     [java] ; (DEFUN RASSOC-IF-NOT (PREDICATE ALIST &KEY KEY) (IF KEY (ASSOC-GUTS (NOT (FUNCALL PREDICATE (FUNCALL KEY (CDAR ALIST))))) (ASSOC-GUTS (NOT (FUNCALL PREDICATE (CDAR ALIST))))))
     [java] ; (DEFUN ACONS (KEY DATUM ALIST) (CONS (CONS KEY DATUM) ALIST))
     [java] ; (DEFUN PAIRLIS (KEYS DATA &OPTIONAL (ALIST (QUOTE NIL))) (DO ((X KEYS (CDR X)) (Y DATA (CDR Y))) ((AND (ENDP X) (ENDP Y)) ALIST) (IF (OR (ENDP X) (ENDP Y)) (ERROR "the lists of keys and data are of unequal length")) (SETQ ALIST (ACONS (CAR X) (CAR Y) ALIST))))
     [java] ; (DEFUN COPY-ALIST (ALIST) "Return a new association list which is EQUAL to ALIST." (IF (ENDP ALIST) ALIST (LET ((RESULT (CONS (IF (ATOM (CAR ALIST)) (CAR ALIST) (CONS (CAAR ALIST) (CDAR ALIST))) NIL))) (DO ((X (CDR ALIST) (CDR X)) (SPLICE RESULT (CDR (RPLACD SPLICE (CONS (IF (ATOM (CAR X)) (CAR X) (CONS (CAAR X) (CDAR X))) NIL))))) ((ENDP X))) RESULT)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/assoc.abcl (0.337 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/aver.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN %FAILED-AVER (EXPR-AS-STRING) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "Failed AVER: ~S" :FORMAT-ARGUMENTS (LIST EXPR-AS-STRING)))
     [java] ; (DEFMACRO AVER (EXPR) (BACKQ-LIST (QUOTE UNLESS) EXPR (BACKQ-LIST (QUOTE %FAILED-AVER) (FORMAT NIL "~A" EXPR))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/aver.abcl (0.096 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/bit-array-ops.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN BIT-ARRAY-SAME-DIMENSIONS-P (ARRAY1 ARRAY2) (DECLARE (TYPE (ARRAY BIT) ARRAY1 ARRAY2)) (AND (= (ARRAY-RANK ARRAY1) (ARRAY-RANK ARRAY2)) (DOTIMES (INDEX (ARRAY-RANK ARRAY1) T) (WHEN (/= (ARRAY-DIMENSION ARRAY1 INDEX) (ARRAY-DIMENSION ARRAY2 INDEX)) (RETURN NIL)))))
     [java] ; (DEFUN REQUIRE-SAME-DIMENSIONS (ARRAY1 ARRAY2) (UNLESS (BIT-ARRAY-SAME-DIMENSIONS-P ARRAY1 ARRAY2) (ERROR (QUOTE PROGRAM-ERROR) "~S and ~S do not have the same dimensions." ARRAY1 ARRAY2)))
     [java] ; (DEFUN PICK-RESULT-ARRAY (RESULT-BIT-ARRAY BIT-ARRAY-1) (CASE RESULT-BIT-ARRAY ((T) BIT-ARRAY-1) ((NIL) (MAKE-ARRAY (ARRAY-DIMENSIONS BIT-ARRAY-1) :ELEMENT-TYPE (QUOTE BIT) :INITIAL-ELEMENT 0)) (T (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 RESULT-BIT-ARRAY) RESULT-BIT-ARRAY)))
     [java] ; (DEFUN BIT-AND (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-AND BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)))))))
     [java] ; (DEFUN BIT-IOR (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-IOR BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGIOR (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)))))))
     [java] ; (DEFUN BIT-XOR (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-XOR BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGXOR (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)))))))
     [java] ; (DEFUN BIT-EQV (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-EQV BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGEQV (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-NAND (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-NAND BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGNAND (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-NOR (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-NOR BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGNOR (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-ANDC1 (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-ANDC1 BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGANDC1 (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-ANDC2 (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-ANDC2 BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGANDC2 (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-ORC1 (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-ORC1 BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGORC1 (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-ORC2 (BIT-ARRAY-1 BIT-ARRAY-2 &OPTIONAL RESULT-BIT-ARRAY) (REQUIRE-SAME-DIMENSIONS BIT-ARRAY-1 BIT-ARRAY-2) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY-1))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY-1) (SIMPLE-BIT-VECTOR-P BIT-ARRAY-2) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-ORC2 BIT-ARRAY-1 BIT-ARRAY-2 RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGAND (LOGORC2 (ROW-MAJOR-AREF BIT-ARRAY-1 I) (ROW-MAJOR-AREF BIT-ARRAY-2 I)) 1))))))
     [java] ; (DEFUN BIT-NOT (BIT-ARRAY &OPTIONAL RESULT-BIT-ARRAY) (LET ((RESULT-BIT-ARRAY (PICK-RESULT-ARRAY RESULT-BIT-ARRAY BIT-ARRAY))) (IF (AND (SIMPLE-BIT-VECTOR-P BIT-ARRAY) (SIMPLE-BIT-VECTOR-P RESULT-BIT-ARRAY)) (%SIMPLE-BIT-VECTOR-BIT-NOT BIT-ARRAY RESULT-BIT-ARRAY) (DOTIMES (I (ARRAY-TOTAL-SIZE RESULT-BIT-ARRAY) RESULT-BIT-ARRAY) (SETF (ROW-MAJOR-AREF RESULT-BIT-ARRAY I) (LOGXOR (ROW-MAJOR-AREF BIT-ARRAY I) 1))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/bit-array-ops.abcl (0.454 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/boole.lisp ...
     [java] ; (DEFUN BOOLE (OP N1 N2) (UNLESS (AND (INTEGERP N1) (INTEGERP N2)) (ERROR (QUOTE TYPE-ERROR) :DATUM (IF (INTEGERP N1) N2 N1) :EXPECTED-TYPE (QUOTE INTEGER))) (CASE OP (0 0) (1 -1) (2 N1) (3 N2) (4 (LOGNOT N1)) (5 (LOGNOT N2)) (6 (LOGAND N1 N2)) (7 (LOGIOR N1 N2)) (8 (LOGXOR N1 N2)) (9 (LOGEQV N1 N2)) (10 (LOGNAND N1 N2)) (11 (LOGNOR N1 N2)) (12 (LOGANDC1 N1 N2)) (13 (LOGANDC2 N1 N2)) (14 (LOGORC1 N1 N2)) (15 (LOGORC2 N1 N2)) (T (ERROR (QUOTE TYPE-ERROR) :DATUM OP :EXPECTED-TYPE (LIST (QUOTE INTEGER) 0 15)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/boole.abcl (0.069 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/butlast.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFUN BUTLAST (LIST &OPTIONAL (N 1)) (UNLESS (AND (LISTP LIST) (TYPEP N (QUOTE (INTEGER 0)))) (ERROR (QUOTE TYPE-ERROR))) (UNLESS (NULL LIST) (LET ((LENGTH (DO ((LIST LIST (CDR LIST)) (I 0 (1+ I))) ((ATOM LIST) (1- I))))) (UNLESS (< LENGTH N) (DO* ((TOP (CDR LIST) (CDR TOP)) (RESULT (LIST (CAR LIST))) (SPLICE RESULT) (COUNT LENGTH (1- COUNT))) ((= COUNT N) RESULT) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR TOP))))))))))
     [java] ; (DEFUN NBUTLAST (LIST &OPTIONAL (N 1)) (UNLESS (AND (LISTP LIST) (TYPEP N (QUOTE (INTEGER 0)))) (ERROR (QUOTE TYPE-ERROR))) (UNLESS (NULL LIST) (LET ((LENGTH (DO ((LIST LIST (CDR LIST)) (I 0 (1+ I))) ((ATOM LIST) (1- I))))) (UNLESS (< LENGTH N) (DO ((1ST (CDR LIST) (CDR 1ST)) (2ND LIST 1ST) (COUNT LENGTH (1- COUNT))) ((= COUNT N) (RPLACD 2ND NIL) LIST))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/butlast.abcl (0.13 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/byte-io.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN WRITE-BYTE (BYTE STREAM) (DECLARE (TYPE STREAM STREAM)) (LET ((ELEMENT-TYPE (EXPAND-DEFTYPE (STREAM-ELEMENT-TYPE STREAM)))) (REQUIRE-TYPE BYTE ELEMENT-TYPE) (LET ((WIDTH (CADR ELEMENT-TYPE))) (IF (= WIDTH 8) (WRITE-8-BITS (THE (UNSIGNED-BYTE 8) BYTE) STREAM) (LET ((BYTES NIL)) (DOTIMES (I (/ WIDTH 8)) (PUSH (LOGAND BYTE 255) BYTES) (SETF BYTE (ASH BYTE -8))) (DOLIST (B BYTES) (WRITE-8-BITS (THE (UNSIGNED-BYTE 8) B) STREAM))))) BYTE))
     [java] ; (DEFUN READ-BYTE (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE) (DECLARE (TYPE STREAM STREAM)) (LET* ((ELEMENT-TYPE (EXPAND-DEFTYPE (STREAM-ELEMENT-TYPE STREAM)))) (UNLESS ELEMENT-TYPE (IF EOF-ERROR-P (ERROR (QUOTE END-OF-FILE) :STREAM STREAM) (RETURN-FROM READ-BYTE EOF-VALUE))) (UNLESS (CONSP ELEMENT-TYPE) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "READ-BYTE: unsupported element type ~S." :FORMAT-ARGUMENTS (LIST ELEMENT-TYPE))) (LET ((WIDTH (CADR ELEMENT-TYPE))) (IF (= WIDTH 8) (READ-8-BITS STREAM EOF-ERROR-P EOF-VALUE) (LET ((RESULT 0)) (DOTIMES (I (/ WIDTH 8)) (LET ((BYTE (READ-8-BITS STREAM EOF-ERROR-P EOF-VALUE))) (WHEN (EQ BYTE EOF-VALUE) (RETURN-FROM READ-BYTE EOF-VALUE)) (SETF RESULT (ASH RESULT 8)) (SETF RESULT (+ RESULT BYTE)))) (IF (AND (EQ (CAR ELEMENT-TYPE) (QUOTE SIGNED-BYTE)) (NOT (ZEROP (LOGAND RESULT (EXPT 2 (1- WIDTH)))))) (- RESULT (EXPT 2 WIDTH)) RESULT))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/byte-io.abcl (0.123 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/case.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LIST-OF-LENGTH-AT-LEAST-P (X N) (OR (ZEROP N) (AND (CONSP X) (LIST-OF-LENGTH-AT-LEAST-P (CDR X) (1- N)))))
     [java] ; (DEFUN CASE-BODY-ERROR (NAME KEYFORM KEYFORM-VALUE EXPECTED-TYPE KEYS) (DECLARE (IGNORE NAME KEYS)) (RESTART-CASE (ERROR (QUOTE TYPE-ERROR) :DATUM KEYFORM-VALUE :EXPECTED-TYPE EXPECTED-TYPE) (STORE-VALUE (VALUE) :REPORT (LAMBDA (STREAM) (FORMAT STREAM "Supply a new value for ~S." KEYFORM)) :INTERACTIVE READ-EVALUATED-FORM VALUE)))
     [java] ; (DEFUN CASE-BODY-AUX (NAME KEYFORM KEYFORM-VALUE CLAUSES KEYS ERRORP PROCEEDP EXPECTED-TYPE) (IF PROCEEDP (LET ((BLOCK (GENSYM)) (AGAIN (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST KEYFORM-VALUE KEYFORM)) (BACKQ-LIST (QUOTE BLOCK) BLOCK (BACKQ-LIST (QUOTE TAGBODY) AGAIN (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK (BACKQ-CONS (QUOTE COND) (BACKQ-APPEND (NREVERSE CLAUSES) (BACKQ-LIST (BACKQ-LIST (QUOTE T) (BACKQ-LIST (QUOTE SETF) KEYFORM-VALUE (BACKQ-LIST (QUOTE SETF) KEYFORM (BACKQ-LIST (QUOTE CASE-BODY-ERROR) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE QUOTE) KEYFORM) KEYFORM-VALUE (BACKQ-LIST (QUOTE QUOTE) EXPECTED-TYPE) (BACKQ-LIST (QUOTE QUOTE) KEYS)))) (BACKQ-LIST (QUOTE GO) AGAIN)))))))))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST KEYFORM-VALUE KEYFORM)) (BACKQ-CONS (QUOTE COND) (BACKQ-APPEND (NREVERSE CLAUSES) (IF ERRORP (BACKQ-LIST (BACKQ-LIST (QUOTE T) (BACKQ-LIST (QUOTE ERROR) (QUOTE (QUOTE TYPE-ERROR)) (QUOTE :DATUM) KEYFORM-VALUE (QUOTE :EXPECTED-TYPE) (BACKQ-LIST (QUOTE QUOTE) EXPECTED-TYPE))))))))))
     [java] ; (DEFUN CASE-BODY (NAME KEYFORM CASES MULTI-P TEST ERRORP PROCEEDP NEEDCASESP) (UNLESS (OR CASES (NOT NEEDCASESP)) (WARN "no clauses in ~S" NAME)) (LET ((KEYFORM-VALUE (GENSYM)) (CLAUSES NIL) (KEYS NIL)) (DO* ((CASES CASES (CDR CASES)) (CASE (CAR CASES) (CAR CASES))) ((NULL CASES) NIL) (UNLESS (LIST-OF-LENGTH-AT-LEAST-P CASE 1) (ERROR "~S -- bad clause in ~S" CASE NAME)) (DESTRUCTURING-BIND (KEYOID &REST FORMS) CASE (COND ((AND (MEMQ KEYOID (QUOTE (T OTHERWISE))) (NULL (CDR CASES))) (IF ERRORP (PROGN (STYLE-WARN "~@<Treating bare ~A in ~A as introducing a ~
     [java]                                   normal-clause, not an otherwise-clause~@:>" KEYOID NAME) (PUSH KEYOID KEYS) (PUSH (BACKQ-LIST* (BACKQ-LIST TEST KEYFORM-VALUE (BACKQ-LIST (QUOTE QUOTE) KEYOID)) NIL FORMS) CLAUSES)) (PUSH (BACKQ-LIST* (QUOTE T) NIL FORMS) CLAUSES))) ((AND MULTI-P (LISTP KEYOID)) (SETF KEYS (APPEND KEYOID KEYS)) (PUSH (BACKQ-LIST* (BACKQ-CONS (QUOTE OR) (MAPCAR (LAMBDA (KEY) (BACKQ-LIST TEST KEYFORM-VALUE (BACKQ-LIST (QUOTE QUOTE) KEY))) KEYOID)) NIL FORMS) CLAUSES)) (T (PUSH KEYOID KEYS) (PUSH (BACKQ-LIST* (BACKQ-LIST TEST KEYFORM-VALUE (BACKQ-LIST (QUOTE QUOTE) KEYOID)) NIL FORMS) CLAUSES))))) (CASE-BODY-AUX NAME KEYFORM KEYFORM-VALUE CLAUSES KEYS ERRORP PROCEEDP (BACKQ-CONS (IF MULTI-P (QUOTE MEMBER) (QUOTE OR)) KEYS))))
     [java] ; (DEFMACRO CASE (KEYFORM &BODY CASES) "CASE Keyform {({(Key*) | Key} Form*)}*
     [java]   Evaluates the Forms in the first clause with a Key EQL to the value of
     [java]   Keyform. If a singleton key is T then the clause is a default clause." (CASE-BODY (QUOTE CASE) KEYFORM CASES T (QUOTE EQL) NIL NIL NIL))
     [java] ; (DEFMACRO CCASE (KEYFORM &BODY CASES) "CCASE Keyform {({(Key*) | Key} Form*)}*
     [java]   Evaluates the Forms in the first clause with a Key EQL to the value of
     [java]   Keyform. If none of the keys matches then a correctable error is
     [java]   signalled." (CASE-BODY (QUOTE CCASE) KEYFORM CASES T (QUOTE EQL) T T T))
     [java] ; (DEFMACRO ECASE (KEYFORM &BODY CASES) "ECASE Keyform {({(Key*) | Key} Form*)}*
     [java]   Evaluates the Forms in the first clause with a Key EQL to the value of
     [java]   Keyform. If none of the keys matches then an error is signalled." (CASE-BODY (QUOTE ECASE) KEYFORM CASES T (QUOTE EQL) T NIL T))
     [java] ; (DEFMACRO TYPECASE (KEYFORM &BODY CASES) "TYPECASE Keyform {(Type Form*)}*
     [java]   Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
     [java]   is true." (CASE-BODY (QUOTE TYPECASE) KEYFORM CASES NIL (QUOTE TYPEP) NIL NIL NIL))
     [java] ; (DEFMACRO CTYPECASE (KEYFORM &BODY CASES) "CTYPECASE Keyform {(Type Form*)}*
     [java]   Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
     [java]   is true. If no form is satisfied then a correctable error is signalled." (CASE-BODY (QUOTE CTYPECASE) KEYFORM CASES NIL (QUOTE TYPEP) T T T))
     [java] ; (DEFMACRO ETYPECASE (KEYFORM &BODY CASES) "ETYPECASE Keyform {(Type Form*)}*
     [java]   Evaluates the Forms in the first clause for which TYPEP of Keyform and Type
     [java]   is true. If no form is satisfied then an error is signalled." (CASE-BODY (QUOTE ETYPECASE) KEYFORM CASES NIL (QUOTE TYPEP) T NIL T))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/case.abcl (0.307 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/chars.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN CHAR/= (CHARACTER &REST MORE-CHARACTERS) (DO* ((HEAD CHARACTER (CAR LIST)) (LIST MORE-CHARACTERS (CDR LIST))) ((ATOM LIST) T) (UNLESS (DO* ((L LIST (CDR L))) ((ATOM L) T) (IF (EQL HEAD (CAR L)) (RETURN NIL))) (RETURN NIL))))
     [java] ; (DEFUN CHAR> (CHARACTER &REST MORE-CHARACTERS) (DO* ((C CHARACTER (CAR LIST)) (LIST MORE-CHARACTERS (CDR LIST))) ((ATOM LIST) T) (UNLESS (> (CHAR-INT C) (CHAR-INT (CAR LIST))) (RETURN NIL))))
     [java] ; (DEFUN CHAR>= (CHARACTER &REST MORE-CHARACTERS) (DO* ((C CHARACTER (CAR LIST)) (LIST MORE-CHARACTERS (CDR LIST))) ((ATOM LIST) T) (UNLESS (>= (CHAR-INT C) (CHAR-INT (CAR LIST))) (RETURN NIL))))
     [java] ; (DEFMACRO EQUAL-CHAR-CODE (CHARACTER) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE CH) (BACKQ-LIST (QUOTE CHAR-CODE) CHARACTER))) (QUOTE ((IF (< 96 CH 123) (- CH 32) CH)))))
     [java] ; (DEFUN CHAR-NOT-EQUAL (CHARACTER &REST MORE-CHARACTERS) (DO* ((HEAD CHARACTER (CAR LIST)) (LIST MORE-CHARACTERS (CDR LIST))) ((ATOM LIST) T) (UNLESS (DO* ((L LIST (CDR L))) ((ATOM L) T) (IF (= (EQUAL-CHAR-CODE HEAD) (EQUAL-CHAR-CODE (CAR L))) (RETURN NIL))) (RETURN NIL))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/chars.abcl (0.109 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/check-type.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO CHECK-TYPE (PLACE TYPE &OPTIONAL TYPE-STRING) (LET ((PLACE-VALUE (GENSYM))) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST PLACE-VALUE PLACE)) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST (QUOTE TYPEP) PLACE-VALUE (BACKQ-LIST (QUOTE QUOTE) TYPE)) (QUOTE ((RETURN NIL)))) (BACKQ-LIST (QUOTE SETF) PLACE (BACKQ-LIST (QUOTE CHECK-TYPE-ERROR) (BACKQ-LIST (QUOTE QUOTE) PLACE) PLACE-VALUE (BACKQ-LIST (QUOTE QUOTE) TYPE) TYPE-STRING))))))
     [java] ; (DEFUN CHECK-TYPE-ERROR (PLACE PLACE-VALUE TYPE TYPE-STRING) (LET ((COND (IF TYPE-STRING (MAKE-CONDITION (QUOTE SIMPLE-TYPE-ERROR) :DATUM PLACE-VALUE :EXPECTED-TYPE TYPE :FORMAT-CONTROL "The value of ~S is ~S, which is not ~A." :FORMAT-ARGUMENTS (LIST PLACE PLACE-VALUE TYPE-STRING)) (MAKE-CONDITION (QUOTE SIMPLE-TYPE-ERROR) :DATUM PLACE-VALUE :EXPECTED-TYPE TYPE :FORMAT-CONTROL "The value of ~S is ~S, which is not of type ~S." :FORMAT-ARGUMENTS (LIST PLACE PLACE-VALUE TYPE))))) (RESTART-CASE (ERROR COND) (STORE-VALUE (VALUE) :REPORT (LAMBDA (STREAM) (FORMAT STREAM "Supply a new value for ~S." PLACE)) :INTERACTIVE READ-EVALUATED-FORM VALUE))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/check-type.abcl (0.143 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compile-file-pathname.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN CFP-OUTPUT-FILE-DEFAULT (INPUT-FILE) (LET* ((DEFAULTS (MERGE-PATHNAMES INPUT-FILE *DEFAULT-PATHNAME-DEFAULTS*)) (RETYPED (MAKE-PATHNAME :TYPE *COMPILE-FILE-TYPE* :DEFAULTS DEFAULTS))) RETYPED))
     [java] ; (DEFUN COMPILE-FILE-PATHNAME (INPUT-FILE &KEY (OUTPUT-FILE (CFP-OUTPUT-FILE-DEFAULT INPUT-FILE)) &ALLOW-OTHER-KEYS) (MERGE-PATHNAMES OUTPUT-FILE (MERGE-PATHNAMES INPUT-FILE) NIL))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compile-file-pathname.abcl (0.056 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compile-system.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN CHECK-LISP-HOME NIL (LOOP (COND ((AND *LISP-HOME* (PROBE-DIRECTORY (PATHNAME *LISP-HOME*))) (RETURN)) (T (CERROR "Continue" "*LISP-HOME* is NIL or invalid.~%  Please set *LISP-HOME* to the full pathname of the directory containing the Lisp system files.")))))
     [java] ; (DEFUN GROVEL-JAVA-DEFINITIONS-IN-FILE (FILE OUT) (WITH-OPEN-FILE (IN FILE) (DECLARE (TYPE STREAM IN)) (LET ((SYSTEM-PACKAGE (FIND-PACKAGE "SYSTEM")) (LINE-NUMBER 1)) (LOOP (LET ((TEXT (READ-LINE IN NIL))) (WHEN (NULL TEXT) (RETURN)) (LET ((POSITION (SEARCH "###" TEXT))) (WHEN POSITION (LET* ((NAME (STRING (READ-FROM-STRING (SUBSEQ TEXT (+ POSITION 3))))) (SYMBOL (OR (FIND-SYMBOL NAME SYSTEM-PACKAGE) (FIND-SYMBOL NAME (FIND-PACKAGE "MOP")) (FIND-SYMBOL NAME (FIND-PACKAGE "JAVA"))))) (WHEN SYMBOL (%FORMAT OUT "~A::~A ~S ~S~%" (PACKAGE-NAME (SYMBOL-PACKAGE SYMBOL)) NAME FILE LINE-NUMBER))))) (INCF LINE-NUMBER))))))
     [java] ; (DEFUN GROVEL-JAVA-DEFINITIONS NIL (CHECK-LISP-HOME) (TIME (LET ((FILES (DIRECTORY (MERGE-PATHNAMES "*.java" *LISP-HOME*)))) (WITH-OPEN-FILE (STREAM (MERGE-PATHNAMES "tags" *LISP-HOME*) :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE) (DOLIST (FILE FILES) (GROVEL-JAVA-DEFINITIONS-IN-FILE FILE STREAM))))))
     [java] ; (DEFUN PACKAGES-FROM-COMBOS (COMBOS) (REMOVE-DUPLICATES (MAPCAR (FUNCTION SYMBOL-PACKAGE) (MAPCAR (FUNCTION FDEFINITION-BLOCK-NAME) (MAPCAR (FUNCTION SECOND) COMBOS)))))
     [java] ; (DEFUN REMOVE-MULTI-COMBO-SYMBOLS (COMBOS) (PRINC "; Removing multi-homed symbols") (LET ((SYM-HASH (MAKE-HASH-TABLE :SIZE (* 2 (LENGTH COMBOS))))) (DOLIST (COMBO COMBOS) (INCF (GETHASH (SECOND COMBO) SYM-HASH 0))) (PRINT (REMOVE-IF-NOT (LAMBDA (X) (< 1 (GETHASH X SYM-HASH))) COMBOS :KEY (FUNCTION SECOND))) (REMOVE-IF (LAMBDA (X) (< 1 (GETHASH X SYM-HASH))) COMBOS :KEY (FUNCTION SECOND))))
     [java] ; (DEFUN SET-EQUAL (SET1 SET2 &KEY TEST) (OR (EQ SET1 SET2) (EQUAL SET1 SET2) (AND (SUBSETP SET2 SET1 :TEST TEST) (SUBSETP SET1 SET2 :TEST TEST))))
     [java] ; (DEFUN COMBOS-TO-SYMBOL-FILESETS (COMBOS) (LET (FILESETS) (DOLIST (COMBO COMBOS) (PUSHNEW (LIST (SECOND COMBO)) FILESETS :TEST (FUNCTION EQUAL) :KEY (FUNCTION FIRST)) (PUSHNEW (FIRST COMBO) (CDR (ASSOC (SECOND COMBO) FILESETS :TEST (FUNCTION EQUAL))) :TEST (FUNCTION STRING=))) FILESETS))
     [java] ; (DEFUN COMBOS-TO-FILESET-SYMBOLS (COMBOS) (LET (FILESET-SYMBOLS) (DOLIST (SYMBOL-FILESET (COMBOS-TO-SYMBOL-FILESETS COMBOS)) (PUSHNEW (LIST (CDR SYMBOL-FILESET)) FILESET-SYMBOLS :TEST (LAMBDA (X Y) (SET-EQUAL X Y :TEST (FUNCTION STRING=))) :KEY (FUNCTION FIRST)) (PUSHNEW (FIRST SYMBOL-FILESET) (CDR (ASSOC (CDR SYMBOL-FILESET) FILESET-SYMBOLS :TEST (LAMBDA (X Y) (SET-EQUAL X Y :TEST (FUNCTION STRING=))))))) FILESET-SYMBOLS))
     [java] ; (DEFUN WRITE-AUTOLOADER (STREAM PACKAGE TYPE FILESET-SYMBOLS) (WHEN FILESET-SYMBOLS (WRITE (BACKQ-LIST (QUOTE IN-PACKAGE) PACKAGE) :STREAM STREAM) (TERPRI STREAM) (LET ((*PACKAGE* (FIND-PACKAGE PACKAGE))) (WRITE (BACKQ-LIST (QUOTE DOLIST) (BACKQ-LIST (QUOTE FS) (BACKQ-LIST (QUOTE QUOTE) FILESET-SYMBOLS)) (BACKQ-LIST* (QUOTE FUNCALL) (BACKQ-LIST (QUOTE FUNCTION) TYPE) (QUOTE ((CDR FS) (CAR (CAR FS)))))) :STREAM STREAM) (TERPRI STREAM))))
     [java] ; (DEFUN WRITE-PACKAGE-FILESETS (STREAM PACKAGE TYPE FILESETS-SYMBOLS) (LET* ((FILTER-PACKAGE (FIND-PACKAGE PACKAGE)) (FILTERED-FILESETS (REMOVE-IF (LAMBDA (X) (NULL (CDR X))) (MAPCAR (LAMBDA (X) (CONS (CAR X) (REMOVE-IF-NOT (LAMBDA (X) (AND (SYMBOLP X) (EQ (SYMBOL-PACKAGE X) FILTER-PACKAGE))) (CDR X)))) FILESETS-SYMBOLS)))) (WRITE-AUTOLOADER STREAM PACKAGE TYPE FILTERED-FILESETS)))
     [java] ; (DEFUN LOAD-COMBOS (PATH-SPEC) (LET (ALL-FUNCTIONS) (DOLIST (FUNCTIONS-FILE (DIRECTORY PATH-SPEC) ALL-FUNCTIONS) (LET ((BASE-NAME (PATHNAME-NAME FUNCTIONS-FILE))) (UNLESS (MEMBER BASE-NAME (QUOTE ("asdf" "gray-streams")) :TEST (FUNCTION STRING=)) (WITH-OPEN-FILE (F FUNCTIONS-FILE :DIRECTION :INPUT) (DOLIST (FUNCTION-NAME (READ F)) (PUSH (LIST BASE-NAME FUNCTION-NAME) ALL-FUNCTIONS))))))))
     [java] ; (DEFUN GENERATE-AUTOLOADS (SYMBOL-FILES-PATHSPEC) (LABELS ((FILTER-COMBOS (COMBOS) (REMOVE-MULTI-COMBO-SYMBOLS (REMOVE-IF (LAMBDA (X) (MEMBER X (QUOTE ("fdefinition" "early-defuns" "require" "signal" "restart" "extensible-sequences-base" "extensible-sequences" "java-collections" "macros" "precompiler")) :TEST (FUNCTION STRING=))) COMBOS :KEY (FUNCTION FIRST)))) (FILTER-SETF-COMBOS (COMBOS) (FILTER-COMBOS (REMOVE-MULTI-COMBO-SYMBOLS (REMOVE-IF (LAMBDA (X) (MEMBER X (QUOTE ("clos")) :TEST (FUNCTION STRING=))) COMBOS :KEY (FUNCTION FIRST))))) (SYMBOLS-PATHSPEC (FILESPEC) (MERGE-PATHNAMES FILESPEC SYMBOL-FILES-PATHSPEC))) (LET ((FUNCS (FILTER-COMBOS (LOAD-COMBOS (SYMBOLS-PATHSPEC "*.funcs")))) (MACS (FILTER-COMBOS (LOAD-COMBOS (SYMBOLS-PATHSPEC "*.macs")))) (SETF-FUNCTIONS (FILTER-SETF-COMBOS (LOAD-COMBOS (SYMBOLS-PATHSPEC "*.setf-functions")))) (SETF-EXPANDERS (FILTER-SETF-COMBOS (LOAD-COMBOS (SYMBOLS-PATHSPEC "*.setf-expanders")))) (EXPS (FILTER-COMBOS (LOAD-COMBOS (SYMBOLS-PATHSPEC "*.exps"))))) (WITH-OPEN-FILE (F (SYMBOLS-PATHSPEC "autoloads-gen.lisp") :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :SUPERSEDE) (TERPRI F) (WRITE-LINE ";; ---- GENERATED CONTENT BELOW" F) (TERPRI F) (DOLIST (PACKAGE (QUOTE (:FORMAT :SEQUENCE :LOOP :MOP :XP :PRECOMPILER :PROFILER :JAVA :JVM :EXTENSIONS :THREADS :TOP-LEVEL :SYSTEM :CL))) (LET* ((*PACKAGE* (FIND-PACKAGE PACKAGE)) (ALL-EXPORTED-SYMBOLS (REMOVE-DUPLICATES (MAPCAR (FUNCTION SECOND) EXPS))) (EXTERNALS (REMOVE-IF-NOT (LAMBDA (SYM) (EQ (SYMBOL-PACKAGE SYM) *PACKAGE*)) ALL-EXPORTED-SYMBOLS))) (WHEN EXTERNALS (WRITE-LINE ";; EXPORTS" F) (WRITE (BACKQ-LIST (QUOTE IN-PACKAGE) PACKAGE) :STREAM F) (TERPRI F) (WRITE (BACKQ-LIST (QUOTE EXPORT) (BACKQ-LIST (QUOTE QUOTE) EXTERNALS)) :STREAM F) (TERPRI F))) (TERPRI F) (WRITE-LINE ";; FUNCTIONS" F) (TERPRI F) (WRITE-PACKAGE-FILESETS F PACKAGE (QUOTE AUTOLOAD) (COMBOS-TO-FILESET-SYMBOLS FUNCS)) (TERPRI F) (WRITE-LINE ";; MACROS" F) (TERPRI F) (WRITE-PACKAGE-FILESETS F PACKAGE (QUOTE AUTOLOAD-MACRO) (COMBOS-TO-FILESET-SYMBOLS MACS)) (TERPRI F) (WRITE-LINE ";; SETF-FUNCTIONS" F) (TERPRI F) (WRITE-PACKAGE-FILESETS F PACKAGE (QUOTE AUTOLOAD-SETF-FUNCTION) (COMBOS-TO-FILESET-SYMBOLS SETF-FUNCTIONS)) (TERPRI F) (WRITE-LINE ";; SETF-EXPANDERS" F) (TERPRI F) (WRITE-PACKAGE-FILESETS F PACKAGE (QUOTE AUTOLOAD-SETF-EXPANDER) (COMBOS-TO-FILESET-SYMBOLS SETF-EXPANDERS)))))))
     [java] ; (DEFUN %COMPILE-SYSTEM (&KEY OUTPUT-PATH) (LET ((*DEFAULT-PATHNAME-DEFAULTS* (PATHNAME *LISP-HOME*)) (*WARN-ON-REDEFINITION* NIL) (*PREVENT-FASL-CIRCLE-DETECTION* T)) (UNLESS OUTPUT-PATH (SETF OUTPUT-PATH *DEFAULT-PATHNAME-DEFAULTS*)) (FLET ((DO-COMPILE (FILE &KEY (EXTRACT T)) (LET ((OUT (MAKE-PATHNAME :TYPE *COMPILE-FILE-TYPE* :DEFAULTS (MERGE-PATHNAMES FILE OUTPUT-PATH)))) (COMPILE-FILE-IF-NEEDED FILE :OUTPUT-FILE OUT :EXTRACT-TOPLEVEL-FUNCS-AND-MACROS EXTRACT)))) (LOAD (DO-COMPILE "defstruct.lisp")) (LOAD (DO-COMPILE "coerce.lisp")) (LOAD (DO-COMPILE "open.lisp")) (LOAD (DO-COMPILE "dump-form.lisp")) (LOAD (DO-COMPILE "compiler-types.lisp")) (LOAD (DO-COMPILE "compile-file.lisp")) (LOAD (DO-COMPILE "precompiler.lisp")) (LOAD (DO-COMPILE "compiler-pass1.lisp")) (LOAD (DO-COMPILE "compiler-pass2.lisp")) (LOAD (DO-COMPILE "jvm-class-file.lisp")) (LOAD (DO-COMPILE "jvm.lisp")) (LOAD (DO-COMPILE "source-transform.lisp")) (LOAD (DO-COMPILE "compiler-macro.lisp")) (LOAD (DO-COMPILE "jvm-instructions.lisp")) (LOAD (DO-COMPILE "setf.lisp")) (LOAD (DO-COMPILE "extensible-sequences-base.lisp")) (LOAD (DO-COMPILE "require.lisp")) (LOAD (DO-COMPILE "substitute.lisp")) (LOAD (DO-COMPILE "clos.lisp")) (LOAD (DO-COMPILE "mop.lisp")) (MAPC (FUNCTION DO-COMPILE) (QUOTE ("collect.lisp" "macros.lisp" "loop.lisp"))) (LOAD (DO-COMPILE "backquote.lisp")) (LOAD (DO-COMPILE "early-defuns.lisp")) (LOAD (DO-COMPILE "typep.lisp")) (LOAD (DO-COMPILE "subtypep.lisp")) (LOAD (DO-COMPILE "find.lisp")) (LOAD (DO-COMPILE "print.lisp")) (LOAD (DO-COMPILE "pprint-dispatch.lisp")) (LOAD (DO-COMPILE "pprint.lisp")) (LOAD (DO-COMPILE "format.lisp")) (LOAD (DO-COMPILE "delete.lisp")) (LOAD (DO-COMPILE "concatenate.lisp")) (LOAD (DO-COMPILE "ldb.lisp")) (LOAD (DO-COMPILE "destructuring-bind.lisp")) (LOAD (DO-COMPILE "featurep.lisp")) (MAPC (FUNCTION DO-COMPILE) (QUOTE ("adjoin.lisp" "and.lisp" "apropos.lisp" "arrays.lisp" "assert.lisp" "assoc.lisp" "aver.lisp" "bit-array-ops.lisp" "boole.lisp" "butlast.lisp" "byte-io.lisp" "case.lisp" "chars.lisp" "check-type.lisp" "compile-file-pathname.lisp" "compile-system.lisp" "compiler-error.lisp" "cond.lisp" "copy-seq.lisp" "copy-symbol.lisp" "count.lisp" "digest.lisp" "debug.lisp" "define-modify-macro.lisp" "define-symbol-macro.lisp" "defmacro.lisp" "defpackage.lisp" "defsetf.lisp" "deftype.lisp" "delete-duplicates.lisp" "deposit-field.lisp" "describe.lisp" "describe-compiler-policy.lisp" "directory.lisp" "disassemble.lisp" "do-all-symbols.lisp" "do-external-symbols.lisp" "do-symbols.lisp" "do.lisp" "documentation.lisp" "dolist.lisp" "dotimes.lisp" "dribble.lisp" "dump-class.lisp" "ed.lisp" "enough-namestring.lisp" "ensure-directories-exist.lisp" "error.lisp" "extensible-sequences.lisp" "fasl-concat.lisp" "fdefinition.lisp" "fill.lisp" "find-all-symbols.lisp" "get-pid.lisp" "gentemp.lisp" "gray-streams.lisp" "gui.lisp" "inline.lisp" "inspect.lisp" "java.lisp" "java-collections.lisp" "known-functions.lisp" "known-symbols.lisp" "late-setf.lisp" "lcm.lisp" "ldiff.lisp" "list-length.lisp" "list.lisp" "load.lisp" "make-hash-table.lisp" "make-load-form-saving-slots.lisp" "make-sequence.lisp" "make-string-output-stream.lisp" "make-string.lisp" "map-into.lisp" "map.lisp" "map1.lisp" "mask-field.lisp" "member-if.lisp" "mismatch.lisp" "multiple-value-bind.lisp" "multiple-value-list.lisp" "multiple-value-setq.lisp" "nsubstitute.lisp" "nth-value.lisp" "numbers.lisp" "or.lisp" "parse-integer.lisp" "parse-lambda-list.lisp" "package.lisp" "pathnames.lisp" "print-object.lisp" "print-unreadable-object.lisp" "proclaim.lisp" "profiler.lisp" "prog.lisp" "psetf.lisp" "query.lisp" "read-circle.lisp" "read-conditional.lisp" "read-from-string.lisp" "read-sequence.lisp" "reduce.lisp" "remf.lisp" "remove-duplicates.lisp" "remove.lisp" "replace.lisp" "restart.lisp" "revappend.lisp" "rotatef.lisp" "run-program.lisp" "run-shell-command.lisp" "runtime-class.lisp" "search.lisp" "sequences.lisp" "sets.lisp" "shiftf.lisp" "signal.lisp" "socket.lisp" "sort.lisp" "step.lisp" "strings.lisp" "sublis.lisp" "subst.lisp" "tailp.lisp" "threads.lisp" "time.lisp" "top-level.lisp" "trace.lisp" "tree-equal.lisp" "upgraded-complex-part-type.lisp" "with-accessors.lisp" "with-hash-table-iterator.lisp" "with-input-from-string.lisp" "with-open-file.lisp" "with-output-to-string.lisp" "with-package-iterator.lisp" "with-slots.lisp" "with-standard-io-syntax.lisp" "write-sequence.lisp"))) (LOAD (DO-COMPILE "asdf.lisp")) (LOAD (DO-COMPILE "abcl-contrib.lisp")) (FORMAT T "; Generating autoloads...~%") (GENERATE-AUTOLOADS OUTPUT-PATH) (DO-COMPILE (MERGE-PATHNAMES #P"autoloads-gen.lisp" OUTPUT-PATH) :EXTRACT NIL) (DO-COMPILE "autoloads.lisp" :EXTRACT NIL)) T))
     [java] ; (DEFUN COMPILE-SYSTEM (&KEY QUIT (ZIP T) (CLS-EXT *COMPILE-FILE-CLASS-EXTENSION*) (ABCL-EXT *COMPILE-FILE-TYPE*) OUTPUT-PATH) (LET ((STATUS -1) (*COMPILE-FILE-CLASS-EXTENSION* CLS-EXT) (*COMPILE-FILE-TYPE* ABCL-EXT)) (CHECK-LISP-HOME) (TIME (WITH-COMPILATION-UNIT NIL (LET ((*COMPILE-FILE-ZIP* ZIP) FAILURE-P) (HANDLER-BIND (((OR WARNING COMPILER-ERROR) (FUNCTION (LAMBDA (C) (DECLARE (IGNORE C)) (SETF FAILURE-P T) NIL)))) (%COMPILE-SYSTEM :OUTPUT-PATH OUTPUT-PATH)) (UNLESS FAILURE-P (SETF STATUS 0))))) (CREATE-SYSTEM-LOGICAL-TRANSLATIONS OUTPUT-PATH) (WHEN QUIT (QUIT :STATUS STATUS))))
     [java] ; (DEFUN CREATE-SYSTEM-LOGICAL-TRANSLATIONS (OUTPUT-PATH) (LET* ((DIR (DIRECTORY-NAMESTRING (PATHNAME OUTPUT-PATH))) (SYSTEM (MERGE-PATHNAMES "system.lisp" DIR)) (HOME (PATHNAME *LISP-HOME*)) (SRC (FORMAT NIL "~A**/*.*" HOME)) (JAVA (FORMAT NIL "~A../../../**/*.*" HOME))) (WITH-OPEN-FILE (S SYSTEM :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE) (PPRINT (BACKQ-LIST (QUOTE SETF) (QUOTE (LOGICAL-PATHNAME-TRANSLATIONS "sys")) (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (BACKQ-LIST "SYS:SRC;**;*.*" SRC) (BACKQ-LIST "SYS:JAVA;**;*.*" JAVA)))) S))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compile-system.abcl (0.874 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/compiler-error.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFVAR *COMPILER-ERROR-CONTEXT* NIL)
     [java] ; (DEFINE-CONDITION COMPILER-ERROR (ERROR) NIL)
     [java] ; (DEFINE-CONDITION INTERNAL-COMPILER-ERROR (COMPILER-ERROR) NIL)
     [java] ; (DEFINE-CONDITION COMPILER-UNSUPPORTED-FEATURE-ERROR (COMPILER-ERROR) NIL)
     [java] ; (DEFUN COMPILER-STYLE-WARN (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (WARN (QUOTE STYLE-WARNING) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; (DEFUN COMPILER-WARN (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (WARN (QUOTE WARNING) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; (DEFUN COMPILER-ERROR (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (ERROR (QUOTE COMPILER-ERROR) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; (DEFUN INTERNAL-COMPILER-ERROR (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (CERROR "Eventually use interpreted form instead" (QUOTE INTERNAL-COMPILER-ERROR) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; (DEFUN COMPILER-UNSUPPORTED (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (ERROR (QUOTE COMPILER-UNSUPPORTED-FEATURE-ERROR) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/compiler-error.abcl (0.156 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/cond.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO COND (&REST CLAUSES) (IF (ENDP CLAUSES) NIL (LET ((CLAUSE (FIRST CLAUSES))) (WHEN (ATOM CLAUSE) (ERROR "COND clause is not a list: ~S" CLAUSE)) (LET ((TEST (FIRST CLAUSE)) (FORMS (REST CLAUSE))) (IF (ENDP FORMS) (LET ((N-RESULT (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST N-RESULT TEST)) (BACKQ-LIST (QUOTE IF) N-RESULT N-RESULT (BACKQ-CONS (QUOTE COND) (REST CLAUSES))))) (BACKQ-LIST (QUOTE IF) TEST (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-CONS (QUOTE COND) (REST CLAUSES))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/cond.abcl (0.05 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/copy-seq.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO VECTOR-COPY-SEQ (SEQUENCE TYPE) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE LENGTH) (BACKQ-LIST (QUOTE LENGTH) SEQUENCE))) (BACKQ-LIST (QUOTE DO) (BACKQ-LIST (QUOTE (INDEX 0 (1+ INDEX))) (BACKQ-LIST (QUOTE COPY) (BACKQ-LIST* (QUOTE MAKE-SEQUENCE-OF-TYPE) TYPE (QUOTE (LENGTH))))) (QUOTE ((= INDEX LENGTH) COPY)) (BACKQ-LIST (QUOTE ASET) (QUOTE COPY) (QUOTE INDEX) (BACKQ-LIST* (QUOTE AREF) SEQUENCE (QUOTE (INDEX)))))))
     [java] ; (DEFMACRO LIST-COPY-SEQ (LIST) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE ATOM) LIST) (QUOTE (QUOTE NIL)) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE RESULT) (BACKQ-LIST* (QUOTE CONS) (BACKQ-LIST (QUOTE CAR) LIST) (QUOTE ((QUOTE NIL)))))) (BACKQ-LIST* (QUOTE DO) (BACKQ-CONS (BACKQ-LIST* (QUOTE X) (BACKQ-LIST (QUOTE CDR) LIST) (QUOTE ((CDR X)))) (QUOTE ((SPLICE RESULT (CDR (RPLACD SPLICE (CONS (CAR X) (QUOTE NIL)))))))) (QUOTE (((ATOM X) (UNLESS (NULL X) (RPLACD SPLICE X)) RESULT)))))))
     [java] ; (DEFUN COPY-SEQ (SEQUENCE) "Return a copy of SEQUENCE which is EQUAL to SEQUENCE but not EQ." (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-COPY-SEQ SEQUENCE) (VECTOR-COPY-SEQ SEQUENCE (TYPE-OF SEQUENCE)) (SEQUENCE:COPY-SEQ SEQUENCE)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/copy-seq.abcl (0.112 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/copy-symbol.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN COPY-SYMBOL (SYMBOL &OPTIONAL (COPY-PROPS NIL) &AUX NEW-SYMBOL) (DECLARE (TYPE SYMBOL SYMBOL)) (SETQ NEW-SYMBOL (MAKE-SYMBOL (SYMBOL-NAME SYMBOL))) (WHEN COPY-PROPS (WHEN (BOUNDP SYMBOL) (SET NEW-SYMBOL (SYMBOL-VALUE SYMBOL))) (SETF (SYMBOL-PLIST NEW-SYMBOL) (COPY-LIST (SYMBOL-PLIST SYMBOL))) (WHEN (FBOUNDP SYMBOL) (SETF (SYMBOL-FUNCTION NEW-SYMBOL) (SYMBOL-FUNCTION SYMBOL)))) NEW-SYMBOL)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/copy-symbol.abcl (0.055 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/count.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFMACRO VECTOR-COUNT-IF (NOT-P FROM-END-P PREDICATE SEQUENCE) (LET ((NEXT-INDEX (IF FROM-END-P (QUOTE (1- INDEX)) (QUOTE (1+ INDEX)))) (PRED (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) PREDICATE (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::APPLY-KEY) (QUOTE KEY) (SYSTEM::BACKQ-LIST* (QUOTE AREF) SEQUENCE (QUOTE (INDEX))))))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE %START) (IF FROM-END-P (QUOTE (1- END)) (QUOTE START))) (SYSTEM::BACKQ-LIST (QUOTE %END) (IF FROM-END-P (QUOTE (1- START)) (QUOTE END)))) (SYSTEM::BACKQ-LIST (QUOTE DO) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE INDEX) (QUOTE %START) NEXT-INDEX) (QUOTE ((COUNT 0)))) (QUOTE ((= INDEX %END) COUNT)) (SYSTEM::BACKQ-LIST* (IF NOT-P (QUOTE UNLESS) (QUOTE WHEN)) PRED (QUOTE ((SETQ COUNT (1+ COUNT)))))))))
     [java] ; (DEFMACRO LIST-COUNT-IF (NOT-P FROM-END-P PREDICATE SEQUENCE) (LET ((PRED (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) PREDICATE (QUOTE ((SYSTEM::APPLY-KEY KEY (POP SEQUENCE))))))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE %START) (IF FROM-END-P (QUOTE (- LENGTH END)) (QUOTE START))) (SYSTEM::BACKQ-LIST (QUOTE %END) (IF FROM-END-P (QUOTE (- LENGTH START)) (QUOTE END))) (SYSTEM::BACKQ-LIST (QUOTE SEQUENCE) (IF FROM-END-P (QUOTE (REVERSE SEQUENCE)) (QUOTE SEQUENCE)))) (SYSTEM::BACKQ-LIST (QUOTE DO) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE SEQUENCE) (SYSTEM::BACKQ-LIST (QUOTE NTHCDR) (QUOTE %START) SEQUENCE)) (QUOTE ((INDEX %START (1+ INDEX)) (COUNT 0)))) (QUOTE ((OR (= INDEX %END) (NULL SEQUENCE)) COUNT)) (SYSTEM::BACKQ-LIST* (IF NOT-P (QUOTE UNLESS) (QUOTE WHEN)) PRED (QUOTE ((SETQ COUNT (1+ COUNT)))))))))
     [java] ; (DEFUN COUNT (ITEM SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL) TEST-P) (TEST-NOT NIL TEST-NOT-P) (START 0) END KEY) (WHEN (AND TEST-P TEST-NOT-P) (ERROR "test and test-not both supplied")) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH))) (LET ((%TEST (IF TEST-NOT-P (LAMBDA (X) (NOT (FUNCALL TEST-NOT ITEM X))) (LAMBDA (X) (FUNCALL TEST ITEM X))))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (LIST-COUNT-IF NIL T %TEST SEQUENCE) (LIST-COUNT-IF NIL NIL %TEST SEQUENCE)) (IF FROM-END (VECTOR-COUNT-IF NIL T %TEST SEQUENCE) (VECTOR-COUNT-IF NIL NIL %TEST SEQUENCE)) (APPLY (FUNCTION SEQUENCE:COUNT) ITEM SEQUENCE ARGS)))))
     [java] ; (DEFUN COUNT-IF (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (LIST-COUNT-IF NIL T TEST SEQUENCE) (LIST-COUNT-IF NIL NIL TEST SEQUENCE)) (IF FROM-END (VECTOR-COUNT-IF NIL T TEST SEQUENCE) (VECTOR-COUNT-IF NIL NIL TEST SEQUENCE)) (APPLY (FUNCTION SEQUENCE:COUNT-IF) TEST SEQUENCE ARGS))))
     [java] ; (DEFUN COUNT-IF-NOT (TEST SEQUENCE &REST ARGS &KEY FROM-END (START 0) END KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (LIST-COUNT-IF T T TEST SEQUENCE) (LIST-COUNT-IF T NIL TEST SEQUENCE)) (IF FROM-END (VECTOR-COUNT-IF T T TEST SEQUENCE) (VECTOR-COUNT-IF T NIL TEST SEQUENCE)) (APPLY (FUNCTION SEQUENCE:COUNT-IF-NOT) TEST SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/count.abcl (0.322 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/digest.lisp ...
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DEFUN ASCIIFY (DIGEST) (FORMAT NIL "~{~2,'0X~}" (MAPCAR (LAMBDA (B) (IF (< B 0) (+ 256 B) B)) (JAVA::LIST-FROM-JARRAY DIGEST))))
     [java] ; (DEFUN SHA256 (&REST PATHS-OR-STRINGS) "Returned ASCIIfied representation of SHA256 digest of byte-based resource at PATHS-OR-STRINGs." (UNLESS (AND (NULL (REST PATHS-OR-STRINGS)) (PATHNAMEP (FIRST PATHS-OR-STRINGS))) (WARN "Unaudited computation of cryptographic digest initiated.")) (LET ((FIRST (FIRST PATHS-OR-STRINGS)) (REST (REST PATHS-OR-STRINGS))) (CONCATENATE (QUOTE STRING) (WHEN FIRST (ASCIIFY (TYPECASE FIRST (PATHNAME (DIGEST FIRST)) (STRING (DIGEST FIRST)) (NULL) (LIST (CONCATENATE (QUOTE STRING) (SHA256 (FIRST FIRST)) (SHA256 (REST FIRST))))))) (WHEN REST (SHA256 REST)))))
     [java] ; (DEFGENERIC DIGEST (RESOURCE &KEY (DIGEST (QUOTE SHA-256))) (:DOCUMENTATION "Digest byte based resource at RESOURCE."))
     [java] ; (DEFUN DIGEST-PATH (PATH) (ASCIIFY (DIGEST PATH (QUOTE NIO) (QUOTE SHA-256))))
     [java] ; (DEFVAR *DIGEST-TYPES* (QUOTE ((SHA-1 . "SHA-1") (SHA-256 . "SHA-256") (SHA-512 . "SHA-512"))) "Normalization of cryptographic digest naming.")
     [java] ; (DEFCONSTANT +BYTE-BUFFER-REWIND+ (JAVA:JMETHOD "java.nio.ByteBuffer" "rewind"))
     [java] ; (DEFCONSTANT +BYTE-BUFFER-GET+ (JAVA:JMETHOD "java.nio.ByteBuffer" "get" "[B" "int" "int"))
     [java] ; (DEFCONSTANT +DIGEST-UPDATE+ (JAVA:JMETHOD "java.security.MessageDigest" "update" "[B" "int" "int"))
     [java] ; (DEFMETHOD DIGEST ((URL PATHNAME) &KEY (DIGEST (QUOTE SHA-256))) (DIGEST-NIO URL :DIGEST DIGEST))
     [java] ; (DEFUN DIGEST-NIO (SOURCE &KEY (DIGEST (QUOTE SHA-256))) "Calculate digest with default of :SHA-256 pathname specified by URL.
     [java] Returns an array of JVM primitive signed 8-bit bytes.
     [java]
     [java] Uses \"New I/O\" in JVM \"worse named API of all time\".
     [java]
     [java] *DIGEST-TYPES* controls the allowable digest types." (LET* ((CHANNEL (TYPECASE SOURCE (PATHNAME (JAVA:JCALL "getChannel" (JAVA:JNEW "java.io.FileInputStream" (NAMESTRING SOURCE)))) (STRING (JAVA:JSTATIC "newChannel" "java.nio.channels.Channels" (JAVA:JNEW "java.io.ByteArrayInputStream" (JAVA:JCALL "getBytes" SOURCE)))) (ERROR "Typecase failed of object of type ~S." SOURCE))) (DIGEST-TYPE (CDR (ASSOC DIGEST *DIGEST-TYPES*))) (DIGEST (JAVA:JSTATIC "getInstance" "java.security.MessageDigest" DIGEST-TYPE)) (LENGTH 8192) (BUFFER (JAVA:JSTATIC "allocateDirect" "java.nio.ByteBuffer" LENGTH)) (ARRAY (JAVA:JNEW-ARRAY "byte" LENGTH))) (DO ((READ (JAVA:JCALL "read" CHANNEL BUFFER) (JAVA:JCALL "read" CHANNEL BUFFER))) ((NOT (> READ 0))) (JAVA:JCALL +BYTE-BUFFER-REWIND+ BUFFER) (JAVA:JCALL +BYTE-BUFFER-GET+ BUFFER ARRAY 0 READ) (JAVA:JCALL +BYTE-BUFFER-REWIND+ BUFFER) (JAVA:JCALL +DIGEST-UPDATE+ DIGEST ARRAY 0 READ)) (JAVA:JCALL "digest" DIGEST)))
     [java] ; (DEFMETHOD DIGEST ((SOURCE STRING) &KEY (DIGEST (QUOTE SHA-256))) (DIGEST-NIO SOURCE :DIGEST DIGEST))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/digest.abcl (0.242 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/debug.lisp ...
     [java] ; (IN-PACKAGE #:EXTENSIONS)
     [java] ; (DEFVAR *DEBUG-CONDITION* NIL)
     [java] ; (DEFVAR *DEBUG-LEVEL* 0)
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN SHOW-RESTARTS (RESTARTS STREAM) (WHEN RESTARTS (FRESH-LINE STREAM) (%FORMAT STREAM "Restarts:~%") (LET ((MAX-NAME-LEN 0)) (DOLIST (RESTART RESTARTS) (LET ((NAME (RESTART-NAME RESTART))) (WHEN NAME (LET ((LEN (LENGTH (PRINC-TO-STRING NAME)))) (WHEN (> LEN MAX-NAME-LEN) (SETF MAX-NAME-LEN LEN)))))) (LET ((COUNT 0)) (DOLIST (RESTART RESTARTS) (LET ((NAME (RESTART-NAME RESTART)) (REPORT-FUNCTION (RESTART-REPORT-FUNCTION RESTART))) (%FORMAT STREAM "  ~D: ~A" COUNT NAME) (WHEN (FUNCTIONP REPORT-FUNCTION) (DOTIMES (I (1+ (- MAX-NAME-LEN (LENGTH (PRINC-TO-STRING NAME))))) (WRITE-CHAR #\  STREAM)) (FUNCALL REPORT-FUNCTION STREAM)) (TERPRI STREAM)) (INCF COUNT))))))
     [java] ; (DEFUN INTERNAL-DEBUG NIL (IF (FBOUNDP (QUOTE TOP-LEVEL::REPL)) (LET* ((CURRENT-DEBUG-IO (IF (TYPEP *DEBUG-IO* (QUOTE SYNONYM-STREAM)) (SYMBOL-VALUE (SYNONYM-STREAM-SYMBOL *DEBUG-IO*)) *DEBUG-IO*)) (IN (TWO-WAY-STREAM-INPUT-STREAM CURRENT-DEBUG-IO)) (OUT (TWO-WAY-STREAM-OUTPUT-STREAM CURRENT-DEBUG-IO))) (LOOP (TOP-LEVEL::REPL IN OUT))) (QUIT)))
     [java] ; (DEFUN DEBUG-LOOP NIL (LET ((*DEBUG-LEVEL* (1+ *DEBUG-LEVEL*))) (SHOW-RESTARTS (COMPUTE-RESTARTS) *DEBUG-IO*) (INTERNAL-DEBUG)))
     [java] ; (DEFUN INVOKE-DEBUGGER-REPORT-CONDITION (CONDITION) (WHEN CONDITION (FRESH-LINE *DEBUG-IO*) (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-STRUCTURE* NIL) (*PRINT-READABLY* NIL)) (WHEN (AND *LOAD-TRUENAME* (STREAMP *LOAD-STREAM*)) (SIMPLE-FORMAT *DEBUG-IO* "Error loading ~A at line ~D (offset ~D)~%" *LOAD-TRUENAME* (STREAM-LINE-NUMBER *LOAD-STREAM*) (STREAM-OFFSET *LOAD-STREAM*))) (SIMPLE-FORMAT *DEBUG-IO* (IF (FBOUNDP (QUOTE TOP-LEVEL::REPL)) "~S: Debugger invoked on condition of type ~A~%" "~S: Unhandled condition of type ~A:~%") (THREADS:CURRENT-THREAD) (TYPE-OF CONDITION)) (SIMPLE-FORMAT *DEBUG-IO* "  ~A~%" CONDITION)))))
     [java] ; (DECLAIM (INLINE RUN-HOOK))
     [java] ; (DEFUN RUN-HOOK (HOOK &REST ARGS) (LET ((HOOK-FUNCTION (SYMBOL-VALUE HOOK))) (WHEN HOOK-FUNCTION (PROGV (LIST HOOK) (LIST NIL) (APPLY HOOK-FUNCTION ARGS)))))
     [java] ; (DEFVAR *INVOKE-DEBUGGER-HOOK* NIL "Like *DEBUGGER-HOOK* but observed by INVOKE-DEBUGGER even when
     [java] called by BREAK. This hook is run before *DEBUGGER-HOOK*.")
     [java] ; (DEFUN INVOKE-DEBUGGER (CONDITION) (LET ((*SAVED-BACKTRACE* (BACKTRACE))) (RUN-HOOK (QUOTE *INVOKE-DEBUGGER-HOOK*) CONDITION *INVOKE-DEBUGGER-HOOK*) (RUN-HOOK (QUOTE *DEBUGGER-HOOK*) CONDITION *DEBUGGER-HOOK*) (INVOKE-DEBUGGER-REPORT-CONDITION CONDITION) (UNLESS (FBOUNDP (QUOTE TOP-LEVEL::REPL)) (QUIT)) (LET ((ORIGINAL-PACKAGE *PACKAGE*)) (WITH-STANDARD-IO-SYNTAX (LET ((*PACKAGE* ORIGINAL-PACKAGE) (*PRINT-READABLY* NIL) (*PRINT-STRUCTURE* NIL) (*DEBUG-CONDITION* CONDITION) (LEVEL *DEBUG-LEVEL*)) (CLEAR-INPUT *DEBUG-IO*) (IF (> LEVEL 0) (WITH-SIMPLE-RESTART (ABORT "Return to debug level ~D." LEVEL) (DEBUG-LOOP)) (DEBUG-LOOP)))))))
     [java] ; (DEFUN BREAK (&OPTIONAL (FORMAT-CONTROL "BREAK called") &REST FORMAT-ARGUMENTS) (LET ((*DEBUGGER-HOOK* NIL)) (WITH-SIMPLE-RESTART (CONTINUE "Return from BREAK.") (INVOKE-DEBUGGER (%MAKE-CONDITION (QUOTE SIMPLE-CONDITION) (LIST :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS)))) NIL))
     [java] ; (DEFUN BACKTRACE-AS-LIST (&OPTIONAL (N 0)) "Return BACKTRACE with each element converted to a list." (MAPCAR (FUNCTION FRAME-TO-LIST) (BACKTRACE N)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/debug.abcl (0.337 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/define-modify-macro.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DEFINE-MODIFY-MACRO (NAME LAMBDA-LIST FUNCTION &OPTIONAL DOC-STRING) "Creates a new read-modify-write macro like PUSH or INCF." (LET ((OTHER-ARGS NIL) (REST-ARG NIL) (ENV (GENSYM)) (REFERENCE (GENSYM))) (DO ((LL LAMBDA-LIST (CDR LL)) (ARG NIL)) ((NULL LL)) (SETQ ARG (CAR LL)) (COND ((EQ ARG (QUOTE &OPTIONAL))) ((EQ ARG (QUOTE &REST)) (IF (SYMBOLP (CADR LL)) (SETQ REST-ARG (CADR LL)) (ERROR "Non-symbol &REST arg in definition of ~S." NAME)) (IF (NULL (CDDR LL)) (RETURN NIL) (ERROR "Illegal stuff after &REST argument in DEFINE-MODIFY-MACRO."))) ((MEMQ ARG (QUOTE (&KEY &ALLOW-OTHER-KEYS &AUX))) (ERROR "~S not allowed in DEFINE-MODIFY-MACRO lambda list." ARG)) ((SYMBOLP ARG) (PUSH ARG OTHER-ARGS)) ((AND (LISTP ARG) (SYMBOLP (CAR ARG))) (PUSH (CAR ARG) OTHER-ARGS)) (T (ERROR "Illegal stuff in DEFINE-MODIFY-MACRO lambda list.")))) (SETQ OTHER-ARGS (NREVERSE OTHER-ARGS)) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE DEFMACRO) NAME (BACKQ-CONS REFERENCE (BACKQ-APPEND LAMBDA-LIST (BACKQ-LIST (QUOTE &ENVIRONMENT) ENV))) DOC-STRING (BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) (QUOTE (DUMMIES VALS NEWVAL SETTER GETTER)) (BACKQ-LIST (QUOTE GET-SETF-EXPANSION) REFERENCE ENV) (BACKQ-LIST (QUOTE DO) (QUOTE ((D DUMMIES (CDR D)) (V VALS (CDR V)) (LET-LIST NIL (CONS (LIST (CAR D) (CAR V)) LET-LIST)))) (BACKQ-LIST* (QUOTE (NULL D)) (BACKQ-LIST* (QUOTE PUSH) (BACKQ-LIST (QUOTE LIST) (QUOTE (CAR NEWVAL)) (IF REST-ARG (BACKQ-LIST* (QUOTE LIST*) (BACKQ-LIST (QUOTE QUOTE) FUNCTION) (QUOTE GETTER) (BACKQ-APPEND OTHER-ARGS (BACKQ-LIST REST-ARG))) (BACKQ-LIST* (QUOTE LIST) (BACKQ-LIST (QUOTE QUOTE) FUNCTION) (QUOTE GETTER) OTHER-ARGS))) (QUOTE (LET-LIST))) (QUOTE ((BACKQ-LIST (QUOTE LET*) (NREVERSE LET-LIST) SETTER))))))))))
     [java] ; (DEFINE-MODIFY-MACRO INCF-COMPLEX (&OPTIONAL (DELTA 1)) + "The first argument is some location holding a number.  This number is
     [java]    incremented by the second argument, DELTA, which defaults to 1.")
     [java] ; (DEFINE-MODIFY-MACRO DECF-COMPLEX (&OPTIONAL (DELTA 1)) - "The first argument is some location holding a number.  This number is
     [java]    decremented by the second argument, DELTA, which defaults to 1.")
     [java] ; (DEFMACRO INCF (PLACE &OPTIONAL (DELTA 1)) (COND ((SYMBOLP PLACE) (COND ((CONSTANTP DELTA) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE +) PLACE DELTA))) (T (LET ((TEMP (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST TEMP DELTA)) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE +) PLACE TEMP))))))) ((AND (CONSP PLACE) (EQ (CAR PLACE) (QUOTE THE))) (LET ((RES (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST RES (BACKQ-LIST (QUOTE THE) (SECOND PLACE) (BACKQ-LIST (QUOTE +) PLACE DELTA)))) (BACKQ-LIST (QUOTE SETF) (THIRD PLACE) RES)))) (T (BACKQ-LIST (QUOTE INCF-COMPLEX) PLACE DELTA))))
     [java] ; (DEFMACRO DECF (PLACE &OPTIONAL (DELTA 1)) (COND ((SYMBOLP PLACE) (COND ((CONSTANTP DELTA) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE -) PLACE DELTA))) (T (LET ((TEMP (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST TEMP DELTA)) (BACKQ-LIST (QUOTE SETQ) PLACE (BACKQ-LIST (QUOTE -) PLACE TEMP))))))) ((AND (CONSP PLACE) (EQ (CAR PLACE) (QUOTE THE))) (LET ((RES (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST RES (BACKQ-LIST (QUOTE THE) (SECOND PLACE) (BACKQ-LIST (QUOTE -) PLACE DELTA)))) (BACKQ-LIST (QUOTE SETF) (THIRD PLACE) RES)))) (T (BACKQ-LIST (QUOTE DECF-COMPLEX) PLACE DELTA))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/define-modify-macro.abcl (0.221 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/define-symbol-macro.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN %DEFINE-SYMBOL-MACRO (SYMBOL EXPANSION) (%SET-SYMBOL-MACRO SYMBOL (MAKE-SYMBOL-MACRO EXPANSION)) SYMBOL)
     [java] ; (DEFMACRO DEFINE-SYMBOL-MACRO (SYMBOL EXPANSION) (WHEN (SPECIAL-VARIABLE-P SYMBOL) (ERROR (QUOTE PROGRAM-ERROR) "~S has already been defined as a global variable." SYMBOL)) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) SYMBOL) (QUOTE (:SYMBOL-MACRO))) (BACKQ-LIST (QUOTE %DEFINE-SYMBOL-MACRO) (BACKQ-LIST (QUOTE QUOTE) SYMBOL) (BACKQ-LIST (QUOTE QUOTE) EXPANSION))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/define-symbol-macro.abcl (0.071 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defmacro.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DEFMACRO (NAME LAMBDA-LIST &REST BODY) (LET* ((WHOLE (GENSYM "WHOLE-")) (ENV (GENSYM "ENVIRONMENT-"))) (MULTIPLE-VALUE-BIND (BODY DECLS DOCUMENTATION) (PARSE-DEFMACRO LAMBDA-LIST WHOLE BODY NAME (QUOTE DEFMACRO) :ENVIRONMENT ENV) (LET ((EXPANDER (BACKQ-LIST* (QUOTE LAMBDA) (BACKQ-LIST WHOLE ENV) (BACKQ-APPEND DECLS (BACKQ-LIST BODY))))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:MACRO))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE MACRO) (BACKQ-LIST (QUOTE MAKE-MACRO) (BACKQ-LIST (QUOTE QUOTE) NAME) (BACKQ-LIST (QUOTE OR) (BACKQ-LIST (QUOTE PRECOMPILE) NIL EXPANDER) EXPANDER)))) (BACKQ-APPEND (IF (SPECIAL-OPERATOR-P NAME) (BACKQ-LIST (BACKQ-LIST* (QUOTE PUT) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE MACROEXPAND-MACRO) MACRO)))) (BACKQ-LIST (BACKQ-LIST* (QUOTE FSET) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (MACRO))))) (BACKQ-CONS (BACKQ-LIST (QUOTE %SET-ARGLIST) (QUOTE MACRO) (BACKQ-LIST (QUOTE QUOTE) LAMBDA-LIST)) (BACKQ-APPEND (WHEN DOCUMENTATION (BACKQ-LIST (BACKQ-LIST (QUOTE %SET-DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (QUOTE FUNCTION)) DOCUMENTATION))) (BACKQ-LIST (BACKQ-LIST (QUOTE QUOTE) NAME)))))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defmacro.abcl (0.07 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defpackage.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN DESIGNATED-PACKAGE-NAME (DESIGNATOR) (COND ((PACKAGEP DESIGNATOR) (PACKAGE-NAME DESIGNATOR)) (T (STRING DESIGNATOR))))
     [java] ; (DEFUN STRINGIFY-NAMES (NAMES) (MAPCAR (FUNCTION STRING) NAMES))
     [java] ; (DEFUN CHECK-DISJOINT (&REST ARGS) (LET ((REST-ARGS ARGS)) (DOLIST (ARG1 ARGS) (LET ((KEY1 (CAR ARG1)) (SET1 (CDR ARG1))) (SETQ REST-ARGS (CDR REST-ARGS)) (DOLIST (ARG2 REST-ARGS) (LET* ((KEY2 (CAR ARG2)) (SET2 (CDR ARG2)) (COMMON (REMOVE-DUPLICATES (INTERSECTION SET1 SET2 :TEST (FUNCTION STRING=))))) (WHEN COMMON (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Parameters ~S and ~S must be disjoint, but have common elements: ~S" :FORMAT-ARGUMENTS (LIST KEY1 KEY2 COMMON)))))))))
     [java] ; (DEFUN ENSURE-AVAILABLE-SYMBOLS (SYMBOLS) SYMBOLS)
     [java] ; (DEFMACRO DEFPACKAGE (PACKAGE &REST OPTIONS) (LET ((NICKNAMES NIL) (SIZE NIL) (SHADOWS NIL) (SHADOWING-IMPORTS NIL) (USE NIL) (USE-P NIL) (IMPORTS NIL) (INTERNS NIL) (EXPORTS NIL) (LOCAL-NICKNAMES NIL) (DOC NIL)) (DOLIST (OPTION OPTIONS) (UNLESS (CONSP OPTION) (ERROR (QUOTE PROGRAM-ERROR) "bad DEFPACKAGE option: ~S" OPTION)) (CASE (CAR OPTION) (:NICKNAMES (SETQ NICKNAMES (STRINGIFY-NAMES (CDR OPTION)))) (:SIZE (COND (SIZE (ERROR (QUOTE PROGRAM-ERROR) "can't specify :SIZE twice")) ((AND (CONSP (CDR OPTION)) (TYPEP (SECOND OPTION) (QUOTE UNSIGNED-BYTE))) (SETQ SIZE (SECOND OPTION))) (T (ERROR (QUOTE PROGRAM-ERROR) "bad :SIZE, must be a positive integer: ~S" (SECOND OPTION))))) (:SHADOW (LET ((NEW (STRINGIFY-NAMES (CDR OPTION)))) (SETQ SHADOWS (APPEND SHADOWS NEW)))) (:SHADOWING-IMPORT-FROM (LET ((PACKAGE-NAME (DESIGNATED-PACKAGE-NAME (CADR OPTION))) (SYMBOL-NAMES (STRINGIFY-NAMES (CDDR OPTION)))) (LET ((ASSOC (ASSOC PACKAGE-NAME SHADOWING-IMPORTS :TEST (FUNCTION STRING=)))) (IF ASSOC (SETF (CDR ASSOC) (APPEND (CDR ASSOC) SYMBOL-NAMES)) (SETQ SHADOWING-IMPORTS (ACONS PACKAGE-NAME SYMBOL-NAMES SHADOWING-IMPORTS)))))) (:USE (LET ((NEW (MAPCAR (FUNCTION DESIGNATED-PACKAGE-NAME) (CDR OPTION)))) (SETQ USE (DELETE-DUPLICATES (NCONC USE NEW) :TEST (FUNCTION STRING=))) (SETQ USE-P T))) (:IMPORT-FROM (LET ((PACKAGE-NAME (DESIGNATED-PACKAGE-NAME (CADR OPTION))) (SYMBOL-NAMES (STRINGIFY-NAMES (CDDR OPTION)))) (LET ((ASSOC (ASSOC PACKAGE-NAME IMPORTS :TEST (FUNCTION STRING=)))) (IF ASSOC (SETF (CDR ASSOC) (APPEND (CDR ASSOC) SYMBOL-NAMES)) (SETQ IMPORTS (ACONS PACKAGE-NAME SYMBOL-NAMES IMPORTS)))))) (:INTERN (LET ((NEW (STRINGIFY-NAMES (CDR OPTION)))) (SETQ INTERNS (APPEND INTERNS NEW)))) (:EXPORT (LET ((NEW (STRINGIFY-NAMES (CDR OPTION)))) (SETQ EXPORTS (APPEND EXPORTS NEW)))) (:DOCUMENTATION (WHEN DOC (ERROR (QUOTE PROGRAM-ERROR) "can't specify :DOCUMENTATION twice")) (SETQ DOC (COERCE (CADR OPTION) (QUOTE SIMPLE-STRING)))) (:LOCAL-NICKNAMES (DOLIST (NICKDECL (CDR OPTION)) (UNLESS (= (LENGTH NICKDECL) 2) (ERROR (QUOTE PROGRAM-ERROR) "Malformed local nickname declaration ~A" NICKDECL)) (LET ((LOCAL-NICKNAME (STRING (FIRST NICKDECL))) (PACKAGE-NAME (DESIGNATED-PACKAGE-NAME (SECOND NICKDECL)))) (WHEN (MEMBER LOCAL-NICKNAME (QUOTE ("CL" "COMMON-LISP" "KEYWORD")) :TEST (FUNCTION STRING=)) (CERROR "Continue anyway" (FORMAT NIL "Trying to define a local nickname for package ~A" LOCAL-NICKNAME))) (WHEN (MEMBER LOCAL-NICKNAME (LIST* PACKAGE NICKNAMES) :TEST (FUNCTION STRING=)) (CERROR "Continue anyway" "Trying to override the name or a nickname (~A) ~
     [java]                         with a local nickname for another package ~A" LOCAL-NICKNAME PACKAGE-NAME)) (PUSH (LIST LOCAL-NICKNAME PACKAGE-NAME) LOCAL-NICKNAMES)))) (T (ERROR (QUOTE PROGRAM-ERROR) "bad DEFPACKAGE option: ~S" OPTION)))) (CHECK-DISJOINT (BACKQ-CONS (QUOTE :INTERN) INTERNS) (BACKQ-CONS (QUOTE :EXPORT) EXPORTS)) (CHECK-DISJOINT (BACKQ-CONS (QUOTE :INTERN) INTERNS) (BACKQ-CONS (QUOTE :IMPORT-FROM) (APPLY (FUNCTION APPEND) (MAPCAR (FUNCTION REST) IMPORTS))) (BACKQ-CONS (QUOTE :SHADOW) SHADOWS) (BACKQ-CONS (QUOTE :SHADOWING-IMPORT-FROM) (APPLY (FUNCTION APPEND) (MAPCAR (FUNCTION REST) SHADOWING-IMPORTS)))) (BACKQ-LIST (QUOTE PROG1) (BACKQ-LIST (QUOTE %DEFPACKAGE) (STRING PACKAGE) (BACKQ-LIST (QUOTE QUOTE) NICKNAMES) (BACKQ-LIST (QUOTE QUOTE) SIZE) (BACKQ-LIST (QUOTE QUOTE) SHADOWS) (BACKQ-LIST (QUOTE ENSURE-AVAILABLE-SYMBOLS) (BACKQ-LIST (QUOTE QUOTE) SHADOWING-IMPORTS)) (BACKQ-LIST (QUOTE QUOTE) (IF USE-P USE NIL)) (BACKQ-LIST (QUOTE ENSURE-AVAILABLE-SYMBOLS) (BACKQ-LIST (QUOTE QUOTE) IMPORTS)) (BACKQ-LIST (QUOTE QUOTE) INTERNS) (BACKQ-LIST (QUOTE QUOTE) EXPORTS) (BACKQ-LIST (QUOTE QUOTE) LOCAL-NICKNAMES) (BACKQ-LIST (QUOTE QUOTE) DOC)) (WHEN (AND (SYMBOLP PACKAGE) (NOT (KEYWORDP PACKAGE))) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) PACKAGE) (QUOTE (:PACKAGE)))) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (INTERN (STRING PACKAGE) :KEYWORD) (QUOTE (:PACKAGE))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defpackage.abcl (0.255 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/defsetf.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN %DEFSETF (ORIG-ACCESS-FORM NUM-STORE-VARS EXPANDER) (COLLECT ((SUBFORMS) (SUBFORM-VARS) (SUBFORM-EXPRS) (STORE-VARS)) (DOLIST (SUBFORM (CDR ORIG-ACCESS-FORM)) (IF (CONSTANTP SUBFORM) (SUBFORMS SUBFORM) (LET ((VAR (GENSYM))) (SUBFORMS VAR) (SUBFORM-VARS VAR) (SUBFORM-EXPRS SUBFORM)))) (DOTIMES (I NUM-STORE-VARS) (STORE-VARS (GENSYM))) (VALUES (SUBFORM-VARS) (SUBFORM-EXPRS) (STORE-VARS) (FUNCALL EXPANDER (CONS (SUBFORMS) (STORE-VARS))) (BACKQ-CONS (CAR ORIG-ACCESS-FORM) (SUBFORMS)))))
     [java] ; (DEFMACRO DEFSETF (ACCESS-FN &REST REST) (COND ((NOT (LISTP (CAR REST))) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:LOAD-TOPLEVEL :COMPILE-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE %DEFINE-SETF-MACRO) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN) NIL (BACKQ-LIST (QUOTE QUOTE) (CAR REST)) (WHEN (AND (CAR REST) (STRINGP (CADR REST))) (BACKQ-LIST (QUOTE QUOTE) (CADR REST)))))) ((AND (CDR REST) (LISTP (CADR REST))) (DESTRUCTURING-BIND (LAMBDA-LIST (&REST STORE-VARIABLES) &BODY BODY) REST (LET ((ARGLIST-VAR (GENSYM "ARGS-")) (ACCESS-FORM-VAR (GENSYM "ACCESS-FORM-")) (ENV-VAR (GENSYM "ENVIRONMENT-"))) (MULTIPLE-VALUE-BIND (BODY DOC) (PARSE-DEFMACRO (BACKQ-CONS LAMBDA-LIST STORE-VARIABLES) ARGLIST-VAR BODY ACCESS-FN (QUOTE DEFSETF) :ANONYMOUSP T) (BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:LOAD-TOPLEVEL :COMPILE-TOPLEVEL :EXECUTE)) (BACKQ-LIST (QUOTE %DEFINE-SETF-MACRO) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) (BACKQ-LIST ACCESS-FORM-VAR ENV-VAR) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORE) ENV-VAR)) (BACKQ-LIST (QUOTE %DEFSETF) ACCESS-FORM-VAR (LENGTH STORE-VARIABLES) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) (BACKQ-LIST ARGLIST-VAR) (BACKQ-LIST (QUOTE BLOCK) ACCESS-FN BODY)))))) NIL (BACKQ-LIST (QUOTE QUOTE) DOC))))))) (T (ERROR "Ill-formed DEFSETF for ~S" ACCESS-FN))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/defsetf.abcl (0.117 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/deftype.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DEFTYPE (NAME LAMBDA-LIST &REST BODY) (WHEN (EQ (SYMBOL-PACKAGE NAME) +CL-PACKAGE+) (ERROR :FORMAT-CONTROL "Attempt to define ~S, a symbol in the COMMON-LISP package, as a type specifier." :FORMAT-ARGUMENTS (LIST NAME))) (CHECK-DECLARATION-TYPE NAME) (WHEN (OR (MEMQ (QUOTE &OPTIONAL) LAMBDA-LIST) (MEMQ (QUOTE &KEY) LAMBDA-LIST)) (LET ((NEW-LAMBDA-LIST NIL) (STATE NIL)) (DOLIST (THING LAMBDA-LIST) (COND ((EQ THING (QUOTE &OPTIONAL)) (SETF STATE (QUOTE &OPTIONAL))) ((EQ THING (QUOTE &KEY)) (SETF STATE (QUOTE &KEY))) ((MEMQ THING LAMBDA-LIST-KEYWORDS) (SETF STATE NIL)) ((EQ STATE (QUOTE &OPTIONAL)) (WHEN (SYMBOLP THING) (SETF THING (LIST THING (QUOTE (QUOTE *)))))) ((EQ STATE (QUOTE &KEY)) (WHEN (SYMBOLP THING) (SETF THING (LIST THING (QUOTE (QUOTE *))))))) (PUSH THING NEW-LAMBDA-LIST)) (SETF LAMBDA-LIST (NREVERSE NEW-LAMBDA-LIST)))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE (:TYPE))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) NAME) (QUOTE ((QUOTE DEFTYPE-DEFINITION)))) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) LAMBDA-LIST (BACKQ-LIST* (QUOTE BLOCK) NAME BODY)))) (BACKQ-LIST (QUOTE QUOTE) NAME)))
     [java] ; (DEFUN EXPAND-DEFTYPE (TYPE) (LET (TP I) (LOOP (IF (CONSP TYPE) (SETF TP (%CAR TYPE) I (%CDR TYPE)) (SETF TP TYPE I NIL)) (IF (AND (SYMBOLP TP) (GET TP (QUOTE DEFTYPE-DEFINITION))) (SETF TYPE (APPLY (GET TP (QUOTE DEFTYPE-DEFINITION)) I)) (RETURN)))) TYPE)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/deftype.abcl (0.093 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/delete-duplicates.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN LIST-DELETE-DUPLICATES* (LIST TEST TEST-NOT KEY FROM-END START END) (LET ((HANDLE (CONS NIL LIST))) (DO ((CURRENT (NTHCDR START LIST) (CDR CURRENT)) (PREVIOUS (NTHCDR START HANDLE)) (INDEX START (1+ INDEX))) ((OR (AND END (= INDEX END)) (NULL CURRENT)) (CDR HANDLE)) (IF (DO ((X (IF FROM-END (NTHCDR (1+ START) HANDLE) (CDR CURRENT)) (CDR X)) (I (1+ INDEX) (1+ I))) ((OR (NULL X) (AND (NOT FROM-END) END (= I END)) (EQ X CURRENT)) NIL) (IF (IF TEST-NOT (NOT (FUNCALL TEST-NOT (APPLY-KEY KEY (CAR CURRENT)) (APPLY-KEY KEY (CAR X)))) (FUNCALL TEST (APPLY-KEY KEY (CAR CURRENT)) (APPLY-KEY KEY (CAR X)))) (RETURN T))) (RPLACD PREVIOUS (CDR CURRENT)) (SETQ PREVIOUS (CDR PREVIOUS))))))
     [java] ; (DEFUN VECTOR-DELETE-DUPLICATES* (VECTOR TEST TEST-NOT KEY FROM-END START END &OPTIONAL (LENGTH (LENGTH VECTOR))) (WHEN (NULL END) (SETF END (LENGTH VECTOR))) (DO ((INDEX START (1+ INDEX)) (JNDEX START)) ((= INDEX END) (DO ((INDEX INDEX (1+ INDEX)) (JNDEX JNDEX (1+ JNDEX))) ((= INDEX LENGTH) (SHRINK-VECTOR VECTOR JNDEX) VECTOR) (SETF (AREF VECTOR JNDEX) (AREF VECTOR INDEX)))) (SETF (AREF VECTOR JNDEX) (AREF VECTOR INDEX)) (UNLESS (POSITION (APPLY-KEY KEY (AREF VECTOR INDEX)) VECTOR :KEY KEY :START (IF FROM-END START (1+ INDEX)) :TEST TEST :END (IF FROM-END JNDEX END) :TEST-NOT TEST-NOT) (SETQ JNDEX (1+ JNDEX)))))
     [java] ; (DEFUN DELETE-DUPLICATES (SEQUENCE &REST ARGS &KEY (TEST (FUNCTION EQL)) TEST-NOT (START 0) FROM-END END KEY) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF SEQUENCE (LIST-DELETE-DUPLICATES* SEQUENCE TEST TEST-NOT KEY FROM-END START END)) (VECTOR-DELETE-DUPLICATES* SEQUENCE TEST TEST-NOT KEY FROM-END START END) (APPLY (FUNCTION SEQUENCE:DELETE-DUPLICATES) SEQUENCE ARGS)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/delete-duplicates.abcl (0.133 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/deposit-field.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN DEPOSIT-FIELD (NEWBYTE SPEC INTEGER) (LET* ((SIZE (BYTE-SIZE SPEC)) (POS (BYTE-POSITION SPEC)) (MASK (ASH (LDB (BYTE SIZE 0) -1) POS))) (LOGIOR (LOGAND NEWBYTE MASK) (LOGAND INTEGER (LOGNOT MASK)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/deposit-field.abcl (0.044 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/describe.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN DESCRIBE-ARGLIST (OBJECT STREAM) (MULTIPLE-VALUE-BIND (ARGLIST KNOWN-P) (ARGLIST OBJECT) (WHEN KNOWN-P (FORMAT STREAM "~&The function's lambda list is:~%  ~A~%" ARGLIST))))
     [java] ; (DEFUN %DESCRIBE-OBJECT (OBJECT STREAM) (FORMAT STREAM "~S is an object of type ~S.~%" OBJECT (TYPE-OF OBJECT)))
     [java] ; (DEFUN DESCRIBE (OBJECT &OPTIONAL STREAM) (DESCRIBE-OBJECT OBJECT (OUT-SYNONYM-OF STREAM)) (VALUES))
     [java] ; (DEFMETHOD DESCRIBE-OBJECT ((OBJECT T) STREAM) (LET ((*PRINT-PRETTY* T)) (TYPECASE OBJECT (SYMBOL (LET ((PACKAGE (SYMBOL-PACKAGE OBJECT))) (IF PACKAGE (MULTIPLE-VALUE-BIND (SYM STATUS) (FIND-SYMBOL (SYMBOL-NAME OBJECT) PACKAGE) (FORMAT STREAM "~S is an ~A symbol in the ~A package.~%" OBJECT (IF (EQ STATUS :INTERNAL) "internal" "external") (PACKAGE-NAME PACKAGE))) (FORMAT STREAM "~S is an uninterned symbol.~%" OBJECT)) (COND ((SPECIAL-VARIABLE-P OBJECT) (FORMAT STREAM "It is a ~A; " (IF (CONSTANTP OBJECT) "constant" "special variable")) (IF (BOUNDP OBJECT) (FORMAT STREAM "its value is ~S.~%" (SYMBOL-VALUE OBJECT)) (FORMAT STREAM "it is unbound.~%"))) ((BOUNDP OBJECT) (FORMAT STREAM "It is an undefined variable; its value is ~S.~%" (SYMBOL-VALUE OBJECT))))) (WHEN (AUTOLOADP OBJECT) (RESOLVE OBJECT)) (LET ((FUNCTION (AND (FBOUNDP OBJECT) (SYMBOL-FUNCTION OBJECT)))) (WHEN FUNCTION (FORMAT STREAM "Its function binding is ~S.~%" FUNCTION) (DESCRIBE-ARGLIST FUNCTION STREAM))) (LET ((DOC (DOCUMENTATION OBJECT (QUOTE FUNCTION)))) (WHEN DOC (FORMAT STREAM "Function documentation:~%  ~A~%" DOC))) (LET ((DOC (DOCUMENTATION OBJECT (QUOTE VARIABLE)))) (WHEN DOC (FORMAT STREAM "Variable documentation:~%  ~A~%" DOC))) (LET ((PLIST (SYMBOL-PLIST OBJECT))) (WHEN PLIST (FORMAT STREAM "The symbol's property list contains these indicator/value pairs:~%") (LOOP (WHEN (NULL PLIST) (RETURN)) (FORMAT STREAM "  ~S ~S~%" (CAR PLIST) (CADR PLIST)) (SETF PLIST (CDDR PLIST)))))) (FUNCTION (%DESCRIBE-OBJECT OBJECT STREAM) (DESCRIBE-ARGLIST OBJECT STREAM) (LET ((FUNCTION-SYMBOL (NTH-VALUE 2 (FUNCTION-LAMBDA-EXPRESSION OBJECT)))) (IF (AND (CONSP FUNCTION-SYMBOL) (EQ (CAR FUNCTION-SYMBOL) (QUOTE MACRO-FUNCTION))) (SETQ FUNCTION-SYMBOL (SECOND FUNCTION-SYMBOL))) (WHEN FUNCTION-SYMBOL (LET ((DOC (DOCUMENTATION FUNCTION-SYMBOL (QUOTE FUNCTION)))) (WHEN DOC (FORMAT STREAM "Function documentation:~%  ~A~%" DOC)))))) (INTEGER (%DESCRIBE-OBJECT OBJECT STREAM) (FORMAT STREAM "~D.~%~
     [java]                        #x~X~%~
     [java]                        #o~O~%~
     [java]                        #b~B~%" OBJECT OBJECT OBJECT OBJECT)) (T (%DESCRIBE-OBJECT OBJECT STREAM)))) (VALUES))
     [java] ; (DEFMETHOD DESCRIBE-OBJECT ((OBJECT PATHNAME) STREAM) (FORMAT STREAM "~S is an object of type ~S:~%" OBJECT (TYPE-OF OBJECT)) (FORMAT STREAM "  HOST         ~S~%" (PATHNAME-HOST OBJECT)) (FORMAT STREAM "  DEVICE       ~S~%" (PATHNAME-DEVICE OBJECT)) (FORMAT STREAM "  DIRECTORY    ~S~%" (PATHNAME-DIRECTORY OBJECT)) (FORMAT STREAM "  NAME         ~S~%" (PATHNAME-NAME OBJECT)) (FORMAT STREAM "  TYPE         ~S~%" (PATHNAME-TYPE OBJECT)) (FORMAT STREAM "  VERSION      ~S~%" (PATHNAME-VERSION OBJECT)))
     [java] ; (DEFUN %DESCRIBE-STANDARD-OBJECT/FUNCALLABLE (OBJECT STREAM) (LET* ((CLASS (CLASS-OF OBJECT)) (SLOTDS (MOP:CLASS-SLOTS CLASS)) (MAX-SLOT-NAME-LENGTH 0) (INSTANCE-SLOTDS NIL) (CLASS-SLOTDS NIL)) (FORMAT STREAM "~S is an instance of ~S.~%" OBJECT CLASS) (DOLIST (SLOTD SLOTDS) (LET* ((NAME (MOP:SLOT-DEFINITION-NAME SLOTD)) (LENGTH (LENGTH (SYMBOL-NAME NAME)))) (WHEN (> LENGTH MAX-SLOT-NAME-LENGTH) (SETF MAX-SLOT-NAME-LENGTH LENGTH))) (CASE (MOP:SLOT-DEFINITION-ALLOCATION SLOTD) (:INSTANCE (PUSH SLOTD INSTANCE-SLOTDS)) (:CLASS (PUSH SLOTD CLASS-SLOTDS)))) (SETF MAX-SLOT-NAME-LENGTH (MIN (+ MAX-SLOT-NAME-LENGTH 3) 30)) (FLET ((DESCRIBE-SLOT (SLOT-NAME) (IF (SLOT-BOUNDP OBJECT SLOT-NAME) (FORMAT STREAM "~&  ~A~VT  ~S" SLOT-NAME MAX-SLOT-NAME-LENGTH (SLOT-VALUE OBJECT SLOT-NAME)) (FORMAT STREAM "~&  ~A~VT  unbound" SLOT-NAME MAX-SLOT-NAME-LENGTH)))) (WHEN INSTANCE-SLOTDS (FORMAT STREAM "The following slots have :INSTANCE allocation:~%") (DOLIST (SLOTD (NREVERSE INSTANCE-SLOTDS)) (DESCRIBE-SLOT (MOP:SLOT-DEFINITION-NAME SLOTD)))) (FORMAT STREAM "~%") (WHEN CLASS-SLOTDS (FORMAT STREAM "The following slots have :CLASS allocation:~%") (DOLIST (SLOTD (NREVERSE CLASS-SLOTDS)) (DESCRIBE-SLOT (MOP:SLOT-DEFINITION-NAME SLOTD))) (FORMAT STREAM "~%")))))
     [java] ; (DEFMETHOD DESCRIBE-OBJECT ((OBJECT STANDARD-OBJECT) STREAM) (%DESCRIBE-STANDARD-OBJECT/FUNCALLABLE OBJECT STREAM) (VALUES))
     [java] ; (DEFMETHOD DESCRIBE-OBJECT ((OBJECT MOP:FUNCALLABLE-STANDARD-OBJECT) STREAM) (%DESCRIBE-STANDARD-OBJECT/FUNCALLABLE OBJECT STREAM) (VALUES))
     [java] ; (DEFMETHOD DESCRIBE-OBJECT ((OBJECT JAVA:JAVA-OBJECT) STREAM) (JAVA:DESCRIBE-JAVA-OBJECT OBJECT STREAM))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/describe.abcl (1.325 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/describe-compiler-policy.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN DESCRIBE-COMPILER-POLICY NIL (FORMAT T "~&; Compiler policy: safety ~D, space ~D, speed ~D, debug ~D~%" *SAFETY* *SPACE* *SPEED* *DEBUG*) (VALUES))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/describe-compiler-policy.abcl (0.083 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/directory.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN PATHNAME-AS-FILE (PATHNAME) (LET ((DIRECTORY (PATHNAME-DIRECTORY PATHNAME))) (MAKE-PATHNAME :HOST NIL :DEVICE (PATHNAME-DEVICE PATHNAME) :DIRECTORY (BUTLAST DIRECTORY) :NAME (CAR (LAST DIRECTORY)) :TYPE NIL :VERSION NIL)))
     [java] ; (DEFUN WILD-INFERIORS-P (COMPONENT) (EQ COMPONENT :WILD-INFERIORS))
     [java] ; (DEFUN LIST-DIRECTORIES-WITH-WILDCARDS (PATHNAME WILD-INFERIORS-FOUND RESOLVE-SYMLINKS) (LET* ((DIRECTORY (PATHNAME-DIRECTORY PATHNAME)) (FIRST-WILD-INFERIOR (AND (NOT WILD-INFERIORS-FOUND) (POSITION-IF (FUNCTION WILD-INFERIORS-P) DIRECTORY))) (FIRST-WILD (POSITION-IF (FUNCTION WILD-P) DIRECTORY)) (WILD (WHEN (OR FIRST-WILD-INFERIOR FIRST-WILD) (NTHCDR (OR FIRST-WILD-INFERIOR FIRST-WILD) DIRECTORY))) (NON-WILD (IF (OR FIRST-WILD-INFERIOR FIRST-WILD) (NBUTLAST DIRECTORY (- (LENGTH DIRECTORY) (OR FIRST-WILD-INFERIOR FIRST-WILD))) DIRECTORY)) (NEWPATH (MAKE-PATHNAME :DIRECTORY NON-WILD :NAME NIL :TYPE NIL :DEFAULTS PATHNAME)) (ENTRIES (LIST-DIRECTORY NEWPATH RESOLVE-SYMLINKS))) (WHEN (NOT (OR WILD WILD-INFERIORS-FOUND)) (RETURN-FROM LIST-DIRECTORIES-WITH-WILDCARDS ENTRIES)) (LET ((INFERIOR-ENTRIES (WHEN (OR WILD-INFERIORS-FOUND FIRST-WILD-INFERIOR) ENTRIES))) (NCONC (MAPCAN (LAMBDA (ENTRY) (WHEN (PATHNAME-MATCH-P (PATHNAME ENTRY) PATHNAME) (LIST ENTRY))) INFERIOR-ENTRIES) (MAPCAN (LAMBDA (ENTRY) (LET* ((PATHNAME (PATHNAME ENTRY)) (DIRECTORY (PATHNAME-DIRECTORY PATHNAME)) (REST-WILD (CDR WILD))) (UNLESS (PATHNAME-NAME PATHNAME) (WHEN (PATHNAME-MATCH-P (FIRST (LAST DIRECTORY)) (COND ((EQL (CAR WILD) :WILD) "*") ((EQL (CAR WILD) :WILD-INFERIORS) "*") (WILD (CAR WILD)) (T ""))) (WHEN (AND (NOT (OR FIRST-WILD-INFERIOR WILD-INFERIORS-FOUND)) REST-WILD) (SETF DIRECTORY (NCONC DIRECTORY REST-WILD))) (LET ((RECURSE (MAKE-PATHNAME :DIRECTORY DIRECTORY :DEFAULTS NEWPATH))) (WHEN (NOT (EQUAL RECURSE NEWPATH)) (LIST-DIRECTORIES-WITH-WILDCARDS RECURSE (OR FIRST-WILD-INFERIOR WILD-INFERIORS-FOUND) RESOLVE-SYMLINKS))))))) ENTRIES)))))
     [java] ; (DEFUN DIRECTORY (PATHSPEC &KEY (RESOLVE-SYMLINKS NIL)) "Determines which, if any, files that are present in the file system have names matching PATHSPEC, and returns a fresh list of pathnames corresponding to the potential truenames of those files.
     [java]
     [java] With :RESOLVE-SYMLINKS set to nil, not all pathnames returned may
     [java] correspond to an existing file.  Symbolic links are considered to be
     [java] be valid entries even if they do not currently have a valid file or
     [java] directory as a target.  Therefore, subsequent CL:TRUENAME call on
     [java] individual pathnames in the list may signal an error, i.e. the
     [java] pathnames have been constructed as truenames, without calling the
     [java] entire resolution routine of CL:TRUENAME.
     [java]
     [java] If called with :RESOLVE-SYMLINKS set to T, and any of the pathnames
     [java] have truenames which do not exist, this routine will signal a file
     [java] error to its caller." (LET ((PATHNAME (MERGE-PATHNAMES PATHSPEC))) (WHEN (LOGICAL-PATHNAME-P PATHNAME) (SETQ PATHNAME (TRANSLATE-LOGICAL-PATHNAME PATHNAME))) (IF (OR (POSITION #\* (NAMESTRING PATHNAME)) (WILD-PATHNAME-P PATHNAME)) (IF (PATHNAME-JAR-P PATHNAME) (MATCH-WILD-JAR-PATHNAME PATHNAME) (LET ((NAMESTRING (DIRECTORY-NAMESTRING PATHNAME))) (WHEN (AND NAMESTRING (> (LENGTH NAMESTRING) 0)) (WHEN (FEATUREP :WINDOWS) (LET ((HOST (PATHNAME-HOST PATHNAME)) (DEVICE (PATHNAME-DEVICE PATHNAME))) (COND ((AND HOST DEVICE) (SETQ NAMESTRING (CONCATENATE (QUOTE STRING) "//" HOST "/" DEVICE NAMESTRING))) (DEVICE (SETQ NAMESTRING (CONCATENATE (QUOTE STRING) DEVICE ":" NAMESTRING)))))) (LET ((ENTRIES (LIST-DIRECTORIES-WITH-WILDCARDS NAMESTRING NIL RESOLVE-SYMLINKS)) (MATCHING-ENTRIES NIL)) (DOLIST (ENTRY ENTRIES) (WHEN (OR (AND (FILE-DIRECTORY-P ENTRY :WILD-ERROR-P NIL) (PATHNAME-MATCH-P (FILE-NAMESTRING (PATHNAME-AS-FILE ENTRY)) (FILE-NAMESTRING PATHNAME))) (PATHNAME-MATCH-P (OR (FILE-NAMESTRING ENTRY) "") (FILE-NAMESTRING PATHNAME))) (PUSH (IF RESOLVE-SYMLINKS (TRUENAME ENTRY) (IF (AND (NOT (FIND :WINDOWS *FEATURES*)) (NOT (PATHNAME-DEVICE ENTRY))) (MAKE-PATHNAME :DEFAULTS ENTRY :DEVICE :UNSPECIFIC) ENTRY)) MATCHING-ENTRIES))) MATCHING-ENTRIES)))) (LET ((TRUENAME (PROBE-FILE PATHNAME))) (IF TRUENAME (LIST (PATHNAME TRUENAME)) NIL)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/directory.abcl (0.189 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/disassemble.lisp ...
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DEFVAR *DISASSEMBLER-FUNCTION* NIL "The currently used function for CL:DISASSEMBLE.
     [java]
     [java] Available disassemblers are configured by pushing a strategy to SYSTEM:*DISASSEMBLERS*.
     [java]
     [java] SYSTEM:CHOOSE-DISASSEMBLER selects a current strategy from this list .")
     [java] ; (DEFVAR *DISASSEMBLERS* (QUOTE ((:JAD . DISASSEMBLE-CLASS-BYTES))) "Methods of invoking CL:DISASSEMBLE consisting of a pushable list of (name function), where function takes a object to disassemble, returns the results as a string.
     [java]
     [java] The system is :jad using the venerable-but-still-works JAD.
     [java] ")
     [java] ; (DEFUN CHOOSE-DISASSEMBLER (&OPTIONAL NAME) "Hook to choose invoked behavior of CL:DISASSEMBLE by using one of the methods registered in SYSTEM:*DISASSEMBLERS*.
     [java]
     [java] Optionally, prefer the strategy named NAME if one exists." (SETF *DISASSEMBLER-FUNCTION* (IF NAME (LET ((DISASSEMBLER (CDR (ASSOC NAME *DISASSEMBLERS*)))) (IF (AND DISASSEMBLER (FBOUNDP DISASSEMBLER)) DISASSEMBLER (ERROR "Disassembler ~a doesn't appear to work." NAME))) (LOOP :FOR (NIL . DISASSEMBLER) IN *DISASSEMBLERS* :WHEN (AND DISASSEMBLER (FBOUNDP DISASSEMBLER)) :DO (RETURN DISASSEMBLER) FINALLY (WARN "Can't find suitable disassembler.")))))
     [java] ; (DEFMACRO WITH-OPEN ((NAME VALUE) &BODY BODY) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST NAME VALUE)) (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-CONS (QUOTE PROGN) BODY) (BACKQ-LIST (QUOTE JAVA:JCALL-RAW) "close" NAME))))
     [java] ; (DEFUN READ-BYTE-ARRAY-FROM-STREAM (STREAM) (LET ((BUFFER (JAVA:JNEW-ARRAY (JAVA:JCLASS "byte") 4096))) (WITH-OPEN (OUTPUT (JAVA:JNEW "java.io.ByteArrayOutputStream")) (LOOP FOR LENGTH = (JAVA:JCALL "read" STREAM BUFFER) UNTIL (EQL LENGTH -1) DO (JAVA:JCALL-RAW "write" OUTPUT BUFFER 0 LENGTH)) (JAVA:JCALL-RAW "flush" OUTPUT) (JAVA:JCALL-RAW "toByteArray" OUTPUT))))
     [java] ; (DEFUN CLASS-RESOURCE-PATH (CLASS) (FORMAT NIL "~A.class" (SUBSTITUTE #\/ #\. (JAVA:JCALL "getName" CLASS))))
     [java] ; (DEFUN CLASS-BYTES (CLASS) (WITH-OPEN (STREAM (JAVA:JCALL-RAW "getResourceAsStream" (JAVA:JCALL-RAW "getClassLoader" CLASS) (CLASS-RESOURCE-PATH CLASS))) (READ-BYTE-ARRAY-FROM-STREAM STREAM)))
     [java] ; (DEFUN DISASSEMBLE-BYTES (BYTES) "Disassemble jvm code BYTES returning a string." (FUNCALL (OR *DISASSEMBLER-FUNCTION* (CHOOSE-DISASSEMBLER)) BYTES))
     [java] ; (DEFUN DISASSEMBLE-FUNCTION (ARG) (LET ((FUNCTION (COND ((JAVA:JAVA-OBJECT-P ARG) (COND ((JAVA:JINSTANCE-OF-P ARG "java.lang.Class") ARG) ((JAVA:JINSTANCE-OF-P ARG "java.lang.reflect.Method") (JAVA::JMETHOD-DECLARING-CLASS ARG)))) ((FUNCTIONP ARG) ARG) ((SYMBOLP ARG) (OR (MACRO-FUNCTION ARG) (SYMBOL-FUNCTION ARG))) (T ARG)))) (WHEN (TYPEP FUNCTION (QUOTE GENERIC-FUNCTION)) (SETF FUNCTION (MOP::FUNCALLABLE-INSTANCE-FUNCTION FUNCTION))) (WHEN (AND (JAVA:JCALL "isInstance" (JAVA:JCLASS "org.armedbear.lisp.Closure") FUNCTION) (NOT (JAVA:JCALL "isInstance" (JAVA:JCLASS "org.armedbear.lisp.CompiledClosure") FUNCTION))) (RETURN-FROM DISASSEMBLE-FUNCTION (WITH-OUTPUT-TO-STRING (S) (FORMAT S "Not a compiled function: ~%") (PPRINT (JAVA:JCALL "getBody" FUNCTION) S)))) (LET ((BYTES (OR (AND (JAVA:JCALL "isInstance" (JAVA:JCLASS "org.armedbear.lisp.Function") FUNCTION) (IGNORE-ERRORS (GETF (FUNCTION-PLIST FUNCTION))) (QUOTE CLASS-BYTES)) (AND (JAVA:JCALL "isInstance" (JAVA:JCLASS "org.armedbear.lisp.CompiledClosure") FUNCTION) (EQUALP (JAVA:JCALL "getName" (JAVA:JOBJECT-CLASS (JAVA:JCALL "getClassLoader" (JAVA:JCALL "getClass" FUNCTION)))) "org.armedbear.lisp.FaslClassLoader") (FASL-COMPILED-CLOSURE-CLASS-BYTES FUNCTION))))) (IF BYTES (DISASSEMBLE-BYTES BYTES) (LET ((CLASS (IF (JAVA:JAVA-OBJECT-P FUNCTION) FUNCTION (JAVA:JCALL "getClass" FUNCTION)))) (LET ((CLASSLOADER (JAVA:JCALL "getClassLoader" CLASS))) (IF (OR (JAVA:JINSTANCE-OF-P CLASSLOADER "org.armedbear.lisp.MemoryClassLoader") (JAVA:JINSTANCE-OF-P CLASSLOADER "org.armedbear.lisp.FaslClassLoader")) (DISASSEMBLE-BYTES (JAVA:JCALL "getFunctionClassBytes" CLASSLOADER CLASS)) (DISASSEMBLE-BYTES (READ-BYTE-ARRAY-FROM-STREAM (JAVA:JCALL-RAW "getResourceAsStream" (JAVA:JCALL-RAW "getClassLoader" CLASS) (CLASS-RESOURCE-PATH CLASS)))))))))))
     [java] ; (DEFPARAMETER +PROPERTYLIST+ (LOAD-TIME-VALUE (LET ((IT (FIND "propertyList" (JAVA:JCALL "getDeclaredFields" (JAVA:JCLASS "org.armedbear.lisp.Function")) :KEY (LAMBDA (E) (JAVA:JCALL "getName" E)) :TEST (QUOTE EQUAL)))) (JAVA:JCALL "setAccessible" IT T) IT)))
     [java] ; (DEFUN FUNCTION-PLIST (FUNCTION) (JAVA:JCALL "get" +PROPERTYLIST+ FUNCTION))
     [java] ; (DEFUN (SETF FUNCTION-PLIST) (NEW FUNCTION) (JAVA:JCALL "set" +PROPERTYLIST+ FUNCTION NEW))
     [java] ; (DEFUN GET-LOADED-FROM (FUNCTION) (LET* ((JFIELD (FIND "loadedFrom" (JAVA:JCALL "getDeclaredFields" (JAVA:JCLASS "org.armedbear.lisp.Function")) :KEY (QUOTE JAVA:JFIELD-NAME) :TEST (QUOTE EQUAL)))) (JAVA:JCALL "setAccessible" JFIELD JAVA:+TRUE+) (JAVA:JCALL "get" JFIELD FUNCTION)))
     [java] ; (DEFUN SET-LOADED-FROM (FUNCTION VALUE) (LET* ((JFIELD (FIND "loadedFrom" (JAVA:JCALL "getDeclaredFields" (JAVA:JCLASS "org.armedbear.lisp.Function")) :KEY (QUOTE JAVA:JFIELD-NAME) :TEST (QUOTE EQUAL)))) (JAVA:JCALL "setAccessible" JFIELD JAVA:+TRUE+) (JAVA:JCALL "set" JFIELD FUNCTION VALUE)))
     [java] ; (DEFUN FASL-COMPILED-CLOSURE-CLASS-BYTES (FUNCTION) (LET* ((LOADED-FROM (GET-LOADED-FROM FUNCTION)) (CLASS-NAME (SUBSEQ (JAVA:JCALL "getName" (JAVA:JCALL "getClass" FUNCTION)) (LENGTH "org.armedbear.lisp."))) (URL (IF (NOT (EQ (PATHNAME-DEVICE LOADED-FROM) :UNSPECIFIC)) (JAVA:JNEW "java.net.URL" (NAMESTRING (MAKE-PATHNAME :DIRECTORY (PATHNAME-DIRECTORY LOADED-FROM) :DEVICE (PATHNAME-DEVICE LOADED-FROM) :NAME CLASS-NAME :TYPE "cls"))) (JAVA:JNEW "java.net.URL" (NAMESTRING (MAKE-PATHNAME :DEVICE (LIST LOADED-FROM) :NAME CLASS-NAME :TYPE "cls")))))) (READ-BYTE-ARRAY-FROM-STREAM (JAVA:JCALL "openStream" URL))))
     [java] ; (DEFUN DISASSEMBLE (ARG) (PRINT-LINES-WITH-PREFIX (DISASSEMBLE-FUNCTION ARG)))
     [java] ; (DEFUN PRINT-LINES-WITH-PREFIX (STRING) (WITH-INPUT-FROM-STRING (STREAM STRING) (LOOP (LET ((LINE (READ-LINE STREAM NIL))) (UNLESS LINE (RETURN)) (WRITE-STRING "; ") (WRITE-STRING LINE) (TERPRI)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/disassemble.abcl (0.661 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/do-all-symbols.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DO-ALL-SYMBOLS ((VAR &OPTIONAL RESULT-FORM) &BODY BODY) (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY NIL) (LET ((FLET-NAME (GENSYM "DO-SYMBOLS-"))) (BACKQ-LIST (QUOTE BLOCK) NIL (BACKQ-LIST (QUOTE FLET) (BACKQ-LIST (BACKQ-LIST* FLET-NAME (BACKQ-LIST VAR) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-CONS (QUOTE TAGBODY) FORMS))))) (BACKQ-LIST* (QUOTE MAPC) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (PACKAGE)) (BACKQ-LIST* (QUOTE FLET) (BACKQ-LIST (BACKQ-LIST (QUOTE ITERATE-OVER-SYMBOLS) (QUOTE (SYMBOLS)) (BACKQ-LIST* (QUOTE MAPC) (BACKQ-LIST (QUOTE FUNCTION) FLET-NAME) (QUOTE (SYMBOLS))))) (QUOTE ((ITERATE-OVER-SYMBOLS (PACKAGE-INTERNAL-SYMBOLS PACKAGE)) (ITERATE-OVER-SYMBOLS (PACKAGE-EXTERNAL-SYMBOLS PACKAGE))))))) (QUOTE ((LIST-ALL-PACKAGES))))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-CONS VAR (QUOTE (NIL)))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORABLE) VAR)) (BACKQ-APPEND DECLS (BACKQ-LIST RESULT-FORM)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/do-all-symbols.abcl (0.068 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/do-external-symbols.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO DO-EXTERNAL-SYMBOLS ((VAR &OPTIONAL (PACKAGE (QUOTE *PACKAGE*)) (RESULT NIL)) &BODY BODY) (BACKQ-LIST* (QUOTE DOLIST) (BACKQ-LIST VAR (BACKQ-LIST (QUOTE PACKAGE-EXTERNAL-SYMBOLS) PACKAGE) RESULT) BODY))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/do-external-symbols.abcl (0.046 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/do-symbols.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO DO-SYMBOLS ((VAR &OPTIONAL (PACKAGE (QUOTE *PACKAGE*)) (RESULT NIL)) &BODY BODY) (BACKQ-LIST* (QUOTE DOLIST) (BACKQ-LIST VAR (BACKQ-LIST (QUOTE APPEND) (BACKQ-LIST (QUOTE PACKAGE-SYMBOLS) PACKAGE) (BACKQ-LIST (QUOTE PACKAGE-INHERITED-SYMBOLS) PACKAGE)) RESULT) BODY))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/do-symbols.abcl (0.051 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/do.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN DO-DO-BODY (VARLIST ENDLIST DECLS-AND-CODE BIND STEP NAME BLOCK) (LET* ((INITS NIL) (STEPS NIL) (L1 (GENSYM)) (L2 (GENSYM))) (WHEN (OR (NOT (LISTP VARLIST)) (ATOM ENDLIST)) (ERROR "Ill-formed ~S -- possibly illegal old style DO?" NAME)) (DOLIST (V VARLIST) (COND ((SYMBOLP V) (PUSH V INITS)) ((LISTP V) (UNLESS (SYMBOLP (FIRST V)) (ERROR "~S step variable is not a symbol: ~S" NAME (FIRST V))) (CASE (LENGTH V) (1 (PUSH (FIRST V) INITS)) (2 (PUSH V INITS)) (3 (PUSH (LIST (FIRST V) (SECOND V)) INITS) (SETQ STEPS (LIST* (THIRD V) (FIRST V) STEPS))) (T (ERROR "~S is an illegal form for a ~S varlist." V NAME)))) (T (ERROR "~S is an illegal form for a ~S varlist." V NAME)))) (MULTIPLE-VALUE-BIND (CODE DECLS) (PARSE-BODY DECLS-AND-CODE NIL) (BACKQ-LIST (QUOTE BLOCK) BLOCK (BACKQ-LIST* BIND (NREVERSE INITS) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST* (QUOTE TAGBODY) (BACKQ-LIST (QUOTE GO) L2) L1 (BACKQ-APPEND CODE (BACKQ-LIST (BACKQ-CONS STEP (NREVERSE STEPS)) L2 (BACKQ-LIST (QUOTE UNLESS) (CAR ENDLIST) (BACKQ-LIST (QUOTE GO) L1)) (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK (BACKQ-CONS (QUOTE PROGN) (CDR ENDLIST)))))))))))))
     [java] ; (DEFMACRO DO (VARLIST ENDLIST &REST BODY) (DO-DO-BODY VARLIST ENDLIST BODY (QUOTE LET) (QUOTE PSETQ) (QUOTE DO) NIL))
     [java] ; (DEFMACRO DO* (VARLIST ENDLIST &REST BODY) (DO-DO-BODY VARLIST ENDLIST BODY (QUOTE LET*) (QUOTE SETQ) (QUOTE DO*) NIL))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/do.abcl (0.107 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/documentation.lisp ...
     [java] ; (IN-PACKAGE #:MOP)
     [java] ; (DEFGENERIC DOCUMENTATION (X DOC-TYPE) (:METHOD ((X SYMBOL) DOC-TYPE) (%DOCUMENTATION X DOC-TYPE)) (:METHOD ((X FUNCTION) DOC-TYPE) (%DOCUMENTATION X DOC-TYPE)))
     [java] ; (DEFGENERIC (SETF DOCUMENTATION) (NEW-VALUE X DOC-TYPE) (:METHOD (NEW-VALUE (X SYMBOL) DOC-TYPE) (%SET-DOCUMENTATION X DOC-TYPE NEW-VALUE)) (:METHOD (NEW-VALUE (X FUNCTION) DOC-TYPE) (%SET-DOCUMENTATION X DOC-TYPE NEW-VALUE)))
     [java] ; (DEFVAR *LIST-DOCUMENTATION-HASHTABLE* (MAKE-HASH-TABLE :TEST (FUNCTION EQUAL)))
     [java] ; (DEFMETHOD DOCUMENTATION ((X LIST) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (LET ((ALIST (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*))) (AND ALIST (CDR (ASSOC DOC-TYPE ALIST)))))
     [java] ; (DEFMETHOD DOCUMENTATION ((X LIST) (DOC-TYPE (EQL (QUOTE COMPILER-MACRO)))) (LET ((ALIST (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*))) (AND ALIST (CDR (ASSOC DOC-TYPE ALIST)))))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X LIST) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (LET* ((ALIST (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*)) (ENTRY (AND ALIST (ASSOC DOC-TYPE ALIST)))) (COND (ENTRY (SETF (CDR ENTRY) NEW-VALUE)) (T (SETF (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*) (PUSH (CONS DOC-TYPE NEW-VALUE) ALIST))))) NEW-VALUE)
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X LIST) (DOC-TYPE (EQL (QUOTE COMPILER-MACRO)))) (LET* ((ALIST (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*)) (ENTRY (AND ALIST (ASSOC DOC-TYPE ALIST)))) (COND (ENTRY (SETF (CDR ENTRY) NEW-VALUE)) (T (SETF (GETHASH X *LIST-DOCUMENTATION-HASHTABLE*) (PUSH (CONS DOC-TYPE NEW-VALUE) ALIST))))) NEW-VALUE)
     [java] ; (DEFMETHOD DOCUMENTATION ((X CLASS) (DOC-TYPE (EQL (QUOTE T)))) (CLASS-DOCUMENTATION X))
     [java] ; (DEFMETHOD DOCUMENTATION ((X CLASS) (DOC-TYPE (EQL (QUOTE TYPE)))) (CLASS-DOCUMENTATION X))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X CLASS) (DOC-TYPE (EQL (QUOTE T)))) (%SET-CLASS-DOCUMENTATION X NEW-VALUE))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X CLASS) (DOC-TYPE (EQL (QUOTE TYPE)))) (%SET-CLASS-DOCUMENTATION X NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STRUCTURE-CLASS) (DOC-TYPE (EQL (QUOTE T)))) (%DOCUMENTATION X T))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STRUCTURE-CLASS) (DOC-TYPE (EQL (QUOTE TYPE)))) (%DOCUMENTATION X T))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STRUCTURE-CLASS) (DOC-TYPE (EQL (QUOTE T)))) (%SET-DOCUMENTATION X T NEW-VALUE))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STRUCTURE-CLASS) (DOC-TYPE (EQL (QUOTE TYPE)))) (%SET-DOCUMENTATION X T NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STANDARD-GENERIC-FUNCTION) (DOC-TYPE (EQL (QUOTE T)))) (STD-SLOT-VALUE X (QUOTE %DOCUMENTATION)))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STANDARD-GENERIC-FUNCTION) (DOC-TYPE (EQL (QUOTE T)))) (SETF (STD-SLOT-VALUE X (QUOTE %DOCUMENTATION)) NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STANDARD-GENERIC-FUNCTION) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (STD-SLOT-VALUE X (QUOTE %DOCUMENTATION)))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STANDARD-GENERIC-FUNCTION) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (SETF (STD-SLOT-VALUE X (QUOTE %DOCUMENTATION)) NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STANDARD-METHOD) (DOC-TYPE (EQL (QUOTE T)))) (METHOD-DOCUMENTATION X))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STANDARD-METHOD) (DOC-TYPE (EQL (QUOTE T)))) (SETF (METHOD-DOCUMENTATION X) NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X STANDARD-SLOT-DEFINITION) (DOC-TYPE (EQL (QUOTE T)))) (SLOT-DEFINITION-DOCUMENTATION X))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X STANDARD-SLOT-DEFINITION) (DOC-TYPE (EQL (QUOTE T)))) (SETF (SLOT-DEFINITION-DOCUMENTATION X) NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X PACKAGE) (DOC-TYPE (EQL (QUOTE T)))) (%DOCUMENTATION X DOC-TYPE))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X PACKAGE) (DOC-TYPE (EQL (QUOTE T)))) (%SET-DOCUMENTATION X DOC-TYPE NEW-VALUE))
     [java] ; (DEFMETHOD DOCUMENTATION ((X SYMBOL) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (IF (AND (FBOUNDP X) (TYPEP (FDEFINITION X) (QUOTE GENERIC-FUNCTION))) (DOCUMENTATION (FDEFINITION X) DOC-TYPE) (%DOCUMENTATION X DOC-TYPE)))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X SYMBOL) (DOC-TYPE (EQL (QUOTE FUNCTION)))) (IF (AND (FBOUNDP X) (TYPEP (FDEFINITION X) (QUOTE GENERIC-FUNCTION))) (SETF (DOCUMENTATION (FDEFINITION X) (QUOTE FUNCTION)) NEW-VALUE) (%SET-DOCUMENTATION X (QUOTE FUNCTION) NEW-VALUE)))
     [java] ; (DEFMETHOD DOCUMENTATION ((X SYMBOL) (DOC-TYPE (EQL (QUOTE TYPE)))) (LET ((CLASS (FIND-CLASS X NIL))) (IF CLASS (DOCUMENTATION CLASS T) (%DOCUMENTATION X (QUOTE TYPE)))))
     [java] ; (DEFMETHOD DOCUMENTATION ((X SYMBOL) (DOC-TYPE (EQL (QUOTE STRUCTURE)))) (%DOCUMENTATION X (QUOTE STRUCTURE)))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X SYMBOL) (DOC-TYPE (EQL (QUOTE TYPE)))) (LET ((CLASS (FIND-CLASS X NIL))) (IF CLASS (SETF (DOCUMENTATION CLASS T) NEW-VALUE) (%SET-DOCUMENTATION X (QUOTE TYPE) NEW-VALUE))))
     [java] ; (DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (X SYMBOL) (DOC-TYPE (EQL (QUOTE STRUCTURE)))) (%SET-DOCUMENTATION X (QUOTE STRUCTURE) NEW-VALUE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/documentation.abcl (0.873 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dolist.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DOLIST ((VAR LIST-FORM &OPTIONAL (RESULT-FORM NIL)) &BODY BODY) (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY NIL) (LET ((LIST (GENSYM "LIST-")) (TOP (GENSYM "TOP-"))) (BACKQ-LIST (QUOTE BLOCK) NIL (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST LIST LIST-FORM)) (BACKQ-LIST (QUOTE TAGBODY) TOP (BACKQ-LIST (QUOTE UNLESS) (BACKQ-LIST (QUOTE ENDP) LIST) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR (BACKQ-LIST (QUOTE %CAR) LIST))) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE SETQ) LIST (BACKQ-LIST (QUOTE %CDR) LIST)) (BACKQ-CONS (QUOTE TAGBODY) FORMS)))) (BACKQ-LIST (QUOTE GO) TOP)))) (IF (CONSTANTP RESULT-FORM) RESULT-FORM (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-CONS VAR (QUOTE (NIL)))) (BACKQ-APPEND DECLS (BACKQ-LIST VAR RESULT-FORM))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dolist.abcl (0.064 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dotimes.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DOTIMES ((VAR COUNT &OPTIONAL (RESULT NIL)) &BODY BODY) (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY NIL) (LET ((INDEX (GENSYM "INDEX-")) (TOP (GENSYM "TOP-"))) (IF (NUMBERP COUNT) (BACKQ-LIST (QUOTE BLOCK) NIL (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-CONS VAR (QUOTE (0))) (BACKQ-CONS INDEX (QUOTE (0)))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE TYPE) (BACKQ-LIST (QUOTE INTEGER) 0 COUNT) INDEX)) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORABLE) VAR)) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE WHEN) (BACKQ-LIST* (QUOTE >) COUNT (QUOTE (0))) (BACKQ-LIST* (QUOTE TAGBODY) TOP (BACKQ-APPEND FORMS (BACKQ-LIST (BACKQ-LIST (QUOTE SETQ) INDEX (BACKQ-LIST (QUOTE 1+) INDEX)) (BACKQ-LIST (QUOTE SETQ) VAR INDEX) (BACKQ-LIST (QUOTE WHEN) (BACKQ-LIST (QUOTE <) INDEX COUNT) (BACKQ-LIST (QUOTE GO) TOP)))))) (BACKQ-LIST (QUOTE PROGN) RESULT))))) (LET ((LIMIT (GENSYM "LIMIT-"))) (SETF (GET LIMIT (QUOTE DOTIMES-LIMIT-VARIABLE-P)) T) (SETF (GET INDEX (QUOTE DOTIMES-INDEX-VARIABLE-NAME)) INDEX) (SETF (GET INDEX (QUOTE DOTIMES-INDEX-VARIABLE-P)) T) (SETF (GET LIMIT (QUOTE DOTIMES-LIMIT-VARIABLE-NAME)) LIMIT) (BACKQ-LIST (QUOTE BLOCK) NIL (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-CONS VAR (QUOTE (0))) (BACKQ-LIST LIMIT COUNT) (BACKQ-CONS INDEX (QUOTE (0)))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORABLE) VAR)) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE WHEN) (BACKQ-LIST* (QUOTE >) LIMIT (QUOTE (0))) (BACKQ-LIST* (QUOTE TAGBODY) TOP (BACKQ-APPEND FORMS (BACKQ-LIST (BACKQ-LIST (QUOTE SETQ) INDEX (BACKQ-LIST (QUOTE 1+) INDEX)) (BACKQ-LIST (QUOTE SETQ) VAR INDEX) (BACKQ-LIST (QUOTE WHEN) (BACKQ-LIST (QUOTE <) INDEX LIMIT) (BACKQ-LIST (QUOTE GO) TOP)))))) (BACKQ-LIST (QUOTE PROGN) RESULT))))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dotimes.abcl (0.087 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dribble.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFVAR *PREVIOUS-DRIBBLE-STREAMS* NIL)
     [java] ; (DEFVAR *DRIBBLE-STREAM* NIL)
     [java] ; (DEFUN DRIBBLE (&OPTIONAL PATHNAME &KEY (IF-EXISTS :APPEND)) "With a file name as an argument, dribble opens the file and sends a
     [java]   record of further I/O to that file. Without an argument, it closes
     [java]   the dribble file, and quits logging." (COND (PATHNAME (LET* ((NEW-DRIBBLE-STREAM (OPEN PATHNAME :DIRECTION :OUTPUT :IF-EXISTS IF-EXISTS :IF-DOES-NOT-EXIST :CREATE)) (NEW-STANDARD-OUTPUT (MAKE-BROADCAST-STREAM *STANDARD-OUTPUT* NEW-DRIBBLE-STREAM)) (NEW-ERROR-OUTPUT (MAKE-BROADCAST-STREAM *ERROR-OUTPUT* NEW-DRIBBLE-STREAM)) (NEW-STANDARD-INPUT (MAKE-ECHO-STREAM *STANDARD-INPUT* NEW-DRIBBLE-STREAM))) (PUSH (LIST *DRIBBLE-STREAM* *STANDARD-INPUT* *STANDARD-OUTPUT* *ERROR-OUTPUT*) *PREVIOUS-DRIBBLE-STREAMS*) (SETF *DRIBBLE-STREAM* NEW-DRIBBLE-STREAM) (SETF *STANDARD-INPUT* NEW-STANDARD-INPUT) (SETF *STANDARD-OUTPUT* NEW-STANDARD-OUTPUT) (SETF *ERROR-OUTPUT* NEW-ERROR-OUTPUT))) ((NULL *DRIBBLE-STREAM*) (ERROR "Not currently dribbling.")) (T (LET ((OLD-STREAMS (POP *PREVIOUS-DRIBBLE-STREAMS*))) (CLOSE *DRIBBLE-STREAM*) (SETF *DRIBBLE-STREAM* (FIRST OLD-STREAMS)) (SETF *STANDARD-INPUT* (SECOND OLD-STREAMS)) (SETF *STANDARD-OUTPUT* (THIRD OLD-STREAMS)) (SETF *ERROR-OUTPUT* (FOURTH OLD-STREAMS))))) (VALUES))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dribble.abcl (0.069 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/dump-class.lisp ...
     [java] ; (IN-PACKAGE #:JVM)
     [java] ; (DEFVAR *POOL* NIL)
     [java] ; (DEFUN READ-U1 (STREAM) (READ-BYTE STREAM))
     [java] ; (DEFUN READ-U2 (STREAM) (+ (ASH (READ-BYTE STREAM) 8) (READ-BYTE STREAM)))
     [java] ; (DEFUN READ-U4 (STREAM) (+ (ASH (READ-U2 STREAM) 16) (READ-U2 STREAM)))
     [java] ; (DEFUN LOOKUP-UTF8 (INDEX) (LET ((ENTRY (SVREF *POOL* INDEX))) (WHEN (EQL (CAR ENTRY) 1) (CADDR ENTRY))))
     [java] ; (DEFUN READ-CONSTANT-POOL-ENTRY (STREAM) (LET ((TAG (READ-U1 STREAM))) (CASE TAG ((7 8) (LIST TAG (READ-U2 STREAM))) (1 (QUOTE (LET* ((LEN (READ-U2 STREAM)) (S (MAKE-STRING LEN))) (DOTIMES (I LEN) (SETF (CHAR S I) (CODE-CHAR (READ-U1 STREAM)))) (LIST TAG LEN S)))) ((3 4) (LIST TAG (READ-U4 STREAM))) ((5 6) (LIST TAG (READ-U4 STREAM) (READ-U4 STREAM))) ((12 9 10 11) (LIST TAG (READ-U2 STREAM) (READ-U2 STREAM))) (T (ERROR "READ-CONSTANT-POOL-ENTRY unhandled tag ~D" TAG)))))
     [java] ; (DEFVAR *INDENT* 0)
     [java] ; (DEFPARAMETER *SPACES* (MAKE-STRING 256 :INITIAL-ELEMENT #\ ))
     [java] ; (DEFMACRO OUT (&REST ARGS) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (QUOTE (FORMAT T (SUBSEQ *SPACES* 0 *INDENT*))) (SYSTEM::BACKQ-LIST* (QUOTE FORMAT) (QUOTE T) ARGS)))
     [java] ; (DEFUN DUMP-CODE (CODE) (LET ((CODE-LENGTH (LENGTH CODE))) (DO ((I 0)) ((>= I CODE-LENGTH)) (LET* ((OPCODE (SVREF CODE I)) (SIZE (OPCODE-SIZE OPCODE))) (OUT "~D: ~D (#x~X) ~A~%" I OPCODE OPCODE (OPCODE-NAME OPCODE)) (INCF I) (DOTIMES (J (1- SIZE)) (LET ((BYTE (SVREF CODE I))) (OUT "~D: ~D (#x~X)~%" I BYTE BYTE)) (INCF I))))))
     [java] ; (DEFUN DUMP-CODE-ATTRIBUTE (STREAM) (LET ((*INDENT* (+ *INDENT* 2))) (OUT "Stack: ~D~%" (READ-U2 STREAM)) (OUT "Locals: ~D~%" (READ-U2 STREAM)) (LET* ((CODE-LENGTH (READ-U4 STREAM)) (CODE (MAKE-ARRAY CODE-LENGTH))) (OUT "Code length: ~D~%" CODE-LENGTH) (OUT "Code:~%") (DOTIMES (I CODE-LENGTH) (SETF (SVREF CODE I) (READ-U1 STREAM))) (LET ((*INDENT* (+ *INDENT* 2))) (DUMP-CODE CODE))) (LET ((EXCEPTION-TABLE-LENGTH (READ-U2 STREAM))) (OUT "Exception table length: ~D~%" EXCEPTION-TABLE-LENGTH) (LET ((*INDENT* (+ *INDENT* 2))) (DOTIMES (I EXCEPTION-TABLE-LENGTH) (OUT "Start PC: ~D~%" (READ-U2 STREAM)) (OUT "End PC: ~D~%" (READ-U2 STREAM)) (OUT "Handler PC: ~D~%" (READ-U2 STREAM)) (OUT "Catch type: ~D~%" (READ-U2 STREAM))))) (LET ((ATTRIBUTES-COUNT (READ-U2 STREAM))) (OUT "Number of attributes: ~D~%" ATTRIBUTES-COUNT) (LET ((*INDENT* (+ *INDENT* 2))) (DOTIMES (I ATTRIBUTES-COUNT) (READ-ATTRIBUTE I STREAM))))))
     [java] ; (DEFUN DUMP-EXCEPTIONS (STREAM) (DECLARE (IGNORE STREAM)))
     [java] ; (DEFUN READ-ATTRIBUTE (INDEX STREAM) (LET* ((NAME-INDEX (READ-U2 STREAM)) (NAME (LOOKUP-UTF8 NAME-INDEX)) (LENGTH (READ-U4 STREAM)) (*INDENT* (+ *INDENT* 2))) (OUT "Attribute ~D: Name index: ~D (~S)~%" INDEX NAME-INDEX NAME) (OUT "Attribute ~D: Length: ~D~%" INDEX LENGTH) (COND ((STRING= NAME "Code") (DUMP-CODE-ATTRIBUTE STREAM)) ((STRING= NAME "Exceptions") (LET ((COUNT (READ-U2 STREAM))) (OUT "Attribute ~D: Number of exceptions: ~D~%" INDEX COUNT) (LET ((*INDENT* (+ *INDENT* 2))) (DOTIMES (I COUNT) (OUT "Exception ~D: ~D~%" I (READ-U2 STREAM)))))) ((STRING= NAME "SourceFile") (LET ((SOURCE-FILE-INDEX (READ-U2 STREAM))) (OUT "Attribute ~D: Source file index: ~D (~S)~%" INDEX SOURCE-FILE-INDEX (LOOKUP-UTF8 SOURCE-FILE-INDEX)))) (T (DOTIMES (I LENGTH) (READ-U1 STREAM))))))
     [java] ; (DEFUN READ-INFO (INDEX STREAM TYPE) (LET* ((ACCESS-FLAGS (READ-U2 STREAM)) (NAME-INDEX (READ-U2 STREAM)) (DESCRIPTOR-INDEX (READ-U2 STREAM)) (ATTRIBUTES-COUNT (READ-U2 STREAM)) (*INDENT* (+ *INDENT* 2)) (TYPE (CASE TYPE ((QUOTE FIELD) "Field") ((QUOTE METHOD) "Method")))) (OUT "~A ~D: Access flags: #x~X~%" TYPE INDEX ACCESS-FLAGS) (OUT "~A ~D: Name index: ~D (~S)~%" TYPE INDEX NAME-INDEX (LOOKUP-UTF8 NAME-INDEX)) (OUT "~A ~D: Descriptor index: ~D~%" TYPE INDEX DESCRIPTOR-INDEX) (OUT "~A ~D: Number of attributes: ~D~%" TYPE INDEX ATTRIBUTES-COUNT) (LET ((*INDENT* (+ *INDENT* 2))) (DOTIMES (I ATTRIBUTES-COUNT) (READ-ATTRIBUTE I STREAM)))))
     [java] ; (DEFUN DUMP-CLASS (FILENAME) (LET ((*INDENT* 0) (*POOL* NIL)) (WITH-OPEN-FILE (STREAM FILENAME :DIRECTION :INPUT :ELEMENT-TYPE (QUOTE UNSIGNED-BYTE)) (HANDLER-BIND ((END-OF-FILE (FUNCTION (LAMBDA (C) (RETURN-FROM DUMP-CLASS C))))) (OUT "Magic number: #x~X~%" (READ-U4 STREAM)) (LET ((MINOR (READ-U2 STREAM)) (MAJOR (READ-U2 STREAM))) (OUT "Version: ~D.~D~%" MAJOR MINOR)) (LET ((COUNT (READ-U2 STREAM)) ENTRY TYPE) (OUT "Constant pool (~D entries):~%" COUNT) (SETQ *POOL* (MAKE-ARRAY COUNT)) (LET ((*INDENT* (+ *INDENT* 2))) (DOTIMES (INDEX (1- COUNT)) (SETQ ENTRY (READ-CONSTANT-POOL-ENTRY STREAM)) (SETF (SVREF *POOL* (1+ INDEX)) ENTRY) (SETQ TYPE (CASE (CAR ENTRY) (7 (QUOTE CLASS)) (9 (QUOTE FIELD)) (10 (QUOTE METHOD)) (11 (QUOTE INTERFACE)) (8 (QUOTE STRING)) (3 (QUOTE INTEGER)) (4 (QUOTE FLOAT)) (5 (QUOTE LONG)) (6 (QUOTE DOUBLE)) (12 (QUOTE NAME-AND-TYPE)) (1 (QUOTE UTF8)))) (OUT "~D: ~A ~S~%" (1+ INDEX) TYPE ENTRY)))) (OUT "Access flags: #x~X~%" (READ-U2 STREAM)) (OUT "This class: ~D~%" (READ-U2 STREAM)) (OUT "Superclass: ~D~%" (READ-U2 STREAM)) (LET ((COUNT (READ-U2 STREAM))) (COND ((ZEROP COUNT) (OUT "No interfaces~%")) (T (OUT "Interfaces (~D):~%" COUNT) (DOTIMES (I COUNT) (OUT "  ~D: ~D~%" I (READ-U2 STREAM)))))) (LET ((COUNT (READ-U2 STREAM))) (COND ((ZEROP COUNT) (OUT "No fields~%")) (T (OUT "Fields (~D):~%" COUNT))) (DOTIMES (INDEX COUNT) (READ-INFO INDEX STREAM (QUOTE FIELD)))) (LET ((COUNT (READ-U2 STREAM))) (COND ((ZEROP COUNT) (OUT "No methods~%")) (T (OUT "Methods (~D):~%" COUNT))) (DOTIMES (INDEX COUNT) (READ-INFO INDEX STREAM (QUOTE METHOD)))) (LET ((COUNT (READ-U2 STREAM))) (COND ((ZEROP COUNT) (OUT "No attributes~%")) (T (OUT "Attributes (~D):~%" COUNT))) (DOTIMES (INDEX COUNT) (READ-ATTRIBUTE INDEX STREAM)))))) T)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/dump-class.abcl (1.285 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/ed.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN ED (&OPTIONAL X) "Starts the editor (on a file or a function if named).  Functions
     [java] from the list *ED-FUNCTIONS* are called in order with X as an argument
     [java] until one of them returns non-NIL; these functions are responsible for
     [java] signalling a FILE-ERROR to indicate failure to perform an operation on
     [java] the file system." (DOLIST (FUN *ED-FUNCTIONS* (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "Don't know how to ~S ~A" :FORMAT-ARGUMENTS (LIST (QUOTE ED) X))) (WHEN (FUNCALL FUN X) (RETURN))) (VALUES))
     [java] ; (DEFUN DEFAULT-ED-FUNCTION (WHAT) (LET ((PORTFILE (MERGE-PATHNAMES ".j/port" (IF (FEATUREP :WINDOWS) (IF (PROBE-DIRECTORY "C:\\.j") "C:\\" (PROBE-DIRECTORY (PATHNAME (GETENV "APPDATA")))) (USER-HOMEDIR-PATHNAME)))) STREAM) (WHEN (PROBE-FILE PORTFILE) (LET* ((PORT (WITH-OPEN-FILE (S PORTFILE) (READ S NIL NIL))) (SOCKET (AND (INTEGERP PORT) (MAKE-SOCKET "127.0.0.1" PORT)))) (SETF STREAM (AND SOCKET (GET-SOCKET-STREAM SOCKET))))) (UNWIND-PROTECT (COND ((STRINGP WHAT) (IF STREAM (PROGN (WRITE-STRING (NAMESTRING (USER-HOMEDIR-PATHNAME)) STREAM) (TERPRI STREAM) (WRITE-STRING (FORMAT NIL "~S~%" WHAT) STREAM)) (RUN-SHELL-COMMAND (FORMAT NIL "j ~S" WHAT)))) ((AND WHAT (SYMBOLP WHAT)) (WHEN (AUTOLOADP WHAT) (LET ((*LOAD-VERBOSE* NIL) (*LOAD-PRINT* NIL) (*AUTOLOAD-VERBOSE* NIL)) (RESOLVE WHAT))) (COND ((SOURCE WHAT) (LET ((FILE (NAMESTRING (SOURCE-PATHNAME WHAT))) (POSITION (SOURCE-FILE-POSITION WHAT)) (LINE-NUMBER 1) (PATTERN (STRING WHAT))) (WITH-OPEN-FILE (S FILE) (DOTIMES (I POSITION) (LET ((C (READ-CHAR S NIL S))) (COND ((EQ C S) (RETURN)) ((EQL C #\Newline) (INCF LINE-NUMBER))))) (DOTIMES (I 10) (LET ((TEXT (READ-LINE S NIL S))) (COND ((EQ TEXT S) (RETURN)) ((SEARCH PATTERN TEXT :TEST (QUOTE STRING-EQUAL)) (RETURN)) (T (INCF LINE-NUMBER)))))) (IF STREAM (PROGN (WRITE-STRING (NAMESTRING (USER-HOMEDIR-PATHNAME)) STREAM) (TERPRI STREAM) (WRITE-STRING (FORMAT NIL "+~D~%~S~%" LINE-NUMBER FILE) STREAM)) (RUN-SHELL-COMMAND (FORMAT NIL "j +~D ~S" LINE-NUMBER FILE))))) ((NOT (NULL *LISP-HOME*)) (LET ((TAGFILE (MERGE-PATHNAMES "tags" *LISP-HOME*))) (WHEN (AND TAGFILE (PROBE-FILE TAGFILE)) (WITH-OPEN-FILE (S TAGFILE) (LOOP (LET ((TEXT (READ-LINE S NIL S))) (COND ((EQ TEXT S) (RETURN)) ((EQ WHAT (READ-FROM-STRING TEXT NIL NIL)) (WITH-INPUT-FROM-STRING (STRING-STREAM TEXT) (LET* ((SYMBOL (READ STRING-STREAM TEXT NIL NIL)) (FILE (READ STRING-STREAM TEXT NIL NIL)) (LINE-NUMBER (READ STRING-STREAM TEXT NIL NIL))) (DECLARE (IGNORE SYMBOL)) (WHEN (PATHNAMEP FILE) (SETF FILE (NAMESTRING FILE))) (IF STREAM (PROGN (WRITE-STRING (NAMESTRING (USER-HOMEDIR-PATHNAME)) STREAM) (TERPRI STREAM) (WRITE-STRING (FORMAT NIL "+~D~%~S~%" LINE-NUMBER FILE) STREAM)) (RUN-SHELL-COMMAND (FORMAT NIL "j +~D ~S" LINE-NUMBER FILE)))))))))))))))) (WHEN STREAM (CLOSE STREAM)))) T)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ed.abcl (0.3 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/enough-namestring.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DECLAIM (INLINE EQUAL-COMPONENTS-P))
     [java] ; (DEFUN EQUAL-COMPONENTS-P (COMPONENT1 COMPONENT2) (EQUAL COMPONENT1 COMPONENT2))
     [java] ; (DEFUN ENOUGH-NAMESTRING (PATHNAME &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)) (UNLESS (EQUAL (PATHNAME-HOST PATHNAME) (PATHNAME-HOST DEFAULTS)) (RETURN-FROM ENOUGH-NAMESTRING (NAMESTRING PATHNAME))) (LET ((PATHNAME-DIRECTORY (PATHNAME-DIRECTORY PATHNAME))) (IF PATHNAME-DIRECTORY (LET* ((DEFAULTS-DIRECTORY (PATHNAME-DIRECTORY DEFAULTS)) (PREFIX-LEN (LENGTH DEFAULTS-DIRECTORY)) (RESULT-DIRECTORY (COND ((AND (>= PREFIX-LEN 1) (>= (LENGTH PATHNAME-DIRECTORY) PREFIX-LEN) (EQUAL-COMPONENTS-P (SUBSEQ PATHNAME-DIRECTORY 0 PREFIX-LEN) DEFAULTS-DIRECTORY)) (CONS :RELATIVE (NTHCDR PREFIX-LEN PATHNAME-DIRECTORY))) ((EQ (CAR PATHNAME-DIRECTORY) :ABSOLUTE) PATHNAME-DIRECTORY) (T (RETURN-FROM ENOUGH-NAMESTRING (NAMESTRING PATHNAME)))))) (IF (EQUAL RESULT-DIRECTORY (QUOTE (:RELATIVE))) (FILE-NAMESTRING PATHNAME) (CONCATENATE (QUOTE SIMPLE-STRING) (DIRECTORY-NAMESTRING (MAKE-PATHNAME :DIRECTORY RESULT-DIRECTORY)) (FILE-NAMESTRING PATHNAME)))) (FILE-NAMESTRING PATHNAME))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/enough-namestring.abcl (0.065 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/ensure-directories-exist.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN ENSURE-DIRECTORIES-EXIST (PATHSPEC &KEY (VERBOSE NIL)) (LET ((PATHNAME (PATHNAME PATHSPEC)) (CREATED-P NIL)) (WHEN (OR (WILD-PATHNAME-P PATHNAME :HOST) (WILD-PATHNAME-P PATHNAME :DEVICE) (WILD-PATHNAME-P PATHNAME :DIRECTORY)) (ERROR (QUOTE FILE-ERROR) :FORMAT-CONTROL "Bad place for a wild HOST, DEVICE, or DIRECTORY component." :PATHNAME PATHNAME)) (LET ((DIR (PATHNAME-DIRECTORY PATHNAME))) (LOOP :FOR I :FROM 1 :UPTO (LENGTH DIR) :DOING (LET ((NEWPATH (MAKE-PATHNAME :HOST (PATHNAME-HOST PATHNAME) :DEVICE (IF (PATHNAME-DEVICE PATHNAME) (PATHNAME-DEVICE PATHNAME) :UNSPECIFIC) :DIRECTORY (SUBSEQ DIR 0 I)))) (UNLESS (PROBE-DIRECTORY NEWPATH) (WHEN VERBOSE (FRESH-LINE) (FORMAT *STANDARD-OUTPUT* "Creating directory of pathname ~A.~&" NEWPATH)) (MKDIR NEWPATH) (UNLESS (PROBE-DIRECTORY NEWPATH) (ERROR (QUOTE FILE-ERROR) :PATHNAME NEWPATH :FORMAT-CONTROL "Can't ensure directory~& ~S ~&ancestor of~&  ~S." :FORMAT-ARGUMENTS (LIST NEWPATH PATHNAME))) (SETQ CREATED-P T))))) (VALUES PATHNAME CREATED-P)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ensure-directories-exist.abcl (0.096 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/error.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFMACRO IGNORE-ERRORS (&REST FORMS) (SYSTEM::BACKQ-LIST* (QUOTE HANDLER-CASE) (SYSTEM::BACKQ-CONS (QUOTE PROGN) FORMS) (QUOTE ((ERROR (CONDITION) (VALUES NIL CONDITION))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/error.abcl (0.064 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/extensible-sequences.lisp ...
     [java] ; (IN-PACKAGE :SEQUENCE)
     [java] ; (FMAKUNBOUND (QUOTE LENGTH))
     [java] ; (DEFGENERIC LENGTH (SEQUENCE) (:DOCUMENTATION "Extension point for user-defined sequences. Invoked by cl:length."))
     [java] ; (DEFMETHOD LENGTH ((SEQUENCE SEQUENCE)) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE PROPER-SEQUENCE)))
     [java] ; (DEFMETHOD LENGTH ((SEQUENCE VECTOR)) (SYSTEM::%LENGTH SEQUENCE))
     [java] ; (DEFMETHOD LENGTH ((SEQUENCE LIST)) (SYSTEM::%LENGTH SEQUENCE))
     [java] ; (DEFMETHOD LENGTH (SEQUENCE) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE SEQUENCE)))
     [java] ; (DEFUN COMMON-LISP:LENGTH (SEQUENCE) (SEQ-DISPATCH SEQUENCE (SYSTEM::%LENGTH SEQUENCE) (SYSTEM::%LENGTH SEQUENCE) (LENGTH SEQUENCE)))
     [java] ; (DEFGENERIC ELT (SEQUENCE INDEX))
     [java] ; (DEFMETHOD ELT ((SEQUENCE VECTOR) INDEX) (SYSTEM::%ELT SEQUENCE INDEX))
     [java] ; (DEFMETHOD ELT ((SEQUENCE LIST) INDEX) (SYSTEM::%ELT SEQUENCE INDEX))
     [java] ; (DEFMETHOD ELT ((SEQUENCE SEQUENCE) INDEX) (DECLARE (IGNORE INDEX)) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE PROPER-SEQUENCE)))
     [java] ; (DEFMETHOD ELT (SEQUENCE INDEX) (DECLARE (IGNORE INDEX)) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE SEQUENCE)))
     [java] ; (DEFUN COMMON-LISP:ELT (SEQUENCE INDEX) (SEQ-DISPATCH SEQUENCE (SYSTEM::%ELT SEQUENCE INDEX) (SYSTEM::%ELT SEQUENCE INDEX) (ELT SEQUENCE INDEX)))
     [java] ; (DEFGENERIC (SETF ELT) (VALUE SEQUENCE INDEX))
     [java] ; (DEFMETHOD (SETF ELT) (VALUE (SEQUENCE VECTOR) INDEX) (SYSTEM::%SET-ELT SEQUENCE INDEX VALUE))
     [java] ; (DEFMETHOD (SETF ELT) (VALUE (SEQUENCE LIST) INDEX) (SYSTEM::%SET-ELT SEQUENCE INDEX VALUE))
     [java] ; (DEFMETHOD (SETF ELT) (VALUE (SEQUENCE SEQUENCE) INDEX) (DECLARE (IGNORE INDEX VALUE)) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE PROPER-SEQUENCE)))
     [java] ; (DEFMETHOD (SETF ELT) (VALUE SEQUENCE INDEX) (DECLARE (IGNORE INDEX VALUE)) (ERROR (QUOTE TYPE-ERROR) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE SEQUENCE)))
     [java] ; (DEFUN COMMON-LISP:SUBSEQ (SEQUENCE START &OPTIONAL END) "Return a copy of a subsequence of SEQUENCE starting with element number
     [java]    START and continuing to the end of SEQUENCE or the optional END." (SEQ-DISPATCH SEQUENCE (SYSTEM::%SUBSEQ SEQUENCE START END) (SYSTEM::%SUBSEQ SEQUENCE START END) (SUBSEQ SEQUENCE START END)))
     [java] ; (DEFUN COMMON-LISP:REVERSE (SEQUENCE) (SEQ-DISPATCH SEQUENCE (SYSTEM::%REVERSE SEQUENCE) (SYSTEM::%REVERSE SEQUENCE) (REVERSE SEQUENCE)))
     [java] ; (DEFUN COMMON-LISP:NREVERSE (SEQUENCE) (SEQ-DISPATCH SEQUENCE (SYSTEM::%NREVERSE SEQUENCE) (SYSTEM::%NREVERSE SEQUENCE) (NREVERSE SEQUENCE)))
     [java] ; (DEFINE-CONDITION PROTOCOL-UNIMPLEMENTED (TYPE-ERROR) NIL)
     [java] ; (DEFUN PROTOCOL-UNIMPLEMENTED (SEQUENCE) (ERROR (QUOTE PROTOCOL-UNIMPLEMENTED) :DATUM SEQUENCE :EXPECTED-TYPE (QUOTE (OR LIST VECTOR))))
     [java] ; (DEFGENERIC MAKE-SEQUENCE-LIKE (SEQUENCE LENGTH &KEY INITIAL-ELEMENT INITIAL-CONTENTS) (:METHOD ((S LIST) LENGTH &KEY (INITIAL-ELEMENT NIL IEP) (INITIAL-CONTENTS NIL ICP)) (COND ((AND ICP IEP) (ERROR "Can't specify both :initial-element and :initial-contents")) (IEP (MAKE-LIST LENGTH :INITIAL-ELEMENT INITIAL-ELEMENT)) (ICP (UNLESS (= (LENGTH INITIAL-CONTENTS) LENGTH) (ERROR "initial-contents is of length ~S but should be of the same length of the input sequence (~S)" (LENGTH INITIAL-CONTENTS) LENGTH)) (LET ((RESULT (MAKE-LIST LENGTH))) (REPLACE RESULT INITIAL-CONTENTS) RESULT)) (T (MAKE-LIST LENGTH)))) (:METHOD ((S VECTOR) LENGTH &KEY (INITIAL-ELEMENT NIL IEP) (INITIAL-CONTENTS NIL ICP)) (COND ((AND ICP IEP) (ERROR "Can't specify both :initial-element and :initial-contents")) (IEP (MAKE-ARRAY LENGTH :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE S) :INITIAL-ELEMENT INITIAL-ELEMENT)) (ICP (MAKE-ARRAY LENGTH :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE S) :INITIAL-CONTENTS INITIAL-CONTENTS)) (T (MAKE-ARRAY LENGTH :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE S))))) (:METHOD ((S SEQUENCE) LENGTH &KEY INITIAL-ELEMENT INITIAL-CONTENTS) (DECLARE (IGNORE INITIAL-ELEMENT INITIAL-CONTENTS)) (PROTOCOL-UNIMPLEMENTED S)))
     [java] ; (DEFGENERIC ADJUST-SEQUENCE (SEQUENCE LENGTH &KEY INITIAL-ELEMENT INITIAL-CONTENTS) (:METHOD ((S LIST) LENGTH &KEY INITIAL-ELEMENT (INITIAL-CONTENTS NIL ICP)) (IF (EQL LENGTH 0) NIL (LET ((OLENGTH (LENGTH S))) (COND ((EQL LENGTH OLENGTH) (IF ICP (REPLACE S INITIAL-CONTENTS) S)) ((< LENGTH OLENGTH) (RPLACD (NTHCDR (1- LENGTH) S) NIL) (IF ICP (REPLACE S INITIAL-CONTENTS) S)) ((NULL S) (LET ((RETURN (MAKE-LIST LENGTH :INITIAL-ELEMENT INITIAL-ELEMENT))) (IF ICP (REPLACE RETURN INITIAL-CONTENTS) RETURN))) (T (RPLACD (NTHCDR (1- OLENGTH) S) (MAKE-LIST (- LENGTH OLENGTH) :INITIAL-ELEMENT INITIAL-ELEMENT)) (IF ICP (REPLACE S INITIAL-CONTENTS) S)))))) (:METHOD ((S VECTOR) LENGTH &REST ARGS &KEY (INITIAL-CONTENTS NIL ICP) INITIAL-ELEMENT) (DECLARE (IGNORE INITIAL-ELEMENT)) (COND ((AND (ARRAY-HAS-FILL-POINTER-P S) (>= (ARRAY-TOTAL-SIZE S) LENGTH)) (SETF (FILL-POINTER S) LENGTH) (IF ICP (REPLACE S INITIAL-CONTENTS) S)) ((EQL (LENGTH S) LENGTH) (IF ICP (REPLACE S INITIAL-CONTENTS) S)) (T (APPLY (FUNCTION ADJUST-ARRAY) S LENGTH ARGS)))) (:METHOD (NEW-VALUE (S SEQUENCE) &REST ARGS) (DECLARE (IGNORE ARGS)) (PROTOCOL-UNIMPLEMENTED S)))
     [java] ; (DEFGENERIC MAKE-SEQUENCE-ITERATOR (SEQUENCE &KEY FROM-END START END) (:METHOD ((S SEQUENCE) &KEY FROM-END (START 0) END) (MULTIPLE-VALUE-BIND (ITERATOR LIMIT FROM-END) (MAKE-SIMPLE-SEQUENCE-ITERATOR S :FROM-END FROM-END :START START :END END) (VALUES ITERATOR LIMIT FROM-END (FUNCTION ITERATOR-STEP) (FUNCTION ITERATOR-ENDP) (FUNCTION ITERATOR-ELEMENT) (FUNCTION (SETF ITERATOR-ELEMENT)) (FUNCTION ITERATOR-INDEX) (FUNCTION ITERATOR-COPY)))) (:METHOD ((S T) &KEY FROM-END START END) (DECLARE (IGNORE FROM-END START END)) (ERROR (QUOTE TYPE-ERROR) :DATUM S :EXPECTED-TYPE (QUOTE SEQUENCE))))
     [java] ; (DEFVAR *EXHAUSTED* (CONS NIL NIL))
     [java] ; (DEFGENERIC MAKE-SIMPLE-SEQUENCE-ITERATOR (SEQUENCE &KEY FROM-END START END) (:METHOD ((S LIST) &KEY FROM-END (START 0) END) (IF FROM-END (LET* ((TERMINATION (IF (= START 0) *EXHAUSTED* (NTHCDR (1- START) S))) (INIT (IF (<= (OR END (LENGTH S)) START) TERMINATION (IF END (LAST S (- (LENGTH S) (1- END))) (LAST S))))) (VALUES INIT TERMINATION T)) (COND ((NOT END) (VALUES (NTHCDR START S) NIL NIL)) (T (LET ((ST (NTHCDR START S))) (VALUES ST (NTHCDR (- END START) ST) NIL)))))) (:METHOD ((S VECTOR) &KEY FROM-END (START 0) END) (LET ((END (OR END (LENGTH S)))) (IF FROM-END (VALUES (1- END) (1- START) T) (VALUES START END NIL)))) (:METHOD ((S SEQUENCE) &KEY FROM-END (START 0) END) (LET ((END (OR END (LENGTH S)))) (IF FROM-END (VALUES (1- END) (1- START) FROM-END) (VALUES START END NIL)))))
     [java] ; (DEFGENERIC ITERATOR-STEP (SEQUENCE ITERATOR FROM-END) (:METHOD ((S LIST) ITERATOR FROM-END) (IF FROM-END (IF (EQ ITERATOR S) *EXHAUSTED* (DO* ((XS S (CDR XS))) ((EQ (CDR XS) ITERATOR) XS))) (CDR ITERATOR))) (:METHOD ((S VECTOR) ITERATOR FROM-END) (IF FROM-END (1- ITERATOR) (1+ ITERATOR))) (:METHOD ((S SEQUENCE) ITERATOR FROM-END) (IF FROM-END (1- ITERATOR) (1+ ITERATOR))))
     [java] ; (DEFGENERIC ITERATOR-ENDP (SEQUENCE ITERATOR LIMIT FROM-END) (:METHOD ((S LIST) ITERATOR LIMIT FROM-END) (EQ ITERATOR LIMIT)) (:METHOD ((S VECTOR) ITERATOR LIMIT FROM-END) (= ITERATOR LIMIT)) (:METHOD ((S SEQUENCE) ITERATOR LIMIT FROM-END) (= ITERATOR LIMIT)))
     [java] ; (DEFGENERIC ITERATOR-ELEMENT (SEQUENCE ITERATOR) (:METHOD ((S LIST) ITERATOR) (CAR ITERATOR)) (:METHOD ((S VECTOR) ITERATOR) (AREF S ITERATOR)) (:METHOD ((S SEQUENCE) ITERATOR) (ELT S ITERATOR)))
     [java] ; (DEFGENERIC (SETF ITERATOR-ELEMENT) (NEW-VALUE SEQUENCE ITERATOR) (:METHOD (O (S LIST) ITERATOR) (SETF (CAR ITERATOR) O)) (:METHOD (O (S VECTOR) ITERATOR) (SETF (AREF S ITERATOR) O)) (:METHOD (O (S SEQUENCE) ITERATOR) (SETF (ELT S ITERATOR) O)))
     [java] ; (DEFGENERIC ITERATOR-INDEX (SEQUENCE ITERATOR) (:METHOD ((S LIST) ITERATOR) (LOOP FOR L ON S FOR I FROM 0 WHEN (EQ L ITERATOR) RETURN I)) (:METHOD ((S VECTOR) ITERATOR) ITERATOR) (:METHOD ((S SEQUENCE) ITERATOR) ITERATOR))
     [java] ; (DEFGENERIC ITERATOR-COPY (SEQUENCE ITERATOR) (:METHOD ((S LIST) ITERATOR) ITERATOR) (:METHOD ((S VECTOR) ITERATOR) ITERATOR) (:METHOD ((S SEQUENCE) ITERATOR) ITERATOR))
     [java] ; (DEFMACRO WITH-SEQUENCE-ITERATOR ((&REST VARS) (S &REST ARGS &KEY FROM-END START END) &BODY BODY) (DECLARE (IGNORE FROM-END START END)) (SYSTEM::BACKQ-LIST* (QUOTE MULTIPLE-VALUE-BIND) VARS (SYSTEM::BACKQ-LIST* (QUOTE MAKE-SEQUENCE-ITERATOR) S ARGS) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST* (QUOTE TYPE) (QUOTE FUNCTION) (NTHCDR 3 VARS))) BODY))
     [java] ; (DEFMACRO WITH-SEQUENCE-ITERATOR-FUNCTIONS ((STEP ENDP ELT SETF INDEX COPY) (S &REST ARGS &KEY FROM-END START END) &BODY BODY) (DECLARE (IGNORE FROM-END START END)) (LET ((NSTATE (GENSYM "STATE")) (NLIMIT (GENSYM "LIMIT")) (NFROM-END (GENSYM "FROM-END-")) (NSTEP (GENSYM "STEP")) (NENDP (GENSYM "ENDP")) (NELT (GENSYM "ELT")) (NSETF (GENSYM "SETF")) (NINDEX (GENSYM "INDEX")) (NCOPY (GENSYM "COPY"))) (SYSTEM::BACKQ-LIST (QUOTE WITH-SEQUENCE-ITERATOR) (SYSTEM::BACKQ-LIST NSTATE NLIMIT NFROM-END NSTEP NENDP NELT NSETF NINDEX NCOPY) (SYSTEM::BACKQ-CONS S ARGS) (SYSTEM::BACKQ-LIST* (QUOTE FLET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST STEP NIL (SYSTEM::BACKQ-LIST (QUOTE SETQ) NSTATE (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NSTEP S NSTATE NFROM-END))) (SYSTEM::BACKQ-LIST ENDP NIL (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NENDP S NSTATE NLIMIT NFROM-END)) (SYSTEM::BACKQ-LIST ELT NIL (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NELT S NSTATE)) (SYSTEM::BACKQ-LIST SETF (QUOTE (NEW-VALUE)) (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NSETF (QUOTE NEW-VALUE) S NSTATE)) (SYSTEM::BACKQ-LIST INDEX NIL (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NINDEX S NSTATE)) (SYSTEM::BACKQ-LIST COPY NIL (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) NCOPY S NSTATE))) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TRULY-DYNAMIC-EXTENT) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) STEP) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) ENDP) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) ELT) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) SETF) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) INDEX) (SYSTEM::BACKQ-LIST (QUOTE FUNCTION) COPY))) BODY))))
     [java] ; (DEFUN CANONIZE-TEST (TEST TEST-NOT) (COND (TEST (IF (FUNCTIONP TEST) TEST (FDEFINITION TEST))) (TEST-NOT (IF (FUNCTIONP TEST-NOT) (COMPLEMENT TEST-NOT) (COMPLEMENT (FDEFINITION TEST-NOT)))) (T (FUNCTION EQL))))
     [java] ; (DEFUN CANONIZE-KEY (KEY) (OR (AND KEY (IF (FUNCTIONP KEY) KEY (FDEFINITION KEY))) (FUNCTION IDENTITY)))
     [java] ; (DEFGENERIC COUNT (ITEM SEQUENCE &KEY FROM-END START END TEST TEST-NOT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE ITEM))
     [java] ; (DEFMETHOD COUNT (ITEM (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END TEST TEST-NOT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((COUNT 0)) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) COUNT) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL TEST ITEM (FUNCALL KEY O)) (INCF COUNT)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC COUNT-IF (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD COUNT-IF (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((COUNT 0)) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) COUNT) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL PRED (FUNCALL KEY O)) (INCF COUNT)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC COUNT-IF-NOT (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD COUNT-IF-NOT (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((COUNT 0)) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) COUNT) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (UNLESS (FUNCALL PRED (FUNCALL KEY O)) (INCF COUNT)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC FIND (ITEM SEQUENCE &KEY FROM-END START END TEST TEST-NOT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE ITEM))
     [java] ; (DEFMETHOD FIND (ITEM (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END TEST TEST-NOT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO NIL ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL TEST ITEM (FUNCALL KEY O)) (RETURN O)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC FIND-IF (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD FIND-IF (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO NIL ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL PRED (FUNCALL KEY O)) (RETURN O)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC FIND-IF-NOT (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD FIND-IF-NOT (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO NIL ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (UNLESS (FUNCALL PRED (FUNCALL KEY O)) (RETURN O)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC POSITION (ITEM SEQUENCE &KEY FROM-END START END TEST TEST-NOT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE ITEM))
     [java] ; (DEFMETHOD POSITION (ITEM (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END TEST TEST-NOT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((S (IF FROM-END -1 1)) (POS (IF FROM-END (1- (OR END (LENGTH SEQUENCE))) START) (+ POS S))) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL TEST ITEM (FUNCALL KEY O)) (RETURN POS)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC POSITION-IF (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD POSITION-IF (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((S (IF FROM-END -1 1)) (POS (IF FROM-END (1- (OR END (LENGTH SEQUENCE))) START) (+ POS S))) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (WHEN (FUNCALL PRED (FUNCALL KEY O)) (RETURN POS)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC POSITION-IF-NOT (PRED SEQUENCE &KEY FROM-END START END KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PRED))
     [java] ; (DEFMETHOD POSITION-IF-NOT (PRED (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :FROM-END FROM-END :START START :END END) (DO ((S (IF FROM-END -1 1)) (POS (IF FROM-END (1- (OR END (LENGTH SEQUENCE))) START) (+ POS S))) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) NIL) (LET ((O (FUNCALL ELT SEQUENCE STATE))) (UNLESS (FUNCALL PRED (FUNCALL KEY O)) (RETURN POS)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))))
     [java] ; (DEFGENERIC SUBSEQ (SEQUENCE START &OPTIONAL END))
     [java] ; (DEFMETHOD SUBSEQ ((SEQUENCE SEQUENCE) START &OPTIONAL END) (LET* ((END (OR END (LENGTH SEQUENCE))) (LENGTH (- END START)) (RESULT (MAKE-SEQUENCE-LIKE SEQUENCE LENGTH))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :START START :END END) (DECLARE (IGNORE LIMIT ENDP)) (WITH-SEQUENCE-ITERATOR (RSTATE RLIMIT RFROM-END RSTEP RENDP RELT RSETELT) (RESULT) (DECLARE (IGNORE RLIMIT RENDP RELT)) (DO ((I 0 (+ I 1))) ((>= I LENGTH) RESULT) (FUNCALL RSETELT (FUNCALL ELT SEQUENCE STATE) RESULT RSTATE) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)) (SETQ RSTATE (FUNCALL RSTEP RESULT RSTATE RFROM-END)))))))
     [java] ; (DEFGENERIC COPY-SEQ (SEQUENCE))
     [java] ; (DEFMETHOD COPY-SEQ ((SEQUENCE SEQUENCE)) (SUBSEQ SEQUENCE 0))
     [java] ; (FMAKUNBOUND (QUOTE FILL))
     [java] ; (DEFGENERIC FILL (SEQUENCE ITEM &KEY START END))
     [java] ; (DEFMETHOD FILL ((SEQUENCE SEQUENCE) ITEM &KEY (START 0) END) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE :START START :END END) (DECLARE (IGNORE ELT)) (DO NIL ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) SEQUENCE) (FUNCALL SETELT ITEM SEQUENCE STATE) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))))
     [java] ; (DEFGENERIC NSUBSTITUTE (NEW OLD SEQUENCE &KEY START END FROM-END TEST TEST-NOT COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW OLD))
     [java] ; (DEFMETHOD NSUBSTITUTE (NEW OLD (SEQUENCE SEQUENCE) &KEY (START 0) END FROM-END TEST TEST-NOT COUNT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE :START START :END END :FROM-END FROM-END) (DO ((C 0)) ((OR (AND COUNT (>= C COUNT)) (FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END)) SEQUENCE) (WHEN (FUNCALL TEST OLD (FUNCALL KEY (FUNCALL ELT SEQUENCE STATE))) (INCF C) (FUNCALL SETELT NEW SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))
     [java] ; (DEFGENERIC NSUBSTITUTE-IF (NEW PREDICATE SEQUENCE &KEY START END FROM-END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW PREDICATE))
     [java] ; (DEFMETHOD NSUBSTITUTE-IF (NEW PREDICATE (SEQUENCE SEQUENCE) &KEY (START 0) END FROM-END COUNT KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE :START START :END END :FROM-END FROM-END) (DO ((C 0)) ((OR (AND COUNT (>= C COUNT)) (FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END)) SEQUENCE) (WHEN (FUNCALL PREDICATE (FUNCALL KEY (FUNCALL ELT SEQUENCE STATE))) (INCF C) (FUNCALL SETELT NEW SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))
     [java] ; (DEFGENERIC NSUBSTITUTE-IF-NOT (NEW PREDICATE SEQUENCE &KEY START END FROM-END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW PREDICATE))
     [java] ; (DEFMETHOD NSUBSTITUTE-IF-NOT (NEW PREDICATE (SEQUENCE SEQUENCE) &KEY (START 0) END FROM-END COUNT KEY) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE :START START :END END :FROM-END FROM-END) (DO ((C 0)) ((OR (AND COUNT (>= C COUNT)) (FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END)) SEQUENCE) (UNLESS (FUNCALL PREDICATE (FUNCALL KEY (FUNCALL ELT SEQUENCE STATE))) (INCF C) (FUNCALL SETELT NEW SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))
     [java] ; (DEFGENERIC SUBSTITUTE (NEW OLD SEQUENCE &KEY START END FROM-END TEST TEST-NOT COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW OLD))
     [java] ; (DEFMETHOD SUBSTITUTE (NEW OLD (SEQUENCE SEQUENCE) &REST ARGS &KEY (START 0) END FROM-END TEST TEST-NOT COUNT KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE START END FROM-END TEST TEST-NOT COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION NSUBSTITUTE) NEW OLD RESULT ARGS)))
     [java] ; (DEFGENERIC SUBSTITUTE-IF (NEW PREDICATE SEQUENCE &KEY START END FROM-END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW PREDICATE))
     [java] ; (DEFMETHOD SUBSTITUTE-IF (NEW PREDICATE (SEQUENCE SEQUENCE) &REST ARGS &KEY (START 0) END FROM-END COUNT KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE START END FROM-END COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION NSUBSTITUTE-IF) NEW PREDICATE RESULT ARGS)))
     [java] ; (DEFGENERIC SUBSTITUTE-IF-NOT (NEW PREDICATE SEQUENCE &KEY START END FROM-END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE NEW PREDICATE))
     [java] ; (DEFMETHOD SUBSTITUTE-IF-NOT (NEW PREDICATE (SEQUENCE SEQUENCE) &REST ARGS &KEY (START 0) END FROM-END COUNT KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE START END FROM-END COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION NSUBSTITUTE-IF-NOT) NEW PREDICATE RESULT ARGS)))
     [java] ; (DEFUN %SEQUENCE-REPLACE (SEQUENCE1 SEQUENCE2 START1 END1 START2 END2) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE1 :START START1 :END END1) (DECLARE (IGNORE ELT1)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE2 :START START2 :END END2) (DO NIL ((OR (FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1) (FUNCALL ENDP2 SEQUENCE2 STATE2 LIMIT2 FROM-END2)) SEQUENCE1) (FUNCALL SETELT1 (FUNCALL ELT2 SEQUENCE2 STATE2) SEQUENCE1 STATE1) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE1 STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE2 STATE2 FROM-END2))))))
     [java] ; (DEFGENERIC REPLACE (SEQUENCE1 SEQUENCE2 &KEY START1 END1 START2 END2) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE2 SEQUENCE1))
     [java] ; (DEFMETHOD REPLACE ((SEQUENCE1 SEQUENCE) (SEQUENCE2 SEQUENCE) &KEY (START1 0) END1 (START2 0) END2) (PRINT SEQUENCE1) (PRINT SEQUENCE2) (COND ((EQ SEQUENCE1 SEQUENCE2) (LET ((REPLACES (SUBSEQ SEQUENCE2 START2 END2))) (%SEQUENCE-REPLACE SEQUENCE1 REPLACES START1 END1 0 NIL))) (T (%SEQUENCE-REPLACE SEQUENCE1 SEQUENCE2 START1 END1 START2 END2))))
     [java] ; (DEFGENERIC NREVERSE (SEQUENCE))
     [java] ; (DEFMETHOD NREVERSE ((SEQUENCE SEQUENCE)) (LET ((LENGTH (LENGTH SEQUENCE))) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE :END (FLOOR LENGTH 2)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2 SETELT2) (SEQUENCE :START (CEILING LENGTH 2) :FROM-END T) (DECLARE (IGNORE LIMIT2 ENDP2)) (DO NIL ((FUNCALL ENDP1 SEQUENCE STATE1 LIMIT1 FROM-END1) SEQUENCE) (LET ((X (FUNCALL ELT1 SEQUENCE STATE1)) (Y (FUNCALL ELT2 SEQUENCE STATE2))) (FUNCALL SETELT1 Y SEQUENCE STATE1) (FUNCALL SETELT2 X SEQUENCE STATE2)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2)))))))
     [java] ; (DEFGENERIC REVERSE (SEQUENCE))
     [java] ; (DEFMETHOD REVERSE ((SEQUENCE SEQUENCE)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (NREVERSE RESULT)))
     [java] ; (DEFGENERIC REDUCE (FUNCTION SEQUENCE &KEY FROM-END START END INITIAL-VALUE) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE FUNCTION))
     [java] ; (DEFMETHOD REDUCE (FUNCTION (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END KEY (INITIAL-VALUE NIL IVP)) (LET ((KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE :START START :END END :FROM-END FROM-END) (IF (FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) (IF IVP INITIAL-VALUE (FUNCALL FUNCTION)) (DO* ((STATE STATE (FUNCALL STEP SEQUENCE STATE FROM-END)) (VALUE (COND (IVP INITIAL-VALUE) (T (PROG1 (FUNCALL KEY (FUNCALL ELT SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))) ((FUNCALL ENDP SEQUENCE STATE LIMIT FROM-END) VALUE) (LET ((E (FUNCALL KEY (FUNCALL ELT SEQUENCE STATE)))) (IF FROM-END (SETQ VALUE (FUNCALL FUNCTION E VALUE)) (SETQ VALUE (FUNCALL FUNCTION VALUE E)))))))))
     [java] ; (DEFGENERIC MISMATCH (SEQUENCE1 SEQUENCE2 &KEY FROM-END START1 END1 START2 END2 TEST TEST-NOT KEY))
     [java] ; (DEFMETHOD MISMATCH ((SEQUENCE1 SEQUENCE) (SEQUENCE2 SEQUENCE) &KEY FROM-END (START1 0) END1 (START2 0) END2 TEST TEST-NOT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY))) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1) (SEQUENCE1 :START START1 :END END1 :FROM-END FROM-END) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE2 :START START2 :END END2 :FROM-END FROM-END) (IF FROM-END (DO ((RESULT (OR END1 (LENGTH SEQUENCE1)) (1- RESULT)) (E1 (FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1) (FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1)) (E2 (FUNCALL ENDP2 SEQUENCE2 STATE2 LIMIT2 FROM-END2) (FUNCALL ENDP2 SEQUENCE2 STATE2 LIMIT2 FROM-END2))) ((OR E1 E2) (IF (AND E1 E2) NIL RESULT)) (LET ((O1 (FUNCALL KEY (FUNCALL ELT1 SEQUENCE1 STATE1))) (O2 (FUNCALL KEY (FUNCALL ELT2 SEQUENCE2 STATE2)))) (UNLESS (FUNCALL TEST O1 O2) (RETURN RESULT)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE1 STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE2 STATE2 FROM-END2)))) (DO ((RESULT START1 (1+ RESULT)) (E1 (FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1) (FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1)) (E2 (FUNCALL ENDP2 SEQUENCE2 STATE2 LIMIT2 FROM-END2) (FUNCALL ENDP2 SEQUENCE2 STATE2 LIMIT2 FROM-END2))) ((OR E1 E2) (IF (AND E1 E2) NIL RESULT)) (LET ((O1 (FUNCALL KEY (FUNCALL ELT1 SEQUENCE1 STATE1))) (O2 (FUNCALL KEY (FUNCALL ELT2 SEQUENCE2 STATE2)))) (UNLESS (FUNCALL TEST O1 O2) (RETURN RESULT))) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE1 STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE2 STATE2 FROM-END2))))))))
     [java] ; (DEFGENERIC SEARCH (SEQUENCE1 SEQUENCE2 &KEY FROM-END START1 END1 START2 END2 TEST TEST-NOT KEY))
     [java] ; (DEFMETHOD SEARCH ((SEQUENCE1 SEQUENCE) (SEQUENCE2 SEQUENCE) &KEY FROM-END (START1 0) END1 (START2 0) END2 TEST TEST-NOT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY)) (MAINEND2 (- (OR END2 (LENGTH SEQUENCE2)) (- (OR END1 (LENGTH SEQUENCE1)) START1)))) (WHEN (< MAINEND2 0) (RETURN-FROM SEARCH NIL)) (WITH-SEQUENCE-ITERATOR (STATEM LIMITM FROM-ENDM STEPM ENDPM) (SEQUENCE2 :START START2 :END MAINEND2 :FROM-END FROM-END) (DO ((S2 (IF FROM-END MAINEND2 0) (IF FROM-END (1- S2) (1+ S2)))) (NIL) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1) (SEQUENCE1 :START START1 :END END1) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE2 :START S2) (DECLARE (IGNORE LIMIT2 ENDP2)) (WHEN (DO NIL ((FUNCALL ENDP1 SEQUENCE1 STATE1 LIMIT1 FROM-END1) T) (LET ((O1 (FUNCALL KEY (FUNCALL ELT1 SEQUENCE1 STATE1))) (O2 (FUNCALL KEY (FUNCALL ELT2 SEQUENCE2 STATE2)))) (UNLESS (FUNCALL TEST O1 O2) (RETURN NIL))) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE1 STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE2 STATE2 FROM-END2))) (RETURN-FROM SEARCH S2)))) (WHEN (FUNCALL ENDPM SEQUENCE2 STATEM LIMITM FROM-ENDM) (RETURN NIL)) (SETQ STATEM (FUNCALL STEPM SEQUENCE2 STATEM FROM-ENDM))))))
     [java] ; (DEFGENERIC DELETE (ITEM SEQUENCE &KEY FROM-END TEST TEST-NOT START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE ITEM))
     [java] ; (DEFMETHOD DELETE (ITEM (SEQUENCE SEQUENCE) &KEY FROM-END TEST TEST-NOT (START 0) END COUNT KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY)) (C 0)) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE :START START :END END :FROM-END FROM-END) (DECLARE (IGNORE LIMIT1 ENDP1 ELT1)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE :START START :END END :FROM-END FROM-END) (FLET ((FINISH NIL (IF FROM-END (REPLACE SEQUENCE SEQUENCE :START1 START :END1 (- (LENGTH SEQUENCE) C) :START2 (+ START C) :END2 (LENGTH SEQUENCE)) (UNLESS (OR (NULL END) (= END (LENGTH SEQUENCE))) (REPLACE SEQUENCE SEQUENCE :START2 END :START1 (- END C) :END1 (- (LENGTH SEQUENCE) C)))) (ADJUST-SEQUENCE SEQUENCE (- (LENGTH SEQUENCE) C)))) (DECLARE (TRULY-DYNAMIC-EXTENT (FUNCTION FINISH))) (DO NIL ((FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (FINISH)) (LET ((E (FUNCALL ELT2 SEQUENCE STATE2))) (LOOP (WHEN (AND COUNT (>= C COUNT)) (RETURN)) (IF (FUNCALL TEST ITEM (FUNCALL KEY E)) (PROGN (INCF C) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2)) (WHEN (FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (RETURN-FROM DELETE (FINISH))) (SETQ E (FUNCALL ELT2 SEQUENCE STATE2))) (RETURN))) (FUNCALL SETELT1 E SEQUENCE STATE1)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2))))))))
     [java] ; (DEFGENERIC DELETE-IF (PREDICATE SEQUENCE &KEY FROM-END START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PREDICATE))
     [java] ; (DEFMETHOD DELETE-IF (PREDICATE (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END COUNT KEY) (LET ((KEY (CANONIZE-KEY KEY)) (C 0)) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE :START START :END END :FROM-END FROM-END) (DECLARE (IGNORE LIMIT1 ENDP1 ELT1)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE :START START :END END :FROM-END FROM-END) (FLET ((FINISH NIL (IF FROM-END (REPLACE SEQUENCE SEQUENCE :START1 START :END1 (- (LENGTH SEQUENCE) C) :START2 (+ START C) :END2 (LENGTH SEQUENCE)) (UNLESS (OR (NULL END) (= END (LENGTH SEQUENCE))) (REPLACE SEQUENCE SEQUENCE :START2 END :START1 (- END C) :END1 (- (LENGTH SEQUENCE) C)))) (ADJUST-SEQUENCE SEQUENCE (- (LENGTH SEQUENCE) C)))) (DECLARE (TRULY-DYNAMIC-EXTENT (FUNCTION FINISH))) (DO NIL ((FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (FINISH)) (LET ((E (FUNCALL ELT2 SEQUENCE STATE2))) (LOOP (WHEN (AND COUNT (>= C COUNT)) (RETURN)) (IF (FUNCALL PREDICATE (FUNCALL KEY E)) (PROGN (INCF C) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2)) (WHEN (FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (RETURN-FROM DELETE-IF (FINISH))) (SETQ E (FUNCALL ELT2 SEQUENCE STATE2))) (RETURN))) (FUNCALL SETELT1 E SEQUENCE STATE1)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2))))))))
     [java] ; (DEFGENERIC DELETE-IF-NOT (PREDICATE SEQUENCE &KEY FROM-END START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PREDICATE))
     [java] ; (DEFMETHOD DELETE-IF-NOT (PREDICATE (SEQUENCE SEQUENCE) &KEY FROM-END (START 0) END COUNT KEY) (LET ((KEY (CANONIZE-KEY KEY)) (C 0)) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE :START START :END END :FROM-END FROM-END) (DECLARE (IGNORE LIMIT1 ENDP1 ELT1)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE :START START :END END :FROM-END FROM-END) (FLET ((FINISH NIL (IF FROM-END (REPLACE SEQUENCE SEQUENCE :START1 START :END1 (- (LENGTH SEQUENCE) C) :START2 (+ START C) :END2 (LENGTH SEQUENCE)) (UNLESS (OR (NULL END) (= END (LENGTH SEQUENCE))) (REPLACE SEQUENCE SEQUENCE :START2 END :START1 (- END C) :END1 (- (LENGTH SEQUENCE) C)))) (ADJUST-SEQUENCE SEQUENCE (- (LENGTH SEQUENCE) C)))) (DECLARE (TRULY-DYNAMIC-EXTENT (FUNCTION FINISH))) (DO NIL ((FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (FINISH)) (LET ((E (FUNCALL ELT2 SEQUENCE STATE2))) (LOOP (WHEN (AND COUNT (>= C COUNT)) (RETURN)) (IF (FUNCALL PREDICATE (FUNCALL KEY E)) (RETURN) (PROGN (INCF C) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2)) (WHEN (FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (RETURN-FROM DELETE-IF-NOT (FINISH))) (SETQ E (FUNCALL ELT2 SEQUENCE STATE2))))) (FUNCALL SETELT1 E SEQUENCE STATE1)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2))))))))
     [java] ; (DEFGENERIC REMOVE (ITEM SEQUENCE &KEY FROM-END TEST TEST-NOT START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE ITEM))
     [java] ; (DEFMETHOD REMOVE (ITEM (SEQUENCE SEQUENCE) &REST ARGS &KEY FROM-END TEST TEST-NOT (START 0) END COUNT KEY) (DECLARE (DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE FROM-END TEST TEST-NOT START END COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION DELETE) ITEM RESULT ARGS)))
     [java] ; (DEFGENERIC REMOVE-IF (PREDICATE SEQUENCE &KEY FROM-END START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PREDICATE))
     [java] ; (DEFMETHOD REMOVE-IF (PREDICATE (SEQUENCE SEQUENCE) &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE FROM-END START END COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION DELETE-IF) PREDICATE RESULT ARGS)))
     [java] ; (DEFGENERIC REMOVE-IF-NOT (PREDICATE SEQUENCE &KEY FROM-END START END COUNT KEY) (:ARGUMENT-PRECEDENCE-ORDER SEQUENCE PREDICATE))
     [java] ; (DEFMETHOD REMOVE-IF-NOT (PREDICATE (SEQUENCE SEQUENCE) &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE FROM-END START END COUNT KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION DELETE-IF-NOT) PREDICATE RESULT ARGS)))
     [java] ; (DEFGENERIC DELETE-DUPLICATES (SEQUENCE &KEY FROM-END TEST TEST-NOT START END KEY))
     [java] ; (DEFMETHOD DELETE-DUPLICATES ((SEQUENCE SEQUENCE) &KEY FROM-END TEST TEST-NOT (START 0) END KEY) (LET ((TEST (CANONIZE-TEST TEST TEST-NOT)) (KEY (CANONIZE-KEY KEY)) (C 0)) (WITH-SEQUENCE-ITERATOR (STATE1 LIMIT1 FROM-END1 STEP1 ENDP1 ELT1 SETELT1) (SEQUENCE :START START :END END :FROM-END FROM-END) (DECLARE (IGNORE LIMIT1 ENDP1 ELT1)) (WITH-SEQUENCE-ITERATOR (STATE2 LIMIT2 FROM-END2 STEP2 ENDP2 ELT2) (SEQUENCE :START START :END END :FROM-END FROM-END) (FLET ((FINISH NIL (IF FROM-END (REPLACE SEQUENCE SEQUENCE :START1 START :END1 (- (LENGTH SEQUENCE) C) :START2 (+ START C) :END2 (LENGTH SEQUENCE)) (UNLESS (OR (NULL END) (= END (LENGTH SEQUENCE))) (REPLACE SEQUENCE SEQUENCE :START2 END :START1 (- END C) :END1 (- (LENGTH SEQUENCE) C)))) (ADJUST-SEQUENCE SEQUENCE (- (LENGTH SEQUENCE) C)))) (DECLARE (TRULY-DYNAMIC-EXTENT (FUNCTION FINISH))) (DO ((END (OR END (LENGTH SEQUENCE))) (STEP 0 (1+ STEP))) ((FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (FINISH)) (LET ((E (FUNCALL ELT2 SEQUENCE STATE2))) (LOOP (IF (> (COUNT (FUNCALL KEY E) SEQUENCE :TEST TEST :KEY KEY :START (IF FROM-END START (+ START STEP 1)) :END (IF FROM-END (- END STEP 1) END)) 0) (PROGN (INCF C) (INCF STEP) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2)) (WHEN (FUNCALL ENDP2 SEQUENCE STATE2 LIMIT2 FROM-END2) (RETURN-FROM DELETE-DUPLICATES (FINISH))) (SETQ E (FUNCALL ELT2 SEQUENCE STATE2))) (PROGN (RETURN)))) (FUNCALL SETELT1 E SEQUENCE STATE1)) (SETQ STATE1 (FUNCALL STEP1 SEQUENCE STATE1 FROM-END1)) (SETQ STATE2 (FUNCALL STEP2 SEQUENCE STATE2 FROM-END2))))))))
     [java] ; (DEFGENERIC REMOVE-DUPLICATES (SEQUENCE &KEY FROM-END TEST TEST-NOT START END KEY))
     [java] ; (DEFMETHOD REMOVE-DUPLICATES ((SEQUENCE SEQUENCE) &REST ARGS &KEY FROM-END TEST TEST-NOT (START 0) END KEY) (DECLARE (TRULY-DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE FROM-END TEST TEST-NOT START END KEY)) (LET ((RESULT (COPY-SEQ SEQUENCE))) (APPLY (FUNCTION DELETE-DUPLICATES) RESULT ARGS)))
     [java] ; (DEFGENERIC SORT (SEQUENCE PREDICATE &KEY KEY))
     [java] ; (DEFMETHOD SORT ((SEQUENCE SEQUENCE) PREDICATE &REST ARGS &KEY KEY) (DECLARE (DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE KEY)) (LET* ((LENGTH (LENGTH SEQUENCE)) (VECTOR (MAKE-ARRAY LENGTH))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE) (DECLARE (IGNORE LIMIT ENDP)) (DO ((I 0 (1+ I))) ((>= I LENGTH)) (SETF (AREF VECTOR I) (FUNCALL ELT SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))) (APPLY (FUNCTION COMMON-LISP:SORT) VECTOR PREDICATE ARGS) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE) (DECLARE (IGNORE LIMIT ENDP ELT)) (DO ((I 0 (1+ I))) ((>= I LENGTH) SEQUENCE) (FUNCALL SETELT (AREF VECTOR I) SEQUENCE STATE) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))
     [java] ; (DEFGENERIC STABLE-SORT (SEQUENCE PREDICATE &KEY KEY))
     [java] ; (DEFMETHOD STABLE-SORT ((SEQUENCE SEQUENCE) PREDICATE &REST ARGS &KEY KEY) (DECLARE (DYNAMIC-EXTENT ARGS)) (DECLARE (IGNORE KEY)) (LET* ((LENGTH (LENGTH SEQUENCE)) (VECTOR (MAKE-ARRAY LENGTH))) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT) (SEQUENCE) (DECLARE (IGNORE LIMIT ENDP)) (DO ((I 0 (1+ I))) ((>= I LENGTH)) (SETF (AREF VECTOR I) (FUNCALL ELT SEQUENCE STATE)) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END)))) (APPLY (FUNCTION COMMON-LISP:STABLE-SORT) VECTOR PREDICATE ARGS) (WITH-SEQUENCE-ITERATOR (STATE LIMIT FROM-END STEP ENDP ELT SETELT) (SEQUENCE) (DECLARE (IGNORE LIMIT ENDP ELT)) (DO ((I 0 (1+ I))) ((>= I LENGTH) SEQUENCE) (FUNCALL SETELT (AREF VECTOR I) SEQUENCE STATE) (SETQ STATE (FUNCALL STEP SEQUENCE STATE FROM-END))))))
     [java] ; (DEFUN LOOP-ELEMENTS-ITERATION-PATH (VARIABLE DATA-TYPE PREP-PHRASES) (LET (OF-PHRASE) (LOOP FOR (PREP . REST) IN PREP-PHRASES DO (ECASE PREP ((:OF :IN) (IF OF-PHRASE (LOOP::LOOP-ERROR "Too many prepositions") (SETQ OF-PHRASE REST))))) (DESTRUCTURING-BIND (IT LIM F-E STEP ENDP ELT SEQ) (LOOP REPEAT 7 COLLECT (GENSYM)) (PUSH (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SEQ (CAR OF-PHRASE)))) LOOP::*LOOP-WRAPPERS*) (PUSH (SYSTEM::BACKQ-LIST (QUOTE WITH-SEQUENCE-ITERATOR) (SYSTEM::BACKQ-LIST IT LIM F-E STEP ENDP ELT) (SYSTEM::BACKQ-LIST SEQ)) LOOP::*LOOP-WRAPPERS*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST VARIABLE NIL DATA-TYPE)) NIL NIL NIL (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) ENDP SEQ IT LIM F-E) (SYSTEM::BACKQ-LIST VARIABLE (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) ELT SEQ IT) IT (SYSTEM::BACKQ-LIST (QUOTE FUNCALL) STEP SEQ IT F-E))))))
     [java] ; (LOOP::ADD-LOOP-PATH (QUOTE (ELEMENT ELEMENTS)) (QUOTE LOOP-ELEMENTS-ITERATION-PATH) LOOP::*LOOP-ANSI-UNIVERSE* :PREPOSITION-GROUPS (QUOTE ((:OF :IN))) :INCLUSIVE-PERMITTED NIL)
     [java] ; (DEFUN FILTER-DOLIST-DECLARATIONS (DECLS) (MAPCAR (LAMBDA (DECL) (SYSTEM::BACKQ-CONS (QUOTE DECLARE) (REMOVE-IF (LAMBDA (CLAUSE) (AND (CONSP CLAUSE) (OR (EQ (CAR CLAUSE) (QUOTE TYPE)) (EQ (CAR CLAUSE) (QUOTE IGNORE))))) (CDR DECL)))) DECLS))
     [java] ; (DEFMACRO DOVECTOR ((ELT VECTOR &OPTIONAL RESULT) &BODY BODY) (MULTIPLE-VALUE-BIND (FORMS DECLS) (SYSTEM:PARSE-BODY BODY NIL) (LET ((INDEX (GENSYM "INDEX")) (LENGTH (GENSYM "LENGTH")) (VEC (GENSYM "VEC"))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST VEC VECTOR)) (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-LIST (QUOTE TYPE) (QUOTE VECTOR) VEC)) (SYSTEM::BACKQ-LIST (QUOTE DO) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST INDEX 0 (SYSTEM::BACKQ-LIST (QUOTE 1+) INDEX)) (SYSTEM::BACKQ-LIST LENGTH (SYSTEM::BACKQ-LIST (QUOTE LENGTH) VEC))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE >=) INDEX LENGTH) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS ELT (QUOTE (NIL)))) (SYSTEM::BACKQ-APPEND (FILTER-DOLIST-DECLARATIONS DECLS) (SYSTEM::BACKQ-LIST ELT RESULT)))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST ELT (SYSTEM::BACKQ-LIST (QUOTE AREF) VEC INDEX))) (SYSTEM::BACKQ-APPEND DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (QUOTE TAGBODY) FORMS)))))))))
     [java] ; (DEFMACRO DOSEQUENCE ((E SEQUENCE &OPTIONAL RETURN &REST ARGS &KEY FROM-END START END) &BODY BODY) (DECLARE (IGNORE FROM-END START END)) (MULTIPLE-VALUE-BIND (FORMS DECLS) (SYSTEM:PARSE-BODY BODY NIL) (LET ((S SEQUENCE) (SEQUENCE (GENSYM "SEQUENCE"))) (SYSTEM::BACKQ-LIST (QUOTE BLOCK) NIL (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST SEQUENCE S)) (SYSTEM::BACKQ-LIST (QUOTE SEQ-DISPATCH) SEQUENCE (SYSTEM::BACKQ-LIST* (QUOTE DOLIST) (SYSTEM::BACKQ-LIST E SEQUENCE RETURN) BODY) (SYSTEM::BACKQ-LIST* (QUOTE DOVECTOR) (SYSTEM::BACKQ-LIST E SEQUENCE RETURN) BODY) (SYSTEM::BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) (QUOTE (STATE LIMIT FROM-END STEP ENDP ELT)) (SYSTEM::BACKQ-LIST* (QUOTE MAKE-SEQUENCE-ITERATOR) SEQUENCE ARGS) (SYSTEM::BACKQ-LIST (QUOTE DO) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE STATE) (QUOTE STATE) (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (QUOTE STEP) SEQUENCE (QUOTE (STATE FROM-END))))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (QUOTE ENDP) SEQUENCE (QUOTE (STATE LIMIT FROM-END))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS E (QUOTE (NIL)))) (SYSTEM::BACKQ-APPEND (FILTER-DOLIST-DECLARATIONS DECLS) (SYSTEM::BACKQ-LIST E RETURN)))) (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST E (SYSTEM::BACKQ-LIST* (QUOTE FUNCALL) (QUOTE ELT) SEQUENCE (QUOTE (STATE))))) (SYSTEM::BACKQ-APPEND DECLS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (QUOTE TAGBODY) FORMS))))))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/extensible-sequences.abcl (4.077 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/fasl-concat.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN PATHNAME-DIRECTORY-P (PATHNAME) (AND (NULL (PATHNAME-TYPE PATHNAME)) (NULL (PATHNAME-NAME PATHNAME)) (NULL (PATHNAME-VERSION PATHNAME))))
     [java] ; (DEFUN LOAD-CONCATENATED-FASL (SUB-FASL) (LET ((FASL-PATH (MERGE-PATHNAMES (MAKE-PATHNAME :DIRECTORY (LIST :RELATIVE SUB-FASL) :NAME "__loader__" :TYPE "_") *LOAD-TRUENAME-FASL*))) (LOAD FASL-PATH)))
     [java] ; (DEFUN CONCATENATE-FASLS (INPUTS OUTPUT) (LET ((DIRECTORY (MAKE-TEMP-DIRECTORY)) PATHS) (UNWIND-PROTECT (LET* ((UNPACKED (MAPCAN (FUNCTION (LAMBDA (INPUT) (UNZIP INPUT (ENSURE-DIRECTORIES-EXIST (SUB-DIRECTORY DIRECTORY (PATHNAME-NAME INPUT)))))) INPUTS)) (CHAIN-LOADER (MAKE-PATHNAME :NAME "__loader__" :TYPE "_" :DEFAULTS DIRECTORY))) (WITH-OPEN-FILE (F CHAIN-LOADER :DIRECTION :OUTPUT :IF-DOES-NOT-EXIST :CREATE :IF-EXISTS :OVERWRITE) (WRITE-STRING ";; loader code to delegate loading of the embedded fasls below" F) (TERPRI F) (DUMP-FORM (BACKQ-LIST (QUOTE INIT-FASL) (QUOTE :VERSION) *FASL-VERSION*) F) (TERPRI F) (DOLIST (INPUT INPUTS) (DUMP-FORM (BACKQ-LIST (QUOTE LOAD-CONCATENATED-FASL) (PATHNAME-NAME INPUT)) F) (TERPRI F))) (SETF PATHS (DIRECTORY (MERGE-PATHNAMES (MAKE-PATHNAME :DIRECTORY (QUOTE (:RELATIVE :WILD-INFERIORS)) :NAME "*" :TYPE "*") DIRECTORY))) (ZIP OUTPUT (REMOVE-IF (FUNCTION PATHNAME-DIRECTORY-P) PATHS) DIRECTORY) (VALUES DIRECTORY UNPACKED CHAIN-LOADER)) (DOLIST (PATH PATHS) (IGNORE-ERRORS (DELETE-FILE PATH))) (IGNORE-ERRORS (DELETE-FILE DIRECTORY)))))
     [java] ; (DEFUN SUB-DIRECTORY (DIRECTORY NAME) (MERGE-PATHNAMES (MAKE-PATHNAME :DIRECTORY (LIST :RELATIVE NAME)) DIRECTORY))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/fasl-concat.abcl (0.227 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/fdefinition.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN CHECK-REDEFINITION (NAME) (WHEN (AND *WARN-ON-REDEFINITION* (FBOUNDP NAME) (NOT (AUTOLOADP NAME))) (WHEN (AND (SYMBOLP NAME) (SOURCE-PATHNAME NAME)) (LET ((OLD-SOURCE (IF (KEYWORDP (SOURCE-PATHNAME NAME)) (SOURCE-PATHNAME NAME) (PROBE-FILE (SOURCE-PATHNAME NAME)))) (CURRENT-SOURCE (IF (NOT *SOURCE*) :TOP-LEVEL (PROBE-FILE *SOURCE*)))) (COND ((EQUAL OLD-SOURCE CURRENT-SOURCE)) (T (IF (EQ CURRENT-SOURCE :TOP-LEVEL) (STYLE-WARN "redefining ~S at top level" NAME) (LET ((*PACKAGE* +CL-PACKAGE+)) (IF (EQ OLD-SOURCE :TOP-LEVEL) (STYLE-WARN "redefining ~S in ~S (previously defined at top level)" NAME CURRENT-SOURCE) (STYLE-WARN "redefining ~S in ~S (previously defined in ~S)" NAME CURRENT-SOURCE OLD-SOURCE))))))))))
     [java] ; (DEFUN RECORD-SOURCE-INFORMATION (NAME &OPTIONAL SOURCE-PATHNAME SOURCE-POSITION) (UNLESS SOURCE-PATHNAME (SETF SOURCE-PATHNAME (OR *SOURCE* :TOP-LEVEL))) (UNLESS SOURCE-POSITION (SETF SOURCE-POSITION *SOURCE-POSITION*)) (LET ((SOURCE (IF SOURCE-POSITION (CONS SOURCE-PATHNAME SOURCE-POSITION) SOURCE-PATHNAME))) (COND ((SYMBOLP NAME) (PUT NAME (QUOTE %SOURCE) SOURCE)))))
     [java] ; (DEFUN RECORD-SOURCE-INFORMATION-FOR-TYPE (NAME TYPE &OPTIONAL SOURCE-PATHNAME SOURCE-POSITION) "Record source information on the SYS:SOURCE property for symbol with NAME
     [java]
     [java] TYPE is either a symbol or list.
     [java]
     [java] Source information for functions, methods, and generic functions are
     [java] represented as lists of the following form:
     [java]
     [java]     (:generic-function function-name)
     [java]     (:function function-name)
     [java]     (:method method-name qualifiers specializers)
     [java]
     [java] Where FUNCTION-NAME or METHOD-NAME can be a either be of the form
     [java] 'symbol or '(setf symbol).
     [java]
     [java] Source information for all other forms have a symbol for TYPE which is
     [java] one of the following:
     [java]
     [java] :class, :variable, :condition, :constant, :compiler-macro, :macro
     [java] :package, :structure, :type, :setf-expander, :source-transform
     [java]
     [java] These values follow SBCL'S implemenation in SLIME
     [java] c.f. <https://github.com/slime/slime/blob/bad2acf672c33b913aabc1a7facb9c3c16a4afe9/swank/sbcl.lisp#L748>
     [java]
     [java] " (UNLESS SOURCE-PATHNAME (SETF SOURCE-PATHNAME (OR *SOURCE* :TOP-LEVEL))) (UNLESS SOURCE-POSITION (SETF SOURCE-POSITION *SOURCE-POSITION*)) (LET ((SOURCE (IF SOURCE-POSITION (LIST SOURCE-PATHNAME SOURCE-POSITION) (LIST SOURCE-PATHNAME)))) (LET ((SYM (IF (CONSP NAME) (SECOND NAME) NAME)) (NEW (BACKQ-LIST TYPE (IF (SYMBOLP (CAR SOURCE)) (CAR SOURCE) (NAMESTRING (CAR SOURCE))) (SECOND SOURCE)))) (IF (AUTOLOADP (QUOTE DELETE)) (PUT SYM (QUOTE SOURCE) (CONS NEW (GET SYM (QUOTE SOURCE) NIL))) (PUT SYM (QUOTE SOURCE) (CONS NEW (DELETE NEW (GET SYM (QUOTE SOURCE) NIL) :TEST (LAMBDA (A B) (AND (EQUALP (CAR A) (CAR B)) (EQUALP (SECOND A) (SECOND B)))))))))))
     [java] ; (DEFUN TRACE-REDEFINED-UPDATE (&REST ARGS) (DECLARE (IGNORE ARGS)))
     [java] ; (DEFUN UNTRACED-FUNCTION (NAME) (DECLARE (IGNORE NAME)) NIL)
     [java] ; (%DEFVAR (QUOTE *FSET-HOOKS*) NIL)
     [java] ; (DEFUN FSET (NAME FUNCTION &OPTIONAL SOURCE-POSITION ARGLIST DOCUMENTATION) (COND ((SYMBOLP NAME) (CHECK-REDEFINITION NAME) (RECORD-SOURCE-INFORMATION NAME NIL SOURCE-POSITION) (WHEN ARGLIST (%SET-ARGLIST FUNCTION ARGLIST)) (%SET-DOCUMENTATION FUNCTION (QUOTE FUNCTION) DOCUMENTATION) (%SET-SYMBOL-FUNCTION NAME FUNCTION)) ((SETF-FUNCTION-NAME-P NAME) (CHECK-REDEFINITION NAME) (RECORD-SOURCE-INFORMATION NAME NIL SOURCE-POSITION) (SETF (GET (%CADR NAME) (QUOTE SETF-FUNCTION)) FUNCTION)) (T (REQUIRE-TYPE NAME (QUOTE (OR SYMBOL (CONS (EQL SETF) (CONS SYMBOL NULL))))))) (WHEN (FUNCTIONP FUNCTION) (%SET-LAMBDA-NAME FUNCTION NAME)) (DOLIST (HOOK *FSET-HOOKS*) (IGNORE-ERRORS (FUNCALL HOOK NAME FUNCTION))) (TRACE-REDEFINED-UPDATE NAME FUNCTION) FUNCTION)
     [java] ; (DEFUN FDEFINITION (NAME) (COND ((SYMBOLP NAME) (SYMBOL-FUNCTION NAME)) ((SETF-FUNCTION-NAME-P NAME) (OR (GET (%CADR NAME) (QUOTE SETF-FUNCTION)) (ERROR (QUOTE UNDEFINED-FUNCTION) :NAME NAME))) (T (REQUIRE-TYPE NAME (QUOTE (OR SYMBOL (CONS (EQL SETF) (CONS SYMBOL NULL))))))))
     [java] ; (DEFUN %SET-FDEFINITION (NAME FUNCTION) (FSET NAME FUNCTION))
     [java] ; (DEFSETF FDEFINITION %SET-FDEFINITION)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/fdefinition.abcl (0.221 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/fill.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN LIST-FILL (SEQUENCE ITEM START END) (DO ((CURRENT (NTHCDR START SEQUENCE) (CDR CURRENT)) (INDEX START (1+ INDEX))) ((OR (ATOM CURRENT) (AND END (= INDEX END))) SEQUENCE) (RPLACA CURRENT ITEM)))
     [java] ; (DEFUN VECTOR-FILL (SEQUENCE ITEM START END) (UNLESS END (SETF END (LENGTH SEQUENCE))) (DO ((INDEX START (1+ INDEX))) ((= INDEX END) SEQUENCE) (SETF (AREF SEQUENCE INDEX) ITEM)))
     [java] ; (DEFUN FILL (SEQUENCE ITEM &KEY (START 0) END) "Replace the specified elements of SEQUENCE with ITEM." (SEQUENCE::SEQ-DISPATCH SEQUENCE (LIST-FILL SEQUENCE ITEM START END) (COND ((AND (STRINGP SEQUENCE) (ZEROP START) (NULL END)) (SIMPLE-STRING-FILL SEQUENCE ITEM)) (T (VECTOR-FILL SEQUENCE ITEM START END))) (SEQUENCE:FILL SEQUENCE ITEM :START START :END (SEQUENCE::%CHECK-GENERIC-SEQUENCE-BOUNDS SEQUENCE START END))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/fill.abcl (0.085 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/find-all-symbols.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN FIND-ALL-SYMBOLS (STRING) (LET ((STRING (STRING STRING)) (RES NIL)) (DOLIST (PACKAGE (LIST-ALL-PACKAGES)) (MULTIPLE-VALUE-BIND (SYMBOL STATUS) (FIND-SYMBOL STRING PACKAGE) (WHEN STATUS (PUSHNEW SYMBOL RES)))) RES))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/find-all-symbols.abcl (0.053 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/get-pid.lisp ...
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DEFUN GET-PID NIL "Get the process identifier of this lisp process.
     [java]
     [java] Used to be in SLIME but generally useful, so now back in ABCL proper." (HANDLER-CASE (LET* ((RUNTIME (JAVA:JSTATIC "getRuntime" "java.lang.Runtime")) (COMMAND (JAVA:JNEW-ARRAY-FROM-ARRAY "java.lang.String" #("sh" "-c" "echo $PPID"))) (RUNTIME-EXEC-JMETHOD (JAVA:JMETHOD "java.lang.Runtime" "exec" (JAVA:JCALL (JAVA:JMETHOD "java.lang.Object" "getClass") COMMAND))) (PROCESS (JAVA:JCALL RUNTIME-EXEC-JMETHOD RUNTIME COMMAND)) (OUTPUT (JAVA:JCALL (JAVA:JMETHOD "java.lang.Process" "getInputStream") PROCESS))) (JAVA:JCALL (JAVA:JMETHOD "java.lang.Process" "waitFor") PROCESS) (LOOP :WITH B :DO (SETQ B (JAVA:JCALL (JAVA:JMETHOD "java.io.InputStream" "read") OUTPUT)) :UNTIL (MEMBER B (QUOTE (-1 10))) :COLLECTING (CODE-CHAR B) :INTO RESULT :FINALLY (RETURN (PARSE-INTEGER (COERCE RESULT (QUOTE STRING)))))) (T NIL 0)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/get-pid.abcl (0.109 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/gentemp.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFVAR *GENTEMP-COUNTER* 0)
     [java] ; (DEFUN GENTEMP (&OPTIONAL (PREFIX "T") (PACKAGE *PACKAGE*)) (REQUIRE-TYPE PREFIX (QUOTE STRING)) (REQUIRE-TYPE PACKAGE (QUOTE (OR PACKAGE STRING SYMBOL CHARACTER))) (LOOP (LET ((NAME (FORMAT NIL "~A~D" PREFIX (INCF *GENTEMP-COUNTER*)))) (MULTIPLE-VALUE-BIND (SYMBOL EXISTS-P) (FIND-SYMBOL NAME PACKAGE) (UNLESS EXISTS-P (RETURN (VALUES (INTERN NAME PACKAGE))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/gentemp.abcl (0.067 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/gray-streams.lisp ...
     [java] ; (DEFPACKAGE "GRAY-STREAMS" (:USE "COMMON-LISP") (:NICKNAMES "GS") (:EXPORT "FUNDAMENTAL-STREAM" "FUNDAMENTAL-OUTPUT-STREAM" "FUNDAMENTAL-INPUT-STREAM" "FUNDAMENTAL-CHARACTER-STREAM" "FUNDAMENTAL-BINARY-STREAM" "STREAM-READ-BYTE" "STREAM-WRITE-BYTE" "FUNDAMENTAL-CHARACTER-INPUT-STREAM" "STREAM-READ-CHAR" "STREAM-UNREAD-CHAR" "STREAM-READ-CHAR-NO-HANG" "STREAM-PEEK-CHAR" "STREAM-LISTEN" "STREAM-READ-LINE" "STREAM-CLEAR-INPUT" "FUNDAMENTAL-CHARACTER-OUTPUT-STREAM" "STREAM-WRITE-CHAR" "STREAM-LINE-COLUMN" "STREAM-START-LINE-P" "STREAM-WRITE-STRING" "STREAM-TERPRI" "STREAM-FRESH-LINE" "STREAM-FINISH-OUTPUT" "STREAM-FORCE-OUTPUT" "STREAM-CLEAR-OUTPUT" "STREAM-ADVANCE-TO-COLUMN" "STREAM-READ-SEQUENCE" "STREAM-WRITE-SEQUENCE" "STREAM-FILE-POSITION" "FUNDAMENTAL-BINARY-INPUT-STREAM" "FUNDAMENTAL-BINARY-OUTPUT-STREAM"))
     [java] ; (IN-PACKAGE :GRAY-STREAMS)
     [java] ; (DEFVAR *ANSI-READ-CHAR* (FUNCTION READ-CHAR))
     [java] ; (DEFVAR *ANSI-PEEK-CHAR* (FUNCTION PEEK-CHAR))
     [java] ; (DEFVAR *ANSI-UNREAD-CHAR* (FUNCTION UNREAD-CHAR))
     [java] ; (DEFVAR *ANSI-LISTEN* (FUNCTION LISTEN))
     [java] ; (DEFVAR *ANSI-READ-LINE* (FUNCTION READ-LINE))
     [java] ; (DEFVAR *ANSI-READ-CHAR-NO-HANG* (FUNCTION READ-CHAR-NO-HANG))
     [java] ; (DEFVAR *ANSI-WRITE-CHAR* (FUNCTION WRITE-CHAR))
     [java] ; (DEFVAR *ANSI-FRESH-LINE* (FUNCTION FRESH-LINE))
     [java] ; (DEFVAR *ANSI-TERPRI* (FUNCTION TERPRI))
     [java] ; (DEFVAR *ANSI-WRITE-STRING* (FUNCTION WRITE-STRING))
     [java] ; (DEFVAR *ANSI-WRITE-LINE* (FUNCTION WRITE-LINE))
     [java] ; (DEFVAR *SYS-%FORCE-OUTPUT* (FUNCTION SYSTEM::%FORCE-OUTPUT))
     [java] ; (DEFVAR *SYS-%FINISH-OUTPUT* (FUNCTION SYSTEM::%FINISH-OUTPUT))
     [java] ; (DEFVAR *SYS-%CLEAR-OUTPUT* (FUNCTION SYSTEM::%CLEAR-OUTPUT))
     [java] ; (DEFVAR *SYS-%OUTPUT-OBJECT* (FUNCTION SYSTEM:%OUTPUT-OBJECT))
     [java] ; (DEFVAR *ANSI-CLEAR-INPUT* (FUNCTION CLEAR-INPUT))
     [java] ; (DEFVAR *ANSI-READ-BYTE* (FUNCTION READ-BYTE))
     [java] ; (DEFVAR *ANSI-WRITE-BYTE* (FUNCTION WRITE-BYTE))
     [java] ; (DEFVAR *ANSI-STREAM-ELEMENT-TYPE* (FUNCTION STREAM-ELEMENT-TYPE))
     [java] ; (DEFVAR *ANSI-CLOSE* (FUNCTION CLOSE))
     [java] ; (DEFVAR *ANSI-INPUT-CHARACTER-STREAM-P* (FUNCTION (LAMBDA (S) (AND (INPUT-STREAM-P S) (EQL (STREAM-ELEMENT-TYPE S) (QUOTE CHARACTER))))))
     [java] ; (DEFVAR *ANSI-INPUT-STREAM-P* (FUNCTION INPUT-STREAM-P))
     [java] ; (DEFVAR *ANSI-OUTPUT-STREAM-P* (FUNCTION OUTPUT-STREAM-P))
     [java] ; (DEFVAR *ANSI-OPEN-STREAM-P* (FUNCTION OPEN-STREAM-P))
     [java] ; (DEFVAR *ANSI-STREAMP* (FUNCTION STREAMP))
     [java] ; (DEFVAR *ANSI-READ-SEQUENCE* (FUNCTION READ-SEQUENCE))
     [java] ; (DEFVAR *ANSI-WRITE-SEQUENCE* (FUNCTION WRITE-SEQUENCE))
     [java] ; (DEFVAR *ANSI-MAKE-TWO-WAY-STREAM* (FUNCTION MAKE-TWO-WAY-STREAM))
     [java] ; (DEFVAR *ANSI-TWO-WAY-STREAM-INPUT-STREAM* (FUNCTION TWO-WAY-STREAM-INPUT-STREAM))
     [java] ; (DEFVAR *ANSI-TWO-WAY-STREAM-OUTPUT-STREAM* (FUNCTION TWO-WAY-STREAM-OUTPUT-STREAM))
     [java] ; (DEFVAR *ANSI-FILE-POSITION* (FUNCTION FILE-POSITION))
     [java] ; (DEFUN ANSI-STREAMP (STREAM) (OR (XP::XP-STRUCTURE-P STREAM) (FUNCALL *ANSI-STREAMP* STREAM)))
     [java] ; (DEFCLASS FUNDAMENTAL-STREAM (STANDARD-OBJECT STREAM) ((OPEN-P :INITFORM T :ACCESSOR STREAM-OPEN-P)) (:DOCUMENTATION "The base class of all Gray streams"))
     [java] ; (DEFGENERIC GRAY-CLOSE (STREAM &KEY ABORT))
     [java] ; (DEFGENERIC GRAY-OPEN-STREAM-P (STREAM))
     [java] ; (DEFGENERIC GRAY-STREAMP (STREAM))
     [java] ; (DEFGENERIC GRAY-INPUT-STREAM-P (STREAM))
     [java] ; (DEFGENERIC GRAY-INPUT-CHARACTER-STREAM-P (STREAM))
     [java] ; (DEFGENERIC GRAY-OUTPUT-STREAM-P (STREAM))
     [java] ; (DEFGENERIC GRAY-STREAM-ELEMENT-TYPE (STREAM))
     [java] ; (DEFMETHOD GRAY-CLOSE ((STREAM FUNDAMENTAL-STREAM) &KEY ABORT) (DECLARE (IGNORE ABORT)) (SETF (STREAM-OPEN-P STREAM) NIL) T)
     [java] ; (DEFMETHOD GRAY-OPEN-STREAM-P ((STREAM FUNDAMENTAL-STREAM)) (STREAM-OPEN-P STREAM))
     [java] ; (DEFMETHOD GRAY-STREAMP ((S FUNDAMENTAL-STREAM)) S)
     [java] ; (DEFCLASS FUNDAMENTAL-INPUT-STREAM (FUNDAMENTAL-STREAM) NIL)
     [java] ; (DEFMETHOD GRAY-INPUT-CHARACTER-STREAM-P (S) (AND (GRAY-INPUT-STREAM-P S) (EQ (GRAY-STREAM-ELEMENT-TYPE S) (QUOTE CHARACTER))))
     [java] ; (DEFMETHOD GRAY-INPUT-STREAM-P ((S FUNDAMENTAL-INPUT-STREAM)) (DECLARE (IGNORE S)) T)
     [java] ; (DEFCLASS FUNDAMENTAL-OUTPUT-STREAM (FUNDAMENTAL-STREAM) NIL)
     [java] ; (DEFMETHOD GRAY-INPUT-STREAM-P ((S FUNDAMENTAL-OUTPUT-STREAM)) (TYPEP S (QUOTE FUNDAMENTAL-INPUT-STREAM)))
     [java] ; (DEFMETHOD GRAY-OUTPUT-STREAM-P ((S FUNDAMENTAL-OUTPUT-STREAM)) (DECLARE (IGNORE S)) T)
     [java] ; (DEFMETHOD GRAY-OUTPUT-STREAM-P ((S FUNDAMENTAL-INPUT-STREAM)) (TYPEP S (QUOTE FUNDAMENTAL-OUTPUT-STREAM)))
     [java] ; (DEFCLASS FUNDAMENTAL-CHARACTER-STREAM (FUNDAMENTAL-STREAM) NIL)
     [java] ; (DEFMETHOD GRAY-STREAM-ELEMENT-TYPE ((S FUNDAMENTAL-CHARACTER-STREAM)) (DECLARE (IGNORE S)) (QUOTE CHARACTER))
     [java] ; (DEFCLASS FUNDAMENTAL-BINARY-STREAM (FUNDAMENTAL-STREAM) NIL)
     [java] ; (DEFGENERIC STREAM-READ-BYTE (STREAM))
     [java] ; (DEFGENERIC STREAM-WRITE-BYTE (STREAM INTEGER))
     [java] ; (DEFCLASS FUNDAMENTAL-CHARACTER-INPUT-STREAM (FUNDAMENTAL-INPUT-STREAM FUNDAMENTAL-CHARACTER-STREAM) NIL)
     [java] ; (DEFGENERIC STREAM-READ-CHAR (STREAM))
     [java] ; (DEFGENERIC STREAM-UNREAD-CHAR (STREAM CHARACTER))
     [java] ; (DEFGENERIC STREAM-READ-CHAR-NO-HANG (STREAM))
     [java] ; (DEFGENERIC STREAM-PEEK-CHAR (STREAM))
     [java] ; (DEFGENERIC STREAM-LISTEN (STREAM))
     [java] ; (DEFGENERIC STREAM-READ-LINE (STREAM))
     [java] ; (DEFGENERIC STREAM-CLEAR-INPUT (STREAM))
     [java] ; (DEFMETHOD STREAM-PEEK-CHAR ((STREAM FUNDAMENTAL-CHARACTER-INPUT-STREAM)) (LET ((CHARACTER (STREAM-READ-CHAR STREAM))) (UNLESS (EQ CHARACTER :EOF) (STREAM-UNREAD-CHAR STREAM CHARACTER)) CHARACTER))
     [java] ; (DEFMETHOD STREAM-LISTEN ((STREAM FUNDAMENTAL-CHARACTER-INPUT-STREAM)) (LET ((CHAR (STREAM-READ-CHAR-NO-HANG STREAM))) (AND (NOT (NULL CHAR)) (NOT (EQ CHAR :EOF)) (PROGN (STREAM-UNREAD-CHAR STREAM CHAR) T))))
     [java] ; (DEFMETHOD STREAM-READ-LINE ((STREAM FUNDAMENTAL-CHARACTER-INPUT-STREAM)) (LET ((LINE (MAKE-ARRAY 64 :ELEMENT-TYPE (QUOTE CHARACTER) :FILL-POINTER 0 :ADJUSTABLE T))) (LOOP (LET ((CHARACTER (STREAM-READ-CHAR STREAM))) (IF (EQ CHARACTER :EOF) (RETURN (VALUES LINE T)) (IF (EQL CHARACTER #\Newline) (RETURN (VALUES LINE NIL)) (VECTOR-PUSH-EXTEND CHARACTER LINE)))))))
     [java] ; (DEFMETHOD STREAM-CLEAR-INPUT (STREAM) (DECLARE (IGNORE STREAM)) NIL)
     [java] ; (DEFCLASS FUNDAMENTAL-CHARACTER-OUTPUT-STREAM (FUNDAMENTAL-OUTPUT-STREAM FUNDAMENTAL-CHARACTER-STREAM) NIL)
     [java] ; (DEFGENERIC STREAM-WRITE-CHAR (STREAM CHARACTER))
     [java] ; (DEFGENERIC STREAM-LINE-COLUMN (STREAM))
     [java] ; (DEFGENERIC STREAM-START-LINE-P (STREAM))
     [java] ; (DEFGENERIC STREAM-WRITE-STRING (STREAM STRING &OPTIONAL START END))
     [java] ; (DEFGENERIC STREAM-TERPRI (STREAM))
     [java] ; (DEFMETHOD STREAM-TERPRI (STREAM) (STREAM-WRITE-CHAR STREAM #\Newline))
     [java] ; (DEFGENERIC STREAM-FRESH-LINE (STREAM))
     [java] ; (DEFGENERIC STREAM-FINISH-OUTPUT (STREAM))
     [java] ; (DEFGENERIC STREAM-FORCE-OUTPUT (STREAM))
     [java] ; (DEFGENERIC STREAM-CLEAR-OUTPUT (STREAM))
     [java] ; (DEFGENERIC STREAM-ADVANCE-TO-COLUMN (STREAM COLUMN))
     [java] ; (DEFGENERIC STREAM-READ-SEQUENCE (STREAM SEQUENCE &OPTIONAL START END))
     [java] ; (DEFGENERIC STREAM-WRITE-SEQUENCE (STREAM SEQUENCE &OPTIONAL START END))
     [java] ; (DEFMETHOD STREAM-FORCE-OUTPUT (STREAM) (DECLARE (IGNORE STREAM)) NIL)
     [java] ; (DEFMETHOD STREAM-FINISH-OUTPUT (STREAM) (DECLARE (IGNORE STREAM)) NIL)
     [java] ; (DEFMETHOD STREAM-CLEAR-OUTPUT (STREAM) (DECLARE (IGNORE STREAM)) NIL)
     [java] ; (DEFMETHOD STREAM-START-LINE-P ((STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) (EQUAL (STREAM-LINE-COLUMN STREAM) 0))
     [java] ; (DEFMETHOD STREAM-WRITE-STRING ((STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) STRING &OPTIONAL (START 0) END) (LET ((END (OR END (LENGTH STRING)))) (DO ((I START (1+ I))) ((>= I END) STRING) (STREAM-WRITE-CHAR STREAM (CHAR STRING I)))))
     [java] ; (DEFMETHOD STREAM-FRESH-LINE ((STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM)) (IF (STREAM-START-LINE-P STREAM) NIL (PROGN (STREAM-TERPRI STREAM) T)))
     [java] ; (DEFMETHOD STREAM-ADVANCE-TO-COLUMN ((STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) COLUMN) (LET ((CURRENT (STREAM-LINE-COLUMN STREAM))) (UNLESS (NULL CURRENT) (DOTIMES (I (- CURRENT COLUMN) T) (STREAM-WRITE-CHAR STREAM #\ )))))
     [java] ; (DEFUN BASIC-READ-SEQUENCE (STREAM SEQUENCE START END EXPECTED-ELEMENT-TYPE READ-FUN) (LET ((ELEMENT-TYPE (STREAM-ELEMENT-TYPE STREAM))) (IF (SUBTYPEP ELEMENT-TYPE EXPECTED-ELEMENT-TYPE) (DOTIMES (COUNT (- END START) (MAX START END)) (LET ((EL (FUNCALL READ-FUN STREAM))) (WHEN (EQ EL :EOF) (RETURN (+ COUNT START))) (SETF (ELT SEQUENCE (+ COUNT START)) EL))) (ERROR "Cannot READ-SEQUENCE on stream of :ELEMENT-TYPE ~A" ELEMENT-TYPE))))
     [java] ; (DEFUN BASIC-WRITE-SEQUENCE (STREAM SEQUENCE START END EXPECTED-ELEMENT-TYPE WRITE-FUN) (LET ((ELEMENT-TYPE (STREAM-ELEMENT-TYPE STREAM))) (IF (SUBTYPEP ELEMENT-TYPE EXPECTED-ELEMENT-TYPE) (DO ((N START (+ N 1))) ((= N END)) (FUNCALL WRITE-FUN STREAM (ELT SEQUENCE N))) (ERROR "Cannot WRITE-SEQUENCE on stream of :ELEMENT-TYPE ~A" ELEMENT-TYPE))) (STREAM-FORCE-OUTPUT STREAM) SEQUENCE)
     [java] ; (DEFMETHOD STREAM-READ-SEQUENCE ((STREAM FUNDAMENTAL-CHARACTER-INPUT-STREAM) SEQUENCE &OPTIONAL (START 0) END) (BASIC-READ-SEQUENCE STREAM SEQUENCE START (OR END (LENGTH SEQUENCE)) (QUOTE CHARACTER) (FUNCTION STREAM-READ-CHAR)))
     [java] ; (DEFMETHOD STREAM-WRITE-SEQUENCE ((STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM) SEQUENCE &OPTIONAL (START 0) END) (BASIC-WRITE-SEQUENCE STREAM SEQUENCE START (OR END (LENGTH SEQUENCE)) (QUOTE CHARACTER) (FUNCTION STREAM-WRITE-CHAR)))
     [java] ; (DEFCLASS FUNDAMENTAL-BINARY-INPUT-STREAM (FUNDAMENTAL-INPUT-STREAM FUNDAMENTAL-BINARY-STREAM) NIL)
     [java] ; (DEFCLASS FUNDAMENTAL-BINARY-OUTPUT-STREAM (FUNDAMENTAL-OUTPUT-STREAM FUNDAMENTAL-BINARY-STREAM) NIL)
     [java] ; (DEFMETHOD STREAM-READ-SEQUENCE ((STREAM FUNDAMENTAL-BINARY-INPUT-STREAM) SEQUENCE &OPTIONAL (START 0) END) (BASIC-READ-SEQUENCE STREAM SEQUENCE START (OR END (LENGTH SEQUENCE)) (QUOTE SIGNED-BYTE) (FUNCTION STREAM-READ-BYTE)))
     [java] ; (DEFMETHOD STREAM-WRITE-SEQUENCE ((STREAM FUNDAMENTAL-BINARY-OUTPUT-STREAM) SEQUENCE &OPTIONAL (START 0) END) (BASIC-WRITE-SEQUENCE STREAM SEQUENCE START (OR END (LENGTH SEQUENCE)) (QUOTE SIGNED-BYTE) (FUNCTION STREAM-WRITE-BYTE)))
     [java] ; (DEFUN DECODE-READ-ARG (ARG) (COND ((NULL ARG) *STANDARD-INPUT*) ((EQ ARG T) *TERMINAL-IO*) (T ARG)))
     [java] ; (DEFUN DECODE-PRINT-ARG (ARG) (COND ((NULL ARG) *STANDARD-OUTPUT*) ((EQ ARG T) *TERMINAL-IO*) (T ARG)))
     [java] ; (DEFUN REPORT-EOF (STREAM EOF-ERRORP EOF-VALUE) (IF EOF-ERRORP (ERROR (QUOTE END-OF-FILE) :STREAM STREAM) EOF-VALUE))
     [java] ; (DEFUN CHECK-FOR-EOF (VALUE STREAM EOF-ERRORP EOF-VALUE) (IF (EQ VALUE :EOF) (REPORT-EOF STREAM EOF-ERRORP EOF-VALUE) VALUE))
     [java] ; (DEFUN GRAY-READ-CHAR (&OPTIONAL INPUT-STREAM (EOF-ERRORP T) EOF-VALUE RECURSIVE-P) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-READ-CHAR* STREAM EOF-ERRORP EOF-VALUE RECURSIVE-P) (CHECK-FOR-EOF (STREAM-READ-CHAR STREAM) STREAM EOF-ERRORP EOF-VALUE))))
     [java] ; (DEFUN GRAY-PEEK-CHAR (&OPTIONAL PEEK-TYPE INPUT-STREAM (EOF-ERRORP T) EOF-VALUE RECURSIVE-P) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-PEEK-CHAR* PEEK-TYPE STREAM EOF-ERRORP EOF-VALUE RECURSIVE-P) (IF (NULL PEEK-TYPE) (CHECK-FOR-EOF (STREAM-PEEK-CHAR STREAM) STREAM EOF-ERRORP EOF-VALUE) (LOOP (LET ((VALUE (STREAM-PEEK-CHAR STREAM))) (IF (EQ VALUE :EOF) (RETURN (REPORT-EOF STREAM EOF-ERRORP EOF-VALUE)) (IF (IF (EQ PEEK-TYPE T) (NOT (MEMBER VALUE (QUOTE (#\  #\Tab #\Newline #\Return)))) (CHAR= PEEK-TYPE VALUE)) (RETURN VALUE) (STREAM-READ-CHAR STREAM)))))))))
     [java] ; (DEFUN GRAY-UNREAD-CHAR (CHARACTER &OPTIONAL INPUT-STREAM) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-UNREAD-CHAR* CHARACTER STREAM) (STREAM-UNREAD-CHAR STREAM CHARACTER))))
     [java] ; (DEFUN GRAY-LISTEN (&OPTIONAL INPUT-STREAM) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-LISTEN* STREAM) (STREAM-LISTEN STREAM))))
     [java] ; (DEFUN GRAY-READ-LINE (&OPTIONAL INPUT-STREAM (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-READ-LINE* STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P) (MULTIPLE-VALUE-BIND (STRING EOFP) (STREAM-READ-LINE STREAM) (IF EOFP (IF (= (LENGTH STRING) 0) (REPORT-EOF STREAM EOF-ERROR-P EOF-VALUE) (VALUES STRING T)) (VALUES STRING NIL))))))
     [java] ; (DEFUN GRAY-CLEAR-INPUT (&OPTIONAL INPUT-STREAM) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-CLEAR-INPUT* STREAM) (STREAM-CLEAR-INPUT STREAM))))
     [java] ; (DEFUN GRAY-OUTPUT-OBJECT (OBJECT STREAM) (IF (ANSI-STREAMP STREAM) (FUNCALL *SYS-%OUTPUT-OBJECT* OBJECT STREAM) (STREAM-WRITE-STRING STREAM (WITH-OUTPUT-TO-STRING (S) (FUNCALL *SYS-%OUTPUT-OBJECT* OBJECT S)))))
     [java] ; (DEFUN GRAY-READ-CHAR-NO-HANG (&OPTIONAL INPUT-STREAM (EOF-ERRORP T) EOF-VALUE RECURSIVE-P) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-READ-CHAR-NO-HANG* STREAM EOF-ERRORP EOF-VALUE RECURSIVE-P) (CHECK-FOR-EOF (STREAM-READ-CHAR-NO-HANG STREAM) STREAM EOF-ERRORP EOF-VALUE))))
     [java] ; (DEFUN GRAY-WRITE-CHAR (CHARACTER &OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-WRITE-CHAR* CHARACTER STREAM) (STREAM-WRITE-CHAR STREAM CHARACTER))))
     [java] ; (DEFUN GRAY-FRESH-LINE (&OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-FRESH-LINE* STREAM) (STREAM-FRESH-LINE STREAM))))
     [java] ; (DEFUN GRAY-TERPRI (&OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-TERPRI* STREAM) (STREAM-TERPRI STREAM))))
     [java] ; (DEFUN GRAY-WRITE-STRING (STRING &OPTIONAL OUTPUT-STREAM &KEY (START 0) END) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-WRITE-STRING* STRING STREAM :START START :END END) (STREAM-WRITE-STRING STREAM STRING START END))))
     [java] ; (DEFUN GRAY-WRITE-LINE (STRING &OPTIONAL OUTPUT-STREAM &KEY (START 0) END) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-WRITE-LINE* STRING STREAM :START START :END END) (PROGN (STREAM-WRITE-STRING STREAM STRING START END) (STREAM-TERPRI STREAM) STRING))))
     [java] ; (DEFUN GRAY-FORCE-OUTPUT (&OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *SYS-%FORCE-OUTPUT* STREAM) (STREAM-FORCE-OUTPUT STREAM))))
     [java] ; (DEFUN GRAY-FINISH-OUTPUT (&OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *SYS-%FINISH-OUTPUT* STREAM) (STREAM-FINISH-OUTPUT STREAM))))
     [java] ; (DEFUN GRAY-CLEAR-OUTPUT (&OPTIONAL OUTPUT-STREAM) (LET ((STREAM (DECODE-PRINT-ARG OUTPUT-STREAM))) (IF (ANSI-STREAMP STREAM) (FUNCALL *SYS-%CLEAR-OUTPUT* STREAM) (STREAM-CLEAR-OUTPUT STREAM))))
     [java] ; (DEFUN GRAY-READ-BYTE (BINARY-INPUT-STREAM &OPTIONAL (EOF-ERRORP T) EOF-VALUE) (IF (ANSI-STREAMP BINARY-INPUT-STREAM) (FUNCALL *ANSI-READ-BYTE* BINARY-INPUT-STREAM EOF-ERRORP EOF-VALUE) (CHECK-FOR-EOF (STREAM-READ-BYTE BINARY-INPUT-STREAM) BINARY-INPUT-STREAM EOF-ERRORP EOF-VALUE)))
     [java] ; (DEFUN GRAY-WRITE-BYTE (INTEGER BINARY-OUTPUT-STREAM) (IF (ANSI-STREAMP BINARY-OUTPUT-STREAM) (FUNCALL *ANSI-WRITE-BYTE* INTEGER BINARY-OUTPUT-STREAM) (STREAM-WRITE-BYTE BINARY-OUTPUT-STREAM INTEGER)))
     [java] ; (DEFMETHOD STREAM-LINE-COLUMN ((STREAM STREAM)) NIL)
     [java] ; (DEFUN GRAY-STREAM-COLUMN (&OPTIONAL INPUT-STREAM) (LET ((STREAM (DECODE-READ-ARG INPUT-STREAM))) (IF (ANSI-STREAMP STREAM) NIL (STREAM-LINE-COLUMN STREAM))))
     [java] ; (DEFMETHOD GRAY-STREAM-ELEMENT-TYPE (STREAM) (FUNCALL *ANSI-STREAM-ELEMENT-TYPE* STREAM))
     [java] ; (DEFMETHOD GRAY-CLOSE (STREAM &KEY ABORT) (FUNCALL *ANSI-CLOSE* STREAM :ABORT ABORT))
     [java] ; (DEFMETHOD GRAY-INPUT-STREAM-P (STREAM) (FUNCALL *ANSI-INPUT-STREAM-P* STREAM))
     [java] ; (DEFMETHOD GRAY-INPUT-CHARACTER-STREAM-P (STREAM) (FUNCALL *ANSI-INPUT-CHARACTER-STREAM-P* STREAM))
     [java] ; (DEFMETHOD GRAY-OUTPUT-STREAM-P (STREAM) (FUNCALL *ANSI-OUTPUT-STREAM-P* STREAM))
     [java] ; (DEFMETHOD GRAY-OPEN-STREAM-P (STREAM) (FUNCALL *ANSI-OPEN-STREAM-P* STREAM))
     [java] ; (DEFMETHOD GRAY-STREAMP (STREAM) (FUNCALL *ANSI-STREAMP* STREAM))
     [java] ; (DEFUN GRAY-WRITE-SEQUENCE (SEQUENCE STREAM &KEY (START 0) END) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-WRITE-SEQUENCE* SEQUENCE STREAM :START START :END END) (STREAM-WRITE-SEQUENCE STREAM SEQUENCE START END)))
     [java] ; (DEFUN GRAY-READ-SEQUENCE (SEQUENCE STREAM &KEY (START 0) END) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-READ-SEQUENCE* SEQUENCE STREAM :START START :END END) (STREAM-READ-SEQUENCE STREAM SEQUENCE START END)))
     [java] ; (DEFGENERIC STREAM-FILE-POSITION (STREAM &OPTIONAL POSITION-SPEC))
     [java] ; (DEFUN GRAY-FILE-POSITION (STREAM &OPTIONAL POSITION-SPEC) (IF POSITION-SPEC (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-FILE-POSITION* STREAM POSITION-SPEC) (STREAM-FILE-POSITION STREAM POSITION-SPEC)) (IF (ANSI-STREAMP STREAM) (FUNCALL *ANSI-FILE-POSITION* STREAM) (STREAM-FILE-POSITION STREAM))))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE READ-CHAR)) (FUNCTION GRAY-READ-CHAR))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE PEEK-CHAR)) (FUNCTION GRAY-PEEK-CHAR))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE UNREAD-CHAR)) (FUNCTION GRAY-UNREAD-CHAR))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE READ-LINE)) (FUNCTION GRAY-READ-LINE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE CLEAR-INPUT)) (FUNCTION GRAY-CLEAR-INPUT))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE READ-CHAR-NO-HANG)) (FUNCTION GRAY-READ-CHAR-NO-HANG))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE WRITE-CHAR)) (FUNCTION GRAY-WRITE-CHAR))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE FRESH-LINE)) (FUNCTION GRAY-FRESH-LINE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE TERPRI)) (FUNCTION GRAY-TERPRI))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE WRITE-STRING)) (FUNCTION GRAY-WRITE-STRING))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE WRITE-LINE)) (FUNCTION GRAY-WRITE-LINE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE SYSTEM::%FORCE-OUTPUT)) (FUNCTION GRAY-FORCE-OUTPUT))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE SYSTEM::%FINISH-OUTPUT)) (FUNCTION GRAY-FINISH-OUTPUT))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE SYSTEM::%CLEAR-OUTPUT)) (FUNCTION GRAY-CLEAR-OUTPUT))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE SYSTEM:%OUTPUT-OBJECT)) (FUNCTION GRAY-OUTPUT-OBJECT))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE READ-BYTE)) (FUNCTION GRAY-READ-BYTE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE WRITE-BYTE)) (FUNCTION GRAY-WRITE-BYTE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE COMMON-LISP::STREAM-COLUMN)) (FUNCTION GRAY-STREAM-COLUMN))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE STREAM-ELEMENT-TYPE)) (FUNCTION GRAY-STREAM-ELEMENT-TYPE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE CLOSE)) (FUNCTION GRAY-CLOSE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE INPUT-STREAM-P)) (FUNCTION GRAY-INPUT-STREAM-P))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE COMMON-LISP::INPUT-CHARACTER-STREAM-P)) (FUNCTION GRAY-INPUT-CHARACTER-STREAM-P))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE OUTPUT-STREAM-P)) (FUNCTION GRAY-OUTPUT-STREAM-P))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE OPEN-STREAM-P)) (FUNCTION GRAY-OPEN-STREAM-P))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE STREAMP)) (FUNCTION GRAY-STREAMP))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE READ-SEQUENCE)) (FUNCTION GRAY-READ-SEQUENCE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE WRITE-SEQUENCE)) (FUNCTION GRAY-WRITE-SEQUENCE))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE FILE-POSITION)) (FUNCTION GRAY-FILE-POSITION))
     [java] ; (SETF (SYMBOL-FUNCTION (QUOTE LISTEN)) (FUNCTION GRAY-LISTEN))
     [java] ; (DOLIST (E (QUOTE ((READ-CHAR GRAY-READ-CHAR) (PEEK-CHAR GRAY-PEEK-CHAR) (UNREAD-CHAR GRAY-UNREAD-CHAR) (READ-LINE GRAY-READ-LINE) (CLEAR-INPUT GRAY-CLEAR-INPUT) (READ-CHAR-NO-HANG GRAY-READ-CHAR-NO-HANG) (WRITE-CHAR GRAY-WRITE-CHAR) (FRESH-LINE GRAY-FRESH-LINE) (TERPRI GRAY-TERPRI) (WRITE-STRING GRAY-WRITE-STRING) (WRITE-LINE GRAY-WRITE-LINE) (SYSTEM::%FORCE-OUTPUT GRAY-FORCE-OUTPUT) (SYSTEM::%FINISH-OUTPUT GRAY-FINISH-OUTPUT) (SYSTEM::%CLEAR-OUTPUT GRAY-CLEAR-OUTPUT) (SYSTEM:%OUTPUT-OBJECT GRAY-OUTPUT-OBJECT) (READ-BYTE GRAY-READ-BYTE) (WRITE-BYTE GRAY-WRITE-BYTE) (COMMON-LISP::STREAM-COLUMN GRAY-STREAM-COLUMN) (STREAM-ELEMENT-TYPE GRAY-STREAM-ELEMENT-TYPE) (CLOSE GRAY-CLOSE) (INPUT-STREAM-P GRAY-INPUT-STREAM-P) (COMMON-LISP::INPUT-CHARACTER-STREAM-P GRAY-INPUT-CHARACTER-STREAM-P) (OUTPUT-STREAM-P GRAY-OUTPUT-STREAM-P) (OPEN-STREAM-P GRAY-OPEN-STREAM-P) (STREAMP GRAY-STREAMP) (READ-SEQUENCE GRAY-READ-SEQUENCE) (WRITE-SEQUENCE GRAY-WRITE-SEQUENCE) (FILE-POSITION GRAY-FILE-POSITION) (LISTEN GRAY-LISTEN)))) (SYSTEM:PUT (CAR E) (QUOTE SYSTEM::SOURCE) (GET (SECOND E) (QUOTE SYSTEM::SOURCE))))
     [java] ; (MAPCAR (LAMBDA (O) (MOP:FINALIZE-INHERITANCE (FIND-CLASS O))) (QUOTE (FUNDAMENTAL-STREAM FUNDAMENTAL-INPUT-STREAM FUNDAMENTAL-OUTPUT-STREAM FUNDAMENTAL-CHARACTER-STREAM FUNDAMENTAL-CHARACTER-INPUT-STREAM FUNDAMENTAL-CHARACTER-OUTPUT-STREAM FUNDAMENTAL-BINARY-STREAM FUNDAMENTAL-BINARY-INPUT-STREAM FUNDAMENTAL-BINARY-OUTPUT-STREAM)))
     [java] ; (DEFPARAMETER *SYS--STREAM-CHARPOS* (FUNCTION SYSTEM::STREAM-CHARPOS))
     [java] ; (DEFUN SYSTEM::STREAM-CHARPOS (STREAM) (COND ((SUBTYPEP (TYPE-OF STREAM) (QUOTE FUNDAMENTAL-STREAM)) (STREAM-LINE-COLUMN STREAM)) ((STREAMP STREAM) (FUNCALL *SYS--STREAM-CHARPOS* STREAM))))
     [java] ; (DEFPARAMETER *SYS--STREAM-%SET-CHARPOS* (FUNCTION SYSTEM::STREAM-%SET-CHARPOS))
     [java] ; (DEFUN SYSTEM::STREAM-%SET-CHARPOS (NEW-VALUE STREAM) (COND ((SUBTYPEP (TYPE-OF STREAM) (QUOTE FUNDAMENTAL-STREAM)) (SETF (STREAM-LINE-COLUMN STREAM) NEW-VALUE)) ((STREAMP STREAM) (FUNCALL *SYS--STREAM-%SET-CHARPOS* STREAM NEW-VALUE))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/gray-streams.abcl (2.74 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/gui.lisp ...
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DEFVAR *GUI-BACKEND* :SWING)
     [java] ; (DEFUN INIT-GUI NIL "Dummy function used to autoload this file" T)
     [java] ; (DEFUN MAKE-DIALOG-PROMPT-STREAM NIL (%MAKE-DIALOG-PROMPT-STREAM *GUI-BACKEND*))
     [java] ; (DEFGENERIC %MAKE-DIALOG-PROMPT-STREAM (GUI-BACKEND))
     [java] ; (DEFMETHOD %MAKE-DIALOG-PROMPT-STREAM ((GUI-BACKEND (EQL :SWING))) (JAVA:JNEW (JAVA:JCONSTRUCTOR "org.armedbear.lisp.java.swing.SwingDialogPromptStream")))
     [java] ; (DEFMETHOD %MAKE-DIALOG-PROMPT-STREAM ((GUI-BACKEND (EQL :AWT))) (JAVA:JNEW (JAVA:JCONSTRUCTOR "org.armedbear.lisp.java.awt.AwtDialogPromptStream")))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/gui.abcl (0.255 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inline.lisp ...
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DEFUN INLINE-EXPANSION (NAME) (GET-FUNCTION-INFO-VALUE NAME :INLINE-EXPANSION))
     [java] ; (DEFUN SET-INLINE-EXPANSION (NAME EXPANSION) (SET-FUNCTION-INFO-VALUE NAME :INLINE-EXPANSION EXPANSION))
     [java] ; (DEFSETF INLINE-EXPANSION SET-INLINE-EXPANSION)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/inline.abcl (0.085 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/inspect.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFVAR *INSPECT-BREAK* NIL)
     [java] ; (DEFVAR *INSPECTED-OBJECT-STACK* NIL)
     [java] ; (DEFVAR *INSPECTED-OBJECT* NIL)
     [java] ; (DEFUN LEADER (NAME) (LET ((SIZE (MAX 0 (- 16 (LENGTH (STRING NAME)))))) (CONCATENATE (QUOTE STRING) (MAKE-STRING SIZE :INITIAL-ELEMENT #\-) "->")))
     [java] ; (DEFUN SAFE-LENGTH (X) (DO ((N 0 (+ N 2)) (FAST X (CDDR FAST)) (SLOW X (CDR SLOW))) (NIL) (WHEN (NULL FAST) (RETURN (VALUES N :PROPER))) (WHEN (ATOM FAST) (RETURN (VALUES N :DOTTED))) (WHEN (NULL (CDR FAST)) (RETURN (VALUES (+ N 1) :PROPER))) (WHEN (ATOM (CDR FAST)) (RETURN (VALUES (+ N 1) :DOTTED))) (WHEN (AND (EQ FAST SLOW) (> N 0)) (RETURN (VALUES NIL :CIRCULAR)))))
     [java] ; (DEFUN DISPLAY-OBJECT (OBJ) (LET ((*PRINT-LENGTH* 2) (*PRINT-LEVEL* 2)) (COND ((TYPEP OBJ (QUOTE STANDARD-OBJECT)) (LET ((PARTS (INSPECTED-PARTS OBJ)) (I 0)) (DOLIST (PART PARTS) (LET ((NAME (CAR PART)) (VALUE (CDR PART))) (FORMAT T "~4D ~A ~A ~S~%" I NAME (LEADER NAME) VALUE) (INCF I))))) ((SIMPLE-VECTOR-P OBJ) (FORMAT T "~A at #x~X~%" (INSPECTED-DESCRIPTION OBJ) (IDENTITY-HASH-CODE OBJ)) (LET ((LIMIT (MIN (LENGTH OBJ) 25))) (DOTIMES (I LIMIT) (FORMAT T "~4D-> ~A~%" I (AREF OBJ I))))) ((VECTORP OBJ) (FORMAT T "~A~%" (INSPECTED-DESCRIPTION OBJ)) (LET ((LIMIT (MIN (LENGTH OBJ) 25))) (DOTIMES (I LIMIT) (FORMAT T "~4D-> ~A~%" I (AREF OBJ I))))) ((CONSP OBJ) (MULTIPLE-VALUE-BIND (LEN KIND) (SAFE-LENGTH OBJ) (CASE KIND (:PROPER (FORMAT T "A proper list with ~D elements at #x~X~%" LEN (IDENTITY-HASH-CODE OBJ)) (LET ((I 0)) (DOLIST (ITEM OBJ) (COND ((< I 25) (FORMAT T "~4D-> ~S~%" I ITEM)) ((= I 25) (FORMAT T "    ...~%")) ((= I (1- LEN)) (FORMAT T "~4D-> ~S~%" I ITEM))) (INCF I)))) (:DOTTED (FORMAT T "A dotted list with ~D elements at #x~X~%" LEN (IDENTITY-HASH-CODE OBJ)) (LET* ((REST OBJ) (ITEM (CAR REST)) (I 0)) (LOOP (COND ((< I 25) (FORMAT T "~4D-> ~S~%" I ITEM)) ((= I 25) (FORMAT T "    ...~%"))) (INCF I) (SETF REST (CDR REST)) (WHEN (ATOM REST) (RETURN)) (SETF ITEM (CAR REST))) (FORMAT T "tail-> ~S~%" REST))) (:CIRCULAR (FORMAT T "A circular list at #x~X~%" (IDENTITY-HASH-CODE OBJ)))))) (T (FORMAT T "~A~%" (INSPECTED-DESCRIPTION OBJ)) (LET ((PARTS (INSPECTED-PARTS OBJ)) (I 0) (LIMIT 25)) (DOLIST (PART PARTS) (LET ((NAME (STRING (CAR PART))) (VALUE (CDR PART))) (FORMAT T "~4D ~A ~A ~S~%" I NAME (LEADER NAME) VALUE) (INCF I) (WHEN (> I LIMIT) (RETURN)))))))) (VALUES))
     [java] ; (DEFUN DISPLAY-CURRENT NIL (IF *INSPECT-BREAK* (DISPLAY-OBJECT *INSPECTED-OBJECT*) (FORMAT T "No object is being inspected.")))
     [java] ; (DEFUN INSPECT (OBJ) (WHEN *INSPECTOR-HOOK* (FUNCALL *INSPECTOR-HOOK* OBJ)) (WHEN *INSPECTED-OBJECT* (PUSH *INSPECTED-OBJECT* *INSPECTED-OBJECT-STACK*)) (SETF *INSPECTED-OBJECT* OBJ) (LET* ((*INSPECT-BREAK* T) (*DEBUG-LEVEL* (1+ *DEBUG-LEVEL*))) (SETF *** ** ** * * OBJ) (DISPLAY-CURRENT) (CATCH (QUOTE INSPECT-EXIT) (TOP-LEVEL::REPL))) (SETF *** ** ** * * OBJ) (VALUES))
     [java] ; (DEFUN ISTEP (ARGS) (IF (NULL ARGS) (DISPLAY-CURRENT) (LET* ((POS (POSITION #\  ARGS)) (OPTION-STRING (IF POS (SUBSEQ ARGS 0 POS) ARGS)) (OPTION (READ-FROM-STRING OPTION-STRING))) (COND ((STRING= OPTION-STRING "-") (IF *INSPECTED-OBJECT-STACK* (PROGN (SETF *INSPECTED-OBJECT* (POP *INSPECTED-OBJECT-STACK*)) (SETF *** ** ** * * *INSPECTED-OBJECT*) (DISPLAY-CURRENT)) (FORMAT T "Object has no parent."))) ((STRING= OPTION-STRING "q") (SETF *INSPECTED-OBJECT* NIL *INSPECTED-OBJECT-STACK* NIL *INSPECT-BREAK* NIL) (THROW (QUOTE INSPECT-EXIT) NIL)) ((FIXNUMP OPTION) (LET* ((INDEX OPTION) (PARTS (INSPECTED-PARTS *INSPECTED-OBJECT*))) (COND ((NULL PARTS) (IF (TYPEP *INSPECTED-OBJECT* (QUOTE SEQUENCE)) (IF (OR (MINUSP INDEX) (>= INDEX (LENGTH *INSPECTED-OBJECT*))) (FORMAT T "Invalid index (~D)." INDEX) (PROGN (PUSH *INSPECTED-OBJECT* *INSPECTED-OBJECT-STACK*) (SETF *INSPECTED-OBJECT* (ELT *INSPECTED-OBJECT* INDEX)) (SETF * *INSPECTED-OBJECT*) (DISPLAY-CURRENT))) (FORMAT T "Object has no selectable components."))) ((OR (MINUSP INDEX) (>= INDEX (LENGTH PARTS))) (FORMAT T "Invalid index (~D)." INDEX)) (T (PUSH *INSPECTED-OBJECT* *INSPECTED-OBJECT-STACK*) (SETF *INSPECTED-OBJECT* (CDR (ELT PARTS INDEX))) (SETF * *INSPECTED-OBJECT*) (DISPLAY-CURRENT)))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/inspect.abcl (0.758 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/java.lisp ...
     [java] ; (IN-PACKAGE "JAVA")
     [java] ; (DEFVAR *CLASSLOADER* (GET-DEFAULT-CLASSLOADER))
     [java] ; (DEFUN ADD-URL-TO-CLASSPATH (URL &OPTIONAL (CLASSLOADER *CLASSLOADER*)) (JSTATIC "addUrl" +LISP-CLASS+ CLASSLOADER URL))
     [java] ; in (DEFUN ADD-URL-TO-CLASSPATH (URL &OPTIONAL (CLASSLOADER *CLASSLOADER*)) (JSTATIC "addUrl" +LISP-CLASS+ CLASSLOADER URL))
     [java]
     [java] ; Caught STYLE-WARNING:
     [java] ;   Undefined variable +LISP-CLASS+ assumed special
     [java]
     [java] ; (DEFUN ADD-URLS-TO-CLASSPATH (&REST URLS) (DOLIST (URL URLS) (ADD-URL-TO-CLASSPATH URL)))
     [java] ; (DEFGENERIC ADD-TO-CLASSPATH (JAR-OR-JARS &OPTIONAL CLASSLOADER) (:DOCUMENTATION "Add JAR-OR-JARS to the JVM classpath optionally specifying the CLASSLOADER to add.
     [java]
     [java] JAR-OR-JARS is either a pathname designating a jar archive or the root
     [java] directory to search for classes or a list of such values."))
     [java] ; (DEFMETHOD ADD-TO-CLASSPATH (JAR-OR-JARS &OPTIONAL (CLASSLOADER (GET-CURRENT-CLASSLOADER))) (%ADD-TO-CLASSPATH JAR-OR-JARS CLASSLOADER))
     [java] ; (DEFUN JREGISTER-HANDLER (OBJECT EVENT HANDLER &KEY DATA COUNT) (%JREGISTER-HANDLER OBJECT EVENT HANDLER DATA COUNT))
     [java] ; (DEFUN JINTERFACE-IMPLEMENTATION (INTERFACE &REST METHOD-NAMES-AND-DEFS) "Creates and returns an implementation of a Java interface with
     [java]    methods calling Lisp closures as given in METHOD-NAMES-AND-DEFS.
     [java]
     [java]    INTERFACE is either a Java interface or a string naming one.
     [java]
     [java]    METHOD-NAMES-AND-DEFS is an alternating list of method names
     [java]    (strings) and method definitions (closures).
     [java]
     [java]    For missing methods, a dummy implementation is provided that
     [java]    returns nothing or null depending on whether the return type is
     [java]    void or not. This is for convenience only, and a warning is issued
     [java]    for each undefined method." (LET ((INTERFACE (JCLASS INTERFACE)) (IMPLEMENTED-METHODS (LOOP FOR M IN METHOD-NAMES-AND-DEFS FOR I FROM 0 IF (EVENP I) DO (ASSERT (STRINGP M) (M) "Method names must be strings: ~s" M) AND COLLECT M ELSE DO (ASSERT (OR (SYMBOLP M) (FUNCTIONP M)) (M) "Methods must be function designators: ~s" M)))) (LOOP FOR METHOD ACROSS (JCLASS-METHODS INTERFACE :DECLARED NIL :PUBLIC T) FOR METHOD-NAME = (JMETHOD-NAME METHOD) WHEN (NOT (MEMBER METHOD-NAME IMPLEMENTED-METHODS :TEST (FUNCTION STRING=))) DO (LET* ((VOID-P (STRING= (JCLASS-NAME (JMETHOD-RETURN-TYPE METHOD)) "void")) (ARGLIST (WHEN (PLUSP (LENGTH (JMETHOD-PARAMS METHOD))) (QUOTE (&REST IGNORE)))) (DEF (SYSTEM::BACKQ-LIST (QUOTE LAMBDA) ARGLIST (WHEN ARGLIST (QUOTE (DECLARE (IGNORE IGNORE)))) (IF VOID-P (QUOTE (VALUES)) +NULL+)))) (WARN "Implementing dummy method ~a for interface ~a" METHOD-NAME (JCLASS-NAME INTERFACE)) (PUSH (COERCE DEF (QUOTE FUNCTION)) METHOD-NAMES-AND-DEFS) (PUSH METHOD-NAME METHOD-NAMES-AND-DEFS))) (APPLY (FUNCTION %JNEW-PROXY) INTERFACE METHOD-NAMES-AND-DEFS)))
     [java] ; (DEFUN JMAKE-INVOCATION-HANDLER (FUNCTION) (%JMAKE-INVOCATION-HANDLER FUNCTION))
     [java] ; (WHEN (AUTOLOADP (QUOTE JMAKE-PROXY)) (FMAKUNBOUND (QUOTE JMAKE-PROXY)))
     [java] ; (DEFGENERIC JMAKE-PROXY (INTERFACE IMPLEMENTATION &OPTIONAL LISP-THIS) (:DOCUMENTATION "Returns a proxy Java object implementing the provided interface(s) using methods implemented in Lisp - typically closures, but implementations are free to provide other mechanisms. You can pass an optional 'lisp-this' object that will be passed to the implementing methods as their first argument. If you don't provide this object, NIL will be used. The second argument of the Lisp methods is the name of the Java method being implemented. This has the implication that overloaded methods are merged, so you have to manually discriminate them if you want to. The remaining arguments are java-objects wrapping the method's parameters."))
     [java] ; (DEFUN CANONICALIZE-JPROXY-INTERFACES (IFACES) (IF (LISTP IFACES) (MAPCAR (FUNCTION JCLASS) IFACES) (LIST (JCLASS IFACES))))
     [java] ; (DEFMETHOD JMAKE-PROXY (INTERFACE INVOCATION-HANDLER &OPTIONAL LISP-THIS) "Basic implementation that directly uses an invocation handler." (%JMAKE-PROXY (CANONICALIZE-JPROXY-INTERFACES INTERFACE) INVOCATION-HANDLER LISP-THIS))
     [java] ; (DEFMETHOD JMAKE-PROXY (INTERFACE (IMPLEMENTATION FUNCTION) &OPTIONAL LISP-THIS) "Implements a Java interface forwarding method calls to a Lisp function." (%JMAKE-PROXY (CANONICALIZE-JPROXY-INTERFACES INTERFACE) (JMAKE-INVOCATION-HANDLER IMPLEMENTATION) LISP-THIS))
     [java] ; (DEFMETHOD JMAKE-PROXY (INTERFACE (IMPLEMENTATION PACKAGE) &OPTIONAL LISP-THIS) "Implements a Java interface mapping Java method names to symbols in a given package. javaMethodName is mapped to a JAVA-METHOD-NAME symbol. An error is signaled if no such symbol exists in the package, or if the symbol exists but does not name a function." (FLET ((JAVA->LISP (NAME) (WITH-OUTPUT-TO-STRING (STR) (LET ((LAST-LOWER-P NIL)) (MAP NIL (LAMBDA (CHAR) (LET ((UPPER-P (CHAR= (CHAR-UPCASE CHAR) CHAR))) (WHEN (AND LAST-LOWER-P UPPER-P) (PRINC "-" STR)) (SETF LAST-LOWER-P (NOT UPPER-P)) (PRINC (CHAR-UPCASE CHAR) STR))) NAME))))) (%JMAKE-PROXY (CANONICALIZE-JPROXY-INTERFACES INTERFACE) (JMAKE-INVOCATION-HANDLER (LAMBDA (OBJ METHOD &REST ARGS) (LET ((SYM (FIND-SYMBOL (JAVA->LISP METHOD) IMPLEMENTATION))) (UNLESS SYM (ERROR "Symbol ~A, implementation of method ~A, not found in ~A" (JAVA->LISP METHOD) METHOD IMPLEMENTATION)) (IF (FBOUNDP SYM) (APPLY (SYMBOL-FUNCTION SYM) OBJ METHOD ARGS) (ERROR "Function ~A, implementation of method ~A, not found in ~A" SYM METHOD IMPLEMENTATION))))) LISP-THIS)))
     [java] ; (DEFMETHOD JMAKE-PROXY (INTERFACE (IMPLEMENTATION HASH-TABLE) &OPTIONAL LISP-THIS) "Implements a Java interface using closures in an hash-table keyed by Java method name." (%JMAKE-PROXY (CANONICALIZE-JPROXY-INTERFACES INTERFACE) (JMAKE-INVOCATION-HANDLER (LAMBDA (OBJ METHOD &REST ARGS) (LET ((FN (GETHASH METHOD IMPLEMENTATION))) (IF FN (APPLY FN OBJ ARGS) (ERROR "Implementation for method ~A not found in ~A" METHOD IMPLEMENTATION))))) LISP-THIS))
     [java] ; (DEFUN JEQUAL (OBJ1 OBJ2) "Compares obj1 with obj2 using java.lang.Object.equals()" (JCALL (JMETHOD "java.lang.Object" "equals" "java.lang.Object") OBJ1 OBJ2))
     [java] ; (DEFUN JOBJECT-CLASS (OBJ) "Returns the Java class that OBJ belongs to" (JCALL (JMETHOD "java.lang.Object" "getClass") OBJ))
     [java] ; (DEFUN JCLASS-SUPERCLASS (CLASS) "Returns the superclass of CLASS, or NIL if it hasn't got one" (JCALL (JMETHOD "java.lang.Class" "getSuperclass") (JCLASS CLASS)))
     [java] ; (DEFUN JCLASS-INTERFACES (CLASS) "Returns the vector of interfaces of CLASS" (JCALL (JMETHOD "java.lang.Class" "getInterfaces") (JCLASS CLASS)))
     [java] ; (DEFUN JCLASS-INTERFACE-P (CLASS) "Returns T if CLASS is an interface" (JCALL (JMETHOD "java.lang.Class" "isInterface") (JCLASS CLASS)))
     [java] ; (DEFUN JCLASS-SUPERCLASS-P (CLASS-1 CLASS-2) "Returns T if CLASS-1 is a superclass or interface of CLASS-2" (JCALL (JMETHOD "java.lang.Class" "isAssignableFrom" "java.lang.Class") (JCLASS CLASS-1) (JCLASS CLASS-2)))
     [java] ; (DEFUN JCLASS-ARRAY-P (CLASS) "Returns T if CLASS is an array class" (JCALL (JMETHOD "java.lang.Class" "isArray") (JCLASS CLASS)))
     [java] ; (DEFUN JARRAY-COMPONENT-TYPE (ATYPE) "Returns the component type of the array type ATYPE" (ASSERT (JCLASS-ARRAY-P ATYPE)) (JCALL (JMETHOD "java.lang.Class" "getComponentType") ATYPE))
     [java] ; (DEFUN JARRAY-LENGTH (JAVA-ARRAY) "Returns the length of a Java primitive array." (JSTATIC "getLength" "java.lang.reflect.Array" JAVA-ARRAY))
     [java] ; (DEFUN (SETF JARRAY-REF) (NEW-VALUE JAVA-ARRAY &REST INDICES) (APPLY (FUNCTION JARRAY-SET) JAVA-ARRAY NEW-VALUE INDICES))
     [java] ; (DEFUN JNEW-ARRAY-FROM-ARRAY (ELEMENT-TYPE ARRAY) "Returns a new Java array with base type ELEMENT-TYPE (a string or a class-ref)
     [java]    initialized from ARRAY." (FLET ((ROW-MAJOR-TO-INDEX (DIMENSIONS N) (LOOP FOR DIMS ON DIMENSIONS WITH INDICES DO (MULTIPLE-VALUE-BIND (M R) (FLOOR N (APPLY (FUNCTION *) (CDR DIMS))) (PUSH M INDICES) (SETQ N R)) FINALLY (RETURN (NREVERSE INDICES))))) (LET* ((FILL-POINTER (WHEN (ARRAY-HAS-FILL-POINTER-P ARRAY) (FILL-POINTER ARRAY))) (DIMENSIONS (IF FILL-POINTER (LIST FILL-POINTER) (ARRAY-DIMENSIONS ARRAY))) (JARRAY (APPLY (FUNCTION JNEW-ARRAY) ELEMENT-TYPE DIMENSIONS))) (DOTIMES (I (IF FILL-POINTER FILL-POINTER (ARRAY-TOTAL-SIZE ARRAY)) JARRAY) (APPLY (FUNCTION (SETF JARRAY-REF)) (ROW-MAJOR-AREF ARRAY I) JARRAY (ROW-MAJOR-TO-INDEX DIMENSIONS I))))))
     [java] ; (DEFUN JNEW-ARRAY-FROM-LIST (ELEMENT-TYPE LIST) "Returns a new Java array with base type ELEMENT-TYPE (a string or a class-ref)
     [java]    initialized from a Lisp list." (LET ((JARRAY (JNEW-ARRAY ELEMENT-TYPE (LENGTH LIST))) (I 0)) (DOLIST (X LIST) (SETF (JARRAY-REF JARRAY I) X I (1+ I))) JARRAY))
     [java] ; (DEFUN JARRAY-FROM-LIST (LIST) "Return a Java array from LIST whose type is inferred from the first element.
     [java]
     [java] For more control over the type of the array, use JNEW-ARRAY-FROM-LIST." (JNEW-ARRAY-FROM-LIST (JOBJECT-CLASS (FIRST LIST)) LIST))
     [java] ; (DEFUN LIST-FROM-JARRAY (JARRAY) "Returns a list with the elements of `jarray`." (LOOP FOR I FROM 0 BELOW (JARRAY-LENGTH JARRAY) COLLECT (JARRAY-REF JARRAY I)))
     [java] ; (DEFUN VECTOR-FROM-JARRAY (JARRAY) "Returns a vector with the elements of `jarray`." (LOOP WITH VEC = (MAKE-ARRAY (JARRAY-LENGTH JARRAY)) FOR I FROM 0 BELOW (JARRAY-LENGTH JARRAY) DO (SETF (AREF VEC I) (JARRAY-REF JARRAY I)) FINALLY (RETURN VEC)))
     [java] ; (DEFUN LIST-FROM-JENUMERATION (JENUMERATION) "Returns a list with the elements returned by successive `nextElement`
     [java] calls on the java.util.Enumeration `jenumeration`." (LOOP WHILE (JCALL JENUMERATION (JMETHOD "java.util.Enumeration" "hasMoreElements")) COLLECT (JCALL JENUMERATION (JMETHOD "java.util.Enumeration" "nextElement"))))
     [java] ; (DEFUN JCLASS-CONSTRUCTORS (CLASS) "Returns a vector of constructors for CLASS" (JCALL (JMETHOD "java.lang.Class" "getConstructors") (JCLASS CLASS)))
     [java] ; (DEFUN JCONSTRUCTOR-PARAMS (CONSTRUCTOR) "Returns a vector of parameter types (Java classes) for CONSTRUCTOR" (JCALL (JMETHOD "java.lang.reflect.Constructor" "getParameterTypes") CONSTRUCTOR))
     [java] ; (DEFUN JCLASS-FIELDS (CLASS &KEY DECLARED PUBLIC) "Returns a vector of all (or just the declared/public, if DECLARED/PUBLIC is true) fields of CLASS" (LET* ((GETTER (IF DECLARED "getDeclaredFields" "getFields")) (FIELDS (JCALL (JMETHOD "java.lang.Class" GETTER) (JCLASS CLASS)))) (IF PUBLIC (DELETE-IF-NOT (FUNCTION JMEMBER-PUBLIC-P) FIELDS) FIELDS)))
     [java] ; (DEFUN JCLASS-FIELD (CLASS FIELD-NAME) "Returns the field named FIELD-NAME of CLASS" (JCALL (JMETHOD "java.lang.Class" "getField" "java.lang.String") (JCLASS CLASS) FIELD-NAME))
     [java] ; (DEFUN JFIELD-TYPE (FIELD) "Returns the type (Java class) of FIELD" (JCALL (JMETHOD "java.lang.reflect.Field" "getType") FIELD))
     [java] ; (DEFUN JFIELD-NAME (FIELD) "Returns the name of FIELD as a Lisp string" (JCALL (JMETHOD "java.lang.reflect.Field" "getName") FIELD))
     [java] ; (DEFUN (SETF JFIELD) (NEWVALUE CLASS-REF-OR-FIELD FIELD-OR-INSTANCE &OPTIONAL (INSTANCE NIL INSTANCE-SUPPLIED-P) UNUSED-VALUE) (DECLARE (IGNORE UNUSED-VALUE)) (IF INSTANCE-SUPPLIED-P (JFIELD CLASS-REF-OR-FIELD FIELD-OR-INSTANCE INSTANCE NEWVALUE) (JFIELD CLASS-REF-OR-FIELD FIELD-OR-INSTANCE NIL NEWVALUE)))
     [java] ; (DEFUN JCLASS-METHODS (CLASS &KEY DECLARED PUBLIC) "Return a vector of all (or just the declared/public, if DECLARED/PUBLIC is true) methods of CLASS" (LET* ((GETTER (IF DECLARED "getDeclaredMethods" "getMethods")) (METHODS (JCALL (JMETHOD "java.lang.Class" GETTER) (JCLASS CLASS)))) (IF PUBLIC (DELETE-IF-NOT (FUNCTION JMEMBER-PUBLIC-P) METHODS) METHODS)))
     [java] ; (DEFUN JMETHOD-PARAMS (METHOD) "Returns a vector of parameter types (Java classes) for METHOD" (JCALL (JMETHOD "java.lang.reflect.Method" "getParameterTypes") METHOD))
     [java] ; (DEFUN JMETHOD-RETURN-TYPE (METHOD) "Returns the result type (Java class) of the METHOD" (JCALL (JMETHOD "java.lang.reflect.Method" "getReturnType") METHOD))
     [java] ; (DEFUN JMETHOD-DECLARING-CLASS (METHOD) "Returns the Java class declaring METHOD" (JCALL (JMETHOD "java.lang.reflect.Method" "getDeclaringClass") METHOD))
     [java] ; (DEFUN JMETHOD-NAME (METHOD) "Returns the name of METHOD as a Lisp string" (JCALL (JMETHOD "java.lang.reflect.Method" "getName") METHOD))
     [java] ; (DEFUN JINSTANCE-OF-P (OBJ CLASS) "OBJ is an instance of CLASS (or one of its subclasses)" (AND (JAVA-OBJECT-P OBJ) (JCALL (JMETHOD "java.lang.Class" "isInstance" "java.lang.Object") (JCLASS CLASS) OBJ)))
     [java] ; (DEFUN JMEMBER-STATIC-P (MEMBER) "MEMBER is a static member of its declaring class" (JSTATIC (JMETHOD "java.lang.reflect.Modifier" "isStatic" "int") "java.lang.reflect.Modifier" (JCALL (JMETHOD "java.lang.reflect.Member" "getModifiers") MEMBER)))
     [java] ; (DEFUN JMEMBER-PUBLIC-P (MEMBER) "MEMBER is a public member of its declaring class" (JSTATIC (JMETHOD "java.lang.reflect.Modifier" "isPublic" "int") "java.lang.reflect.Modifier" (JCALL (JMETHOD "java.lang.reflect.Member" "getModifiers") MEMBER)))
     [java] ; (DEFUN JMEMBER-PROTECTED-P (MEMBER) "MEMBER is a protected member of its declaring class" (JSTATIC (JMETHOD "java.lang.reflect.Modifier" "isProtected" "int") "java.lang.reflect.Modifier" (JCALL (JMETHOD "java.lang.reflect.Member" "getModifiers") MEMBER)))
     [java] ; (DEFMETHOD MAKE-LOAD-FORM ((OBJECT JAVA-OBJECT) &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (LET ((CLASS-NAME (JCLASS-NAME (JCLASS-OF OBJECT)))) (COND ((STRING= CLASS-NAME "java.lang.reflect.Constructor") (SYSTEM::BACKQ-LIST* (QUOTE JCONSTRUCTOR) (JCLASS-NAME (JCALL (JMETHOD "java.lang.reflect.Constructor" "getDeclaringClass") OBJECT)) (LOOP FOR ARG-TYPE ACROSS (JCALL (JMETHOD "java.lang.reflect.Constructor" "getParameterTypes") OBJECT) COLLECTING (JCLASS-NAME ARG-TYPE)))) ((STRING= CLASS-NAME "java.lang.reflect.Method") (SYSTEM::BACKQ-LIST* (QUOTE JMETHOD) (JCLASS-NAME (JCALL (JMETHOD "java.lang.reflect.Method" "getDeclaringClass") OBJECT)) (JMETHOD-NAME OBJECT) (LOOP FOR ARG-TYPE ACROSS (JCALL (JMETHOD "java.lang.reflect.Method" "getParameterTypes") OBJECT) COLLECTING (JCLASS-NAME ARG-TYPE)))) ((STRING= CLASS-NAME "java.lang.reflect.Field") (SYSTEM::BACKQ-LIST* (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE FIELD) (SYSTEM::BACKQ-LIST* (QUOTE FIND) (JCALL "getName" OBJECT) (SYSTEM::BACKQ-LIST (QUOTE JCALL) "getDeclaredFields" (JCALL "getDeclaringClass" OBJECT)) (QUOTE (:KEY (LAMBDA (EL) (JCALL "getName" EL)) :TEST (QUOTE EQUAL)))))) (QUOTE ((JCALL "setAccessible" FIELD T) FIELD)))) ((JINSTANCE-OF-P OBJECT "java.lang.Class") (SYSTEM::BACKQ-LIST (QUOTE JCLASS) (JCALL (JMETHOD "java.lang.Class" "getName") OBJECT))) (T (ERROR "Unknown load-form for ~A" CLASS-NAME)))))
     [java] ; (DEFUN JPROPERTY-VALUE (OBJECT PROPERTY) "setf-able access on the Java Beans notion of property named PROPETRY on OBJECT." (%JGET-PROPERTY-VALUE OBJECT PROPERTY))
     [java] ; (DEFUN (SETF JPROPERTY-VALUE) (VALUE OBJ PROP) (%JSET-PROPERTY-VALUE OBJ PROP VALUE))
     [java] ; (DEFMACRO CHAIN (TARGET OP &REST OPS) "Performs chained method invocations.
     [java]
     [java] TARGET is either the receiver object when the first call is a virtual method
     [java] call or a list in the form (:static <jclass>) when the first method
     [java] call is a static method call.
     [java]
     [java] OP and each of the OPS are either method designators or lists in the
     [java] form (<method designator> &rest args), where a method designator is
     [java] either a string naming a method, or a jmethod object. CHAIN will
     [java] perform the method call specified by OP on TARGET; then, for each
     [java] of the OPS, CHAIN will perform the specified method call using the
     [java] object returned by the previous method call as the receiver, and will
     [java] ultimately return the result of the last method call.  For example,
     [java] the form:
     [java]
     [java]   (chain (:static \"java.lang.Runtime\") \"getRuntime\" (\"exec\" \"ls\"))
     [java]
     [java]   is equivalent to the following Java code:
     [java]
     [java]   java.lang.Runtime.getRuntime().exec(\"ls\");" (LABELS ((CANONICALIZE-OP (OP) (IF (LISTP OP) OP (LIST OP))) (COMPOSE-ARGLIST (TARGET OP) (SYSTEM::BACKQ-LIST* (CAR OP) TARGET (CDR OP))) (MAKE-BINDING-FOR (FORM) (SYSTEM::BACKQ-LIST (GENSYM) FORM)) (MAKE-BINDING (BINDINGS NEXT-OP &AUX (TARGET (CAAR BINDINGS))) (CONS (MAKE-BINDING-FOR (SYSTEM::BACKQ-CONS (QUOTE JCALL) (COMPOSE-ARGLIST TARGET (CANONICALIZE-OP NEXT-OP)))) BINDINGS))) (LET* ((FIRST (IF (AND (CONSP TARGET) (EQ (FIRST TARGET) :STATIC)) (SYSTEM::BACKQ-CONS (QUOTE JSTATIC) (COMPOSE-ARGLIST (CADR TARGET) (CANONICALIZE-OP OP))) (SYSTEM::BACKQ-CONS (QUOTE JCALL) (COMPOSE-ARGLIST TARGET (CANONICALIZE-OP OP))))) (BINDINGS (NREVERSE (REDUCE (FUNCTION MAKE-BINDING) OPS :INITIAL-VALUE (LIST (MAKE-BINDING-FOR FIRST)))))) (SYSTEM::BACKQ-LIST (QUOTE LET*) BINDINGS (SYSTEM::BACKQ-LIST (QUOTE DECLARE) (SYSTEM::BACKQ-CONS (QUOTE IGNORE) (BUTLAST (MAPCAR (FUNCTION CAR) BINDINGS)))) (CAAR (LAST BINDINGS))))))
     [java] ; (DEFMACRO JMETHOD-LET (BINDINGS &BODY BODY) (LET ((ARGS (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (MAPCAR (LAMBDA (BINDING) (SYSTEM::BACKQ-LIST (CAR BINDING) (SYSTEM::BACKQ-CONS (QUOTE JMETHOD) (CDR BINDING)))) BINDINGS) (SYSTEM::BACKQ-LIST* (QUOTE MACROLET) (MAPCAR (LAMBDA (BINDING) (SYSTEM::BACKQ-LIST (CAR BINDING) (SYSTEM::BACKQ-LIST (QUOTE &REST) ARGS) (SYSTEM::BACKQ-LIST (QUOTE SYSTEM::BACKQ-LIST*) (QUOTE (QUOTE JCALL)) (CAR BINDING) ARGS))) BINDINGS) BODY))))
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJ JAVA-OBJECT) STREAM) (IF (JNULL-REF-P OBJ) (WRITE-STRING "#<null>" STREAM) (PRINT-JAVA-OBJECT-BY-CLASS (INTERN (JCLASS-NAME (JOBJECT-CLASS OBJ)) (QUOTE KEYWORD)) OBJ STREAM)))
     [java] ; (DEFMETHOD PRINT-JAVA-OBJECT-BY-CLASS :AROUND (CLASS OBJ STREAM) (HANDLER-BIND ((JAVA-EXCEPTION (FUNCTION (LAMBDA (C) (FORMAT STREAM "#<~a, while printing a ~a>" (JCALL "toString" (JAVA-EXCEPTION-CAUSE C)) (JCALL "getName" (JCALL "getClass" OBJ))) (RETURN-FROM PRINT-JAVA-OBJECT-BY-CLASS))))) (CALL-NEXT-METHOD)))
     [java] ; (DEFMETHOD PRINT-JAVA-OBJECT-BY-CLASS (CLASS OBJ STREAM) (LOOP FOR SUPER = CLASS THEN (JCLASS-SUPERCLASS SUPER) FOR KEYWORD = (INTERN (JCALL "getName" SUPER) (QUOTE KEYWORD)) FOR METHOD = (FIND-METHOD (FUNCTION PRINT-JAVA-OBJECT-BY-CLASS) NIL (LIST (SYSTEM::BACKQ-LIST (QUOTE EQL) KEYWORD) T T) NIL) WHILE (JCLASS-SUPERCLASS SUPER) WHEN METHOD DO (RETURN-FROM PRINT-JAVA-OBJECT-BY-CLASS (PRINT-JAVA-OBJECT-BY-CLASS KEYWORD OBJ STREAM))) (WRITE-STRING (SYSTEM::%WRITE-TO-STRING OBJ) STREAM))
     [java] ; (DEFMETHOD PRINT-OBJECT ((E JAVA-EXCEPTION) STREAM) (HANDLER-BIND ((JAVA-EXCEPTION (FUNCTION (LAMBDA (C) (FORMAT STREAM "#<~a,while printing a ~a>" (JCALL "toString" (JAVA-EXCEPTION-CAUSE C)) (JCALL "getName" (JCALL "getClass" E))) (RETURN-FROM PRINT-OBJECT))))) (IF *PRINT-ESCAPE* (PRINT-UNREADABLE-OBJECT (E STREAM :TYPE T :IDENTITY T) (FORMAT STREAM "~A" (JCALL (JMETHOD "java.lang.Object" "toString") (JAVA-EXCEPTION-CAUSE E)))) (FORMAT STREAM "Java exception '~A'." (JCALL (JMETHOD "java.lang.Object" "toString") (JAVA-EXCEPTION-CAUSE E))))))
     [java] ; (DEFCONSTANT +JAVA-LANG-OBJECT+ (JCLASS "java.lang.Object"))
     [java] ; (DEFCLASS JAVA-CLASS (STANDARD-CLASS) ((JCLASS :INITARG :JAVA-CLASS :INITFORM (ERROR "class is required") :READER JAVA-CLASS-JCLASS)))
     [java] ; (DEFMETHOD MOP:VALIDATE-SUPERCLASS ((CLASS JAVA-CLASS) (SUPERCLASS BUILT-IN-CLASS)) T)
     [java] ; (DEFCONSTANT +JAVA-LANG-OBJECT-CLASS+ (%REGISTER-JAVA-CLASS +JAVA-LANG-OBJECT+ (MOP:ENSURE-CLASS (MAKE-SYMBOL "java.lang.Object") :METACLASS (FIND-CLASS (QUOTE JAVA-CLASS)) :DIRECT-SUPERCLASSES (LIST (FIND-CLASS (QUOTE JAVA-OBJECT))) :JAVA-CLASS +JAVA-LANG-OBJECT+)))
     [java] ; (DEFUN JCLASS-ADDITIONAL-SUPERCLASSES (JCLASS) "Extension point to put additional CLOS classes on the CPL of a CLOS Java class." (LET ((SUPERS NIL)) (WHEN (JCLASS-INTERFACE-P JCLASS) (PUSH (FIND-CLASS (QUOTE JAVA-OBJECT)) SUPERS)) SUPERS))
     [java] ; (DEFUN ENSURE-JAVA-CLASS (JCLASS) "Attempt to ensure that the Java class referenced by JCLASS exists in the current process of the implementation." (LET ((CLASS (%FIND-JAVA-CLASS JCLASS))) (IF CLASS CLASS (%REGISTER-JAVA-CLASS JCLASS (MOP:ENSURE-CLASS (MAKE-SYMBOL (JCLASS-NAME JCLASS)) :METACLASS (FIND-CLASS (QUOTE JAVA-CLASS)) :DIRECT-SUPERCLASSES (LET ((SUPERS (MAPCAR (FUNCTION ENSURE-JAVA-CLASS) (DELETE NIL (CONCATENATE (QUOTE LIST) (LIST (JCLASS-SUPERCLASS JCLASS)) (JCLASS-INTERFACES JCLASS)))))) (APPEND SUPERS (JCLASS-ADDITIONAL-SUPERCLASSES JCLASS))) :JAVA-CLASS JCLASS)))))
     [java] ; (DEFMETHOD MOP:COMPUTE-CLASS-PRECEDENCE-LIST ((CLASS JAVA-CLASS)) "Sort classes this way:
     [java]    1. Java classes (but not java.lang.Object)
     [java]    2. Java interfaces
     [java]    3. java.lang.Object
     [java]    4. other classes
     [java]    Rationale:
     [java]    1. Concrete classes are the most specific.
     [java]    2. Then come interfaces.
     [java]      So if a generic function is specialized both on an interface and a concrete class,
     [java]      the concrete class comes first.
     [java]    3. because everything is an Object.
     [java]    4. to handle base CLOS classes.
     [java]    Note: Java interfaces are not sorted among themselves in any way, so if a
     [java]    gf is specialized on two different interfaces and you apply it to an object that
     [java]    implements both, it is unspecified which method will be called." (LET ((CPL (NREVERSE (MOP::COLLECT-SUPERCLASSES* CLASS)))) (FLET ((SCORE (CLASS) (IF (NOT (TYPEP CLASS (QUOTE JAVA-CLASS))) 4 (COND ((JCALL (JMETHOD "java.lang.Object" "equals" "java.lang.Object") (JAVA-CLASS-JCLASS CLASS) +JAVA-LANG-OBJECT+) 3) ((JCLASS-INTERFACE-P (JAVA-CLASS-JCLASS CLASS)) 2) (T 1))))) (STABLE-SORT CPL (FUNCTION (LAMBDA (X Y) (< (SCORE X) (SCORE Y))))))))
     [java] ; (DEFMETHOD MAKE-INSTANCE ((CLASS JAVA-CLASS) &REST INITARGS &KEY &ALLOW-OTHER-KEYS) (DECLARE (IGNORE INITARGS)) (ERROR "make-instance not supported for ~S" CLASS))
     [java] ; (DEFUN JINPUT-STREAM (PATHNAME) "Returns a java.io.InputStream for resource denoted by PATHNAME." (SYSTEM:ENSURE-INPUT-STREAM PATHNAME))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/java.abcl (1.94 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/java-collections.lisp ...
     [java] ; (IN-PACKAGE :JAVA)
     [java] ; (LET* ((JCLASS (JCLASS "java.util.List")) (CLASS (%FIND-JAVA-CLASS JCLASS))) (IF CLASS (ERROR "java.util.List is already registered as a Lisp class; since JAVA-CLASSes can't be redefined, I can't inject SEQUENCE in its class precedence list. Ensure that you require :java-collections before specializing any method on java.util.List and in general before using java.util.List as a CLOS class.") (%REGISTER-JAVA-CLASS JCLASS (MOP:ENSURE-CLASS (MAKE-SYMBOL (JCLASS-NAME JCLASS)) :METACLASS (FIND-CLASS (QUOTE JAVA-CLASS)) :DIRECT-SUPERCLASSES (LET ((SUPERS (MAPCAR (FUNCTION ENSURE-JAVA-CLASS) (DELETE NIL (CONCATENATE (QUOTE LIST) (LIST (JCLASS-SUPERCLASS JCLASS)) (JCLASS-INTERFACES JCLASS)))))) (APPEND SUPERS (LIST (FIND-CLASS (QUOTE SEQUENCE))) (JCLASS-ADDITIONAL-SUPERCLASSES JCLASS))) :JAVA-CLASS JCLASS))))
     [java] ; (DEFMETHOD PRINT-OBJECT ((COLL (JCLASS "java.util.Collection")) STREAM) (PRINT-UNREADABLE-OBJECT (COLL STREAM :TYPE T :IDENTITY T) (FORMAT STREAM "~A ~A" (JCLASS-OF COLL) (JCALL "toString" COLL))))
     [java] ; (DEFUN JLIST-ADD (LIST ITEM) (JCALL (JMETHOD "java.util.List" "add" "java.lang.Object") LIST ITEM))
     [java] ; (DEFUN JLIST-SET (LIST INDEX ITEM) (JCALL (JMETHOD "java.util.List" "set" "int" "java.lang.Object") LIST INDEX ITEM))
     [java] ; (DEFUN JLIST-GET (LIST INDEX) (JCALL (JMETHOD "java.util.List" "get" "int") LIST INDEX))
     [java] ; (DEFMETHOD SEQUENCE:LENGTH ((S (JCLASS "java.util.List"))) (JCALL (JMETHOD "java.util.Collection" "size") S))
     [java] ; (DEFMETHOD SEQUENCE:ELT ((S (JCLASS "java.util.List")) INDEX) (JLIST-GET S INDEX))
     [java] ; (DEFMETHOD (SETF SEQUENCE:ELT) (VALUE (LIST (JCLASS "java.util.List")) INDEX) (JLIST-SET LIST INDEX VALUE) VALUE)
     [java] ; (DEFMETHOD SEQUENCE:MAKE-SEQUENCE-LIKE ((S (JCLASS "java.util.List")) LENGTH &REST ARGS &KEY INITIAL-ELEMENT INITIAL-CONTENTS) (DECLARE (IGNORABLE INITIAL-ELEMENT INITIAL-CONTENTS)) (APPLY (FUNCTION MAKE-JSEQUENCE-LIKE) S LENGTH (FUNCTION JLIST-ADD) ARGS))
     [java] ; (DEFUN MAKE-JSEQUENCE-LIKE (S LENGTH ADD-FN &KEY (INITIAL-ELEMENT NIL IEP) (INITIAL-CONTENTS NIL ICP)) (LET ((SEQ (JNEW (JCLASS-OF S)))) (COND ((AND ICP IEP) (ERROR "Can't specify both :initial-element and :initial-contents")) (ICP (DOTIMES (I LENGTH) (FUNCALL ADD-FN SEQ (ELT INITIAL-CONTENTS I)))) (T (DOTIMES (I LENGTH) (FUNCALL ADD-FN SEQ INITIAL-ELEMENT)))) SEQ))
     [java] ; (DEFSTRUCT (JLIST-ITERATOR (:TYPE LIST) (:CONC-NAME #:JLIST-IT-)) (NATIVE-ITERATOR (ERROR "Native iterator required") :READ-ONLY T) ELEMENT INDEX)
     [java] ; (DEFMETHOD SEQUENCE:MAKE-SIMPLE-SEQUENCE-ITERATOR ((S (JCLASS "java.util.List")) &KEY FROM-END (START 0) END) (LET* ((END (OR END (LENGTH S))) (INDEX (IF FROM-END END START)) (IT (JCALL "listIterator" S INDEX)) (ITER (MAKE-JLIST-ITERATOR :NATIVE-ITERATOR IT :INDEX (IF FROM-END (1+ INDEX) (1- INDEX)))) (LIMIT (IF FROM-END (1+ START) (1- END)))) (UNLESS (SEQUENCE:ITERATOR-ENDP S ITER LIMIT FROM-END) (SEQUENCE:ITERATOR-STEP S ITER FROM-END)) (VALUES ITER LIMIT FROM-END)))
     [java] ; (DEFMETHOD SEQUENCE:ITERATOR-STEP ((S (JCLASS "java.util.Collection")) IT FROM-END) (LET ((NATIVE-IT (JLIST-IT-NATIVE-ITERATOR IT))) (IF FROM-END (PROGN (SETF (JLIST-IT-ELEMENT IT) (WHEN (JCALL "hasPrevious" NATIVE-IT) (JCALL "previous" NATIVE-IT))) (DECF (JLIST-IT-INDEX IT))) (PROGN (SETF (JLIST-IT-ELEMENT IT) (WHEN (JCALL "hasNext" NATIVE-IT) (JCALL "next" NATIVE-IT))) (INCF (JLIST-IT-INDEX IT))))) IT)
     [java] ; (DEFMETHOD SEQUENCE:ITERATOR-ENDP ((S (JCLASS "java.util.Collection")) IT LIMIT FROM-END) (IF FROM-END (< (JLIST-IT-INDEX IT) LIMIT) (> (JLIST-IT-INDEX IT) LIMIT)))
     [java] ; (DEFMETHOD SEQUENCE:ITERATOR-ELEMENT ((S (JCLASS "java.util.Collection")) ITERATOR) (DECLARE (IGNORE S)) (JLIST-IT-ELEMENT ITERATOR))
     [java] ; (DEFMETHOD (SETF SEQUENCE:ITERATOR-ELEMENT) (NEW-VALUE (S (JCLASS "java.util.Collection")) IT) (JCALL "set" (JLIST-IT-NATIVE-ITERATOR IT) NEW-VALUE))
     [java] ; (DEFMETHOD SEQUENCE:ITERATOR-INDEX ((S (JCLASS "java.util.Collection")) ITERATOR) (DECLARE (IGNORE S)) (JLIST-IT-INDEX ITERATOR))
     [java] ; (DEFMETHOD SEQUENCE:ITERATOR-COPY ((S (JCLASS "java.util.Collection")) ITERATOR) (DECLARE (IGNORE S ITERATOR)) (ERROR "iterator-copy not supported for Java iterators."))
     [java] ; (DEFUN JSET-ADD (SET ITEM) (JCALL (JMETHOD "java.util.Set" "add" "java.lang.Object") SET ITEM))
     [java] ; (DEFMETHOD SEQUENCE:LENGTH ((S (JCLASS "java.util.Set"))) (JCALL (JMETHOD "java.util.Collection" "size") S))
     [java] ; (DEFMETHOD SEQUENCE:MAKE-SEQUENCE-LIKE ((S (JCLASS "java.util.Set")) LENGTH &REST ARGS &KEY INITIAL-ELEMENT INITIAL-CONTENTS) (DECLARE (IGNORABLE INITIAL-ELEMENT INITIAL-CONTENTS)) (APPLY (FUNCTION MAKE-JSEQUENCE-LIKE) S LENGTH (FUNCTION JSET-ADD) ARGS))
     [java] ; (DEFMETHOD SEQUENCE:MAKE-SIMPLE-SEQUENCE-ITERATOR ((S (JCLASS "java.util.Set")) &KEY FROM-END (START 0) END) (WHEN (OR FROM-END (NOT (= START 0))) (ERROR "Java Sets can only be iterated from the start.")) (LET* ((END (OR END (LENGTH S))) (IT (JCALL "iterator" S)) (ITER (MAKE-JLIST-ITERATOR :NATIVE-ITERATOR IT :INDEX -1)) (LIMIT (1- END))) (UNLESS (SEQUENCE:ITERATOR-ENDP S ITER LIMIT NIL) (SEQUENCE:ITERATOR-STEP S ITER NIL)) (VALUES ITER LIMIT NIL)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/java-collections.abcl (0.756 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-functions.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFKNOWN (COPY-SYMBOL GENSYM FDEFINITION-BLOCK-NAME) * SYMBOL)
     [java] ; (DEFKNOWN GETHASH1 (T T) T)
     [java] ; (DEFKNOWN MAKE-KEYWORD (T) SYMBOL)
     [java] ; (DEFKNOWN (BACKQ-LIST BACKQ-LIST* BACKQ-APPEND BACKQ-NCONC %CLASS-PRECEDENCE-LIST) * LIST)
     [java] ; (DEFKNOWN BACKQ-CONS * CONS)
     [java] ; (DEFKNOWN (CHAR-DOWNCASE CHAR-UPCASE) (CHARACTER) CHARACTER)
     [java] ; (DEFKNOWN (FINISH-OUTPUT FORCE-OUTPUT CLEAR-OUTPUT TERPRI FRESH-LINE) * T)
     [java] ; (DEFKNOWN SYMBOL-NAME (SYMBOL) STRING)
     [java] ; (DEFKNOWN (GET-OUTPUT-STREAM-STRING NSTRING-CAPITALIZE NSTRING-DOWNCASE NSTRING-UPCASE STRING-CAPITALIZE STRING-DOWNCASE STRING-UPCASE WRITE-LINE WRITE-STRING) * STRING)
     [java] ; (DEFKNOWN (%FAILED-AVER %LDB %MAKE-STRUCTURE %METHOD-FUNCTION PUT %SET-CDDR %STREAM-TERPRI %STREAM-WRITE-CHAR ALPHANUMERICP ARRAY-HAS-FILL-POINTER-P ASET BIT-AND BIT-ANDC1 BIT-ANDC2 BIT-EQV BIT-IOR BIT-NAND BIT-NOR BIT-NOT BIT-ORC1 BIT-ORC2 BIT-XOR BOTH-CASE-P BUILT-IN-FUNCTION-P CAADR CHAR-EQUAL CHARACTERP CHARPOS CLOSE COERCE COERCE-TO-FUNCTION COMPILE-FILE-PATHNAME COMPLEX CONJUGATE COUNT COUNT-IF COUNT-IF-NOT DELETE-FILE DIRECTORY-NAMESTRING EIGHTH ENOUGH-NAMESTRING EVERY FIFTH FILE-DIRECTORY-P FILE-NAMESTRING FILE-POSITION FILL FIRST FLOAT FMAKUNBOUND FOURTH FSET FTYPE-RESULT-TYPE GET-INTERNAL-REAL-TIME GETF HASH-TABLE-COUNT HASH-TABLE-P HOST-NAMESTRING INTERSECTION LDB LDB-TEST LIST-ALL-PACKAGES LIST-FIND* LOAD-COMPILED-FUNCTION LOWER-CASE-P MAKE-STRING-OUTPUT-STREAM MAKE-STRUCTURE MAP MERGE-PATHNAMES NAMESTRING NEQ NINTERSECTION NINTH NORMALIZE-TYPE NSUBST NSUBST-IF NSUBST-IF-NOT NTH PATHNAME-TYPE PATHNAME-TYPE PATHNAMEP PHASE PROBE-FILE PROCLAIMED-FTYPE RANDOM READ READ-CHAR READ-SEQUENCE REDUCE REPLACE REST SCALE-FLOAT SEARCH SECOND SET SET-CHAR SET-SCHAR SET-STD-SLOT-VALUE SETF-FUNCTION-NAME-P SEVENTH SIMPLE-CONDITION-FORMAT-ARGUMENTS SIMPLE-CONDITION-FORMAT-CONTROL SIMPLE-SEARCH SIXTH SOME SORT STABLE-SORT STANDARD-OBJECT-P STD-INSTANCE-LAYOUT STD-SLOT-VALUE STREAM-ELEMENT-TYPE STREAM-LINE-NUMBER STRING-FIND STRING<= STRUCTURE-OBJECT-P STRUCTURE-REF STRUCTURE-SET SUBST SUBST-IF SUBST-IF-NOT SVREF SVSET TENTH THIRD TRUENAME UPPER-CASE-P VECTOR VECTOR-FIND* VECTORP WRITE-BYTE WRITE-SEQUENCE ZEROP) * T)
     [java] ; (DEFKNOWN LENGTH (SEQUENCE) (INTEGER 0 2147483646))
     [java] ; (DEFKNOWN (DEPOSIT-FIELD DPB LOGAND LOGCOUNT LOGNOR MASK-FIELD NUMERATOR DENOMINATOR BOOLE ARRAY-DIMENSION ARRAY-ROW-MAJOR-INDEX ARRAY-RANK ARRAY-TOTAL-SIZE %DPB ASH) * INTEGER)
     [java] ; (DEFKNOWN SXHASH (T) (INTEGER 0 2147483647))
     [java] ; (DEFKNOWN CHAR-CODE (CHARACTER) (UNSIGNED-BYTE 16))
     [java] ; (DEFKNOWN SCHAR (SIMPLE-STRING INDEX) CHARACTER)
     [java] ; (DEFKNOWN (CHAR WRITE-CHAR) * CHARACTER)
     [java] ; (DEFKNOWN (CHAR= CHAR/= CHAR< CHAR> CHAR<= CHAR>= CHAR-EQUAL CHAR-NOT-EQUAL CHAR-LESSP CHAR-GREATERP CHAR-NOT-GREATERP CHAR-NOT-LESSP) * T)
     [java] ; (DEFKNOWN (MOD REM) (REAL REAL) REAL)
     [java] ; (DEFKNOWN (RATIONAL RATIONALIZE) (NUMBER) RATIONAL)
     [java] ; (DEFKNOWN (BIT SBIT) * BIT)
     [java] ; (DEFKNOWN MAKE-MACRO * FUNCTION)
     [java] ; (DEFKNOWN %SET-ARGLIST * T)
     [java] ; (DEFKNOWN (%TYPE-ERROR CHECK-SEQUENCE-BOUNDS) * T)
     [java] ; (DEFKNOWN OUT-SYNONYM-OF * T)
     [java] ; (DEFKNOWN (ERROR COMPILER-STYLE-WARN COMPILER-WARN COMPILER-ERROR COMPILER-UNSUPPORTED) * T)
     [java] ; (DEFKNOWN RESOLVE (SYMBOL) FUNCTION)
     [java] ; (DEFKNOWN %SET-CHAR (STRING INDEX CHARACTER) CHARACTER)
     [java] ; (DEFKNOWN SET-FUNCTION-INFO-VALUE (T T T) T)
     [java] ; (DEFKNOWN MAKE-HASH-TABLE * HASH-TABLE)
     [java] ; (DEFKNOWN %CLASS-SLOTS (CLASS) T)
     [java] ; (DEFKNOWN SET-CLASS-SLOTS (CLASS LIST) T)
     [java] ; (DEFKNOWN %SLOT-DEFINITION-INITFUNCTION * T)
     [java] ; (DEFKNOWN STD-SLOT-BOUNDP * T)
     [java] ; (DEFKNOWN STD-SLOT-VALUE * T)
     [java] ; (DEFKNOWN SET-STD-SLOT-VALUE * T)
     [java] ; (DEFKNOWN OPEN * (OR STREAM NULL))
     [java] ; (DEFKNOWN MAKE-STRING-INPUT-STREAM * STREAM)
     [java] ; (DEFKNOWN (ARRAYP ATOM CONSP ENDP EVENP FLOATP INTEGERP LISTP MINUSP NUMBERP ODDP PACKAGEP PLUSP RATIONALP READTABLEP REALP SIMPLE-BIT-VECTOR-P SIMPLE-VECTOR-P STRINGP SYMBOLP ZEROP) (T) BOOLEAN)
     [java] ; (DEFKNOWN (CONSTANTP SIMPLE-TYPEP TYPEP %TYPEP) * BOOLEAN)
     [java] ; (DEFKNOWN (/= < <= = > >= EQ EQL EQUAL EQUALP) * BOOLEAN)
     [java] ; (DEFKNOWN (BIT-VECTOR-P COMPILED-FUNCTION-P COMPLEXP FBOUNDP FUNCTIONP KEYWORDP SIMPLE-STRING-P TYPEP) (T) T)
     [java] ; (DEFKNOWN (BOUNDP SPECIAL-OPERATOR-P SPECIAL-VARIABLE-P) (SYMBOL) T)
     [java] ; (DEFKNOWN (+ - * / 1+ 1- CAR CDR CAAR CADR CDAR CDDR CADAR CADDR CDDDR CDDDDR FIRST SECOND THIRD LIST LIST* MACRO-FUNCTION COMPILER-MACRO-FUNCTION %DEFUN GET FDEFINITION ARRAY-DIMENSIONS ARRAY-RANK ARRAY-TOTAL-SIZE ARRAY-ELEMENT-TYPE UPGRADED-ARRAY-ELEMENT-TYPE ROW-MAJOR-AREF QUOTE FUNCTION MAP MAPCAR FIND POSITION APPEND NCONC SUBSEQ ADJOIN REVAPPEND NRECONC COPY-SEQ ASSOC ASSOC-IF ASSOC-IF-NOT ACONS ASSQ ASSQL CHAR-INT DIGIT-CHAR-P MEMBER MEMQ REMOVE REMOVE-IF REMOVE-IF-NOT DELETE DELETE-IF DELETE-IF-NOT SYMBOL-FUNCTION COERCE REVERSE NREVERSE LAST CONS RPLACA RPLACD SET-CAR SET-CDR COPY-LIST COPY-TREE MAKE-SEQUENCE MAKE-LIST MAKE-ARRAY MAKE-PACKAGE FIND-PACKAGE PATHNAME MAKE-PATHNAME PATHNAME-NAME DIRECTORY PACKAGE-USED-BY-LIST PACKAGE-SHADOWING-SYMBOLS NTHCDR AREF ELT NOT NULL CONCATENATE FORMAT %FORMAT PRIN1 PRINC PRINT WRITE COMPUTE-RESTARTS FIND-RESTART RESTART-NAME STRING STRING= SETQ MULTIPLE-VALUE-LIST PUSH POP TYPE-OF CLASS-OF ABS FLOAT-RADIX LOGAND LOGANDC1 LOGANDC2 LOGEQV LOGIOR LOGNAND LOGNOT LOGORC1 LOGORC2 LOGXOR LOGBITP SLOT-BOUNDP SLOT-VALUE SLOT-EXISTS-P ALLOCATE-INSTANCE FIND-CLASS CLASS-NAME CONSTANTLY EXP EXPT LOG MIN MAX REALPART IMAGPART INTEGER-LENGTH SQRT ISQRT GCD LCM SIGNUM OPEN SVREF FILL-POINTER SYMBOL-VALUE SYMBOL-PACKAGE PACKAGE-NAME FOURTH VECTOR-PUSH VECTOR-PUSH-EXTEND UNION NUNION REMOVE-DUPLICATES DELETE-DUPLICATES READ-BYTE FRESH-LINE TERPRI LAMBDA CLASSP FIXNUMP MEMQL PUTHASH PRECOMPILER::PRECOMPILE1 DECLARE GO INST EMIT LABEL MAYBE-EMIT-CLEAR-VALUES SINGLE-VALUED-P READ-8-BITS WRITE-8-BITS REQUIRE-TYPE ARG-COUNT-ERROR SUBCLASSP CACHE-EMF GET-CACHED-EMF AUTOLOADP PROCLAIM-FTYPE-1 PROCLAIM-FTYPE) * T)
     [java] ; (DEFKNOWN MAKE-STRING * SIMPLE-STRING)
     [java] ; (DEFKNOWN CONCATENATE-TO-STRING * SIMPLE-STRING)
     [java] ; (DEFKNOWN CODE-CHAR * (OR CHARACTER NULL))
     [java] ; (DEFKNOWN LOOKUP-KNOWN-SYMBOL (SYMBOL) T)
     [java] ; (DEFKNOWN %CLASS-NAME (CLASS) SYMBOL)
     [java] ; (DEFKNOWN ADJOIN-EQL (T T) LIST)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/known-functions.abcl (0.075 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/known-symbols.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (LET ((SYMBOLS (MAKE-HASH-TABLE :TEST (QUOTE EQ) :SIZE 2048))) (DEFUN INITIALIZE-KNOWN-SYMBOLS (SOURCE HT) (LET* ((SOURCE-CLASS (JAVA:JCLASS SOURCE)) (CLASS-DESIGNATOR (JVM::MAKE-JVM-CLASS-NAME SOURCE)) (SYMBOL-CLASS (JAVA:JCLASS "org.armedbear.lisp.Symbol")) (FIELDS (JAVA:JCLASS-FIELDS SOURCE-CLASS :DECLARED T :PUBLIC T))) (DOTIMES (I (LENGTH FIELDS)) (LET* ((FIELD (AREF FIELDS I)) (TYPE (JAVA:JFIELD-TYPE FIELD))) (WHEN (EQUAL TYPE SYMBOL-CLASS) (LET* ((NAME (JAVA:JFIELD-NAME FIELD)) (SYMBOL (JAVA:JFIELD SOURCE-CLASS NAME))) (PUTHASH SYMBOL HT (LIST NAME CLASS-DESIGNATOR))))))) (HASH-TABLE-COUNT HT)) (INITIALIZE-KNOWN-SYMBOLS "org.armedbear.lisp.Symbol" SYMBOLS) (INITIALIZE-KNOWN-SYMBOLS "org.armedbear.lisp.Keyword" SYMBOLS) (INITIALIZE-KNOWN-SYMBOLS "org.armedbear.lisp.Lisp" SYMBOLS) (INITIALIZE-KNOWN-SYMBOLS "org.armedbear.lisp.Nil" SYMBOLS) (DEFUN LOOKUP-KNOWN-SYMBOL (SYMBOL) "Returns the name of the field and its class designator
     [java] which stores the Java object `symbol'." (VALUES-LIST (GETHASH1 SYMBOL SYMBOLS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/known-symbols.abcl (0.1 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/late-setf.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DEFINE-SETF-EXPANDER (ACCESS-FN LAMBDA-LIST &BODY BODY) (REQUIRE-TYPE ACCESS-FN (QUOTE SYMBOL)) (LET ((WHOLE (GENSYM "WHOLE-")) (ENVIRONMENT (GENSYM "ENV-"))) (MULTIPLE-VALUE-BIND (BODY LOCAL-DECS DOC) (PARSE-DEFMACRO LAMBDA-LIST WHOLE BODY ACCESS-FN (QUOTE DEFINE-SETF-EXPANDER) :ENVIRONMENT ENVIRONMENT) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST* (QUOTE RECORD-SOURCE-INFORMATION-FOR-TYPE) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN) (QUOTE (:SETF-EXPANDER))) (BACKQ-LIST* (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (BACKQ-APPEND (WHEN DOC (BACKQ-LIST (BACKQ-LIST (QUOTE %SET-DOCUMENTATION) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN) (QUOTE (QUOTE SETF)) DOC))) (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST* (QUOTE GET) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN) (QUOTE ((QUOTE SETF-EXPANDER)))) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST* (QUOTE LAMBDA) (BACKQ-LIST WHOLE ENVIRONMENT) (BACKQ-APPEND LOCAL-DECS (BACKQ-LIST (BACKQ-LIST (QUOTE BLOCK) ACCESS-FN BODY)))))) (BACKQ-LIST (QUOTE QUOTE) ACCESS-FN))))))))
     [java] ; (DEFINE-SETF-EXPANDER VALUES (&REST PLACES &ENVIRONMENT ENV) (LET ((SETTERS NIL) (GETTERS NIL) (ALL-DUMMIES NIL) (ALL-VALS NIL) (NEWVALS NIL)) (DOLIST (PLACE PLACES) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (SETF ALL-DUMMIES (APPEND ALL-DUMMIES DUMMIES (CDR NEWVAL)) ALL-VALS (APPEND ALL-VALS VALS (MAPCAR (CONSTANTLY NIL) (CDR NEWVAL))) NEWVALS (APPEND NEWVALS (LIST (CAR NEWVAL)))) (PUSH SETTER SETTERS) (PUSH GETTER GETTERS))) (VALUES ALL-DUMMIES ALL-VALS NEWVALS (BACKQ-CONS (QUOTE VALUES) (REVERSE SETTERS)) (BACKQ-CONS (QUOTE VALUES) (REVERSE GETTERS)))))
     [java] ; (DEFUN MAKE-GENSYM-LIST (N) (LET ((LIST NIL)) (DOTIMES (I N LIST) (PUSH (GENSYM) LIST))))
     [java] ; (DEFINE-SETF-EXPANDER GETF (PLACE PROP &OPTIONAL DEFAULT &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (TEMPS VALUES STORES SET GET) (GET-SETF-EXPANSION PLACE ENV) (LET ((NEWVAL (GENSYM)) (PTEMP (GENSYM)) (DEF-TEMP (IF DEFAULT (GENSYM)))) (VALUES (BACKQ-APPEND TEMPS (BACKQ-CONS PTEMP (IF DEFAULT (BACKQ-LIST DEF-TEMP)))) (BACKQ-APPEND VALUES (BACKQ-CONS PROP (IF DEFAULT (BACKQ-LIST DEFAULT)))) (BACKQ-LIST NEWVAL) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAR STORES) (BACKQ-LIST (QUOTE %PUTF) GET PTEMP NEWVAL))) SET NEWVAL) (BACKQ-LIST* (QUOTE GETF) GET PTEMP (IF DEFAULT (BACKQ-LIST DEF-TEMP)))))))
     [java] ; (DEFINE-SETF-EXPANDER APPLY (FUNCTIONOID &REST ARGS) (LET ((FUNCTION (SECOND FUNCTIONOID)) (NEW-VAR (GENSYM)) (VARS (MAKE-GENSYM-LIST (LENGTH ARGS)))) (VALUES VARS ARGS (LIST NEW-VAR) (BACKQ-LIST* (QUOTE APPLY) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE SETF) FUNCTION)) NEW-VAR VARS) (BACKQ-LIST* (QUOTE APPLY) (BACKQ-LIST (QUOTE FUNCTION) FUNCTION) VARS))))
     [java] ; (DEFINE-SETF-EXPANDER THE (TYPE PLACE &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (TEMPS SUBFORMS STORE-VARS SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (VALUES TEMPS SUBFORMS STORE-VARS (BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) STORE-VARS (BACKQ-LIST (QUOTE THE) TYPE (BACKQ-CONS (QUOTE VALUES) STORE-VARS)) SETTER) (BACKQ-LIST (QUOTE THE) TYPE GETTER))))
     [java] ; (DEFUN (SETF MACRO-FUNCTION) (NEW-FUNCTION SYMBOL &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (LET ((MACRO (MAKE-MACRO SYMBOL (OR (PRECOMPILE NIL NEW-FUNCTION) NEW-FUNCTION)))) (FSET SYMBOL MACRO) MACRO))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/late-setf.abcl (0.154 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/lcm.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN TWO-ARG-LCM (N M) (COND ((ZEROP N) 0) ((ZEROP M) 0) (T (/ (ABS (* N M)) (GCD N M)))))
     [java] ; (DEFUN LCM (&REST INTEGERS) (UNLESS (EVERY (FUNCTION INTEGERP) INTEGERS) (ERROR (QUOTE TYPE-ERROR) :DATUM (FIND-IF-NOT (FUNCTION INTEGERP) INTEGERS) :EXPECTED-TYPE (QUOTE INTEGER))) (CASE (LENGTH INTEGERS) (0 1) (1 (ABS (CAR INTEGERS))) (2 (TWO-ARG-LCM (CAR INTEGERS) (CADR INTEGERS))) (T (DO ((RESULT (CAR INTEGERS) (TWO-ARG-LCM RESULT (CAR REST))) (REST (CDR INTEGERS) (CDR REST))) ((NULL REST) RESULT)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/lcm.abcl (0.074 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/ldiff.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LDIFF (LIST OBJECT) (REQUIRE-TYPE LIST (QUOTE LIST)) (DO* ((LIST LIST (CDR LIST)) (RESULT (LIST NIL)) (SPLICE RESULT)) ((ATOM LIST) (IF (EQL LIST OBJECT) (CDR RESULT) (PROGN (RPLACD SPLICE LIST) (CDR RESULT)))) (IF (EQL LIST OBJECT) (RETURN (CDR RESULT)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR LIST))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/ldiff.abcl (0.041 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/list-length.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LIST-LENGTH (LIST) (DO ((N 0 (+ N 2)) (Y LIST (CDDR Y)) (Z LIST (CDR Z))) (NIL) (WHEN (ENDP Y) (RETURN N)) (WHEN (ENDP (CDR Y)) (RETURN (+ N 1))) (WHEN (AND (EQ Y Z) (> N 0)) (RETURN NIL))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/list-length.abcl (0.066 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/list.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN FIFTH (LIST) (CAR (CDDDDR LIST)))
     [java] ; (DEFUN SIXTH (LIST) (CADR (CDDDDR LIST)))
     [java] ; (DEFUN SEVENTH (LIST) (CADDR (CDDDDR LIST)))
     [java] ; (DEFUN EIGHTH (LIST) (CADDDR (CDDDDR LIST)))
     [java] ; (DEFUN NINTH (LIST) (CAR (CDDDDR (CDDDDR LIST))))
     [java] ; (DEFUN TENTH (LIST) (CADR (CDDDDR (CDDDDR LIST))))
     [java] ; (DEFUN MAKE-LIST (SIZE &KEY INITIAL-ELEMENT) (%MAKE-LIST SIZE INITIAL-ELEMENT))
     [java] ; (DEFMACRO APPLY-KEY (KEY ELEMENT) (BACKQ-LIST (QUOTE IF) KEY (BACKQ-LIST (QUOTE FUNCALL) KEY ELEMENT) ELEMENT))
     [java] ; (DEFUN COMPLEMENT (F) (FUNCTION (LAMBDA (&REST X) (NOT (APPLY F X)))))
     [java] ; (DEFUN CONSTANTLY (X) (FUNCTION (LAMBDA (&REST ARGS) (DECLARE (IGNORE ARGS)) X)))
     [java] ; (DEFUN MEMBER (ITEM LIST &KEY KEY TEST TEST-NOT) (%MEMBER ITEM LIST KEY TEST TEST-NOT))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/list.abcl (0.257 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/load.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LOAD (FILESPEC &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*) (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT)) (LET (*FASL-LOADER*) (%LOAD (IF (STREAMP FILESPEC) FILESPEC (MERGE-PATHNAMES (PATHNAME FILESPEC))) VERBOSE PRINT IF-DOES-NOT-EXIST EXTERNAL-FORMAT)))
     [java] ; (DEFUN LOAD-RETURNING-LAST-RESULT (FILESPEC &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*) (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT)) (LET (*FASL-LOADER*) (%LOAD-RETURNING-LAST-RESULT (IF (STREAMP FILESPEC) FILESPEC (MERGE-PATHNAMES (PATHNAME FILESPEC))) VERBOSE PRINT IF-DOES-NOT-EXIST EXTERNAL-FORMAT)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/load.abcl (0.069 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/make-hash-table.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN MAKE-HASH-TABLE (&KEY (TEST (QUOTE EQL)) (SIZE 11) (REHASH-SIZE 1.5f0) (REHASH-THRESHOLD 0.75f0) (WEAKNESS NIL)) (SETF TEST (COERCE-TO-FUNCTION TEST)) (UNLESS (AND (INTEGERP SIZE) (>= SIZE 0)) (ERROR (QUOTE TYPE-ERROR) :DATUM SIZE :EXPECTED-TYPE (QUOTE (INTEGER 0)))) (LET ((SIZE (MAX 11 (MIN SIZE ARRAY-DIMENSION-LIMIT))) (WEAKNESS-TYPES (QUOTE (OR (EQL :KEY) (EQL :VALUE) (EQL :KEY-AND-VALUE) (EQL :KEY-OR-VALUE))))) (IF WEAKNESS (IF (NOT (TYPEP WEAKNESS WEAKNESS-TYPES)) (ERROR (QUOTE TYPE-ERROR) :DATUM WEAKNESS :EXPECTED-TYPE WEAKNESS-TYPES) (%MAKE-WEAK-HASH-TABLE TEST SIZE REHASH-SIZE REHASH-THRESHOLD WEAKNESS)) (%MAKE-HASH-TABLE TEST SIZE REHASH-SIZE REHASH-THRESHOLD))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/make-hash-table.abcl (0.065 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/make-load-form-saving-slots.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (RESOLVE (QUOTE DEFSTRUCT))
     [java] ; (DEFUN MAKE-LOAD-FORM-SAVING-SLOTS (OBJECT &KEY SLOT-NAMES ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (LET ((CLASS (CLASS-OF OBJECT)) (INITS NIL) (INSTANCE (GENSYM "INSTANCE-"))) (COND ((TYPEP OBJECT (QUOTE STRUCTURE-OBJECT)) (LET ((INDEX 0)) (DOLIST (SLOT (MOP:CLASS-SLOTS CLASS)) (LET ((SLOT-NAME (DSD-NAME SLOT))) (WHEN (OR (MEMQ SLOT-NAME SLOT-NAMES) (NULL SLOT-NAMES)) (LET ((VALUE (STRUCTURE-REF OBJECT INDEX))) (PUSH (BACKQ-LIST (QUOTE STRUCTURE-SET) INSTANCE INDEX (BACKQ-LIST (QUOTE QUOTE) VALUE)) INITS)))) (INCF INDEX)))) ((TYPEP OBJECT (QUOTE STANDARD-OBJECT)) (DOLIST (SLOT (MOP:CLASS-SLOTS CLASS)) (LET ((SLOT-NAME (MOP:SLOT-DEFINITION-NAME SLOT))) (WHEN (OR (MEMQ SLOT-NAME SLOT-NAMES) (NULL SLOT-NAMES)) (WHEN (SLOT-BOUNDP OBJECT SLOT-NAME) (LET ((VALUE (SLOT-VALUE OBJECT SLOT-NAME))) (PUSH (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE SLOT-VALUE) INSTANCE (BACKQ-LIST (QUOTE QUOTE) SLOT-NAME)) (BACKQ-LIST (QUOTE QUOTE) VALUE)) INITS)))))))) (VALUES (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST INSTANCE (BACKQ-LIST (QUOTE ALLOCATE-INSTANCE) (BACKQ-LIST (QUOTE FIND-CLASS) (BACKQ-LIST (QUOTE QUOTE) (%CLASS-NAME CLASS)))))) (BACKQ-CONS (QUOTE PROGN) INITS) INSTANCE) NIL)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/make-load-form-saving-slots.abcl (0.073 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/make-sequence.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN SIZE-MISMATCH-ERROR (TYPE SIZE) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "The requested length (~D) does not match the specified type ~A." :FORMAT-ARGUMENTS (LIST SIZE TYPE)))
     [java] ; (DEFUN MAKE-SEQUENCE (TYPE SIZE &KEY (INITIAL-ELEMENT NIL IESP)) "Returns a sequence of SIZE elements, of type TYPE.
     [java] Each element is set to INITIAL-ELEMENT.
     [java] TYPE must be equivalent to either LIST or some sort of ARRAY.
     [java] If the value is a list, it is completely cdr-coded." (LET (ELEMENT-TYPE SEQUENCE CLASS) (SETF TYPE (NORMALIZE-TYPE TYPE)) (COND ((ATOM TYPE) (SETF CLASS (IF (CLASSP TYPE) TYPE (FIND-CLASS TYPE NIL))) (WHEN (CLASSP TYPE) (LET ((CLASS-NAME (%CLASS-NAME TYPE))) (WHEN (MEMBER CLASS-NAME (QUOTE (LIST CONS STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING NULL BIT-VECTOR SIMPLE-BIT-VECTOR VECTOR SIMPLE-VECTOR))) (SETF TYPE CLASS-NAME)))) (COND ((MEMQ TYPE (QUOTE (LIST CONS))) (WHEN (ZEROP SIZE) (IF (EQ TYPE (QUOTE CONS)) (SIZE-MISMATCH-ERROR TYPE SIZE) (RETURN-FROM MAKE-SEQUENCE NIL))) (RETURN-FROM MAKE-SEQUENCE (IF IESP (MAKE-LIST SIZE :INITIAL-ELEMENT INITIAL-ELEMENT) (MAKE-LIST SIZE)))) ((MEMQ TYPE (QUOTE (STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING))) (RETURN-FROM MAKE-SEQUENCE (IF IESP (MAKE-STRING SIZE :INITIAL-ELEMENT INITIAL-ELEMENT) (MAKE-STRING SIZE)))) ((EQ TYPE (QUOTE NULL)) (IF (ZEROP SIZE) (RETURN-FROM MAKE-SEQUENCE NIL) (SIZE-MISMATCH-ERROR TYPE SIZE))) (T (SETQ ELEMENT-TYPE (COND ((MEMQ TYPE (QUOTE (BIT-VECTOR SIMPLE-BIT-VECTOR))) (QUOTE BIT)) ((MEMQ TYPE (QUOTE (VECTOR SIMPLE-VECTOR))) T) ((NULL CLASS) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "~S is not a sequence type." :FORMAT-ARGUMENTS (LIST TYPE)))))))) (T (LET ((NAME (%CAR TYPE)) (ARGS (%CDR TYPE))) (WHEN (EQ NAME (QUOTE LIST)) (RETURN-FROM MAKE-SEQUENCE (IF IESP (MAKE-LIST SIZE :INITIAL-ELEMENT INITIAL-ELEMENT) (MAKE-LIST SIZE)))) (WHEN (EQ NAME (QUOTE CONS)) (UNLESS (PLUSP SIZE) (SIZE-MISMATCH-ERROR NAME SIZE)) (RETURN-FROM MAKE-SEQUENCE (IF IESP (MAKE-LIST SIZE :INITIAL-ELEMENT INITIAL-ELEMENT) (MAKE-LIST SIZE)))) (UNLESS (MEMQ NAME (QUOTE (ARRAY SIMPLE-ARRAY VECTOR SIMPLE-VECTOR BIT-VECTOR SIMPLE-BIT-VECTOR STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING))) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "~S is not a sequence type." :FORMAT-ARGUMENTS (LIST TYPE))) (LET ((LEN NIL)) (COND ((MEMQ NAME (QUOTE (STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING))) (SETF ELEMENT-TYPE (QUOTE CHARACTER) LEN (CAR ARGS))) ((MEMQ NAME (QUOTE (ARRAY SIMPLE-ARRAY))) (SETF ELEMENT-TYPE (OR (CAR ARGS) T) LEN (IF (CONSP (CADR ARGS)) (CAADR ARGS) (QUOTE *)))) ((MEMQ NAME (QUOTE (BIT-VECTOR SIMPLE-BIT-VECTOR))) (SETF ELEMENT-TYPE (QUOTE BIT) LEN (CAR ARGS))) (T (SETF ELEMENT-TYPE (OR (CAR ARGS) T) LEN (CADR ARGS)))) (UNLESS (OR (NULL LEN) (EQ LEN (QUOTE *)) (EQUAL LEN (QUOTE (*)))) (WHEN (/= SIZE LEN) (SIZE-MISMATCH-ERROR TYPE SIZE))))))) (SETQ SEQUENCE (COND ((OR (NOT (ATOM TYPE)) (SUBTYPEP TYPE (QUOTE ARRAY))) (IF IESP (MAKE-ARRAY SIZE :ELEMENT-TYPE ELEMENT-TYPE :INITIAL-ELEMENT INITIAL-ELEMENT) (MAKE-ARRAY SIZE :ELEMENT-TYPE ELEMENT-TYPE))) ((AND CLASS (SUBTYPEP TYPE (QUOTE SEQUENCE))) (IF IESP (SEQUENCE:MAKE-SEQUENCE-LIKE (MOP:CLASS-PROTOTYPE CLASS) SIZE :INITIAL-ELEMENT INITIAL-ELEMENT) (SEQUENCE:MAKE-SEQUENCE-LIKE (MOP:CLASS-PROTOTYPE CLASS) SIZE))) (T (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "~S is not a sequence type." :FORMAT-ARGUMENTS (LIST TYPE))))) SEQUENCE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/make-sequence.abcl (0.122 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/make-string-output-stream.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN MAKE-STRING-OUTPUT-STREAM (&KEY (ELEMENT-TYPE (QUOTE CHARACTER))) (%MAKE-STRING-OUTPUT-STREAM ELEMENT-TYPE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/make-string-output-stream.abcl (0.055 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/make-string.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN MAKE-STRING (SIZE &KEY INITIAL-ELEMENT ELEMENT-TYPE) (%MAKE-STRING SIZE INITIAL-ELEMENT ELEMENT-TYPE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/make-string.abcl (0.044 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/map-into.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFUN MAP-INTO (RESULT-SEQUENCE FUNCTION &REST SEQUENCES) (LET* ((FP-RESULT (AND (ARRAYP RESULT-SEQUENCE) (ARRAY-HAS-FILL-POINTER-P RESULT-SEQUENCE))) (LEN (APPLY (FUNCTION MIN) (IF FP-RESULT (ARRAY-DIMENSION RESULT-SEQUENCE 0) (LENGTH RESULT-SEQUENCE)) (MAPCAR (FUNCTION LENGTH) SEQUENCES)))) (WHEN FP-RESULT (SETF (FILL-POINTER RESULT-SEQUENCE) LEN)) (DOTIMES (INDEX LEN) (SETF (ELT RESULT-SEQUENCE INDEX) (APPLY FUNCTION (MAPCAR (FUNCTION (LAMBDA (SEQ) (ELT SEQ INDEX))) SEQUENCES))))) RESULT-SEQUENCE)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/map-into.abcl (0.081 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/map.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN MAP (RESULT-TYPE FUNCTION SEQUENCE &REST MORE-SEQUENCES) (LET* ((SEQUENCES (CONS SEQUENCE MORE-SEQUENCES)) (LIMIT (APPLY (FUNCTION MIN) (MAPCAR (FUNCTION LENGTH) SEQUENCES)))) (DECLARE (TYPE INDEX LIMIT)) (COND ((NULL RESULT-TYPE) (DOTIMES (I LIMIT NIL) (APPLY FUNCTION (MAPCAR (FUNCTION (LAMBDA (Z) (ELT Z I))) SEQUENCES)))) ((EQ RESULT-TYPE (QUOTE LIST)) (LET (RESULT) (DOTIMES (I LIMIT (NREVERSE RESULT)) (PUSH (APPLY FUNCTION (MAPCAR (FUNCTION (LAMBDA (Z) (ELT-SAFE Z I))) SEQUENCES)) RESULT)))) (T (LET ((RESULT (CASE RESULT-TYPE (STRING (MAKE-STRING LIMIT)) (VECTOR (MAKE-ARRAY LIMIT)) (T (MAKE-SEQUENCE RESULT-TYPE LIMIT))))) (DOTIMES (I LIMIT RESULT) (SETF (ELT RESULT I) (APPLY FUNCTION (MAPCAR (FUNCTION (LAMBDA (Z) (ELT Z I))) SEQUENCES)))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/map.abcl (0.113 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/map1.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN MAP1 (FUNCTION ORIGINAL-ARGLISTS ACCUMULATE TAKE-CAR) (LET* ((ARGLISTS (COPY-LIST ORIGINAL-ARGLISTS)) (RET-LIST (LIST NIL)) (TEMP RET-LIST)) (DO ((RES NIL) (ARGS (QUOTE NIL) (QUOTE NIL))) ((DOLIST (X ARGLISTS NIL) (IF (NULL X) (RETURN T))) (IF ACCUMULATE (CDR RET-LIST) (CAR ORIGINAL-ARGLISTS))) (DO ((L ARGLISTS (CDR L))) ((NULL L)) (PUSH (IF TAKE-CAR (CAAR L) (CAR L)) ARGS) (SETF (CAR L) (CDAR L))) (SETQ RES (APPLY FUNCTION (NREVERSE ARGS))) (CASE ACCUMULATE (:NCONC (SETQ TEMP (LAST (NCONC TEMP RES)))) (:LIST (RPLACD TEMP (LIST RES)) (SETQ TEMP (CDR TEMP)))))))
     [java] ; (DEFUN MAPCAN (FUNCTION LIST &REST MORE-LISTS) (MAP1 FUNCTION (CONS LIST MORE-LISTS) :NCONC T))
     [java] ; (DEFUN MAPL (FUNCTION LIST &REST MORE-LISTS) (MAP1 FUNCTION (CONS LIST MORE-LISTS) NIL NIL))
     [java] ; (DEFUN MAPLIST (FUNCTION LIST &REST MORE-LISTS) (MAP1 FUNCTION (CONS LIST MORE-LISTS) :LIST NIL))
     [java] ; (DEFUN MAPCON (FUNCTION LIST &REST MORE-LISTS) (MAP1 FUNCTION (CONS LIST MORE-LISTS) :NCONC NIL))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/map1.abcl (0.119 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/mask-field.lisp ...
     [java] ; (DEFUN MASK-FIELD (BYTESPEC INTEGER) (LET ((SIZE (BYTE-SIZE BYTESPEC)) (POS (BYTE-POSITION BYTESPEC))) (LOGAND INTEGER (ASH (1- (ASH 1 SIZE)) POS))))
     [java] ; (DEFINE-SETF-EXPANDER MASK-FIELD (BYTESPEC PLACE &ENVIRONMENT ENV) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (LET ((BTEMP (GENSYM)) (GNUVAL (GENSYM))) (VALUES (CONS BTEMP DUMMIES) (CONS BYTESPEC VALS) (LIST GNUVAL) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (CAR NEWVAL) (SYSTEM::BACKQ-LIST (QUOTE DEPOSIT-FIELD) GNUVAL BTEMP GETTER))) SETTER GNUVAL) (SYSTEM::BACKQ-LIST (QUOTE MASK-FIELD) BTEMP GETTER)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/mask-field.abcl (0.061 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/member-if.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN MEMBER-IF (TEST LIST &KEY KEY) (DO ((LIST LIST (CDR LIST))) ((ENDP LIST) NIL) (IF (FUNCALL TEST (APPLY-KEY KEY (CAR LIST))) (RETURN LIST))))
     [java] ; (DEFUN MEMBER-IF-NOT (TEST LIST &KEY KEY) (DO ((LIST LIST (CDR LIST))) ((ENDP LIST) NIL) (IF (NOT (FUNCALL TEST (APPLY-KEY KEY (CAR LIST)))) (RETURN LIST))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/member-if.abcl (0.104 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/mismatch.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFUN BAD-SEQ-LIMIT (X &OPTIONAL Y) (ERROR "bad sequence limit ~a" (IF Y (LIST X Y) X)))
     [java] ; (DEFUN THE-END (X Y) (COND ((EXTENSIONS:FIXNUMP X) (UNLESS (<= X (LENGTH Y)) (BAD-SEQ-LIMIT X)) X) ((NULL X) (LENGTH Y)) (T (BAD-SEQ-LIMIT X))))
     [java] ; (DEFUN THE-START (X) (COND ((EXTENSIONS:FIXNUMP X) (UNLESS (>= X 0) (BAD-SEQ-LIMIT X)) X) ((NULL X) 0) (T (BAD-SEQ-LIMIT X))))
     [java] ; (DEFMACRO WITH-START-END (START END SEQ &BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE LET*) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST START (SYSTEM::BACKQ-LIST* (QUOTE IF) START (SYSTEM::BACKQ-LIST (QUOTE THE-START) START) (QUOTE (0)))) (SYSTEM::BACKQ-LIST END (SYSTEM::BACKQ-LIST (QUOTE THE-END) END SEQ))) (SYSTEM::BACKQ-LIST (QUOTE UNLESS) (SYSTEM::BACKQ-LIST (QUOTE <=) START END) (SYSTEM::BACKQ-LIST (QUOTE BAD-SEQ-LIMIT) START END)) BODY))
     [java] ; (DEFUN CALL-TEST (TEST TEST-NOT ITEM KEYX) (COND (TEST (FUNCALL TEST ITEM KEYX)) (TEST-NOT (NOT (FUNCALL TEST-NOT ITEM KEYX))) (T (EQL ITEM KEYX))))
     [java] ; (DEFUN TEST-ERROR NIL (ERROR "both test and test are supplied"))
     [java] ; (DEFUN MISMATCH (SEQUENCE1 SEQUENCE2 &REST ARGS &KEY FROM-END TEST TEST-NOT (KEY (FUNCTION IDENTITY)) START1 START2 END1 END2) (AND TEST TEST-NOT (TEST-ERROR)) (IF (AND (OR (LISTP SEQUENCE1) (ARRAYP SEQUENCE1)) (OR (LISTP SEQUENCE2) (ARRAYP SEQUENCE2))) (WITH-START-END START1 END1 SEQUENCE1 (WITH-START-END START2 END2 SEQUENCE2 (IF (NOT FROM-END) (DO ((I1 START1 (1+ I1)) (I2 START2 (1+ I2))) ((OR (>= I1 END1) (>= I2 END2)) (IF (AND (>= I1 END1) (>= I2 END2)) NIL I1)) (UNLESS (CALL-TEST TEST TEST-NOT (FUNCALL KEY (ELT SEQUENCE1 I1)) (FUNCALL KEY (ELT SEQUENCE2 I2))) (RETURN I1))) (DO ((I1 (1- END1) (1- I1)) (I2 (1- END2) (1- I2))) ((OR (< I1 START1) (< I2 START2)) (IF (AND (< I1 START1) (< I2 START2)) NIL (1+ I1))) (UNLESS (CALL-TEST TEST TEST-NOT (FUNCALL KEY (ELT SEQUENCE1 I1)) (FUNCALL KEY (ELT SEQUENCE2 I2))) (RETURN (1+ I1))))))) (APPLY (FUNCTION SEQUENCE:MISMATCH) SEQUENCE1 SEQUENCE2 ARGS)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/mismatch.abcl (0.18 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/multiple-value-bind.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO MULTIPLE-VALUE-BIND (VARLIST VALUE-FORM &BODY BODY) (UNLESS (AND (LISTP VARLIST) (EVERY (FUNCTION SYMBOLP) VARLIST)) (ERROR (QUOTE PROGRAM-ERROR) :FORMAT-CONTROL "Variable list is not a list of symbols: ~S." :FORMAT-ARGUMENTS (LIST VARLIST))) (IF (= (LENGTH VARLIST) 1) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAR VARLIST) VALUE-FORM)) BODY) (LET ((IGNORE (GENSYM))) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-CALL) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST* (QUOTE LAMBDA) (BACKQ-CONS (QUOTE &OPTIONAL) (BACKQ-APPEND (MAPCAR (FUNCTION LIST) VARLIST) (BACKQ-LIST (QUOTE &REST) IGNORE))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORE) IGNORE)) BODY)) VALUE-FORM))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/multiple-value-bind.abcl (0.087 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/multiple-value-list.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO MULTIPLE-VALUE-LIST (FORM) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-CALL) (QUOTE (FUNCTION LIST)) FORM))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/multiple-value-list.abcl (0.043 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/multiple-value-setq.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO MULTIPLE-VALUE-SETQ (VARLIST VALUE-FORM) (UNLESS (AND (LISTP VARLIST) (EVERY (FUNCTION SYMBOLP) VARLIST)) (ERROR "~S is not a list of symbols." VARLIST)) (IF VARLIST (BACKQ-LIST (QUOTE VALUES) (BACKQ-LIST (QUOTE SETF) (BACKQ-CONS (QUOTE VALUES) VARLIST) VALUE-FORM)) (BACKQ-LIST (QUOTE VALUES) VALUE-FORM)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/multiple-value-setq.abcl (0.079 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/nsubstitute.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO REAL-COUNT (COUNT) (BACKQ-LIST (QUOTE COND) (BACKQ-CONS (BACKQ-LIST (QUOTE NULL) COUNT) (QUOTE (MOST-POSITIVE-FIXNUM))) (BACKQ-LIST (BACKQ-LIST (QUOTE FIXNUMP) COUNT) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) 0 COUNT)) (BACKQ-LIST (BACKQ-LIST (QUOTE INTEGERP) COUNT) (BACKQ-LIST* (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) (QUOTE (0 MOST-POSITIVE-FIXNUM)))) (BACKQ-LIST (QUOTE T) COUNT)))
     [java] ; (DEFUN NLIST-SUBSTITUTE* (NEW OLD SEQUENCE TEST TEST-NOT START END COUNT KEY) (DO ((LIST (NTHCDR START SEQUENCE) (CDR LIST)) (INDEX START (1+ INDEX))) ((OR (= INDEX END) (NULL LIST) (= COUNT 0)) SEQUENCE) (WHEN (IF TEST-NOT (NOT (FUNCALL TEST-NOT OLD (APPLY-KEY KEY (CAR LIST)))) (FUNCALL TEST OLD (APPLY-KEY KEY (CAR LIST)))) (RPLACA LIST NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NVECTOR-SUBSTITUTE* (NEW OLD SEQUENCE INCREMENTER TEST TEST-NOT START END COUNT KEY) (DO ((INDEX START (+ INDEX INCREMENTER))) ((OR (= INDEX END) (= COUNT 0)) SEQUENCE) (WHEN (IF TEST-NOT (NOT (FUNCALL TEST-NOT OLD (APPLY-KEY KEY (AREF SEQUENCE INDEX)))) (FUNCALL TEST OLD (APPLY-KEY KEY (AREF SEQUENCE INDEX)))) (SETF (AREF SEQUENCE INDEX) NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NSUBSTITUTE (NEW OLD SEQUENCE &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT END COUNT KEY (START 0)) (LET ((END (OR END (LENGTH SEQUENCE))) (COUNT (REAL-COUNT COUNT))) (IF (LISTP SEQUENCE) (IF FROM-END (LET ((LENGTH (LENGTH SEQUENCE))) (NREVERSE (NLIST-SUBSTITUTE* NEW OLD (NREVERSE SEQUENCE) TEST TEST-NOT (- LENGTH END) (- LENGTH START) COUNT KEY))) (NLIST-SUBSTITUTE* NEW OLD SEQUENCE TEST TEST-NOT START END COUNT KEY)) (IF FROM-END (NVECTOR-SUBSTITUTE* NEW OLD SEQUENCE -1 TEST TEST-NOT (1- END) (1- START) COUNT KEY) (NVECTOR-SUBSTITUTE* NEW OLD SEQUENCE 1 TEST TEST-NOT START END COUNT KEY)))))
     [java] ; (DEFUN NLIST-SUBSTITUTE-IF* (NEW TEST SEQUENCE START END COUNT KEY) (DO ((LIST (NTHCDR START SEQUENCE) (CDR LIST)) (INDEX START (1+ INDEX))) ((OR (= INDEX END) (NULL LIST) (= COUNT 0)) SEQUENCE) (WHEN (FUNCALL TEST (APPLY-KEY KEY (CAR LIST))) (RPLACA LIST NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NVECTOR-SUBSTITUTE-IF* (NEW TEST SEQUENCE INCREMENTER START END COUNT KEY) (DO ((INDEX START (+ INDEX INCREMENTER))) ((OR (= INDEX END) (= COUNT 0)) SEQUENCE) (WHEN (FUNCALL TEST (APPLY-KEY KEY (AREF SEQUENCE INDEX))) (SETF (AREF SEQUENCE INDEX) NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NSUBSTITUTE-IF (NEW TEST SEQUENCE &KEY FROM-END (START 0) END COUNT KEY) (LET ((END (OR END (LENGTH SEQUENCE))) (COUNT (REAL-COUNT COUNT))) (IF (LISTP SEQUENCE) (IF FROM-END (LET ((LENGTH (LENGTH SEQUENCE))) (NREVERSE (NLIST-SUBSTITUTE-IF* NEW TEST (NREVERSE SEQUENCE) (- LENGTH END) (- LENGTH START) COUNT KEY))) (NLIST-SUBSTITUTE-IF* NEW TEST SEQUENCE START END COUNT KEY)) (IF FROM-END (NVECTOR-SUBSTITUTE-IF* NEW TEST SEQUENCE -1 (1- END) (1- START) COUNT KEY) (NVECTOR-SUBSTITUTE-IF* NEW TEST SEQUENCE 1 START END COUNT KEY)))))
     [java] ; (DEFUN NLIST-SUBSTITUTE-IF-NOT* (NEW TEST SEQUENCE START END COUNT KEY) (DO ((LIST (NTHCDR START SEQUENCE) (CDR LIST)) (INDEX START (1+ INDEX))) ((OR (= INDEX END) (NULL LIST) (= COUNT 0)) SEQUENCE) (WHEN (NOT (FUNCALL TEST (APPLY-KEY KEY (CAR LIST)))) (RPLACA LIST NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NVECTOR-SUBSTITUTE-IF-NOT* (NEW TEST SEQUENCE INCREMENTER START END COUNT KEY) (DO ((INDEX START (+ INDEX INCREMENTER))) ((OR (= INDEX END) (= COUNT 0)) SEQUENCE) (WHEN (NOT (FUNCALL TEST (APPLY-KEY KEY (AREF SEQUENCE INDEX)))) (SETF (AREF SEQUENCE INDEX) NEW) (SETQ COUNT (1- COUNT)))))
     [java] ; (DEFUN NSUBSTITUTE-IF-NOT (NEW TEST SEQUENCE &KEY FROM-END (START 0) END COUNT KEY) (LET ((END (OR END (LENGTH SEQUENCE))) (COUNT (REAL-COUNT COUNT))) (IF (LISTP SEQUENCE) (IF FROM-END (LET ((LENGTH (LENGTH SEQUENCE))) (NREVERSE (NLIST-SUBSTITUTE-IF-NOT* NEW TEST (NREVERSE SEQUENCE) (- LENGTH END) (- LENGTH START) COUNT KEY))) (NLIST-SUBSTITUTE-IF-NOT* NEW TEST SEQUENCE START END COUNT KEY)) (IF FROM-END (NVECTOR-SUBSTITUTE-IF-NOT* NEW TEST SEQUENCE -1 (1- END) (1- START) COUNT KEY) (NVECTOR-SUBSTITUTE-IF-NOT* NEW TEST SEQUENCE 1 START END COUNT KEY)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/nsubstitute.abcl (0.28 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/nth-value.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO NTH-VALUE (N FORM) (BACKQ-LIST (QUOTE NTH) N (BACKQ-LIST (QUOTE MULTIPLE-VALUE-LIST) FORM)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/nth-value.abcl (0.051 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/numbers.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN SIGNUM (NUMBER) "If NUMBER is zero, return NUMBER, else return (/ NUMBER (ABS NUMBER))." (IF (ZEROP NUMBER) NUMBER (IF (RATIONALP NUMBER) (IF (PLUSP NUMBER) 1 -1) (/ NUMBER (ABS NUMBER)))))
     [java] ; (DEFUN ROUND (NUMBER &OPTIONAL (DIVISOR 1)) "Rounds number (or number/divisor) to nearest integer.
     [java]    The second returned value is the remainder." (MULTIPLE-VALUE-BIND (TRU REM) (TRUNCATE NUMBER DIVISOR) (IF (ZEROP REM) (VALUES TRU REM) (LET ((THRESH (/ (ABS DIVISOR) 2))) (COND ((OR (> REM THRESH) (AND (= REM THRESH) (ODDP TRU))) (IF (MINUSP DIVISOR) (VALUES (- TRU 1) (+ REM DIVISOR)) (VALUES (+ TRU 1) (- REM DIVISOR)))) ((LET ((-THRESH (- THRESH))) (OR (< REM -THRESH) (AND (= REM -THRESH) (ODDP TRU)))) (IF (MINUSP DIVISOR) (VALUES (+ TRU 1) (- REM DIVISOR)) (VALUES (- TRU 1) (+ REM DIVISOR)))) (T (VALUES TRU REM)))))))
     [java] ; (DEFUN FFLOOR (NUMBER &OPTIONAL (DIVISOR 1)) "Same as FLOOR, but returns first value as a float." (MULTIPLE-VALUE-BIND (TRU REM) (FTRUNCATE NUMBER DIVISOR) (IF (AND (NOT (ZEROP REM)) (IF (MINUSP DIVISOR) (PLUSP NUMBER) (MINUSP NUMBER))) (VALUES (1- TRU) (+ REM DIVISOR)) (VALUES TRU REM))))
     [java] ; (DEFUN FCEILING (NUMBER &OPTIONAL (DIVISOR 1)) "Same as CEILING, but returns first value as a float." (MULTIPLE-VALUE-BIND (TRU REM) (FTRUNCATE NUMBER DIVISOR) (IF (AND (NOT (ZEROP REM)) (IF (MINUSP DIVISOR) (MINUSP NUMBER) (PLUSP NUMBER))) (VALUES (+ TRU 1) (- REM DIVISOR)) (VALUES TRU REM))))
     [java] ; (DEFUN FROUND (NUMBER &OPTIONAL (DIVISOR 1)) "Same as ROUND, but returns first value as a float." (MULTIPLE-VALUE-BIND (RES REM) (ROUND NUMBER DIVISOR) (VALUES (FLOAT RES (IF (FLOATP REM) REM 1.0f0)) REM)))
     [java] ; (DEFUN RATIONALIZE (NUMBER) (RATIONAL NUMBER))
     [java] ; (DEFUN GCD (&REST INTEGERS) (COND ((NULL INTEGERS) 0) ((NULL (CDR INTEGERS)) (LET ((N (CAR INTEGERS))) (IF (INTEGERP N) (ABS N) (ERROR (QUOTE TYPE-ERROR) :DATUM N :EXPECTED-TYPE (QUOTE INTEGER))))) (T (DO ((GCD (CAR INTEGERS) (GCD-2 GCD (CAR REST))) (REST (CDR INTEGERS) (CDR REST))) ((NULL REST) GCD)))))
     [java] ; (DEFUN ISQRT (NATURAL) "Returns the root of the nearest integer less than natural which is a perfect
     [java]    square." (UNLESS (AND (INTEGERP NATURAL) (NOT (MINUSP NATURAL))) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "The value ~A is not a non-negative real number." :FORMAT-ARGUMENTS (LIST NATURAL))) (IF (AND (FIXNUMP NATURAL) (<= NATURAL 24)) (COND ((> NATURAL 15) 4) ((> NATURAL 8) 3) ((> NATURAL 3) 2) ((> NATURAL 0) 1) (T 0)) (LET* ((N-LEN-QUARTER (ASH (INTEGER-LENGTH NATURAL) -2)) (N-HALF (ASH NATURAL (- (ASH N-LEN-QUARTER 1)))) (N-HALF-ISQRT (ISQRT N-HALF)) (INIT-VALUE (ASH (1+ N-HALF-ISQRT) N-LEN-QUARTER))) (LOOP (LET ((ITERATED-VALUE (ASH (+ INIT-VALUE (TRUNCATE NATURAL INIT-VALUE)) -1))) (UNLESS (< ITERATED-VALUE INIT-VALUE) (RETURN INIT-VALUE)) (SETQ INIT-VALUE ITERATED-VALUE))))))
     [java] ; (DEFUN FLOAT-PRECISION (FLOAT) (IF (FLOATP FLOAT) (COND ((ZEROP FLOAT) 0) ((TYPEP FLOAT (QUOTE SINGLE-FLOAT)) 24) ((TYPEP FLOAT (QUOTE DOUBLE-FLOAT)) 53) (T (AVER NIL))) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL "~S is not of type FLOAT." :FORMAT-ARGUMENTS (LIST FLOAT))))
     [java] ; (DEFUN DECODE-FLOAT (FLOAT) (MULTIPLE-VALUE-BIND (SIGNIFICAND EXPONENT SIGN) (INTEGER-DECODE-FLOAT FLOAT) (VALUES (COERCE (/ SIGNIFICAND (EXPT 2 53)) (QUOTE FLOAT)) (+ EXPONENT 53) (IF (MINUSP SIGN) -1.0f0 1.0f0))))
     [java] ; (DEFUN CONJUGATE (NUMBER) (ETYPECASE NUMBER (COMPLEX (COMPLEX (REALPART NUMBER) (- (IMAGPART NUMBER)))) (NUMBER NUMBER)))
     [java] ; (DEFUN PHASE (NUMBER) "Returns the angle part of the polar representation of a complex number.
     [java]    For complex numbers, this is (atan (imagpart number) (realpart number)).
     [java]    For non-complex positive numbers, this is 0.  For non-complex negative
     [java]    numbers this is PI." (ETYPECASE NUMBER (RATIONAL (IF (MINUSP NUMBER) (COERCE PI (QUOTE SINGLE-FLOAT)) 0.0f0)) (SINGLE-FLOAT (IF (MINUSP (FLOAT-SIGN NUMBER)) (COERCE PI (QUOTE SINGLE-FLOAT)) 0.0f0)) (DOUBLE-FLOAT (IF (MINUSP (FLOAT-SIGN NUMBER)) (COERCE PI (QUOTE DOUBLE-FLOAT)) 0.0d0)) (COMPLEX (IF (ZEROP (REALPART NUMBER)) (COERCE (* (/ PI 2) (SIGNUM (IMAGPART NUMBER))) (IF (TYPEP (IMAGPART NUMBER) (QUOTE DOUBLE-FLOAT)) (QUOTE DOUBLE-FLOAT) (QUOTE SINGLE-FLOAT))) (ATAN (IMAGPART NUMBER) (REALPART NUMBER))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/numbers.abcl (0.305 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/or.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO OR (&REST FORMS) (COND ((ENDP FORMS) NIL) ((ENDP (REST FORMS)) (FIRST FORMS)) (T (LET ((N-RESULT (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST N-RESULT (FIRST FORMS))) (BACKQ-LIST (QUOTE IF) N-RESULT N-RESULT (BACKQ-CONS (QUOTE OR) (REST FORMS))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/or.abcl (0.059 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/parse-integer.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN PARSE-INTEGER-ERROR (STRING) (ERROR (QUOTE PARSE-ERROR) "not an integer string: ~S" STRING))
     [java] ; (DEFUN PARSE-INTEGER (STRING &KEY (START 0) END (RADIX 10) JUNK-ALLOWED) (WHEN (NULL END) (SETQ END (LENGTH STRING))) (LET ((INDEX (DO ((I START (1+ I))) ((= I END) (IF JUNK-ALLOWED (RETURN-FROM PARSE-INTEGER (VALUES NIL END)) (PARSE-INTEGER-ERROR STRING))) (UNLESS (WHITESPACEP (CHAR STRING I)) (RETURN I)))) (MINUSP NIL) (FOUND-DIGIT NIL) (RESULT 0)) (LET ((CHAR (CHAR STRING INDEX))) (COND ((CHAR= CHAR #\-) (SETQ MINUSP T) (SETQ INDEX (1+ INDEX))) ((CHAR= CHAR #\+) (SETQ INDEX (1+ INDEX))))) (LOOP (WHEN (= INDEX END) (RETURN NIL)) (LET* ((CHAR (CHAR STRING INDEX)) (WEIGHT (DIGIT-CHAR-P CHAR RADIX))) (COND (WEIGHT (SETQ RESULT (+ WEIGHT (* RESULT RADIX)) FOUND-DIGIT T)) (JUNK-ALLOWED (RETURN NIL)) ((WHITESPACEP CHAR) (DO NIL ((= (SETQ INDEX (1+ INDEX)) END)) (UNLESS (WHITESPACEP (CHAR STRING INDEX)) (PARSE-INTEGER-ERROR STRING))) (RETURN NIL)) (T (PARSE-INTEGER-ERROR STRING)))) (SETQ INDEX (1+ INDEX))) (VALUES (IF FOUND-DIGIT (IF MINUSP (- RESULT) RESULT) (IF JUNK-ALLOWED NIL (PARSE-INTEGER-ERROR STRING))) INDEX)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/parse-integer.abcl (0.095 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/parse-lambda-list.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN PARSE-LAMBDA-LIST-LIKE-THING (LIST) (COLLECT ((REQUIRED) (OPTIONAL) (KEYS) (AUX)) (LET ((RESTP NIL) (REST NIL) (KEYP NIL) (AUXP NIL) (ALLOWP NIL) (STATE :REQUIRED)) (DECLARE (TYPE (MEMBER :ALLOW-OTHER-KEYS :AUX :KEY :OPTIONAL :POST-REST :REQUIRED :REST) STATE)) (DOLIST (ARG LIST) (IF (AND (SYMBOLP ARG) (LET ((NAME (SYMBOL-NAME (THE SYMBOL ARG)))) (AND (PLUSP (LENGTH NAME)) (CHAR= (CHAR NAME 0) #\&)))) (CASE ARG (&OPTIONAL (UNLESS (EQ STATE :REQUIRED) (ERROR "misplaced &OPTIONAL in lambda list: ~S" LIST)) (SETQ STATE :OPTIONAL)) (&REST (UNLESS (MEMBER STATE (QUOTE (:REQUIRED :OPTIONAL))) (ERROR "misplaced &REST in lambda list: ~S" LIST)) (SETQ STATE :REST)) (&KEY (UNLESS (MEMBER STATE (QUOTE (:REQUIRED :OPTIONAL :POST-REST))) (ERROR "misplaced &KEY in lambda list: ~S" LIST)) (SETQ KEYP T STATE :KEY)) (&ALLOW-OTHER-KEYS (UNLESS (EQ STATE (QUOTE :KEY)) (ERROR "misplaced &ALLOW-OTHER-KEYS in lambda list: ~S" LIST)) (SETQ ALLOWP T STATE :ALLOW-OTHER-KEYS)) (&AUX (WHEN (EQ STATE :REST) (ERROR "misplaced &AUX in lambda list: ~S" LIST)) (SETQ AUXP T STATE :AUX)) (T (ERROR "unknown &KEYWORD in lambda list: ~S" ARG))) (CASE STATE (:REQUIRED (REQUIRED ARG)) (:OPTIONAL (OPTIONAL ARG)) (:REST (SETQ RESTP T REST ARG STATE :POST-REST)) (:KEY (KEYS ARG)) (:AUX (AUX ARG)) (T (ERROR "found garbage in lambda list when expecting a keyword: ~S" ARG))))) (WHEN (EQ STATE :REST) (ERROR "&REST without rest variable")) (VALUES (REQUIRED) (OPTIONAL) RESTP REST KEYP (KEYS) ALLOWP AUXP (AUX) (NEQ STATE :REQUIRED)))))
     [java] ; (DEFUN PARSE-LAMBDA-LIST (LAMBDA-LIST) (MULTIPLE-VALUE-BIND (REQUIRED OPTIONAL RESTP REST KEYP KEYS ALLOWP AUXP AUX) (PARSE-LAMBDA-LIST-LIKE-THING LAMBDA-LIST) (FLET ((NEED-SYMBOL (X WHY) (UNLESS (SYMBOLP X) (ERROR "~A is not a symbol: ~S" WHY X)))) (DOLIST (I REQUIRED) (NEED-SYMBOL I "Required argument")) (DOLIST (I OPTIONAL) (TYPECASE I (SYMBOL) (CONS (DESTRUCTURING-BIND (VAR &OPTIONAL INIT-FORM SUPPLIED-P) I (DECLARE (IGNORE INIT-FORM SUPPLIED-P)) (NEED-SYMBOL VAR "&OPTIONAL parameter name"))) (T (ERROR "&OPTIONAL parameter is not a symbol or cons: ~S" I)))) (WHEN RESTP (NEED-SYMBOL REST "&REST argument")) (WHEN KEYP (DOLIST (I KEYS) (TYPECASE I (SYMBOL) (CONS (DESTRUCTURING-BIND (VAR-OR-KV &OPTIONAL INIT-FORM SUPPLIED-P) I (DECLARE (IGNORE INIT-FORM SUPPLIED-P)) (IF (CONSP VAR-OR-KV) (DESTRUCTURING-BIND (KEYWORD-NAME VAR) VAR-OR-KV (DECLARE (IGNORE KEYWORD-NAME)) (NEED-SYMBOL VAR "&KEY parameter name")) (NEED-SYMBOL VAR-OR-KV "&KEY parameter name")))) (T (ERROR "&KEY parameter is not a symbol or cons: ~S" I)))))) (VALUES REQUIRED OPTIONAL RESTP REST KEYP KEYS ALLOWP AUXP AUX)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/parse-lambda-list.abcl (0.143 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/package.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN MAKE-PACKAGE (NAME &KEY NICKNAMES USE) (RESTART-CASE (PROGN (WHEN (FIND-PACKAGE NAME) (ERROR (QUOTE SIMPLE-ERROR) "Package ~A already exists." NAME)) (DOLIST (NICK NICKNAMES) (WHEN (FIND-PACKAGE NICK) (ERROR (QUOTE PACKAGE-ERROR) :PACKAGE NICK))) (%MAKE-PACKAGE NAME NICKNAMES USE)) (USE-EXISTING-PACKAGE NIL :REPORT "Use existing package" (RETURN-FROM MAKE-PACKAGE (FIND-PACKAGE NAME)))))
     [java] ; (DEFUN ENSURE-AVAILABLE-SYMBOLS (IMPORTS) (REMOVE NIL (MAPCAR (FUNCTION (LAMBDA (PACKAGE-AND-SYMBOLS) (LET* ((PACKAGE (FIND-PACKAGE (DESIGNATED-PACKAGE-NAME (CAR PACKAGE-AND-SYMBOLS)))) (NEW-SYMBOLS (REMOVE NIL (MAPCAR (FUNCTION (LAMBDA (SYM) (RESTART-CASE (PROGN (UNLESS (NTH-VALUE 1 (FIND-SYMBOL SYM PACKAGE)) (ERROR (QUOTE PACKAGE-ERROR) "The symbol ~A is not present in package ~A." SYM (PACKAGE-NAME PACKAGE))) SYM) (SKIP NIL :REPORT "Skip this symbol." NIL)))) (CDR PACKAGE-AND-SYMBOLS))))) (WHEN NEW-SYMBOLS (CONS PACKAGE NEW-SYMBOLS))))) IMPORTS)))
     [java] ; (DEFUN IMPORT (SYMBOLS &OPTIONAL (PACKAGE *PACKAGE* PACKAGE-SUPPLIED-P)) (DOLIST (SYMBOL (IF (LISTP SYMBOLS) SYMBOLS (LIST SYMBOLS))) (LET* ((SYM-NAME (STRING SYMBOL)) (LOCAL-SYM (FIND-SYMBOL SYM-NAME PACKAGE))) (RESTART-CASE (PROGN (WHEN (AND LOCAL-SYM (NOT (EQL SYMBOL LOCAL-SYM))) (ERROR (QUOTE PACKAGE-ERROR) "Different symbol (~A) with the same name already accessible in package ~A." LOCAL-SYM (PACKAGE-NAME PACKAGE))) (IF PACKAGE-SUPPLIED-P (%IMPORT (LIST SYMBOL) PACKAGE) (%IMPORT (LIST SYMBOL)))) (UNINTERN-EXISTING NIL :REPORT (LAMBDA (S) (FORMAT S "Unintern ~S and continue" LOCAL-SYM)) (UNINTERN LOCAL-SYM) (%IMPORT SYMBOL)) (SKIP NIL :REPORT "Skip symbol")))) T)
     [java] ; (DEFUN DELETE-PACKAGE (PACKAGE) (WITH-SIMPLE-RESTART (CONTINUE "Ignore missing package.") (%DELETE-PACKAGE PACKAGE)))
     [java] ; (DEFUN ADD-PACKAGE-LOCAL-NICKNAME (LOCAL-NICKNAME ACTUAL-PACKAGE &OPTIONAL (PACKAGE-DESIGNATOR *PACKAGE*)) (LET* ((LOCAL-NICKNAME (STRING LOCAL-NICKNAME)) (PACKAGE-DESIGNATOR (OR (FIND-PACKAGE PACKAGE-DESIGNATOR) (ERROR "Package ~A not found" PACKAGE-DESIGNATOR))) (ACTUAL-PACKAGE (OR (FIND-PACKAGE ACTUAL-PACKAGE) (ERROR "Package ~A not found" ACTUAL-PACKAGE)))) (WHEN (MEMBER LOCAL-NICKNAME (QUOTE ("CL" "COMMON-LISP" "KEYWORD")) :TEST (FUNCTION STRING=)) (CERROR "Continue anyway" "Trying to define a local nickname called ~A" LOCAL-NICKNAME)) (WHEN (MEMBER LOCAL-NICKNAME (LIST* (PACKAGE-NAME PACKAGE-DESIGNATOR) (PACKAGE-NICKNAMES PACKAGE-DESIGNATOR)) :TEST (FUNCTION STRING=)) (CERROR "Continue anyway" "Trying to override the name or nickname ~A  for package ~A ~
     [java]                with a local nickname for another package ~A" LOCAL-NICKNAME PACKAGE-DESIGNATOR ACTUAL-PACKAGE)) (%ADD-PACKAGE-LOCAL-NICKNAME LOCAL-NICKNAME ACTUAL-PACKAGE PACKAGE-DESIGNATOR)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/package.abcl (0.406 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/pathnames.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN PATHNAME-HOST (PATHNAME &KEY (CASE :LOCAL)) (%PATHNAME-HOST PATHNAME CASE))
     [java] ; (DEFUN PATHNAME-DEVICE (PATHNAME &KEY (CASE :LOCAL)) (%PATHNAME-DEVICE PATHNAME CASE))
     [java] ; (DEFUN PATHNAME-DIRECTORY (PATHNAME &KEY (CASE :LOCAL)) (%PATHNAME-DIRECTORY PATHNAME CASE))
     [java] ; (DEFUN PATHNAME-NAME (PATHNAME &KEY (CASE :LOCAL)) (%PATHNAME-NAME PATHNAME CASE))
     [java] ; (DEFUN PATHNAME-TYPE (PATHNAME &KEY (CASE :LOCAL)) (%PATHNAME-TYPE PATHNAME CASE))
     [java] ; (DEFUN WILD-PATHNAME-P (PATHNAME &OPTIONAL FIELD-KEY) (%WILD-PATHNAME-P PATHNAME FIELD-KEY))
     [java] ; (DEFUN COMPONENT-MATCH-WILD-P (THING WILD IGNORE-CASE) (LET ((TESTFUNC (IF IGNORE-CASE (FUNCTION EQUALP) (FUNCTION EQUAL)))) (LABELS ((SPLIT-STRING (DELIM STR) (FLET ((FINDER (CHAR) (FIND CHAR DELIM))) (LOOP FOR X = (POSITION-IF-NOT (FUNCTION FINDER) STR) THEN (POSITION-IF-NOT (FUNCTION FINDER) STR :START (OR Y (LENGTH STR))) FOR Y = (POSITION-IF (FUNCTION FINDER) STR :START X) THEN (POSITION-IF (FUNCTION FINDER) STR :START (OR X (LENGTH STR))) WHILE X COLLECT (SUBSEQ STR X Y)))) (POSITIONS-LARGER (THING SUBSTRINGS PREVIOUS-POS) (LET ((NEW-POS (SEARCH (CAR SUBSTRINGS) THING :START2 PREVIOUS-POS :TEST TESTFUNC))) (OR (NOT SUBSTRINGS) (AND NEW-POS (>= NEW-POS PREVIOUS-POS) (POSITIONS-LARGER THING (CDR SUBSTRINGS) NEW-POS)))))) (LET ((SPLIT-RESULT (SPLIT-STRING "*" WILD))) (AND (POSITIONS-LARGER THING SPLIT-RESULT 0) (IF (EQL (ELT WILD 0) #\*) T (EQL (SEARCH (FIRST SPLIT-RESULT) THING :TEST TESTFUNC) 0)) (IF (EQL (ELT WILD (1- (LENGTH WILD))) #\*) T (LET ((LAST-SPLIT-RESULT (FIRST (LAST SPLIT-RESULT)))) (EQL (SEARCH LAST-SPLIT-RESULT THING :FROM-END T :TEST TESTFUNC) (- (LENGTH THING) (LENGTH LAST-SPLIT-RESULT))))))))))
     [java] ; (DEFUN COMPONENT-MATCH-P (THING WILD IGNORE-CASE) (COND ((EQ WILD :WILD) T) ((NULL WILD) T) ((AND (STRINGP WILD) (POSITION #\* WILD)) (COMPONENT-MATCH-WILD-P THING WILD IGNORE-CASE)) (IGNORE-CASE (EQUALP THING WILD)) (T (EQUAL THING WILD))))
     [java] ; (DEFUN DIRECTORY-MATCH-COMPONENTS (THING WILD IGNORE-CASE) (LOOP (COND ((ENDP THING) (RETURN (OR (ENDP WILD) (EQUAL WILD (QUOTE (:WILD-INFERIORS)))))) ((ENDP WILD) (RETURN NIL))) (LET ((X (CAR THING)) (Y (CAR WILD))) (WHEN (EQ Y :WILD-INFERIORS) (RETURN T)) (UNLESS (COMPONENT-MATCH-P X Y IGNORE-CASE) (RETURN NIL)) (SETF THING (CDR THING) WILD (CDR WILD)))))
     [java] ; (DEFUN DIRECTORY-MATCH-P (THING WILD IGNORE-CASE) (COND ((EQ WILD :WILD) T) ((NULL WILD) T) ((AND IGNORE-CASE (EQUALP THING WILD)) T) ((EQUAL THING WILD) T) ((AND (NULL THING) (EQUAL WILD (QUOTE (:ABSOLUTE :WILD-INFERIORS)))) T) ((AND (CONSP THING) (CONSP WILD)) (IF (EQ (%CAR THING) (%CAR WILD)) (DIRECTORY-MATCH-COMPONENTS (%CDR THING) (%CDR WILD) IGNORE-CASE) NIL)) (T NIL)))
     [java] ; (DEFUN PATHNAME-MATCH-P (PATHNAME WILDCARD) (SETF PATHNAME (PATHNAME PATHNAME) WILDCARD (PATHNAME WILDCARD)) (UNLESS (COMPONENT-MATCH-P (PATHNAME-HOST PATHNAME) (PATHNAME-HOST WILDCARD) NIL) (RETURN-FROM PATHNAME-MATCH-P NIL)) (WHEN (AND (PATHNAME-JAR-P PATHNAME) (PATHNAME-JAR-P WILDCARD)) (UNLESS (EVERY (LAMBDA (VALUE) (NOT (NULL VALUE))) (MAPCAR (FUNCTION PATHNAME-MATCH-P) (PATHNAME-DEVICE PATHNAME) (PATHNAME-DEVICE WILDCARD))) (RETURN-FROM PATHNAME-MATCH-P NIL))) (WHEN (OR (AND (PATHNAME-JAR-P PATHNAME) (NOT (PATHNAME-JAR-P WILDCARD))) (AND (NOT (PATHNAME-JAR-P PATHNAME)) (PATHNAME-JAR-P WILDCARD))) (RETURN-FROM PATHNAME-MATCH-P NIL)) (LET* ((WINDOWS-P (FEATUREP :WINDOWS)) (IGNORE-CASE (OR WINDOWS-P (TYPEP PATHNAME (QUOTE LOGICAL-PATHNAME))))) (COND ((AND WINDOWS-P (NOT (PATHNAME-JAR-P PATHNAME)) (NOT (PATHNAME-JAR-P WILDCARD)) (NOT (COMPONENT-MATCH-P (PATHNAME-DEVICE PATHNAME) (PATHNAME-DEVICE WILDCARD) IGNORE-CASE))) NIL) ((NOT (DIRECTORY-MATCH-P (PATHNAME-DIRECTORY PATHNAME) (PATHNAME-DIRECTORY WILDCARD) IGNORE-CASE)) NIL) ((NOT (COMPONENT-MATCH-P (PATHNAME-NAME PATHNAME) (PATHNAME-NAME WILDCARD) IGNORE-CASE)) NIL) ((NOT (COMPONENT-MATCH-P (PATHNAME-TYPE PATHNAME) (PATHNAME-TYPE WILDCARD) IGNORE-CASE)) NIL) (T T))))
     [java] ; (DEFUN WILD-P (COMPONENT) (OR (EQ COMPONENT :WILD) (AND (STRINGP COMPONENT) (POSITION #\* COMPONENT))))
     [java] ; (DEFUN CASIFY (THING CASE) (TYPECASE THING (STRING (CASE CASE (:UPCASE (STRING-UPCASE THING)) (:DOWNCASE (STRING-DOWNCASE THING)) (T THING))) (LIST (LET (RESULT) (DOLIST (COMPONENT THING (NREVERSE RESULT)) (PUSH (CASIFY COMPONENT CASE) RESULT)))) (T THING)))
     [java] ; (DEFUN TRANSLATE-COMPONENT (SOURCE FROM TO &OPTIONAL CASE) (DECLARE (IGNORE FROM)) (COND ((OR (EQ TO :WILD) (NULL TO)) (CASIFY SOURCE CASE)) ((AND TO (NOT (WILD-P TO))) TO) (T (ERROR "Unsupported wildcard pattern: ~S" TO))))
     [java] ; (DEFUN TRANSLATE-JAR-DEVICE (SOURCE FROM TO &OPTIONAL CASE) (DECLARE (IGNORE CASE)) (UNLESS TO (RETURN-FROM TRANSLATE-JAR-DEVICE NIL)) (WHEN (NOT (= (LENGTH SOURCE) (LENGTH FROM) (LENGTH TO))) (ERROR "Unsupported pathname translation for unequal jar ~
     [java]   references: ~S != ~S != ~S" SOURCE FROM TO)) (MAPCAR (FUNCTION TRANSLATE-PATHNAME) SOURCE FROM TO))
     [java] ; (DEFUN TRANSLATE-DIRECTORY-COMPONENTS-AUX (SRC FROM TO CASE) (COND ((AND (NULL SRC) (NULL FROM) (NULL TO)) NIL) ((AND TO (NOT (MEMBER (CAR TO) (QUOTE (:WILD :WILD-INFERIORS))))) (CONS (CASIFY (CAR TO) CASE) (TRANSLATE-DIRECTORY-COMPONENTS-AUX SRC FROM (CDR TO) CASE))) ((AND (NOT SRC) (EQ (CAR FROM) :WILD-INFERIORS) (EQ (CAR TO) :WILD-INFERIORS)) (TRANSLATE-DIRECTORY-COMPONENTS-AUX SRC (CDR FROM) (CDR TO) CASE)) ((NOT (AND SRC FROM)) (THROW (QUOTE FAILED-MATCH) NIL)) ((NOT (MEMBER (CAR FROM) (QUOTE (:WILD :WILD-INFERIORS)))) (UNLESS (STRING= (CASIFY (CAR SRC) CASE) (CASIFY (CAR FROM) CASE)) (THROW (QUOTE FAILED-MATCH) NIL)) (TRANSLATE-DIRECTORY-COMPONENTS-AUX (CDR SRC) (CDR FROM) TO CASE)) ((NOT (EQ (CAR FROM) (CAR TO))) (THROW (QUOTE FAILED-MATCH) NIL)) ((EQ (CAR TO) :WILD) (CONS (CASIFY (CAR SRC) CASE) (TRANSLATE-DIRECTORY-COMPONENTS-AUX (CDR SRC) (CDR FROM) (CDR TO) CASE))) ((EQ (CAR TO) :WILD-INFERIORS) (DO ((SRC (CDR SRC) (CDR SRC)) (MATCH (LIST (CASIFY (CAR SRC) CASE)) (CONS (CASIFY (CAR SRC) CASE) MATCH))) (NIL) (CATCH (QUOTE FAILED-MATCH) (RETURN-FROM TRANSLATE-DIRECTORY-COMPONENTS-AUX (APPEND (REVERSE MATCH) (TRANSLATE-DIRECTORY-COMPONENTS-AUX SRC (CDR FROM) (CDR TO) CASE)))) (WHEN (AND (NULL SRC) (EQ (CAR FROM) :WILD-INFERIORS) (EQ (CAR TO) :WILD-INFERIORS)) (RETURN-FROM TRANSLATE-DIRECTORY-COMPONENTS-AUX NIL)) (WHEN (NULL SRC) (THROW (QUOTE FAILED-MATCH) NIL))))))
     [java] ; (DEFUN TRANSLATE-DIRECTORY-COMPONENTS (SRC FROM TO CASE) (CATCH (QUOTE FAILED-MATCH) (RETURN-FROM TRANSLATE-DIRECTORY-COMPONENTS (TRANSLATE-DIRECTORY-COMPONENTS-AUX SRC FROM TO CASE))) (ERROR "Unsupported case in TRANSLATE-DIRECTORY-COMPONENTS."))
     [java] ; (DEFUN TRANSLATE-DIRECTORY (SOURCE FROM TO CASE) (COND ((NULL SOURCE) TO) ((EQUAL SOURCE (QUOTE (:ABSOLUTE))) (REMOVE :WILD-INFERIORS TO)) (T (TRANSLATE-DIRECTORY-COMPONENTS SOURCE FROM TO CASE))))
     [java] ; (DEFUN TRANSLATE-PATHNAME (SOURCE FROM-WILDCARD TO-WILDCARD &KEY) (UNLESS (PATHNAME-MATCH-P SOURCE FROM-WILDCARD) (ERROR "~S and ~S do not match." SOURCE FROM-WILDCARD)) (LET* ((SOURCE (PATHNAME SOURCE)) (FROM (PATHNAME FROM-WILDCARD)) (TO (PATHNAME TO-WILDCARD)) (DEVICE (IF (TYPEP (QUOTE TO) (QUOTE LOGICAL-PATHNAME)) :UNSPECIFIC (IF (PATHNAME-JAR-P SOURCE) (TRANSLATE-JAR-DEVICE (PATHNAME-DEVICE SOURCE) (PATHNAME-DEVICE FROM) (PATHNAME-DEVICE TO)) (TRANSLATE-COMPONENT (PATHNAME-DEVICE SOURCE) (PATHNAME-DEVICE FROM) (PATHNAME-DEVICE TO))))) (CASE (AND (TYPEP SOURCE (QUOTE LOGICAL-PATHNAME)) (OR (FEATUREP :UNIX) (FEATUREP :WINDOWS)) :DOWNCASE))) (MAKE-PATHNAME :HOST (PATHNAME-HOST TO) :DEVICE (COND ((TYPEP TO (QUOTE LOGICAL-PATHNAME)) :UNSPECIFIC) ((EQ DEVICE :UNSPECIFIC) NIL) (T DEVICE)) :DIRECTORY (TRANSLATE-DIRECTORY (PATHNAME-DIRECTORY SOURCE) (PATHNAME-DIRECTORY FROM) (PATHNAME-DIRECTORY TO) CASE) :NAME (TRANSLATE-COMPONENT (PATHNAME-NAME SOURCE) (PATHNAME-NAME FROM) (PATHNAME-NAME TO) CASE) :TYPE (TRANSLATE-COMPONENT (PATHNAME-TYPE SOURCE) (PATHNAME-TYPE FROM) (PATHNAME-TYPE TO) CASE) :VERSION (IF (NULL (PATHNAME-HOST FROM)) (IF (OR (EQ (PATHNAME-VERSION TO) :WILD) (EQ (PATHNAME-VERSION TO) NIL)) (PATHNAME-VERSION SOURCE) (PATHNAME-VERSION TO)) (TRANSLATE-COMPONENT (PATHNAME-VERSION SOURCE) (PATHNAME-VERSION FROM) (PATHNAME-VERSION TO))))))
     [java] ; (DEFUN LOGICAL-HOST-P (CANONICAL-HOST) (MULTIPLE-VALUE-BIND (TRANSLATIONS PRESENT) (GETHASH CANONICAL-HOST *LOGICAL-PATHNAME-TRANSLATIONS*) (DECLARE (IGNORE TRANSLATIONS)) PRESENT))
     [java] ; (DEFUN LOGICAL-PATHNAME-TRANSLATIONS (HOST) (MULTIPLE-VALUE-BIND (TRANSLATIONS PRESENT) (GETHASH (CANONICALIZE-LOGICAL-HOST HOST) *LOGICAL-PATHNAME-TRANSLATIONS*) (UNLESS PRESENT (ERROR (QUOTE TYPE-ERROR) :DATUM HOST :EXPECTED-TYPE (QUOTE (AND STRING (SATISFIES LOGICAL-HOST-P))))) TRANSLATIONS))
     [java] ; (DEFUN CANONICALIZE-LOGICAL-PATHNAME-TRANSLATIONS (TRANSLATIONS HOST) (LET (RESULT) (DOLIST (TRANSLATION TRANSLATIONS (NREVERSE RESULT)) (LET ((FROM (CAR TRANSLATION)) (TO (CADR TRANSLATION))) (PUSH (LIST (IF (TYPEP FROM (QUOTE LOGICAL-PATHNAME)) FROM (PARSE-NAMESTRING FROM HOST)) (PATHNAME TO)) RESULT)))))
     [java] ; (DEFUN %SET-LOGICAL-PATHNAME-TRANSLATIONS (HOST TRANSLATIONS) (SETF HOST (CANONICALIZE-LOGICAL-HOST HOST)) (UNLESS (LOGICAL-HOST-P HOST) (SETF (GETHASH HOST *LOGICAL-PATHNAME-TRANSLATIONS*) NIL)) (SETF (GETHASH HOST *LOGICAL-PATHNAME-TRANSLATIONS*) (CANONICALIZE-LOGICAL-PATHNAME-TRANSLATIONS TRANSLATIONS HOST)))
     [java] ; (DEFSETF LOGICAL-PATHNAME-TRANSLATIONS %SET-LOGICAL-PATHNAME-TRANSLATIONS)
     [java] ; (DEFUN TRANSLATE-LOGICAL-PATHNAME (PATHNAME &KEY) (TYPECASE PATHNAME (LOGICAL-PATHNAME (LET* ((HOST (PATHNAME-HOST PATHNAME)) (TRANSLATIONS (LOGICAL-PATHNAME-TRANSLATIONS HOST))) (DOLIST (TRANSLATION TRANSLATIONS (ERROR (QUOTE FILE-ERROR) :PATHNAME PATHNAME :FORMAT-CONTROL "No translation for ~S" :FORMAT-ARGUMENTS (LIST PATHNAME))) (LET ((FROM-WILDCARD (CAR TRANSLATION)) (TO-WILDCARD (CADR TRANSLATION))) (WHEN (PATHNAME-MATCH-P PATHNAME FROM-WILDCARD) (RETURN (TRANSLATE-LOGICAL-PATHNAME (TRANSLATE-PATHNAME PATHNAME FROM-WILDCARD TO-WILDCARD)))))))) (PATHNAME PATHNAME) (T (TRANSLATE-LOGICAL-PATHNAME (PATHNAME PATHNAME)))))
     [java] ; (DEFUN LOAD-LOGICAL-PATHNAME-TRANSLATIONS (HOST) (DECLARE (TYPE STRING HOST)) (MULTIPLE-VALUE-BIND (IGNORE FOUND) (GETHASH (CANONICALIZE-LOGICAL-HOST HOST) *LOGICAL-PATHNAME-TRANSLATIONS*) (DECLARE (IGNORE IGNORE)) (UNLESS FOUND (ERROR "The logical host ~S was not found." HOST))))
     [java] ; (DEFUN LOGICAL-PATHNAME (PATHSPEC) (TYPECASE PATHSPEC (LOGICAL-PATHNAME PATHSPEC) (STRING (%MAKE-LOGICAL-PATHNAME PATHSPEC)) (STREAM (LET ((RESULT (PATHNAME PATHSPEC))) (IF (TYPEP RESULT (QUOTE LOGICAL-PATHNAME)) RESULT (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM RESULT :EXPECTED-TYPE (QUOTE LOGICAL-PATHNAME))))) (T (ERROR (QUOTE TYPE-ERROR) :DATUM PATHSPEC :EXPECTED-TYPE (QUOTE (OR LOGICAL-PATHNAME STRING STREAM))))))
     [java] ; (DEFUN PARSE-NAMESTRING (THING &OPTIONAL HOST (DEFAULT-PATHNAME *DEFAULT-PATHNAME-DEFAULTS*) &KEY (START 0) END JUNK-ALLOWED) (DECLARE (IGNORE JUNK-ALLOWED)) (COND ((EQ HOST :UNSPECIFIC) (SETF HOST NIL)) ((CONSP HOST)) (HOST (SETF HOST (CANONICALIZE-LOGICAL-HOST HOST)))) (TYPECASE THING (STREAM (VALUES (PATHNAME THING) START)) (PATHNAME (VALUES THING START)) (STRING (UNLESS END (SETF END (LENGTH THING))) (%PARSE-NAMESTRING (SUBSEQ THING START END) HOST DEFAULT-PATHNAME)) (T (ERROR (QUOTE TYPE-ERROR) :FORMAT-CONTROL "~S cannot be converted to a pathname." :FORMAT-ARGUMENTS (LIST THING)))))
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DEFUN URL-PATHNAME-SCHEME (P) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (GETF (PATHNAME-HOST P) :SCHEME))
     [java] ; (DEFUN SET-URL-PATHNAME-SCHEME (P V) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (LET ((HOST (PATHNAME-HOST P))) (SETF (GETF HOST :SCHEME) V)) (%INVALIDATE-NAMESTRING P))
     [java] ; (DEFSETF URL-PATHNAME-SCHEME SET-URL-PATHNAME-SCHEME)
     [java] ; (DEFUN URL-PATHNAME-AUTHORITY (P) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (GETF (PATHNAME-HOST P) :AUTHORITY))
     [java] ; (DEFUN SET-URL-PATHNAME-AUTHORITY (P V) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (LET ((HOST (PATHNAME-HOST P))) (SETF (GETF HOST :AUTHORITY) V)) (%INVALIDATE-NAMESTRING P))
     [java] ; (DEFSETF URL-PATHNAME-AUTHORITY SET-URL-PATHNAME-AUTHORITY)
     [java] ; (DEFUN URL-PATHNAME-QUERY (P) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (GETF (PATHNAME-HOST P) :QUERY))
     [java] ; (DEFUN SET-URL-PATHNAME-QUERY (P V) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (LET ((HOST (PATHNAME-HOST P))) (SETF (GETF HOST :QUERY) V)) (%INVALIDATE-NAMESTRING P))
     [java] ; (DEFSETF URL-PATHNAME-QUERY SET-URL-PATHNAME-QUERY)
     [java] ; (DEFUN URL-PATHNAME-FRAGMENT (P) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (GETF (PATHNAME-HOST P) :FRAGMENT))
     [java] ; (DEFUN SET-URL-PATHNAME-FRAGMENT (P V) (UNLESS (PATHNAME-URL-P P) (ERROR "~A is not a URL pathname." P)) (LET ((HOST (PATHNAME-HOST P))) (SETF (GETF HOST :FRAGMENT) V)) (%INVALIDATE-NAMESTRING P))
     [java] ; (DEFSETF URL-PATHNAME-QUERY SET-URL-PATHNAME-FRAGMENT)
     [java] ; (DEFSETF URL-PATHNAME-FRAGMENT SET-URL-PATHNAME-FRAGMENT)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/pathnames.abcl (0.857 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print-object.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (WHEN (AUTOLOADP (QUOTE PRINT-OBJECT)) (FMAKUNBOUND (QUOTE PRINT-OBJECT)))
     [java] ; (DEFGENERIC PRINT-OBJECT (OBJECT STREAM))
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJECT T) STREAM) (PRINT-UNREADABLE-OBJECT (OBJECT STREAM :TYPE T :IDENTITY T) (WRITE-STRING (%WRITE-TO-STRING OBJECT) STREAM)))
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJECT STANDARD-OBJECT) STREAM) (WRITE-STRING (%WRITE-TO-STRING OBJECT) STREAM))
     [java] ; (DEFMETHOD PRINT-OBJECT ((OBJECT STRUCTURE-OBJECT) STREAM) (WRITE-STRING (%WRITE-TO-STRING OBJECT) STREAM))
     [java] ; (DEFMETHOD PRINT-OBJECT ((CLASS CLASS) STREAM) (PRINT-UNREADABLE-OBJECT (CLASS STREAM :IDENTITY T) (FORMAT STREAM "~S ~S" (CLASS-NAME (CLASS-OF CLASS)) (IGNORE-ERRORS (CLASS-NAME CLASS)))) CLASS)
     [java] ; (DEFMETHOD PRINT-OBJECT ((GF GENERIC-FUNCTION) STREAM) (PRINT-UNREADABLE-OBJECT (GF STREAM :IDENTITY T) (FORMAT STREAM "~S ~S" (CLASS-NAME (CLASS-OF GF)) (IGNORE-ERRORS (MOP:GENERIC-FUNCTION-NAME GF)))) GF)
     [java] ; (DEFMETHOD PRINT-OBJECT ((METHOD METHOD) STREAM) (PRINT-UNREADABLE-OBJECT (METHOD STREAM :IDENTITY T) (FORMAT STREAM "~S ~S~{ ~S~} ~S" (CLASS-NAME (CLASS-OF METHOD)) (MOP:GENERIC-FUNCTION-NAME (MOP:METHOD-GENERIC-FUNCTION METHOD)) (METHOD-QUALIFIERS METHOD) (MAPCAR (FUNCTION (LAMBDA (C) (IF (TYPEP C (QUOTE MOP:EQL-SPECIALIZER)) (BACKQ-LIST (QUOTE EQL) (MOP:EQL-SPECIALIZER-OBJECT C)) (CLASS-NAME C)))) (MOP:METHOD-SPECIALIZERS METHOD)))) METHOD)
     [java] ; (DEFMETHOD PRINT-OBJECT ((METHOD-COMBINATION METHOD-COMBINATION) STREAM) (PRINT-UNREADABLE-OBJECT (METHOD-COMBINATION STREAM :IDENTITY T) (FORMAT STREAM "~A ~S" (CLASS-NAME (CLASS-OF METHOD-COMBINATION)) (IGNORE-ERRORS (MOP::METHOD-COMBINATION-NAME METHOD-COMBINATION)))) METHOD-COMBINATION)
     [java] ; (DEFMETHOD PRINT-OBJECT ((RESTART RESTART) STREAM) (IF *PRINT-ESCAPE* (PRINT-UNREADABLE-OBJECT (RESTART STREAM :TYPE T :IDENTITY T) (PRIN1 (RESTART-NAME RESTART) STREAM)) (RESTART-REPORT RESTART STREAM)))
     [java] ; (DEFMETHOD PRINT-OBJECT ((C CONDITION) STREAM) (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (IF (SLOT-BOUNDP C (QUOTE FORMAT-CONTROL)) (APPLY (FUNCTION FORMAT) STREAM (SIMPLE-CONDITION-FORMAT-CONTROL C) (SIMPLE-CONDITION-FORMAT-ARGUMENTS C)) (CALL-NEXT-METHOD))))
     [java] ; (DEFMETHOD PRINT-OBJECT ((C TYPE-ERROR) STREAM) (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (IF (SLOT-BOUNDP C (QUOTE FORMAT-CONTROL)) (APPLY (QUOTE FORMAT) STREAM (SIMPLE-CONDITION-FORMAT-CONTROL C) (SIMPLE-CONDITION-FORMAT-ARGUMENTS C)) (FORMAT STREAM "The value ~S is not of type ~S." (TYPE-ERROR-DATUM C) (TYPE-ERROR-EXPECTED-TYPE C)))))
     [java] ; (DEFMETHOD PRINT-OBJECT ((X UNDEFINED-FUNCTION) STREAM) (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (FORMAT STREAM "The function ~S is undefined." (CELL-ERROR-NAME X))))
     [java] ; (DEFMETHOD PRINT-OBJECT ((X UNBOUND-VARIABLE) STREAM) (IF *PRINT-ESCAPE* (PRINT-UNREADABLE-OBJECT (X STREAM :IDENTITY T) (FORMAT STREAM "~S ~S" (TYPE-OF X) (CELL-ERROR-NAME X))) (FORMAT STREAM "The variable ~S is unbound." (CELL-ERROR-NAME X))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/print-object.abcl (1.239 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/print-unreadable-object.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN %PRINT-UNREADABLE-OBJECT (OBJECT STREAM TYPE IDENTITY BODY) (SETF STREAM (OUT-SYNONYM-OF STREAM)) (WHEN *PRINT-READABLY* (ERROR (QUOTE PRINT-NOT-READABLE) :OBJECT OBJECT)) (FORMAT STREAM "#<") (WHEN TYPE (FORMAT STREAM "~S" (TYPE-OF OBJECT)) (FORMAT STREAM " ")) (WHEN BODY (FUNCALL BODY)) (WHEN IDENTITY (WHEN (OR BODY (NOT TYPE)) (FORMAT STREAM " ")) (FORMAT STREAM "{~X}" (IDENTITY-HASH-CODE OBJECT))) (FORMAT STREAM ">") NIL)
     [java] ; (DEFMACRO PRINT-UNREADABLE-OBJECT ((OBJECT STREAM &KEY TYPE IDENTITY) &BODY BODY) (BACKQ-LIST (QUOTE %PRINT-UNREADABLE-OBJECT) OBJECT STREAM TYPE IDENTITY (IF BODY (BACKQ-LIST* (QUOTE LAMBDA) NIL BODY) NIL)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/print-unreadable-object.abcl (0.159 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/proclaim.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO DECLAIM (&REST DECLS) (BACKQ-LIST* (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (MAPCAR (LAMBDA (DECL) (BACKQ-LIST (QUOTE PROCLAIM) (BACKQ-LIST (QUOTE QUOTE) DECL))) DECLS)))
     [java] ; (DEFUN DECLARATION-ERROR (NAME) (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "The symbol ~S cannot be both the name of a type and the name of a declaration." :FORMAT-ARGUMENTS (LIST NAME)))
     [java] ; (DEFVAR *INLINE-DECLARATIONS* NIL)
     [java] ; (DEFVAR *DECLARATION-TYPES* (MAKE-HASH-TABLE :TEST (QUOTE EQ)))
     [java] ; (DEFUN CHECK-DECLARATION-TYPE (NAME) (WHEN (GETHASH1 NAME (THE HASH-TABLE *DECLARATION-TYPES*)) (DECLARATION-ERROR NAME)))
     [java] ; (DEFUN PROCLAIM (DECLARATION-SPECIFIER) (UNLESS (SYMBOLP (CAR DECLARATION-SPECIFIER)) (%TYPE-ERROR (CAR DECLARATION-SPECIFIER) (QUOTE SYMBOL))) (UNLESS (LISTP (CDDR DECLARATION-SPECIFIER)) (%TYPE-ERROR (CDDR DECLARATION-SPECIFIER) (QUOTE LIST))) (CASE (CAR DECLARATION-SPECIFIER) (SPECIAL (DOLIST (NAME (CDR DECLARATION-SPECIFIER)) (%DEFVAR NAME))) (OPTIMIZE (DOLIST (SPEC (CDR DECLARATION-SPECIFIER)) (LET ((VAL 3) (QUALITY SPEC)) (WHEN (CONSP SPEC) (SETF QUALITY (%CAR SPEC) VAL (CADR SPEC))) (WHEN (AND (FIXNUMP VAL) (<= 0 VAL 3)) (CASE QUALITY (SPEED (SETF *SPEED* VAL)) (SPACE (SETF *SPACE* VAL)) (SAFETY (SETF *SAFETY* VAL)) (DEBUG (SETF *DEBUG* VAL))))))) (FTYPE (UNLESS (CDR DECLARATION-SPECIFIER) (ERROR "No type specified in FTYPE declaration: ~S" DECLARATION-SPECIFIER)) (APPLY (QUOTE PROCLAIM-FTYPE) (CDR DECLARATION-SPECIFIER))) (TYPE (UNLESS (CDR DECLARATION-SPECIFIER) (ERROR "No type specified in TYPE declaration: ~S" DECLARATION-SPECIFIER)) (APPLY (QUOTE PROCLAIM-TYPE) (CDR DECLARATION-SPECIFIER))) ((INLINE NOTINLINE) (DOLIST (NAME (CDR DECLARATION-SPECIFIER)) (IF (SYMBOLP NAME) (SETF (GET NAME (QUOTE %INLINE)) (CAR DECLARATION-SPECIFIER)) (PUSH (CONS NAME (CAR DECLARATION-SPECIFIER)) *INLINE-DECLARATIONS*)))) (DECLARATION (DOLIST (NAME (CDR DECLARATION-SPECIFIER)) (WHEN (OR (GET NAME (QUOTE DEFTYPE-DEFINITION)) (FIND-CLASS NAME NIL)) (DECLARATION-ERROR NAME)) (SETF (GETHASH NAME (THE HASH-TABLE *DECLARATION-TYPES*)) NAME))) (:EXPLAIN (DOLIST (SPEC (CDR DECLARATION-SPECIFIER)) (LET ((VAL T) (QUALITY SPEC)) (WHEN (CONSP SPEC) (SETF QUALITY (%CAR SPEC)) (WHEN (= (LENGTH SPEC) 2) (SETF VAL (%CADR SPEC)))) (IF VAL (PUSHNEW QUALITY *EXPLAIN*) (SETF *EXPLAIN* (REMOVE QUALITY *EXPLAIN*))))))))
     [java] ; (DEFUN PROCLAIM-TYPE (TYPE &REST NAMES) (DOLIST (NAME NAMES) (SETF (GET NAME (QUOTE PROCLAIMED-TYPE)) TYPE)))
     [java] ; (DEFUN PROCLAIMED-TYPE (NAME) (GET NAME (QUOTE PROCLAIMED-TYPE)))
     [java] ; (DECLAIM (TYPE HASH-TABLE *PROCLAIMED-FTYPES*))
     [java] ; (DEFCONST *PROCLAIMED-FTYPES* (MAKE-HASH-TABLE :TEST (QUOTE EQUAL)))
     [java] ; (DECLAIM (INLINE PROCLAIM-FTYPE-1))
     [java] ; (DEFUN PROCLAIM-FTYPE-1 (FTYPE NAME) (DECLARE (OPTIMIZE SPEED)) (IF (SYMBOLP NAME) (SETF (GET NAME (QUOTE PROCLAIMED-FTYPE)) FTYPE) (SETF (GETHASH NAME *PROCLAIMED-FTYPES*) FTYPE)))
     [java] ; (DECLAIM (NOTINLINE PROCLAIM-FTYPE-1))
     [java] ; (DEFUN PROCLAIM-FTYPE (FTYPE &REST NAMES) (DECLARE (OPTIMIZE SPEED)) (DECLARE (INLINE PROCLAIM-FTYPE-1)) (DOLIST (NAME NAMES) (PROCLAIM-FTYPE-1 FTYPE NAME)))
     [java] ; (DEFUN PROCLAIMED-FTYPE (NAME) (IF (SYMBOLP NAME) (GET NAME (QUOTE PROCLAIMED-FTYPE)) (GETHASH1 NAME *PROCLAIMED-FTYPES*)))
     [java] ; (DEFUN FTYPE-RESULT-TYPE (FTYPE) (IF (ATOM FTYPE) (QUOTE *) (LET ((RESULT-TYPE (THIRD FTYPE))) (IF RESULT-TYPE RESULT-TYPE (QUOTE *)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/proclaim.abcl (0.248 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/profiler.lisp ...
     [java] ; (IN-PACKAGE #:PROFILER)
     [java] ; (DEFVAR *TYPE* NIL)
     [java] ; (DEFVAR *GRANULARITY* 1 "Sampling interval (in milliseconds).")
     [java] ; (DEFVAR *HIDDEN-FUNCTIONS* (QUOTE (FUNCALL APPLY EVAL SYSTEM::%EVAL SYSTEM:INTERACTIVE-EVAL TOP-LEVEL::REPL TOP-LEVEL::TOP-LEVEL-LOOP)))
     [java] ; (DEFSTRUCT (PROFILE-INFO (:CONSTRUCTOR MAKE-PROFILE-INFO (OBJECT FULL-COUNT HOT-COUNT))) OBJECT FULL-COUNT HOT-COUNT)
     [java] ; (DEFUN LIST-CALLED-OBJECTS NIL (LET ((RESULT (QUOTE NIL))) (DOLIST (PKG (LIST-ALL-PACKAGES)) (DOLIST (SYM (SYSTEM:PACKAGE-SYMBOLS PKG)) (UNLESS (MEMQ SYM *HIDDEN-FUNCTIONS*) (WHEN (FBOUNDP SYM) (LET* ((DEFINITION (FDEFINITION SYM)) (FULL-COUNT (SYSTEM:CALL-COUNT DEFINITION)) (HOT-COUNT (SYSTEM:HOT-COUNT DEFINITION))) (UNLESS (ZEROP FULL-COUNT) (COND ((TYPEP DEFINITION (QUOTE GENERIC-FUNCTION)) (PUSH (MAKE-PROFILE-INFO DEFINITION FULL-COUNT HOT-COUNT) RESULT) (DOLIST (METHOD (MOP:GENERIC-FUNCTION-METHODS DEFINITION)) (LET ((FUNCTION (MOP:METHOD-FUNCTION METHOD))) (SETF FULL-COUNT (SYSTEM:CALL-COUNT FUNCTION)) (SETF HOT-COUNT (SYSTEM:HOT-COUNT FUNCTION))) (UNLESS (ZEROP FULL-COUNT) (PUSH (MAKE-PROFILE-INFO METHOD FULL-COUNT HOT-COUNT) RESULT)))) (T (PUSH (MAKE-PROFILE-INFO SYM FULL-COUNT HOT-COUNT) RESULT))))))))) (REMOVE-DUPLICATES RESULT :KEY (QUOTE PROFILE-INFO-OBJECT) :TEST (QUOTE EQ))))
     [java] ; (DEFUN OBJECT-NAME (OBJECT) (COND ((SYMBOLP OBJECT) OBJECT) ((TYPEP OBJECT (QUOTE GENERIC-FUNCTION)) (MOP:GENERIC-FUNCTION-NAME OBJECT)) ((TYPEP OBJECT (QUOTE METHOD)) (LIST (QUOTE METHOD) (MOP:GENERIC-FUNCTION-NAME (MOP:METHOD-GENERIC-FUNCTION OBJECT)) (MOP:METHOD-SPECIALIZERS OBJECT)))))
     [java] ; (DEFUN OBJECT-COMPILED-FUNCTION-P (OBJECT) (COND ((SYMBOLP OBJECT) (COMPILED-FUNCTION-P (FDEFINITION OBJECT))) ((TYPEP OBJECT (QUOTE METHOD)) (COMPILED-FUNCTION-P (MOP:METHOD-FUNCTION OBJECT))) (T (COMPILED-FUNCTION-P OBJECT))))
     [java] ; (DEFUN SHOW-CALL-COUNT (INFO MAX-COUNT) (LET* ((OBJECT (PROFILE-INFO-OBJECT INFO)) (COUNT (PROFILE-INFO-FULL-COUNT INFO))) (IF MAX-COUNT (FORMAT T "~5,1F ~8D ~S~A~%" (/ (* COUNT 100.0f0) MAX-COUNT) COUNT (OBJECT-NAME OBJECT) (IF (OBJECT-COMPILED-FUNCTION-P OBJECT) "" " [interpreted function]")) (FORMAT T "~8D ~S~A~%" COUNT (OBJECT-NAME OBJECT) (IF (OBJECT-COMPILED-FUNCTION-P OBJECT) "" " [interpreted function]")))))
     [java] ; (DEFUN SHOW-HOT-COUNT (INFO MAX-COUNT) (LET* ((OBJECT (PROFILE-INFO-OBJECT INFO)) (COUNT (PROFILE-INFO-HOT-COUNT INFO))) (IF MAX-COUNT (FORMAT T "~5,1F ~8D ~S~A~%" (/ (* COUNT 100.0f0) MAX-COUNT) COUNT (OBJECT-NAME OBJECT) (IF (OBJECT-COMPILED-FUNCTION-P OBJECT) "" " [interpreted function]")) (FORMAT T "~8D ~S~A~%" COUNT (OBJECT-NAME OBJECT) (IF (OBJECT-COMPILED-FUNCTION-P OBJECT) "" " [interpreted function]")))))
     [java] ; (DEFUN SHOW-CALL-COUNTS NIL (LET ((LIST (LIST-CALLED-OBJECTS))) (SETF LIST (SORT LIST (FUNCTION <) :KEY (QUOTE PROFILE-INFO-FULL-COUNT))) (LET ((MAX-COUNT NIL)) (WHEN (EQ *TYPE* :TIME) (LET ((LAST-INFO (CAR (LAST LIST)))) (SETF MAX-COUNT (IF LAST-INFO (PROFILE-INFO-FULL-COUNT LAST-INFO) NIL)) (WHEN (EQL MAX-COUNT 0) (SETF MAX-COUNT NIL)))) (DOLIST (INFO LIST) (SHOW-CALL-COUNT INFO MAX-COUNT)))) (VALUES))
     [java] ; (DEFUN SHOW-HOT-COUNTS NIL (LET ((LIST (LIST-CALLED-OBJECTS))) (SETF LIST (SORT LIST (FUNCTION <) :KEY (QUOTE PROFILE-INFO-HOT-COUNT))) (LET ((MAX-COUNT NIL)) (WHEN (EQ *TYPE* :TIME) (LET ((LAST-INFO (CAR (LAST LIST)))) (SETF MAX-COUNT (IF LAST-INFO (PROFILE-INFO-HOT-COUNT LAST-INFO) NIL)) (WHEN (EQL MAX-COUNT 0) (SETF MAX-COUNT NIL)))) (DOLIST (INFO LIST) (SHOW-HOT-COUNT INFO MAX-COUNT)))) (VALUES))
     [java] ; (DEFUN START-PROFILER (&KEY TYPE) "Starts the profiler.
     [java]   :TYPE may be either :TIME (statistical sampling) or :COUNT-ONLY (exact call
     [java]   counts)." (UNLESS TYPE (SETF TYPE :TIME)) (UNLESS (MEMQ TYPE (QUOTE (:TIME :COUNT-ONLY))) (ERROR ":TYPE must be :TIME or :COUNT-ONLY")) (SETF *TYPE* TYPE) (%START-PROFILER TYPE *GRANULARITY*))
     [java] ; (DEFMACRO WITH-PROFILING ((&KEY TYPE) &BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE UNWIND-PROTECT) (SYSTEM::BACKQ-LIST* (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE START-PROFILER) (QUOTE :TYPE) TYPE) BODY) (QUOTE ((STOP-PROFILER)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/profiler.abcl (0.753 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/prog.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFMACRO PROG (VL &REST BODY &AUX (DECL NIL)) (DO NIL ((OR (ENDP BODY) (NOT (CONSP (CAR BODY))) (NOT (EQ (CAAR BODY) (QUOTE DECLARE)))) (SYSTEM::BACKQ-LIST (QUOTE BLOCK) NIL (SYSTEM::BACKQ-LIST* (QUOTE LET) VL (SYSTEM::BACKQ-APPEND DECL (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (QUOTE TAGBODY) BODY)))))) (PUSH (CAR BODY) DECL) (POP BODY)))
     [java] ; (DEFMACRO PROG* (VL &REST BODY &AUX (DECL NIL)) (DO NIL ((OR (ENDP BODY) (NOT (CONSP (CAR BODY))) (NOT (EQ (CAAR BODY) (QUOTE DECLARE)))) (SYSTEM::BACKQ-LIST (QUOTE BLOCK) NIL (SYSTEM::BACKQ-LIST* (QUOTE LET*) VL (SYSTEM::BACKQ-APPEND DECL (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (QUOTE TAGBODY) BODY)))))) (PUSH (CAR BODY) DECL) (POP BODY)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/prog.abcl (0.063 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/psetf.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO PSETF (&REST ARGS &ENVIRONMENT ENV) "This is to SETF as PSETQ is to SETQ.  Args are alternating place
     [java]    expressions and values to go into those places.  All of the subforms and
     [java]    values are determined, left to right, and only then are the locations
     [java]    updated.  Returns NIL." (COLLECT ((LET*-BINDINGS) (MV-BINDINGS) (SETTERS)) (DO ((A ARGS (CDDR A))) ((ENDP A)) (WHEN (ENDP (CDR A)) (ERROR (QUOTE SIMPLE-PROGRAM-ERROR) :FORMAT-CONTROL "Odd number of arguments to PSETF.")) (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION (MACROEXPAND-1 (CAR A) ENV) ENV) (DECLARE (IGNORE GETTER)) (LET*-BINDINGS (MAPCAR (FUNCTION LIST) DUMMIES VALS)) (MV-BINDINGS (LIST NEWVAL (CADR A))) (SETTERS SETTER))) (LABELS ((THUNK (LET*-BINDINGS MV-BINDINGS) (IF LET*-BINDINGS (BACKQ-LIST (QUOTE LET*) (CAR LET*-BINDINGS) (BACKQ-CONS (QUOTE MULTIPLE-VALUE-BIND) (BACKQ-APPEND (CAR MV-BINDINGS) (BACKQ-LIST (THUNK (CDR LET*-BINDINGS) (CDR MV-BINDINGS)))))) (BACKQ-CONS (QUOTE PROGN) (BACKQ-APPEND (SETTERS) (QUOTE (NIL))))))) (THUNK (LET*-BINDINGS) (MV-BINDINGS)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/psetf.abcl (0.09 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/query.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN QUERY-READLINE NIL (FORCE-OUTPUT *QUERY-IO*) (STRING-TRIM (QUOTE (#\  #\Tab)) (READ-LINE *QUERY-IO*)))
     [java] ; (DEFUN Y-OR-N-P (&OPTIONAL FORMAT-STRING &REST ARGUMENTS) (WHEN FORMAT-STRING (FRESH-LINE *QUERY-IO*) (APPLY (FUNCTION FORMAT) *QUERY-IO* FORMAT-STRING ARGUMENTS)) (LOOP (LET* ((LINE (QUERY-READLINE)) (ANS (IF (STRING= LINE "") #\? (SCHAR LINE 0)))) (UNLESS (WHITESPACEP ANS) (CASE ANS ((#\y #\Y) (RETURN T)) ((#\n #\N) (RETURN NIL)) (T (WRITE-LINE "Type \"y\" for yes or \"n\" for no. " *QUERY-IO*) (WHEN FORMAT-STRING (APPLY (FUNCTION FORMAT) *QUERY-IO* FORMAT-STRING ARGUMENTS)) (FORCE-OUTPUT *QUERY-IO*)))))))
     [java] ; (DEFUN YES-OR-NO-P (&OPTIONAL FORMAT-STRING &REST ARGUMENTS) (CLEAR-INPUT *QUERY-IO*) (WHEN FORMAT-STRING (FRESH-LINE *QUERY-IO*) (APPLY (FUNCTION FORMAT) *QUERY-IO* FORMAT-STRING ARGUMENTS)) (DO ((ANS (QUERY-READLINE) (QUERY-READLINE))) (NIL) (COND ((STRING-EQUAL ANS "YES") (RETURN T)) ((STRING-EQUAL ANS "NO") (RETURN NIL)) (T (WRITE-LINE "Type \"yes\" for yes or \"no\" for no. " *QUERY-IO*) (WHEN FORMAT-STRING (APPLY (FUNCTION FORMAT) *QUERY-IO* FORMAT-STRING ARGUMENTS))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/query.abcl (0.094 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-circle.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFVAR *SHARP-EQUAL-CIRCLE-TABLE*)
     [java] ; (DEFUN CIRCLE-SUBST (OLD-NEW-ALIST TREE) (MACROLET ((RECURSABLE-ELEMENT-P (SUBTREE) (BACKQ-LIST* (QUOTE TYPEP) SUBTREE (QUOTE ((QUOTE (OR CONS (ARRAY T) STRUCTURE-OBJECT STANDARD-OBJECT)))))) (ELEMENT-REPLACEMENT (SUBTREE) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE ENTRY) (BACKQ-LIST* (QUOTE FIND) SUBTREE (QUOTE (OLD-NEW-ALIST :KEY (FUNCTION SECOND)))))) (BACKQ-LIST (QUOTE IF) (QUOTE ENTRY) (QUOTE (THIRD ENTRY)) SUBTREE)))) (COND ((NOT (RECURSABLE-ELEMENT-P TREE)) (ELEMENT-REPLACEMENT TREE)) ((NULL (GETHASH TREE *SHARP-EQUAL-CIRCLE-TABLE*)) (COND ((TYPEP TREE (QUOTE STRUCTURE-OBJECT)) (SETF (GETHASH TREE *SHARP-EQUAL-CIRCLE-TABLE*) T) (DO ((I 0 (1+ I)) (END (STRUCTURE-LENGTH TREE))) ((= I END)) (LET* ((OLD (STRUCTURE-REF TREE I)) (NEW (CIRCLE-SUBST OLD-NEW-ALIST OLD))) (UNLESS (EQ OLD NEW) (STRUCTURE-SET TREE I NEW))))) ((ARRAYP TREE) (SETF (GETHASH TREE *SHARP-EQUAL-CIRCLE-TABLE*) T) (DO ((I 0 (1+ I)) (END (ARRAY-TOTAL-SIZE TREE))) ((>= I END)) (LET* ((OLD (ROW-MAJOR-AREF TREE I)) (NEW (CIRCLE-SUBST OLD-NEW-ALIST OLD))) (UNLESS (EQ OLD NEW) (SETF (ROW-MAJOR-AREF TREE I) NEW))))) (T (DO ((SUBTREE TREE (CDR SUBTREE))) ((OR (NOT (CONSP SUBTREE)) (GETHASH SUBTREE *SHARP-EQUAL-CIRCLE-TABLE*))) (SETF (GETHASH SUBTREE *SHARP-EQUAL-CIRCLE-TABLE*) T) (LET* ((C (CAR SUBTREE)) (D (CDR SUBTREE)) (A (IF (RECURSABLE-ELEMENT-P C) (CIRCLE-SUBST OLD-NEW-ALIST C) (ELEMENT-REPLACEMENT C))) (B (COND ((CONSP D) D) ((RECURSABLE-ELEMENT-P D) (CIRCLE-SUBST OLD-NEW-ALIST D)) (T (ELEMENT-REPLACEMENT D))))) (UNLESS (EQ A C) (RPLACA SUBTREE A)) (UNLESS (EQ D B) (RPLACD SUBTREE B)))))) TREE) (T TREE))))
     [java] ; (DEFVAR *SHARP-SHARP-ALIST* NIL)
     [java] ; (DEFUN SHARP-EQUAL (STREAM LABEL READTABLE) (WHEN *READ-SUPPRESS* (RETURN-FROM SHARP-EQUAL (VALUES))) (UNLESS LABEL (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL "Missing label for #=")) (WHEN (OR (ASSOC LABEL *SHARP-SHARP-ALIST*) (ASSOC LABEL *SHARP-EQUAL-ALIST*)) (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL "Multiply defined label: #~D=" :FORMAT-ARGUMENTS (LIST LABEL))) (LET* ((TAG (GENSYM)) (*SHARP-SHARP-ALIST* (CONS (LIST LABEL TAG NIL) *SHARP-SHARP-ALIST*)) (OBJ (LET ((*READTABLE* READTABLE)) (READ STREAM T NIL T)))) (WHEN (EQ OBJ TAG) (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL "Must tag something more than just #~D#" :FORMAT-ARGUMENTS (LIST LABEL))) (PUSH (LIST LABEL TAG OBJ) *SHARP-EQUAL-ALIST*) (WHEN (THIRD (CAR *SHARP-SHARP-ALIST*)) (LET ((*SHARP-EQUAL-CIRCLE-TABLE* (MAKE-HASH-TABLE :TEST (QUOTE EQ) :SIZE 20))) (CIRCLE-SUBST *SHARP-EQUAL-ALIST* OBJ))) OBJ))
     [java] ; (DEFUN SHARP-SHARP (STREAM IGNORE LABEL) (DECLARE (IGNORE IGNORE)) (WHEN *READ-SUPPRESS* (RETURN-FROM SHARP-SHARP NIL)) (UNLESS LABEL (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL "Missing label for ##")) (LET ((ENTRY (ASSOC LABEL *SHARP-EQUAL-ALIST*))) (IF ENTRY (THIRD ENTRY) (LET ((PAIR (ASSOC LABEL *SHARP-SHARP-ALIST*))) (UNLESS PAIR (ERROR (QUOTE READER-ERROR) :STREAM STREAM :FORMAT-CONTROL "Object is not labelled #~S#" :FORMAT-ARGUMENTS (LIST LABEL))) (SETF (THIRD PAIR) T) (SECOND PAIR)))))
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\= (FUNCTION (LAMBDA (STREAM IGNORE LABEL) (DECLARE (IGNORE IGNORE)) (SHARP-EQUAL STREAM LABEL *READTABLE*))) +STANDARD-READTABLE+)
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\# (FUNCTION SHARP-SHARP) +STANDARD-READTABLE+)
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\= (FUNCTION (LAMBDA (STREAM IGNORE LABEL) (DECLARE (IGNORE IGNORE)) (SHARP-EQUAL STREAM LABEL (GET-FASL-READTABLE)))) (GET-FASL-READTABLE))
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\# (FUNCTION SHARP-SHARP) (GET-FASL-READTABLE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/read-circle.abcl (0.235 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-conditional.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN READ-FEATURE (STREAM) (LET* ((*PACKAGE* +KEYWORD-PACKAGE+) (*READ-SUPPRESS* NIL)) (IF (FEATUREP (READ STREAM T NIL T)) #\+ #\-)))
     [java] ; (DEFUN READ-CONDITIONAL (STREAM SUBCHAR INT) (DECLARE (IGNORE INT)) (IF (EQL SUBCHAR (READ-FEATURE STREAM)) (READ STREAM T NIL T) (LET ((*READ-SUPPRESS* T)) (READ STREAM T NIL T) (VALUES))))
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\+ (FUNCTION READ-CONDITIONAL) +STANDARD-READTABLE+)
     [java] ; (SET-DISPATCH-MACRO-CHARACTER #\# #\- (FUNCTION READ-CONDITIONAL) +STANDARD-READTABLE+)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/read-conditional.abcl (0.138 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-from-string.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN READ-FROM-STRING (STRING &OPTIONAL (EOF-ERROR-P T) EOF-VALUE &KEY (START 0) END PRESERVE-WHITESPACE) (%READ-FROM-STRING STRING EOF-ERROR-P EOF-VALUE START END PRESERVE-WHITESPACE))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/read-from-string.abcl (0.046 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/read-sequence.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN READ-SEQUENCE (SEQUENCE STREAM &KEY (START 0) END) (DECLARE (TYPE STREAM STREAM)) (REQUIRE-TYPE START (QUOTE (INTEGER 0))) (IF END (REQUIRE-TYPE END (QUOTE (INTEGER 0))) (SETF END (LENGTH SEQUENCE))) (LET* ((ELEMENT-TYPE (EXPAND-DEFTYPE (STREAM-ELEMENT-TYPE STREAM)))) (COND ((EQ ELEMENT-TYPE (QUOTE CHARACTER)) (DO ((POS START (1+ POS))) ((>= POS END) POS) (LET ((ELEMENT (READ-CHAR STREAM NIL :EOF))) (WHEN (EQ ELEMENT :EOF) (RETURN POS)) (SETF (ELT SEQUENCE POS) ELEMENT)))) ((EQUAL ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8))) (IF (AND (VECTORP SEQUENCE) (EQUAL (ARRAY-ELEMENT-TYPE SEQUENCE) (QUOTE (UNSIGNED-BYTE 8)))) (READ-VECTOR-UNSIGNED-BYTE-8 SEQUENCE STREAM START END) (DO ((POS START (1+ POS))) ((>= POS END) POS) (LET ((ELEMENT (READ-8-BITS STREAM NIL :EOF))) (WHEN (EQ ELEMENT :EOF) (RETURN POS)) (SETF (ELT SEQUENCE POS) ELEMENT))))) (T (DO ((POS START (1+ POS))) ((>= POS END) POS) (LET ((ELEMENT (READ-BYTE STREAM NIL :EOF))) (WHEN (EQ ELEMENT :EOF) (RETURN POS)) (SETF (ELT SEQUENCE POS) ELEMENT)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/read-sequence.abcl (0.07 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/reduce.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO LIST-REDUCE (FUNCTION SEQUENCE START END INITIAL-VALUE IVP KEY) (LET ((WHAT (BACKQ-LIST* (QUOTE IF) KEY (BACKQ-LIST* (QUOTE FUNCALL) KEY (QUOTE ((CAR SEQUENCE)))) (QUOTE ((CAR SEQUENCE)))))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE SEQUENCE) (BACKQ-LIST (QUOTE NTHCDR) START SEQUENCE))) (BACKQ-LIST (QUOTE DO) (BACKQ-LIST (BACKQ-LIST* (QUOTE COUNT) (BACKQ-LIST (QUOTE IF) IVP START (BACKQ-LIST (QUOTE 1+) START)) (QUOTE ((1+ COUNT)))) (BACKQ-LIST* (QUOTE SEQUENCE) (BACKQ-LIST* (QUOTE IF) IVP (QUOTE (SEQUENCE (CDR SEQUENCE)))) (QUOTE ((CDR SEQUENCE)))) (BACKQ-LIST (QUOTE VALUE) (BACKQ-LIST (QUOTE IF) IVP INITIAL-VALUE WHAT) (BACKQ-LIST (QUOTE FUNCALL) FUNCTION (QUOTE VALUE) WHAT))) (BACKQ-CONS (BACKQ-LIST (QUOTE =) (QUOTE COUNT) END) (QUOTE (VALUE)))))))
     [java] ; (DEFMACRO LIST-REDUCE-FROM-END (FUNCTION SEQUENCE START END INITIAL-VALUE IVP KEY) (LET ((WHAT (BACKQ-LIST* (QUOTE IF) KEY (BACKQ-LIST* (QUOTE FUNCALL) KEY (QUOTE ((CAR SEQUENCE)))) (QUOTE ((CAR SEQUENCE)))))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE SEQUENCE) (BACKQ-LIST (QUOTE NTHCDR) (BACKQ-LIST (QUOTE -) (BACKQ-LIST (QUOTE LENGTH) SEQUENCE) END) (BACKQ-LIST (QUOTE REVERSE) SEQUENCE)))) (BACKQ-LIST (QUOTE DO) (BACKQ-LIST (BACKQ-LIST* (QUOTE COUNT) (BACKQ-LIST (QUOTE IF) IVP START (BACKQ-LIST (QUOTE 1+) START)) (QUOTE ((1+ COUNT)))) (BACKQ-LIST* (QUOTE SEQUENCE) (BACKQ-LIST* (QUOTE IF) IVP (QUOTE (SEQUENCE (CDR SEQUENCE)))) (QUOTE ((CDR SEQUENCE)))) (BACKQ-LIST (QUOTE VALUE) (BACKQ-LIST (QUOTE IF) IVP INITIAL-VALUE WHAT) (BACKQ-LIST* (QUOTE FUNCALL) FUNCTION WHAT (QUOTE (VALUE))))) (BACKQ-CONS (BACKQ-LIST (QUOTE =) (QUOTE COUNT) END) (QUOTE (VALUE)))))))
     [java] ; (DEFUN REDUCE (FUNCTION SEQUENCE &REST ARGS &KEY FROM-END (START 0) END (INITIAL-VALUE NIL IVP) KEY) (UNLESS END (SETQ END (LENGTH SEQUENCE))) (IF (= END START) (IF IVP INITIAL-VALUE (FUNCALL FUNCTION)) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (LIST-REDUCE-FROM-END FUNCTION SEQUENCE START END INITIAL-VALUE IVP KEY) (LIST-REDUCE FUNCTION SEQUENCE START END INITIAL-VALUE IVP KEY)) (LET* ((DISP (IF FROM-END -1 1)) (INDEX (IF FROM-END (1- END) START)) (TERMINUS (IF FROM-END (1- START) END)) (VALUE (IF IVP INITIAL-VALUE (LET ((ELT (AREF SEQUENCE INDEX))) (SETF INDEX (+ INDEX DISP)) (IF KEY (FUNCALL KEY ELT) ELT)))) (ELEMENT NIL)) (DO* NIL ((= INDEX TERMINUS) VALUE) (SETF ELEMENT (AREF SEQUENCE INDEX) INDEX (+ INDEX DISP) ELEMENT (IF KEY (FUNCALL KEY ELEMENT) ELEMENT) VALUE (FUNCALL FUNCTION (IF FROM-END ELEMENT VALUE) (IF FROM-END VALUE ELEMENT))))) (APPLY (FUNCTION SEQUENCE:REDUCE) FUNCTION SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/reduce.abcl (0.152 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/remf.lisp ...
     [java] ; (DEFMACRO REMF (PLACE INDICATOR &ENVIRONMENT ENV) "Place may be any place expression acceptable to SETF, and is expected
     [java]    to hold a property list or (). This list is destructively altered to
     [java]    remove the property specified by the indicator. Returns T if such a
     [java]    property was present, NIL if not." (MULTIPLE-VALUE-BIND (DUMMIES VALS NEWVAL SETTER GETTER) (GET-SETF-EXPANSION PLACE ENV) (DO* ((D DUMMIES (CDR D)) (V VALS (CDR V)) (LET-LIST NIL) (IND-TEMP (GENSYM)) (LOCAL1 (GENSYM)) (LOCAL2 (GENSYM))) ((NULL D) (PUSH (LIST IND-TEMP INDICATOR) LET-LIST) (PUSH (LIST (CAR NEWVAL) GETTER) LET-LIST) (SYSTEM::BACKQ-LIST (QUOTE LET*) (NREVERSE LET-LIST) (SYSTEM::BACKQ-LIST (QUOTE DO) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST LOCAL1 (CAR NEWVAL) (SYSTEM::BACKQ-LIST (QUOTE CDDR) LOCAL1)) (SYSTEM::BACKQ-LIST LOCAL2 NIL LOCAL1)) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE ATOM) LOCAL1) (QUOTE (NIL))) (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (QUOTE ATOM) (SYSTEM::BACKQ-LIST (QUOTE CDR) LOCAL1)) (QUOTE ((ERROR "Odd-length property list in REMF.")))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (QUOTE EQ) (SYSTEM::BACKQ-LIST (QUOTE CAR) LOCAL1) IND-TEMP) (SYSTEM::BACKQ-LIST (QUOTE COND) (SYSTEM::BACKQ-LIST* LOCAL2 (SYSTEM::BACKQ-LIST (QUOTE RPLACD) (SYSTEM::BACKQ-LIST (QUOTE CDR) LOCAL2) (SYSTEM::BACKQ-LIST (QUOTE CDDR) LOCAL1)) (QUOTE ((RETURN T)))) (SYSTEM::BACKQ-LIST* (QUOTE T) (SYSTEM::BACKQ-LIST (QUOTE SETQ) (CAR NEWVAL) (SYSTEM::BACKQ-LIST (QUOTE CDDR) (CAR NEWVAL))) SETTER (QUOTE ((RETURN T)))))))))) (PUSH (LIST (CAR D) (CAR V)) LET-LIST))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/remf.abcl (0.069 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/remove-duplicates.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LIST-REMOVE-DUPLICATES (LIST TEST TEST-NOT START END KEY FROM-END) (LET* ((RESULT (LIST NIL)) (SPLICE RESULT) (CURRENT LIST)) (DO ((INDEX 0 (1+ INDEX))) ((= INDEX START)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR CURRENT))))) (SETQ CURRENT (CDR CURRENT))) (DO ((INDEX START (1+ INDEX))) ((OR (AND END (= INDEX END)) (ATOM CURRENT))) (IF (OR (AND FROM-END (NOT (MEMBER (APPLY-KEY KEY (CAR CURRENT)) (NTHCDR (1+ START) RESULT) :TEST TEST :TEST-NOT TEST-NOT :KEY KEY))) (AND (NOT FROM-END) (NOT (DO ((IT (APPLY-KEY KEY (CAR CURRENT))) (L (CDR CURRENT) (CDR L)) (I (1+ INDEX) (1+ I))) ((OR (ATOM L) (AND END (= I END))) NIL) (IF (IF TEST-NOT (NOT (FUNCALL TEST-NOT IT (APPLY-KEY KEY (CAR L)))) (FUNCALL TEST IT (APPLY-KEY KEY (CAR L)))) (RETURN T)))))) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR CURRENT)))))) (SETQ CURRENT (CDR CURRENT))) (DO NIL ((ATOM CURRENT)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (CAR CURRENT))))) (SETQ CURRENT (CDR CURRENT))) (CDR RESULT)))
     [java] ; (DEFUN VECTOR-REMOVE-DUPLICATES (VECTOR TEST TEST-NOT START END KEY FROM-END &OPTIONAL (LENGTH (LENGTH VECTOR))) (WHEN (NULL END) (SETF END (LENGTH VECTOR))) (LET ((RESULT (MAKE-SEQUENCE-LIKE VECTOR LENGTH)) (INDEX 0) (JNDEX START)) (DO NIL ((= INDEX START)) (SETF (AREF RESULT INDEX) (AREF VECTOR INDEX)) (SETQ INDEX (1+ INDEX))) (DO ((ELT)) ((= INDEX END)) (SETQ ELT (AREF VECTOR INDEX)) (UNLESS (OR (AND FROM-END (POSITION (APPLY-KEY KEY ELT) RESULT :START START :END JNDEX :TEST TEST :TEST-NOT TEST-NOT :KEY KEY)) (AND (NOT FROM-END) (POSITION (APPLY-KEY KEY ELT) VECTOR :START (1+ INDEX) :END END :TEST TEST :TEST-NOT TEST-NOT :KEY KEY))) (SETF (AREF RESULT JNDEX) ELT) (SETQ JNDEX (1+ JNDEX))) (SETQ INDEX (1+ INDEX))) (DO NIL ((= INDEX LENGTH)) (SETF (AREF RESULT JNDEX) (AREF VECTOR INDEX)) (SETQ INDEX (1+ INDEX)) (SETQ JNDEX (1+ JNDEX))) (SHRINK-VECTOR RESULT JNDEX)))
     [java] ; (DEFUN REMOVE-DUPLICATES (SEQUENCE &REST ARGS &KEY (TEST (FUNCTION EQL)) TEST-NOT (START 0) FROM-END END KEY) (SEQUENCE::SEQ-DISPATCH SEQUENCE (WHEN SEQUENCE (IF (AND (EQ TEST (FUNCTION EQL)) (NULL TEST-NOT) (EQL START 0) (NULL FROM-END) (NULL END) (NULL KEY)) (SIMPLE-LIST-REMOVE-DUPLICATES SEQUENCE) (LIST-REMOVE-DUPLICATES SEQUENCE TEST TEST-NOT START END KEY FROM-END))) (VECTOR-REMOVE-DUPLICATES SEQUENCE TEST TEST-NOT START END KEY FROM-END) (APPLY (FUNCTION SEQUENCE:REMOVE-DUPLICATES) SEQUENCE ARGS)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/remove-duplicates.abcl (0.153 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/remove.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO REAL-COUNT (COUNT) (BACKQ-LIST (QUOTE COND) (BACKQ-CONS (BACKQ-LIST (QUOTE NULL) COUNT) (QUOTE (MOST-POSITIVE-FIXNUM))) (BACKQ-LIST (BACKQ-LIST (QUOTE FIXNUMP) COUNT) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) 0 COUNT)) (BACKQ-LIST (BACKQ-LIST (QUOTE INTEGERP) COUNT) (BACKQ-LIST* (QUOTE IF) (BACKQ-LIST (QUOTE MINUSP) COUNT) (QUOTE (0 MOST-POSITIVE-FIXNUM)))) (BACKQ-LIST (QUOTE T) COUNT)))
     [java] ; (DEFMACRO MUMBLE-REMOVE-MACRO (BUMP LEFT BEGIN FINISH RIGHT PRED) (BACKQ-LIST (QUOTE DO) (BACKQ-LIST* (BACKQ-LIST (QUOTE INDEX) BEGIN (BACKQ-CONS BUMP (QUOTE (INDEX)))) (BACKQ-LIST (QUOTE RESULT) (BACKQ-LIST* (QUOTE DO) (BACKQ-CONS (BACKQ-LIST (QUOTE INDEX) LEFT (BACKQ-CONS BUMP (QUOTE (INDEX)))) (QUOTE ((RESULT (MAKE-SEQUENCE-LIKE SEQUENCE LENGTH))))) (BACKQ-CONS (BACKQ-LIST (QUOTE =) (QUOTE INDEX) BEGIN) (QUOTE (RESULT))) (QUOTE ((ASET RESULT INDEX (AREF SEQUENCE INDEX)))))) (BACKQ-LIST (QUOTE NEW-INDEX) BEGIN) (QUOTE ((NUMBER-ZAPPED 0) (THIS-ELEMENT)))) (BACKQ-LIST (BACKQ-LIST* (QUOTE OR) (BACKQ-LIST (QUOTE =) (QUOTE INDEX) FINISH) (QUOTE ((= NUMBER-ZAPPED COUNT)))) (BACKQ-LIST* (QUOTE DO) (BACKQ-LIST (BACKQ-LIST (QUOTE INDEX) (QUOTE INDEX) (BACKQ-CONS BUMP (QUOTE (INDEX)))) (BACKQ-LIST (QUOTE NEW-INDEX) (QUOTE NEW-INDEX) (BACKQ-CONS BUMP (QUOTE (NEW-INDEX))))) (BACKQ-CONS (BACKQ-LIST (QUOTE =) (QUOTE INDEX) RIGHT) (QUOTE ((SHRINK-VECTOR RESULT NEW-INDEX)))) (QUOTE ((ASET RESULT NEW-INDEX (AREF SEQUENCE INDEX)))))) (QUOTE (SETQ THIS-ELEMENT (AREF SEQUENCE INDEX))) (BACKQ-LIST (QUOTE COND) (BACKQ-CONS PRED (QUOTE ((SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED))))) (BACKQ-LIST (QUOTE T) (QUOTE (ASET RESULT NEW-INDEX THIS-ELEMENT)) (BACKQ-LIST (QUOTE SETQ) (QUOTE NEW-INDEX) (BACKQ-CONS BUMP (QUOTE (NEW-INDEX))))))))
     [java] ; (DEFMACRO MUMBLE-REMOVE (PRED) (BACKQ-LIST (QUOTE MUMBLE-REMOVE-MACRO) (QUOTE 1+) 0 (QUOTE START) (QUOTE END) (QUOTE LENGTH) PRED))
     [java] ; (DEFMACRO MUMBLE-REMOVE-FROM-END (PRED) (BACKQ-LIST (QUOTE LET) (QUOTE ((SEQUENCE (COPY-SEQ SEQUENCE)))) (BACKQ-LIST (QUOTE MUMBLE-DELETE-FROM-END) PRED)))
     [java] ; (DEFMACRO NORMAL-MUMBLE-REMOVE NIL (QUOTE (MUMBLE-REMOVE (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (APPLY-KEY KEY THIS-ELEMENT))) (FUNCALL TEST ITEM (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO NORMAL-MUMBLE-REMOVE-FROM-END NIL (QUOTE (MUMBLE-REMOVE-FROM-END (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (APPLY-KEY KEY THIS-ELEMENT))) (FUNCALL TEST ITEM (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO IF-MUMBLE-REMOVE NIL (QUOTE (MUMBLE-REMOVE (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT)))))
     [java] ; (DEFMACRO IF-MUMBLE-REMOVE-FROM-END NIL (QUOTE (MUMBLE-REMOVE-FROM-END (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT)))))
     [java] ; (DEFMACRO IF-NOT-MUMBLE-REMOVE NIL (QUOTE (MUMBLE-REMOVE (NOT (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO IF-NOT-MUMBLE-REMOVE-FROM-END NIL (QUOTE (MUMBLE-REMOVE-FROM-END (NOT (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO LIST-REMOVE-MACRO (PRED REVERSE-P) (BACKQ-LIST (QUOTE LET*) (BACKQ-LIST* (BACKQ-LIST (QUOTE SEQUENCE) (IF REVERSE-P (QUOTE (REVERSE SEQUENCE)) (QUOTE SEQUENCE))) (BACKQ-LIST (QUOTE %START) (IF REVERSE-P (QUOTE (- LENGTH END)) (QUOTE START))) (BACKQ-LIST (QUOTE %END) (IF REVERSE-P (QUOTE (- LENGTH START)) (QUOTE END))) (QUOTE ((SPLICE (LIST NIL)) (RESULTS (DO ((INDEX 0 (1+ INDEX)) (BEFORE-START SPLICE)) ((= INDEX %START) BEFORE-START) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST (POP SEQUENCE)))))))))) (BACKQ-LIST (QUOTE DO) (QUOTE ((INDEX %START (1+ INDEX)) (THIS-ELEMENT) (NUMBER-ZAPPED 0))) (BACKQ-LIST (QUOTE (OR (= INDEX %END) (= NUMBER-ZAPPED COUNT))) (BACKQ-LIST* (QUOTE DO) (QUOTE ((INDEX INDEX (1+ INDEX)))) (BACKQ-LIST (QUOTE (NULL SEQUENCE)) (IF REVERSE-P (QUOTE (NREVERSE (CDR RESULTS))) (QUOTE (CDR RESULTS)))) (QUOTE ((SETQ SPLICE (CDR (RPLACD SPLICE (LIST (POP SEQUENCE))))))))) (QUOTE (SETQ THIS-ELEMENT (POP SEQUENCE))) (BACKQ-LIST* (QUOTE IF) PRED (QUOTE ((SETQ NUMBER-ZAPPED (1+ NUMBER-ZAPPED)) (SETQ SPLICE (CDR (RPLACD SPLICE (LIST THIS-ELEMENT))))))))))
     [java] ; (DEFMACRO LIST-REMOVE (PRED) (BACKQ-LIST* (QUOTE LIST-REMOVE-MACRO) PRED (QUOTE (NIL))))
     [java] ; (DEFMACRO LIST-REMOVE-FROM-END (PRED) (BACKQ-LIST* (QUOTE LIST-REMOVE-MACRO) PRED (QUOTE (T))))
     [java] ; (DEFMACRO NORMAL-LIST-REMOVE NIL (QUOTE (LIST-REMOVE (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (APPLY-KEY KEY THIS-ELEMENT))) (FUNCALL TEST ITEM (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO NORMAL-LIST-REMOVE-FROM-END NIL (QUOTE (LIST-REMOVE-FROM-END (IF TEST-NOT (NOT (FUNCALL TEST-NOT ITEM (APPLY-KEY KEY THIS-ELEMENT))) (FUNCALL TEST ITEM (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO IF-LIST-REMOVE NIL (QUOTE (LIST-REMOVE (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT)))))
     [java] ; (DEFMACRO IF-LIST-REMOVE-FROM-END NIL (QUOTE (LIST-REMOVE-FROM-END (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT)))))
     [java] ; (DEFMACRO IF-NOT-LIST-REMOVE NIL (QUOTE (LIST-REMOVE (NOT (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFMACRO IF-NOT-LIST-REMOVE-FROM-END NIL (QUOTE (LIST-REMOVE-FROM-END (NOT (FUNCALL PREDICATE (APPLY-KEY KEY THIS-ELEMENT))))))
     [java] ; (DEFUN REMOVE (ITEM SEQUENCE &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START 0) END COUNT KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (NORMAL-LIST-REMOVE-FROM-END) (NORMAL-LIST-REMOVE)) (IF FROM-END (NORMAL-MUMBLE-REMOVE-FROM-END) (NORMAL-MUMBLE-REMOVE)) (APPLY (FUNCTION SEQUENCE:REMOVE) ITEM SEQUENCE ARGS))))
     [java] ; (DEFUN REMOVE-IF (PREDICATE SEQUENCE &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (IF-LIST-REMOVE-FROM-END) (IF-LIST-REMOVE)) (IF FROM-END (IF-MUMBLE-REMOVE-FROM-END) (IF-MUMBLE-REMOVE)) (APPLY (FUNCTION SEQUENCE:REMOVE-IF) PREDICATE SEQUENCE ARGS))))
     [java] ; (DEFUN REMOVE-IF-NOT (PREDICATE SEQUENCE &REST ARGS &KEY FROM-END (START 0) END COUNT KEY) (LET* ((LENGTH (LENGTH SEQUENCE)) (END (OR END LENGTH)) (COUNT (REAL-COUNT COUNT))) (SEQUENCE::SEQ-DISPATCH SEQUENCE (IF FROM-END (IF-NOT-LIST-REMOVE-FROM-END) (IF-NOT-LIST-REMOVE)) (IF FROM-END (IF-NOT-MUMBLE-REMOVE-FROM-END) (IF-NOT-MUMBLE-REMOVE)) (APPLY (FUNCTION SEQUENCE:REMOVE-IF-NOT) PREDICATE SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/remove.abcl (0.737 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/replace.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN LIST-REPLACE-FROM-LIST* (TARGET-SEQUENCE SOURCE-SEQUENCE TARGET-START TARGET-END SOURCE-START SOURCE-END) (WHEN (NULL TARGET-END) (SETQ TARGET-END (LENGTH TARGET-SEQUENCE))) (WHEN (NULL SOURCE-END) (SETQ SOURCE-END (LENGTH SOURCE-SEQUENCE))) (LIST-REPLACE-FROM-LIST))
     [java] ; (DEFUN LIST-REPLACE-FROM-VECTOR* (TARGET-SEQUENCE SOURCE-SEQUENCE TARGET-START TARGET-END SOURCE-START SOURCE-END) (WHEN (NULL TARGET-END) (SETQ TARGET-END (LENGTH TARGET-SEQUENCE))) (WHEN (NULL SOURCE-END) (SETQ SOURCE-END (LENGTH SOURCE-SEQUENCE))) (LIST-REPLACE-FROM-MUMBLE))
     [java] ; (DEFUN VECTOR-REPLACE-FROM-LIST* (TARGET-SEQUENCE SOURCE-SEQUENCE TARGET-START TARGET-END SOURCE-START SOURCE-END) (WHEN (NULL TARGET-END) (SETQ TARGET-END (LENGTH TARGET-SEQUENCE))) (WHEN (NULL SOURCE-END) (SETQ SOURCE-END (LENGTH SOURCE-SEQUENCE))) (MUMBLE-REPLACE-FROM-LIST))
     [java] ; (DEFUN VECTOR-REPLACE-FROM-VECTOR* (TARGET-SEQUENCE SOURCE-SEQUENCE TARGET-START TARGET-END SOURCE-START SOURCE-END) (WHEN (NULL TARGET-END) (SETQ TARGET-END (LENGTH TARGET-SEQUENCE))) (WHEN (NULL SOURCE-END) (SETQ SOURCE-END (LENGTH SOURCE-SEQUENCE))) (MUMBLE-REPLACE-FROM-MUMBLE))
     [java] ; (DEFUN REPLACE (TARGET-SEQUENCE SOURCE-SEQUENCE &REST ARGS &KEY ((:START1 TARGET-START) 0) ((:END1 TARGET-END)) ((:START2 SOURCE-START) 0) ((:END2 SOURCE-END))) "The target sequence is destructively modified by copying successive
     [java] elements into it from the source sequence." (LET ((TARGET-END (OR TARGET-END (LENGTH TARGET-SEQUENCE))) (SOURCE-END (OR SOURCE-END (LENGTH SOURCE-SEQUENCE)))) (DECLARE (TYPE (INTEGER 0 2147483647) TARGET-START TARGET-END SOURCE-START SOURCE-END)) (SEQUENCE::SEQ-DISPATCH TARGET-SEQUENCE (SEQUENCE::SEQ-DISPATCH SOURCE-SEQUENCE (LIST-REPLACE-FROM-LIST) (LIST-REPLACE-FROM-MUMBLE) (APPLY (FUNCTION SEQUENCE:REPLACE) TARGET-SEQUENCE SOURCE-SEQUENCE ARGS)) (SEQUENCE::SEQ-DISPATCH SOURCE-SEQUENCE (MUMBLE-REPLACE-FROM-LIST) (MUMBLE-REPLACE-FROM-MUMBLE) (APPLY (FUNCTION SEQUENCE:REPLACE) TARGET-SEQUENCE SOURCE-SEQUENCE ARGS)) (APPLY (FUNCTION SEQUENCE:REPLACE) TARGET-SEQUENCE SOURCE-SEQUENCE ARGS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/replace.abcl (0.246 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/restart.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN READ-EVALUATED-FORM NIL (FRESH-LINE *QUERY-IO*) (%FORMAT *QUERY-IO* "Enter a form to be evaluated:~%") (LIST (EVAL (READ *QUERY-IO*))))
     [java] ; (DEFVAR *RESTART-CLUSTERS* NIL)
     [java] ; (DEFVAR *CONDITION-RESTARTS* NIL)
     [java] ; (DEFSTRUCT RESTART NAME FUNCTION REPORT-FUNCTION INTERACTIVE-FUNCTION (TEST-FUNCTION (FUNCTION (LAMBDA (C) (DECLARE (IGNORE C)) T))))
     [java] ; (DEFMACRO RESTART-BIND (BINDINGS &BODY FORMS) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE *RESTART-CLUSTERS*) (BACKQ-LIST* (QUOTE CONS) (BACKQ-CONS (QUOTE LIST) (MAPCAR (FUNCTION (LAMBDA (BINDING) (BACKQ-LIST* (QUOTE MAKE-RESTART) (QUOTE :NAME) (BACKQ-LIST (QUOTE QUOTE) (CAR BINDING)) (QUOTE :FUNCTION) (CADR BINDING) (CDDR BINDING)))) BINDINGS)) (QUOTE (*RESTART-CLUSTERS*))))) FORMS))
     [java] ; (DEFUN COMPUTE-RESTARTS (&OPTIONAL CONDITION) (LET ((RES NIL)) (MAP-RESTARTS (LAMBDA (RESTART) (PUSH RESTART RES)) CONDITION T) (NREVERSE RES)))
     [java] ; (DEFUN MAP-RESTARTS (FN CONDITION CALL-TEST-P) (LET ((ASSOCIATED NIL) (OTHER NIL)) (DOLIST (ALIST *CONDITION-RESTARTS*) (IF (EQ (CAR ALIST) CONDITION) (SETQ ASSOCIATED (CDR ALIST)) (SETQ OTHER (APPEND (CDR ALIST) OTHER)))) (DOLIST (RESTART-CLUSTER *RESTART-CLUSTERS*) (DOLIST (RESTART RESTART-CLUSTER) (WHEN (AND (OR (NOT CONDITION) (MEMBER RESTART ASSOCIATED) (NOT (MEMBER RESTART OTHER))) (OR (NOT CALL-TEST-P) (FUNCALL (RESTART-TEST-FUNCTION RESTART) CONDITION))) (FUNCALL FN RESTART))))))
     [java] ; (DEFUN RESTART-REPORT (RESTART STREAM) (FUNCALL (OR (RESTART-REPORT-FUNCTION RESTART) (LET ((NAME (RESTART-NAME RESTART))) (LAMBDA (STREAM) (IF NAME (%FORMAT STREAM "~S" NAME) (%FORMAT STREAM "~S" RESTART))))) STREAM))
     [java] ; (DEFUN PRINT-RESTART (RESTART STREAM) (IF *PRINT-ESCAPE* (PRINT-UNREADABLE-OBJECT (RESTART STREAM :TYPE T :IDENTITY T) (PRIN1 (RESTART-NAME RESTART) STREAM)) (RESTART-REPORT RESTART STREAM)))
     [java] ; (DEFUN FIND-RESTART (NAME &OPTIONAL CONDITION) (LET ((RESTARTS (COMPUTE-RESTARTS CONDITION))) (DOLIST (RESTART RESTARTS) (WHEN (OR (EQ RESTART NAME) (EQ (RESTART-NAME RESTART) NAME)) (RETURN-FROM FIND-RESTART RESTART)))))
     [java] ; (DEFUN FIND-RESTART-OR-CONTROL-ERROR (IDENTIFIER &OPTIONAL CONDITION) (OR (FIND-RESTART IDENTIFIER CONDITION) (ERROR (QUOTE CONTROL-ERROR) :FORMAT-CONTROL "Restart ~S is not active." :FORMAT-ARGUMENTS (LIST IDENTIFIER))))
     [java] ; (DEFUN INVOKE-RESTART (RESTART &REST VALUES) (LET ((REAL-RESTART (IF (RESTART-P RESTART) (CATCH (QUOTE FOUND) (MAP-RESTARTS (LAMBDA (R) (WHEN (EQ R RESTART) (THROW (QUOTE FOUND) R))) NIL NIL) (ERROR (QUOTE CONTROL-ERROR) :FORMAT-CONTROL "Restart ~S is not active." :FORMAT-ARGUMENTS (LIST RESTART))) (FIND-RESTART-OR-CONTROL-ERROR RESTART)))) (APPLY (RESTART-FUNCTION REAL-RESTART) VALUES)))
     [java] ; (DEFUN INTERACTIVE-RESTART-ARGUMENTS (REAL-RESTART) (LET ((INTERACTIVE-FUNCTION (RESTART-INTERACTIVE-FUNCTION REAL-RESTART))) (IF INTERACTIVE-FUNCTION (FUNCALL INTERACTIVE-FUNCTION) (QUOTE NIL))))
     [java] ; (DEFUN INVOKE-RESTART-INTERACTIVELY (RESTART) (LET* ((REAL-RESTART (IF (RESTART-P RESTART) (CATCH (QUOTE FOUND) (MAP-RESTARTS (LAMBDA (R) (WHEN (EQ R RESTART) (THROW (QUOTE FOUND) R))) NIL NIL) (ERROR (QUOTE CONTROL-ERROR) :FORMAT-CONTROL "Restart ~S is not active." :FORMAT-ARGUMENTS (LIST RESTART))) (FIND-RESTART-OR-CONTROL-ERROR RESTART))) (ARGS (INTERACTIVE-RESTART-ARGUMENTS REAL-RESTART))) (APPLY (RESTART-FUNCTION REAL-RESTART) ARGS)))
     [java] ; (DEFUN PARSE-KEYWORD-PAIRS (LIST KEYS) (DO ((L LIST (CDDR L)) (K (QUOTE NIL) (LIST* (CADR L) (CAR L) K))) ((OR (NULL L) (NOT (MEMBER (CAR L) KEYS))) (VALUES (NREVERSE K) L))))
     [java] ; (DEFMACRO WITH-KEYWORD-PAIRS ((NAMES EXPRESSION &OPTIONAL KEYWORDS-VAR) &BODY FORMS) (LET ((TEMP (MEMBER (QUOTE &REST) NAMES))) (UNLESS (= (LENGTH TEMP) 2) (ERROR "&REST keyword is ~:[missing~;misplaced~]." TEMP)) (LET ((KEY-VARS (LDIFF NAMES TEMP)) (KEY-VAR (OR KEYWORDS-VAR (GENSYM))) (REST-VAR (CADR TEMP))) (LET ((KEYWORDS (MAPCAR (FUNCTION (LAMBDA (X) (INTERN (STRING X) (FIND-PACKAGE "KEYWORD")))) KEY-VARS))) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-BIND) (BACKQ-LIST KEY-VAR REST-VAR) (BACKQ-LIST (QUOTE PARSE-KEYWORD-PAIRS) EXPRESSION (BACKQ-LIST (QUOTE QUOTE) KEYWORDS)) (BACKQ-LIST* (QUOTE LET) (MAPCAR (FUNCTION (LAMBDA (VAR KEYWORD) (BACKQ-LIST VAR (BACKQ-LIST (QUOTE GETF) KEY-VAR KEYWORD)))) KEY-VARS KEYWORDS) FORMS))))))
     [java] ; (DEFUN TRANSFORM-KEYWORDS (&KEY REPORT INTERACTIVE TEST) (LET ((RESULT NIL)) (WHEN REPORT (SETF RESULT (LIST* (IF (STRINGP REPORT) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (STREAM)) (BACKQ-LIST* (QUOTE WRITE-STRING) REPORT (QUOTE (STREAM))))) (BACKQ-LIST (QUOTE FUNCTION) REPORT)) :REPORT-FUNCTION RESULT))) (WHEN INTERACTIVE (SETF RESULT (LIST* (BACKQ-LIST (QUOTE FUNCTION) INTERACTIVE) :INTERACTIVE-FUNCTION RESULT))) (WHEN TEST (SETF RESULT (LIST* (BACKQ-LIST (QUOTE FUNCTION) TEST) :TEST-FUNCTION RESULT))) (NREVERSE RESULT)))
     [java] ; (DEFUN MUNGE-RESTART-CASE-EXPRESSION (EXPRESSION ENV) (LET ((EXP (MACROEXPAND EXPRESSION ENV))) (IF (CONSP EXP) (LET* ((NAME (CAR EXP)) (ARGS (IF (EQ NAME (QUOTE CERROR)) (CDDR EXP) (CDR EXP)))) (IF (MEMBER NAME (QUOTE (SIGNAL ERROR CERROR WARN))) (LET ((N-COND (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST N-COND (BACKQ-LIST (QUOTE COERCE-TO-CONDITION) (FIRST ARGS) (BACKQ-CONS (QUOTE LIST) (REST ARGS)) (BACKQ-LIST (QUOTE QUOTE) (CASE NAME (WARN (QUOTE SIMPLE-WARNING)) (SIGNAL (QUOTE SIMPLE-CONDITION)) (T (QUOTE SIMPLE-ERROR)))) (BACKQ-LIST (QUOTE QUOTE) NAME)))) (BACKQ-LIST (QUOTE WITH-CONDITION-RESTARTS) N-COND (QUOTE (CAR *RESTART-CLUSTERS*)) (IF (EQ NAME (QUOTE CERROR)) (BACKQ-LIST (QUOTE CERROR) (SECOND EXP) N-COND) (BACKQ-LIST NAME N-COND))))) EXPRESSION)) EXPRESSION)))
     [java] ; (DEFMACRO RESTART-CASE (EXPRESSION &BODY CLAUSES &ENVIRONMENT ENV) (LET ((BLOCK-TAG (GENSYM)) (TEMP-VAR (GENSYM)) (DATA (MAPCAR (FUNCTION (LAMBDA (CLAUSE) (WITH-KEYWORD-PAIRS ((REPORT INTERACTIVE TEST &REST FORMS) (CDDR CLAUSE)) (LIST (CAR CLAUSE) (GENSYM) (TRANSFORM-KEYWORDS :REPORT REPORT :INTERACTIVE INTERACTIVE :TEST TEST) (CADR CLAUSE) FORMS)))) CLAUSES))) (BACKQ-LIST (QUOTE BLOCK) BLOCK-TAG (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-CONS TEMP-VAR (QUOTE (NIL)))) (BACKQ-LIST* (QUOTE TAGBODY) (BACKQ-LIST (QUOTE RESTART-BIND) (MAPCAR (FUNCTION (LAMBDA (DATUM) (LET ((NAME (NTH 0 DATUM)) (TAG (NTH 1 DATUM)) (KEYS (NTH 2 DATUM))) (BACKQ-LIST* NAME (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (&REST TEMP)) (BACKQ-LIST* (QUOTE SETQ) TEMP-VAR (QUOTE (TEMP))) (BACKQ-LIST (QUOTE GO) TAG))) KEYS)))) DATA) (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK-TAG (MUNGE-RESTART-CASE-EXPRESSION EXPRESSION ENV))) (MAPCAN (FUNCTION (LAMBDA (DATUM) (LET ((TAG (NTH 1 DATUM)) (BVL (NTH 3 DATUM)) (BODY (NTH 4 DATUM))) (LIST TAG (BACKQ-LIST (QUOTE RETURN-FROM) BLOCK-TAG (BACKQ-LIST (QUOTE APPLY) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST* (QUOTE LAMBDA) BVL BODY)) TEMP-VAR)))))) DATA))))))
     [java] ; (DEFMACRO WITH-SIMPLE-RESTART ((RESTART-NAME FORMAT-STRING &REST FORMAT-ARGUMENTS) &BODY FORMS) (BACKQ-LIST (QUOTE RESTART-CASE) (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-LIST* RESTART-NAME NIL (QUOTE :REPORT) (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (STREAM)) (BACKQ-LIST* (QUOTE SIMPLE-FORMAT) (QUOTE STREAM) FORMAT-STRING FORMAT-ARGUMENTS)) (QUOTE ((VALUES NIL T))))))
     [java] ; (DEFMACRO WITH-CONDITION-RESTARTS (CONDITION-FORM RESTARTS-FORM &BODY BODY) (LET ((N-COND (GENSYM))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE *CONDITION-RESTARTS*) (BACKQ-LIST* (QUOTE CONS) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST N-COND CONDITION-FORM)) (BACKQ-LIST (QUOTE CONS) N-COND (BACKQ-LIST (QUOTE APPEND) RESTARTS-FORM (BACKQ-LIST (QUOTE CDR) (BACKQ-LIST* (QUOTE ASSOC) N-COND (QUOTE (*CONDITION-RESTARTS*))))))) (QUOTE (*CONDITION-RESTARTS*))))) BODY)))
     [java] ; (DEFUN ABORT (&OPTIONAL CONDITION) (INVOKE-RESTART (FIND-RESTART-OR-CONTROL-ERROR (QUOTE ABORT) CONDITION)) (ERROR (QUOTE CONTROL-ERROR) :FORMAT-CONTROL "ABORT restart failed to transfer control dynamically."))
     [java] ; (DEFUN MUFFLE-WARNING (&OPTIONAL CONDITION) (INVOKE-RESTART (FIND-RESTART-OR-CONTROL-ERROR (QUOTE MUFFLE-WARNING) CONDITION)))
     [java] ; (DEFUN CONTINUE (&OPTIONAL CONDITION) (LET ((RESTART (FIND-RESTART (QUOTE CONTINUE) CONDITION))) (WHEN RESTART (INVOKE-RESTART RESTART))))
     [java] ; (DEFUN STORE-VALUE (VALUE &OPTIONAL CONDITION) (LET ((RESTART (FIND-RESTART (QUOTE STORE-VALUE) CONDITION))) (WHEN RESTART (INVOKE-RESTART RESTART VALUE))))
     [java] ; (DEFUN USE-VALUE (VALUE &OPTIONAL CONDITION) (LET ((RESTART (FIND-RESTART (QUOTE USE-VALUE) CONDITION))) (WHEN RESTART (INVOKE-RESTART RESTART VALUE))))
     [java] ; (DEFUN WARN (DATUM &REST ARGUMENTS) (LET ((CONDITION (COERCE-TO-CONDITION DATUM ARGUMENTS (QUOTE SIMPLE-WARNING) (QUOTE WARN)))) (REQUIRE-TYPE CONDITION (QUOTE WARNING)) (RESTART-CASE (SIGNAL CONDITION) (MUFFLE-WARNING NIL :REPORT "Skip warning." (RETURN-FROM WARN NIL))) (LET ((BADNESS (ETYPECASE CONDITION (STYLE-WARNING (QUOTE STYLE-WARNING)) (WARNING (QUOTE WARNING))))) (FRESH-LINE *ERROR-OUTPUT*) (SIMPLE-FORMAT *ERROR-OUTPUT* "~S: ~A~%" BADNESS CONDITION))) NIL)
     [java] ; (DEFUN STYLE-WARN (FORMAT-CONTROL &REST FORMAT-ARGUMENTS) (WARN (QUOTE STYLE-WARNING) :FORMAT-CONTROL FORMAT-CONTROL :FORMAT-ARGUMENTS FORMAT-ARGUMENTS))
     [java] ; (DEFUN CERROR (CONTINUE-STRING DATUM &REST ARGUMENTS) (WITH-SIMPLE-RESTART (CONTINUE "~A" (APPLY (FUNCTION SIMPLE-FORMAT) NIL CONTINUE-STRING ARGUMENTS)) (LET ((CONDITION (COERCE-TO-CONDITION DATUM ARGUMENTS (QUOTE SIMPLE-ERROR) (QUOTE ERROR)))) (WITH-CONDITION-RESTARTS CONDITION (LIST (FIND-RESTART (QUOTE CONTINUE))) (SIGNAL CONDITION) (INVOKE-DEBUGGER CONDITION)))) NIL)
     [java] ; (DEFUN QUERY-FUNCTION NIL (FORMAT *QUERY-IO* "~&Enter a form to be evaluated: ") (FORCE-OUTPUT *QUERY-IO*) (MULTIPLE-VALUE-LIST (EVAL (READ *QUERY-IO*))))
     [java] ; (DEFUN UNDEFINED-FUNCTION-CALLED (NAME ARGUMENTS) (FINISH-OUTPUT) (LOOP (RESTART-CASE (ERROR (QUOTE UNDEFINED-FUNCTION) :NAME NAME) (CONTINUE NIL :REPORT "Try again.") (USE-VALUE (VALUE) :REPORT "Specify a function to call instead." :INTERACTIVE QUERY-FUNCTION (RETURN-FROM UNDEFINED-FUNCTION-CALLED (APPLY VALUE ARGUMENTS))) (RETURN-VALUE (&REST VALUES) :REPORT (LAMBDA (STREAM) (FORMAT STREAM "Return one or more values from the call to ~S." NAME)) :INTERACTIVE QUERY-FUNCTION (RETURN-FROM UNDEFINED-FUNCTION-CALLED (VALUES-LIST VALUES)))) (WHEN (FBOUNDP NAME) (RETURN (APPLY NAME ARGUMENTS)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/restart.abcl (1.684 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/revappend.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN REVAPPEND (X Y) (DO ((TOP X (CDR TOP)) (RESULT Y (CONS (CAR TOP) RESULT))) ((ENDP TOP) RESULT)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/revappend.abcl (0.042 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/rotatef.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO ROTATEF (&REST ARGS &ENVIRONMENT ENV) (WHEN ARGS (COLLECT ((LET*-BINDINGS) (MV-BINDINGS) (SETTERS) (GETTERS)) (DOLIST (ARG ARGS) (MULTIPLE-VALUE-BIND (TEMPS SUBFORMS STORE-VARS SETTER GETTER) (GET-SETF-EXPANSION ARG ENV) (LOOP FOR TEMP IN TEMPS FOR SUBFORM IN SUBFORMS DO (LET*-BINDINGS (BACKQ-LIST TEMP SUBFORM))) (MV-BINDINGS STORE-VARS) (SETTERS SETTER) (GETTERS GETTER))) (SETTERS NIL) (GETTERS (CAR (GETTERS))) (LABELS ((THUNK (MV-BINDINGS GETTERS) (IF MV-BINDINGS (BACKQ-LIST (BACKQ-LIST* (QUOTE MULTIPLE-VALUE-BIND) (CAR MV-BINDINGS) (CAR GETTERS) (THUNK (CDR MV-BINDINGS) (CDR GETTERS)))) (SETTERS)))) (BACKQ-LIST* (QUOTE LET*) (LET*-BINDINGS) (THUNK (MV-BINDINGS) (CDR (GETTERS))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/rotatef.abcl (0.102 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/run-program.lisp ...
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DEFPARAMETER *IMPLEMENTATIONS* (QUOTE (:JAVA-1.6 :JAVA-1.7 :JAVA-1.8)))
     [java] ; (DEFUN NOT-JAVA-6 NIL (NOT (FIND :JAVA-1.6 *FEATURES*)))
     [java] ; (DEFUN RUN-PROGRAM (PROGRAM ARGS &KEY ENVIRONMENT (WAIT T) CLEAR-ENVIRONMENT (INPUT :STREAM) (OUTPUT :STREAM) (ERROR :STREAM) IF-INPUT-DOES-NOT-EXIST (IF-OUTPUT-EXISTS :ERROR) (IF-ERROR-EXISTS :ERROR) DIRECTORY) "Run PROGRAM with ARGS in with ENVIRONMENT variables.
     [java]
     [java] Possibly WAIT for subprocess to exit.
     [java]
     [java] Optionally CLEAR-ENVIRONMENT of the subprocess of any non specified values.
     [java]
     [java] Creates a new process running the the PROGRAM.
     [java]
     [java] ARGS are a list of strings to be passed to the program as arguments.
     [java]
     [java] For no arguments, use nil which means that just the name of the
     [java] program is passed as arg 0.
     [java]
     [java] Returns a process structure containing the JAVA-OBJECT wrapped Process
     [java] object, and the PROCESS-INPUT, PROCESS-OUTPUT, and PROCESS-ERROR streams.
     [java]
     [java] c.f. http://download.oracle.com/javase/6/docs/api/java/lang/Process.html
     [java]
     [java] Notes about Unix environments (as in the :environment):
     [java]
     [java]     * The ABCL implementation of run-program, like SBCL, Perl and many
     [java]       other programs, copies the Unix environment by default.
     [java]
     [java]     * Running Unix programs from a setuid process, or in any other
     [java]       situation where the Unix environment is under the control of
     [java]       someone else, is a mother lode of security problems. If you are
     [java]       contemplating doing this, read about it first. (The Perl
     [java]       community has a lot of good documentation about this and other
     [java]       security issues in script-like programs.
     [java]
     [java] The &key arguments have the following meanings:
     [java]
     [java] :environment
     [java]     An alist of STRINGs (name . value) describing new
     [java]     environment values that replace existing ones.
     [java]
     [java] :clear-environment
     [java]     If non-NIL, the current environment is cleared before the
     [java]     values supplied by :environment are inserted.
     [java]
     [java] :wait
     [java]     If non-NIL, which is the default, wait until the created process
     [java]     finishes. If NIL, continue running Lisp until the program
     [java]     finishes.
     [java]
     [java] :input
     [java]     If T, I/O is inherited from the Java process. If NIL, /dev/null is used
     [java]     (nul on Windows). If a PATHNAME designator other than a stream is
     [java]     supplied, input will be read from that file. If set to :STREAM, a stream
     [java]     will be available via PROCESS-INPUT to read from. Defaults to :STREAM.
     [java]
     [java] :if-input-does-not-exist
     [java]     If :input points to a non-existing file, this may be set to :ERROR in
     [java]     order to signal an error, :CREATE to create and read from an empty file,
     [java]     or NIL to immediately NIL instead of creating the process.
     [java]     Defaults to NIL.
     [java]
     [java] :output
     [java]     If T, I/O is inherited from the Java process. If NIL, /dev/null is used
     [java]     (nul on Windows). If a PATHNAME designator other than a stream is
     [java]     supplied, output will be redirect to that file. If set to :STREAM, a
     [java]     stream will be available via PROCESS-OUTPUT to write to.
     [java]     Defaults to :STREAM.
     [java]
     [java] :if-output-exists
     [java]     If :output points to a non-existing file, this may be set to :ERROR in
     [java]     order to signal an error, :SUPERSEDE to supersede the existing file,
     [java]     :APPEND to append to it instead, or NIL to immediately NIL instead of
     [java]     creating the process. Defaults to :ERROR.
     [java]
     [java] :error
     [java]     Same as :output, but can also be :output, in which case the error stream
     [java]     is redirected to wherever the standard output stream goes.
     [java]     Defaults to :STREAM.
     [java]
     [java] :if-error-exists
     [java]     Same as :if-output-exists, but for the :error target.
     [java]
     [java] :directory
     [java]     If set will become the working directory for the new process, otherwise
     [java]     the working directory will be unchanged from the current Java process.
     [java]     Defaults to NIL.
     [java] " (LET* ((PROGRAM-NAMESTRING (NAMESTRING (PATHNAME PROGRAM))) (PROCESS-BUILDER (%MAKE-PROCESS-BUILDER PROGRAM-NAMESTRING ARGS))) (LET ((ENV-MAP (%PROCESS-BUILDER-ENVIRONMENT PROCESS-BUILDER))) (WHEN CLEAR-ENVIRONMENT (%PROCESS-BUILDER-ENV-CLEAR ENV-MAP)) (WHEN ENVIRONMENT (DOLIST (ENTRY ENVIRONMENT) (%PROCESS-BUILDER-ENV-PUT ENV-MAP (PRINC-TO-STRING (CAR ENTRY)) (PRINC-TO-STRING (CDR ENTRY)))))) (LET ((INPUT-STREAM-P (EQ INPUT :STREAM)) (OUTPUT-STREAM-P (EQ OUTPUT :STREAM)) (ERROR-STREAM-P (EQ ERROR :STREAM)) OUTPUT-REDIRECTION INPUT-REDIRECTION ERROR-REDIRECTION) (UNLESS OUTPUT-STREAM-P (UNLESS (SETF OUTPUT-REDIRECTION (SETUP-OUTPUT-REDIRECTION PROCESS-BUILDER OUTPUT NIL IF-OUTPUT-EXISTS)) (RETURN-FROM RUN-PROGRAM))) (IF (EQ ERROR :OUTPUT) (JAVA:JCALL "redirectErrorStream" PROCESS-BUILDER T) (UNLESS ERROR-STREAM-P (UNLESS (SETF ERROR-REDIRECTION (SETUP-OUTPUT-REDIRECTION PROCESS-BUILDER ERROR T IF-ERROR-EXISTS)) (RETURN-FROM RUN-PROGRAM)))) (UNLESS INPUT-STREAM-P (UNLESS (SETF INPUT-REDIRECTION (SETUP-INPUT-REDIRECTION PROCESS-BUILDER INPUT IF-INPUT-DOES-NOT-EXIST)) (RETURN-FROM RUN-PROGRAM))) (WHEN DIRECTORY (JAVA:JCALL "directory" PROCESS-BUILDER (JAVA:JNEW "java.io.File" (NAMESTRING DIRECTORY)))) (LET ((PROCESS (IF (NOT-JAVA-6) (MAKE-PROCESS (%PROCESS-BUILDER-START PROCESS-BUILDER) INPUT-STREAM-P OUTPUT-STREAM-P ERROR-STREAM-P) (MAKE-PROCESS (%PROCESS-BUILDER-START PROCESS-BUILDER) T T T)))) (WHEN (FIND :JAVA-1.6 *FEATURES*) (WHEN INPUT-REDIRECTION (LET ((INPUT (PROCESS-INPUT PROCESS))) (THREADS:MAKE-THREAD (LAMBDA NIL (FROM-FILE INPUT-REDIRECTION INPUT))))) (WHEN OUTPUT-REDIRECTION (LET ((OUTPUT (PROCESS-OUTPUT PROCESS)) (FILE (FIRST OUTPUT-REDIRECTION)) (APPENDP (SECOND OUTPUT-REDIRECTION))) (THREADS:MAKE-THREAD (LAMBDA NIL (TO-FILE OUTPUT FILE :APPEND APPENDP))))) (WHEN ERROR-REDIRECTION (LET ((ERROR (PROCESS-ERROR PROCESS)) (FILE (FIRST OUTPUT-REDIRECTION)) (APPENDP (SECOND OUTPUT-REDIRECTION))) (THREADS:MAKE-THREAD (LAMBDA NIL (TO-FILE ERROR FILE :APPEND APPENDP)))))) (WHEN (OR WAIT (NOT-JAVA-6) (PROCESS-WAIT PROCESS)) PROCESS)))))
     [java] ; (DEFCONSTANT +INHERIT+ (IGNORE-ERRORS (JAVA:JFIELD "java.lang.ProcessBuilder$Redirect" "INHERIT")))
     [java] ; (DEFUN COERCE-TO-FILE (VALUE) (JAVA:JNEW "java.io.File" (IF VALUE (NAMESTRING VALUE) (COND ((OS-UNIX-P) "/dev/null") ((OS-WINDOWS-P) "nul") (T (ERROR "Don't know how to set up null stream on this platform."))))))
     [java] ; (DEFINE-CONDITION IMPLEMENTATION-NOT-AVAILABLE (ERROR) ((MISSING :INITARG :MISSING :READER MISSING)) (:REPORT (LAMBDA (CONDITION STREAM) (FORMAT STREAM "This JVM is missing the ~a implementation." (MISSING CONDITION)))))
     [java] ; (DEFUN SETUP-INPUT-REDIRECTION (PROCESS-BUILDER VALUE IF-DOES-NOT-EXIST) "Returns boolean truth when input redirections has been successfully set up.
     [java]
     [java] As a second value, returns either nil if input should inherit from the
     [java] parent process, or a java.io.File reference to the file to read input from." (LET ((REDIRECT (IF (EQ VALUE T) (IF (NOT-JAVA-6) +INHERIT+ (SIGNAL (QUOTE IMPLEMENTATION-NOT-AVAILABLE) :MISSING "Inheritance for subprocess of standard input")) (LET ((FILE (COERCE-TO-FILE VALUE))) (WHEN VALUE (IF (EQ IF-DOES-NOT-EXIST :CREATE) (OPEN VALUE :DIRECTION :PROBE :IF-DOES-NOT-EXIST :CREATE) (UNLESS (PROBE-FILE VALUE) (ECASE IF-DOES-NOT-EXIST (:ERROR (ERROR "Input file ~S does not already exist." VALUE)) ((NIL) (RETURN-FROM SETUP-INPUT-REDIRECTION)))))) (IF (NOT-JAVA-6) (JAVA:JSTATIC "from" "java.lang.ProcessBuilder$Redirect" FILE) FILE))))) (WHEN (NOT-JAVA-6) (JAVA:JCALL "redirectInput" PROCESS-BUILDER REDIRECT)) REDIRECT))
     [java] ; (DEFUN SETUP-OUTPUT-REDIRECTION (PROCESS-BUILDER VALUE ERRORP IF-DOES-EXIST) (LET ((REDIRECT (IF (EQ VALUE T) (IF (NOT-JAVA-6) +INHERIT+ (IF ERRORP (SIGNAL (QUOTE IMPLEMENTATION-NOT-AVAILABLE) :MISSING "Inheritance for subprocess of standard error") (SIGNAL (QUOTE IMPLEMENTATION-NOT-AVAILABLE) :MISSING "Inheritance for subprocess of standard output"))) (LET ((FILE (COERCE-TO-FILE VALUE)) APPENDP) (WHEN (AND VALUE (PROBE-FILE VALUE)) (ECASE IF-DOES-EXIST (:ERROR (ERROR "Output file ~S does already exist." VALUE)) (:SUPERSEDE (WITH-OPEN-FILE (F VALUE :DIRECTION :OUTPUT :IF-EXISTS IF-DOES-EXIST))) (:APPEND (SETF APPENDP T)) ((NIL) (RETURN-FROM SETUP-OUTPUT-REDIRECTION)))) (IF (NOT-JAVA-6) (IF APPENDP (JAVA:JSTATIC "appendTo" "java.lang.ProcessBuilder$Redirect" FILE) (JAVA:JSTATIC "to" "java.lang.ProcessBuilder$Redirect" FILE)) (LIST FILE APPENDP)))))) (WHEN (NOT-JAVA-6) (IF ERRORP (JAVA:JCALL "redirectError" PROCESS-BUILDER REDIRECT) (JAVA:JCALL "redirectOutput" PROCESS-BUILDER REDIRECT))) REDIRECT))
     [java] ; (DEFSTRUCT (PROCESS (:CONSTRUCTOR %MAKE-PROCESS (JPROCESS))) JPROCESS %INPUT %OUTPUT %ERROR)
     [java] ; (DEFUN MAKE-PROCESS (PROC INPUTP OUTPUTP ERRORP) (LET ((PROCESS (%MAKE-PROCESS PROC))) (WHEN INPUTP (SETF (PROCESS-%INPUT PROCESS) (%MAKE-PROCESS-INPUT-STREAM PROC))) (WHEN OUTPUTP (SETF (PROCESS-%OUTPUT PROCESS) (%MAKE-PROCESS-OUTPUT-STREAM PROC))) (WHEN ERRORP (SETF (PROCESS-%ERROR PROCESS) (%MAKE-PROCESS-ERROR-STREAM PROC))) PROCESS))
     [java] ; (DEFUN PROCESS-INPUT (PROCESS) (PROCESS-%INPUT PROCESS))
     [java] ; (DEFUN PROCESS-OUTPUT (PROCESS) (PROCESS-%OUTPUT PROCESS))
     [java] ; (DEFUN PROCESS-ERROR (PROCESS) (PROCESS-%ERROR PROCESS))
     [java] ; (DEFUN PROCESS-ALIVE-P (PROCESS) "Return t if process is still alive, nil otherwise." (%PROCESS-ALIVE-P (PROCESS-JPROCESS PROCESS)))
     [java] ; (DEFUN PROCESS-WAIT (PROCESS) "Wait for process to quit running for some reason." (%PROCESS-WAIT (PROCESS-JPROCESS PROCESS)))
     [java] ; (DEFUN PROCESS-EXIT-CODE (INSTANCE) "The exit code of a process." (%PROCESS-EXIT-CODE (PROCESS-JPROCESS INSTANCE)))
     [java] ; (DEFUN PROCESS-KILL (PROCESS) "Kills the process." (%PROCESS-KILL (PROCESS-JPROCESS PROCESS)))
     [java] ; (DEFUN PROCESS-PID (PROCESS) "Return the process ID." (%PROCESS-PID (PROCESS-JPROCESS PROCESS)))
     [java] ; (DEFUN %MAKE-PROCESS-BUILDER (PROGRAM ARGS) (JAVA:JNEW "java.lang.ProcessBuilder" (JAVA:JNEW-ARRAY-FROM-LIST "java.lang.String" (CONS PROGRAM ARGS))))
     [java] ; (DEFUN %PROCESS-BUILDER-ENVIRONMENT (PB) (JAVA:JCALL "environment" PB))
     [java] ; (DEFUN %PROCESS-BUILDER-ENV-PUT (ENV-MAP KEY VALUE) (JAVA:JCALL "put" ENV-MAP KEY VALUE))
     [java] ; (DEFUN %PROCESS-BUILDER-ENV-CLEAR (ENV-MAP) (JAVA:JCALL "clear" ENV-MAP))
     [java] ; (DEFUN %PROCESS-BUILDER-START (PB) (JAVA:JCALL "start" PB))
     [java] ; (DEFUN %MAKE-PROCESS-INPUT-STREAM (PROC) (JAVA:JNEW "org.armedbear.lisp.Stream" (QUOTE SYSTEM-STREAM) (JAVA:JCALL "getOutputStream" PROC) (QUOTE CHARACTER)))
     [java] ; (DEFUN %MAKE-PROCESS-OUTPUT-STREAM (PROC) (JAVA:JNEW "org.armedbear.lisp.Stream" (QUOTE SYSTEM-STREAM) (JAVA:JCALL "getInputStream" PROC) (QUOTE CHARACTER)))
     [java] ; (DEFUN %MAKE-PROCESS-ERROR-STREAM (PROC) (JAVA:JNEW "org.armedbear.lisp.Stream" (QUOTE SYSTEM-STREAM) (JAVA:JCALL "getErrorStream" PROC) (QUOTE CHARACTER)))
     [java] ; (DEFUN %PROCESS-ALIVE-P (JPROCESS) (NOT (IGNORE-ERRORS (JAVA:JCALL "exitValue" JPROCESS))))
     [java] ; (DEFUN %PROCESS-WAIT (JPROCESS) (JAVA:JCALL "waitFor" JPROCESS))
     [java] ; (DEFUN %PROCESS-EXIT-CODE (JPROCESS) (IGNORE-ERRORS (JAVA:JCALL "exitValue" JPROCESS)))
     [java] ; (DEFUN %PROCESS-PID (JPROCESS) (IF (OS-UNIX-P) (LET ((FIELD (JAVA:JCALL "getDeclaredField" (JAVA:JCLASS "java.lang.UNIXProcess") "pid"))) (JAVA:JCALL "setAccessible" FIELD JAVA:+TRUE+) (JAVA:JCALL "get" FIELD JPROCESS)) (ERROR "Can't retrieve PID on this platform.")))
     [java] ; (DEFUN %PROCESS-KILL (JPROCESS) (JAVA:JCALL "destroy" JPROCESS))
     [java] ; (DEFUN TO-FILE (INPUT JAVA.IO.FILE &KEY (APPEND NIL)) (DECLARE (IGNORE APPEND)) (LET ((FILE (JAVA:JCALL "toString" JAVA.IO.FILE))) (WITH-OPEN-FILE (S FILE :DIRECTION :OUTPUT :ELEMENT-TYPE (STREAM-ELEMENT-TYPE INPUT)) (LET ((BUFFER (MAKE-ARRAY 8192 :ELEMENT-TYPE (STREAM-ELEMENT-TYPE INPUT)))) (LOOP :FOR BYTES-READ = (READ-SEQUENCE BUFFER INPUT) :WHILE (PLUSP BYTES-READ) :DO (WRITE-SEQUENCE BUFFER S :END BYTES-READ))))) (CLOSE INPUT))
     [java] ; (DEFUN FROM-FILE (JAVA.IO.FILE OUTPUT) (LET ((FILE (JAVA:JCALL "toString" JAVA.IO.FILE))) (WITH-OPEN-FILE (S FILE :DIRECTION :INPUT :ELEMENT-TYPE (STREAM-ELEMENT-TYPE OUTPUT)) (LET ((BUFFER (MAKE-ARRAY 8192 :ELEMENT-TYPE (STREAM-ELEMENT-TYPE OUTPUT)))) (LOOP :FOR BYTES-READ = (READ-SEQUENCE BUFFER S) :WHILE (PLUSP BYTES-READ) :DO (WRITE-SEQUENCE BUFFER OUTPUT :END BYTES-READ)))) (CLOSE OUTPUT)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/run-program.abcl (1.275 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/run-shell-command.lisp ...
     [java] ; (IN-PACKAGE "EXTENSIONS")
     [java] ; (DEFUN RUN-SHELL-COMMAND (COMMAND &KEY DIRECTORY (OUTPUT *STANDARD-OUTPUT*)) "Deprecated.  Use SYS:RUN-PROGRAM." (SYSTEM::%RUN-SHELL-COMMAND COMMAND DIRECTORY OUTPUT))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/run-shell-command.abcl (0.052 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/runtime-class.lisp ...
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DEFCONSTANT +ABCL-JAVA-OBJECT+ (MAKE-JVM-CLASS-NAME "org.armedbear.lisp.JavaObject"))
     [java] ; (DEFUN JAVA::MAKE-MEMORY-CLASS-LOADER (&OPTIONAL (PARENT (JAVA:GET-CURRENT-CLASSLOADER))) (JAVA:JNEW "org.armedbear.lisp.MemoryClassLoader" PARENT))
     [java] ; (DEFUN JAVA:JNEW-RUNTIME-CLASS (CLASS-NAME &REST ARGS &KEY (SUPERCLASS "java.lang.Object") INTERFACES CONSTRUCTORS METHODS FIELDS (ACCESS-FLAGS (QUOTE (:PUBLIC))) ANNOTATIONS (CLASS-LOADER (JAVA::MAKE-MEMORY-CLASS-LOADER))) "Creates and loads a Java class with methods calling Lisp closures
     [java]    as given in METHODS.  CLASS-NAME and SUPER-NAME are strings,
     [java]    INTERFACES is a list of strings, CONSTRUCTORS, METHODS and FIELDS are
     [java]    lists of constructor, method and field definitions.
     [java]
     [java]    Constructor definitions - currently NOT supported - are lists of the form
     [java]    (argument-types function &optional super-invocation-arguments)
     [java]    where argument-types is a list of strings and function is a lisp function of
     [java]    (1+ (length argument-types)) arguments; the instance (`this') is passed in as
     [java]    the last argument. The optional super-invocation-arguments is a list of numbers
     [java]    between 1 and (length argument-types), where the number k stands for the kth argument
     [java]    to the just defined constructor. If present, the constructor of the superclass
     [java]    will be called with the appropriate arguments. E.g., if the constructor definition is
     [java]    ((\"java.lang.String\" \"int\") #'(lambda (string i this) ...) (2 1))
     [java]    then the constructor of the superclass with argument types (int, java.lang.String) will
     [java]    be called with the second and first arguments.
     [java]
     [java]    Method definitions are lists of the form
     [java]
     [java]      (METHOD-NAME RETURN-TYPE ARGUMENT-TYPES FUNCTION &key MODIFIERS ANNOTATIONS)
     [java]
     [java]    where
     [java]       METHOD-NAME is a string
     [java]       RETURN-TYPE denotes the type of the object returned by the method
     [java]       ARGUMENT-TYPES is a list of parameters to the method
     [java]
     [java]         The types are either strings naming fully qualified java classes or Lisp keywords referring to
     [java]         primitive types (:void, :int, etc.).
     [java]
     [java]      FUNCTION is a Lisp function of minimum arity (1+ (length
     [java]      argument-types)). The instance (`this') is passed as the first
     [java]      argument.
     [java]
     [java]    Field definitions are lists of the form (field-name type &key modifiers annotations)." (DECLARE (IGNORABLE SUPERCLASS INTERFACES CONSTRUCTORS METHODS FIELDS ACCESS-FLAGS ANNOTATIONS)) (LET ((STREAM (SYSTEM::%MAKE-BYTE-ARRAY-OUTPUT-STREAM))) (MULTIPLE-VALUE-BIND (CLASS-FILE METHOD-IMPLEMENTATION-FIELDS) (APPLY (FUNCTION JAVA::%JNEW-RUNTIME-CLASS) CLASS-NAME STREAM :ALLOW-OTHER-KEYS T ARGS) (SYSTEM::PUT-MEMORY-FUNCTION CLASS-LOADER CLASS-NAME (SYSTEM::%GET-OUTPUT-STREAM-BYTES STREAM)) (LET ((JCLASS (JAVA:JCALL "loadClass" CLASS-LOADER CLASS-NAME))) (DOLIST (METHOD METHOD-IMPLEMENTATION-FIELDS) (SETF (JAVA:JFIELD JCLASS (CAR METHOD)) (CDR METHOD))) JCLASS))))
     [java] ; (DEFCONSTANT +ABCL-LISP-INTEGER-OBJECT+ (MAKE-JVM-CLASS-NAME "org.armedbear.lisp.LispInteger"))
     [java] ; (DEFUN BOX-ARGUMENTS (ARGUMENT-TYPES OFFSET ALL-ARGC) (LOOP :FOR ARG-TYPE :IN ARGUMENT-TYPES :FOR I :FROM OFFSET :DO (PROGN (COND ((EQ ARG-TYPE :INT) (ILOAD I) (EMIT-INVOKESTATIC +ABCL-LISP-INTEGER-OBJECT+ "getInstance" (LIST :INT) +ABCL-LISP-INTEGER-OBJECT+)) ((KEYWORDP ARG-TYPE) (ERROR "Unsupported arg-type: ~A" ARG-TYPE)) (T (ALOAD I) (EMIT (QUOTE ICONST_1)) (EMIT-INVOKESTATIC +ABCL-JAVA-OBJECT+ "getInstance" (LIST +JAVA-OBJECT+ :BOOLEAN) +LISP-OBJECT+))) (ASTORE (+ I ALL-ARGC)))))
     [java] ; (DEFUN JAVA::%JNEW-RUNTIME-CLASS (CLASS-NAME STREAM &KEY (SUPERCLASS "java.lang.Object") INTERFACES CONSTRUCTORS METHODS FIELDS (ACCESS-FLAGS (QUOTE (:PUBLIC))) ANNOTATIONS) "Actual implementation of jnew-runtime-class. Writes the class bytes to a stream. Returns two values: the finalized class-file structure and the alist of method implementation fields." (LET* ((JVM-CLASS-NAME (MAKE-JVM-CLASS-NAME CLASS-NAME)) (CLASS-FILE (MAKE-CLASS-FILE JVM-CLASS-NAME (MAKE-JVM-CLASS-NAME SUPERCLASS) ACCESS-FLAGS)) METHOD-IMPLEMENTATION-FIELDS) (SETF (CLASS-FILE-INTERFACES CLASS-FILE) (MAPCAR (FUNCTION MAKE-JVM-CLASS-NAME) INTERFACES)) (WHEN ANNOTATIONS (CLASS-ADD-ATTRIBUTE CLASS-FILE (MAKE-RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE :LIST (MAPCAR (FUNCTION PARSE-ANNOTATION) ANNOTATIONS)))) (SETF METHOD-IMPLEMENTATION-FIELDS (JAVA::RUNTIME-CLASS-ADD-METHODS CLASS-FILE METHODS)) (JAVA::RUNTIME-CLASS-ADD-FIELDS CLASS-FILE FIELDS) (IF (NULL CONSTRUCTORS) (LET ((CTOR (MAKE-JVM-METHOD :CONSTRUCTOR :VOID NIL :FLAGS (QUOTE (:PUBLIC))))) (CLASS-ADD-METHOD CLASS-FILE CTOR) (WITH-CODE-TO-METHOD (CLASS-FILE CTOR) (ALOAD 0) (EMIT-INVOKESPECIAL-INIT (CLASS-FILE-SUPERCLASS CLASS-FILE) NIL) (EMIT (QUOTE RETURN)))) (DOLIST (CONSTRUCTOR CONSTRUCTORS) (DESTRUCTURING-BIND (ARGUMENT-TYPES FUNCTION &KEY (MODIFIERS (QUOTE (:PUBLIC)))) CONSTRUCTOR (LET* ((ARGUMENT-TYPES (MAPCAR (FUNCTION JAVA::CANONICALIZE-JAVA-TYPE) ARGUMENT-TYPES)) (ARGC (LENGTH ARGUMENT-TYPES)) (CTOR (MAKE-JVM-METHOD :CONSTRUCTOR :VOID ARGUMENT-TYPES :FLAGS MODIFIERS)) (FIELD-NAME (STRING (GENSYM "CONSTRUCTOR"))) (ALL-ARGC (1+ ARGC))) (CLASS-ADD-METHOD CLASS-FILE CTOR) (LET ((FIELD (MAKE-FIELD FIELD-NAME +LISP-OBJECT+ :FLAGS (QUOTE (:PUBLIC :STATIC))))) (CLASS-ADD-FIELD CLASS-FILE FIELD)) (PUSH (CONS FIELD-NAME FUNCTION) METHOD-IMPLEMENTATION-FIELDS) (WITH-CODE-TO-METHOD (CLASS-FILE CTOR) (DOTIMES (I (* 2 ALL-ARGC)) (ALLOCATE-REGISTER NIL)) (ALOAD 0) (EMIT-INVOKESPECIAL-INIT (CLASS-FILE-SUPERCLASS CLASS-FILE) NIL) (ALOAD 0) (EMIT (QUOTE ICONST_1)) (EMIT-INVOKESTATIC +ABCL-JAVA-OBJECT+ "getInstance" (LIST +JAVA-OBJECT+ :BOOLEAN) +LISP-OBJECT+) (ASTORE ALL-ARGC) (BOX-ARGUMENTS ARGUMENT-TYPES 1 ALL-ARGC) (EMIT-GETSTATIC (CLASS-FILE-CLASS CLASS-FILE) FIELD-NAME +LISP-OBJECT+) (IF (<= ALL-ARGC CALL-REGISTERS-LIMIT) (PROGN (ALOAD ALL-ARGC) (DOTIMES (I ARGC) (ALOAD (+ I 1 ALL-ARGC)))) (ERROR "execute(LispObject[]) is currently not supported")) (EMIT-CALL-EXECUTE ALL-ARGC) (EMIT (QUOTE RETURN))))))) (FINALIZE-CLASS-FILE CLASS-FILE) (WRITE-CLASS-FILE CLASS-FILE STREAM) (FINISH-OUTPUT STREAM) (VALUES CLASS-FILE METHOD-IMPLEMENTATION-FIELDS)))
     [java] ; (DEFUN JAVA::MAKE-ACCESSOR-NAME (PREFIX NAME) (LET ((INITIAL (CHAR-UPCASE (AREF NAME 0))) (REST (SUBSEQ NAME 1))) (FORMAT NIL "~A~A~A" PREFIX INITIAL REST)))
     [java] ; (DEFUN EMIT-INVOKESPECIAL (CLASS-NAME METHOD-NAME ARG-TYPES RETURN-TYPE) (LET* ((STACK-EFFECT (APPLY (FUNCTION DESCRIPTOR-STACK-EFFECT) RETURN-TYPE ARG-TYPES)) (INDEX (POOL-ADD-METHOD-REF *POOL* CLASS-NAME METHOD-NAME (CONS RETURN-TYPE ARG-TYPES))) (INSTRUCTION (APPLY (FUNCTION %EMIT) (QUOTE INVOKESPECIAL) (U2 INDEX)))) (DECLARE (TYPE (SIGNED-BYTE 8) STACK-EFFECT)) (SETF (INSTRUCTION-STACK INSTRUCTION) (1- STACK-EFFECT))))
     [java] ; (DEFUN JAVA::CANONICALIZE-JAVA-TYPE (TYPE) (COND ((STRINGP TYPE) (MAKE-JVM-CLASS-NAME TYPE)) ((KEYWORDP TYPE) TYPE) (T (ERROR "Unrecognized Java type: ~A" TYPE))))
     [java] ; (DEFUN JAVA::EMIT-UNBOX-AND-RETURN (RETURN-TYPE) (COND ((EQ RETURN-TYPE :VOID) (EMIT (QUOTE POP)) (EMIT (QUOTE RETURN))) ((EQ RETURN-TYPE :INT) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "intValue" NIL :INT) (EMIT (QUOTE IRETURN))) ((EQ RETURN-TYPE :BOOLEAN) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "getBooleanValue" NIL :BOOLEAN) (EMIT (QUOTE IRETURN))) ((JVM-CLASS-NAME-P RETURN-TYPE) (EMIT (QUOTE LDC_W) (POOL-CLASS RETURN-TYPE)) (EMIT-INVOKEVIRTUAL +LISP-OBJECT+ "javaInstance" (LIST +JAVA-CLASS+) +JAVA-OBJECT+) (EMIT-CHECKCAST RETURN-TYPE) (EMIT (QUOTE ARETURN))) (T (ERROR "Unsupported return type: ~A" RETURN-TYPE))))
     [java] ; (DEFUN JAVA::RUNTIME-CLASS-ADD-METHODS (CLASS-FILE METHODS) (LET (METHOD-IMPLEMENTATION-FIELDS) (DOLIST (METHOD METHODS) (DESTRUCTURING-BIND (NAME RETURN-TYPE ARGUMENT-TYPES FUNCTION &KEY (MODIFIERS (QUOTE (:PUBLIC))) ANNOTATIONS OVERRIDE) METHOD (LET* ((ARGUMENT-TYPES (MAPCAR (FUNCTION JAVA::CANONICALIZE-JAVA-TYPE) ARGUMENT-TYPES)) (ARGC (LENGTH ARGUMENT-TYPES)) (RETURN-TYPE (JAVA::CANONICALIZE-JAVA-TYPE RETURN-TYPE)) (JMETHOD (MAKE-JVM-METHOD NAME RETURN-TYPE ARGUMENT-TYPES :FLAGS MODIFIERS)) (FIELD-NAME (STRING (GENSYM NAME))) (STATICP (MEMBER :STATIC MODIFIERS)) (OFFSET (IF STATICP 0 1)) (ALL-ARGC (+ ARGC OFFSET))) (CLASS-ADD-METHOD CLASS-FILE JMETHOD) (LET ((FIELD (MAKE-FIELD FIELD-NAME +LISP-OBJECT+ :FLAGS (QUOTE (:PUBLIC :STATIC))))) (CLASS-ADD-FIELD CLASS-FILE FIELD) (PUSH (CONS FIELD-NAME FUNCTION) METHOD-IMPLEMENTATION-FIELDS)) (WHEN ANNOTATIONS (METHOD-ADD-ATTRIBUTE JMETHOD (MAKE-RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE :LIST (MAPCAR (FUNCTION PARSE-ANNOTATION) ANNOTATIONS)))) (WITH-CODE-TO-METHOD (CLASS-FILE JMETHOD) (DOTIMES (I (* 2 ALL-ARGC)) (ALLOCATE-REGISTER NIL)) (UNLESS STATICP (ALOAD 0) (EMIT (QUOTE ICONST_1)) (EMIT-INVOKESTATIC +ABCL-JAVA-OBJECT+ "getInstance" (LIST +JAVA-OBJECT+ :BOOLEAN) +LISP-OBJECT+) (ASTORE ALL-ARGC)) (BOX-ARGUMENTS ARGUMENT-TYPES OFFSET ALL-ARGC) (EMIT-GETSTATIC (CLASS-FILE-CLASS CLASS-FILE) FIELD-NAME +LISP-OBJECT+) (IF (<= ALL-ARGC CALL-REGISTERS-LIMIT) (PROGN (UNLESS STATICP (ALOAD ALL-ARGC)) (DOTIMES (I ARGC) (ALOAD (+ I 1 ALL-ARGC)))) (ERROR "execute(LispObject[]) is currently not supported")) (EMIT-CALL-EXECUTE ALL-ARGC) (JAVA::EMIT-UNBOX-AND-RETURN RETURN-TYPE)) (COND ((EQ OVERRIDE T) (LET ((SUPER-METHOD (MAKE-JVM-METHOD (FORMAT NIL "super$~A" NAME) RETURN-TYPE ARGUMENT-TYPES :FLAGS MODIFIERS))) (CLASS-ADD-METHOD CLASS-FILE SUPER-METHOD) (WITH-CODE-TO-METHOD (CLASS-FILE SUPER-METHOD) (DOTIMES (I (1+ (LENGTH ARGUMENT-TYPES))) (ALLOCATE-REGISTER NIL)) (ALOAD 0) (LOOP :FOR ARG-TYPE :IN ARGUMENT-TYPES :FOR I :FROM 1 :DO (PROGN (COND ((KEYWORDP ARG-TYPE) (ERROR "Unsupported arg-type: ~A" ARG-TYPE)) ((EQ ARG-TYPE :INT) :TODO) (T (ALOAD I))))) (EMIT-INVOKESPECIAL (CLASS-FILE-SUPERCLASS CLASS-FILE) NAME ARGUMENT-TYPES RETURN-TYPE) (COND ((EQ RETURN-TYPE :VOID) (EMIT (QUOTE RETURN))) ((EQ RETURN-TYPE :INT) (EMIT (QUOTE IRETURN))) ((EQ RETURN-TYPE :BOOLEAN) (EMIT (QUOTE IRETURN))) ((JVM-CLASS-NAME-P RETURN-TYPE) (EMIT (QUOTE ARETURN))) (T (ERROR "Unsupported return type: ~A" RETURN-TYPE)))))))))) METHOD-IMPLEMENTATION-FIELDS))
     [java] ; (DEFUN JAVA::RUNTIME-CLASS-ADD-FIELDS (CLASS-FILE FIELDS) (DOLIST (FIELD-SPEC FIELDS) (DESTRUCTURING-BIND (NAME TYPE &KEY (MODIFIERS (QUOTE (:PUBLIC))) ANNOTATIONS (GETTER NIL GETTER-P) (SETTER NIL SETTER-P) (PROPERTY (AND (NOT GETTER-P) (NOT SETTER-P)))) FIELD-SPEC (LET* ((TYPE (IF (KEYWORDP TYPE) TYPE (MAKE-JVM-CLASS-NAME TYPE))) (FIELD (MAKE-FIELD NAME TYPE :FLAGS MODIFIERS))) (WHEN (MEMBER :STATIC MODIFIERS) (SETF PROPERTY NIL GETTER NIL SETTER NIL)) (WHEN ANNOTATIONS (FIELD-ADD-ATTRIBUTE FIELD (MAKE-RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE :LIST (MAPCAR (FUNCTION PARSE-ANNOTATION) ANNOTATIONS)))) (CLASS-ADD-FIELD CLASS-FILE FIELD) (WHEN (OR GETTER PROPERTY) (UNLESS (STRINGP GETTER) (SETF GETTER (JAVA::MAKE-ACCESSOR-NAME "get" (IF (STRINGP PROPERTY) PROPERTY NAME)))) (LET ((JMETHOD (MAKE-JVM-METHOD GETTER TYPE NIL :FLAGS (QUOTE (:PUBLIC))))) (CLASS-ADD-METHOD CLASS-FILE JMETHOD) (WITH-CODE-TO-METHOD (CLASS-FILE JMETHOD) (ALOAD 0) (EMIT-GETFIELD (CLASS-FILE-CLASS CLASS-FILE) NAME TYPE) (COND ((JVM-CLASS-NAME-P TYPE) (EMIT (QUOTE ARETURN))) ((EQ TYPE :INT) (EMIT (QUOTE IRETURN))) (T (ERROR "Unsupported getter return type: ~A" TYPE)))))) (WHEN (OR SETTER PROPERTY) (UNLESS (STRINGP SETTER) (SETF SETTER (JAVA::MAKE-ACCESSOR-NAME "set" (IF (STRINGP PROPERTY) PROPERTY NAME)))) (LET ((JMETHOD (MAKE-JVM-METHOD SETTER :VOID (LIST TYPE) :FLAGS (QUOTE (:PUBLIC))))) (CLASS-ADD-METHOD CLASS-FILE JMETHOD) (WITH-CODE-TO-METHOD (CLASS-FILE JMETHOD) (ALOAD 0) (COND ((JVM-CLASS-NAME-P TYPE) (ALOAD 1)) ((EQ TYPE :INT) (EMIT (QUOTE ILOAD) 1)) (T (ERROR "Unsupported setter parameter type: ~A" TYPE))) (EMIT-PUTFIELD (CLASS-FILE-CLASS CLASS-FILE) NAME TYPE) (EMIT (QUOTE RETURN)))))))))
     [java] ; (DEFMACRO JAVA:DEFINE-JAVA-CLASS NIL :TODO)
     [java] ; (DEFUN PARSE-ANNOTATION (ANNOTATION) (WHEN (ANNOTATION-P ANNOTATION) (RETURN-FROM PARSE-ANNOTATION ANNOTATION)) (DESTRUCTURING-BIND (CLASS &REST ELEMENTS) (IF (LISTP ANNOTATION) ANNOTATION (LIST ANNOTATION)) (LET (ACTUAL-ELEMENTS) (DOLIST (ELEM ELEMENTS) (PUSH (PARSE-ANNOTATION-ELEMENT ELEM) ACTUAL-ELEMENTS)) (MAKE-ANNOTATION :TYPE CLASS :ELEMENTS (NREVERSE ACTUAL-ELEMENTS)))))
     [java] ; (DEFUN PARSE-ANNOTATION-ELEMENT (ELEM) (COND ((ANNOTATION-ELEMENT-P ELEM) ELEM) ((ATOM ELEM) (MAKE-PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT :NAME NIL :VALUE ELEM)) ((KEYWORDP (CAR ELEM)) (PARSE-ANNOTATION-ELEMENT (SYSTEM::BACKQ-CONS "value" ELEM))) (T (DESTRUCTURING-BIND (NAME &KEY VALUE ENUM ANNOTATION) ELEM (COND (ENUM (MAKE-ENUM-VALUE-ANNOTATION-ELEMENT :NAME NAME :TYPE ENUM :VALUE VALUE)) (ANNOTATION (MAKE-ANNOTATION-VALUE-ANNOTATION-ELEMENT :NAME NAME :VALUE (PARSE-ANNOTATION ANNOTATION))) ((LISTP VALUE) (MAKE-ARRAY-ANNOTATION-ELEMENT :NAME NAME :VALUES (MAPCAR (FUNCTION PARSE-ANNOTATION-ELEMENT) VALUE))) (T (MAKE-PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT :NAME NAME :VALUE VALUE)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/runtime-class.abcl (1.002 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/search.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN SEARCH (SEQUENCE1 SEQUENCE2 &REST ARGS &KEY FROM-END (TEST (FUNCTION EQL)) TEST-NOT (START1 0) END1 (START2 0) END2 KEY) (LET ((END1 (OR END1 (LENGTH SEQUENCE1))) (END2 (OR END2 (LENGTH SEQUENCE2)))) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (SEQUENCE::SEQ-DISPATCH SEQUENCE2 (LIST-SEARCH SEQUENCE2 SEQUENCE1) (VECTOR-SEARCH SEQUENCE2 SEQUENCE1) (APPLY (FUNCTION SEQUENCE:SEARCH) SEQUENCE1 SEQUENCE2 ARGS))))
     [java] ; (DEFUN SIMPLE-SEARCH (SEQUENCE1 SEQUENCE2) (COND ((AND (STRINGP SEQUENCE1) (STRINGP SEQUENCE2)) (SIMPLE-STRING-SEARCH SEQUENCE1 SEQUENCE2)) ((VECTORP SEQUENCE2) (SIMPLE-VECTOR-SEARCH SEQUENCE1 SEQUENCE2)) (T (SEARCH SEQUENCE1 SEQUENCE2 :FROM-END NIL))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/search.abcl (0.192 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sequences.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO TYPE-SPECIFIER-ATOM (TYPE) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE ATOM) TYPE) TYPE (BACKQ-LIST (QUOTE CAR) TYPE)))
     [java] ; (DEFUN MAKE-SEQUENCE-OF-TYPE (TYPE LENGTH) (CASE (TYPE-SPECIFIER-ATOM TYPE) (LIST (MAKE-LIST LENGTH)) ((BIT-VECTOR SIMPLE-BIT-VECTOR) (MAKE-ARRAY LENGTH :ELEMENT-TYPE (QUOTE BIT))) ((SIMPLE-BASE-STRING SIMPLE-STRING STRING) (MAKE-STRING LENGTH)) ((SIMPLE-VECTOR VECTOR) (IF (CADR TYPE) (MAKE-ARRAY LENGTH :ELEMENT-TYPE (CADR TYPE)) (MAKE-ARRAY LENGTH))) (NIL-VECTOR (MAKE-ARRAY LENGTH :ELEMENT-TYPE NIL)) (SIMPLE-ARRAY (IF (CADR TYPE) (MAKE-ARRAY LENGTH :ELEMENT-TYPE (CADR TYPE)) (MAKE-ARRAY LENGTH))) (T (ERROR "MAKE-SEQUENCE-OF-TYPE: unsupported case ~S" TYPE))))
     [java] ; (DEFMACRO MAKE-SEQUENCE-LIKE (SEQUENCE LENGTH) "Return a sequence of the same type as SEQUENCE and the given LENGTH." (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE MSL-SEQ-TMP-VAR) SEQUENCE) (BACKQ-LIST (QUOTE MSL-LEN-TMP-VAR) LENGTH)) (QUOTE ((SEQUENCE::SEQ-DISPATCH MSL-SEQ-TMP-VAR (MAKE-SEQUENCE-OF-TYPE (TYPE-OF MSL-SEQ-TMP-VAR) MSL-LEN-TMP-VAR) (MAKE-SEQUENCE-OF-TYPE (TYPE-OF MSL-SEQ-TMP-VAR) MSL-LEN-TMP-VAR) (SEQUENCE:MAKE-SEQUENCE-LIKE MSL-SEQ-TMP-VAR MSL-LEN-TMP-VAR))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/sequences.abcl (0.121 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sets.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO WITH-SET-KEYS (FUNCALL) (BACKQ-LIST (QUOTE COND) (BACKQ-LIST (QUOTE NOTP) (BACKQ-APPEND FUNCALL (QUOTE (:KEY KEY :TEST-NOT TEST-NOT)))) (BACKQ-LIST (QUOTE T) (BACKQ-APPEND FUNCALL (QUOTE (:KEY KEY :TEST TEST))))))
     [java] ; (DEFUN UNION (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (REQUIRE-TYPE LIST2 (QUOTE LIST)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RES LIST2)) (DOLIST (ELT LIST1) (UNLESS (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST2)) (PUSH ELT RES))) RES))
     [java] ; (DEFMACRO STEVE-SPLICE (SOURCE DESTINATION) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE TEMP) SOURCE)) (BACKQ-LIST* (QUOTE SETF) SOURCE (BACKQ-LIST (QUOTE CDR) SOURCE) (QUOTE (CDR TEMP)) DESTINATION DESTINATION (QUOTE (TEMP)))))
     [java] ; (DEFUN NUNION (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RES LIST2) (LIST1 LIST1)) (DO NIL ((ENDP LIST1)) (IF (NOT (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY (CAR LIST1)) LIST2))) (STEVE-SPLICE LIST1 RES) (SETF LIST1 (CDR LIST1)))) RES))
     [java] ; (DEFUN INTERSECTION (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RES NIL)) (DOLIST (ELT LIST1) (IF (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST2)) (PUSH ELT RES))) RES))
     [java] ; (DEFUN NINTERSECTION (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RES NIL) (LIST1 LIST1)) (DO NIL ((ENDP LIST1)) (IF (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY (CAR LIST1)) LIST2)) (STEVE-SPLICE LIST1 RES) (SETQ LIST1 (CDR LIST1)))) RES))
     [java] ; (DEFUN SET-DIFFERENCE (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (IF (NULL LIST2) LIST1 (LET ((RES NIL)) (DOLIST (ELT LIST1) (IF (NOT (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST2))) (PUSH ELT RES))) RES)))
     [java] ; (DEFUN NSET-DIFFERENCE (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RES NIL) (LIST1 LIST1)) (DO NIL ((ENDP LIST1)) (IF (NOT (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY (CAR LIST1)) LIST2))) (STEVE-SPLICE LIST1 RES) (SETQ LIST1 (CDR LIST1)))) RES))
     [java] ; (DEFUN SET-EXCLUSIVE-OR (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (WHEN KEY (SETQ KEY (COERCE-TO-FUNCTION KEY))) (LET ((RESULT NIL) (KEY (WHEN KEY (COERCE KEY (QUOTE FUNCTION)))) (TEST (COERCE TEST (QUOTE FUNCTION))) (TEST-NOT (IF TEST-NOT (COERCE TEST-NOT (QUOTE FUNCTION)) (FUNCTION EQL)))) (DOLIST (ELT LIST1) (UNLESS (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST2)) (SETQ RESULT (CONS ELT RESULT)))) (LET ((TEST (IF TESTP (LAMBDA (X Y) (FUNCALL TEST Y X)) TEST)) (TEST-NOT (IF NOTP (LAMBDA (X Y) (FUNCALL TEST-NOT Y X)) TEST-NOT))) (DOLIST (ELT LIST2) (UNLESS (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST1)) (SETQ RESULT (CONS ELT RESULT))))) RESULT))
     [java] ; (DEFUN NSET-EXCLUSIVE-OR (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT (FUNCTION EQL) NOTP)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (LET ((KEY (AND KEY (COERCE-TO-FUNCTION KEY))) (TEST (IF TESTP (COERCE-TO-FUNCTION TEST) TEST)) (TEST-NOT (IF NOTP (COERCE-TO-FUNCTION TEST-NOT) TEST-NOT))) (DO ((LIST1 LIST1) (LIST2 LIST2) (X LIST1 (CDR X)) (SPLICEX NIL) (DELETED-Y NIL)) ((ENDP X) (IF (NULL SPLICEX) (SETQ LIST1 LIST2) (RPLACD SPLICEX LIST2)) LIST1) (LET ((KEY-VAL-X (APPLY-KEY KEY (CAR X))) (FOUND-DUPLICATE NIL)) (DO* ((Y LIST2 NEXT-Y) (NEXT-Y (CDR Y) (CDR Y)) (SPLICEY NIL)) ((ENDP Y)) (COND ((LET ((KEY-VAL-Y (APPLY-KEY KEY (CAR Y)))) (IF NOTP (NOT (FUNCALL TEST-NOT KEY-VAL-X KEY-VAL-Y)) (FUNCALL TEST KEY-VAL-X KEY-VAL-Y))) (IF (NULL SPLICEY) (SETQ LIST2 (CDR Y)) (RPLACD SPLICEY (CDR Y))) (SETQ DELETED-Y (RPLACD Y DELETED-Y)) (SETQ FOUND-DUPLICATE T)) (T (SETQ SPLICEY Y)))) (UNLESS FOUND-DUPLICATE (SETQ FOUND-DUPLICATE (WITH-SET-KEYS (MEMBER KEY-VAL-X DELETED-Y)))) (IF FOUND-DUPLICATE (IF (NULL SPLICEX) (SETQ LIST1 (CDR X)) (RPLACD SPLICEX (CDR X))) (SETQ SPLICEX X))))))
     [java] ; (DEFUN SUBSETP (LIST1 LIST2 &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (REQUIRE-TYPE LIST2 (QUOTE LIST)) (WHEN (AND TESTP NOTP) (ERROR "Both :TEST and :TEST-NOT were supplied.")) (LET ((KEY (AND KEY (COERCE-TO-FUNCTION KEY)))) (DOLIST (ELT LIST1) (UNLESS (WITH-SET-KEYS (MEMBER (FUNCALL-KEY KEY ELT) LIST2)) (RETURN-FROM SUBSETP NIL))) T))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/sets.abcl (0.444 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/shiftf.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO SHIFTF (&REST ARGS &ENVIRONMENT ENV) "One or more SETF-style place expressions, followed by a single
     [java]    value expression.  Evaluates all of the expressions in turn, then
     [java]    assigns the value of each expression to the place on its left,
     [java]    returning the value of the leftmost." (WHEN ARGS (COLLECT ((LET*-BINDINGS) (MV-BINDINGS) (SETTERS) (GETTERS)) (DOLIST (ARG (BUTLAST ARGS)) (MULTIPLE-VALUE-BIND (TEMPS SUBFORMS STORE-VARS SETTER GETTER) (GET-SETF-EXPANSION ARG ENV) (LOOP FOR TEMP IN TEMPS FOR SUBFORM IN SUBFORMS DO (LET*-BINDINGS (BACKQ-LIST TEMP SUBFORM))) (MV-BINDINGS STORE-VARS) (SETTERS SETTER) (GETTERS GETTER))) (SETTERS NIL) (GETTERS (CAR (LAST ARGS))) (LABELS ((THUNK (MV-BINDINGS GETTERS) (IF MV-BINDINGS (BACKQ-LIST (BACKQ-LIST* (QUOTE MULTIPLE-VALUE-BIND) (CAR MV-BINDINGS) (CAR GETTERS) (THUNK (CDR MV-BINDINGS) (CDR GETTERS)))) (BUTLAST (SETTERS))))) (BACKQ-LIST (QUOTE LET*) (LET*-BINDINGS) (BACKQ-LIST* (QUOTE MULTIPLE-VALUE-BIND) (CAR (MV-BINDINGS)) (CAR (GETTERS)) (BACKQ-APPEND (THUNK (MV-BINDINGS) (CDR (GETTERS))) (BACKQ-LIST (BACKQ-CONS (QUOTE VALUES) (CAR (MV-BINDINGS)))))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/shiftf.abcl (0.109 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/signal.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFVAR *MAXIMUM-ERROR-DEPTH* 10)
     [java] ; (DEFVAR *CURRENT-ERROR-DEPTH* 0)
     [java] ; (DEFVAR *HANDLER-CLUSTERS* NIL)
     [java] ; (DEFVAR *BREAK-ON-SIGNALS* NIL)
     [java] ; (DEFUN SIGNAL (DATUM &REST ARGUMENTS) (LET ((CONDITION (COERCE-TO-CONDITION DATUM ARGUMENTS (QUOTE SIMPLE-CONDITION) (QUOTE SIGNAL))) (*HANDLER-CLUSTERS* *HANDLER-CLUSTERS*)) (LET* ((OLD-BOS *BREAK-ON-SIGNALS*) (*BREAK-ON-SIGNALS* NIL)) (WHEN (TYPEP CONDITION OLD-BOS) (LET ((*SAVED-BACKTRACE* (BACKTRACE))) (BREAK "~A~%BREAK called because of *BREAK-ON-SIGNALS* (now rebound to NIL)." CONDITION)))) (LOOP (UNLESS *HANDLER-CLUSTERS* (RETURN)) (LET ((CLUSTER (POP *HANDLER-CLUSTERS*))) (DOLIST (HANDLER CLUSTER) (WHEN (TYPEP CONDITION (CAR HANDLER)) (FUNCALL (CDR HANDLER) CONDITION))))) NIL))
     [java] ; (DEFUN ERROR (DATUM &REST ARGUMENTS) (WHEN (EQ DATUM (QUOTE PRINT-NOT-READABLE)) (RETURN-FROM ERROR (APPLY (FUNCTION %RAISE-UNREADABLE) ARGUMENTS))) (LET ((CONDITION (COERCE-TO-CONDITION DATUM ARGUMENTS (QUOTE SIMPLE-ERROR) (QUOTE ERROR)))) (SIGNAL CONDITION) (LET ((*CURRENT-ERROR-DEPTH* (1+ *CURRENT-ERROR-DEPTH*))) (COND ((> *CURRENT-ERROR-DEPTH* *MAXIMUM-ERROR-DEPTH*) (%FORMAT *DEBUG-IO* "~%Maximum error depth exceeded (~D nested errors) with '~A'.~%" *CURRENT-ERROR-DEPTH* CONDITION) (TRACE-LISP T) (IF (FBOUNDP (QUOTE INTERNAL-DEBUG)) (INTERNAL-DEBUG) (QUIT :STATUS 89))) (T (INVOKE-DEBUGGER CONDITION))))))
     [java] ; (DEFUN COERCE-TO-CONDITION (DATUM ARGUMENTS DEFAULT-TYPE FUN-NAME) (COND ((TYPEP DATUM (QUOTE CONDITION)) (WHEN ARGUMENTS (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM ARGUMENTS :EXPECTED-TYPE (QUOTE NULL) :FORMAT-CONTROL "You may not supply additional arguments when giving ~S to ~S." :FORMAT-ARGUMENTS (LIST DATUM FUN-NAME))) DATUM) ((SYMBOLP DATUM) (%MAKE-CONDITION DATUM ARGUMENTS)) ((OR (STRINGP DATUM) (FUNCTIONP DATUM)) (%MAKE-CONDITION DEFAULT-TYPE (LIST :FORMAT-CONTROL DATUM :FORMAT-ARGUMENTS ARGUMENTS))) (T (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM DATUM :EXPECTED-TYPE (QUOTE (OR SYMBOL STRING)) :FORMAT-CONTROL "Bad argument to ~S: ~S." :FORMAT-ARGUMENTS (LIST FUN-NAME DATUM)))))
     [java] ; (DEFMACRO HANDLER-BIND (BINDINGS &BODY FORMS) (DOLIST (BINDING BINDINGS) (UNLESS (AND (CONSP BINDING) (= (LENGTH BINDING) 2)) (ERROR "ill-formed handler binding ~S" BINDING))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (QUOTE *HANDLER-CLUSTERS*) (BACKQ-LIST* (QUOTE CONS) (BACKQ-CONS (QUOTE LIST) (MAPCAR (LAMBDA (X) (BACKQ-LIST (QUOTE CONS) (BACKQ-LIST (QUOTE QUOTE) (CAR X)) (CADR X))) BINDINGS)) (QUOTE (*HANDLER-CLUSTERS*))))) (BACKQ-LIST (QUOTE JAVA:JRUN-EXCEPTION-PROTECTED) (BACKQ-LIST (QUOTE LAMBDA) NIL (BACKQ-CONS (QUOTE PROGN) FORMS)))))
     [java] ; (DEFMACRO HANDLER-CASE (FORM &REST CASES) (LET ((NO-ERROR-CLAUSE (ASSOC (QUOTE :NO-ERROR) CASES))) (IF NO-ERROR-CLAUSE (LET ((NORMAL-RETURN (MAKE-SYMBOL "normal-return")) (ERROR-RETURN (MAKE-SYMBOL "error-return"))) (BACKQ-LIST (QUOTE BLOCK) ERROR-RETURN (BACKQ-LIST (QUOTE MULTIPLE-VALUE-CALL) (BACKQ-CONS (QUOTE LAMBDA) (CDR NO-ERROR-CLAUSE)) (BACKQ-LIST (QUOTE BLOCK) NORMAL-RETURN (BACKQ-LIST (QUOTE RETURN-FROM) ERROR-RETURN (BACKQ-LIST* (QUOTE HANDLER-CASE) (BACKQ-LIST (QUOTE RETURN-FROM) NORMAL-RETURN FORM) (REMOVE NO-ERROR-CLAUSE CASES))))))) (LET ((TAG (GENSYM)) (VAR (GENSYM)) (ANNOTATED-CASES (MAPCAR (LAMBDA (CASE) (CONS (GENSYM) CASE)) CASES))) (BACKQ-LIST (QUOTE BLOCK) TAG (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-CONS VAR (QUOTE (NIL)))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORABLE) VAR)) (BACKQ-LIST* (QUOTE TAGBODY) (BACKQ-LIST (QUOTE HANDLER-BIND) (MAPCAR (LAMBDA (ANNOTATED-CASE) (LIST (CADR ANNOTATED-CASE) (BACKQ-LIST (QUOTE LAMBDA) (QUOTE (TEMP)) (IF (CADDR ANNOTATED-CASE) (BACKQ-LIST* (QUOTE SETQ) VAR (QUOTE (TEMP))) (QUOTE (DECLARE (IGNORE TEMP)))) (BACKQ-LIST (QUOTE GO) (CAR ANNOTATED-CASE))))) ANNOTATED-CASES) (BACKQ-LIST (QUOTE RETURN-FROM) TAG FORM)) (MAPCAN (LAMBDA (ANNOTATED-CASE) (LIST (CAR ANNOTATED-CASE) (LET ((BODY (CDDDR ANNOTATED-CASE))) (BACKQ-LIST (QUOTE RETURN-FROM) TAG (COND ((CADDR ANNOTATED-CASE) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST (CAADDR ANNOTATED-CASE) VAR)) BODY)) (T (BACKQ-CONS (QUOTE LOCALLY) BODY))))))) ANNOTATED-CASES))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/signal.abcl (0.275 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/socket.lisp ...
     [java] ; (IN-PACKAGE "EXTENSIONS")
     [java] ; (DEFUN GET-SOCKET-STREAM (SOCKET &KEY (ELEMENT-TYPE (QUOTE CHARACTER)) (EXTERNAL-FORMAT :DEFAULT)) ":ELEMENT-TYPE must be CHARACTER or (UNSIGNED-BYTE 8); the default is CHARACTER.
     [java] EXTERNAL-FORMAT must be of the same format as specified for OPEN." (COND ((EQ ELEMENT-TYPE (QUOTE CHARACTER))) ((REDUCE (FUNCTION EQUAL) (MAPCAR (FUNCTION SYSTEM:NORMALIZE-TYPE) (LIST ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8)))))) (T (ERROR (QUOTE SIMPLE-TYPE-ERROR) :FORMAT-CONTROL ":ELEMENT-TYPE must be CHARACTER or (UNSIGNED-BYTE 8)."))) (SYSTEM::%SOCKET-STREAM SOCKET ELEMENT-TYPE EXTERNAL-FORMAT))
     [java] ; (DEFUN MAKE-SOCKET (HOST PORT) "Create a TCP socket for client communication to HOST on PORT." (SYSTEM::%MAKE-SOCKET HOST PORT))
     [java] ; (DEFUN MAKE-SERVER-SOCKET (PORT) "Create a TCP server socket listening for clients on PORT." (SYSTEM::%MAKE-SERVER-SOCKET PORT))
     [java] ; (DEFUN SOCKET-ACCEPT (SOCKET) "Block until able to return a new socket for handling a incoming request to the specified server SOCKET." (SYSTEM::%SOCKET-ACCEPT SOCKET))
     [java] ; (DEFUN SOCKET-CLOSE (SOCKET) "Close the client SOCKET." (SYSTEM::%SOCKET-CLOSE SOCKET))
     [java] ; (DEFUN SERVER-SOCKET-CLOSE (SOCKET) "Close the server SOCKET." (SYSTEM::%SERVER-SOCKET-CLOSE SOCKET))
     [java] ; (DECLAIM (INLINE %SOCKET-ADDRESS %SOCKET-PORT))
     [java] ; (DEFUN %SOCKET-ADDRESS (SOCKET ADDRESS-NAME) "Return the underlying ADDRESS-NAME for SOCKET." (JAVA:JCALL "getHostAddress" (JAVA:JCALL-RAW ADDRESS-NAME SOCKET)))
     [java] ; (DEFUN %SOCKET-PORT (SOCKET PORT-NAME) "Return the PORT-NAME of SOCKET." (JAVA:JCALL PORT-NAME SOCKET))
     [java] ; (DEFUN SOCKET-LOCAL-ADDRESS (SOCKET) "Returns the local address of the SOCKET as a dotted quad string." (%SOCKET-ADDRESS SOCKET "getLocalAddress"))
     [java] ; (DEFUN SOCKET-PEER-ADDRESS (SOCKET) "Returns the peer address of the SOCKET as a dotted quad string." (%SOCKET-ADDRESS SOCKET "getInetAddress"))
     [java] ; (DEFUN SOCKET-LOCAL-PORT (SOCKET) "Returns the local port number of the SOCKET." (%SOCKET-PORT SOCKET "getLocalPort"))
     [java] ; (DEFUN SOCKET-PEER-PORT (SOCKET) "Returns the peer port number of the given SOCKET." (%SOCKET-PORT SOCKET "getPort"))
     [java] ; (DEFUN READ-TIMEOUT (SOCKET SECONDS) "Time in SECONDS to set local implementation of 'SO_RCVTIMEO' on SOCKET." (JAVA:JCALL (JAVA:JMETHOD "java.net.Socket" "setSoTimeout" "int") SOCKET (* SECONDS 1000)))
     [java] ; (DEFUN WRITE-TIMEOUT (SOCKET SECONDS) "No-op setting of write timeout to SECONDS on SOCKET." (DECLARE (IGNORE SOCKET SECONDS)) (WARN "Unimplemented.
     [java]
     [java] Timeouts for writes should be implemented by spawning a guardian
     [java] to the thread perfoming the socket write"))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/socket.abcl (0.265 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sort.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO MERGE-VECTORS-BODY (TYPE REF A START-A END-A B START-B END-B AUX START-AUX PREDICATE &OPTIONAL KEY) (LET ((I-A (GENSYM)) (I-B (GENSYM)) (I-AUX (GENSYM)) (V-A (GENSYM)) (V-B (GENSYM)) (K-A (GENSYM)) (K-B (GENSYM)) (MERGE-BLOCK (GENSYM))) (BACKQ-LIST (QUOTE LOCALLY) (BACKQ-LIST* (QUOTE DECLARE) (BACKQ-LIST (QUOTE TYPE) (QUOTE FIXNUM) START-A END-A START-B END-B START-AUX) (BACKQ-LIST (QUOTE TYPE) TYPE A B) (BACKQ-LIST (QUOTE TYPE) (QUOTE SIMPLE-VECTOR) AUX) (BACKQ-LIST* (QUOTE TYPE) (QUOTE FUNCTION) PREDICATE (IF KEY (BACKQ-LIST KEY))) (QUOTE ((OPTIMIZE (SPEED 3) (SAFETY 0))))) (BACKQ-LIST (QUOTE BLOCK) MERGE-BLOCK (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST I-A START-A) (BACKQ-LIST I-B START-B) (BACKQ-LIST I-AUX START-AUX) V-A V-B K-A K-B) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE TYPE) (QUOTE FIXNUM) I-A I-B I-AUX)) (BACKQ-LIST (QUOTE COND) (BACKQ-LIST (BACKQ-LIST (QUOTE =) START-A END-A) (BACKQ-LIST (QUOTE WHEN) (BACKQ-LIST (QUOTE =) START-B END-B) (BACKQ-LIST (QUOTE RETURN-FROM) MERGE-BLOCK)) (BACKQ-LIST (QUOTE SETF) I-A START-B END-A END-B A B V-A (BACKQ-LIST REF A I-A))) (BACKQ-LIST (BACKQ-LIST (QUOTE =) START-B END-B) (BACKQ-LIST (QUOTE SETF) I-A START-A V-A (BACKQ-LIST REF A I-A))) (BACKQ-LIST (QUOTE T) (BACKQ-LIST* (QUOTE SETF) V-A (BACKQ-LIST REF A I-A) V-B (BACKQ-LIST REF B I-B) (BACKQ-APPEND (IF KEY (BACKQ-LIST K-A (BACKQ-LIST (QUOTE FUNCALL) KEY V-A)) (BACKQ-LIST K-A V-A)) (IF KEY (BACKQ-LIST K-B (BACKQ-LIST (QUOTE FUNCALL) KEY V-B)) (BACKQ-LIST K-B V-B)))) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE FUNCALL) PREDICATE K-B K-A) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE AREF) AUX I-AUX) V-B I-AUX (BACKQ-LIST* (QUOTE +) I-AUX (QUOTE (1))) I-B (BACKQ-LIST* (QUOTE +) I-B (QUOTE (1)))) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST (QUOTE =) I-B END-B) (QUOTE ((RETURN)))) (BACKQ-LIST* (QUOTE SETF) V-B (BACKQ-LIST REF B I-B) (IF KEY (BACKQ-LIST K-B (BACKQ-LIST (QUOTE FUNCALL) KEY V-B)) (BACKQ-LIST K-B V-B)))) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE AREF) AUX I-AUX) V-A I-AUX (BACKQ-LIST* (QUOTE +) I-AUX (QUOTE (1))) I-A (BACKQ-LIST* (QUOTE +) I-A (QUOTE (1)))) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST (QUOTE =) I-A END-A) (BACKQ-LIST (QUOTE SETF) A B I-A I-B END-A END-B V-A V-B) (QUOTE ((RETURN)))) (BACKQ-LIST* (QUOTE SETF) V-A (BACKQ-LIST REF A I-A) (IF KEY (BACKQ-LIST K-A (BACKQ-LIST (QUOTE FUNCALL) KEY V-A)) (BACKQ-LIST K-A V-A)))))))) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST (QUOTE AREF) AUX I-AUX) V-A I-A (BACKQ-LIST* (QUOTE +) I-A (QUOTE (1)))) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST (QUOTE =) I-A END-A) (QUOTE ((RETURN)))) (BACKQ-LIST (QUOTE SETF) V-A (BACKQ-LIST REF A I-A) I-AUX (BACKQ-LIST* (QUOTE +) I-AUX (QUOTE (1))))))))))
     [java] ; (DEFMACRO MERGE-SORT-BODY (TYPE REF MPREDICATE MKEY MSEQUENCE MSTART MEND) (LET ((MERGE-SORT-CALL (GENSYM)) (MAUX (GENSYM)) (AUX (GENSYM)) (SEQUENCE (GENSYM)) (START (GENSYM)) (END (GENSYM)) (PREDICATE (GENSYM)) (KEY (GENSYM)) (MID (GENSYM)) (DIRECTION (GENSYM))) (BACKQ-LIST (QUOTE LOCALLY) (QUOTE (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0)))) (BACKQ-LIST (QUOTE LABELS) (BACKQ-LIST (BACKQ-LIST MERGE-SORT-CALL (BACKQ-LIST SEQUENCE START END PREDICATE KEY AUX DIRECTION) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST* (QUOTE TYPE) (QUOTE FUNCTION) PREDICATE (IF MKEY (BACKQ-LIST KEY))) (BACKQ-LIST (QUOTE TYPE) (QUOTE FIXNUM) START END) (BACKQ-LIST (QUOTE TYPE) TYPE SEQUENCE)) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST MID (BACKQ-LIST (QUOTE +) START (BACKQ-LIST* (QUOTE ASH) (BACKQ-LIST (QUOTE -) END START) (QUOTE (-1)))))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE TYPE) (QUOTE FIXNUM) MID)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE <=) (BACKQ-LIST* (QUOTE -) MID (QUOTE (1))) START) (BACKQ-LIST (QUOTE UNLESS) DIRECTION (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST REF AUX START) (BACKQ-LIST REF SEQUENCE START))) (BACKQ-LIST MERGE-SORT-CALL SEQUENCE START MID PREDICATE KEY AUX (BACKQ-LIST (QUOTE NOT) DIRECTION))) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE >=) (BACKQ-LIST* (QUOTE +) MID (QUOTE (1))) END) (BACKQ-LIST (QUOTE UNLESS) DIRECTION (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST REF AUX MID) (BACKQ-LIST REF SEQUENCE MID))) (BACKQ-LIST MERGE-SORT-CALL SEQUENCE MID END PREDICATE KEY AUX (BACKQ-LIST (QUOTE NOT) DIRECTION))) (BACKQ-LIST (QUOTE UNLESS) DIRECTION (BACKQ-LIST (QUOTE PSETQ) SEQUENCE AUX AUX SEQUENCE)) (IF MKEY (BACKQ-LIST (QUOTE MERGE-VECTORS-BODY) TYPE REF SEQUENCE START MID SEQUENCE MID END AUX START PREDICATE KEY) (BACKQ-LIST (QUOTE MERGE-VECTORS-BODY) TYPE REF SEQUENCE START MID SEQUENCE MID END AUX START PREDICATE))))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST MAUX (BACKQ-LIST (QUOTE MAKE-ARRAY) MEND))) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE TYPE) (QUOTE VECTOR) MAUX)) (BACKQ-LIST* MERGE-SORT-CALL MSEQUENCE MSTART MEND MPREDICATE MKEY MAUX (QUOTE (NIL))))))))
     [java] ; (DEFUN MERGE-SORT-VECTORS (SEQUENCE PREDICATE KEY) (LET ((END (LENGTH SEQUENCE))) (TYPECASE SEQUENCE (SIMPLE-VECTOR (IF KEY (MERGE-SORT-BODY SIMPLE-VECTOR SVREF PREDICATE KEY SEQUENCE 0 END) (MERGE-SORT-BODY SIMPLE-VECTOR SVREF PREDICATE NIL SEQUENCE 0 END))) (VECTOR (IF KEY (MERGE-SORT-BODY VECTOR AREF PREDICATE KEY SEQUENCE 0 END) (MERGE-SORT-BODY VECTOR AREF PREDICATE NIL SEQUENCE 0 END)))) SEQUENCE))
     [java] ; (DECLAIM (FTYPE (FUNCTION (LIST) CONS) LAST-CONS-OF))
     [java] ; (DEFUN LAST-CONS-OF (LIST) (LOOP (LET ((REST (REST LIST))) (IF REST (SETF LIST REST) (RETURN LIST)))))
     [java] ; (DEFUN MERGE-LISTS (LIST1 LIST2 PRED KEY) (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0))) (IF (NULL KEY) (MERGE-LISTS-NO-KEY LIST1 LIST2 PRED) (COND ((NULL LIST1) (VALUES LIST2 (LAST-CONS-OF LIST2))) ((NULL LIST2) (VALUES LIST1 (LAST-CONS-OF LIST1))) (T (LET* ((RESULT (CONS NIL NIL)) (P RESULT) (KEY1 (FUNCALL KEY (CAR LIST1))) (KEY2 (FUNCALL KEY (CAR LIST2)))) (DECLARE (TYPE LIST P)) (LOOP (COND ((FUNCALL PRED KEY2 KEY1) (RPLACD P LIST2) (SETF P (CDR P)) (POP LIST2) (UNLESS LIST2 (RPLACD P LIST1) (RETURN (VALUES (CDR RESULT) (LAST-CONS-OF P)))) (SETF KEY2 (FUNCALL KEY (CAR LIST2)))) (T (RPLACD P LIST1) (SETF P (CDR P)) (POP LIST1) (UNLESS LIST1 (RPLACD P LIST2) (RETURN (VALUES (CDR RESULT) (LAST-CONS-OF P)))) (SETF KEY1 (FUNCALL KEY (CAR LIST1)))))))))))
     [java] ; (DEFUN MERGE-LISTS-NO-KEY (LIST1 LIST2 PRED) (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0))) (COND ((NULL LIST1) (VALUES LIST2 (LAST-CONS-OF LIST2))) ((NULL LIST2) (VALUES LIST1 (LAST-CONS-OF LIST1))) (T (LET* ((RESULT (CONS NIL NIL)) (P RESULT) (KEY1 (CAR LIST1)) (KEY2 (CAR LIST2))) (DECLARE (TYPE LIST P)) (LOOP (COND ((FUNCALL PRED KEY2 KEY1) (RPLACD P LIST2) (SETF P (CDR P)) (POP LIST2) (UNLESS LIST2 (RPLACD P LIST1) (RETURN (VALUES (CDR RESULT) (LAST-CONS-OF P)))) (SETF KEY2 (CAR LIST2))) (T (RPLACD P LIST1) (SETF P (CDR P)) (POP LIST1) (UNLESS LIST1 (RPLACD P LIST2) (RETURN (VALUES (CDR RESULT) (LAST-CONS-OF P)))) (SETF KEY1 (CAR LIST1)))))))))
     [java] ; (DEFUN SORT-LIST (LIST PRED KEY) (WHEN (OR (EQ KEY (FUNCTION IDENTITY)) (EQ KEY (QUOTE IDENTITY))) (SETF KEY NIL)) (LET ((HEAD (CONS NIL LIST)) (N 1) UNSORTED LIST-1 LAST) (DECLARE (TYPE FIXNUM N)) (LOOP (SETF UNSORTED (CDR HEAD)) (SETF LAST HEAD) (LET ((N-1 (1- N))) (DECLARE (TYPE FIXNUM N-1)) (LOOP (SETF LIST-1 UNSORTED) (LET ((TEMP (NTHCDR N-1 LIST-1)) LIST-2) (COND (TEMP (SETF LIST-2 (CDR TEMP)) (SETF (CDR TEMP) NIL) (SETF TEMP (NTHCDR N-1 LIST-2)) (COND (TEMP (SETF UNSORTED (CDR TEMP)) (SETF (CDR TEMP) NIL)) (T (SETF UNSORTED NIL))) (MULTIPLE-VALUE-BIND (MERGED-HEAD MERGED-LAST) (MERGE-LISTS LIST-1 LIST-2 PRED KEY) (SETF (CDR LAST) MERGED-HEAD) (SETF LAST MERGED-LAST)) (IF (NULL UNSORTED) (RETURN))) (T (SETF (CDR LAST) LIST-1) (RETURN))))) (SETF N (+ N N)) (IF (EQ LIST-1 (CDR HEAD)) (RETURN LIST-1))))))
     [java] ; (DEFUN MERGE (RESULT-TYPE SEQUENCE1 SEQUENCE2 PREDICATE &KEY KEY &AUX (L1 (LENGTH SEQUENCE1)) (L2 (LENGTH SEQUENCE2))) (UNLESS KEY (SETQ KEY (FUNCTION IDENTITY))) (DO ((NEWSEQ (MAKE-SEQUENCE RESULT-TYPE (+ L1 L2))) (J 0 (1+ J)) (I1 0) (I2 0)) ((AND (= I1 L1) (= I2 L2)) NEWSEQ) (COND ((AND (< I1 L1) (< I2 L2)) (COND ((FUNCALL PREDICATE (FUNCALL KEY (ELT SEQUENCE1 I1)) (FUNCALL KEY (ELT SEQUENCE2 I2))) (SETF (ELT NEWSEQ J) (ELT SEQUENCE1 I1)) (INCF I1)) ((FUNCALL PREDICATE (FUNCALL KEY (ELT SEQUENCE2 I2)) (FUNCALL KEY (ELT SEQUENCE1 I1))) (SETF (ELT NEWSEQ J) (ELT SEQUENCE2 I2)) (INCF I2)) (T (SETF (ELT NEWSEQ J) (ELT SEQUENCE1 I1)) (INCF I1)))) ((< I1 L1) (SETF (ELT NEWSEQ J) (ELT SEQUENCE1 I1)) (INCF I1)) (T (SETF (ELT NEWSEQ J) (ELT SEQUENCE2 I2)) (INCF I2)))))
     [java] ; (DEFMACRO QUICKSORT-BODY (TYPE REF MPREDICATE MKEY SEQUENCE MSTART MEND) (LET ((QUICKSORT-CALL (GENSYM)) (PREDICATE (GENSYM)) (KEY (GENSYM)) (VECTOR (GENSYM)) (START (GENSYM)) (END (GENSYM)) (I (GENSYM)) (J (GENSYM)) (P (GENSYM)) (D (GENSYM)) (KD (GENSYM))) (BACKQ-LIST (QUOTE LOCALLY) (QUOTE (DECLARE (SPEED 3) (SAFETY 0))) (BACKQ-LIST (QUOTE LABELS) (BACKQ-LIST (BACKQ-LIST QUICKSORT-CALL (BACKQ-LIST VECTOR START END PREDICATE KEY) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST* (QUOTE TYPE) (QUOTE FUNCTION) PREDICATE (IF MKEY (BACKQ-LIST KEY))) (BACKQ-LIST (QUOTE TYPE) (QUOTE FIXNUM) START END) (BACKQ-LIST (QUOTE TYPE) TYPE SEQUENCE)) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE <) START END) (BACKQ-LIST (QUOTE LET*) (BACKQ-LIST* (BACKQ-LIST I START) (BACKQ-LIST J (BACKQ-LIST (QUOTE 1+) END)) (BACKQ-LIST P (BACKQ-LIST (QUOTE THE) (QUOTE FIXNUM) (BACKQ-LIST (QUOTE +) START (BACKQ-LIST* (QUOTE ASH) (BACKQ-LIST (QUOTE -) END START) (QUOTE (-1)))))) (BACKQ-LIST D (BACKQ-LIST REF VECTOR P)) (IF MKEY (BACKQ-LIST (BACKQ-LIST KD (BACKQ-LIST (QUOTE FUNCALL) KEY D))) (BACKQ-LIST (BACKQ-LIST KD D)))) (BACKQ-LIST (QUOTE ROTATEF) (BACKQ-LIST REF VECTOR P) (BACKQ-LIST REF VECTOR START)) (BACKQ-LIST (QUOTE BLOCK) (QUOTE OUTER-LOOP) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST* (QUOTE UNLESS) (BACKQ-LIST (QUOTE >) (BACKQ-LIST (QUOTE DECF) J) I) (QUOTE ((RETURN-FROM OUTER-LOOP)))) (BACKQ-LIST* (QUOTE WHEN) (BACKQ-LIST* (QUOTE FUNCALL) PREDICATE (BACKQ-APPEND (IF MKEY (BACKQ-LIST (BACKQ-LIST (QUOTE FUNCALL) KEY (BACKQ-LIST REF VECTOR J))) (BACKQ-LIST (BACKQ-LIST REF VECTOR J))) (BACKQ-LIST KD))) (QUOTE ((RETURN))))) (BACKQ-LIST (QUOTE LOOP) (BACKQ-LIST* (QUOTE UNLESS) (BACKQ-LIST (QUOTE <) (BACKQ-LIST (QUOTE INCF) I) J) (QUOTE ((RETURN-FROM OUTER-LOOP)))) (BACKQ-LIST* (QUOTE UNLESS) (BACKQ-LIST* (QUOTE FUNCALL) PREDICATE (BACKQ-APPEND (IF MKEY (BACKQ-LIST (BACKQ-LIST (QUOTE FUNCALL) KEY (BACKQ-LIST REF VECTOR I))) (BACKQ-LIST (BACKQ-LIST REF VECTOR I))) (BACKQ-LIST KD))) (QUOTE ((RETURN))))) (BACKQ-LIST (QUOTE ROTATEF) (BACKQ-LIST REF VECTOR I) (BACKQ-LIST REF VECTOR J)))) (BACKQ-LIST (QUOTE SETF) (BACKQ-LIST REF VECTOR START) (BACKQ-LIST REF VECTOR J) (BACKQ-LIST REF VECTOR J) D) (BACKQ-LIST (QUOTE IF) (BACKQ-LIST (QUOTE <) (BACKQ-LIST (QUOTE -) J START) (BACKQ-LIST (QUOTE -) END J)) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST QUICKSORT-CALL VECTOR START (BACKQ-LIST (QUOTE 1-) J) PREDICATE KEY) (BACKQ-LIST QUICKSORT-CALL VECTOR (BACKQ-LIST (QUOTE 1+) J) END PREDICATE KEY)) (BACKQ-LIST (QUOTE PROGN) (BACKQ-LIST QUICKSORT-CALL VECTOR (BACKQ-LIST (QUOTE 1+) J) END PREDICATE KEY) (BACKQ-LIST QUICKSORT-CALL VECTOR START (BACKQ-LIST (QUOTE 1-) J) PREDICATE KEY))))))) (BACKQ-LIST QUICKSORT-CALL SEQUENCE MSTART MEND MPREDICATE MKEY)))))
     [java] ; (DEFUN QUICKSORT (SEQUENCE PREDICATE KEY) (HANDLER-CASE (LET ((END (1- (LENGTH SEQUENCE)))) (TYPECASE SEQUENCE (SIMPLE-VECTOR (IF KEY (QUICKSORT-BODY SIMPLE-VECTOR SVREF PREDICATE KEY SEQUENCE 0 END) (QUICKSORT-BODY SIMPLE-VECTOR SVREF PREDICATE NIL SEQUENCE 0 END))) (VECTOR (IF KEY (QUICKSORT-BODY VECTOR AREF PREDICATE KEY SEQUENCE 0 END) (QUICKSORT-BODY VECTOR AREF PREDICATE NIL SEQUENCE 0 END)))) SEQUENCE) (T (E) (WARN "~&New quicksort implementation failed with~&'~A'.~&Trying stable implementation...~&" E) (QUICK-SORT SEQUENCE 0 (LENGTH SEQUENCE) PREDICATE KEY))))
     [java] ; (DEFUN QUICK-SORT (SEQ START END PRED KEY) (UNLESS KEY (SETQ KEY (FUNCTION IDENTITY))) (IF (<= END (1+ START)) SEQ (LET* ((J START) (K END) (D (ELT SEQ START)) (KD (FUNCALL KEY D))) (BLOCK OUTER-LOOP (LOOP (LOOP (DECF K) (UNLESS (< J K) (RETURN-FROM OUTER-LOOP)) (WHEN (FUNCALL PRED (FUNCALL KEY (ELT SEQ K)) KD) (RETURN))) (LOOP (INCF J) (UNLESS (< J K) (RETURN-FROM OUTER-LOOP)) (UNLESS (FUNCALL PRED (FUNCALL KEY (ELT SEQ J)) KD) (RETURN))) (LET ((TEMP (ELT SEQ J))) (SETF (ELT SEQ J) (ELT SEQ K) (ELT SEQ K) TEMP)))) (SETF (ELT SEQ START) (ELT SEQ J) (ELT SEQ J) D) (QUICK-SORT SEQ START J PRED KEY) (QUICK-SORT SEQ (1+ J) END PRED KEY))))
     [java] ; (DEFUN SORT (SEQUENCE PREDICATE &REST ARGS &KEY KEY) (SEQUENCE::SEQ-DISPATCH SEQUENCE (SORT-LIST SEQUENCE PREDICATE KEY) (QUICKSORT SEQUENCE PREDICATE KEY) (APPLY (FUNCTION SEQUENCE:SORT) SEQUENCE PREDICATE ARGS)))
     [java] ; (DEFUN STABLE-SORT (SEQUENCE PREDICATE &REST ARGS &KEY KEY) (SEQUENCE::SEQ-DISPATCH SEQUENCE (SORT-LIST SEQUENCE PREDICATE KEY) (MERGE-SORT-VECTORS SEQUENCE PREDICATE KEY) (APPLY (FUNCTION SEQUENCE:STABLE-SORT) SEQUENCE PREDICATE ARGS)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/sort.abcl (1.02 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/step.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO STEP (FORM) (BACKQ-LIST (QUOTE LET) NIL FORM))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/step.abcl (0.05 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/strings.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN STRING-UPCASE (STRING &KEY (START 0) END) (%STRING-UPCASE STRING START END))
     [java] ; (DEFUN STRING-DOWNCASE (STRING &KEY (START 0) END) (%STRING-DOWNCASE STRING START END))
     [java] ; (DEFUN STRING-CAPITALIZE (STRING &KEY (START 0) END) (%STRING-CAPITALIZE STRING START END))
     [java] ; (DEFUN NSTRING-UPCASE (STRING &KEY (START 0) END) (%NSTRING-UPCASE STRING START END))
     [java] ; (DEFUN NSTRING-DOWNCASE (STRING &KEY (START 0) END) (%NSTRING-DOWNCASE STRING START END))
     [java] ; (DEFUN NSTRING-CAPITALIZE (STRING &KEY (START 0) END) (%NSTRING-CAPITALIZE STRING START END))
     [java] ; (DEFUN STRING= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (%STRING= STRING1 STRING2 START1 END1 START2 END2))
     [java] ; (DEFUN STRING/= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING/= STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-EQUAL (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-EQUAL STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-NOT-EQUAL (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-NOT-EQUAL STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING< (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING< STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING> (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING> STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING<= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING<= STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING>= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING>= STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-LESSP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-LESSP STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-GREATERP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-GREATERP STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-NOT-LESSP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-NOT-LESSP STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-NOT-GREATERP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2) (LET* ((STRING1 (STRING STRING1)) (STRING2 (STRING STRING2)) (END1 (OR END1 (LENGTH STRING1))) (END2 (OR END2 (LENGTH STRING2)))) (%STRING-NOT-GREATERP STRING1 STRING2 START1 END1 START2 END2)))
     [java] ; (DEFUN STRING-LEFT-TRIM (CHAR-BAG STRING &AUX END) "Given a set of characters (a list or string) and a string, returns
     [java]    a copy of the string with the characters in the set removed from the
     [java]    left end." (SETQ STRING (STRING STRING)) (SETQ END (LENGTH STRING)) (DO ((INDEX 0 (+ INDEX 1))) ((OR (= INDEX END) (NOT (FIND (AREF STRING INDEX) CHAR-BAG))) (SUBSEQ STRING INDEX END))))
     [java] ; (DEFUN STRING-RIGHT-TRIM (CHAR-BAG STRING &AUX END) "Given a set of characters (a list or string) and a string, returns
     [java]    a copy of the string with the characters in the set removed from the
     [java]    right end." (SETQ STRING (STRING STRING)) (SETQ END (LENGTH STRING)) (DO ((INDEX (- END 1) (- INDEX 1))) ((OR (< INDEX 0) (NOT (FIND (AREF STRING INDEX) CHAR-BAG))) (SUBSEQ STRING 0 (+ INDEX 1)))))
     [java] ; (DEFUN STRING-TRIM (CHAR-BAG STRING &AUX END) "Given a set of characters (a list or string) and a string, returns a
     [java]    copy of the string with the characters in the set removed from both
     [java]    ends." (SETQ STRING (STRING STRING)) (SETQ END (LENGTH STRING)) (LET (LEFT-END RIGHT-END) (DO ((INDEX 0 (+ INDEX 1))) ((OR (= INDEX END) (NOT (FIND (AREF STRING INDEX) CHAR-BAG))) (SETQ LEFT-END INDEX))) (DO ((INDEX (- END 1) (- INDEX 1))) ((OR (< INDEX LEFT-END) (NOT (FIND (AREF STRING INDEX) CHAR-BAG))) (SETQ RIGHT-END INDEX))) (SUBSEQ STRING LEFT-END (+ RIGHT-END 1))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/strings.abcl (0.429 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/sublis.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFUN SUBLIS (ALIST TREE &KEY KEY (TEST (FUNCTION EQL)) (TEST-NOT NIL NOTP)) (LABELS ((S (SUBTREE) (LET* ((KEY-VAL (SYSTEM::APPLY-KEY KEY SUBTREE)) (ASSOC (IF NOTP (ASSOC KEY-VAL ALIST :TEST-NOT TEST-NOT) (ASSOC KEY-VAL ALIST :TEST TEST)))) (COND (ASSOC (CDR ASSOC)) ((ATOM SUBTREE) SUBTREE) (T (LET ((CAR (S (CAR SUBTREE))) (CDR (S (CDR SUBTREE)))) (IF (AND (EQ CAR (CAR SUBTREE)) (EQ CDR (CDR SUBTREE))) SUBTREE (CONS CAR CDR)))))))) (S TREE)))
     [java] ; (DEFMACRO NSUBLIS-MACRO NIL (LET ((KEY-TMP (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS KEY-TMP (QUOTE ((SYSTEM::APPLY-KEY KEY SUBTREE))))) (SYSTEM::BACKQ-LIST (QUOTE IF) (QUOTE NOTP) (SYSTEM::BACKQ-LIST* (QUOTE ASSOC) KEY-TMP (QUOTE (ALIST :TEST-NOT TEST-NOT))) (SYSTEM::BACKQ-LIST* (QUOTE ASSOC) KEY-TMP (QUOTE (ALIST :TEST TEST)))))))
     [java] ; (DEFUN NSUBLIS (ALIST TREE &KEY KEY (TEST (FUNCTION EQL)) (TEST-NOT NIL NOTP)) (LET (TEMP) (LABELS ((S (SUBTREE) (COND ((SETQ TEMP (NSUBLIS-MACRO)) (CDR TEMP)) ((ATOM SUBTREE) SUBTREE) (T (DO* ((LAST NIL SUBTREE) (SUBTREE SUBTREE (CDR SUBTREE))) ((ATOM SUBTREE) (IF (SETQ TEMP (NSUBLIS-MACRO)) (SETF (CDR LAST) (CDR TEMP)))) (IF (SETQ TEMP (NSUBLIS-MACRO)) (RETURN (SETF (CDR LAST) (CDR TEMP))) (SETF (CAR SUBTREE) (S (CAR SUBTREE))))) SUBTREE)))) (S TREE))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/sublis.abcl (0.16 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/subst.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO SATISFIES-THE-TEST (ITEM ELT) (LET ((KEY-TMP (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST KEY-TMP (BACKQ-LIST (QUOTE APPLY-KEY) (QUOTE KEY) ELT))) (BACKQ-LIST (QUOTE COND) (BACKQ-LIST (QUOTE TESTP) (BACKQ-LIST (QUOTE FUNCALL) (QUOTE TEST) ITEM KEY-TMP)) (BACKQ-LIST (QUOTE NOTP) (BACKQ-LIST (QUOTE NOT) (BACKQ-LIST (QUOTE FUNCALL) (QUOTE TEST-NOT) ITEM KEY-TMP))) (BACKQ-LIST (QUOTE T) (BACKQ-LIST (QUOTE FUNCALL) (QUOTE TEST) ITEM KEY-TMP))))))
     [java] ; (DEFUN %SUBST (NEW OLD TREE KEY TEST TESTP TEST-NOT NOTP) (COND ((SATISFIES-THE-TEST OLD TREE) NEW) ((ATOM TREE) TREE) (T (LET ((CAR (%SUBST NEW OLD (CAR TREE) KEY TEST TESTP TEST-NOT NOTP)) (CDR (%SUBST NEW OLD (CDR TREE) KEY TEST TESTP TEST-NOT NOTP))) (IF (AND (EQ CAR (CAR TREE)) (EQ CDR (CDR TREE))) TREE (CONS CAR CDR))))))
     [java] ; (DEFUN SUBST (NEW OLD TREE &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (%SUBST NEW OLD TREE KEY TEST TESTP TEST-NOT NOTP))
     [java] ; (DEFUN %SUBST-IF (NEW TEST TREE KEY) (COND ((FUNCALL TEST (APPLY-KEY KEY TREE)) NEW) ((ATOM TREE) TREE) (T (LET ((CAR (%SUBST-IF NEW TEST (CAR TREE) KEY)) (CDR (%SUBST-IF NEW TEST (CDR TREE) KEY))) (IF (AND (EQ CAR (CAR TREE)) (EQ CDR (CDR TREE))) TREE (CONS CAR CDR))))))
     [java] ; (DEFUN SUBST-IF (NEW TEST TREE &KEY KEY) (%SUBST-IF NEW TEST TREE KEY))
     [java] ; (DEFUN %SUBST-IF-NOT (NEW TEST TREE KEY) (COND ((NOT (FUNCALL TEST (APPLY-KEY KEY TREE))) NEW) ((ATOM TREE) TREE) (T (LET ((CAR (%SUBST-IF-NOT NEW TEST (CAR TREE) KEY)) (CDR (%SUBST-IF-NOT NEW TEST (CDR TREE) KEY))) (IF (AND (EQ CAR (CAR TREE)) (EQ CDR (CDR TREE))) TREE (CONS CAR CDR))))))
     [java] ; (DEFUN SUBST-IF-NOT (NEW TEST TREE &KEY KEY) (%SUBST-IF-NOT NEW TEST TREE KEY))
     [java] ; (DEFUN NSUBST (NEW OLD TREE &KEY KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (LABELS ((S (SUBTREE) (COND ((SATISFIES-THE-TEST OLD SUBTREE) NEW) ((ATOM SUBTREE) SUBTREE) (T (DO* ((LAST NIL SUBTREE) (SUBTREE SUBTREE (CDR SUBTREE))) ((ATOM SUBTREE) (IF (SATISFIES-THE-TEST OLD SUBTREE) (SETF (CDR LAST) NEW))) (IF (SATISFIES-THE-TEST OLD SUBTREE) (RETURN (SETF (CDR LAST) NEW)) (SETF (CAR SUBTREE) (S (CAR SUBTREE))))) SUBTREE)))) (S TREE)))
     [java] ; (DEFUN NSUBST-IF (NEW TEST TREE &KEY KEY) (LABELS ((S (SUBTREE) (COND ((FUNCALL TEST (APPLY-KEY KEY SUBTREE)) NEW) ((ATOM SUBTREE) SUBTREE) (T (DO* ((LAST NIL SUBTREE) (SUBTREE SUBTREE (CDR SUBTREE))) ((ATOM SUBTREE) (IF (FUNCALL TEST (APPLY-KEY KEY SUBTREE)) (SETF (CDR LAST) NEW))) (IF (FUNCALL TEST (APPLY-KEY KEY SUBTREE)) (RETURN (SETF (CDR LAST) NEW)) (SETF (CAR SUBTREE) (S (CAR SUBTREE))))) SUBTREE)))) (S TREE)))
     [java] ; (DEFUN NSUBST-IF-NOT (NEW TEST TREE &KEY KEY) (LABELS ((S (SUBTREE) (COND ((NOT (FUNCALL TEST (APPLY-KEY KEY SUBTREE))) NEW) ((ATOM SUBTREE) SUBTREE) (T (DO* ((LAST NIL SUBTREE) (SUBTREE SUBTREE (CDR SUBTREE))) ((ATOM SUBTREE) (IF (NOT (FUNCALL TEST (APPLY-KEY KEY SUBTREE))) (SETF (CDR LAST) NEW))) (IF (NOT (FUNCALL TEST (APPLY-KEY KEY SUBTREE))) (RETURN (SETF (CDR LAST) NEW)) (SETF (CAR SUBTREE) (S (CAR SUBTREE))))) SUBTREE)))) (S TREE)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/subst.abcl (0.302 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/tailp.lisp ...
     [java] ; (IN-PACKAGE "COMMON-LISP")
     [java] ; (DEFUN TAILP (OBJECT LIST) (DO ((LIST LIST (CDR LIST))) ((ATOM LIST) (EQL LIST OBJECT)) (IF (EQL OBJECT LIST) (RETURN T))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/tailp.abcl (0.042 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/threads.lisp ...
     [java] ; (IN-PACKAGE #:THREADS)
     [java] ; (DEFUN THREAD-FUNCTION-WRAPPER (FUN) (RESTART-CASE (FUNCALL FUN) (ABORT NIL :REPORT "Abort thread.")))
     [java] ; (DEFSTRUCT MAILBOX QUEUE)
     [java] ; (DEFUN MAILBOX-SEND (MAILBOX ITEM) "Sends an item into the mailbox, notifying 1 waiter
     [java] to wake up for retrieval of that object." (SYNCHRONIZED-ON MAILBOX (PUSH ITEM (MAILBOX-QUEUE MAILBOX)) (OBJECT-NOTIFY MAILBOX)))
     [java] ; (DEFUN MAILBOX-EMPTY-P (MAILBOX) "Returns non-NIL if the mailbox can be read from, NIL otherwise." (NULL (MAILBOX-QUEUE MAILBOX)))
     [java] ; (DEFUN MAILBOX-READ (MAILBOX) "Blocks on the mailbox until an item is available for reading.
     [java] When an item is available, it is returned." (SYNCHRONIZED-ON MAILBOX (LOOP (UNLESS (MAILBOX-EMPTY-P MAILBOX) (RETURN)) (OBJECT-WAIT MAILBOX)) (POP (MAILBOX-QUEUE MAILBOX))))
     [java] ; (DEFUN MAILBOX-PEEK (MAILBOX) "Returns two values. The second returns non-NIL when the mailbox
     [java] is empty. The first is the next item to be read from the mailbox.
     [java]
     [java] Note that due to multi-threading, the first value returned upon
     [java] peek, may be different from the one returned upon next read in the
     [java] calling thread." (SYNCHRONIZED-ON MAILBOX (VALUES (CAR (MAILBOX-QUEUE MAILBOX)) (NULL (MAILBOX-QUEUE MAILBOX)))))
     [java] ; (DEFSTRUCT MUTEX IN-USE)
     [java] ; (DEFUN GET-MUTEX (MUTEX) "Acquires a lock on the `mutex'." (SYNCHRONIZED-ON MUTEX (LOOP WHILE (MUTEX-IN-USE MUTEX) DO (OBJECT-WAIT MUTEX)) (SETF (MUTEX-IN-USE MUTEX) T)))
     [java] ; (DEFUN RELEASE-MUTEX (MUTEX) "Releases a lock on the `mutex'." (SYNCHRONIZED-ON MUTEX (SETF (MUTEX-IN-USE MUTEX) NIL) (OBJECT-NOTIFY MUTEX)))
     [java] ; (DEFMACRO WITH-MUTEX ((MUTEX) &BODY BODY) "Acquires a lock on `mutex', executes the body
     [java] and releases the lock." (LET ((M (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST M MUTEX)) (SYSTEM::BACKQ-LIST (QUOTE WHEN) (SYSTEM::BACKQ-LIST (QUOTE GET-MUTEX) M) (SYSTEM::BACKQ-LIST (QUOTE UNWIND-PROTECT) (SYSTEM::BACKQ-CONS (QUOTE PROGN) BODY) (SYSTEM::BACKQ-LIST (QUOTE RELEASE-MUTEX) M))))))
     [java] ; (DEFUN MAKE-THREAD-LOCK NIL "Returns an object to be used with the `with-thread-lock' macro." (GENSYM))
     [java] ; (DEFMACRO WITH-THREAD-LOCK ((LOCK) &BODY BODY) "Acquires a lock on the `lock', executes `body' and releases the lock." (LET ((GLOCK (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST GLOCK LOCK)) (SYSTEM::BACKQ-LIST* (QUOTE SYNCHRONIZED-ON) GLOCK BODY))))
     [java] ; (DEFUN YIELD NIL "A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.
     [java]
     [java] See java.lang.Thread.yield()." (JAVA:JCALL "yield" (JAVA:JSTATIC "currentThread" "java.lang.Thread")))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/threads.abcl (0.616 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/time.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFCONSTANT SECONDS-IN-WEEK (* 60 60 24 7))
     [java] ; (DEFCONSTANT WEEKS-OFFSET 2145)
     [java] ; (DEFCONSTANT SECONDS-OFFSET 432000)
     [java] ; (DEFCONSTANT MINUTES-PER-DAY (* 24 60))
     [java] ; (DEFCONSTANT QUARTER-DAYS-PER-YEAR (1+ (* 365 4)))
     [java] ; (DEFCONSTANT QUARTER-DAYS-PER-CENTURY 146097)
     [java] ; (DEFCONSTANT NOVEMBER-17-1858 678882)
     [java] ; (DEFCONSTANT WEEKDAY-NOVEMBER-17-1858 2)
     [java] ; (DEFUN DECODE-UNIVERSAL-TIME (UNIVERSAL-TIME &OPTIONAL TIME-ZONE) (LET (SECONDS-WEST DAYLIGHT) (IF TIME-ZONE (SETF SECONDS-WEST (* TIME-ZONE 3600) DAYLIGHT NIL) (MULTIPLE-VALUE-BIND (TIME-ZONE DAYLIGHT-P) (GET-TIME-ZONE UNIVERSAL-TIME) (SETF SECONDS-WEST (* TIME-ZONE 3600) DAYLIGHT DAYLIGHT-P))) (MULTIPLE-VALUE-BIND (WEEKS SECS) (TRUNCATE (+ (- UNIVERSAL-TIME SECONDS-WEST) SECONDS-OFFSET) SECONDS-IN-WEEK) (LET ((WEEKS (+ WEEKS WEEKS-OFFSET))) (MULTIPLE-VALUE-BIND (T1 SECOND) (TRUNCATE SECS 60) (LET ((TDAY (TRUNCATE T1 MINUTES-PER-DAY))) (MULTIPLE-VALUE-BIND (HOUR MINUTE) (TRUNCATE (- T1 (* TDAY MINUTES-PER-DAY)) 60) (LET* ((T2 (1- (* (+ (* WEEKS 7) TDAY NOVEMBER-17-1858) 4))) (TCENT (TRUNCATE T2 QUARTER-DAYS-PER-CENTURY))) (SETQ T2 (MOD T2 QUARTER-DAYS-PER-CENTURY)) (SETQ T2 (+ (- T2 (MOD T2 4)) 3)) (LET* ((YEAR (+ (* TCENT 100) (TRUNCATE T2 QUARTER-DAYS-PER-YEAR))) (DAYS-SINCE-MAR0 (1+ (TRUNCATE (MOD T2 QUARTER-DAYS-PER-YEAR) 4))) (DAY (MOD (+ TDAY WEEKDAY-NOVEMBER-17-1858) 7)) (T3 (+ (* DAYS-SINCE-MAR0 5) 456))) (COND ((>= T3 1989) (SETQ T3 (- T3 1836)) (SETQ YEAR (1+ YEAR)))) (MULTIPLE-VALUE-BIND (MONTH T3) (TRUNCATE T3 153) (LET ((DATE (1+ (TRUNCATE T3 5)))) (VALUES SECOND MINUTE HOUR DATE MONTH YEAR DAY DAYLIGHT (IF DAYLIGHT (1+ (/ SECONDS-WEST 3600)) (/ SECONDS-WEST 3600))))))))))))))
     [java] ; (DEFUN GET-DECODED-TIME NIL (DECODE-UNIVERSAL-TIME (GET-UNIVERSAL-TIME)))
     [java] ; (DEFUN PICK-OBVIOUS-YEAR (YEAR) (DECLARE (TYPE (MOD 100) YEAR)) (LET* ((CURRENT-YEAR (NTH-VALUE 5 (GET-DECODED-TIME))) (GUESS (+ YEAR (* (TRUNCATE (- CURRENT-YEAR 50) 100) 100)))) (DECLARE (TYPE (INTEGER 1900 9999) CURRENT-YEAR GUESS)) (IF (> (- CURRENT-YEAR GUESS) 50) (+ GUESS 100) GUESS)))
     [java] ; (DEFUN LEAP-YEARS-BEFORE (YEAR) (LET ((YEARS (- YEAR 1901))) (+ (- (TRUNCATE YEARS 4) (TRUNCATE YEARS 100)) (TRUNCATE (+ YEARS 300) 400))))
     [java] ; (DEFVAR *DAYS-BEFORE-MONTH* #(NIL 0 31 59 90 120 151 181 212 243 273 304 334))
     [java] ; (DEFUN ENCODE-UNIVERSAL-TIME (SECOND MINUTE HOUR DATE MONTH YEAR &OPTIONAL TIME-ZONE) (LET* ((YEAR (IF (< YEAR 100) (PICK-OBVIOUS-YEAR YEAR) YEAR)) (DAYS (+ (1- DATE) (AREF *DAYS-BEFORE-MONTH* MONTH) (IF (> MONTH 2) (LEAP-YEARS-BEFORE (1+ YEAR)) (LEAP-YEARS-BEFORE YEAR)) (* (- YEAR 1900) 365))) (HOURS (+ HOUR (* DAYS 24)))) (COND (TIME-ZONE (+ SECOND (* (+ MINUTE (* (+ HOURS TIME-ZONE) 60)) 60))) ((> YEAR 2037) (LABELS ((LEAP-YEAR-P (YEAR) (COND ((ZEROP (MOD YEAR 400)) T) ((ZEROP (MOD YEAR 100)) NIL) ((ZEROP (MOD YEAR 4)) T) (T NIL)))) (LET* ((FAKE-YEAR (IF (LEAP-YEAR-P YEAR) 2036 2037)) (FAKE-TIME (ENCODE-UNIVERSAL-TIME SECOND MINUTE HOUR DATE MONTH FAKE-YEAR))) (+ FAKE-TIME (* 86400 (+ (* 365 (- YEAR FAKE-YEAR)) (- (LEAP-YEARS-BEFORE YEAR) (LEAP-YEARS-BEFORE FAKE-YEAR)))))))) (T (LET* ((TZ-GUESS (GET-TIME-ZONE (* HOURS 3600))) (GUESS (+ SECOND (* 60 (+ MINUTE (* 60 (+ HOURS TZ-GUESS)))))) (TZ (GET-TIME-ZONE GUESS))) (+ GUESS (* 3600 (- TZ TZ-GUESS))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/time.abcl (0.204 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/top-level.lisp ...
     [java] ; (IN-PACKAGE #:TOP-LEVEL)
     [java] ; (DEFVAR *NULL-CMD* (GENSYM))
     [java] ; (DEFVAR *HANDLED-CMD* (GENSYM))
     [java] ; (DEFVAR *COMMAND-CHAR* #\:)
     [java] ; (DEFVAR *CMD-NUMBER* 1 "Number of the next command")
     [java] ; (DEFUN PROMPT-PACKAGE-NAME NIL (LET ((RESULT (PACKAGE-NAME *PACKAGE*))) (DOLIST (NICKNAME (PACKAGE-NICKNAMES *PACKAGE*)) (WHEN (< (LENGTH NICKNAME) (LENGTH RESULT)) (SETF RESULT NICKNAME))) RESULT))
     [java] ; (DEFUN REPL-PROMPT-FUN (STREAM) (FRESH-LINE STREAM) (WHEN (> *DEBUG-LEVEL* 0) (SYSTEM::%FORMAT STREAM "[~D~A] " *DEBUG-LEVEL* (IF SYSTEM::*INSPECT-BREAK* "i" ""))) (SYSTEM::%FORMAT STREAM "~A(~D): " (PROMPT-PACKAGE-NAME) *CMD-NUMBER*))
     [java] ; (DEFPARAMETER *REPL-PROMPT-FUN* (FUNCTION REPL-PROMPT-FUN))
     [java] ; (DEFUN PEEK-CHAR-NON-WHITESPACE (STREAM) (LOOP (LET ((C (READ-CHAR STREAM NIL))) (WHEN (NULL C) (QUIT)) (UNLESS (EQL C #\ ) (UNREAD-CHAR C STREAM) (RETURN C)))))
     [java] ; (DEFUN APROPOS-COMMAND (ARGS) (WHEN ARGS (APROPOS ARGS)))
     [java] ; (DEFUN CONTINUE-COMMAND (ARGS) (WHEN ARGS (LET ((N (READ-FROM-STRING ARGS))) (LET ((RESTARTS (COMPUTE-RESTARTS))) (WHEN (< -1 N (LENGTH RESTARTS)) (INVOKE-RESTART-INTERACTIVELY (NTH N RESTARTS)))))))
     [java] ; (DEFUN DESCRIBE-COMMAND (ARGS) (LET ((OBJ (EVAL (READ-FROM-STRING ARGS)))) (DESCRIBE OBJ)))
     [java] ; (DEFUN ERROR-COMMAND (IGNORED) (DECLARE (IGNORE IGNORED)) (WHEN *DEBUG-CONDITION* (LET* ((S (SYSTEM::%FORMAT NIL "~A" *DEBUG-CONDITION*)) (LEN (LENGTH S))) (WHEN (PLUSP LEN) (SETF (SCHAR S 0) (CHAR-UPCASE (SCHAR S 0))) (UNLESS (EQL (SCHAR S (1- LEN)) #\.) (SETF S (CONCATENATE (QUOTE STRING) S ".")))) (SYSTEM::%FORMAT *DEBUG-IO* "~A~%" S)) (SHOW-RESTARTS (COMPUTE-RESTARTS) *DEBUG-IO*)))
     [java] ; (DEFUN PRINT-FRAME (FRAME STREAM &KEY PREFIX) (WHEN PREFIX (WRITE-STRING PREFIX STREAM)) (ETYPECASE FRAME (SYSTEM::LISP-STACK-FRAME (LET ((FRAME (SYSTEM:FRAME-TO-LIST FRAME))) (PPRINT-LOGICAL-BLOCK (STREAM NIL :PREFIX "(" :SUFFIX ")") (IGNORE-ERRORS (PRIN1 (CAR FRAME) STREAM) (LET ((ARGS (CDR FRAME))) (IF (LISTP ARGS) (FORMAT STREAM "~{ ~_~S~}" ARGS) (FORMAT STREAM " ~S" ARGS))))))) (SYSTEM::JAVA-STACK-FRAME (WRITE-STRING (SYSTEM:FRAME-TO-STRING FRAME) STREAM))))
     [java] ; (DEFUN BACKTRACE-COMMAND (ARGS) (LET ((COUNT (OR (AND ARGS (IGNORE-ERRORS (PARSE-INTEGER ARGS))) 8)) (N 0)) (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-READABLY* NIL) (*PRINT-STRUCTURE* NIL) (*PRINT-ARRAY* NIL)) (DOLIST (FRAME *SAVED-BACKTRACE*) (FRESH-LINE *DEBUG-IO*) (PRINT-FRAME FRAME *DEBUG-IO* :PREFIX (FORMAT NIL "~3D: " N)) (INCF N) (WHEN (>= N COUNT) (FRESH-LINE *DEBUG-IO*) (RETURN)))))) (FRESH-LINE *DEBUG-IO*) (VALUES))
     [java] ; (DEFUN FRAME-COMMAND (ARGS) (LET* ((N (OR (AND ARGS (IGNORE-ERRORS (PARSE-INTEGER ARGS))) 0)) (FRAME (NTH N *SAVED-BACKTRACE*))) (WHEN FRAME (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-READABLY* NIL) (*PRINT-STRUCTURE* NIL)) (FRESH-LINE *DEBUG-IO*) (PRINT-FRAME FRAME *DEBUG-IO*))) (SETF *** ** ** * * FRAME))) (VALUES))
     [java] ; (DEFUN INSPECT-COMMAND (ARGS) (LET ((OBJ (EVAL (READ-FROM-STRING ARGS)))) (INSPECT OBJ)))
     [java] ; (DEFUN ISTEP-COMMAND (ARGS) (SYSTEM::ISTEP ARGS))
     [java] ; (DEFUN MACROEXPAND-COMMAND (ARGS) (LET ((S (WITH-OUTPUT-TO-STRING (STREAM) (PPRINT (MACROEXPAND (READ-FROM-STRING ARGS)) STREAM)))) (WRITE-STRING (STRING-LEFT-TRIM (QUOTE (#\Return #\Newline)) S))) (VALUES))
     [java] ; (DEFVAR *OLD-PACKAGE* NIL)
     [java] ; (DEFUN PACKAGE-COMMAND (ARGS) (COND ((NULL ARGS) (SYSTEM::%FORMAT *STANDARD-OUTPUT* "The ~A package is current.~%" (PACKAGE-NAME *PACKAGE*))) ((AND *OLD-PACKAGE* (STRING= ARGS "-") (NULL (FIND-PACKAGE "-"))) (ROTATEF *OLD-PACKAGE* *PACKAGE*)) (T (WHEN (AND (PLUSP (LENGTH ARGS)) (EQL (CHAR ARGS 0) #\:)) (SETF ARGS (SUBSEQ ARGS 1))) (SETF ARGS (NSTRING-UPCASE ARGS)) (LET ((PKG (FIND-PACKAGE ARGS))) (IF PKG (SETF *OLD-PACKAGE* *PACKAGE* *PACKAGE* PKG) (SYSTEM::%FORMAT *STANDARD-OUTPUT* "Unknown package ~A.~%" ARGS))))))
     [java] ; (DEFUN RESET-COMMAND (IGNORED) (DECLARE (IGNORE IGNORED)) (INVOKE-RESTART (QUOTE TOP-LEVEL)))
     [java] ; (DEFUN EXIT-COMMAND (IGNORED) (DECLARE (IGNORE IGNORED)) (EXIT))
     [java] ; (DEFVAR *OLD-PWD* NIL)
     [java] ; (DEFUN CD-COMMAND (ARGS) (COND ((NULL ARGS) (SETF ARGS (IF (FEATUREP :WINDOWS) "C:\\" (NAMESTRING (USER-HOMEDIR-PATHNAME))))) ((STRING= ARGS "-") (IF *OLD-PWD* (SETF ARGS (NAMESTRING *OLD-PWD*)) (PROGN (SYSTEM::%FORMAT T "No previous directory.") (RETURN-FROM CD-COMMAND)))) ((AND (> (LENGTH ARGS) 1) (STRING= (SUBSEQ ARGS 0 2) "~/") (SETF ARGS (CONCATENATE (QUOTE STRING) (NAMESTRING (USER-HOMEDIR-PATHNAME)) (SUBSEQ ARGS 2)))))) (LET ((DIR (PROBE-DIRECTORY ARGS))) (IF DIR (PROGN (UNLESS (EQUAL DIR *DEFAULT-PATHNAME-DEFAULTS*) (SETF *OLD-PWD* *DEFAULT-PATHNAME-DEFAULTS* *DEFAULT-PATHNAME-DEFAULTS* DIR)) (SYSTEM::%FORMAT T "~A" (NAMESTRING *DEFAULT-PATHNAME-DEFAULTS*))) (SYSTEM::%FORMAT T "Error: no such directory (~S).~%" ARGS))))
     [java] ; (DEFUN LS-COMMAND (ARGS) (LET ((ARGS (IF (STRINGP ARGS) ARGS "")) (LS-PROGRAM (IF (FEATUREP :WINDOWS) "dir" "ls"))) (RUN-SHELL-COMMAND (CONCATENATE (QUOTE STRING) LS-PROGRAM " " ARGS) :DIRECTORY *DEFAULT-PATHNAME-DEFAULTS*)) (VALUES))
     [java] ; (DEFUN TOKENIZE (STRING) (DO* ((RES NIL) (STRING (STRING-LEFT-TRIM " " STRING) (STRING-LEFT-TRIM " " (SUBSEQ STRING END))) (END (POSITION #\  STRING) (POSITION #\  STRING))) ((ZEROP (LENGTH STRING)) (NREVERSE RES)) (UNLESS END (SETF END (LENGTH STRING))) (PUSH (SUBSEQ STRING 0 END) RES)))
     [java] ; (DEFVAR *LAST-FILES-LOADED* NIL)
     [java] ; (DEFUN LD-COMMAND (ARGS) (LET ((FILES (IF ARGS (TOKENIZE ARGS) *LAST-FILES-LOADED*))) (SETF *LAST-FILES-LOADED* FILES) (DOLIST (FILE FILES) (LOAD FILE))))
     [java] ; (DEFUN CF-COMMAND (ARGS) (LET ((FILES (TOKENIZE ARGS))) (DOLIST (FILE FILES) (COMPILE-FILE FILE))))
     [java] ; (DEFVAR *LAST-FILES-CLOADED* NIL)
     [java] ; (DEFUN CLOAD-COMMAND (ARGS) (LET ((FILES (IF ARGS (TOKENIZE ARGS) *LAST-FILES-CLOADED*))) (SETF *LAST-FILES-CLOADED* FILES) (DOLIST (FILE FILES) (LOAD (COMPILE-FILE FILE)))))
     [java] ; (DEFUN RQ-COMMAND (ARGS) (LET ((MODULES (TOKENIZE (STRING-UPCASE ARGS)))) (DOLIST (MODULE MODULES) (REQUIRE MODULE))))
     [java] ; (DEFUN PWD-COMMAND (IGNORED) (DECLARE (IGNORE IGNORED)) (SYSTEM::%FORMAT T "~A~%" (NAMESTRING *DEFAULT-PATHNAME-DEFAULTS*)))
     [java] ; (DEFUN TRACE-COMMAND (ARGS) (IF (NULL ARGS) (SYSTEM::%FORMAT T "~A~%" (SYSTEM::LIST-TRACED-FUNCTIONS)) (DOLIST (F (TOKENIZE ARGS)) (SYSTEM::TRACE-1 (READ-FROM-STRING F)))))
     [java] ; (DEFUN UNTRACE-COMMAND (ARGS) (IF (NULL ARGS) (SYSTEM::UNTRACE-ALL) (DOLIST (F (TOKENIZE ARGS)) (SYSTEM::UNTRACE-1 (READ-FROM-STRING F)))))
     [java] ; (DEFCONSTANT SPACES (MAKE-STRING 32 :INITIAL-ELEMENT #\ ))
     [java] ; (DEFUN PAD (STRING WIDTH) (IF (< (LENGTH STRING) WIDTH) (CONCATENATE (QUOTE STRING) STRING (SUBSEQ SPACES 0 (- WIDTH (LENGTH STRING)))) STRING))
     [java] ; (DEFPARAMETER *COMMAND-TABLE* (QUOTE (("apropos" "ap" APROPOS-COMMAND "apropos") ("bt" NIL BACKTRACE-COMMAND "backtrace n stack frames (default 8)") ("cd" NIL CD-COMMAND "change default directory") ("cf" NIL CF-COMMAND "compile file(s)") ("cload" "cl" CLOAD-COMMAND "compile and load file(s)") ("continue" "cont" CONTINUE-COMMAND "invoke restart n") ("describe" "de" DESCRIBE-COMMAND "describe an object") ("error" "err" ERROR-COMMAND "print the current error message") ("exit" "ex" EXIT-COMMAND "exit lisp") ("frame" "fr" FRAME-COMMAND "set the value of cl:* to be frame n (default 0)") ("help" "he" HELP-COMMAND "print this help") ("inspect" "in" INSPECT-COMMAND "inspect an object") ("istep" "i" ISTEP-COMMAND "navigate within inspection of an object") ("ld" NIL LD-COMMAND "load a file") ("ls" NIL LS-COMMAND "list directory") ("macroexpand" "ma" MACROEXPAND-COMMAND "macroexpand an expression") ("package" "pa" PACKAGE-COMMAND "change *PACKAGE*") ("pwd" "pw" PWD-COMMAND "print current directory") ("reset" "res" RESET-COMMAND "return to top level") ("rq" NIL RQ-COMMAND "require a module") ("trace" "tr" TRACE-COMMAND "trace function(s)") ("untrace" "untr" UNTRACE-COMMAND "untrace function(s)"))))
     [java] ; (DEFUN %HELP-COMMAND (PREFIX) (LET ((PREFIX-LEN (LENGTH PREFIX))) (WHEN (AND (> PREFIX-LEN 0) (EQL (SCHAR PREFIX 0) *COMMAND-CHAR*)) (SETF PREFIX (SUBSEQ PREFIX 1)) (DECF PREFIX-LEN)) (SYSTEM::%FORMAT T "~%  COMMAND     ABBR DESCRIPTION~%") (DOLIST (ENTRY *COMMAND-TABLE*) (WHEN (OR (NULL PREFIX) (AND (<= PREFIX-LEN (LENGTH (ENTRY-NAME ENTRY))) (STRING-EQUAL PREFIX (SUBSEQ (ENTRY-NAME ENTRY) 0 PREFIX-LEN)))) (SYSTEM::%FORMAT T "  ~A~A~A~%" (PAD (ENTRY-NAME ENTRY) 12) (PAD (ENTRY-ABBREVIATION ENTRY) 5) (ENTRY-HELP ENTRY)))) (SYSTEM::%FORMAT T "~%Commands must be prefixed by the command character, which is '~A'~A.~%~%" *COMMAND-CHAR* (IF (EQL *COMMAND-CHAR* #\:) " by default" ""))))
     [java] ; (DEFUN HELP-COMMAND (&OPTIONAL IGNORED) (DECLARE (IGNORE IGNORED)) (%HELP-COMMAND NIL))
     [java] ; (DEFUN ENTRY-NAME (ENTRY) (FIRST ENTRY))
     [java] ; (DEFUN ENTRY-ABBREVIATION (ENTRY) (SECOND ENTRY))
     [java] ; (DEFUN ENTRY-COMMAND (ENTRY) (THIRD ENTRY))
     [java] ; (DEFUN ENTRY-HELP (ENTRY) (FOURTH ENTRY))
     [java] ; (DEFUN FIND-COMMAND (STRING) (LET ((LEN (LENGTH STRING))) (WHEN (AND (> LEN 0) (EQL (SCHAR STRING 0) *COMMAND-CHAR*)) (SETF STRING (SUBSEQ STRING 1) LEN (1- LEN))) (DOLIST (ENTRY *COMMAND-TABLE*) (WHEN (OR (STRING-EQUAL STRING (ENTRY-ABBREVIATION ENTRY)) (STRING-EQUAL STRING (ENTRY-NAME ENTRY))) (RETURN (ENTRY-COMMAND ENTRY))))))
     [java] ; (DEFUN PROCESS-CMD (FORM) (WHEN (EQ FORM *NULL-CMD*) (RETURN-FROM PROCESS-CMD T)) (WHEN (AND (STRINGP FORM) (> (LENGTH FORM) 1) (EQL (CHAR FORM 0) *COMMAND-CHAR*)) (LET* ((POS (OR (POSITION #\  FORM) (POSITION #\Return FORM))) (COMMAND-STRING (SUBSEQ FORM 0 POS)) (ARGS (IF POS (SUBSEQ FORM (1+ POS)) NIL))) (LET ((COMMAND (FIND-COMMAND COMMAND-STRING))) (COND ((NULL COMMAND) (SYSTEM::%FORMAT T "Unknown top-level command \"~A\".~%" COMMAND-STRING) (SYSTEM::%FORMAT T "Type \"~Ahelp\" for a list of available commands." *COMMAND-CHAR*)) (T (WHEN ARGS (SETF ARGS (STRING-TRIM (LIST #\  #\Return) ARGS)) (WHEN (ZEROP (LENGTH ARGS)) (SETF ARGS NIL))) (FUNCALL COMMAND ARGS))))) T))
     [java] ; (DEFUN READ-CMD (STREAM) (LET ((C (PEEK-CHAR-NON-WHITESPACE STREAM))) (COND ((EQL C *COMMAND-CHAR*) (LET* ((INPUT (READ-LINE STREAM)) (NAME (SYMBOL-NAME (READ-FROM-STRING INPUT)))) (IF (FIND-COMMAND NAME) (PROGN (PROCESS-CMD INPUT) *HANDLED-CMD*) (READ-FROM-STRING (CONCATENATE (QUOTE STRING) ":" NAME))))) ((EQL C #\Newline) (READ-LINE STREAM) *NULL-CMD*) (T (READ STREAM NIL *NULL-CMD*)))))
     [java] ; (DEFUN REPL-READ-FORM-FUN (IN OUT) (LOOP (FUNCALL *REPL-PROMPT-FUN* OUT) (FINISH-OUTPUT OUT) (LET ((FORM (READ-CMD IN))) (SETF (CHARPOS OUT) 0) (UNLESS (EQ FORM *NULL-CMD*) (INCF *CMD-NUMBER*)) (COND ((OR (EQ FORM *NULL-CMD*) (EQ FORM *HANDLED-CMD*))) ((AND (> *DEBUG-LEVEL* 0) (FIXNUMP FORM)) (LET ((N FORM) (RESTARTS (COMPUTE-RESTARTS))) (IF (< -1 N (LENGTH RESTARTS)) (INVOKE-RESTART-INTERACTIVELY (NTH N RESTARTS)) (RETURN FORM)))) (T (RETURN FORM))))))
     [java] ; (DEFPARAMETER *REPL-READ-FORM-FUN* (FUNCTION REPL-READ-FORM-FUN))
     [java] ; (DEFUN REPL (&OPTIONAL (IN *STANDARD-INPUT*) (OUT *STANDARD-OUTPUT*)) (LOOP (LET* ((FORM (FUNCALL *REPL-READ-FORM-FUN* IN OUT)) (RESULTS (MULTIPLE-VALUE-LIST (SYSTEM:INTERACTIVE-EVAL FORM)))) (DOLIST (RESULT RESULTS) (FRESH-LINE OUT) (PRIN1 RESULT OUT)))))
     [java] ; (DEFUN TOP-LEVEL-LOOP NIL (FRESH-LINE) (UNLESS SYSTEM:*NOINFORM* (SYSTEM::%FORMAT T "Type \"~Ahelp\" for a list of available commands.~%" *COMMAND-CHAR*)) (LOOP (SETF *INSPECTED-OBJECT* NIL *INSPECTED-OBJECT-STACK* NIL *INSPECT-BREAK* NIL) (WITH-SIMPLE-RESTART (TOP-LEVEL "Return to top level.") (IF (FEATUREP :J) (HANDLER-CASE (REPL) (STREAM-ERROR (C) (DECLARE (IGNORE C)) (RETURN-FROM TOP-LEVEL-LOOP))) (REPL)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/top-level.abcl (1.142 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/trace.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFVAR *TRACE-INFO-HASHTABLE* (MAKE-HASH-TABLE :TEST (FUNCTION EQUAL)))
     [java] ; (DEFSTRUCT TRACE-INFO NAME UNTRACED-FUNCTION BREAKP)
     [java] ; (DEFVAR *TRACE-DEPTH* 0 "Current depth of stack push for use of TRACE facility.")
     [java] ; (DEFUN LIST-TRACED-FUNCTIONS NIL (COPY-LIST *TRACED-NAMES*))
     [java] ; (DEFMACRO TRACE (&REST ARGS) (IF ARGS (EXPAND-TRACE ARGS) (QUOTE (LIST-TRACED-FUNCTIONS))))
     [java] ; (DEFUN EXPAND-TRACE (ARGS) (LET ((RESULTS NIL) (BREAKP NIL)) (LET ((INDEX (POSITION :BREAK ARGS))) (WHEN INDEX (SETF BREAKP (NTH (1+ INDEX) ARGS)) (SETF ARGS (APPEND (SUBSEQ ARGS 0 INDEX) (SUBSEQ ARGS (+ INDEX 2)))))) (DOLIST (ARG ARGS) (PUSH (BACKQ-LIST (QUOTE TRACE-1) (BACKQ-LIST (QUOTE QUOTE) ARG) (BACKQ-LIST (QUOTE MAKE-TRACE-INFO) (QUOTE :NAME) (BACKQ-LIST (QUOTE QUOTE) ARG) (QUOTE :BREAKP) BREAKP)) RESULTS)) (BACKQ-CONS (QUOTE LIST) (NREVERSE RESULTS))))
     [java] ; (DEFUN TRACE-1 (NAME INFO) (UNLESS (FBOUNDP NAME) (ERROR "~S is not the name of a function." NAME)) (IF (MEMBER NAME *TRACED-NAMES* :TEST (FUNCTION EQUAL)) (FORMAT T "~S is already being traced." NAME) (LET* ((UNTRACED-FUNCTION (FDEFINITION NAME)) (TRACED-FUNCTION (TRACED-FUNCTION NAME INFO UNTRACED-FUNCTION))) (SETF (TRACE-INFO-UNTRACED-FUNCTION INFO) UNTRACED-FUNCTION) (LET ((*WARN-ON-REDEFINITION* NIL)) (SETF (FDEFINITION NAME) TRACED-FUNCTION)) (SETF (GETHASH NAME *TRACE-INFO-HASHTABLE*) INFO) (PUSH NAME *TRACED-NAMES*))) NAME)
     [java] ; (DEFUN TRACED-FUNCTION (NAME INFO UNTRACED-FUNCTION) (LET ((BREAKP (TRACE-INFO-BREAKP INFO)) (*TRACE-DEPTH* *TRACE-DEPTH*)) (LAMBDA (&REST ARGS) (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-READABLY* NIL) (*PRINT-STRUCTURE* NIL)) (FORMAT *TRACE-OUTPUT* (INDENT "~D: ~S~%") *TRACE-DEPTH* (CONS NAME ARGS)))) (WHEN BREAKP (BREAK)) (INCF *TRACE-DEPTH*) (LET ((RESULTS (MULTIPLE-VALUE-LIST (UNWIND-PROTECT (APPLY UNTRACED-FUNCTION ARGS) (DECF *TRACE-DEPTH*))))) (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-READABLY* NIL) (*PRINT-STRUCTURE* NIL)) (FORMAT *TRACE-OUTPUT* (INDENT "~D: ~A returned") *TRACE-DEPTH* NAME) (IF RESULTS (DOLIST (RESULT RESULTS) (FORMAT *TRACE-OUTPUT* " ~S" RESULT)) (FORMAT *TRACE-OUTPUT* " no values")) (TERPRI *TRACE-OUTPUT*))) (VALUES-LIST RESULTS)))))
     [java] ; (DEFUN UNTRACED-FUNCTION (NAME) (LET ((INFO (GETHASH NAME *TRACE-INFO-HASHTABLE*))) (AND INFO (TRACE-INFO-UNTRACED-FUNCTION INFO))))
     [java] ; (DEFUN TRACE-REDEFINED-UPDATE (NAME UNTRACED-FUNCTION) (WHEN (AND *TRACED-NAMES* (FIND NAME *TRACED-NAMES* :TEST (FUNCTION EQUAL))) (LET* ((INFO (GETHASH NAME *TRACE-INFO-HASHTABLE*)) (TRACED-FUNCTION (TRACED-FUNCTION NAME INFO UNTRACED-FUNCTION))) (SETF (TRACE-INFO-UNTRACED-FUNCTION INFO) UNTRACED-FUNCTION) (LET ((*TRACED-NAMES* (QUOTE NIL))) (SETF (FDEFINITION NAME) TRACED-FUNCTION)))))
     [java] ; (DEFUN INDENT (STRING) (CONCATENATE (QUOTE STRING) (MAKE-STRING (* (1+ *TRACE-DEPTH*) 2) :INITIAL-ELEMENT #\ ) STRING))
     [java] ; (DEFMACRO UNTRACE (&REST ARGS) (COND ((NULL ARGS) (QUOTE (UNTRACE-ALL))) (T (BACKQ-CONS (QUOTE PROGN) (BACKQ-APPEND (MAPCAR (LAMBDA (ARG) (BACKQ-LIST (QUOTE UNTRACE-1) (BACKQ-LIST (QUOTE QUOTE) ARG))) ARGS) (QUOTE (T)))))))
     [java] ; (DEFUN UNTRACE-ALL NIL (DOLIST (ARG *TRACED-NAMES*) (UNTRACE-1 ARG)) T)
     [java] ; (DEFUN UNTRACE-1 (NAME) (COND ((MEMBER NAME *TRACED-NAMES* :TEST (FUNCTION EQUAL)) (LET* ((TRACE-INFO (GETHASH NAME *TRACE-INFO-HASHTABLE*)) (UNTRACED-FUNCTION (TRACE-INFO-UNTRACED-FUNCTION TRACE-INFO)) (*WARN-ON-REDEFINITION* NIL)) (REMHASH NAME *TRACE-INFO-HASHTABLE*) (SETF *TRACED-NAMES* (REMOVE NAME *TRACED-NAMES*)) (SETF (FDEFINITION NAME) UNTRACED-FUNCTION))) (T (FORMAT T "~S is not being traced.~%" NAME))) NIL)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/trace.abcl (0.77 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/tree-equal.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN TREE-EQUAL-TEST-NOT (X Y TEST-NOT) (COND ((CONSP X) (AND (CONSP Y) (TREE-EQUAL-TEST-NOT (CAR X) (CAR Y) TEST-NOT) (TREE-EQUAL-TEST-NOT (CDR X) (CDR Y) TEST-NOT))) ((CONSP Y) NIL) ((NOT (FUNCALL TEST-NOT X Y)) T) (T NIL)))
     [java] ; (DEFUN TREE-EQUAL-TEST (X Y TEST) (COND ((CONSP X) (AND (CONSP Y) (TREE-EQUAL-TEST (CAR X) (CAR Y) TEST) (TREE-EQUAL-TEST (CDR X) (CDR Y) TEST))) ((CONSP Y) NIL) ((FUNCALL TEST X Y) T) (T NIL)))
     [java] ; (DEFUN TREE-EQUAL (X Y &KEY (TEST (FUNCTION EQL) TESTP) (TEST-NOT NIL NOTP)) (WHEN (AND TESTP NOTP) (ERROR "test and test-not both supplied")) (IF TEST-NOT (TREE-EQUAL-TEST-NOT X Y TEST-NOT) (TREE-EQUAL-TEST X Y TEST)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/tree-equal.abcl (0.085 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/upgraded-complex-part-type.lisp ...
     [java] ; (DEFUN UPGRADED-COMPLEX-PART-TYPE (TYPESPEC &OPTIONAL ENVIRONMENT) (DECLARE (IGNORE ENVIRONMENT)) (IF (SUBTYPEP TYPESPEC (QUOTE REAL)) TYPESPEC (ERROR (QUOTE SIMPLE-ERROR) :FORMAT-CONTROL "The type ~S is not a subtype of ~S." :FORMAT-ARGUMENTS (LIST TYPESPEC (QUOTE REAL)))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/upgraded-complex-part-type.abcl (0.055 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-accessors.lisp ...
     [java] ; (DEFMACRO WITH-ACCESSORS (SLOTS INSTANCE &BODY BODY) (LET ((IN (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST IN INSTANCE)) (SYSTEM::BACKQ-LIST* (QUOTE SYMBOL-MACROLET) (MAPCAR (LAMBDA (SLOT-ENTRY) (LET ((VARIABLE-NAME (CAR SLOT-ENTRY)) (ACCESSOR-NAME (CADR SLOT-ENTRY))) (SYSTEM::BACKQ-LIST VARIABLE-NAME (SYSTEM::BACKQ-LIST ACCESSOR-NAME IN)))) SLOTS) BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-accessors.abcl (0.067 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-hash-table-iterator.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN HASH-TABLE-ITERATOR-FUNCTION (HASH-TABLE) (LET ((ENTRIES (HASH-TABLE-ENTRIES HASH-TABLE))) (FUNCTION (LAMBDA NIL (LET ((ENTRY (CAR ENTRIES))) (SETQ ENTRIES (CDR ENTRIES)) (IF ENTRY (VALUES T (CAR ENTRY) (CDR ENTRY)) NIL))))))
     [java] ; (DEFMACRO WITH-HASH-TABLE-ITERATOR ((NAME HASH-TABLE) &BODY BODY) (LET ((ITER (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST ITER (BACKQ-LIST (QUOTE HASH-TABLE-ITERATOR-FUNCTION) HASH-TABLE))) (BACKQ-LIST* (QUOTE MACROLET) (BACKQ-LIST (BACKQ-LIST NAME NIL (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE FUNCALL) ITER)))) BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-hash-table-iterator.abcl (0.072 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-input-from-string.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO WITH-INPUT-FROM-STRING ((VAR STRING &KEY INDEX START END) &BODY BODY) (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR (COND ((NULL END) (BACKQ-LIST (QUOTE MAKE-STRING-INPUT-STREAM) STRING (OR START 0))) ((SYMBOLP END) (BACKQ-LIST (QUOTE IF) END (BACKQ-LIST (QUOTE MAKE-STRING-INPUT-STREAM) STRING (OR START 0) END) (BACKQ-LIST (QUOTE MAKE-STRING-INPUT-STREAM) STRING (OR START 0)))) (T (BACKQ-LIST (QUOTE MAKE-STRING-INPUT-STREAM) STRING (OR START 0) END))))) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-LIST* (QUOTE MULTIPLE-VALUE-PROG1) (BACKQ-CONS (QUOTE PROGN) FORMS) (WHEN INDEX (BACKQ-LIST (BACKQ-LIST (QUOTE SETF) INDEX (BACKQ-LIST (QUOTE STRING-INPUT-STREAM-CURRENT) VAR))))) (BACKQ-LIST (QUOTE CLOSE) VAR)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-input-from-string.abcl (0.157 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-open-file.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFMACRO WITH-OPEN-FILE (&REST ARGS) (LET ((VAR (CAAR ARGS)) (OPEN-ARGS (CDAR ARGS)) (BODY (CDR ARGS)) (ABORTP (GENSYM))) (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR (BACKQ-CONS (QUOTE OPEN) OPEN-ARGS)) (BACKQ-CONS ABORTP (QUOTE (T)))) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-LIST (QUOTE MULTIPLE-VALUE-PROG1) (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-LIST* (QUOTE SETQ) ABORTP (QUOTE (NIL)))) (BACKQ-LIST (QUOTE WHEN) VAR (BACKQ-LIST (QUOTE CLOSE) VAR (QUOTE :ABORT) ABORTP)))))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-open-file.abcl (0.078 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-output-to-string.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFMACRO WITH-OUTPUT-TO-STRING ((VAR &OPTIONAL STRING &KEY (ELEMENT-TYPE (QUOTE (QUOTE CHARACTER)))) &BODY BODY) "If STRING is specified, it must be a string with a fill pointer;
     [java]    the output is incrementally appended to the string (as if by use of
     [java]    VECTOR-PUSH-EXTEND)." (MULTIPLE-VALUE-BIND (FORMS DECLS) (PARSE-BODY BODY) (IF STRING (LET ((IGNORED (GENSYM))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR (BACKQ-LIST (QUOTE MAKE-FILL-POINTER-OUTPUT-STREAM) STRING)) (BACKQ-LIST IGNORED ELEMENT-TYPE)) (BACKQ-LIST (QUOTE DECLARE) (BACKQ-LIST (QUOTE IGNORE) IGNORED)) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-LIST (QUOTE CLOSE) VAR)))))) (BACKQ-LIST* (QUOTE LET) (BACKQ-LIST (BACKQ-LIST VAR (BACKQ-LIST (QUOTE MAKE-STRING-OUTPUT-STREAM) (QUOTE :ELEMENT-TYPE) ELEMENT-TYPE))) (BACKQ-APPEND DECLS (BACKQ-LIST (BACKQ-LIST (QUOTE UNWIND-PROTECT) (BACKQ-CONS (QUOTE PROGN) FORMS) (BACKQ-LIST (QUOTE CLOSE) VAR)) (BACKQ-LIST (QUOTE GET-OUTPUT-STREAM-STRING) VAR)))))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-output-to-string.abcl (0.083 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-package-iterator.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN PACKAGE-ITERATOR-FUNCTION (PACKAGE-LIST SYMBOL-TYPES) (UNLESS (CONSP PACKAGE-LIST) (SETQ PACKAGE-LIST (LIST PACKAGE-LIST))) (LET ((RESULTS NIL)) (DOLIST (PKG PACKAGE-LIST) (UNLESS (PACKAGEP PKG) (SETQ PKG (FIND-PACKAGE PKG)) (UNLESS PKG (ERROR (QUOTE PACKAGE-ERROR) "not a package"))) (WHEN (MEMQ :INTERNAL SYMBOL-TYPES) (DOLIST (SYM (PACKAGE-INTERNAL-SYMBOLS PKG)) (PUSH (LIST SYM :INTERNAL PKG) RESULTS))) (WHEN (MEMQ :EXTERNAL SYMBOL-TYPES) (DOLIST (SYM (PACKAGE-EXTERNAL-SYMBOLS PKG)) (PUSH (LIST SYM :EXTERNAL PKG) RESULTS))) (WHEN (MEMQ :INHERITED SYMBOL-TYPES) (DOLIST (SYM (PACKAGE-INHERITED-SYMBOLS PKG)) (PUSH (LIST SYM :INHERITED PKG) RESULTS)))) (FUNCTION (LAMBDA NIL (LET ((ITEM (CAR RESULTS))) (SETQ RESULTS (CDR RESULTS)) (IF ITEM (VALUES T (FIRST ITEM) (SECOND ITEM) (THIRD ITEM)) NIL))))))
     [java] ; (DEFMACRO WITH-PACKAGE-ITERATOR ((NAME PACKAGE-LIST &REST SYMBOL-TYPES) &BODY BODY) (UNLESS SYMBOL-TYPES (ERROR (QUOTE PROGRAM-ERROR) "WITH-PACKAGE-ITERATOR: no symbol types specified")) (DOLIST (SYMBOL-TYPE SYMBOL-TYPES) (UNLESS (MEMQ SYMBOL-TYPE (QUOTE (:INTERNAL :EXTERNAL :INHERITED))) (ERROR (QUOTE PROGRAM-ERROR) "WITH-PACKAGE-ITERATOR: invalid symbol type: %S" SYMBOL-TYPE))) (LET ((ITER (GENSYM))) (BACKQ-LIST (QUOTE LET) (BACKQ-LIST (BACKQ-LIST ITER (BACKQ-LIST (QUOTE PACKAGE-ITERATOR-FUNCTION) PACKAGE-LIST (BACKQ-LIST (QUOTE QUOTE) (REMOVE-DUPLICATES SYMBOL-TYPES))))) (BACKQ-LIST* (QUOTE MACROLET) (BACKQ-LIST (BACKQ-LIST NAME NIL (BACKQ-LIST (QUOTE QUOTE) (BACKQ-LIST (QUOTE FUNCALL) ITER)))) BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-package-iterator.abcl (0.136 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-slots.lisp ...
     [java] ; (DEFMACRO WITH-SLOTS (SLOTS INSTANCE &BODY BODY) (LET ((IN (GENSYM))) (SYSTEM::BACKQ-LIST (QUOTE LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST IN INSTANCE)) (SYSTEM::BACKQ-LIST* (QUOTE SYMBOL-MACROLET) (MAPCAR (LAMBDA (SLOT-ENTRY) (LET ((VAR-NAME (IF (SYMBOLP SLOT-ENTRY) SLOT-ENTRY (CAR SLOT-ENTRY))) (SLOT-NAME (IF (SYMBOLP SLOT-ENTRY) SLOT-ENTRY (CADR SLOT-ENTRY)))) (SYSTEM::BACKQ-LIST VAR-NAME (SYSTEM::BACKQ-LIST (QUOTE SLOT-VALUE) IN (SYSTEM::BACKQ-LIST (QUOTE QUOTE) SLOT-NAME))))) SLOTS) BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-slots.abcl (0.059 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/with-standard-io-syntax.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (DEFUN %WITH-STANDARD-IO-SYNTAX (FUNCTION) (LET ((*PACKAGE* (FIND-PACKAGE "CL-USER")) (*PRINT-ARRAY* T) (*PRINT-BASE* 10) (*PRINT-CASE* :UPCASE) (*PRINT-CIRCLE* NIL) (*PRINT-ESCAPE* T) (*PRINT-GENSYM* T) (*PRINT-LENGTH* NIL) (*PRINT-LEVEL* NIL) (*PRINT-LINES* NIL) (*PRINT-MISER-WIDTH* NIL) (*PRINT-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL)) (*PRINT-PRETTY* NIL) (*PRINT-RADIX* NIL) (*PRINT-READABLY* T) (*PRINT-RIGHT-MARGIN* NIL) (*READ-BASE* 10) (*READ-DEFAULT-FLOAT-FORMAT* (QUOTE SINGLE-FLOAT)) (*READ-EVAL* T) (*READ-SUPPRESS* NIL) (*READTABLE* (COPY-READTABLE NIL))) (FUNCALL FUNCTION)))
     [java] ; (DEFMACRO WITH-STANDARD-IO-SYNTAX (&BODY BODY) (BACKQ-LIST (QUOTE %WITH-STANDARD-IO-SYNTAX) (BACKQ-LIST (QUOTE FUNCTION) (BACKQ-LIST* (QUOTE LAMBDA) NIL BODY))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/with-standard-io-syntax.abcl (0.062 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/write-sequence.lisp ...
     [java] ; (IN-PACKAGE #:SYSTEM)
     [java] ; (DEFUN WRITE-SEQUENCE (SEQUENCE STREAM &KEY (START 0) END) (DECLARE (TYPE STREAM STREAM)) (DECLARE (TYPE INDEX START)) (UNLESS (>= START 0) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM START :EXPECTED-TYPE (QUOTE (INTEGER 0)))) (IF END (UNLESS (AND (INTEGERP END) (>= END 0)) (ERROR (QUOTE SIMPLE-TYPE-ERROR) :DATUM END :EXPECTED-TYPE (QUOTE (INTEGER 0)))) (SETF END (LENGTH SEQUENCE))) (LET ((END (THE FIXNUM END)) (STREAM-ELEMENT-TYPE (EXPAND-DEFTYPE (STREAM-ELEMENT-TYPE STREAM)))) (COND ((EQ STREAM-ELEMENT-TYPE (QUOTE CHARACTER)) (IF (STRINGP SEQUENCE) (%WRITE-STRING SEQUENCE STREAM START END) (DO* ((I START (1+ I))) ((>= I END) SEQUENCE) (DECLARE (TYPE INDEX I)) (WRITE-CHAR (ELT SEQUENCE I) STREAM)))) ((EQUAL STREAM-ELEMENT-TYPE (QUOTE (UNSIGNED-BYTE 8))) (IF (AND (VECTORP SEQUENCE) (EQUAL (ARRAY-ELEMENT-TYPE SEQUENCE) (QUOTE (UNSIGNED-BYTE 8)))) (WRITE-VECTOR-UNSIGNED-BYTE-8 SEQUENCE STREAM START END) (DO* ((I START (1+ I))) ((>= I END) SEQUENCE) (DECLARE (TYPE INDEX I)) (WRITE-8-BITS (ELT SEQUENCE I) STREAM)))) (T (DO* ((I START (1+ I))) ((>= I END) SEQUENCE) (DECLARE (TYPE INDEX I)) (WRITE-BYTE (ELT SEQUENCE I) STREAM))))) SEQUENCE)
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/write-sequence.abcl (0.064 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/asdf.lisp ...
     [java] ; (DEFPACKAGE :UIOP/PACKAGE (:USE :COMMON-LISP) (:EXPORT #:FIND-PACKAGE* #:FIND-SYMBOL* #:SYMBOL-CALL #:INTERN* #:EXPORT* #:IMPORT* #:SHADOWING-IMPORT* #:SHADOW* #:MAKE-SYMBOL* #:UNINTERN* #:SYMBOL-SHADOWING-P #:HOME-PACKAGE-P #:SYMBOL-PACKAGE-NAME #:STANDARD-COMMON-LISP-SYMBOL-P #:REIFY-PACKAGE #:UNREIFY-PACKAGE #:REIFY-SYMBOL #:UNREIFY-SYMBOL #:NUKE-SYMBOL-IN-PACKAGE #:NUKE-SYMBOL #:REHOME-SYMBOL #:ENSURE-PACKAGE-UNUSED #:DELETE-PACKAGE* #:PACKAGE-NAMES #:PACKAGES-FROM-NAMES #:FRESH-PACKAGE-NAME #:RENAME-PACKAGE-AWAY #:PACKAGE-DEFINITION-FORM #:PARSE-DEFINE-PACKAGE-FORM #:ENSURE-PACKAGE #:DEFINE-PACKAGE))
     [java] ; (IN-PACKAGE :UIOP/PACKAGE)
     [java] ; (DEFUN FIND-PACKAGE* (PACKAGE-DESIGNATOR &OPTIONAL (ERROR T)) (LET ((PACKAGE (FIND-PACKAGE PACKAGE-DESIGNATOR))) (COND (PACKAGE PACKAGE) (ERROR (ERROR "No package named ~S" (STRING PACKAGE-DESIGNATOR))) (T NIL))))
     [java] ; (DEFUN FIND-SYMBOL* (NAME PACKAGE-DESIGNATOR &OPTIONAL (ERROR T)) "Find a symbol in a package of given string'ified NAME;
     [java] unlike CL:FIND-SYMBOL, work well with 'modern' case sensitive syntax
     [java] by letting you supply a symbol or keyword for the name;
     [java] also works well when the package is not present.
     [java] If optional ERROR argument is NIL, return NIL instead of an error
     [java] when the symbol is not found." (BLOCK NIL (LET ((PACKAGE (FIND-PACKAGE* PACKAGE-DESIGNATOR ERROR))) (WHEN PACKAGE (MULTIPLE-VALUE-BIND (SYMBOL STATUS) (FIND-SYMBOL (STRING NAME) PACKAGE) (COND (STATUS (RETURN (VALUES SYMBOL STATUS))) (ERROR (ERROR "There is no symbol ~S in package ~S" NAME (PACKAGE-NAME PACKAGE)))))) (VALUES NIL NIL))))
     [java] ; (DEFUN SYMBOL-CALL (PACKAGE NAME &REST ARGS) "Call a function associated with symbol of given name in given package,
     [java] with given ARGS. Useful when the call is read before the package is loaded,
     [java] or when loading the package is optional." (APPLY (FIND-SYMBOL* NAME PACKAGE) ARGS))
     [java] ; (DEFUN INTERN* (NAME PACKAGE-DESIGNATOR &OPTIONAL (ERROR T)) (INTERN (STRING NAME) (FIND-PACKAGE* PACKAGE-DESIGNATOR ERROR)))
     [java] ; (DEFUN EXPORT* (NAME PACKAGE-DESIGNATOR) (LET* ((PACKAGE (FIND-PACKAGE* PACKAGE-DESIGNATOR)) (SYMBOL (INTERN* NAME PACKAGE))) (EXPORT (OR SYMBOL (LIST SYMBOL)) PACKAGE)))
     [java] ; (DEFUN IMPORT* (SYMBOL PACKAGE-DESIGNATOR) (IMPORT (OR SYMBOL (LIST SYMBOL)) (FIND-PACKAGE* PACKAGE-DESIGNATOR)))
     [java] ; (DEFUN SHADOWING-IMPORT* (SYMBOL PACKAGE-DESIGNATOR) (SHADOWING-IMPORT (OR SYMBOL (LIST SYMBOL)) (FIND-PACKAGE* PACKAGE-DESIGNATOR)))
     [java] ; (DEFUN SHADOW* (NAME PACKAGE-DESIGNATOR) (SHADOW (LIST (STRING NAME)) (FIND-PACKAGE* PACKAGE-DESIGNATOR)))
     [java] ; (DEFUN MAKE-SYMBOL* (NAME) (ETYPECASE NAME (STRING (MAKE-SYMBOL NAME)) (SYMBOL (COPY-SYMBOL NAME))))
     [java] ; (DEFUN UNINTERN* (NAME PACKAGE-DESIGNATOR &OPTIONAL (ERROR T)) (BLOCK NIL (LET ((PACKAGE (FIND-PACKAGE* PACKAGE-DESIGNATOR ERROR))) (WHEN PACKAGE (MULTIPLE-VALUE-BIND (SYMBOL STATUS) (FIND-SYMBOL* NAME PACKAGE ERROR) (COND (STATUS (UNINTERN SYMBOL PACKAGE) (RETURN (VALUES SYMBOL STATUS))) (ERROR (ERROR "symbol ~A not present in package ~A" (STRING SYMBOL) (PACKAGE-NAME PACKAGE)))))) (VALUES NIL NIL))))
     [java] ; (DEFUN SYMBOL-SHADOWING-P (SYMBOL PACKAGE) (AND (MEMBER SYMBOL (PACKAGE-SHADOWING-SYMBOLS PACKAGE)) T))
     [java] ; (DEFUN HOME-PACKAGE-P (SYMBOL PACKAGE) (AND PACKAGE (LET ((SP (SYMBOL-PACKAGE SYMBOL))) (AND SP (LET ((PP (FIND-PACKAGE* PACKAGE))) (AND PP (EQ SP PP)))))))
     [java] ; (DEFUN SYMBOL-PACKAGE-NAME (SYMBOL) (LET ((PACKAGE (SYMBOL-PACKAGE SYMBOL))) (AND PACKAGE (PACKAGE-NAME PACKAGE))))
     [java] ; (DEFUN STANDARD-COMMON-LISP-SYMBOL-P (SYMBOL) (MULTIPLE-VALUE-BIND (SYM STATUS) (FIND-SYMBOL* SYMBOL :COMMON-LISP NIL) (AND (EQ SYM SYMBOL) (EQ STATUS :EXTERNAL))))
     [java] ; (DEFUN REIFY-PACKAGE (PACKAGE &OPTIONAL PACKAGE-CONTEXT) (IF (EQ PACKAGE PACKAGE-CONTEXT) T (ETYPECASE PACKAGE (NULL NIL) ((EQL (FIND-PACKAGE :CL)) :CL) (PACKAGE (PACKAGE-NAME PACKAGE)))))
     [java] ; (DEFUN UNREIFY-PACKAGE (PACKAGE &OPTIONAL PACKAGE-CONTEXT) (ETYPECASE PACKAGE (NULL NIL) ((EQL T) PACKAGE-CONTEXT) ((OR SYMBOL STRING) (FIND-PACKAGE PACKAGE))))
     [java] ; (DEFUN REIFY-SYMBOL (SYMBOL &OPTIONAL PACKAGE-CONTEXT) (ETYPECASE SYMBOL ((OR KEYWORD (SATISFIES STANDARD-COMMON-LISP-SYMBOL-P)) SYMBOL) (SYMBOL (VECTOR (SYMBOL-NAME SYMBOL) (REIFY-PACKAGE (SYMBOL-PACKAGE SYMBOL) PACKAGE-CONTEXT)))))
     [java] ; (DEFUN UNREIFY-SYMBOL (SYMBOL &OPTIONAL PACKAGE-CONTEXT) (ETYPECASE SYMBOL (SYMBOL SYMBOL) ((SIMPLE-VECTOR 2) (LET* ((SYMBOL-NAME (SVREF SYMBOL 0)) (PACKAGE-FOO (SVREF SYMBOL 1)) (PACKAGE (UNREIFY-PACKAGE PACKAGE-FOO PACKAGE-CONTEXT))) (IF PACKAGE (INTERN* SYMBOL-NAME PACKAGE) (MAKE-SYMBOL* SYMBOL-NAME))))))
     [java] ; (DEFVAR *ALL-PACKAGE-HAPPINESS* (QUOTE NIL))
     [java] ; (DEFVAR *ALL-PACKAGE-FISHINESS* (LIST T))
     [java] ; (DEFUN RECORD-FISHY (INFO) (PUSH INFO *ALL-PACKAGE-FISHINESS*))
     [java] ; (DEFMACRO WHEN-PACKAGE-FISHINESS (&BODY BODY) (SYSTEM::BACKQ-LIST* (QUOTE WHEN) (QUOTE *ALL-PACKAGE-FISHINESS*) BODY))
     [java] ; (DEFMACRO NOTE-PACKAGE-FISHINESS (&REST INFO) (SYSTEM::BACKQ-LIST (QUOTE WHEN-PACKAGE-FISHINESS) (SYSTEM::BACKQ-LIST (QUOTE RECORD-FISHY) (SYSTEM::BACKQ-CONS (QUOTE LIST) INFO))))
     [java] ; (DEFUN SET-DUMMY-SYMBOL (SYMBOL REASON OTHER-SYMBOL) (SETF (GET SYMBOL (QUOTE DUMMY-SYMBOL)) (CONS REASON OTHER-SYMBOL)))
     [java] ; (DEFUN MAKE-DUMMY-SYMBOL (SYMBOL) (LET ((DUMMY (COPY-SYMBOL SYMBOL))) (SET-DUMMY-SYMBOL DUMMY (QUOTE REPLACING) SYMBOL) (SET-DUMMY-SYMBOL SYMBOL (QUOTE REPLACED-BY) DUMMY) DUMMY))
     [java] ; (DEFUN DUMMY-SYMBOL (SYMBOL) (GET SYMBOL (QUOTE DUMMY-SYMBOL)))
     [java] ; (DEFUN GET-DUMMY-SYMBOL (SYMBOL) (LET ((EXISTING (DUMMY-SYMBOL SYMBOL))) (IF EXISTING (VALUES (CDR EXISTING) (CAR EXISTING)) (MAKE-DUMMY-SYMBOL SYMBOL))))
     [java] ; (DEFUN NUKE-SYMBOL-IN-PACKAGE (SYMBOL PACKAGE-DESIGNATOR) (LET ((PACKAGE (FIND-PACKAGE* PACKAGE-DESIGNATOR)) (NAME (SYMBOL-NAME SYMBOL))) (MULTIPLE-VALUE-BIND (SYM STAT) (FIND-SYMBOL NAME PACKAGE) (WHEN (AND (MEMBER STAT (QUOTE (:INTERNAL :EXTERNAL))) (EQ SYMBOL SYM)) (IF (SYMBOL-SHADOWING-P SYMBOL PACKAGE) (SHADOWING-IMPORT* (GET-DUMMY-SYMBOL SYMBOL) PACKAGE) (UNINTERN* SYMBOL PACKAGE))))))
     [java] ; (DEFUN NUKE-SYMBOL (SYMBOL &OPTIONAL (PACKAGES (LIST-ALL-PACKAGES))) (LOOP :FOR P :IN PACKAGES :DO (NUKE-SYMBOL-IN-PACKAGE SYMBOL P)))
     [java] ; (DEFUN REHOME-SYMBOL (SYMBOL PACKAGE-DESIGNATOR) "Changes the home package of a symbol, also leaving it present in its old home if any" (LET* ((NAME (SYMBOL-NAME SYMBOL)) (PACKAGE (FIND-PACKAGE* PACKAGE-DESIGNATOR)) (OLD-PACKAGE (SYMBOL-PACKAGE SYMBOL)) (OLD-STATUS (AND OLD-PACKAGE (NTH-VALUE 1 (FIND-SYMBOL NAME OLD-PACKAGE)))) (SHADOWING (AND OLD-PACKAGE (SYMBOL-SHADOWING-P SYMBOL OLD-PACKAGE) (MAKE-SYMBOL NAME)))) (MULTIPLE-VALUE-BIND (OVERWRITTEN-SYMBOL OVERWRITTEN-SYMBOL-STATUS) (FIND-SYMBOL NAME PACKAGE) (UNLESS (EQ PACKAGE OLD-PACKAGE) (LET ((OVERWRITTEN-SYMBOL-SHADOWING-P (AND OVERWRITTEN-SYMBOL-STATUS (SYMBOL-SHADOWING-P OVERWRITTEN-SYMBOL PACKAGE)))) (NOTE-PACKAGE-FISHINESS :REHOME-SYMBOL NAME (WHEN OLD-PACKAGE (PACKAGE-NAME OLD-PACKAGE)) OLD-STATUS (AND SHADOWING T) (PACKAGE-NAME PACKAGE) OVERWRITTEN-SYMBOL-STATUS OVERWRITTEN-SYMBOL-SHADOWING-P) (WHEN OLD-PACKAGE (IF SHADOWING (SHADOWING-IMPORT* SHADOWING OLD-PACKAGE)) (UNINTERN* SYMBOL OLD-PACKAGE)) (COND (OVERWRITTEN-SYMBOL-SHADOWING-P (SHADOWING-IMPORT* SYMBOL PACKAGE)) (T (WHEN OVERWRITTEN-SYMBOL-STATUS (UNINTERN* OVERWRITTEN-SYMBOL PACKAGE)) (IMPORT* SYMBOL PACKAGE))) (IF SHADOWING (SHADOWING-IMPORT* SYMBOL OLD-PACKAGE) (IMPORT* SYMBOL OLD-PACKAGE)) (WHEN (EQ OLD-STATUS :EXTERNAL) (EXPORT* SYMBOL OLD-PACKAGE)) (WHEN (EQ OVERWRITTEN-SYMBOL-STATUS :EXTERNAL) (EXPORT* SYMBOL PACKAGE)))) (VALUES OVERWRITTEN-SYMBOL OVERWRITTEN-SYMBOL-STATUS))))
     [java] ; (DEFUN ENSURE-PACKAGE-UNUSED (PACKAGE) (LOOP :FOR P :IN (PACKAGE-USED-BY-LIST PACKAGE) :DO (UNUSE-PACKAGE PACKAGE P)))
     [java] ; (DEFUN DELETE-PACKAGE* (PACKAGE &KEY NUKE) (LET ((P (FIND-PACKAGE PACKAGE))) (WHEN P (WHEN NUKE (DO-SYMBOLS (S P) (WHEN (HOME-PACKAGE-P S P) (NUKE-SYMBOL S)))) (ENSURE-PACKAGE-UNUSED P) (DELETE-PACKAGE PACKAGE))))
     [java] ; (DEFUN PACKAGE-NAMES (PACKAGE) (CONS (PACKAGE-NAME PACKAGE) (PACKAGE-NICKNAMES PACKAGE)))
     [java] ; (DEFUN PACKAGES-FROM-NAMES (NAMES) (REMOVE-DUPLICATES (REMOVE NIL (MAPCAR (FUNCTION FIND-PACKAGE) NAMES)) :FROM-END T))
     [java] ; (DEFUN FRESH-PACKAGE-NAME (&KEY (PREFIX :%TO-BE-DELETED) SEPARATOR (INDEX (RANDOM MOST-POSITIVE-FIXNUM))) (LOOP :FOR I :FROM INDEX :FOR N = (FORMAT NIL "~A~@[~A~D~]" PREFIX (AND (PLUSP I) (OR SEPARATOR "")) I) :THEREIS (AND (NOT (FIND-PACKAGE N)) N)))
     [java] ; (DEFUN RENAME-PACKAGE-AWAY (P &REST KEYS &KEY PREFIX &ALLOW-OTHER-KEYS) (LET ((NEW-NAME (APPLY (QUOTE FRESH-PACKAGE-NAME) :PREFIX (OR PREFIX (FORMAT NIL "__~A__" (PACKAGE-NAME P))) KEYS))) (RECORD-FISHY (LIST :RENAME-AWAY (PACKAGE-NAMES P) NEW-NAME)) (RENAME-PACKAGE P NEW-NAME)))
     [java] ; (DEFUN PACKAGE-DEFINITION-FORM (PACKAGE-DESIGNATOR &KEY (NICKNAMESP T) (USEP T) (SHADOWP T) (SHADOWING-IMPORT-P T) (EXPORTP T) (IMPORTP T) INTERNP (ERROR T)) (LET* ((PACKAGE (OR (FIND-PACKAGE* PACKAGE-DESIGNATOR ERROR) (RETURN-FROM PACKAGE-DEFINITION-FORM NIL))) (NAME (PACKAGE-NAME PACKAGE)) (NICKNAMES (PACKAGE-NICKNAMES PACKAGE)) (USE (MAPCAR (FUNCTION PACKAGE-NAME) (PACKAGE-USE-LIST PACKAGE))) (SHADOW NIL) (SHADOWING-IMPORT (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))) (IMPORT (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))) (EXPORT NIL) (INTERN NIL)) (WHEN PACKAGE (LOOP :FOR SYM :BEING :THE :SYMBOLS :IN PACKAGE :FOR STATUS = (NTH-VALUE 1 (FIND-SYMBOL* SYM PACKAGE)) :DO (ECASE STATUS ((NIL :INHERITED)) ((:INTERNAL :EXTERNAL) (LET* ((NAME (SYMBOL-NAME SYM)) (EXTERNAL (EQ STATUS :EXTERNAL)) (HOME (SYMBOL-PACKAGE SYM)) (HOME-NAME (PACKAGE-NAME HOME)) (IMPORTED (NOT (EQ HOME PACKAGE))) (SHADOWING (SYMBOL-SHADOWING-P SYM PACKAGE))) (COND ((AND SHADOWING IMPORTED) (PUSH NAME (GETHASH HOME-NAME SHADOWING-IMPORT))) (SHADOWING (PUSH NAME SHADOW)) (IMPORTED (PUSH NAME (GETHASH HOME-NAME IMPORT)))) (COND (EXTERNAL (PUSH NAME EXPORT)) (IMPORTED) (T (PUSH NAME INTERN))))))) (LABELS ((SORT-NAMES (NAMES) (SORT (COPY-LIST NAMES) (FUNCTION STRING<))) (TABLE-KEYS (TABLE) (LOOP :FOR K :BEING :THE :HASH-KEYS :OF TABLE :COLLECT K)) (WHEN-RELEVANT (KEY VALUE) (WHEN VALUE (LIST (CONS KEY VALUE)))) (IMPORT-OPTIONS (KEY TABLE) (LOOP :FOR I :IN (SORT-NAMES (TABLE-KEYS TABLE)) :COLLECT (SYSTEM::BACKQ-LIST* KEY I (SORT-NAMES (GETHASH I TABLE)))))) (SYSTEM::BACKQ-LIST* (QUOTE DEFPACKAGE) NAME (SYSTEM::BACKQ-APPEND (WHEN-RELEVANT :NICKNAMES (AND NICKNAMESP (SORT-NAMES NICKNAMES))) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-CONS (QUOTE :USE) (AND USEP (SORT-NAMES USE))) (SYSTEM::BACKQ-APPEND (WHEN-RELEVANT :SHADOW (AND SHADOWP (SORT-NAMES SHADOW))) (IMPORT-OPTIONS :SHADOWING-IMPORT-FROM (AND SHADOWING-IMPORT-P SHADOWING-IMPORT)) (IMPORT-OPTIONS :IMPORT-FROM (AND IMPORTP IMPORT)) (WHEN-RELEVANT :EXPORT (AND EXPORTP (SORT-NAMES EXPORT))) (WHEN-RELEVANT :INTERN (AND INTERNP (SORT-NAMES INTERN)))))))))))
     [java] ; (DEFUN ENSURE-SHADOWING-IMPORT (NAME TO-PACKAGE FROM-PACKAGE SHADOWED IMPORTED) (CHECK-TYPE NAME STRING) (CHECK-TYPE TO-PACKAGE PACKAGE) (CHECK-TYPE FROM-PACKAGE PACKAGE) (CHECK-TYPE SHADOWED HASH-TABLE) (CHECK-TYPE IMPORTED HASH-TABLE) (LET ((IMPORT-ME (FIND-SYMBOL* NAME FROM-PACKAGE))) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME TO-PACKAGE) (COND ((GETHASH NAME SHADOWED) (UNLESS (EQ IMPORT-ME EXISTING) (ERROR "Conflicting shadowings for ~A" NAME))) (T (SETF (GETHASH NAME SHADOWED) T) (SETF (GETHASH NAME IMPORTED) T) (UNLESS (OR (NULL STATUS) (AND (MEMBER STATUS (QUOTE (:INTERNAL :EXTERNAL))) (EQ EXISTING IMPORT-ME) (SYMBOL-SHADOWING-P EXISTING TO-PACKAGE))) (NOTE-PACKAGE-FISHINESS :SHADOWING-IMPORT NAME (PACKAGE-NAME FROM-PACKAGE) (OR (HOME-PACKAGE-P IMPORT-ME FROM-PACKAGE) (SYMBOL-PACKAGE-NAME IMPORT-ME)) (PACKAGE-NAME TO-PACKAGE) STATUS (AND STATUS (OR (HOME-PACKAGE-P EXISTING TO-PACKAGE) (SYMBOL-PACKAGE-NAME EXISTING))))) (SHADOWING-IMPORT* IMPORT-ME TO-PACKAGE))))))
     [java] ; (DEFUN ENSURE-IMPORTED (IMPORT-ME INTO-PACKAGE &OPTIONAL FROM-PACKAGE) (CHECK-TYPE IMPORT-ME SYMBOL) (CHECK-TYPE INTO-PACKAGE PACKAGE) (CHECK-TYPE FROM-PACKAGE (OR NULL PACKAGE)) (LET ((NAME (SYMBOL-NAME IMPORT-ME))) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME INTO-PACKAGE) (COND ((NOT STATUS) (IMPORT* IMPORT-ME INTO-PACKAGE)) ((EQ IMPORT-ME EXISTING)) (T (LET ((SHADOWING-P (SYMBOL-SHADOWING-P EXISTING INTO-PACKAGE))) (NOTE-PACKAGE-FISHINESS :ENSURE-IMPORTED NAME (AND FROM-PACKAGE (PACKAGE-NAME FROM-PACKAGE)) (OR (HOME-PACKAGE-P IMPORT-ME FROM-PACKAGE) (SYMBOL-PACKAGE-NAME IMPORT-ME)) (PACKAGE-NAME INTO-PACKAGE) STATUS (AND STATUS (OR (HOME-PACKAGE-P EXISTING INTO-PACKAGE) (SYMBOL-PACKAGE-NAME EXISTING))) SHADOWING-P) (COND ((OR SHADOWING-P (EQ STATUS :INHERITED)) (SHADOWING-IMPORT* IMPORT-ME INTO-PACKAGE)) (T (UNINTERN* EXISTING INTO-PACKAGE) (IMPORT* IMPORT-ME INTO-PACKAGE)))))))) (VALUES))
     [java] ; (DEFUN ENSURE-IMPORT (NAME TO-PACKAGE FROM-PACKAGE SHADOWED IMPORTED) (CHECK-TYPE NAME STRING) (CHECK-TYPE TO-PACKAGE PACKAGE) (CHECK-TYPE FROM-PACKAGE PACKAGE) (CHECK-TYPE SHADOWED HASH-TABLE) (CHECK-TYPE IMPORTED HASH-TABLE) (MULTIPLE-VALUE-BIND (IMPORT-ME IMPORT-STATUS) (FIND-SYMBOL NAME FROM-PACKAGE) (WHEN (NULL IMPORT-STATUS) (NOTE-PACKAGE-FISHINESS :IMPORT-UNINTERNED NAME (PACKAGE-NAME FROM-PACKAGE) (PACKAGE-NAME TO-PACKAGE)) (SETF IMPORT-ME (INTERN* NAME FROM-PACKAGE))) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME TO-PACKAGE) (COND ((AND IMPORTED (GETHASH NAME IMPORTED)) (UNLESS (AND STATUS (EQ IMPORT-ME EXISTING)) (ERROR "Can't import ~S from both ~S and ~S" NAME (PACKAGE-NAME (SYMBOL-PACKAGE EXISTING)) (PACKAGE-NAME FROM-PACKAGE)))) ((GETHASH NAME SHADOWED) (ERROR "Can't both shadow ~S and import it from ~S" NAME (PACKAGE-NAME FROM-PACKAGE))) (T (SETF (GETHASH NAME IMPORTED) T)))) (ENSURE-IMPORTED IMPORT-ME TO-PACKAGE FROM-PACKAGE)))
     [java] ; (DEFUN ENSURE-INHERITED (NAME SYMBOL TO-PACKAGE FROM-PACKAGE MIXP SHADOWED IMPORTED INHERITED) (CHECK-TYPE NAME STRING) (CHECK-TYPE SYMBOL SYMBOL) (CHECK-TYPE TO-PACKAGE PACKAGE) (CHECK-TYPE FROM-PACKAGE PACKAGE) (CHECK-TYPE MIXP (MEMBER NIL T)) (CHECK-TYPE SHADOWED HASH-TABLE) (CHECK-TYPE IMPORTED HASH-TABLE) (CHECK-TYPE INHERITED HASH-TABLE) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME TO-PACKAGE) (LET* ((SP (SYMBOL-PACKAGE SYMBOL)) (IN (GETHASH NAME INHERITED)) (XP (AND STATUS (SYMBOL-PACKAGE EXISTING)))) (WHEN (NULL SP) (NOTE-PACKAGE-FISHINESS :IMPORT-UNINTERNED NAME (PACKAGE-NAME FROM-PACKAGE) (PACKAGE-NAME TO-PACKAGE) MIXP) (IMPORT* SYMBOL FROM-PACKAGE) (SETF SP (PACKAGE-NAME FROM-PACKAGE))) (COND ((GETHASH NAME SHADOWED)) (IN (UNLESS (EQUAL SP (FIRST IN)) (IF MIXP (ENSURE-SHADOWING-IMPORT NAME TO-PACKAGE (SECOND IN) SHADOWED IMPORTED) (ERROR "Can't inherit ~S from ~S, it is inherited from ~S" NAME (PACKAGE-NAME SP) (PACKAGE-NAME (FIRST IN)))))) ((GETHASH NAME IMPORTED) (UNLESS (EQ SYMBOL EXISTING) (ERROR "Can't inherit ~S from ~S, it is imported from ~S" NAME (PACKAGE-NAME SP) (PACKAGE-NAME XP)))) (T (SETF (GETHASH NAME INHERITED) (LIST SP FROM-PACKAGE)) (WHEN (AND STATUS (NOT (EQ SP XP))) (LET ((SHADOWING (SYMBOL-SHADOWING-P EXISTING TO-PACKAGE))) (NOTE-PACKAGE-FISHINESS :INHERITED NAME (PACKAGE-NAME FROM-PACKAGE) (OR (HOME-PACKAGE-P SYMBOL FROM-PACKAGE) (SYMBOL-PACKAGE-NAME SYMBOL)) (PACKAGE-NAME TO-PACKAGE) (OR (HOME-PACKAGE-P EXISTING TO-PACKAGE) (SYMBOL-PACKAGE-NAME EXISTING))) (IF SHADOWING (ENSURE-SHADOWING-IMPORT NAME TO-PACKAGE FROM-PACKAGE SHADOWED IMPORTED) (UNINTERN* EXISTING TO-PACKAGE)))))))))
     [java] ; (DEFUN ENSURE-MIX (NAME SYMBOL TO-PACKAGE FROM-PACKAGE SHADOWED IMPORTED INHERITED) (CHECK-TYPE NAME STRING) (CHECK-TYPE SYMBOL SYMBOL) (CHECK-TYPE TO-PACKAGE PACKAGE) (CHECK-TYPE FROM-PACKAGE PACKAGE) (CHECK-TYPE SHADOWED HASH-TABLE) (CHECK-TYPE IMPORTED HASH-TABLE) (CHECK-TYPE INHERITED HASH-TABLE) (UNLESS (GETHASH NAME SHADOWED) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME TO-PACKAGE) (LET* ((SP (SYMBOL-PACKAGE SYMBOL)) (IM (GETHASH NAME IMPORTED)) (IN (GETHASH NAME INHERITED))) (COND ((OR (NULL STATUS) (AND STATUS (EQ SYMBOL EXISTING)) (AND IN (EQ SP (FIRST IN)))) (ENSURE-INHERITED NAME SYMBOL TO-PACKAGE FROM-PACKAGE T SHADOWED IMPORTED INHERITED)) (IN (REMHASH NAME INHERITED) (ENSURE-SHADOWING-IMPORT NAME TO-PACKAGE (SECOND IN) SHADOWED IMPORTED)) (IM (ERROR "Symbol ~S import from ~S~:[~; actually ~:[uninterned~;~:*from ~S~]~] conflicts with existing symbol in ~S~:[~; actually ~:[uninterned~;from ~:*~S~]~]" NAME (PACKAGE-NAME FROM-PACKAGE) (HOME-PACKAGE-P SYMBOL FROM-PACKAGE) (SYMBOL-PACKAGE-NAME SYMBOL) (PACKAGE-NAME TO-PACKAGE) (HOME-PACKAGE-P EXISTING TO-PACKAGE) (SYMBOL-PACKAGE-NAME EXISTING))) (T (ENSURE-INHERITED NAME SYMBOL TO-PACKAGE FROM-PACKAGE T SHADOWED IMPORTED INHERITED)))))))
     [java] ; (DEFUN RECYCLE-SYMBOL (NAME RECYCLE EXPORTED) (CHECK-TYPE NAME STRING) (CHECK-TYPE RECYCLE LIST) (CHECK-TYPE EXPORTED HASH-TABLE) (WHEN (GETHASH NAME EXPORTED) (LET (RECYCLED FOUNDP) (DOLIST (R RECYCLE (VALUES RECYCLED FOUNDP)) (MULTIPLE-VALUE-BIND (SYMBOL STATUS) (FIND-SYMBOL NAME R) (WHEN (AND STATUS (HOME-PACKAGE-P SYMBOL R)) (COND (FOUNDP (NOTE-PACKAGE-FISHINESS :RECYCLED-DUPLICATE NAME (PACKAGE-NAME FOUNDP) (PACKAGE-NAME R))) (T (SETF RECYCLED SYMBOL FOUNDP R)))))))))
     [java] ; (DEFUN SYMBOL-RECYCLED-P (SYM RECYCLE) (CHECK-TYPE SYM SYMBOL) (CHECK-TYPE RECYCLE LIST) (AND (MEMBER (SYMBOL-PACKAGE SYM) RECYCLE) T))
     [java] ; (DEFUN ENSURE-SYMBOL (NAME PACKAGE INTERN RECYCLE SHADOWED IMPORTED INHERITED EXPORTED) (CHECK-TYPE NAME STRING) (CHECK-TYPE PACKAGE PACKAGE) (CHECK-TYPE INTERN (MEMBER NIL T)) (CHECK-TYPE SHADOWED HASH-TABLE) (CHECK-TYPE IMPORTED HASH-TABLE) (CHECK-TYPE INHERITED HASH-TABLE) (UNLESS (OR (GETHASH NAME SHADOWED) (GETHASH NAME IMPORTED) (GETHASH NAME INHERITED)) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME PACKAGE) (MULTIPLE-VALUE-BIND (RECYCLED PREVIOUS) (RECYCLE-SYMBOL NAME RECYCLE EXPORTED) (COND ((AND STATUS (EQ EXISTING RECYCLED) (EQ PREVIOUS PACKAGE))) (PREVIOUS (REHOME-SYMBOL RECYCLED PACKAGE)) ((AND STATUS (EQ PACKAGE (SYMBOL-PACKAGE EXISTING)))) (T (WHEN STATUS (NOTE-PACKAGE-FISHINESS :ENSURE-SYMBOL NAME (REIFY-PACKAGE (SYMBOL-PACKAGE EXISTING) PACKAGE) STATUS INTERN) (UNINTERN EXISTING)) (WHEN INTERN (INTERN* NAME PACKAGE))))))))
     [java] ; (DECLAIM (FTYPE (FUNCTION (T T T &OPTIONAL T) T) ENSURE-EXPORTED))
     [java] ; (DEFUN ENSURE-EXPORTED-TO-USER (NAME SYMBOL TO-PACKAGE &OPTIONAL RECYCLE) (CHECK-TYPE NAME STRING) (CHECK-TYPE SYMBOL SYMBOL) (CHECK-TYPE TO-PACKAGE PACKAGE) (CHECK-TYPE RECYCLE LIST) (ASSERT (EQUAL NAME (SYMBOL-NAME SYMBOL))) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME TO-PACKAGE) (UNLESS (AND STATUS (EQ SYMBOL EXISTING)) (LET ((ACCESSIBLE (OR (NULL STATUS) (LET ((SHADOWING (SYMBOL-SHADOWING-P EXISTING TO-PACKAGE)) (RECYCLED (SYMBOL-RECYCLED-P EXISTING RECYCLE))) (UNLESS (AND SHADOWING (NOT RECYCLED)) (NOTE-PACKAGE-FISHINESS :ENSURE-EXPORT NAME (SYMBOL-PACKAGE-NAME SYMBOL) (PACKAGE-NAME TO-PACKAGE) (OR (HOME-PACKAGE-P EXISTING TO-PACKAGE) (SYMBOL-PACKAGE-NAME EXISTING)) STATUS SHADOWING) (IF (OR (EQ STATUS :INHERITED) SHADOWING) (SHADOWING-IMPORT* SYMBOL TO-PACKAGE) (UNINTERN EXISTING TO-PACKAGE)) T))))) (WHEN (AND ACCESSIBLE (EQ STATUS :EXTERNAL)) (ENSURE-EXPORTED NAME SYMBOL TO-PACKAGE RECYCLE))))))
     [java] ; (DEFUN ENSURE-EXPORTED (NAME SYMBOL FROM-PACKAGE &OPTIONAL RECYCLE) (DOLIST (TO-PACKAGE (PACKAGE-USED-BY-LIST FROM-PACKAGE)) (ENSURE-EXPORTED-TO-USER NAME SYMBOL TO-PACKAGE RECYCLE)) (UNLESS (EQ FROM-PACKAGE (SYMBOL-PACKAGE SYMBOL)) (ENSURE-IMPORTED SYMBOL FROM-PACKAGE)) (EXPORT* NAME FROM-PACKAGE))
     [java] ; (DEFUN ENSURE-EXPORT (NAME FROM-PACKAGE &OPTIONAL RECYCLE) (MULTIPLE-VALUE-BIND (SYMBOL STATUS) (FIND-SYMBOL* NAME FROM-PACKAGE) (UNLESS (EQ STATUS :EXTERNAL) (ENSURE-EXPORTED NAME SYMBOL FROM-PACKAGE RECYCLE))))
     [java] ; (DEFUN ENSURE-PACKAGE (NAME &KEY NICKNAMES DOCUMENTATION USE SHADOW SHADOWING-IMPORT-FROM IMPORT-FROM EXPORT INTERN RECYCLE MIX REEXPORT UNINTERN) (LET* ((PACKAGE-NAME (STRING NAME)) (NICKNAMES (MAPCAR (FUNCTION STRING) NICKNAMES)) (NAMES (CONS PACKAGE-NAME NICKNAMES)) (PREVIOUS (PACKAGES-FROM-NAMES NAMES)) (DISCARDED (CDR PREVIOUS)) (TO-DELETE NIL) (PACKAGE (OR (FIRST PREVIOUS) (MAKE-PACKAGE PACKAGE-NAME :NICKNAMES NICKNAMES))) (RECYCLE (PACKAGES-FROM-NAMES RECYCLE)) (USE (MAPCAR (QUOTE FIND-PACKAGE*) USE)) (MIX (MAPCAR (QUOTE FIND-PACKAGE*) MIX)) (REEXPORT (MAPCAR (QUOTE FIND-PACKAGE*) REEXPORT)) (SHADOW (MAPCAR (QUOTE STRING) SHADOW)) (EXPORT (MAPCAR (QUOTE STRING) EXPORT)) (INTERN (MAPCAR (QUOTE STRING) INTERN)) (UNINTERN (MAPCAR (QUOTE STRING) UNINTERN)) (SHADOWED (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))) (IMPORTED (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))) (EXPORTED (MAKE-HASH-TABLE :TEST (QUOTE EQUAL))) (INHERITED (MAKE-HASH-TABLE :TEST (QUOTE EQUAL)))) (WHEN-PACKAGE-FISHINESS (RECORD-FISHY PACKAGE-NAME)) (WHEN DOCUMENTATION (SETF (DOCUMENTATION PACKAGE T) DOCUMENTATION)) (LOOP :FOR P :IN (SET-DIFFERENCE (PACKAGE-USE-LIST PACKAGE) (APPEND MIX USE)) :DO (NOTE-PACKAGE-FISHINESS :OVER-USE NAME (PACKAGE-NAMES P)) (UNUSE-PACKAGE P PACKAGE)) (LOOP :FOR P :IN DISCARDED :FOR N = (REMOVE-IF (FUNCTION (LAMBDA (X) (MEMBER X NAMES :TEST (QUOTE EQUAL)))) (PACKAGE-NAMES P)) :DO (NOTE-PACKAGE-FISHINESS :NICKNAME NAME (PACKAGE-NAMES P)) (COND (N (RENAME-PACKAGE P (FIRST N) (REST N))) (T (RENAME-PACKAGE-AWAY P) (PUSH P TO-DELETE)))) (RENAME-PACKAGE PACKAGE PACKAGE-NAME NICKNAMES) (DOLIST (NAME UNINTERN) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME PACKAGE) (WHEN STATUS (UNLESS (EQ STATUS :INHERITED) (NOTE-PACKAGE-FISHINESS :UNINTERN (PACKAGE-NAME PACKAGE) NAME (SYMBOL-PACKAGE-NAME EXISTING) STATUS) (UNINTERN* NAME PACKAGE NIL))))) (DOLIST (NAME EXPORT) (SETF (GETHASH NAME EXPORTED) T)) (DOLIST (P REEXPORT) (DO-EXTERNAL-SYMBOLS (SYM P) (SETF (GETHASH (STRING SYM) EXPORTED) T))) (DO-EXTERNAL-SYMBOLS (SYM PACKAGE) (LET ((NAME (SYMBOL-NAME SYM))) (UNLESS (GETHASH NAME EXPORTED) (NOTE-PACKAGE-FISHINESS :OVER-EXPORT (PACKAGE-NAME PACKAGE) NAME (OR (HOME-PACKAGE-P SYM PACKAGE) (SYMBOL-PACKAGE-NAME SYM))) (UNEXPORT SYM PACKAGE)))) (DOLIST (NAME SHADOW) (SETF (GETHASH NAME SHADOWED) T) (MULTIPLE-VALUE-BIND (EXISTING STATUS) (FIND-SYMBOL NAME PACKAGE) (MULTIPLE-VALUE-BIND (RECYCLED PREVIOUS) (RECYCLE-SYMBOL NAME RECYCLE EXPORTED) (LET ((SHADOWING (AND STATUS (SYMBOL-SHADOWING-P EXISTING PACKAGE)))) (COND ((EQ PREVIOUS PACKAGE)) (PREVIOUS (REHOME-SYMBOL RECYCLED PACKAGE)) ((OR (MEMBER STATUS (QUOTE (NIL :INHERITED))) (HOME-PACKAGE-P EXISTING PACKAGE))) (T (LET ((DUMMY (MAKE-SYMBOL NAME))) (NOTE-PACKAGE-FISHINESS :SHADOW-IMPORTED (PACKAGE-NAME PACKAGE) NAME (SYMBOL-PACKAGE-NAME EXISTING) STATUS SHADOWING) (SHADOWING-IMPORT* DUMMY PACKAGE) (IMPORT* DUMMY PACKAGE))))))) (SHADOW* NAME PACKAGE)) (LOOP :FOR (P . SYMS) :IN SHADOWING-IMPORT-FROM :FOR PP = (FIND-PACKAGE* P) :DO (DOLIST (SYM SYMS) (ENSURE-SHADOWING-IMPORT (STRING SYM) PACKAGE PP SHADOWED IMPORTED))) (LOOP :FOR P :IN MIX :FOR PP = (FIND-PACKAGE* P) :DO (DO-EXTERNAL-SYMBOLS (SYM PP) (ENSURE-MIX (SYMBOL-NAME SYM) SYM PACKAGE PP SHADOWED IMPORTED INHERITED))) (LOOP :FOR (P . SYMS) :IN IMPORT-FROM :FOR PP = (FIND-PACKAGE P) :DO (DOLIST (SYM SYMS) (ENSURE-IMPORT (SYMBOL-NAME SYM) PACKAGE PP SHADOWED IMPORTED))) (DOLIST (P (APPEND USE MIX)) (DO-EXTERNAL-SYMBOLS (SYM P) (ENSURE-INHERITED (STRING SYM) SYM PACKAGE P NIL SHADOWED IMPORTED INHERITED)) (USE-PACKAGE P PACKAGE)) (LOOP :FOR NAME :BEING :THE :HASH-KEYS :OF EXPORTED :DO (ENSURE-SYMBOL NAME PACKAGE T RECYCLE SHADOWED IMPORTED INHERITED EXPORTED) (ENSURE-EXPORT NAME PACKAGE RECYCLE)) (DOLIST (NAME INTERN) (ENSURE-SYMBOL NAME PACKAGE T RECYCLE SHADOWED IMPORTED INHERITED EXPORTED)) (DO-SYMBOLS (SYM PACKAGE) (ENSURE-SYMBOL (SYMBOL-NAME SYM) PACKAGE NIL RECYCLE SHADOWED IMPORTED INHERITED EXPORTED)) (MAP NIL (QUOTE DELETE-PACKAGE*) TO-DELETE) PACKAGE))
     [java] ; (DEFUN PARSE-DEFINE-PACKAGE-FORM (PACKAGE CLAUSES) (LOOP :WITH USE-P = NIL :WITH RECYCLE-P = NIL :WITH DOCUMENTATION = NIL :FOR (KW . ARGS) :IN CLAUSES :WHEN (EQ KW :NICKNAMES) :APPEND ARGS :INTO NICKNAMES :ELSE :WHEN (EQ KW :DOCUMENTATION) :DO (COND (DOCUMENTATION (ERROR "define-package: can't define documentation twice")) ((OR (ATOM ARGS) (CDR ARGS)) (ERROR "define-package: bad documentation")) (T (SETF DOCUMENTATION (CAR ARGS)))) :ELSE :WHEN (EQ KW :USE) :APPEND ARGS :INTO USE :AND :DO (SETF USE-P T) :ELSE :WHEN (EQ KW :SHADOW) :APPEND ARGS :INTO SHADOW :ELSE :WHEN (EQ KW :SHADOWING-IMPORT-FROM) :COLLECT ARGS :INTO SHADOWING-IMPORT-FROM :ELSE :WHEN (EQ KW :IMPORT-FROM) :COLLECT ARGS :INTO IMPORT-FROM :ELSE :WHEN (EQ KW :EXPORT) :APPEND ARGS :INTO EXPORT :ELSE :WHEN (EQ KW :INTERN) :APPEND ARGS :INTO INTERN :ELSE :WHEN (EQ KW :RECYCLE) :APPEND ARGS :INTO RECYCLE :AND :DO (SETF RECYCLE-P T) :ELSE :WHEN (EQ KW :MIX) :APPEND ARGS :INTO MIX :ELSE :WHEN (EQ KW :REEXPORT) :APPEND ARGS :INTO REEXPORT :ELSE :WHEN (EQ KW :USE-REEXPORT) :APPEND ARGS :INTO USE :AND :APPEND ARGS :INTO REEXPORT :AND :DO (SETF USE-P T) :ELSE :WHEN (EQ KW :MIX-REEXPORT) :APPEND ARGS :INTO MIX :AND :APPEND ARGS :INTO REEXPORT :AND :DO (SETF USE-P T) :ELSE :WHEN (EQ KW :UNINTERN) :APPEND ARGS :INTO UNINTERN :ELSE :DO (ERROR "unrecognized define-package keyword ~S" KW) :FINALLY (RETURN (SYSTEM::BACKQ-LIST PACKAGE (QUOTE :NICKNAMES) NICKNAMES (QUOTE :DOCUMENTATION) DOCUMENTATION (QUOTE :USE) (IF USE-P USE (QUOTE (:COMMON-LISP))) (QUOTE :SHADOW) SHADOW (QUOTE :SHADOWING-IMPORT-FROM) SHADOWING-IMPORT-FROM (QUOTE :IMPORT-FROM) IMPORT-FROM (QUOTE :EXPORT) EXPORT (QUOTE :INTERN) INTERN (QUOTE :RECYCLE) (IF RECYCLE-P RECYCLE (CONS PACKAGE NICKNAMES)) (QUOTE :MIX) MIX (QUOTE :REEXPORT) REEXPORT (QUOTE :UNINTERN) UNINTERN))))
     [java] ; (DEFMACRO DEFINE-PACKAGE (PACKAGE &REST CLAUSES) "DEFINE-PACKAGE takes a PACKAGE and a number of CLAUSES, of the form
     [java] (KEYWORD . ARGS).
     [java] DEFINE-PACKAGE supports the following keywords:
     [java] USE, SHADOW, SHADOWING-IMPORT-FROM, IMPORT-FROM, EXPORT, INTERN -- as per CL:DEFPACKAGE.
     [java] RECYCLE -- Recycle the package's exported symbols from the specified packages,
     [java] in order.  For every symbol scheduled to be exported by the DEFINE-PACKAGE,
     [java] either through an :EXPORT option or a :REEXPORT option, if the symbol exists in
     [java] one of the :RECYCLE packages, the first such symbol is re-homed to the package
     [java] being defined.
     [java] For the sake of idempotence, it is important that the package being defined
     [java] should appear in first position if it already exists, and even if it doesn't,
     [java] ahead of any package that is not going to be deleted afterwards and never
     [java] created again. In short, except for special cases, always make it the first
     [java] package on the list if the list is not empty.
     [java] MIX -- Takes a list of package designators.  MIX behaves like
     [java] (:USE PKG1 PKG2 ... PKGn) but additionally uses :SHADOWING-IMPORT-FROM to
     [java] resolve conflicts in favor of the first found symbol.  It may still yield
     [java] an error if there is a conflict with an explicitly :IMPORT-FROM symbol.
     [java] REEXPORT -- Takes a list of package designators.  For each package, p, in the list,
     [java] export symbols with the same name as those exported from p.  Note that in the case
     [java] of shadowing, etc. the symbols with the same name may not be the same symbols.
     [java] UNINTERN -- Remove symbols here from PACKAGE." (LET ((ENSURE-FORM (SYSTEM::BACKQ-LIST (QUOTE APPLY) (QUOTE (QUOTE ENSURE-PACKAGE)) (SYSTEM::BACKQ-LIST (QUOTE QUOTE) (PARSE-DEFINE-PACKAGE-FORM PACKAGE CLAUSES))))) (SYSTEM::BACKQ-LIST (QUOTE PROGN) (SYSTEM::BACKQ-LIST (QUOTE EVAL-WHEN) (QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) ENSURE-FORM))))
     [java] ; (DEFINE-PACKAGE :ASDF/PACKAGE (:USE :CL :UIOP/PACKAGE) (:REEXPORT :UIOP/PACKAGE))
     [java] ;COMMON-LISP:MAP triggers autoloading of map ...
     [java] ; Autoloaded map (0.009 seconds)
     [java] ; (DEFINE-PACKAGE :UIOP/COMMON-LISP (:NICKNAMES :UOIP/CL :ASDF/COMMON-LISP :ASDF/CL) (:USE :UIOP/PACKAGE) (:USE-REEXPORT :COMMON-LISP) (:RECYCLE :UIOP/COMMON-LISP :UOIP/CL :ASDF/COMMON-LISP :ASDF/CL :ASDF))
     [java] ; (IN-PACKAGE :UIOP/COMMON-LISP)
     [java] ; (WHEN (AND) (PUSHNEW :ASDF-UNICODE *FEATURES*))
     [java] ; (DEFMACRO LOOP* (&REST REST) (SYSTEM::BACKQ-CONS (QUOTE LOOP) REST))
     [java] ; (DEFUN FROB-SUBSTRINGS (STRING SUBSTRINGS &OPTIONAL FROB) "for each substring in SUBSTRINGS, find occurrences of it within STRING
     [java] that don't use parts of matched occurrences of previous strings, and
     [java] FROB them, that is to say, remove them if FROB is NIL,
     [java] replace by FROB if FROB is a STRING, or if FROB is a FUNCTION,
     [java] call FROB with the match and a function that emits a string in the output.
     [java] Return a string made of the parts not omitted or emitted by FROB." (DECLARE (OPTIMIZE (SPEED 0) (SAFETY 3) (DEBUG 3))) (LET ((LENGTH (LENGTH STRING)) (STREAM NIL)) (LABELS ((EMIT-STRING (X &OPTIONAL (START 0) (END (LENGTH X))) (WHEN (< START END) (UNLESS STREAM (SETF STREAM (MAKE-STRING-OUTPUT-STREAM))) (WRITE-STRING X STREAM :START START :END END))) (EMIT-SUBSTRING (START END) (WHEN (AND (ZEROP START) (= END LENGTH)) (RETURN-FROM FROB-SUBSTRINGS STRING)) (EMIT-STRING STRING START END)) (RECURSE (SUBSTRINGS START END) (COND ((>= START END)) ((NULL SUBSTRINGS) (EMIT-SUBSTRING START END)) (T (LET* ((SUB-SPEC (FIRST SUBSTRINGS)) (SUB (IF (CONSP SUB-SPEC) (CAR SUB-SPEC) SUB-SPEC)) (FUN (IF (CONSP SUB-SPEC) (CDR SUB-SPEC) FROB)) (FOUND (SEARCH SUB STRING :START2 START :END2 END)) (MORE (REST SUBSTRINGS))) (COND (FOUND (RECURSE MORE START FOUND) (ETYPECASE FUN (NULL) (STRING (EMIT-STRING FUN)) (FUNCTION (FUNCALL FUN SUB (FUNCTION EMIT-STRING)))) (RECURSE SUBSTRINGS (+ FOUND (LENGTH SUB)) END)) (T (RECURSE MORE START END)))))))) (RECURSE SUBSTRINGS 0 LENGTH)) (IF STREAM (GET-OUTPUT-STREAM-STRING STREAM) "")))
     [java] ; (DEFMACRO COMPATFMT (FORMAT) FORMAT)
     [java] ; (DEFINE-PACKAGE :UIOP/UTILITY (:NICKNAMES :ASDF/UTILITY) (:RECYCLE :UIOP/UTILITY :ASDF/UTILITY :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE) (:IMPORT-FROM :UIOP/COMMON-LISP #:COMPATFMT #:LOOP* #:FROB-SUBSTRINGS) (:EXPORT #:COMPATFMT #:LOOP* #:FROB-SUBSTRINGS #:COMPATFMT) (:EXPORT #:UIOP-DEBUG #:LOAD-UIOP-DEBUG-UTILITY #:*UIOP-DEBUG-UTILITY* #:WITH-UPGRADABILITY #:UNDEFINE-FUNCTION #:UNDEFINE-FUNCTIONS #:DEFUN* #:DEFGENERIC* #:NEST #:IF-LET #:WHILE-COLLECTING #:APPENDF #:LENGTH=N-P #:ENSURE-LIST #:REMOVE-PLIST-KEYS #:REMOVE-PLIST-KEY #:EMPTYP #:+NON-BASE-CHARS-EXIST-P+ #:+MAX-CHARACTER-TYPE-INDEX+ #:CHARACTER-TYPE-INDEX #:+CHARACTER-TYPES+ #:BASE-STRING-P #:STRINGS-COMMON-ELEMENT-TYPE #:REDUCE/STRCAT #:STRCAT #:FIRST-CHAR #:LAST-CHAR #:SPLIT-STRING #:STRIPLN #:+CR+ #:+LF+ #:+CRLF+ #:STRING-PREFIX-P #:STRING-ENCLOSED-P #:STRING-SUFFIX-P #:STANDARD-CASE-SYMBOL-NAME #:FIND-STANDARD-CASE-SYMBOL #:COERCE-CLASS #:STAMP< #:STAMPS< #:STAMP*< #:STAMP<= #:EARLIER-STAMP #:STAMPS-EARLIEST #:EARLIEST-STAMP #:LATER-STAMP #:STAMPS-LATEST #:LATEST-STAMP #:LATEST-STAMP-F #:LIST-TO-HASH-SET #:ENSURE-GETHASH #:ENSURE-FUNCTION #:ACCESS-AT #:ACCESS-AT-COUNT #:CALL-FUNCTION #:CALL-FUNCTIONS #:REGISTER-HOOK-FUNCTION #:MATCH-CONDITION-P #:MATCH-ANY-CONDITION-P #:CALL-WITH-MUFFLED-CONDITIONS #:WITH-MUFFLED-CONDITIONS #:LEXICOGRAPHIC< #:LEXICOGRAPHIC<= #:PARSE-VERSION #:UNPARSE-VERSION #:VERSION< #:VERSION<= #:VERSION-COMPATIBLE-P))
     [java] ; (IN-PACKAGE :UIOP/UTILITY)
     [java] ; (COMMON-LISP:DEFUN UNDEFINE-FUNCTION (FUNCTION-SPEC) (COMMON-LISP:COND ((COMMON-LISP:SYMBOLP FUNCTION-SPEC) (COMMON-LISP:FMAKUNBOUND FUNCTION-SPEC)) ((COMMON-LISP:AND (COMMON-LISP:CONSP FUNCTION-SPEC) (COMMON-LISP:EQ (COMMON-LISP:CAR FUNCTION-SPEC) (COMMON-LISP:QUOTE COMMON-LISP:SETF)) (COMMON-LISP:CONSP (COMMON-LISP:CDR FUNCTION-SPEC)) (COMMON-LISP:NULL (COMMON-LISP:CDDR FUNCTION-SPEC))) (COMMON-LISP:FMAKUNBOUND FUNCTION-SPEC)) (COMMON-LISP:T (COMMON-LISP:ERROR "bad function spec ~S" FUNCTION-SPEC))))
     [java] ; (COMMON-LISP:DEFUN UNDEFINE-FUNCTIONS (FUNCTION-SPEC-LIST) (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:QUOTE UNDEFINE-FUNCTION) FUNCTION-SPEC-LIST))
     [java] ; (DEFDEF DEFGENERIC* COMMON-LISP:DEFGENERIC)
     [java] ; (DEFDEF DEFUN* COMMON-LISP:DEFUN)
     [java] ; (COMMON-LISP:DEFMACRO WITH-UPGRADABILITY ((COMMON-LISP:&OPTIONAL) COMMON-LISP:&BODY BODY) "Evaluate BODY at compile- load- and run- times, with DEFUN and DEFGENERIC modified
     [java] to also declare the functions NOTINLINE and to accept a wrapping the function name
     [java] specification into a list with keyword argument SUPERSEDE (which defaults to T if the name
     [java] is not wrapped, and NIL if it is wrapped). If SUPERSEDE is true, call UNDEFINE-FUNCTION
     [java] to supersede any previous definition." (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:EVAL-WHEN) (COMMON-LISP:QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (COMMON-LISP:LOOP :FOR FORM :IN BODY :COLLECT (COMMON-LISP:IF (COMMON-LISP:CONSP FORM) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:CAR . COMMON-LISP:CDR) FORM (COMMON-LISP:CASE COMMON-LISP:CAR ((COMMON-LISP:DEFUN) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE DEFUN*) COMMON-LISP:CDR)) ((COMMON-LISP:DEFGENERIC) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE DEFGENERIC*) COMMON-LISP:CDR)) (COMMON-LISP:OTHERWISE FORM))) FORM))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *UIOP-DEBUG-UTILITY* (COMMON-LISP:QUOTE (COMMON-LISP:OR (COMMON-LISP:IGNORE-ERRORS (SYMBOL-CALL :ASDF :SYSTEM-RELATIVE-PATHNAME :UIOP "contrib/debug.lisp")) (SYMBOL-CALL :UIOP/PATHNAME :SUBPATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME) "cl/asdf/uiop/contrib/debug.lisp"))) "form that evaluates to the pathname to your favorite debugging utilities") (COMMON-LISP:DEFMACRO UIOP-DEBUG (COMMON-LISP:&REST KEYS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:EVAL-WHEN) (COMMON-LISP:QUOTE (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE LOAD-UIOP-DEBUG-UTILITY) KEYS))) (COMMON-LISP:DEFUN LOAD-UIOP-DEBUG-UTILITY (COMMON-LISP:&KEY COMMON-LISP:PACKAGE UTILITY-FILE) (COMMON-LISP:LET* ((COMMON-LISP:*PACKAGE* (COMMON-LISP:IF COMMON-LISP:PACKAGE (COMMON-LISP:FIND-PACKAGE COMMON-LISP:PACKAGE) COMMON-LISP:*PACKAGE*)) (COMMON-LISP:KEYWORD (COMMON-LISP:READ-FROM-STRING (COMMON-LISP:FORMAT COMMON-LISP:NIL ":DBG-~:@(~A~)" (COMMON-LISP:PACKAGE-NAME COMMON-LISP:*PACKAGE*))))) (COMMON-LISP:UNLESS (COMMON-LISP:MEMBER COMMON-LISP:KEYWORD COMMON-LISP:*FEATURES*) (COMMON-LISP:LET* ((UTILITY-FILE (COMMON-LISP:OR UTILITY-FILE *UIOP-DEBUG-UTILITY*)) (FILE (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:PROBE-FILE (COMMON-LISP:EVAL UTILITY-FILE))))) (COMMON-LISP:IF FILE (COMMON-LISP:LOAD FILE) (COMMON-LISP:ERROR "Failed to locate debug utility file: ~S" UTILITY-FILE)))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMACRO NEST (COMMON-LISP:&REST THINGS) "Macro to do keep code nesting and indentation under control." (COMMON-LISP:REDUCE (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (OUTER INNER) (SYSTEM::BACKQ-APPEND OUTER (SYSTEM::BACKQ-LIST INNER)))) THINGS :FROM-END COMMON-LISP:T)) (COMMON-LISP:DEFMACRO IF-LET (BINDINGS COMMON-LISP:&BODY (THEN-FORM COMMON-LISP:&OPTIONAL ELSE-FORM)) (COMMON-LISP:LET* ((BINDING-LIST (COMMON-LISP:IF (COMMON-LISP:AND (COMMON-LISP:CONSP BINDINGS) (COMMON-LISP:SYMBOLP (COMMON-LISP:CAR BINDINGS))) (COMMON-LISP:LIST BINDINGS) BINDINGS)) (VARIABLES (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION COMMON-LISP:CAR) BINDING-LIST))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:LET) BINDING-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IF) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:AND) VARIABLES) THEN-FORM ELSE-FORM)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMACRO WHILE-COLLECTING ((COMMON-LISP:&REST COLLECTORS) COMMON-LISP:&BODY BODY) "COLLECTORS should be a list of names for collections.  A collector
     [java] defines a function that, when applied to an argument inside BODY, will
     [java] add its argument to the corresponding collection.  Returns multiple values,
     [java] a list for each collection, in order.
     [java]    E.g.,
     [java] (while-collecting (foo bar)
     [java]            (dolist (x '((a 1) (b 2) (c 3)))
     [java]              (foo (first x))
     [java]              (bar (second x))))
     [java] Returns two values: (A B C) and (1 2 3)." (COMMON-LISP:LET ((VARS (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:GENSYM (COMMON-LISP:SYMBOL-NAME X)))) COLLECTORS)) (INITIAL-VALUES (COMMON-LISP:MAPCAR (COMMON-LISP:CONSTANTLY COMMON-LISP:NIL) COLLECTORS))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:LET) (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION COMMON-LISP:LIST) VARS INITIAL-VALUES) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:FLET) (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C V) (SYSTEM::BACKQ-LIST* C (COMMON-LISP:QUOTE (X)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:PUSH) (COMMON-LISP:QUOTE X) V) (COMMON-LISP:QUOTE ((COMMON-LISP:VALUES)))))) COLLECTORS VARS) (SYSTEM::BACKQ-APPEND BODY (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:VALUES) (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (V) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:REVERSE) V))) VARS)))))))) (COMMON-LISP:DEFINE-MODIFY-MACRO APPENDF (COMMON-LISP:&REST ARGS) COMMON-LISP:APPEND "Append onto list") (COMMON-LISP:DEFUN LENGTH=N-P (X N) (COMMON-LISP:CHECK-TYPE N (COMMON-LISP:INTEGER 0 COMMON-LISP:*)) (COMMON-LISP:LOOP :FOR L COMMON-LISP:= X :THEN (COMMON-LISP:CDR L) :FOR I :DOWNFROM N :DO (COMMON-LISP:COND ((COMMON-LISP:ZEROP I) (COMMON-LISP:RETURN (COMMON-LISP:NULL L))) ((COMMON-LISP:NOT (COMMON-LISP:CONSP L)) (COMMON-LISP:RETURN COMMON-LISP:NIL))))) (COMMON-LISP:DEFUN ENSURE-LIST (X) (COMMON-LISP:IF (COMMON-LISP:LISTP X) X (COMMON-LISP:LIST X))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN REMOVE-PLIST-KEY (KEY PLIST) "Remove a single key from a plist" (LOOP* :FOR (K V) :ON PLIST :BY (COMMON-LISP:FUNCTION COMMON-LISP:CDDR) :UNLESS (COMMON-LISP:EQ K KEY) :APPEND (COMMON-LISP:LIST K V))) (COMMON-LISP:DEFUN REMOVE-PLIST-KEYS (KEYS PLIST) "Remove a list of keys from a plist" (LOOP* :FOR (K V) :ON PLIST :BY (COMMON-LISP:FUNCTION COMMON-LISP:CDDR) :UNLESS (COMMON-LISP:MEMBER K KEYS) :APPEND (COMMON-LISP:LIST K V))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN EMPTYP (X) "Predicate that is true for an empty sequence" (COMMON-LISP:OR (COMMON-LISP:NULL X) (COMMON-LISP:AND (COMMON-LISP:VECTORP X) (COMMON-LISP:ZEROP (COMMON-LISP:LENGTH X))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER +CHARACTER-TYPES+ #(COMMON-LISP:CHARACTER)) (COMMON-LISP:DEFPARAMETER +MAX-CHARACTER-TYPE-INDEX+ (COMMON-LISP:1- (COMMON-LISP:LENGTH +CHARACTER-TYPES+))) (COMMON-LISP:DEFCONSTANT +NON-BASE-CHARS-EXIST-P+ (COMMON-LISP:PLUSP +MAX-CHARACTER-TYPE-INDEX+)) (COMMON-LISP:WHEN +NON-BASE-CHARS-EXIST-P+ (COMMON-LISP:PUSHNEW :NON-BASE-CHARS-EXIST-P COMMON-LISP:*FEATURES*)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CHARACTER-TYPE-INDEX (X) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE X)) 0))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN BASE-STRING-P (COMMON-LISP:STRING) "Does the STRING only contain BASE-CHARs?" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:STRING)) (COMMON-LISP:AND)) (COMMON-LISP:DEFUN STRINGS-COMMON-ELEMENT-TYPE (STRINGS) "What least subtype of CHARACTER can contain all the elements of all the STRINGS?" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE STRINGS)) (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) (COMMON-LISP:DEFUN REDUCE/STRCAT (STRINGS COMMON-LISP:&KEY KEY START END) "Reduce a list as if by STRCAT, accepting KEY START and END keywords like REDUCE.
     [java] NIL is interpreted as an empty string. A character is interpreted as a string of length one." (COMMON-LISP:WHEN (COMMON-LISP:OR START END) (COMMON-LISP:SETF STRINGS (COMMON-LISP:SUBSEQ STRINGS START END))) (COMMON-LISP:WHEN KEY (COMMON-LISP:SETF STRINGS (COMMON-LISP:MAPCAR KEY STRINGS))) (COMMON-LISP:LOOP :WITH OUTPUT COMMON-LISP:= (COMMON-LISP:MAKE-STRING (COMMON-LISP:LOOP :FOR S :IN STRINGS :SUM (COMMON-LISP:IF (COMMON-LISP:CHARACTERP S) 1 (COMMON-LISP:LENGTH S))) :ELEMENT-TYPE (STRINGS-COMMON-ELEMENT-TYPE STRINGS)) :WITH POS COMMON-LISP:= 0 :FOR INPUT :IN STRINGS :DO (COMMON-LISP:ETYPECASE INPUT (COMMON-LISP:NULL) (COMMON-LISP:CHARACTER (COMMON-LISP:SETF (COMMON-LISP:CHAR OUTPUT POS) INPUT) (COMMON-LISP:INCF POS)) (COMMON-LISP:STRING (COMMON-LISP:REPLACE OUTPUT INPUT :START1 POS) (COMMON-LISP:INCF POS (COMMON-LISP:LENGTH INPUT)))) :FINALLY (COMMON-LISP:RETURN OUTPUT))) (COMMON-LISP:DEFUN STRCAT (COMMON-LISP:&REST STRINGS) "Concatenate strings.
     [java] NIL is interpreted as an empty string, a character as a string of length one." (REDUCE/STRCAT STRINGS)) (COMMON-LISP:DEFUN FIRST-CHAR (S) "Return the first character of a non-empty string S, or NIL" (COMMON-LISP:AND (COMMON-LISP:STRINGP S) (COMMON-LISP:PLUSP (COMMON-LISP:LENGTH S)) (COMMON-LISP:CHAR S 0))) (COMMON-LISP:DEFUN LAST-CHAR (S) "Return the last character of a non-empty string S, or NIL" (COMMON-LISP:AND (COMMON-LISP:STRINGP S) (COMMON-LISP:PLUSP (COMMON-LISP:LENGTH S)) (COMMON-LISP:CHAR S (COMMON-LISP:1- (COMMON-LISP:LENGTH S))))) (COMMON-LISP:DEFUN SPLIT-STRING (COMMON-LISP:STRING COMMON-LISP:&KEY COMMON-LISP:MAX (SEPARATOR (COMMON-LISP:QUOTE (#\  #\Tab)))) "Split STRING into a list of components separated by
     [java] any of the characters in the sequence SEPARATOR.
     [java] If MAX is specified, then no more than max(1,MAX) components will be returned,
     [java] starting the separation from the end, e.g. when called with arguments
     [java]  \"a.b.c.d.e\" :max 3 :separator \".\" it will return (\"a.b.c\" \"d\" \"e\")." (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:LET ((COMMON-LISP:LIST COMMON-LISP:NIL) (WORDS 0) (END (COMMON-LISP:LENGTH COMMON-LISP:STRING))) (COMMON-LISP:WHEN (COMMON-LISP:ZEROP END) (COMMON-LISP:RETURN COMMON-LISP:NIL)) (COMMON-LISP:FLET ((SEPARATORP (COMMON-LISP:CHAR) (COMMON-LISP:FIND COMMON-LISP:CHAR SEPARATOR)) (DONE COMMON-LISP:NIL (COMMON-LISP:RETURN (COMMON-LISP:CONS (COMMON-LISP:SUBSEQ COMMON-LISP:STRING 0 END) COMMON-LISP:LIST)))) (COMMON-LISP:LOOP :FOR START COMMON-LISP:= (COMMON-LISP:IF (COMMON-LISP:AND COMMON-LISP:MAX (COMMON-LISP:>= WORDS (COMMON-LISP:1- COMMON-LISP:MAX))) (DONE) (COMMON-LISP:POSITION-IF (COMMON-LISP:FUNCTION SEPARATORP) COMMON-LISP:STRING :END END :FROM-END COMMON-LISP:T)) :DO (COMMON-LISP:WHEN (COMMON-LISP:NULL START) (DONE)) (COMMON-LISP:PUSH (COMMON-LISP:SUBSEQ COMMON-LISP:STRING (COMMON-LISP:1+ START) END) COMMON-LISP:LIST) (COMMON-LISP:INCF WORDS) (COMMON-LISP:SETF END START)))))) (COMMON-LISP:DEFUN STRING-PREFIX-P (PREFIX COMMON-LISP:STRING) "Does STRING begin with PREFIX?" (COMMON-LISP:LET* ((X (COMMON-LISP:STRING PREFIX)) (Y (COMMON-LISP:STRING COMMON-LISP:STRING)) (LX (COMMON-LISP:LENGTH X)) (LY (COMMON-LISP:LENGTH Y))) (COMMON-LISP:AND (COMMON-LISP:<= LX LY) (COMMON-LISP:STRING= X Y :END2 LX)))) (COMMON-LISP:DEFUN STRING-SUFFIX-P (COMMON-LISP:STRING SUFFIX) "Does STRING end with SUFFIX?" (COMMON-LISP:LET* ((X (COMMON-LISP:STRING COMMON-LISP:STRING)) (Y (COMMON-LISP:STRING SUFFIX)) (LX (COMMON-LISP:LENGTH X)) (LY (COMMON-LISP:LENGTH Y))) (COMMON-LISP:AND (COMMON-LISP:<= LY LX) (COMMON-LISP:STRING= X Y :START1 (COMMON-LISP:- LX LY))))) (COMMON-LISP:DEFUN STRING-ENCLOSED-P (PREFIX COMMON-LISP:STRING SUFFIX) "Does STRING begin with PREFIX and end with SUFFIX?" (COMMON-LISP:AND (STRING-PREFIX-P PREFIX COMMON-LISP:STRING) (STRING-SUFFIX-P COMMON-LISP:STRING SUFFIX))) (COMMON-LISP:DEFVAR +CR+ (COMMON-LISP:COERCE #(#\Return) (COMMON-LISP:QUOTE COMMON-LISP:STRING))) (COMMON-LISP:DEFVAR +LF+ (COMMON-LISP:COERCE #(#\Newline) (COMMON-LISP:QUOTE COMMON-LISP:STRING))) (COMMON-LISP:DEFVAR +CRLF+ (COMMON-LISP:COERCE #(#\Return #\Newline) (COMMON-LISP:QUOTE COMMON-LISP:STRING))) (COMMON-LISP:DEFUN STRIPLN (X) "Strip a string X from any ending CR, LF or CRLF.
     [java] Return two values, the stripped string and the ending that was stripped,
     [java] or the original value and NIL if no stripping took place.
     [java] Since our STRCAT accepts NIL as empty string designator,
     [java] the two results passed to STRCAT always reconstitute the original string" (COMMON-LISP:CHECK-TYPE X COMMON-LISP:STRING) (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:FLET ((C (END) (COMMON-LISP:WHEN (STRING-SUFFIX-P X END) (COMMON-LISP:RETURN (COMMON-LISP:VALUES (COMMON-LISP:SUBSEQ X 0 (COMMON-LISP:- (COMMON-LISP:LENGTH X) (COMMON-LISP:LENGTH END))) END))))) (COMMON-LISP:WHEN X (C +CRLF+) (C +LF+) (C +CR+) (COMMON-LISP:VALUES X COMMON-LISP:NIL))))) (COMMON-LISP:DEFUN STANDARD-CASE-SYMBOL-NAME (NAME-DESIGNATOR) "Given a NAME-DESIGNATOR for a symbol, if it is a symbol, convert it to a string using STRING;
     [java] if it is a string, use STRING-UPCASE on an ANSI CL platform, or STRING on a so-called \"modern\"
     [java] platform such as Allegro with modern syntax." (COMMON-LISP:CHECK-TYPE NAME-DESIGNATOR (COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:SYMBOL)) (COMMON-LISP:COND ((COMMON-LISP:OR (COMMON-LISP:SYMBOLP NAME-DESIGNATOR)) (COMMON-LISP:STRING NAME-DESIGNATOR)) (COMMON-LISP:T (COMMON-LISP:STRING-UPCASE NAME-DESIGNATOR)))) (COMMON-LISP:DEFUN FIND-STANDARD-CASE-SYMBOL (NAME-DESIGNATOR PACKAGE-DESIGNATOR COMMON-LISP:&OPTIONAL (COMMON-LISP:ERROR COMMON-LISP:T)) "Find a symbol designated by NAME-DESIGNATOR in a package designated by PACKAGE-DESIGNATOR,
     [java] where STANDARD-CASE-SYMBOL-NAME is used to transform them if these designators are strings.
     [java] If optional ERROR argument is NIL, return NIL instead of an error when the symbol is not found." (FIND-SYMBOL* (STANDARD-CASE-SYMBOL-NAME NAME-DESIGNATOR) (COMMON-LISP:ETYPECASE PACKAGE-DESIGNATOR ((COMMON-LISP:OR COMMON-LISP:PACKAGE COMMON-LISP:SYMBOL) PACKAGE-DESIGNATOR) (COMMON-LISP:STRING (STANDARD-CASE-SYMBOL-NAME PACKAGE-DESIGNATOR))) COMMON-LISP:ERROR)))
     [java] ; (COMMON-LISP:DEFTYPE STAMP COMMON-LISP:NIL (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:REAL COMMON-LISP:BOOLEAN)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN STAMP< (X Y) (COMMON-LISP:ETYPECASE X (COMMON-LISP:NULL (COMMON-LISP:AND Y COMMON-LISP:T)) ((COMMON-LISP:EQL COMMON-LISP:T) COMMON-LISP:NIL) (COMMON-LISP:REAL (COMMON-LISP:ETYPECASE Y (COMMON-LISP:NULL COMMON-LISP:NIL) ((COMMON-LISP:EQL COMMON-LISP:T) COMMON-LISP:T) (COMMON-LISP:REAL (COMMON-LISP:< X Y)))))) (COMMON-LISP:DEFUN STAMPS< (COMMON-LISP:LIST) (COMMON-LISP:LOOP :FOR Y :IN COMMON-LISP:LIST :FOR X COMMON-LISP:= COMMON-LISP:NIL :THEN Y :ALWAYS (STAMP< X Y))) (COMMON-LISP:DEFUN STAMP*< (COMMON-LISP:&REST COMMON-LISP:LIST) (STAMPS< COMMON-LISP:LIST)) (COMMON-LISP:DEFUN STAMP<= (X Y) (COMMON-LISP:NOT (STAMP< Y X))) (COMMON-LISP:DEFUN EARLIER-STAMP (X Y) (COMMON-LISP:IF (STAMP< X Y) X Y)) (COMMON-LISP:DEFUN STAMPS-EARLIEST (COMMON-LISP:LIST) (COMMON-LISP:REDUCE (COMMON-LISP:QUOTE EARLIER-STAMP) COMMON-LISP:LIST :INITIAL-VALUE COMMON-LISP:T)) (COMMON-LISP:DEFUN EARLIEST-STAMP (COMMON-LISP:&REST COMMON-LISP:LIST) (STAMPS-EARLIEST COMMON-LISP:LIST)) (COMMON-LISP:DEFUN LATER-STAMP (X Y) (COMMON-LISP:IF (STAMP< X Y) Y X)) (COMMON-LISP:DEFUN STAMPS-LATEST (COMMON-LISP:LIST) (COMMON-LISP:REDUCE (COMMON-LISP:QUOTE LATER-STAMP) COMMON-LISP:LIST :INITIAL-VALUE COMMON-LISP:NIL)) (COMMON-LISP:DEFUN LATEST-STAMP (COMMON-LISP:&REST COMMON-LISP:LIST) (STAMPS-LATEST COMMON-LISP:LIST)) (COMMON-LISP:DEFINE-MODIFY-MACRO LATEST-STAMP-F (COMMON-LISP:&REST STAMPS) LATEST-STAMP))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ENSURE-FUNCTION (FUN COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL)) "Coerce the object FUN into a function.
     [java]
     [java] If FUN is a FUNCTION, return it.
     [java] If the FUN is a non-sequence literal constant, return constantly that,
     [java] i.e. for a boolean keyword character number or pathname.
     [java] Otherwise if FUN is a non-literally constant symbol, return its FDEFINITION.
     [java] If FUN is a CONS, return the function that applies its CAR
     [java] to the appended list of the rest of its CDR and the arguments,
     [java] unless the CAR is LAMBDA, in which case the expression is evaluated.
     [java] If FUN is a string, READ a form from it in the specified PACKAGE (default: CL)
     [java] and EVAL that in a (FUNCTION ...) context." (COMMON-LISP:ETYPECASE FUN (COMMON-LISP:FUNCTION FUN) ((COMMON-LISP:OR COMMON-LISP:BOOLEAN COMMON-LISP:KEYWORD COMMON-LISP:CHARACTER COMMON-LISP:NUMBER COMMON-LISP:PATHNAME) (COMMON-LISP:CONSTANTLY FUN)) (COMMON-LISP:HASH-TABLE (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:GETHASH X FUN)))) (COMMON-LISP:SYMBOL (COMMON-LISP:FDEFINITION FUN)) (COMMON-LISP:CONS (COMMON-LISP:IF (COMMON-LISP:EQ (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (COMMON-LISP:CAR FUN)) (COMMON-LISP:EVAL FUN) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (COMMON-LISP:&REST ARGS) (COMMON-LISP:APPLY (COMMON-LISP:CAR FUN) (COMMON-LISP:APPEND (COMMON-LISP:CDR FUN) ARGS)))))) (COMMON-LISP:STRING (COMMON-LISP:EVAL (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (COMMON-LISP:WITH-STANDARD-IO-SYNTAX (COMMON-LISP:LET ((COMMON-LISP:*PACKAGE* (COMMON-LISP:FIND-PACKAGE COMMON-LISP:PACKAGE))) (COMMON-LISP:READ-FROM-STRING FUN)))))))) (COMMON-LISP:DEFUN ACCESS-AT (OBJECT AT) "Given an OBJECT and an AT specifier, list of successive accessors,
     [java] call each accessor on the result of the previous calls.
     [java] An accessor may be an integer, meaning a call to ELT,
     [java] a keyword, meaning a call to GETF,
     [java] NIL, meaning identity,
     [java] a function or other symbol, meaning itself,
     [java] or a list of a function designator and arguments, interpreted as per ENSURE-FUNCTION.
     [java] As a degenerate case, the AT specifier may be an atom of a single such accessor
     [java] instead of a list." (COMMON-LISP:FLET ((ACCESS (OBJECT ACCESSOR) (COMMON-LISP:ETYPECASE ACCESSOR (COMMON-LISP:FUNCTION (COMMON-LISP:FUNCALL ACCESSOR OBJECT)) (COMMON-LISP:INTEGER (COMMON-LISP:ELT OBJECT ACCESSOR)) (COMMON-LISP:KEYWORD (COMMON-LISP:GETF OBJECT ACCESSOR)) (COMMON-LISP:NULL OBJECT) (COMMON-LISP:SYMBOL (COMMON-LISP:FUNCALL ACCESSOR OBJECT)) (COMMON-LISP:CONS (COMMON-LISP:FUNCALL (ENSURE-FUNCTION ACCESSOR) OBJECT))))) (COMMON-LISP:IF (COMMON-LISP:LISTP AT) (COMMON-LISP:DOLIST (ACCESSOR AT OBJECT) (COMMON-LISP:SETF OBJECT (ACCESS OBJECT ACCESSOR))) (ACCESS OBJECT AT)))) (COMMON-LISP:DEFUN ACCESS-AT-COUNT (AT) "From an AT specification, extract a COUNT of maximum number
     [java] of sub-objects to read as per ACCESS-AT" (COMMON-LISP:COND ((COMMON-LISP:INTEGERP AT) (COMMON-LISP:1+ AT)) ((COMMON-LISP:AND (COMMON-LISP:CONSP AT) (COMMON-LISP:INTEGERP (COMMON-LISP:FIRST AT))) (COMMON-LISP:1+ (COMMON-LISP:FIRST AT))))) (COMMON-LISP:DEFUN CALL-FUNCTION (FUNCTION-SPEC COMMON-LISP:&REST ARGUMENTS) "Call the function designated by FUNCTION-SPEC as per ENSURE-FUNCTION,
     [java] with the given ARGUMENTS" (COMMON-LISP:APPLY (ENSURE-FUNCTION FUNCTION-SPEC) ARGUMENTS)) (COMMON-LISP:DEFUN CALL-FUNCTIONS (FUNCTION-SPECS) "For each function in the list FUNCTION-SPECS, in order, call the function as per CALL-FUNCTION" (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:QUOTE CALL-FUNCTION) FUNCTION-SPECS)) (COMMON-LISP:DEFUN REGISTER-HOOK-FUNCTION (COMMON-LISP:VARIABLE HOOK COMMON-LISP:&OPTIONAL CALL-NOW-P) "Push the HOOK function (a designator as per ENSURE-FUNCTION) onto the hook VARIABLE.
     [java] When CALL-NOW-P is true, also call the function immediately." (COMMON-LISP:PUSHNEW HOOK (COMMON-LISP:SYMBOL-VALUE COMMON-LISP:VARIABLE) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) (COMMON-LISP:WHEN CALL-NOW-P (CALL-FUNCTION HOOK))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COERCE-CLASS (COMMON-LISP:CLASS COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL) (SUPER COMMON-LISP:T) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE COMMON-LISP:ERROR))) "Coerce CLASS to a class that is subclass of SUPER if specified,
     [java] or invoke ERROR handler as per CALL-FUNCTION.
     [java]
     [java] A keyword designates the name a symbol, which when found in either PACKAGE, designates a class.
     [java] -- for backward compatibility, *PACKAGE* is also accepted for now, but this may go in the future.
     [java] A string is read as a symbol while in PACKAGE, the symbol designates a class.
     [java]
     [java] A class object designates itself.
     [java] NIL designates itself (no class).
     [java] A symbol otherwise designates a class by name." (COMMON-LISP:LET* ((NORMALIZED (COMMON-LISP:TYPECASE COMMON-LISP:CLASS (COMMON-LISP:KEYWORD (COMMON-LISP:OR (FIND-SYMBOL* COMMON-LISP:CLASS COMMON-LISP:PACKAGE COMMON-LISP:NIL) (FIND-SYMBOL* COMMON-LISP:CLASS COMMON-LISP:*PACKAGE* COMMON-LISP:NIL))) (COMMON-LISP:STRING (SYMBOL-CALL :UIOP :SAFE-READ-FROM-STRING COMMON-LISP:CLASS :PACKAGE COMMON-LISP:PACKAGE)) (COMMON-LISP:T COMMON-LISP:CLASS))) (FOUND (COMMON-LISP:ETYPECASE NORMALIZED ((COMMON-LISP:OR COMMON-LISP:STANDARD-CLASS COMMON-LISP:BUILT-IN-CLASS) NORMALIZED) ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:KEYWORD) COMMON-LISP:NIL) (COMMON-LISP:SYMBOL (COMMON-LISP:FIND-CLASS NORMALIZED COMMON-LISP:NIL COMMON-LISP:NIL))))) (COMMON-LISP:OR (COMMON-LISP:AND FOUND (COMMON-LISP:OR (COMMON-LISP:EQ SUPER COMMON-LISP:T) (COMMON-LISP:SUBTYPEP FOUND SUPER)) FOUND) (CALL-FUNCTION COMMON-LISP:ERROR "Can't coerce ~S to a ~:[class~;subclass of ~:*~S~]" COMMON-LISP:CLASS SUPER)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ENSURE-GETHASH (KEY TABLE DEFAULT) "Lookup the TABLE for a KEY as by GETHASH, but if not present,
     [java] call the (possibly constant) function designated by DEFAULT as per CALL-FUNCTION,
     [java] set the corresponding entry to the result in the table.
     [java] Return two values: the entry after its optional computation, and whether it was found" (COMMON-LISP:MULTIPLE-VALUE-BIND (VALUE FOUNDP) (COMMON-LISP:GETHASH KEY TABLE) (COMMON-LISP:VALUES (COMMON-LISP:IF FOUNDP VALUE (COMMON-LISP:SETF (COMMON-LISP:GETHASH KEY TABLE) (CALL-FUNCTION DEFAULT))) FOUNDP))) (COMMON-LISP:DEFUN LIST-TO-HASH-SET (COMMON-LISP:LIST COMMON-LISP:&AUX (H (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) "Convert a LIST into hash-table that has the same elements when viewed as a set,
     [java] up to the given equality TEST" (COMMON-LISP:DOLIST (X COMMON-LISP:LIST H) (COMMON-LISP:SETF (COMMON-LISP:GETHASH X H) COMMON-LISP:T))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN UNPARSE-VERSION (VERSION-LIST) (COMMON-LISP:FORMAT COMMON-LISP:NIL "~{~D~^.~}" VERSION-LIST)) (COMMON-LISP:DEFUN PARSE-VERSION (VERSION-STRING COMMON-LISP:&OPTIONAL ON-ERROR) "Parse a VERSION-STRING as a series of natural integers separated by dots.
     [java] Return a (non-null) list of integers if the string is valid;
     [java] otherwise return NIL.
     [java]
     [java] When invalid, ON-ERROR is called as per CALL-FUNCTION before to return NIL,
     [java] with format arguments explaining why the version is invalid.
     [java] ON-ERROR is also called if the version is not canonical
     [java] in that it doesn't print back to itself, but the list is returned anyway." (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:UNLESS (COMMON-LISP:STRINGP VERSION-STRING) (CALL-FUNCTION ON-ERROR "~S: ~S is not a string" (COMMON-LISP:QUOTE PARSE-VERSION) VERSION-STRING) (COMMON-LISP:RETURN)) (COMMON-LISP:UNLESS (COMMON-LISP:LOOP :FOR PREV COMMON-LISP:= COMMON-LISP:NIL :THEN C :FOR C :ACROSS VERSION-STRING :ALWAYS (COMMON-LISP:OR (COMMON-LISP:DIGIT-CHAR-P C) (COMMON-LISP:AND (COMMON-LISP:EQL C #\.) PREV (COMMON-LISP:NOT (COMMON-LISP:EQL PREV #\.)))) :FINALLY (COMMON-LISP:RETURN (COMMON-LISP:AND C (COMMON-LISP:DIGIT-CHAR-P C)))) (CALL-FUNCTION ON-ERROR "~S: ~S doesn't follow asdf version numbering convention" (COMMON-LISP:QUOTE PARSE-VERSION) VERSION-STRING) (COMMON-LISP:RETURN)) (COMMON-LISP:LET* ((VERSION-LIST (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION COMMON-LISP:PARSE-INTEGER) (SPLIT-STRING VERSION-STRING :SEPARATOR "."))) (NORMALIZED-VERSION (UNPARSE-VERSION VERSION-LIST))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL VERSION-STRING NORMALIZED-VERSION) (CALL-FUNCTION ON-ERROR "~S: ~S contains leading zeros" (COMMON-LISP:QUOTE PARSE-VERSION) VERSION-STRING)) VERSION-LIST))) (COMMON-LISP:DEFUN LEXICOGRAPHIC< (COMMON-LISP:< X Y) (COMMON-LISP:COND ((COMMON-LISP:NULL Y) COMMON-LISP:NIL) ((COMMON-LISP:NULL X) COMMON-LISP:T) ((COMMON-LISP:FUNCALL COMMON-LISP:< (COMMON-LISP:CAR X) (COMMON-LISP:CAR Y)) COMMON-LISP:T) ((COMMON-LISP:FUNCALL COMMON-LISP:< (COMMON-LISP:CAR Y) (COMMON-LISP:CAR X)) COMMON-LISP:NIL) (COMMON-LISP:T (LEXICOGRAPHIC< COMMON-LISP:< (COMMON-LISP:CDR X) (COMMON-LISP:CDR Y))))) (COMMON-LISP:DEFUN LEXICOGRAPHIC<= (COMMON-LISP:< X Y) (COMMON-LISP:NOT (LEXICOGRAPHIC< COMMON-LISP:< Y X))) (COMMON-LISP:DEFUN VERSION< (VERSION1 VERSION2) (COMMON-LISP:LET ((V1 (PARSE-VERSION VERSION1 COMMON-LISP:NIL)) (V2 (PARSE-VERSION VERSION2 COMMON-LISP:NIL))) (LEXICOGRAPHIC< (COMMON-LISP:QUOTE COMMON-LISP:<) V1 V2))) (COMMON-LISP:DEFUN VERSION<= (VERSION1 VERSION2) (COMMON-LISP:NOT (VERSION< VERSION2 VERSION1))) (COMMON-LISP:DEFUN VERSION-COMPATIBLE-P (PROVIDED-VERSION REQUIRED-VERSION) "Is the provided version a compatible substitution for the required-version?
     [java] If major versions differ, it's not compatible.
     [java] If they are equal, then any later version is compatible,
     [java] with later being determined by a lexicographical comparison of minor numbers." (COMMON-LISP:LET ((X (PARSE-VERSION PROVIDED-VERSION COMMON-LISP:NIL)) (Y (PARSE-VERSION REQUIRED-VERSION COMMON-LISP:NIL))) (COMMON-LISP:AND X Y (COMMON-LISP:= (COMMON-LISP:CAR X) (COMMON-LISP:CAR Y)) (LEXICOGRAPHIC<= (COMMON-LISP:QUOTE COMMON-LISP:<) (COMMON-LISP:CDR Y) (COMMON-LISP:CDR X))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER +SIMPLE-CONDITION-FORMAT-CONTROL-SLOT+ (COMMON-LISP:QUOTE SYSTEM::FORMAT-CONTROL) "Name of the slot for FORMAT-CONTROL in simple-condition") (COMMON-LISP:DEFUN MATCH-CONDITION-P (X COMMON-LISP:CONDITION) "Compare received CONDITION to some pattern X:
     [java] a symbol naming a condition class,
     [java] a simple vector of length 2, arguments to find-symbol* with result as above,
     [java] or a string describing the format-control of a simple-condition." (COMMON-LISP:ETYPECASE X (COMMON-LISP:SYMBOL (COMMON-LISP:TYPEP COMMON-LISP:CONDITION X)) ((COMMON-LISP:SIMPLE-VECTOR 2) (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:TYPEP COMMON-LISP:CONDITION (FIND-SYMBOL* (COMMON-LISP:SVREF X 0) (COMMON-LISP:SVREF X 1) COMMON-LISP:NIL)))) (COMMON-LISP:FUNCTION (COMMON-LISP:FUNCALL X COMMON-LISP:CONDITION)) (COMMON-LISP:STRING (COMMON-LISP:AND (COMMON-LISP:TYPEP COMMON-LISP:CONDITION (COMMON-LISP:QUOTE COMMON-LISP:SIMPLE-CONDITION)) (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:EQUAL (COMMON-LISP:SIMPLE-CONDITION-FORMAT-CONTROL COMMON-LISP:CONDITION) X)))))) (COMMON-LISP:DEFUN MATCH-ANY-CONDITION-P (COMMON-LISP:CONDITION CONDITIONS) "match CONDITION against any of the patterns of CONDITIONS supplied" (COMMON-LISP:LOOP :FOR X :IN CONDITIONS :THEREIS (MATCH-CONDITION-P X COMMON-LISP:CONDITION))) (COMMON-LISP:DEFUN CALL-WITH-MUFFLED-CONDITIONS (THUNK CONDITIONS) "calls the THUNK in a context where the CONDITIONS are muffled" (COMMON-LISP:HANDLER-BIND ((COMMON-LISP:T (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:WHEN (MATCH-ANY-CONDITION-P C CONDITIONS) (COMMON-LISP:MUFFLE-WARNING C)))))) (COMMON-LISP:FUNCALL THUNK))) (COMMON-LISP:DEFMACRO WITH-MUFFLED-CONDITIONS ((CONDITIONS) COMMON-LISP:&BODY BODY) "Shorthand syntax for CALL-WITH-MUFFLED-CONDITIONS" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-MUFFLED-CONDITIONS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)) CONDITIONS)))
     [java] ; (DEFINE-PACKAGE :UIOP/OS (:NICKNAMES :ASDF/OS) (:RECYCLE :UIOP/OS :ASDF/OS :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY) (:EXPORT #:FEATUREP #:OS-UNIX-P #:OS-MACOSX-P #:OS-WINDOWS-P #:OS-GENERA-P #:DETECT-OS #:OS-COND #:GETENV #:GETENVP #:IMPLEMENTATION-IDENTIFIER #:IMPLEMENTATION-TYPE #:*IMPLEMENTATION-TYPE* #:OPERATING-SYSTEM #:ARCHITECTURE #:LISP-VERSION-STRING #:HOSTNAME #:GETCWD #:CHDIR #:READ-NULL-TERMINATED-STRING #:READ-LITTLE-ENDIAN #:PARSE-FILE-LOCATION-INFO #:PARSE-WINDOWS-SHORTCUT))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/OS)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN FEATUREP (X COMMON-LISP:&OPTIONAL (COMMON-LISP:*FEATURES* COMMON-LISP:*FEATURES*)) "Checks whether a feature expression X is true with respect to the *FEATURES* set,
     [java] as per the CLHS standard for #+ and #-. Beware that just like the CLHS,
     [java] we assume symbols from the KEYWORD package are used, but that unless you're using #+/#-
     [java] your reader will not have magically used the KEYWORD package, so you need specify
     [java] keywords explicitly." (COMMON-LISP:COND ((COMMON-LISP:ATOM X) (COMMON-LISP:AND (COMMON-LISP:MEMBER X COMMON-LISP:*FEATURES*) COMMON-LISP:T)) ((COMMON-LISP:EQ :NOT (COMMON-LISP:CAR X)) (COMMON-LISP:ASSERT (COMMON-LISP:NULL (COMMON-LISP:CDDR X))) (COMMON-LISP:NOT (FEATUREP (COMMON-LISP:CADR X)))) ((COMMON-LISP:EQ :OR (COMMON-LISP:CAR X)) (COMMON-LISP:SOME (COMMON-LISP:FUNCTION FEATUREP) (COMMON-LISP:CDR X))) ((COMMON-LISP:EQ :AND (COMMON-LISP:CAR X)) (COMMON-LISP:EVERY (COMMON-LISP:FUNCTION FEATUREP) (COMMON-LISP:CDR X))) (COMMON-LISP:T (COMMON-LISP:ERROR "Malformed feature specification ~S" X)))) (COMMON-LISP:DEFUN OS-MACOSX-P COMMON-LISP:NIL "Is the underlying operating system MacOS X?" (FEATUREP (COMMON-LISP:QUOTE (:OR :DARWIN (:AND :ALLEGRO :MACOSX) (:AND :CLISP :MACOS))))) (COMMON-LISP:DEFUN OS-UNIX-P COMMON-LISP:NIL "Is the underlying operating system some Unix variant?" (COMMON-LISP:OR (FEATUREP (COMMON-LISP:QUOTE (:OR :UNIX :CYGWIN))) (OS-MACOSX-P))) (COMMON-LISP:DEFUN OS-WINDOWS-P COMMON-LISP:NIL "Is the underlying operating system Microsoft Windows?" (COMMON-LISP:AND (COMMON-LISP:NOT (OS-UNIX-P)) (FEATUREP (COMMON-LISP:QUOTE (:OR :WIN32 :WINDOWS :MSWINDOWS :MINGW32 :MINGW64))))) (COMMON-LISP:DEFUN OS-GENERA-P COMMON-LISP:NIL "Is the underlying operating system Genera (running on a Symbolics Lisp Machine)?" (FEATUREP :GENERA)) (COMMON-LISP:DEFUN OS-OLDMAC-P COMMON-LISP:NIL "Is the underlying operating system an (emulated?) MacOS 9 or earlier?" (FEATUREP :MCL)) (COMMON-LISP:DEFUN DETECT-OS COMMON-LISP:NIL "Detects the current operating system. Only needs be run at compile-time,
     [java] except on ABCL where it might change between FASL compilation and runtime." (UIOP/COMMON-LISP::LOOP* :WITH O :FOR (FEATURE . DETECT) :IN (COMMON-LISP:QUOTE ((:OS-UNIX . OS-UNIX-P) (:OS-MACOSX . OS-MACOSX-P) (:OS-WINDOWS . OS-WINDOWS-P) (:GENERA . OS-GENERA-P) (:OS-OLDMAC . OS-OLDMAC-P))) :WHEN (COMMON-LISP:AND (COMMON-LISP:OR (COMMON-LISP:NOT O) (COMMON-LISP:EQ FEATURE :OS-MACOSX)) (COMMON-LISP:FUNCALL DETECT)) :DO (COMMON-LISP:SETF O FEATURE) (COMMON-LISP:PUSHNEW FEATURE COMMON-LISP:*FEATURES*) :ELSE :DO (COMMON-LISP:SETF COMMON-LISP:*FEATURES* (COMMON-LISP:REMOVE FEATURE COMMON-LISP:*FEATURES*)) :FINALLY (COMMON-LISP:RETURN (COMMON-LISP:OR O (COMMON-LISP:ERROR "Congratulations for trying ASDF on an operating system~%~
     [java] that is neither Unix, nor Windows, nor Genera, nor even old MacOS.~%Now you port it."))))) (COMMON-LISP:DEFMACRO OS-COND (COMMON-LISP:&REST CLAUSES) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:COND) CLAUSES)) (DETECT-OS))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN GETENV (X) "Query the environment, as in C getenv.
     [java] Beware: may return empty string if a variable is present but empty;
     [java] use getenvp to return NIL in such a case." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE X)) (EXTENSIONS:GETENV X)) (COMMON-LISP:DEFSETF GETENV (X) (VAL) "Set an environment variable." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE X VAL)) (COMMON-LISP:QUOTE (COMMON-LISP:ERROR "~S ~S is not supported on your implementation" (COMMON-LISP:QUOTE COMMON-LISP:SETF) (COMMON-LISP:QUOTE GETENV)))) (COMMON-LISP:DEFUN GETENVP (X) "Predicate that is true if the named variable is present in the libc environment,
     [java] then returning the non-empty string value of the variable" (COMMON-LISP:LET ((G (GETENV X))) (COMMON-LISP:AND (COMMON-LISP:NOT (EMPTYP G)) G))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN FIRST-FEATURE (FEATURE-SETS) "A helper for various feature detection functions" (COMMON-LISP:DOLIST (X FEATURE-SETS) (COMMON-LISP:MULTIPLE-VALUE-BIND (SHORT LONG FEATURE-EXPR) (COMMON-LISP:IF (COMMON-LISP:CONSP X) (COMMON-LISP:VALUES (COMMON-LISP:FIRST X) (COMMON-LISP:SECOND X) (COMMON-LISP:CONS :OR (COMMON-LISP:REST X))) (COMMON-LISP:VALUES X X X)) (COMMON-LISP:WHEN (FEATUREP FEATURE-EXPR) (COMMON-LISP:RETURN (COMMON-LISP:VALUES SHORT LONG)))))) (COMMON-LISP:DEFUN IMPLEMENTATION-TYPE COMMON-LISP:NIL "The type of Lisp implementation used, as a short UIOP-standardized keyword" (FIRST-FEATURE (COMMON-LISP:QUOTE (:ABCL (:ACL :ALLEGRO) (:CCL :CLOZURE) :CLISP (:CORMAN :CORMANLISP) (:CMU :CMUCL :CMU) :CLASP :ECL :GCL (:LWPE :LISPWORKS-PERSONAL-EDITION) (:LW :LISPWORKS) :MCL :MKCL :SBCL :SCL (:SMBX :SYMBOLICS) :XCL)))) (COMMON-LISP:DEFVAR *IMPLEMENTATION-TYPE* (IMPLEMENTATION-TYPE) "The type of Lisp implementation used, as a short UIOP-standardized keyword") (COMMON-LISP:DEFUN OPERATING-SYSTEM COMMON-LISP:NIL "The operating system of the current host" (FIRST-FEATURE (COMMON-LISP:QUOTE (:CYGWIN (:WIN :WINDOWS :MSWINDOWS :WIN32 :MINGW32) (:LINUX :LINUX :LINUX-TARGET) (:MACOSX :MACOSX :DARWIN :DARWIN-TARGET :APPLE) (:SOLARIS :SOLARIS :SUNOS) (:BSD :BSD :FREEBSD :NETBSD :OPENBSD :DRAGONFLY) :UNIX :GENERA)))) (COMMON-LISP:DEFUN ARCHITECTURE COMMON-LISP:NIL "The CPU architecture of the current host" (FIRST-FEATURE (COMMON-LISP:QUOTE ((:X64 :X86-64 :X86_64 :X8664-TARGET :AMD64 (:AND :WORD-SIZE=64 :PC386)) (:X86 :X86 :I386 :I486 :I586 :I686 :PENTIUM3 :PENTIUM4 :PC386 :IAPX386 :X8632-TARGET) (:PPC64 :PPC64 :PPC64-TARGET) (:PPC32 :PPC32 :PPC32-TARGET :PPC :POWERPC) :HPPA64 :HPPA :SPARC64 (:SPARC32 :SPARC32 :SPARC) :MIPSEL :MIPSEB :MIPS :ALPHA (:ARM :ARM :ARM-TARGET) :IMACH (:JAVA :JAVA :JAVA-1.4 :JAVA-1.5 :JAVA-1.6 :JAVA-1.7))))) (COMMON-LISP:DEFUN LISP-VERSION-STRING COMMON-LISP:NIL "return a string that identifies the current Lisp implementation version" (COMMON-LISP:LET ((S (COMMON-LISP:LISP-IMPLEMENTATION-VERSION))) (COMMON-LISP:CAR (COMMON-LISP:LIST (COMMON-LISP:FORMAT COMMON-LISP:NIL "~a-fasl~a" S SYSTEM:*FASL-VERSION*) S)))) (COMMON-LISP:DEFUN IMPLEMENTATION-IDENTIFIER COMMON-LISP:NIL "Return a string that identifies the ABI of the current implementation,
     [java] suitable for use as a directory name to segregate Lisp FASLs, C dynamic libraries, etc." (COMMON-LISP:SUBSTITUTE-IF #\_ (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:FIND X " /:;&^\\|?<>(){}[]$#`'\""))) (COMMON-LISP:FORMAT COMMON-LISP:NIL "~(~a~@{~@[-~a~]~}~)" (COMMON-LISP:OR (IMPLEMENTATION-TYPE) (COMMON-LISP:LISP-IMPLEMENTATION-TYPE)) (COMMON-LISP:OR (LISP-VERSION-STRING) (COMMON-LISP:LISP-IMPLEMENTATION-VERSION)) (COMMON-LISP:OR (OPERATING-SYSTEM) (COMMON-LISP:SOFTWARE-TYPE)) (COMMON-LISP:OR (ARCHITECTURE) (COMMON-LISP:MACHINE-TYPE))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN HOSTNAME COMMON-LISP:NIL "return the hostname of the current host" (COMMON-LISP:MACHINE-INSTANCE)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN GETCWD COMMON-LISP:NIL "Get the current working directory as per POSIX getcwd(3), as a pathname object" (COMMON-LISP:OR (COMMON-LISP:TRUENAME COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*) (COMMON-LISP:ERROR "getcwd not supported on your implementation"))) (COMMON-LISP:DEFUN CHDIR (X) "Change current directory, as per POSIX chdir(2), to a given pathname object" (IF-LET (X (COMMON-LISP:PATHNAME X)) (COMMON-LISP:SETF COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS* (COMMON-LISP:TRUENAME X)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER *LINK-INITIAL-DWORD* 76) (COMMON-LISP:DEFPARAMETER *LINK-GUID* #(1 20 2 0 0 0 0 0 192 0 0 0 0 0 0 70)) (COMMON-LISP:DEFUN READ-NULL-TERMINATED-STRING (S) "Read a null-terminated string from an octet stream S" (COMMON-LISP:WITH-OUTPUT-TO-STRING (OUT) (COMMON-LISP:LOOP :FOR CODE COMMON-LISP:= (COMMON-LISP:READ-BYTE S) :UNTIL (COMMON-LISP:ZEROP CODE) :DO (COMMON-LISP:WRITE-CHAR (COMMON-LISP:CODE-CHAR CODE) OUT)))) (COMMON-LISP:DEFUN READ-LITTLE-ENDIAN (S COMMON-LISP:&OPTIONAL (BYTES 4)) "Read a number in little-endian format from an byte (octet) stream S,
     [java] the number having BYTES octets (defaulting to 4)." (COMMON-LISP:LOOP :FOR I :FROM 0 :BELOW BYTES :SUM (COMMON-LISP:ASH (COMMON-LISP:READ-BYTE S) (COMMON-LISP:* 8 I)))) (COMMON-LISP:DEFUN PARSE-FILE-LOCATION-INFO (S) "helper to parse-windows-shortcut" (COMMON-LISP:LET ((START (COMMON-LISP:FILE-POSITION S)) (TOTAL-LENGTH (READ-LITTLE-ENDIAN S)) (END-OF-HEADER (READ-LITTLE-ENDIAN S)) (FLI-FLAGS (READ-LITTLE-ENDIAN S)) (LOCAL-VOLUME-OFFSET (READ-LITTLE-ENDIAN S)) (LOCAL-OFFSET (READ-LITTLE-ENDIAN S)) (NETWORK-VOLUME-OFFSET (READ-LITTLE-ENDIAN S)) (REMAINING-OFFSET (READ-LITTLE-ENDIAN S))) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE TOTAL-LENGTH END-OF-HEADER LOCAL-VOLUME-OFFSET)) (COMMON-LISP:UNLESS (COMMON-LISP:ZEROP FLI-FLAGS) (COMMON-LISP:COND ((COMMON-LISP:LOGBITP 0 FLI-FLAGS) (COMMON-LISP:FILE-POSITION S (COMMON-LISP:+ START LOCAL-OFFSET))) ((COMMON-LISP:LOGBITP 1 FLI-FLAGS) (COMMON-LISP:FILE-POSITION S (COMMON-LISP:+ START NETWORK-VOLUME-OFFSET 20)))) (STRCAT (READ-NULL-TERMINATED-STRING S) (COMMON-LISP:PROGN (COMMON-LISP:FILE-POSITION S (COMMON-LISP:+ START REMAINING-OFFSET)) (READ-NULL-TERMINATED-STRING S)))))) (COMMON-LISP:DEFUN PARSE-WINDOWS-SHORTCUT (COMMON-LISP:PATHNAME) "From a .lnk windows shortcut, extract the pathname linked to" (COMMON-LISP:WITH-OPEN-FILE (S COMMON-LISP:PATHNAME :ELEMENT-TYPE (COMMON-LISP:QUOTE (COMMON-LISP:UNSIGNED-BYTE 8))) (COMMON-LISP:HANDLER-CASE (COMMON-LISP:WHEN (COMMON-LISP:AND (COMMON-LISP:= (READ-LITTLE-ENDIAN S) *LINK-INITIAL-DWORD*) (COMMON-LISP:LET ((HEADER (COMMON-LISP:MAKE-ARRAY (COMMON-LISP:LENGTH *LINK-GUID*)))) (COMMON-LISP:READ-SEQUENCE HEADER S) (COMMON-LISP:EQUALP HEADER *LINK-GUID*))) (COMMON-LISP:LET ((FLAGS (READ-LITTLE-ENDIAN S))) (COMMON-LISP:FILE-POSITION S 76) (COMMON-LISP:WHEN (COMMON-LISP:LOGBITP 0 FLAGS) (COMMON-LISP:LET ((COMMON-LISP:LENGTH (READ-LITTLE-ENDIAN S 2))) (COMMON-LISP:FILE-POSITION S (COMMON-LISP:+ COMMON-LISP:LENGTH (COMMON-LISP:FILE-POSITION S))))) (COMMON-LISP:COND ((COMMON-LISP:LOGBITP 1 FLAGS) (PARSE-FILE-LOCATION-INFO S)) (COMMON-LISP:T (COMMON-LISP:WHEN (COMMON-LISP:LOGBITP 2 FLAGS) (COMMON-LISP:LET ((COMMON-LISP:LENGTH (READ-LITTLE-ENDIAN S 2))) (COMMON-LISP:FILE-POSITION S (COMMON-LISP:+ COMMON-LISP:LENGTH (COMMON-LISP:FILE-POSITION S))))) (COMMON-LISP:WHEN (COMMON-LISP:LOGBITP 3 FLAGS) (COMMON-LISP:LET* ((COMMON-LISP:LENGTH (READ-LITTLE-ENDIAN S 2)) (BUFFER (COMMON-LISP:MAKE-ARRAY COMMON-LISP:LENGTH))) (COMMON-LISP:READ-SEQUENCE BUFFER S) (COMMON-LISP:MAP (COMMON-LISP:QUOTE COMMON-LISP:STRING) (COMMON-LISP:FUNCTION COMMON-LISP:CODE-CHAR) BUFFER))))))) (COMMON-LISP:END-OF-FILE (C) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE C)) COMMON-LISP:NIL)))))
     [java] ; (DEFINE-PACKAGE :UIOP/PATHNAME (:NICKNAMES :ASDF/PATHNAME) (:RECYCLE :UIOP/PATHNAME :ASDF/PATHNAME :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/OS) (:EXPORT #:NORMALIZE-PATHNAME-DIRECTORY-COMPONENT #:DENORMALIZE-PATHNAME-DIRECTORY-COMPONENT #:MERGE-PATHNAME-DIRECTORY-COMPONENTS #:*UNSPECIFIC-PATHNAME-TYPE* #:MAKE-PATHNAME* #:MAKE-PATHNAME-COMPONENT-LOGICAL #:MAKE-PATHNAME-LOGICAL #:MERGE-PATHNAMES* #:NIL-PATHNAME #:*NIL-PATHNAME* #:WITH-PATHNAME-DEFAULTS #:PATHNAME-EQUAL #:LOGICAL-PATHNAME-P #:PHYSICAL-PATHNAME-P #:PHYSICALIZE-PATHNAME #:ABSOLUTE-PATHNAME-P #:RELATIVE-PATHNAME-P #:HIDDEN-PATHNAME-P #:FILE-PATHNAME-P #:PATHNAME-DIRECTORY-PATHNAME #:PATHNAME-PARENT-DIRECTORY-PATHNAME #:DIRECTORY-PATHNAME-P #:ENSURE-DIRECTORY-PATHNAME #:COMPONENT-NAME-TO-PATHNAME-COMPONENTS #:SPLIT-NAME-TYPE #:PARSE-UNIX-NAMESTRING #:UNIX-NAMESTRING #:SPLIT-UNIX-NAMESTRING-DIRECTORY-COMPONENTS #:SUBPATHNAME #:SUBPATHNAME* #:ENSURE-ABSOLUTE-PATHNAME #:PATHNAME-ROOT #:PATHNAME-HOST-PATHNAME #:SUBPATHP #:ENOUGH-PATHNAME #:WITH-ENOUGH-PATHNAME #:CALL-WITH-ENOUGH-PATHNAME #:ENSURE-PATHNAME #:*WILD* #:*WILD-FILE* #:*WILD-DIRECTORY* #:*WILD-INFERIORS* #:*WILD-PATH* #:WILDEN #:RELATIVIZE-DIRECTORY-COMPONENT #:RELATIVIZE-PATHNAME-DIRECTORY #:DIRECTORY-SEPARATOR-FOR-HOST #:DIRECTORIZE-PATHNAME-HOST-DEVICE #:TRANSLATE-PATHNAME* #:*OUTPUT-TRANSLATION-FUNCTION*))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/PATHNAME)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:DIRECTORY) "Convert the DIRECTORY component from a format usable by the underlying
     [java] implementation's MAKE-PATHNAME and other primitives to a CLHS-standard format
     [java] that is a list and not a string." (COMMON-LISP:COND ((COMMON-LISP:STRINGP COMMON-LISP:DIRECTORY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :ABSOLUTE) COMMON-LISP:DIRECTORY)) ((COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:DIRECTORY) (COMMON-LISP:AND (COMMON-LISP:CONSP COMMON-LISP:DIRECTORY) (COMMON-LISP:MEMBER (COMMON-LISP:FIRST COMMON-LISP:DIRECTORY) (COMMON-LISP:QUOTE (:ABSOLUTE :RELATIVE))))) COMMON-LISP:DIRECTORY) (COMMON-LISP:T (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Unrecognized pathname directory component ~S~@:>") COMMON-LISP:DIRECTORY)))) (COMMON-LISP:DEFUN DENORMALIZE-PATHNAME-DIRECTORY-COMPONENT (DIRECTORY-COMPONENT) "Convert the DIRECTORY-COMPONENT from a CLHS-standard format to a format usable
     [java] by the underlying implementation's MAKE-PATHNAME and other primitives" DIRECTORY-COMPONENT) (COMMON-LISP:DEFUN MERGE-PATHNAME-DIRECTORY-COMPONENTS (SPECIFIED DEFAULTS) "Helper for MERGE-PATHNAMES* that handles directory components" (COMMON-LISP:LET ((COMMON-LISP:DIRECTORY (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT SPECIFIED))) (COMMON-LISP:ECASE (COMMON-LISP:FIRST COMMON-LISP:DIRECTORY) ((COMMON-LISP:NIL) DEFAULTS) (:ABSOLUTE SPECIFIED) (:RELATIVE (COMMON-LISP:LET ((DEFDIR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT DEFAULTS)) (RELDIR (COMMON-LISP:CDR COMMON-LISP:DIRECTORY))) (COMMON-LISP:COND ((COMMON-LISP:NULL DEFDIR) COMMON-LISP:DIRECTORY) ((COMMON-LISP:NOT (COMMON-LISP:EQ :BACK (COMMON-LISP:FIRST RELDIR))) (COMMON-LISP:APPEND DEFDIR RELDIR)) (COMMON-LISP:T (COMMON-LISP:LOOP :WITH DEFABS COMMON-LISP:= (COMMON-LISP:FIRST DEFDIR) :WITH DEFREV COMMON-LISP:= (COMMON-LISP:REVERSE (COMMON-LISP:REST DEFDIR)) :WHILE (COMMON-LISP:AND (COMMON-LISP:EQ :BACK (COMMON-LISP:CAR RELDIR)) (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:EQ :ABSOLUTE DEFABS) (COMMON-LISP:NULL DEFREV)) (COMMON-LISP:STRINGP (COMMON-LISP:CAR DEFREV)))) :DO (COMMON-LISP:POP RELDIR) (COMMON-LISP:POP DEFREV) :FINALLY (COMMON-LISP:RETURN (COMMON-LISP:CONS DEFABS (COMMON-LISP:APPEND (COMMON-LISP:REVERSE DEFREV) RELDIR))))))))))) (COMMON-LISP:DEFPARAMETER *UNSPECIFIC-PATHNAME-TYPE* :UNSPECIFIC "Unspecific type component to use with the underlying implementation's MAKE-PATHNAME") (COMMON-LISP:DEFUN MAKE-PATHNAME* (COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (COMMON-LISP:DIRECTORY COMMON-LISP:NIL) HOST (DEVICE COMMON-LISP:NIL) NAME COMMON-LISP:TYPE VERSION DEFAULTS) "Takes arguments like CL:MAKE-PATHNAME in the CLHS, and
     [java]    tries hard to make a pathname that will actually behave as documented,
     [java]    despite the peculiarities of each implementation" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE HOST DEVICE COMMON-LISP:DIRECTORY NAME COMMON-LISP:TYPE VERSION DEFAULTS)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-PATHNAME) (COMMON-LISP:APPEND KEYS))) (COMMON-LISP:DEFUN MAKE-PATHNAME-COMPONENT-LOGICAL (X) "Make a pathname component suitable for use in a logical-pathname" (COMMON-LISP:TYPECASE X ((COMMON-LISP:EQL :UNSPECIFIC) COMMON-LISP:NIL) (COMMON-LISP:T X))) (COMMON-LISP:DEFUN MAKE-PATHNAME-LOGICAL (COMMON-LISP:PATHNAME HOST) "Take a PATHNAME's directory, name, type and version components,
     [java] and make a new pathname with corresponding components and specified logical HOST" (MAKE-PATHNAME* :HOST HOST :DIRECTORY (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:PATHNAME)) :NAME (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME)) :TYPE (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-TYPE COMMON-LISP:PATHNAME)) :VERSION (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-VERSION COMMON-LISP:PATHNAME)))) (COMMON-LISP:DEFUN MERGE-PATHNAMES* (SPECIFIED COMMON-LISP:&OPTIONAL (DEFAULTS COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)) "MERGE-PATHNAMES* is like MERGE-PATHNAMES except that
     [java] if the SPECIFIED pathname does not have an absolute directory,
     [java] then the HOST and DEVICE both come from the DEFAULTS, whereas
     [java] if the SPECIFIED pathname does have an absolute directory,
     [java] then the HOST and DEVICE both come from the SPECIFIED pathname.
     [java] This is what users want on a modern Unix or Windows operating system,
     [java] unlike the MERGE-PATHNAMES behavior.
     [java] Also, if either argument is NIL, then the other argument is returned unmodified;
     [java] this is unlike MERGE-PATHNAMES which always merges with a pathname,
     [java] by default *DEFAULT-PATHNAME-DEFAULTS*, which cannot be NIL." (COMMON-LISP:WHEN (COMMON-LISP:NULL SPECIFIED) (COMMON-LISP:RETURN-FROM MERGE-PATHNAMES* DEFAULTS)) (COMMON-LISP:WHEN (COMMON-LISP:NULL DEFAULTS) (COMMON-LISP:RETURN-FROM MERGE-PATHNAMES* SPECIFIED)) (COMMON-LISP:LET* ((SPECIFIED (COMMON-LISP:PATHNAME SPECIFIED)) (DEFAULTS (COMMON-LISP:PATHNAME DEFAULTS)) (COMMON-LISP:DIRECTORY (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY SPECIFIED))) (NAME (COMMON-LISP:OR (COMMON-LISP:PATHNAME-NAME SPECIFIED) (COMMON-LISP:PATHNAME-NAME DEFAULTS))) (COMMON-LISP:TYPE (COMMON-LISP:OR (COMMON-LISP:PATHNAME-TYPE SPECIFIED) (COMMON-LISP:PATHNAME-TYPE DEFAULTS))) (VERSION (COMMON-LISP:OR (COMMON-LISP:PATHNAME-VERSION SPECIFIED) (COMMON-LISP:PATHNAME-VERSION DEFAULTS)))) (COMMON-LISP:LABELS ((UNSPECIFIC-HANDLER (P) (COMMON-LISP:IF (COMMON-LISP:TYPEP P (COMMON-LISP:QUOTE COMMON-LISP:LOGICAL-PATHNAME)) (COMMON-LISP:FUNCTION MAKE-PATHNAME-COMPONENT-LOGICAL) (COMMON-LISP:FUNCTION COMMON-LISP:IDENTITY)))) (COMMON-LISP:MULTIPLE-VALUE-BIND (HOST DEVICE COMMON-LISP:DIRECTORY UNSPECIFIC-HANDLER) (COMMON-LISP:ECASE (COMMON-LISP:FIRST COMMON-LISP:DIRECTORY) ((:ABSOLUTE) (COMMON-LISP:VALUES (COMMON-LISP:PATHNAME-HOST SPECIFIED) (COMMON-LISP:PATHNAME-DEVICE SPECIFIED) COMMON-LISP:DIRECTORY (UNSPECIFIC-HANDLER SPECIFIED))) ((COMMON-LISP:NIL :RELATIVE) (COMMON-LISP:VALUES (COMMON-LISP:PATHNAME-HOST DEFAULTS) (COMMON-LISP:PATHNAME-DEVICE DEFAULTS) (MERGE-PATHNAME-DIRECTORY-COMPONENTS COMMON-LISP:DIRECTORY (COMMON-LISP:PATHNAME-DIRECTORY DEFAULTS)) (UNSPECIFIC-HANDLER DEFAULTS)))) (MAKE-PATHNAME* :HOST HOST :DEVICE DEVICE :DIRECTORY COMMON-LISP:DIRECTORY :NAME (COMMON-LISP:FUNCALL UNSPECIFIC-HANDLER NAME) :TYPE (COMMON-LISP:FUNCALL UNSPECIFIC-HANDLER COMMON-LISP:TYPE) :VERSION (COMMON-LISP:FUNCALL UNSPECIFIC-HANDLER VERSION)))))) (COMMON-LISP:DEFUN LOGICAL-PATHNAME-P (X) "is X a logical-pathname?" (COMMON-LISP:TYPEP X (COMMON-LISP:QUOTE COMMON-LISP:LOGICAL-PATHNAME))) (COMMON-LISP:DEFUN PHYSICAL-PATHNAME-P (X) "is X a pathname that is not a logical-pathname?" (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP X) (COMMON-LISP:NOT (LOGICAL-PATHNAME-P X)))) (COMMON-LISP:DEFUN PHYSICALIZE-PATHNAME (X) "if X is a logical pathname, use translate-logical-pathname on it." (COMMON-LISP:LET ((P (COMMON-LISP:WHEN X (COMMON-LISP:PATHNAME X)))) (COMMON-LISP:IF (LOGICAL-PATHNAME-P P) (COMMON-LISP:TRANSLATE-LOGICAL-PATHNAME P) P))) (COMMON-LISP:DEFUN NIL-PATHNAME (COMMON-LISP:&OPTIONAL (DEFAULTS COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)) "A pathname that is as neutral as possible for use as defaults
     [java] when merging, making or parsing pathnames" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE DEFAULTS)) (MAKE-PATHNAME* :DIRECTORY COMMON-LISP:NIL :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEVICE (COMMON-LISP:OR) :HOST (COMMON-LISP:OR) :DEFAULTS DEFAULTS)) (COMMON-LISP:DEFVAR *NIL-PATHNAME* (NIL-PATHNAME (PHYSICALIZE-PATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME))) "A pathname that is as neutral as possible for use as defaults
     [java] when merging, making or parsing pathnames") (COMMON-LISP:DEFMACRO WITH-PATHNAME-DEFAULTS ((COMMON-LISP:&OPTIONAL DEFAULTS) COMMON-LISP:&BODY BODY) "Execute BODY in a context where the *DEFAULT-PATHNAME-DEFAULTS* is as specified,
     [java] where leaving the defaults NIL or unspecified means a (NIL-PATHNAME), except
     [java] on ABCL, Genera and XCL, where it remains unchanged for it doubles as current-directory." (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*) (COMMON-LISP:OR DEFAULTS (COMMON-LISP:QUOTE COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)))) BODY)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN PATHNAME-EQUAL (P1 P2) "Are the two pathnames P1 and P2 reasonably equal in the paths they denote?" (COMMON-LISP:WHEN (COMMON-LISP:STRINGP P1) (COMMON-LISP:SETF P1 (COMMON-LISP:PATHNAME P1))) (COMMON-LISP:WHEN (COMMON-LISP:STRINGP P2) (COMMON-LISP:SETF P2 (COMMON-LISP:PATHNAME P2))) (COMMON-LISP:FLET ((NORMALIZE-COMPONENT (X) (COMMON-LISP:UNLESS (COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE (COMMON-LISP:NIL :UNSPECIFIC :NEWEST (:RELATIVE))) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) X))) (COMMON-LISP:MACROLET ((=? (COMMON-LISP:&REST ACCESSORS) (COMMON-LISP:FLET ((FROB (X) (COMMON-LISP:REDUCE (COMMON-LISP:QUOTE COMMON-LISP:LIST) (COMMON-LISP:CONS (COMMON-LISP:QUOTE NORMALIZE-COMPONENT) ACCESSORS) :INITIAL-VALUE X :FROM-END COMMON-LISP:T))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL) (FROB (COMMON-LISP:QUOTE P1)) (FROB (COMMON-LISP:QUOTE P2)))))) (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:NULL P1) (COMMON-LISP:NULL P2)) (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP P1) (COMMON-LISP:PATHNAMEP P2) (COMMON-LISP:AND (=? COMMON-LISP:PATHNAME-HOST) (=? COMMON-LISP:PATHNAME-DEVICE) (=? NORMALIZE-PATHNAME-DIRECTORY-COMPONENT COMMON-LISP:PATHNAME-DIRECTORY) (=? COMMON-LISP:PATHNAME-NAME) (=? COMMON-LISP:PATHNAME-TYPE) (=? COMMON-LISP:PATHNAME-VERSION))))))) (COMMON-LISP:DEFUN ABSOLUTE-PATHNAME-P (PATHSPEC) "If PATHSPEC is a pathname or namestring object that parses as a pathname
     [java] possessing an :ABSOLUTE directory component, return the (parsed) pathname.
     [java] Otherwise return NIL" (COMMON-LISP:AND PATHSPEC (COMMON-LISP:TYPEP PATHSPEC (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:PATHNAME COMMON-LISP:STRING))) (COMMON-LISP:LET ((COMMON-LISP:PATHNAME (COMMON-LISP:PATHNAME PATHSPEC))) (COMMON-LISP:AND (COMMON-LISP:EQ :ABSOLUTE (COMMON-LISP:CAR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:PATHNAME)))) COMMON-LISP:PATHNAME)))) (COMMON-LISP:DEFUN RELATIVE-PATHNAME-P (PATHSPEC) "If PATHSPEC is a pathname or namestring object that parses as a pathname
     [java] possessing a :RELATIVE or NIL directory component, return the (parsed) pathname.
     [java] Otherwise return NIL" (COMMON-LISP:AND PATHSPEC (COMMON-LISP:TYPEP PATHSPEC (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:PATHNAME COMMON-LISP:STRING))) (COMMON-LISP:LET* ((COMMON-LISP:PATHNAME (COMMON-LISP:PATHNAME PATHSPEC)) (COMMON-LISP:DIRECTORY (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:PATHNAME)))) (COMMON-LISP:WHEN (COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:DIRECTORY) (COMMON-LISP:EQ :RELATIVE (COMMON-LISP:CAR COMMON-LISP:DIRECTORY))) COMMON-LISP:PATHNAME)))) (COMMON-LISP:DEFUN HIDDEN-PATHNAME-P (COMMON-LISP:PATHNAME) "Return a boolean that is true if the pathname is hidden as per Unix style,
     [java] i.e. its name starts with a dot." (COMMON-LISP:AND COMMON-LISP:PATHNAME (COMMON-LISP:EQUAL (FIRST-CHAR (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME)) #\.))) (COMMON-LISP:DEFUN FILE-PATHNAME-P (COMMON-LISP:PATHNAME) "Does PATHNAME represent a file, i.e. has a non-null NAME component?
     [java]
     [java] Accepts NIL, a string (converted through PARSE-NAMESTRING) or a PATHNAME.
     [java]
     [java] Note that this does _not_ check to see that PATHNAME points to an
     [java] actually-existing file.
     [java]
     [java] Returns the (parsed) PATHNAME when true" (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:LET* ((COMMON-LISP:PATHNAME (COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME)) (NAME (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME))) (COMMON-LISP:WHEN (COMMON-LISP:NOT (COMMON-LISP:MEMBER NAME (COMMON-LISP:QUOTE (COMMON-LISP:NIL :UNSPECIFIC "")) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) COMMON-LISP:PATHNAME)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN PATHNAME-DIRECTORY-PATHNAME (COMMON-LISP:PATHNAME) "Returns a new pathname with same HOST, DEVICE, DIRECTORY as PATHNAME,
     [java] and NIL NAME, TYPE and VERSION components" (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:MAKE-PATHNAME :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEFAULTS COMMON-LISP:PATHNAME))) (COMMON-LISP:DEFUN PATHNAME-PARENT-DIRECTORY-PATHNAME (COMMON-LISP:PATHNAME) "Returns a new pathname that corresponds to the parent of the current pathname's directory,
     [java] i.e. removing one level of depth in the DIRECTORY component. e.g. if pathname is
     [java] Unix pathname /foo/bar/baz/file.type then return /foo/bar/" (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (MAKE-PATHNAME* :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DIRECTORY (MERGE-PATHNAME-DIRECTORY-COMPONENTS (COMMON-LISP:QUOTE (:RELATIVE :BACK)) (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:PATHNAME)) :DEFAULTS COMMON-LISP:PATHNAME))) (COMMON-LISP:DEFUN DIRECTORY-PATHNAME-P (COMMON-LISP:PATHNAME) "Does PATHNAME represent a directory?
     [java]
     [java] A directory-pathname is a pathname _without_ a filename. The three
     [java] ways that the filename components can be missing are for it to be NIL,
     [java] :UNSPECIFIC or the empty string.
     [java]
     [java] Note that this does _not_ check to see that PATHNAME points to an
     [java] actually-existing directory." (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:LET ((COMMON-LISP:PATHNAME (COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME))) (COMMON-LISP:FLET ((CHECK-ONE (X) (COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE (COMMON-LISP:NIL :UNSPECIFIC)) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (COMMON-LISP:AND (COMMON-LISP:NOT (COMMON-LISP:WILD-PATHNAME-P COMMON-LISP:PATHNAME)) (CHECK-ONE (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME)) (CHECK-ONE (COMMON-LISP:PATHNAME-TYPE COMMON-LISP:PATHNAME)) COMMON-LISP:T))))) (COMMON-LISP:DEFUN ENSURE-DIRECTORY-PATHNAME (PATHSPEC COMMON-LISP:&OPTIONAL (ON-ERROR (COMMON-LISP:QUOTE COMMON-LISP:ERROR))) "Converts the non-wild pathname designator PATHSPEC to directory form." (COMMON-LISP:COND ((COMMON-LISP:STRINGP PATHSPEC) (ENSURE-DIRECTORY-PATHNAME (COMMON-LISP:PATHNAME PATHSPEC))) ((COMMON-LISP:NOT (COMMON-LISP:PATHNAMEP PATHSPEC)) (CALL-FUNCTION ON-ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid pathname designator ~S~@:>") PATHSPEC)) ((COMMON-LISP:WILD-PATHNAME-P PATHSPEC) (CALL-FUNCTION ON-ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Can't reliably convert wild pathname ~3i~_~S~@:>") PATHSPEC)) ((DIRECTORY-PATHNAME-P PATHSPEC) PATHSPEC) (COMMON-LISP:T (MAKE-PATHNAME* :DIRECTORY (COMMON-LISP:APPEND (COMMON-LISP:OR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY PATHSPEC)) (COMMON-LISP:LIST :RELATIVE)) (COMMON-LISP:LIST (COMMON-LISP:FILE-NAMESTRING PATHSPEC))) :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEFAULTS PATHSPEC)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN SPLIT-UNIX-NAMESTRING-DIRECTORY-COMPONENTS (UNIX-NAMESTRING COMMON-LISP:&KEY ENSURE-DIRECTORY DOT-DOT) "Splits the path string UNIX-NAMESTRING, returning four values:
     [java] A flag that is either :absolute or :relative, indicating
     [java]    how the rest of the values are to be interpreted.
     [java] A directory path --- a list of strings and keywords, suitable for
     [java]    use with MAKE-PATHNAME when prepended with the flag value.
     [java]    Directory components with an empty name or the name . are removed.
     [java]    Any directory named .. is read as DOT-DOT, or :BACK if it's NIL (not :UP).
     [java] A last-component, either a file-namestring including type extension,
     [java]    or NIL in the case of a directory pathname.
     [java] A flag that is true iff the unix-style-pathname was just
     [java]    a file-namestring without / path specification.
     [java] ENSURE-DIRECTORY forces the namestring to be interpreted as a directory pathname:
     [java] the third return value will be NIL, and final component of the namestring
     [java] will be treated as part of the directory path.
     [java]
     [java] An empty string is thus read as meaning a pathname object with all fields nil.
     [java]
     [java] Note that colon characters #: will NOT be interpreted as host specification.
     [java] Absolute pathnames are only appropriate on Unix-style systems.
     [java]
     [java] The intention of this function is to support structured component names,
     [java] e.g., (:file \"foo/bar\"), which will be unpacked to relative pathnames." (COMMON-LISP:CHECK-TYPE UNIX-NAMESTRING COMMON-LISP:STRING) (COMMON-LISP:CHECK-TYPE DOT-DOT (COMMON-LISP:MEMBER COMMON-LISP:NIL :BACK :UP)) (COMMON-LISP:IF (COMMON-LISP:AND (COMMON-LISP:NOT (COMMON-LISP:FIND #\/ UNIX-NAMESTRING)) (COMMON-LISP:NOT ENSURE-DIRECTORY) (COMMON-LISP:PLUSP (COMMON-LISP:LENGTH UNIX-NAMESTRING))) (COMMON-LISP:VALUES :RELATIVE COMMON-LISP:NIL UNIX-NAMESTRING COMMON-LISP:T) (COMMON-LISP:LET* ((COMPONENTS (SPLIT-STRING UNIX-NAMESTRING :SEPARATOR "/")) (LAST-COMP (COMMON-LISP:CAR (COMMON-LISP:LAST COMPONENTS)))) (COMMON-LISP:MULTIPLE-VALUE-BIND (RELATIVE COMPONENTS) (COMMON-LISP:IF (COMMON-LISP:EQUAL (COMMON-LISP:FIRST COMPONENTS) "") (COMMON-LISP:IF (COMMON-LISP:EQUAL (FIRST-CHAR UNIX-NAMESTRING) #\/) (COMMON-LISP:VALUES :ABSOLUTE (COMMON-LISP:CDR COMPONENTS)) (COMMON-LISP:VALUES :RELATIVE COMMON-LISP:NIL)) (COMMON-LISP:VALUES :RELATIVE COMPONENTS)) (COMMON-LISP:SETF COMPONENTS (COMMON-LISP:REMOVE-IF (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE ("" ".")) :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUAL)))) COMPONENTS)) (COMMON-LISP:SETF COMPONENTS (COMMON-LISP:SUBSTITUTE (COMMON-LISP:OR DOT-DOT :BACK) ".." COMPONENTS :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUAL))) (COMMON-LISP:COND ((COMMON-LISP:EQUAL LAST-COMP "") (COMMON-LISP:VALUES RELATIVE COMPONENTS COMMON-LISP:NIL COMMON-LISP:NIL)) (ENSURE-DIRECTORY (COMMON-LISP:VALUES RELATIVE COMPONENTS COMMON-LISP:NIL COMMON-LISP:NIL)) (COMMON-LISP:T (COMMON-LISP:VALUES RELATIVE (COMMON-LISP:BUTLAST COMPONENTS) LAST-COMP COMMON-LISP:NIL))))))) (COMMON-LISP:DEFUN SPLIT-NAME-TYPE (FILENAME) "Split a filename into two values NAME and TYPE that are returned.
     [java] We assume filename has no directory component.
     [java] The last . if any separates name and type from from type,
     [java] except that if there is only one . and it is in first position,
     [java] the whole filename is the NAME with an empty type.
     [java] NAME is always a string.
     [java] For an empty type, *UNSPECIFIC-PATHNAME-TYPE* is returned." (COMMON-LISP:CHECK-TYPE FILENAME COMMON-LISP:STRING) (COMMON-LISP:ASSERT (COMMON-LISP:PLUSP (COMMON-LISP:LENGTH FILENAME))) (COMMON-LISP:DESTRUCTURING-BIND (NAME COMMON-LISP:&OPTIONAL (COMMON-LISP:TYPE *UNSPECIFIC-PATHNAME-TYPE*)) (SPLIT-STRING FILENAME :MAX 2 :SEPARATOR ".") (COMMON-LISP:IF (COMMON-LISP:EQUAL NAME "") (COMMON-LISP:VALUES FILENAME *UNSPECIFIC-PATHNAME-TYPE*) (COMMON-LISP:VALUES NAME COMMON-LISP:TYPE)))) (COMMON-LISP:DEFUN PARSE-UNIX-NAMESTRING (NAME COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:TYPE DEFAULTS DOT-DOT ENSURE-DIRECTORY COMMON-LISP:&ALLOW-OTHER-KEYS) "Coerce NAME into a PATHNAME using standard Unix syntax.
     [java]
     [java] Unix syntax is used whether or not the underlying system is Unix;
     [java] on such non-Unix systems it is reliably usable only for relative pathnames.
     [java] This function is especially useful to manipulate relative pathnames portably,
     [java] where it is of crucial to possess a portable pathname syntax independent of the underlying OS.
     [java] This is what PARSE-UNIX-NAMESTRING provides, and why we use it in ASDF.
     [java]
     [java] When given a PATHNAME object, just return it untouched.
     [java] When given NIL, just return NIL.
     [java] When given a non-null SYMBOL, first downcase its name and treat it as a string.
     [java] When given a STRING, portably decompose it into a pathname as below.
     [java]
     [java] #\\/ separates directory components.
     [java]
     [java] The last #\\/-separated substring is interpreted as follows:
     [java] 1- If TYPE is :DIRECTORY or ENSURE-DIRECTORY is true,
     [java]  the string is made the last directory component, and NAME and TYPE are NIL.
     [java]  if the string is empty, it's the empty pathname with all slots NIL.
     [java] 2- If TYPE is NIL, the substring is a file-namestring, and its NAME and TYPE
     [java]  are separated by SPLIT-NAME-TYPE.
     [java] 3- If TYPE is a string, it is the given TYPE, and the whole string is the NAME.
     [java]
     [java] Directory components with an empty name or the name \".\" are removed.
     [java] Any directory named \"..\" is read as DOT-DOT,
     [java] which must be one of :BACK or :UP and defaults to :BACK.
     [java]
     [java] HOST, DEVICE and VERSION components are taken from DEFAULTS,
     [java] which itself defaults to *NIL-PATHNAME*, also used if DEFAULTS is NIL.
     [java] No host or device can be specified in the string itself,
     [java] which makes it unsuitable for absolute pathnames outside Unix.
     [java]
     [java] For relative pathnames, these components (and hence the defaults) won't matter
     [java] if you use MERGE-PATHNAMES* but will matter if you use MERGE-PATHNAMES,
     [java] which is an important reason to always use MERGE-PATHNAMES*.
     [java]
     [java] Arbitrary keys are accepted, and the parse result is passed to ENSURE-PATHNAME
     [java] with those keys, removing TYPE DEFAULTS and DOT-DOT.
     [java] When you're manipulating pathnames that are supposed to make sense portably
     [java] even though the OS may not be Unixish, we recommend you use :WANT-RELATIVE T
     [java] to throw an error if the pathname is absolute" (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:CHECK-TYPE COMMON-LISP:TYPE (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING (COMMON-LISP:EQL :DIRECTORY))) (COMMON-LISP:WHEN ENSURE-DIRECTORY (COMMON-LISP:SETF COMMON-LISP:TYPE :DIRECTORY)) (COMMON-LISP:ETYPECASE NAME ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:PATHNAME) (COMMON-LISP:RETURN NAME)) (COMMON-LISP:SYMBOL (COMMON-LISP:SETF NAME (COMMON-LISP:STRING-DOWNCASE NAME))) (COMMON-LISP:STRING)) (COMMON-LISP:MULTIPLE-VALUE-BIND (RELATIVE PATH FILENAME FILE-ONLY) (SPLIT-UNIX-NAMESTRING-DIRECTORY-COMPONENTS NAME :DOT-DOT DOT-DOT :ENSURE-DIRECTORY (COMMON-LISP:EQ COMMON-LISP:TYPE :DIRECTORY)) (COMMON-LISP:MULTIPLE-VALUE-BIND (NAME COMMON-LISP:TYPE) (COMMON-LISP:COND ((COMMON-LISP:OR (COMMON-LISP:EQ COMMON-LISP:TYPE :DIRECTORY) (COMMON-LISP:NULL FILENAME)) (COMMON-LISP:VALUES COMMON-LISP:NIL COMMON-LISP:NIL)) (COMMON-LISP:TYPE (COMMON-LISP:VALUES FILENAME COMMON-LISP:TYPE)) (COMMON-LISP:T (SPLIT-NAME-TYPE FILENAME))) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE ENSURE-PATHNAME) (MAKE-PATHNAME* :DIRECTORY (COMMON-LISP:UNLESS FILE-ONLY (COMMON-LISP:CONS RELATIVE PATH)) :NAME NAME :TYPE COMMON-LISP:TYPE :DEFAULTS (COMMON-LISP:OR DEFAULTS *NIL-PATHNAME*)) (REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:TYPE :DOT-DOT :DEFAULTS)) KEYS)))))) (COMMON-LISP:DEFUN UNIX-NAMESTRING (COMMON-LISP:PATHNAME) "Given a non-wild PATHNAME, return a Unix-style namestring for it.
     [java] If the PATHNAME is NIL or a STRING, return it unchanged.
     [java]
     [java] This only considers the DIRECTORY, NAME and TYPE components of the pathname.
     [java] This is a portable solution for representing relative pathnames,
     [java] But unless you are running on a Unix system, it is not a general solution
     [java] to representing native pathnames.
     [java]
     [java] An error is signaled if the argument is not NULL, a STRING or a PATHNAME,
     [java] or if it is a PATHNAME but some of its components are not recognized." (COMMON-LISP:ETYPECASE COMMON-LISP:PATHNAME ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING) COMMON-LISP:PATHNAME) (COMMON-LISP:PATHNAME (COMMON-LISP:WITH-OUTPUT-TO-STRING (S) (COMMON-LISP:FLET ((ERR COMMON-LISP:NIL (COMMON-LISP:ERROR "Not a valid unix-namestring ~S" COMMON-LISP:PATHNAME))) (COMMON-LISP:LET* ((DIR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:PATHNAME))) (NAME (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME)) (NAME (COMMON-LISP:AND (COMMON-LISP:NOT (COMMON-LISP:EQ NAME :UNSPECIFIC)) NAME)) (COMMON-LISP:TYPE (COMMON-LISP:PATHNAME-TYPE COMMON-LISP:PATHNAME)) (COMMON-LISP:TYPE (COMMON-LISP:AND (COMMON-LISP:NOT (COMMON-LISP:EQ COMMON-LISP:TYPE :UNSPECIFIC)) COMMON-LISP:TYPE))) (COMMON-LISP:COND ((COMMON-LISP:MEMBER DIR (COMMON-LISP:QUOTE (COMMON-LISP:NIL :UNSPECIFIC)))) ((COMMON-LISP:EQ DIR (COMMON-LISP:QUOTE (:RELATIVE))) (COMMON-LISP:PRINC "./" S)) ((COMMON-LISP:CONSP DIR) (COMMON-LISP:DESTRUCTURING-BIND (RELABS COMMON-LISP:&REST DIRS) DIR (COMMON-LISP:OR (COMMON-LISP:MEMBER RELABS (COMMON-LISP:QUOTE (:RELATIVE :ABSOLUTE))) (ERR)) (COMMON-LISP:WHEN (COMMON-LISP:EQ RELABS :ABSOLUTE) (COMMON-LISP:PRINC #\/ S)) (COMMON-LISP:LOOP :FOR X :IN DIRS :DO (COMMON-LISP:COND ((COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE (:BACK :UP))) (COMMON-LISP:PRINC "../" S)) ((COMMON-LISP:EQUAL X "") (ERR)) ((COMMON-LISP:STRINGP X) (COMMON-LISP:FORMAT S "~A/" X)) (COMMON-LISP:T (ERR)))))) (COMMON-LISP:T (ERR))) (COMMON-LISP:COND (NAME (COMMON-LISP:UNLESS (COMMON-LISP:AND (COMMON-LISP:STRINGP NAME) (COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:TYPE) (COMMON-LISP:STRINGP COMMON-LISP:TYPE))) (ERR)) (COMMON-LISP:FORMAT S "~A~@[.~A~]" NAME COMMON-LISP:TYPE)) (COMMON-LISP:T (COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:TYPE) (ERR)))))))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN SUBPATHNAME (COMMON-LISP:PATHNAME SUBPATH COMMON-LISP:&KEY COMMON-LISP:TYPE) "This function takes a PATHNAME and a SUBPATH and a TYPE.
     [java] If SUBPATH is already a PATHNAME object (not namestring),
     [java] and is an absolute pathname at that, it is returned unchanged;
     [java] otherwise, SUBPATH is turned into a relative pathname with given TYPE
     [java] as per PARSE-UNIX-NAMESTRING with :WANT-RELATIVE T :TYPE TYPE,
     [java] then it is merged with the PATHNAME-DIRECTORY-PATHNAME of PATHNAME." (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP SUBPATH) (ABSOLUTE-PATHNAME-P SUBPATH)) (MERGE-PATHNAMES* (PARSE-UNIX-NAMESTRING SUBPATH :TYPE COMMON-LISP:TYPE :WANT-RELATIVE COMMON-LISP:T) (PATHNAME-DIRECTORY-PATHNAME COMMON-LISP:PATHNAME)))) (COMMON-LISP:DEFUN SUBPATHNAME* (COMMON-LISP:PATHNAME SUBPATH COMMON-LISP:&KEY COMMON-LISP:TYPE) "returns NIL if the base pathname is NIL, otherwise like SUBPATHNAME." (COMMON-LISP:AND COMMON-LISP:PATHNAME (SUBPATHNAME (ENSURE-DIRECTORY-PATHNAME COMMON-LISP:PATHNAME) SUBPATH :TYPE COMMON-LISP:TYPE))) (COMMON-LISP:DEFUN PATHNAME-ROOT (COMMON-LISP:PATHNAME) "return the root directory for the host and device of given PATHNAME" (MAKE-PATHNAME* :DIRECTORY (COMMON-LISP:QUOTE (:ABSOLUTE)) :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEFAULTS COMMON-LISP:PATHNAME)) (COMMON-LISP:DEFUN PATHNAME-HOST-PATHNAME (COMMON-LISP:PATHNAME) "return a pathname with the same host as given PATHNAME, and all other fields NIL" (MAKE-PATHNAME* :DIRECTORY COMMON-LISP:NIL :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEVICE COMMON-LISP:NIL :DEFAULTS COMMON-LISP:PATHNAME)) (COMMON-LISP:DEFUN ENSURE-ABSOLUTE-PATHNAME (PATH COMMON-LISP:&OPTIONAL DEFAULTS (ON-ERROR (COMMON-LISP:QUOTE COMMON-LISP:ERROR))) "Given a pathname designator PATH, return an absolute pathname as specified by PATH
     [java] considering the DEFAULTS, or, if not possible, use CALL-FUNCTION on the specified ON-ERROR behavior,
     [java] with a format control-string and other arguments as arguments" (COMMON-LISP:COND ((ABSOLUTE-PATHNAME-P PATH)) ((COMMON-LISP:STRINGP PATH) (ENSURE-ABSOLUTE-PATHNAME (COMMON-LISP:PATHNAME PATH) DEFAULTS ON-ERROR)) ((COMMON-LISP:NOT (COMMON-LISP:PATHNAMEP PATH)) (CALL-FUNCTION ON-ERROR "not a valid pathname designator ~S" PATH)) ((COMMON-LISP:LET ((DEFAULT-PATHNAME (COMMON-LISP:IF (COMMON-LISP:PATHNAMEP DEFAULTS) DEFAULTS (CALL-FUNCTION DEFAULTS)))) (COMMON-LISP:OR (COMMON-LISP:IF (ABSOLUTE-PATHNAME-P DEFAULT-PATHNAME) (ABSOLUTE-PATHNAME-P (MERGE-PATHNAMES* PATH DEFAULT-PATHNAME)) (CALL-FUNCTION ON-ERROR "Default pathname ~S is not an absolute pathname" DEFAULT-PATHNAME)) (CALL-FUNCTION ON-ERROR "Failed to merge ~S with ~S into an absolute pathname" PATH DEFAULT-PATHNAME)))) (COMMON-LISP:T (CALL-FUNCTION ON-ERROR "Cannot ensure ~S is evaluated as an absolute pathname with defaults ~S" PATH DEFAULTS)))) (COMMON-LISP:DEFUN SUBPATHP (MAYBE-SUBPATH BASE-PATHNAME) "if MAYBE-SUBPATH is a pathname that is under BASE-PATHNAME, return a pathname object that
     [java] when used with MERGE-PATHNAMES* with defaults BASE-PATHNAME, returns MAYBE-SUBPATH." (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP MAYBE-SUBPATH) (COMMON-LISP:PATHNAMEP BASE-PATHNAME) (ABSOLUTE-PATHNAME-P MAYBE-SUBPATH) (ABSOLUTE-PATHNAME-P BASE-PATHNAME) (DIRECTORY-PATHNAME-P BASE-PATHNAME) (COMMON-LISP:NOT (COMMON-LISP:WILD-PATHNAME-P BASE-PATHNAME)) (PATHNAME-EQUAL (PATHNAME-ROOT MAYBE-SUBPATH) (PATHNAME-ROOT BASE-PATHNAME)) (WITH-PATHNAME-DEFAULTS (*NIL-PATHNAME*) (COMMON-LISP:LET ((ENOUGH (COMMON-LISP:ENOUGH-NAMESTRING MAYBE-SUBPATH BASE-PATHNAME))) (COMMON-LISP:AND (RELATIVE-PATHNAME-P ENOUGH) (COMMON-LISP:PATHNAME ENOUGH)))))) (COMMON-LISP:DEFUN ENOUGH-PATHNAME (MAYBE-SUBPATH BASE-PATHNAME) "if MAYBE-SUBPATH is a pathname that is under BASE-PATHNAME, return a pathname object that
     [java] when used with MERGE-PATHNAMES* with defaults BASE-PATHNAME, returns MAYBE-SUBPATH." (COMMON-LISP:LET ((SUB (COMMON-LISP:WHEN MAYBE-SUBPATH (COMMON-LISP:PATHNAME MAYBE-SUBPATH))) (BASE (COMMON-LISP:WHEN BASE-PATHNAME (ENSURE-ABSOLUTE-PATHNAME (COMMON-LISP:PATHNAME BASE-PATHNAME))))) (COMMON-LISP:OR (COMMON-LISP:AND BASE (SUBPATHP SUB BASE)) SUB))) (COMMON-LISP:DEFUN CALL-WITH-ENOUGH-PATHNAME (MAYBE-SUBPATH DEFAULTS-PATHNAME THUNK) "In a context where *DEFAULT-PATHNAME-DEFAULTS* is bound to DEFAULTS-PATHNAME (if not null,
     [java] or else to its current value), call THUNK with ENOUGH-PATHNAME for MAYBE-SUBPATH
     [java] given DEFAULTS-PATHNAME as a base pathname." (COMMON-LISP:LET ((ENOUGH (ENOUGH-PATHNAME MAYBE-SUBPATH DEFAULTS-PATHNAME)) (COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS* (COMMON-LISP:OR DEFAULTS-PATHNAME COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*))) (COMMON-LISP:FUNCALL THUNK ENOUGH))) (COMMON-LISP:DEFMACRO WITH-ENOUGH-PATHNAME ((PATHNAME-VAR COMMON-LISP:&KEY (COMMON-LISP:PATHNAME PATHNAME-VAR) (DEFAULTS COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)) COMMON-LISP:&BODY BODY) "Shorthand syntax for CALL-WITH-ENOUGH-PATHNAME" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-ENOUGH-PATHNAME) COMMON-LISP:PATHNAME DEFAULTS (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST PATHNAME-VAR) BODY)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER *WILD* (COMMON-LISP:OR :WILD) "Wild component for use with MAKE-PATHNAME") (COMMON-LISP:DEFPARAMETER *WILD-DIRECTORY-COMPONENT* (COMMON-LISP:OR :WILD) "Wild directory component for use with MAKE-PATHNAME") (COMMON-LISP:DEFPARAMETER *WILD-INFERIORS-COMPONENT* (COMMON-LISP:OR :WILD-INFERIORS) "Wild-inferiors directory component for use with MAKE-PATHNAME") (COMMON-LISP:DEFPARAMETER *WILD-FILE* (COMMON-LISP:MAKE-PATHNAME :DIRECTORY COMMON-LISP:NIL :NAME *WILD* :TYPE *WILD* :VERSION (COMMON-LISP:OR)) "A pathname object with wildcards for matching any file in a given directory") (COMMON-LISP:DEFPARAMETER *WILD-DIRECTORY* (MAKE-PATHNAME* :DIRECTORY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :RELATIVE) *WILD-DIRECTORY-COMPONENT*) :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL) "A pathname object with wildcards for matching any subdirectory") (COMMON-LISP:DEFPARAMETER *WILD-INFERIORS* (MAKE-PATHNAME* :DIRECTORY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :RELATIVE) *WILD-INFERIORS-COMPONENT*) :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL) "A pathname object with wildcards for matching any recursive subdirectory") (COMMON-LISP:DEFPARAMETER *WILD-PATH* (MERGE-PATHNAMES* *WILD-FILE* *WILD-INFERIORS*) "A pathname object with wildcards for matching any file in any recursive subdirectory") (COMMON-LISP:DEFUN WILDEN (PATH) "From a pathname, return a wildcard pathname matching any file in any subdirectory of given pathname's directory" (MERGE-PATHNAMES* *WILD-PATH* PATH)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN RELATIVIZE-DIRECTORY-COMPONENT (DIRECTORY-COMPONENT) "Given the DIRECTORY-COMPONENT of a pathname, return an otherwise similar relative directory component" (COMMON-LISP:LET ((COMMON-LISP:DIRECTORY (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT DIRECTORY-COMPONENT))) (COMMON-LISP:COND ((COMMON-LISP:STRINGP COMMON-LISP:DIRECTORY) (COMMON-LISP:LIST :RELATIVE COMMON-LISP:DIRECTORY)) ((COMMON-LISP:EQ (COMMON-LISP:CAR COMMON-LISP:DIRECTORY) :ABSOLUTE) (COMMON-LISP:CONS :RELATIVE (COMMON-LISP:CDR COMMON-LISP:DIRECTORY))) (COMMON-LISP:T COMMON-LISP:DIRECTORY)))) (COMMON-LISP:DEFUN RELATIVIZE-PATHNAME-DIRECTORY (PATHSPEC) "Given a PATHNAME, return a relative pathname with otherwise the same components" (COMMON-LISP:LET ((P (COMMON-LISP:PATHNAME PATHSPEC))) (MAKE-PATHNAME* :DIRECTORY (RELATIVIZE-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY P)) :DEFAULTS P))) (COMMON-LISP:DEFUN DIRECTORY-SEPARATOR-FOR-HOST (COMMON-LISP:&OPTIONAL (COMMON-LISP:PATHNAME COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)) "Given a PATHNAME, return the character used to delimit directory names on this host and device." (COMMON-LISP:LET ((FOO (MAKE-PATHNAME* :DIRECTORY (COMMON-LISP:QUOTE (:ABSOLUTE "FOO")) :DEFAULTS COMMON-LISP:PATHNAME))) (LAST-CHAR (COMMON-LISP:NAMESTRING FOO)))) (COMMON-LISP:DEFUN DIRECTORIZE-PATHNAME-HOST-DEVICE (COMMON-LISP:PATHNAME) "Given a PATHNAME, return a pathname that has representations of its HOST and DEVICE components
     [java] added to its DIRECTORY component. This is useful for output translations." (OS-COND ((OS-UNIX-P) (COMMON-LISP:WHEN (PHYSICAL-PATHNAME-P COMMON-LISP:PATHNAME) (COMMON-LISP:RETURN-FROM DIRECTORIZE-PATHNAME-HOST-DEVICE COMMON-LISP:PATHNAME)))) (COMMON-LISP:LET* ((ROOT (PATHNAME-ROOT COMMON-LISP:PATHNAME)) (WILD-ROOT (WILDEN ROOT)) (ABSOLUTE-PATHNAME (MERGE-PATHNAMES* COMMON-LISP:PATHNAME ROOT)) (SEPARATOR (DIRECTORY-SEPARATOR-FOR-HOST ROOT)) (ROOT-NAMESTRING (COMMON-LISP:NAMESTRING ROOT)) (ROOT-STRING (COMMON-LISP:SUBSTITUTE-IF #\/ (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:OR (COMMON-LISP:EQL X #\:) (COMMON-LISP:EQL X SEPARATOR)))) ROOT-NAMESTRING))) (COMMON-LISP:MULTIPLE-VALUE-BIND (RELATIVE PATH FILENAME) (SPLIT-UNIX-NAMESTRING-DIRECTORY-COMPONENTS ROOT-STRING :ENSURE-DIRECTORY COMMON-LISP:T) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE RELATIVE FILENAME)) (COMMON-LISP:LET ((NEW-BASE (MAKE-PATHNAME* :DEFAULTS ROOT :DIRECTORY (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :ABSOLUTE) PATH)))) (COMMON-LISP:TRANSLATE-PATHNAME ABSOLUTE-PATHNAME WILD-ROOT (WILDEN NEW-BASE)))))) (DEFUN* (TRANSLATE-PATHNAME*) (PATH ABSOLUTE-SOURCE DESTINATION COMMON-LISP:&OPTIONAL ROOT SOURCE) "A wrapper around TRANSLATE-PATHNAME to be used by the ASDF output-translations facility.
     [java] PATH is the pathname to be translated.
     [java] ABSOLUTE-SOURCE is an absolute pathname to use as source for translate-pathname,
     [java] DESTINATION is either a function, to be called with PATH and ABSOLUTE-SOURCE,
     [java] or a relative pathname, to be merged with ROOT and used as destination for translate-pathname
     [java] or an absolute pathname, to be used as destination for translate-pathname.
     [java] In that last case, if ROOT is non-NIL, PATH is first transformated by DIRECTORIZE-PATHNAME-HOST-DEVICE." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE SOURCE)) (COMMON-LISP:COND ((COMMON-LISP:FUNCTIONP DESTINATION) (COMMON-LISP:FUNCALL DESTINATION PATH ABSOLUTE-SOURCE)) ((COMMON-LISP:EQ DESTINATION COMMON-LISP:T) PATH) ((COMMON-LISP:NOT (COMMON-LISP:PATHNAMEP DESTINATION)) (COMMON-LISP:ERROR "Invalid destination")) ((COMMON-LISP:NOT (ABSOLUTE-PATHNAME-P DESTINATION)) (COMMON-LISP:TRANSLATE-PATHNAME PATH ABSOLUTE-SOURCE (MERGE-PATHNAMES* DESTINATION ROOT))) (ROOT (COMMON-LISP:TRANSLATE-PATHNAME (DIRECTORIZE-PATHNAME-HOST-DEVICE PATH) ABSOLUTE-SOURCE DESTINATION)) (COMMON-LISP:T (COMMON-LISP:TRANSLATE-PATHNAME PATH ABSOLUTE-SOURCE DESTINATION)))) (COMMON-LISP:DEFVAR *OUTPUT-TRANSLATION-FUNCTION* (COMMON-LISP:QUOTE COMMON-LISP:IDENTITY) "Hook for output translations.
     [java]
     [java] This function needs to be idempotent, so that actions can work
     [java] whether their inputs were translated or not,
     [java] which they will be if we are composing operations. e.g. if some
     [java] create-lisp-op creates a lisp file from some higher-level input,
     [java] you need to still be able to use compile-op on that lisp file."))
     [java] ; (DEFINE-PACKAGE :UIOP/FILESYSTEM (:NICKNAMES :ASDF/FILESYSTEM) (:RECYCLE :UIOP/FILESYSTEM :ASDF/PATHNAME :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/OS :UIOP/PATHNAME) (:EXPORT #:NATIVE-NAMESTRING #:PARSE-NATIVE-NAMESTRING #:TRUENAME* #:SAFE-FILE-WRITE-DATE #:PROBE-FILE* #:DIRECTORY-EXISTS-P #:FILE-EXISTS-P #:DIRECTORY* #:FILTER-LOGICAL-DIRECTORY-RESULTS #:DIRECTORY-FILES #:SUBDIRECTORIES #:COLLECT-SUB*DIRECTORIES #:TRUENAMIZE #:RESOLVE-SYMLINKS #:*RESOLVE-SYMLINKS* #:RESOLVE-SYMLINKS* #:GET-PATHNAME-DEFAULTS #:CALL-WITH-CURRENT-DIRECTORY #:WITH-CURRENT-DIRECTORY #:INTER-DIRECTORY-SEPARATOR #:SPLIT-NATIVE-PATHNAMES-STRING #:GETENV-PATHNAME #:GETENV-PATHNAMES #:GETENV-ABSOLUTE-DIRECTORY #:GETENV-ABSOLUTE-DIRECTORIES #:LISP-IMPLEMENTATION-DIRECTORY #:LISP-IMPLEMENTATION-PATHNAME-P #:ENSURE-ALL-DIRECTORIES-EXIST #:RENAME-FILE-OVERWRITING-TARGET #:DELETE-FILE-IF-EXISTS #:DELETE-EMPTY-DIRECTORY #:DELETE-DIRECTORY-TREE))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/FILESYSTEM)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN NATIVE-NAMESTRING (X) "From a non-wildcard CL pathname, a return namestring suitable for passing to the operating system" (COMMON-LISP:WHEN X (COMMON-LISP:LET ((P (COMMON-LISP:PATHNAME X))) (OS-COND ((OS-UNIX-P) (UNIX-NAMESTRING P)) (COMMON-LISP:T (COMMON-LISP:NAMESTRING P)))))) (COMMON-LISP:DEFUN PARSE-NATIVE-NAMESTRING (COMMON-LISP:STRING COMMON-LISP:&REST CONSTRAINTS COMMON-LISP:&KEY ENSURE-DIRECTORY COMMON-LISP:&ALLOW-OTHER-KEYS) "From a native namestring suitable for use by the operating system, return
     [java] a CL pathname satisfying all the specified constraints as per ENSURE-PATHNAME" (COMMON-LISP:CHECK-TYPE COMMON-LISP:STRING (COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:NULL)) (COMMON-LISP:LET* ((COMMON-LISP:PATHNAME (COMMON-LISP:WHEN COMMON-LISP:STRING (WITH-PATHNAME-DEFAULTS COMMON-LISP:NIL (OS-COND ((OS-UNIX-P) (PARSE-UNIX-NAMESTRING COMMON-LISP:STRING :ENSURE-DIRECTORY ENSURE-DIRECTORY)) (COMMON-LISP:T (COMMON-LISP:PARSE-NAMESTRING COMMON-LISP:STRING)))))) (COMMON-LISP:PATHNAME (COMMON-LISP:IF ENSURE-DIRECTORY (COMMON-LISP:AND COMMON-LISP:PATHNAME (ENSURE-DIRECTORY-PATHNAME COMMON-LISP:PATHNAME)) COMMON-LISP:PATHNAME))) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE ENSURE-PATHNAME) COMMON-LISP:PATHNAME CONSTRAINTS))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN TRUENAME* (P) "Nicer variant of TRUENAME that plays well with NIL, avoids logical pathname contexts, and tries both files and directories" (COMMON-LISP:WHEN P (COMMON-LISP:WHEN (COMMON-LISP:STRINGP P) (COMMON-LISP:SETF P (WITH-PATHNAME-DEFAULTS COMMON-LISP:NIL (COMMON-LISP:PARSE-NAMESTRING P)))) (COMMON-LISP:VALUES (COMMON-LISP:OR (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:TRUENAME P)))))) (COMMON-LISP:DEFUN SAFE-FILE-WRITE-DATE (COMMON-LISP:PATHNAME) "Safe variant of FILE-WRITE-DATE that may return NIL rather than raise an error." (COMMON-LISP:AND COMMON-LISP:PATHNAME (COMMON-LISP:HANDLER-CASE (COMMON-LISP:FILE-WRITE-DATE (PHYSICALIZE-PATHNAME COMMON-LISP:PATHNAME)) (COMMON-LISP:FILE-ERROR COMMON-LISP:NIL COMMON-LISP:NIL)))) (COMMON-LISP:DEFUN PROBE-FILE* (P COMMON-LISP:&KEY COMMON-LISP:TRUENAME) "when given a pathname P (designated by a string as per PARSE-NAMESTRING),
     [java] probes the filesystem for a file or directory with given pathname.
     [java] If it exists, return its truename is ENSURE-PATHNAME is true,
     [java] or the original (parsed) pathname if it is false (the default)." (COMMON-LISP:VALUES (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:SETF P (COMMON-LISP:FUNCALL (COMMON-LISP:QUOTE ENSURE-PATHNAME) P :NAMESTRING :LISP :ENSURE-PHYSICAL COMMON-LISP:T :ENSURE-ABSOLUTE COMMON-LISP:T :DEFAULTS (COMMON-LISP:QUOTE GET-PATHNAME-DEFAULTS) :WANT-NON-WILD COMMON-LISP:T :ON-ERROR COMMON-LISP:NIL)) (COMMON-LISP:WHEN P (COMMON-LISP:IF COMMON-LISP:TRUENAME (COMMON-LISP:PROBE-FILE P) (COMMON-LISP:AND (COMMON-LISP:FILE-WRITE-DATE P) P)))))) (COMMON-LISP:DEFUN DIRECTORY-EXISTS-P (X) "Is X the name of a directory that exists on the filesystem?" (COMMON-LISP:LET ((P (PROBE-FILE* X :TRUENAME COMMON-LISP:T))) (COMMON-LISP:AND (DIRECTORY-PATHNAME-P P) P))) (COMMON-LISP:DEFUN FILE-EXISTS-P (X) "Is X the name of a file that exists on the filesystem?" (COMMON-LISP:LET ((P (PROBE-FILE* X :TRUENAME COMMON-LISP:T))) (COMMON-LISP:AND (FILE-PATHNAME-P P) P))) (COMMON-LISP:DEFUN DIRECTORY* (PATHNAME-SPEC COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) "Return a list of the entries in a directory by calling DIRECTORY.
     [java] Try to override the defaults to not resolving symlinks, if implementation allows." (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:DIRECTORY) PATHNAME-SPEC (COMMON-LISP:APPEND KEYS (COMMON-LISP:QUOTE COMMON-LISP:NIL)))) (COMMON-LISP:DEFUN FILTER-LOGICAL-DIRECTORY-RESULTS (COMMON-LISP:DIRECTORY ENTRIES MERGER) "Given ENTRIES in a DIRECTORY, remove if the directory is logical
     [java] the entries which are physical yet when transformed by MERGER have a different TRUENAME.
     [java] This function is used as a helper to DIRECTORY-FILES to avoid invalid entries when using logical-pathnames." (COMMON-LISP:REMOVE-DUPLICATES (COMMON-LISP:IF (LOGICAL-PATHNAME-P COMMON-LISP:DIRECTORY) (COMMON-LISP:LOOP :FOR F :IN ENTRIES :FOR P COMMON-LISP:= (COMMON-LISP:OR (COMMON-LISP:AND (LOGICAL-PATHNAME-P F) F) (COMMON-LISP:LET* ((U (COMMON-LISP:IGNORE-ERRORS (CALL-FUNCTION MERGER F)))) (COMMON-LISP:AND U (COMMON-LISP:EQUAL (TRUENAME* U) (TRUENAME* F)) U))) :WHEN P :COLLECT P) ENTRIES) :TEST (COMMON-LISP:QUOTE PATHNAME-EQUAL))) (COMMON-LISP:DEFUN DIRECTORY-FILES (COMMON-LISP:DIRECTORY COMMON-LISP:&OPTIONAL (PATTERN *WILD-FILE*)) "Return a list of the files in a directory according to the PATTERN.
     [java] Subdirectories should NOT be returned.
     [java]   PATTERN defaults to a pattern carefully chosen based on the implementation;
     [java] override the default at your own risk.
     [java]   DIRECTORY-FILES tries NOT to resolve symlinks if the implementation permits this,
     [java] but the behavior in presence of symlinks is not portable. Use IOlib to handle such situations." (COMMON-LISP:LET ((DIR (COMMON-LISP:PATHNAME COMMON-LISP:DIRECTORY))) (COMMON-LISP:WHEN (LOGICAL-PATHNAME-P DIR) (COMMON-LISP:WHEN (COMMON-LISP:WILD-PATHNAME-P DIR) (COMMON-LISP:ERROR "Invalid wild pattern in logical directory ~S" COMMON-LISP:DIRECTORY)) (COMMON-LISP:UNLESS (COMMON-LISP:MEMBER (COMMON-LISP:PATHNAME-DIRECTORY PATTERN) (COMMON-LISP:QUOTE (COMMON-LISP:NIL (:RELATIVE))) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) (COMMON-LISP:ERROR "Invalid file pattern ~S for logical directory ~S" PATTERN COMMON-LISP:DIRECTORY)) (COMMON-LISP:SETF PATTERN (MAKE-PATHNAME-LOGICAL PATTERN (COMMON-LISP:PATHNAME-HOST DIR)))) (COMMON-LISP:LET* ((PAT (MERGE-PATHNAMES* PATTERN DIR)) (ENTRIES (COMMON-LISP:APPEND (COMMON-LISP:IGNORE-ERRORS (DIRECTORY* PAT))))) (COMMON-LISP:REMOVE-IF (COMMON-LISP:QUOTE DIRECTORY-PATHNAME-P) (FILTER-LOGICAL-DIRECTORY-RESULTS COMMON-LISP:DIRECTORY ENTRIES (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (F) (COMMON-LISP:MAKE-PATHNAME :DEFAULTS DIR :NAME (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-NAME F)) :TYPE (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-TYPE F)) :VERSION (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:PATHNAME-VERSION F)))))))))) (COMMON-LISP:DEFUN SUBDIRECTORIES (COMMON-LISP:DIRECTORY) "Given a DIRECTORY pathname designator, return a list of the subdirectories under it.
     [java] The behavior in presence of symlinks is not portable. Use IOlib to handle such situations." (COMMON-LISP:LET* ((COMMON-LISP:DIRECTORY (ENSURE-DIRECTORY-PATHNAME COMMON-LISP:DIRECTORY)) (DIRS (SYSTEM:LIST-DIRECTORY COMMON-LISP:DIRECTORY)) (DIRS (COMMON-LISP:LOOP :FOR X :IN DIRS :FOR D COMMON-LISP:= (EXTENSIONS:PROBE-DIRECTORY X) :WHEN D :COLLECT D))) (FILTER-LOGICAL-DIRECTORY-RESULTS COMMON-LISP:DIRECTORY DIRS (COMMON-LISP:LET ((PREFIX (COMMON-LISP:OR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY COMMON-LISP:DIRECTORY)) (COMMON-LISP:QUOTE (:ABSOLUTE))))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (D) (COMMON-LISP:LET ((DIR (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY D)))) (COMMON-LISP:AND (COMMON-LISP:CONSP DIR) (COMMON-LISP:CONSP (COMMON-LISP:CDR DIR)) (COMMON-LISP:MAKE-PATHNAME :DEFAULTS COMMON-LISP:DIRECTORY :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DIRECTORY (COMMON-LISP:APPEND PREFIX (MAKE-PATHNAME-COMPONENT-LOGICAL (COMMON-LISP:LAST DIR)))))))))))) (COMMON-LISP:DEFUN COLLECT-SUB*DIRECTORIES (COMMON-LISP:DIRECTORY COLLECTP RECURSEP COLLECTOR) "Given a DIRECTORY, when COLLECTP returns true when CALL-FUNCTION'ed with the directory,
     [java] call-function the COLLECTOR function designator on the directory,
     [java] and recurse each of its subdirectories on which the RECURSEP returns true when CALL-FUNCTION'ed with them.
     [java] This function will thus let you traverse a filesystem hierarchy,
     [java] superseding the functionality of CL-FAD:WALK-DIRECTORY.
     [java] The behavior in presence of symlinks is not portable. Use IOlib to handle such situations." (COMMON-LISP:WHEN (CALL-FUNCTION COLLECTP COMMON-LISP:DIRECTORY) (CALL-FUNCTION COLLECTOR COMMON-LISP:DIRECTORY) (COMMON-LISP:DOLIST (SUBDIR (SUBDIRECTORIES COMMON-LISP:DIRECTORY)) (COMMON-LISP:WHEN (CALL-FUNCTION RECURSEP SUBDIR) (COLLECT-SUB*DIRECTORIES SUBDIR COLLECTP RECURSEP COLLECTOR))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN TRUENAMIZE (COMMON-LISP:PATHNAME) "Resolve as much of a pathname as possible" (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:WHEN (COMMON-LISP:TYPEP COMMON-LISP:PATHNAME (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:LOGICAL-PATHNAME))) (COMMON-LISP:RETURN COMMON-LISP:PATHNAME)) (COMMON-LISP:LET ((P COMMON-LISP:PATHNAME)) (COMMON-LISP:UNLESS (ABSOLUTE-PATHNAME-P P) (COMMON-LISP:SETF P (COMMON-LISP:OR (ABSOLUTE-PATHNAME-P (ENSURE-ABSOLUTE-PATHNAME P (COMMON-LISP:QUOTE GET-PATHNAME-DEFAULTS) COMMON-LISP:NIL)) (COMMON-LISP:RETURN P)))) (COMMON-LISP:WHEN (LOGICAL-PATHNAME-P P) (COMMON-LISP:RETURN P)) (COMMON-LISP:LET ((FOUND (PROBE-FILE* P :TRUENAME COMMON-LISP:T))) (COMMON-LISP:WHEN FOUND (COMMON-LISP:RETURN FOUND))) (COMMON-LISP:LET* ((COMMON-LISP:DIRECTORY (NORMALIZE-PATHNAME-DIRECTORY-COMPONENT (COMMON-LISP:PATHNAME-DIRECTORY P))) (UP-COMPONENTS (COMMON-LISP:REVERSE (COMMON-LISP:REST COMMON-LISP:DIRECTORY))) (DOWN-COMPONENTS COMMON-LISP:NIL)) (COMMON-LISP:ASSERT (COMMON-LISP:EQ :ABSOLUTE (COMMON-LISP:FIRST COMMON-LISP:DIRECTORY))) (COMMON-LISP:LOOP :WHILE UP-COMPONENTS :DO (IF-LET (PARENT (COMMON-LISP:IGNORE-ERRORS (PROBE-FILE* (MAKE-PATHNAME* :DIRECTORY (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :ABSOLUTE) (COMMON-LISP:REVERSE UP-COMPONENTS)) :NAME COMMON-LISP:NIL :TYPE COMMON-LISP:NIL :VERSION COMMON-LISP:NIL :DEFAULTS P)))) (IF-LET (SIMPLIFIED (COMMON-LISP:IGNORE-ERRORS (MERGE-PATHNAMES* (MAKE-PATHNAME* :DIRECTORY (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :RELATIVE) DOWN-COMPONENTS) :DEFAULTS P) (ENSURE-DIRECTORY-PATHNAME PARENT)))) (COMMON-LISP:RETURN SIMPLIFIED))) (COMMON-LISP:PUSH (COMMON-LISP:POP UP-COMPONENTS) DOWN-COMPONENTS) :FINALLY (COMMON-LISP:RETURN P)))))) (COMMON-LISP:DEFUN RESOLVE-SYMLINKS (PATH) "Do a best effort at resolving symlinks in PATH, returning a partially or totally resolved PATH." (TRUENAMIZE PATH)) (COMMON-LISP:DEFVAR *RESOLVE-SYMLINKS* COMMON-LISP:T "Determine whether or not ASDF resolves symlinks when defining systems.
     [java] Defaults to T.") (COMMON-LISP:DEFUN RESOLVE-SYMLINKS* (PATH) "RESOLVE-SYMLINKS in PATH iff *RESOLVE-SYMLINKS* is T (the default)." (COMMON-LISP:IF *RESOLVE-SYMLINKS* (COMMON-LISP:AND PATH (RESOLVE-SYMLINKS PATH)) PATH)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ENSURE-PATHNAME (COMMON-LISP:PATHNAME COMMON-LISP:&KEY ON-ERROR DEFAULTS COMMON-LISP:TYPE DOT-DOT COMMON-LISP:NAMESTRING EMPTY-IS-NIL WANT-PATHNAME WANT-LOGICAL WANT-PHYSICAL ENSURE-PHYSICAL WANT-RELATIVE WANT-ABSOLUTE ENSURE-ABSOLUTE ENSURE-SUBPATH WANT-NON-WILD WANT-WILD WILDEN WANT-FILE WANT-DIRECTORY ENSURE-DIRECTORY WANT-EXISTING COMMON-LISP:ENSURE-DIRECTORIES-EXIST COMMON-LISP:TRUENAME RESOLVE-SYMLINKS TRUENAMIZE COMMON-LISP:&AUX (P COMMON-LISP:PATHNAME)) "Coerces its argument into a PATHNAME,
     [java] optionally doing some transformations and checking specified constraints.
     [java]
     [java] If the argument is NIL, then NIL is returned unless the WANT-PATHNAME constraint is specified.
     [java]
     [java] If the argument is a STRING, it is first converted to a pathname via
     [java] PARSE-UNIX-NAMESTRING, PARSE-NAMESTRING or PARSE-NATIVE-NAMESTRING respectively
     [java] depending on the NAMESTRING argument being :UNIX, :LISP or :NATIVE respectively,
     [java] or else by using CALL-FUNCTION on the NAMESTRING argument;
     [java] if :UNIX is specified (or NIL, the default, which specifies the same thing),
     [java] then PARSE-UNIX-NAMESTRING it is called with the keywords
     [java] DEFAULTS TYPE DOT-DOT ENSURE-DIRECTORY WANT-RELATIVE, and
     [java] the result is optionally merged into the DEFAULTS if ENSURE-ABSOLUTE is true.
     [java]
     [java] The pathname passed or resulting from parsing the string
     [java] is then subjected to all the checks and transformations below are run.
     [java]
     [java] Each non-nil constraint argument can be one of the symbols T, ERROR, CERROR or IGNORE.
     [java] The boolean T is an alias for ERROR.
     [java] ERROR means that an error will be raised if the constraint is not satisfied.
     [java] CERROR means that an continuable error will be raised if the constraint is not satisfied.
     [java] IGNORE means just return NIL instead of the pathname.
     [java]
     [java] The ON-ERROR argument, if not NIL, is a function designator (as per CALL-FUNCTION)
     [java] that will be called with the the following arguments:
     [java] a generic format string for ensure pathname, the pathname,
     [java] the keyword argument corresponding to the failed check or transformation,
     [java] a format string for the reason ENSURE-PATHNAME failed,
     [java] and a list with arguments to that format string.
     [java] If ON-ERROR is NIL, ERROR is used instead, which does the right thing.
     [java] You could also pass (CERROR \"CONTINUE DESPITE FAILED CHECK\").
     [java]
     [java] The transformations and constraint checks are done in this order,
     [java] which is also the order in the lambda-list:
     [java]
     [java] EMPTY-IS-NIL returns NIL if the argument is an empty string.
     [java] WANT-PATHNAME checks that pathname (after parsing if needed) is not null.
     [java] Otherwise, if the pathname is NIL, ensure-pathname returns NIL.
     [java] WANT-LOGICAL checks that pathname is a LOGICAL-PATHNAME
     [java] WANT-PHYSICAL checks that pathname is not a LOGICAL-PATHNAME
     [java] ENSURE-PHYSICAL ensures that pathname is physical via TRANSLATE-LOGICAL-PATHNAME
     [java] WANT-RELATIVE checks that pathname has a relative directory component
     [java] WANT-ABSOLUTE checks that pathname does have an absolute directory component
     [java] ENSURE-ABSOLUTE merges with the DEFAULTS, then checks again
     [java] that the result absolute is an absolute pathname indeed.
     [java] ENSURE-SUBPATH checks that the pathname is a subpath of the DEFAULTS.
     [java] WANT-FILE checks that pathname has a non-nil FILE component
     [java] WANT-DIRECTORY checks that pathname has nil FILE and TYPE components
     [java] ENSURE-DIRECTORY uses ENSURE-DIRECTORY-PATHNAME to interpret
     [java] any file and type components as being actually a last directory component.
     [java] WANT-NON-WILD checks that pathname is not a wild pathname
     [java] WANT-WILD checks that pathname is a wild pathname
     [java] WILDEN merges the pathname with **/*.*.* if it is not wild
     [java] WANT-EXISTING checks that a file (or directory) exists with that pathname.
     [java] ENSURE-DIRECTORIES-EXIST creates any parent directory with ENSURE-DIRECTORIES-EXIST.
     [java] TRUENAME replaces the pathname by its truename, or errors if not possible.
     [java] RESOLVE-SYMLINKS replaces the pathname by a variant with symlinks resolved by RESOLVE-SYMLINKS.
     [java] TRUENAMIZE uses TRUENAMIZE to resolve as many symlinks as possible." (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:FLET ((REPORT-ERROR (COMMON-LISP:KEYWORD DESCRIPTION COMMON-LISP:&REST ARGUMENTS) (CALL-FUNCTION (COMMON-LISP:OR ON-ERROR (COMMON-LISP:QUOTE COMMON-LISP:ERROR)) "Invalid pathname ~S: ~*~?" COMMON-LISP:PATHNAME COMMON-LISP:KEYWORD DESCRIPTION ARGUMENTS))) (COMMON-LISP:MACROLET ((ERR (CONSTRAINT COMMON-LISP:&REST ARGUMENTS) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE REPORT-ERROR) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) (INTERN* CONSTRAINT :KEYWORD)) ARGUMENTS)) (CHECK (CONSTRAINT COMMON-LISP:CONDITION COMMON-LISP:&REST ARGUMENTS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:WHEN) CONSTRAINT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:UNLESS) COMMON-LISP:CONDITION (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE ERR) CONSTRAINT ARGUMENTS)))) (TRANSFORM (TRANSFORM COMMON-LISP:CONDITION EXPR) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:WHEN) TRANSFORM (SYSTEM::BACKQ-APPEND (COMMON-LISP:IF COMMON-LISP:CONDITION (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:WHEN) COMMON-LISP:CONDITION) (COMMON-LISP:QUOTE (COMMON-LISP:PROGN))) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:SETF) (COMMON-LISP:QUOTE P) EXPR)))))) (COMMON-LISP:ETYPECASE P ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:PATHNAME)) (COMMON-LISP:STRING (COMMON-LISP:WHEN (COMMON-LISP:AND (EMPTYP P) EMPTY-IS-NIL) (COMMON-LISP:RETURN-FROM ENSURE-PATHNAME COMMON-LISP:NIL)) (COMMON-LISP:SETF P (COMMON-LISP:CASE COMMON-LISP:NAMESTRING ((:UNIX COMMON-LISP:NIL) (PARSE-UNIX-NAMESTRING P :DEFAULTS DEFAULTS :TYPE COMMON-LISP:TYPE :DOT-DOT DOT-DOT :ENSURE-DIRECTORY ENSURE-DIRECTORY :WANT-RELATIVE WANT-RELATIVE)) ((:NATIVE) (PARSE-NATIVE-NAMESTRING P)) ((:LISP) (COMMON-LISP:PARSE-NAMESTRING P)) (COMMON-LISP:T (CALL-FUNCTION COMMON-LISP:NAMESTRING P)))))) (COMMON-LISP:ETYPECASE P (COMMON-LISP:PATHNAME) (COMMON-LISP:NULL (CHECK WANT-PATHNAME (COMMON-LISP:PATHNAMEP P) "Expected a pathname, not NIL") (COMMON-LISP:RETURN COMMON-LISP:NIL))) (CHECK WANT-LOGICAL (LOGICAL-PATHNAME-P P) "Expected a logical pathname") (CHECK WANT-PHYSICAL (PHYSICAL-PATHNAME-P P) "Expected a physical pathname") (TRANSFORM ENSURE-PHYSICAL COMMON-LISP:NIL (PHYSICALIZE-PATHNAME P)) (CHECK ENSURE-PHYSICAL (PHYSICAL-PATHNAME-P P) "Could not translate to a physical pathname") (CHECK WANT-RELATIVE (RELATIVE-PATHNAME-P P) "Expected a relative pathname") (CHECK WANT-ABSOLUTE (ABSOLUTE-PATHNAME-P P) "Expected an absolute pathname") (TRANSFORM ENSURE-ABSOLUTE (COMMON-LISP:NOT (ABSOLUTE-PATHNAME-P P)) (ENSURE-ABSOLUTE-PATHNAME P DEFAULTS (COMMON-LISP:LIST (COMMON-LISP:FUNCTION REPORT-ERROR) :ENSURE-ABSOLUTE "~@?"))) (CHECK ENSURE-ABSOLUTE (ABSOLUTE-PATHNAME-P P) "Could not make into an absolute pathname even after merging with ~S" DEFAULTS) (CHECK ENSURE-SUBPATH (ABSOLUTE-PATHNAME-P DEFAULTS) "cannot be checked to be a subpath of non-absolute pathname ~S" DEFAULTS) (CHECK ENSURE-SUBPATH (SUBPATHP P DEFAULTS) "is not a sub pathname of ~S" DEFAULTS) (CHECK WANT-FILE (FILE-PATHNAME-P P) "Expected a file pathname") (CHECK WANT-DIRECTORY (DIRECTORY-PATHNAME-P P) "Expected a directory pathname") (TRANSFORM ENSURE-DIRECTORY (COMMON-LISP:NOT (DIRECTORY-PATHNAME-P P)) (ENSURE-DIRECTORY-PATHNAME P)) (CHECK WANT-NON-WILD (COMMON-LISP:NOT (COMMON-LISP:WILD-PATHNAME-P P)) "Expected a non-wildcard pathname") (CHECK WANT-WILD (COMMON-LISP:WILD-PATHNAME-P P) "Expected a wildcard pathname") (TRANSFORM WILDEN (COMMON-LISP:NOT (COMMON-LISP:WILD-PATHNAME-P P)) (WILDEN P)) (COMMON-LISP:WHEN WANT-EXISTING (COMMON-LISP:LET ((EXISTING (PROBE-FILE* P :TRUENAME COMMON-LISP:TRUENAME))) (COMMON-LISP:IF EXISTING (COMMON-LISP:WHEN COMMON-LISP:TRUENAME (COMMON-LISP:RETURN EXISTING)) (ERR WANT-EXISTING "Expected an existing pathname")))) (COMMON-LISP:WHEN COMMON-LISP:ENSURE-DIRECTORIES-EXIST (COMMON-LISP:ENSURE-DIRECTORIES-EXIST P)) (COMMON-LISP:WHEN COMMON-LISP:TRUENAME (COMMON-LISP:LET ((COMMON-LISP:TRUENAME (TRUENAME* P))) (COMMON-LISP:IF COMMON-LISP:TRUENAME (COMMON-LISP:RETURN COMMON-LISP:TRUENAME) (ERR COMMON-LISP:TRUENAME "Can't get a truename for pathname")))) (TRANSFORM RESOLVE-SYMLINKS COMMON-LISP:NIL (RESOLVE-SYMLINKS P)) (TRANSFORM TRUENAMIZE COMMON-LISP:NIL (TRUENAMIZE P)) P)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN GET-PATHNAME-DEFAULTS (COMMON-LISP:&OPTIONAL (DEFAULTS COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS*)) "Find the actual DEFAULTS to use for pathnames, including
     [java] resolving them with respect to GETCWD if the DEFAULTS were relative" (COMMON-LISP:OR (ABSOLUTE-PATHNAME-P DEFAULTS) (MERGE-PATHNAMES* DEFAULTS (GETCWD)))) (COMMON-LISP:DEFUN CALL-WITH-CURRENT-DIRECTORY (DIR THUNK) "call the THUNK in a context where the current directory was changed to DIR, if not NIL.
     [java] Note that this operation is usually NOT thread-safe." (COMMON-LISP:IF DIR (COMMON-LISP:LET* ((DIR (RESOLVE-SYMLINKS* (GET-PATHNAME-DEFAULTS (PATHNAME-DIRECTORY-PATHNAME DIR)))) (CWD (GETCWD)) (COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS* DIR)) (CHDIR DIR) (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:FUNCALL THUNK) (CHDIR CWD))) (COMMON-LISP:FUNCALL THUNK))) (COMMON-LISP:DEFMACRO WITH-CURRENT-DIRECTORY ((COMMON-LISP:&OPTIONAL DIR) COMMON-LISP:&BODY BODY) "Call BODY while the POSIX current working directory is set to DIR" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-CURRENT-DIRECTORY) DIR (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN INTER-DIRECTORY-SEPARATOR COMMON-LISP:NIL "What character does the current OS conventionally uses to separate directories?" (OS-COND ((OS-UNIX-P) #\:) (COMMON-LISP:T #\;))) (COMMON-LISP:DEFUN SPLIT-NATIVE-PATHNAMES-STRING (COMMON-LISP:STRING COMMON-LISP:&REST CONSTRAINTS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) "Given a string of pathnames specified in native OS syntax, separate them in a list,
     [java] check constraints and normalize each one as per ENSURE-PATHNAME,
     [java] where an empty string denotes NIL." (COMMON-LISP:LOOP :FOR COMMON-LISP:NAMESTRING :IN (SPLIT-STRING COMMON-LISP:STRING :SEPARATOR (COMMON-LISP:STRING (INTER-DIRECTORY-SEPARATOR))) :COLLECT (COMMON-LISP:UNLESS (EMPTYP COMMON-LISP:NAMESTRING) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE PARSE-NATIVE-NAMESTRING) COMMON-LISP:NAMESTRING CONSTRAINTS)))) (COMMON-LISP:DEFUN GETENV-PATHNAME (X COMMON-LISP:&REST CONSTRAINTS COMMON-LISP:&KEY ENSURE-DIRECTORY WANT-DIRECTORY ON-ERROR COMMON-LISP:&ALLOW-OTHER-KEYS) "Extract a pathname from a user-configured environment variable, as per native OS,
     [java] check constraints and normalize as per ENSURE-PATHNAME." (COMMON-LISP:APPLY (COMMON-LISP:QUOTE PARSE-NATIVE-NAMESTRING) (GETENVP X) :ENSURE-DIRECTORY (COMMON-LISP:OR ENSURE-DIRECTORY WANT-DIRECTORY) :ON-ERROR (COMMON-LISP:OR ON-ERROR (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:ERROR) "In (~S ~S), invalid pathname ~*~S: ~*~?" (COMMON-LISP:QUOTE GETENV-PATHNAME) X)) CONSTRAINTS)) (COMMON-LISP:DEFUN GETENV-PATHNAMES (X COMMON-LISP:&REST CONSTRAINTS COMMON-LISP:&KEY ON-ERROR COMMON-LISP:&ALLOW-OTHER-KEYS) "Extract a list of pathname from a user-configured environment variable, as per native OS,
     [java] check constraints and normalize each one as per ENSURE-PATHNAME.
     [java]        Any empty entries in the environment variable X will be returned as NILs." (COMMON-LISP:UNLESS (COMMON-LISP:GETF CONSTRAINTS :EMPTY-IS-NIL COMMON-LISP:T) (COMMON-LISP:ERROR "Cannot have EMPTY-IS-NIL false for GETENV-PATHNAMES.")) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE SPLIT-NATIVE-PATHNAMES-STRING) (GETENVP X) :ON-ERROR (COMMON-LISP:OR ON-ERROR (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:ERROR) "In (~S ~S), invalid pathname ~*~S: ~*~?" (COMMON-LISP:QUOTE GETENV-PATHNAMES) X)) :EMPTY-IS-NIL COMMON-LISP:T CONSTRAINTS)) (COMMON-LISP:DEFUN GETENV-ABSOLUTE-DIRECTORY (X) "Extract an absolute directory pathname from a user-configured environment variable,
     [java] as per native OS" (GETENV-PATHNAME X :WANT-ABSOLUTE COMMON-LISP:T :ENSURE-DIRECTORY COMMON-LISP:T)) (COMMON-LISP:DEFUN GETENV-ABSOLUTE-DIRECTORIES (X) "Extract a list of absolute directories from a user-configured environment variable,
     [java] as per native OS.  Any empty entries in the environment variable X will be returned as
     [java] NILs." (GETENV-PATHNAMES X :WANT-ABSOLUTE COMMON-LISP:T :ENSURE-DIRECTORY COMMON-LISP:T)) (COMMON-LISP:DEFUN LISP-IMPLEMENTATION-DIRECTORY (COMMON-LISP:&KEY COMMON-LISP:TRUENAME) "Where are the system files of the current installation of the CL implementation?" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:TRUENAME)) (COMMON-LISP:LET ((DIR EXTENSIONS:*LISP-HOME*)) (COMMON-LISP:IF (COMMON-LISP:AND DIR COMMON-LISP:TRUENAME) (TRUENAME* DIR) DIR))) (COMMON-LISP:DEFUN LISP-IMPLEMENTATION-PATHNAME-P (COMMON-LISP:PATHNAME) "Is the PATHNAME under the current installation of the CL implementation?" (COMMON-LISP:AND (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (IF-LET (IMPDIR (LISP-IMPLEMENTATION-DIRECTORY)) (COMMON-LISP:OR (SUBPATHP COMMON-LISP:PATHNAME IMPDIR) (COMMON-LISP:WHEN *RESOLVE-SYMLINKS* (IF-LET (COMMON-LISP:TRUENAME (TRUENAME* COMMON-LISP:PATHNAME)) (IF-LET (TRUEIMPDIR (TRUENAME* IMPDIR)) (SUBPATHP COMMON-LISP:TRUENAME TRUEIMPDIR))))))) COMMON-LISP:T)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ENSURE-ALL-DIRECTORIES-EXIST (PATHNAMES) "Ensure that for every pathname in PATHNAMES, we ensure its directories exist" (COMMON-LISP:DOLIST (COMMON-LISP:PATHNAME PATHNAMES) (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:ENSURE-DIRECTORIES-EXIST (PHYSICALIZE-PATHNAME COMMON-LISP:PATHNAME))))) (COMMON-LISP:DEFUN DELETE-FILE-IF-EXISTS (X) "Delete a file X if it already exists" (COMMON-LISP:WHEN X (COMMON-LISP:HANDLER-CASE (COMMON-LISP:DELETE-FILE X) (COMMON-LISP:FILE-ERROR COMMON-LISP:NIL COMMON-LISP:NIL)))) (COMMON-LISP:DEFUN RENAME-FILE-OVERWRITING-TARGET (SOURCE TARGET) "Rename a file, overwriting any previous file with the TARGET name,
     [java] in an atomic way if the implementation allows." (COMMON-LISP:RENAME-FILE SOURCE TARGET)) (COMMON-LISP:DEFUN DELETE-EMPTY-DIRECTORY (DIRECTORY-PATHNAME) "Delete an empty directory" (COMMON-LISP:DELETE-FILE DIRECTORY-PATHNAME)) (COMMON-LISP:DEFUN DELETE-DIRECTORY-TREE (DIRECTORY-PATHNAME COMMON-LISP:&KEY (VALIDATE COMMON-LISP:NIL VALIDATEP) (IF-DOES-NOT-EXIST :ERROR)) "Delete a directory including all its recursive contents, aka rm -rf.
     [java]
     [java] To reduce the risk of infortunate mistakes, DIRECTORY-PATHNAME must be
     [java] a physical non-wildcard directory pathname (not namestring).
     [java]
     [java] If the directory does not exist, the IF-DOES-NOT-EXIST argument specifies what happens:
     [java] if it is :ERROR (the default), an error is signaled, whereas if it is :IGNORE, nothing is done.
     [java]
     [java] Furthermore, before any deletion is attempted, the DIRECTORY-PATHNAME must pass
     [java] the validation function designated (as per ENSURE-FUNCTION) by the VALIDATE keyword argument
     [java] which in practice is thus compulsory, and validates by returning a non-NIL result.
     [java] If you're suicidal or extremely confident, just use :VALIDATE T." (COMMON-LISP:CHECK-TYPE IF-DOES-NOT-EXIST (COMMON-LISP:MEMBER :ERROR :IGNORE)) (COMMON-LISP:COND ((COMMON-LISP:NOT (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP DIRECTORY-PATHNAME) (DIRECTORY-PATHNAME-P DIRECTORY-PATHNAME) (PHYSICAL-PATHNAME-P DIRECTORY-PATHNAME) (COMMON-LISP:NOT (COMMON-LISP:WILD-PATHNAME-P DIRECTORY-PATHNAME)))) (COMMON-LISP:ERROR "~S was asked to delete ~S but it is not a physical non-wildcard directory pathname" (COMMON-LISP:QUOTE DELETE-DIRECTORY-TREE) DIRECTORY-PATHNAME)) ((COMMON-LISP:NOT VALIDATEP) (COMMON-LISP:ERROR "~S was asked to delete ~S but was not provided a validation predicate" (COMMON-LISP:QUOTE DELETE-DIRECTORY-TREE) DIRECTORY-PATHNAME)) ((COMMON-LISP:NOT (CALL-FUNCTION VALIDATE DIRECTORY-PATHNAME)) (COMMON-LISP:ERROR "~S was asked to delete ~S but it is not valid ~@[according to ~S~]" (COMMON-LISP:QUOTE DELETE-DIRECTORY-TREE) DIRECTORY-PATHNAME VALIDATE)) ((COMMON-LISP:NOT (DIRECTORY-EXISTS-P DIRECTORY-PATHNAME)) (COMMON-LISP:ECASE IF-DOES-NOT-EXIST (:ERROR (COMMON-LISP:ERROR "~S was asked to delete ~S but the directory does not exist" (COMMON-LISP:QUOTE DELETE-DIRECTORY-TREE) DIRECTORY-PATHNAME)) (:IGNORE COMMON-LISP:NIL))) ((OS-UNIX-P) (SYMBOL-CALL :UIOP :RUN-PROGRAM (SYSTEM::BACKQ-LIST "rm" "-rf" (NATIVE-NAMESTRING DIRECTORY-PATHNAME)))) (COMMON-LISP:T (COMMON-LISP:LET ((SUB*DIRECTORIES (WHILE-COLLECTING (C) (COLLECT-SUB*DIRECTORIES DIRECTORY-PATHNAME COMMON-LISP:T COMMON-LISP:T (COMMON-LISP:FUNCTION C))))) (COMMON-LISP:DOLIST (D (COMMON-LISP:NREVERSE SUB*DIRECTORIES)) (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:QUOTE COMMON-LISP:DELETE-FILE) (DIRECTORY-FILES D)) (DELETE-EMPTY-DIRECTORY D)))))))
     [java] ; (DEFINE-PACKAGE :UIOP/STREAM (:NICKNAMES :ASDF/STREAM) (:RECYCLE :UIOP/STREAM :ASDF/STREAM :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/OS :UIOP/PATHNAME :UIOP/FILESYSTEM) (:EXPORT #:*DEFAULT-STREAM-ELEMENT-TYPE* #:*STDIN* #:SETUP-STDIN #:*STDOUT* #:SETUP-STDOUT #:*STDERR* #:SETUP-STDERR #:DETECT-ENCODING #:*ENCODING-DETECTION-HOOK* #:ALWAYS-DEFAULT-ENCODING #:ENCODING-EXTERNAL-FORMAT #:*ENCODING-EXTERNAL-FORMAT-HOOK* #:DEFAULT-ENCODING-EXTERNAL-FORMAT #:*DEFAULT-ENCODING* #:*UTF-8-EXTERNAL-FORMAT* #:WITH-SAFE-IO-SYNTAX #:CALL-WITH-SAFE-IO-SYNTAX #:SAFE-READ-FROM-STRING #:WITH-OUTPUT #:OUTPUT-STRING #:WITH-INPUT #:INPUT-STRING #:WITH-INPUT-FILE #:CALL-WITH-INPUT-FILE #:WITH-OUTPUT-FILE #:CALL-WITH-OUTPUT-FILE #:NULL-DEVICE-PATHNAME #:CALL-WITH-NULL-INPUT #:WITH-NULL-INPUT #:CALL-WITH-NULL-OUTPUT #:WITH-NULL-OUTPUT #:FINISH-OUTPUTS #:FORMAT! #:SAFE-FORMAT! #:COPY-STREAM-TO-STREAM #:CONCATENATE-FILES #:COPY-FILE #:SLURP-STREAM-STRING #:SLURP-STREAM-LINES #:SLURP-STREAM-LINE #:SLURP-STREAM-FORMS #:SLURP-STREAM-FORM #:READ-FILE-STRING #:READ-FILE-LINE #:READ-FILE-LINES #:SAFE-READ-FILE-LINE #:READ-FILE-FORMS #:READ-FILE-FORM #:SAFE-READ-FILE-FORM #:EVAL-INPUT #:EVAL-THUNK #:STANDARD-EVAL-THUNK #:PRINTLN #:WRITELN #:*TEMPORARY-DIRECTORY* #:TEMPORARY-DIRECTORY #:DEFAULT-TEMPORARY-DIRECTORY #:SETUP-TEMPORARY-DIRECTORY #:CALL-WITH-TEMPORARY-FILE #:WITH-TEMPORARY-FILE #:ADD-PATHNAME-SUFFIX #:TMPIZE-PATHNAME #:CALL-WITH-STAGING-PATHNAME #:WITH-STAGING-PATHNAME))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/STREAM)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *DEFAULT-STREAM-ELEMENT-TYPE* (COMMON-LISP:OR (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER) :DEFAULT) "default element-type for open (depends on the current CL implementation)") (COMMON-LISP:DEFVAR *STDIN* COMMON-LISP:*STANDARD-INPUT* "the original standard input stream at startup") (COMMON-LISP:DEFUN SETUP-STDIN COMMON-LISP:NIL (COMMON-LISP:SETF *STDIN* COMMON-LISP:*STANDARD-INPUT*)) (COMMON-LISP:DEFVAR *STDOUT* COMMON-LISP:*STANDARD-OUTPUT* "the original standard output stream at startup") (COMMON-LISP:DEFUN SETUP-STDOUT COMMON-LISP:NIL (COMMON-LISP:SETF *STDOUT* COMMON-LISP:*STANDARD-OUTPUT*)) (COMMON-LISP:DEFVAR *STDERR* COMMON-LISP:*ERROR-OUTPUT* "the original error output stream at startup") (COMMON-LISP:DEFUN SETUP-STDERR COMMON-LISP:NIL (COMMON-LISP:SETF *STDERR* COMMON-LISP:*ERROR-OUTPUT*)) (SETUP-STDIN) (SETUP-STDOUT) (SETUP-STDERR))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER *DEFAULT-ENCODING* (COMMON-LISP:OR (IF-LET (PREVIOUS (COMMON-LISP:AND (COMMON-LISP:BOUNDP (COMMON-LISP:QUOTE *DEFAULT-ENCODING*)) (COMMON-LISP:SYMBOL-VALUE (COMMON-LISP:QUOTE *DEFAULT-ENCODING*)))) (COMMON-LISP:UNLESS (COMMON-LISP:EQ PREVIOUS :DEFAULT) PREVIOUS)) :UTF-8) "Default encoding for source files.
     [java] The default value :utf-8 is the portable thing.
     [java] The legacy behavior was :default.
     [java] If you (asdf:load-system :asdf-encodings) then
     [java] you will have autodetection via *encoding-detection-hook* below,
     [java] reading emacs-style -*- coding: utf-8 -*- specifications,
     [java] and falling back to utf-8 or latin1 if nothing is specified.") (COMMON-LISP:DEFPARAMETER *UTF-8-EXTERNAL-FORMAT* (COMMON-LISP:IF (FEATUREP :ASDF-UNICODE) (COMMON-LISP:OR :UTF-8) :DEFAULT) "Default :external-format argument to pass to CL:OPEN and also
     [java] CL:LOAD or CL:COMPILE-FILE to best process a UTF-8 encoded file.
     [java] On modern implementations, this will decode UTF-8 code points as CL characters.
     [java] On legacy implementations, it may fall back on some 8-bit encoding,
     [java] with non-ASCII code points being read as several CL characters;
     [java] hopefully, if done consistently, that won't affect program behavior too much.") (COMMON-LISP:DEFUN ALWAYS-DEFAULT-ENCODING (COMMON-LISP:PATHNAME) "Trivial function to use as *encoding-detection-hook*,
     [java] always 'detects' the *default-encoding*" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE COMMON-LISP:PATHNAME)) *DEFAULT-ENCODING*) (COMMON-LISP:DEFVAR *ENCODING-DETECTION-HOOK* (COMMON-LISP:FUNCTION ALWAYS-DEFAULT-ENCODING) "Hook for an extension to define a function to automatically detect a file's encoding") (COMMON-LISP:DEFUN DETECT-ENCODING (COMMON-LISP:PATHNAME) "Detects the encoding of a specified file, going through user-configurable hooks" (COMMON-LISP:IF (COMMON-LISP:AND COMMON-LISP:PATHNAME (COMMON-LISP:NOT (DIRECTORY-PATHNAME-P COMMON-LISP:PATHNAME)) (PROBE-FILE* COMMON-LISP:PATHNAME)) (COMMON-LISP:FUNCALL *ENCODING-DETECTION-HOOK* COMMON-LISP:PATHNAME) *DEFAULT-ENCODING*)) (COMMON-LISP:DEFUN DEFAULT-ENCODING-EXTERNAL-FORMAT (ENCODING) "Default, ignorant, function to transform a character ENCODING as a
     [java] portable keyword to an implementation-dependent EXTERNAL-FORMAT specification.
     [java] Load system ASDF-ENCODINGS to hook in a better one." (COMMON-LISP:CASE ENCODING (:DEFAULT :DEFAULT) (:UTF-8 *UTF-8-EXTERNAL-FORMAT*) (COMMON-LISP:OTHERWISE (COMMON-LISP:CERROR "Continue using :external-format :default" (UIOP/COMMON-LISP::COMPATFMT "~@<Your ASDF component is using encoding ~S but it isn't recognized. Your system should :defsystem-depends-on (:asdf-encodings).~:>") ENCODING) :DEFAULT))) (COMMON-LISP:DEFVAR *ENCODING-EXTERNAL-FORMAT-HOOK* (COMMON-LISP:FUNCTION DEFAULT-ENCODING-EXTERNAL-FORMAT) "Hook for an extension (e.g. ASDF-ENCODINGS) to define a better mapping
     [java] from non-default encodings to and implementation-defined external-format's") (COMMON-LISP:DEFUN ENCODING-EXTERNAL-FORMAT (ENCODING) "Transform a portable ENCODING keyword to an implementation-dependent EXTERNAL-FORMAT,
     [java] going through all the proper hooks." (COMMON-LISP:FUNCALL *ENCODING-EXTERNAL-FORMAT-HOOK* (COMMON-LISP:OR ENCODING *DEFAULT-ENCODING*))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *STANDARD-READTABLE* (COMMON-LISP:WITH-STANDARD-IO-SYNTAX COMMON-LISP:*READTABLE*) "The standard readtable, implementing the syntax specified by the CLHS.
     [java] It must never be modified, though only good implementations will even enforce that.") (COMMON-LISP:DEFMACRO WITH-SAFE-IO-SYNTAX ((COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL)) COMMON-LISP:&BODY BODY) "Establish safe CL reader options around the evaluation of BODY" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-SAFE-IO-SYNTAX) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:*PACKAGE*) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FIND-PACKAGE) COMMON-LISP:PACKAGE))) BODY))))) (COMMON-LISP:DEFUN CALL-WITH-SAFE-IO-SYNTAX (THUNK COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL)) (COMMON-LISP:WITH-STANDARD-IO-SYNTAX (COMMON-LISP:LET ((COMMON-LISP:*PACKAGE* (COMMON-LISP:FIND-PACKAGE COMMON-LISP:PACKAGE)) (COMMON-LISP:*READ-DEFAULT-FLOAT-FORMAT* (COMMON-LISP:QUOTE COMMON-LISP:DOUBLE-FLOAT)) (COMMON-LISP:*PRINT-READABLY* COMMON-LISP:NIL) (COMMON-LISP:*READ-EVAL* COMMON-LISP:NIL)) (COMMON-LISP:FUNCALL THUNK)))) (COMMON-LISP:DEFUN SAFE-READ-FROM-STRING (COMMON-LISP:STRING COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL) (EOF-ERROR-P COMMON-LISP:T) EOF-VALUE (START 0) END PRESERVE-WHITESPACE) "Read from STRING using a safe syntax, as per WITH-SAFE-IO-SYNTAX" (WITH-SAFE-IO-SYNTAX (:PACKAGE COMMON-LISP:PACKAGE) (COMMON-LISP:READ-FROM-STRING COMMON-LISP:STRING EOF-ERROR-P EOF-VALUE :START START :END END :PRESERVE-WHITESPACE PRESERVE-WHITESPACE))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CALL-WITH-OUTPUT-FILE (COMMON-LISP:PATHNAME THUNK COMMON-LISP:&KEY (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (IF-EXISTS :ERROR) (IF-DOES-NOT-EXIST :CREATE)) "Open FILE for input with given recognizes options, call THUNK with the resulting stream.
     [java] Other keys are accepted but discarded." (COMMON-LISP:WITH-OPEN-FILE (S COMMON-LISP:PATHNAME :DIRECTION :OUTPUT :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-EXISTS IF-EXISTS :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST) (COMMON-LISP:FUNCALL THUNK S))) (COMMON-LISP:DEFMACRO WITH-OUTPUT-FILE ((VAR COMMON-LISP:PATHNAME COMMON-LISP:&REST KEYS COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT IF-EXISTS IF-DOES-NOT-EXIST) COMMON-LISP:&BODY BODY) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE ELEMENT-TYPE EXTERNAL-FORMAT IF-EXISTS IF-DOES-NOT-EXIST)) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE CALL-WITH-OUTPUT-FILE) COMMON-LISP:PATHNAME (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST VAR) BODY)) KEYS)) (COMMON-LISP:DEFUN CALL-WITH-OUTPUT (OUTPUT COMMON-LISP:FUNCTION COMMON-LISP:&KEY KEYS) "Calls FUNCTION with an actual stream argument,
     [java] behaving like FORMAT with respect to how stream designators are interpreted:
     [java] If OUTPUT is a STREAM, use it as the stream.
     [java] If OUTPUT is NIL, use a STRING-OUTPUT-STREAM as the stream, and return the resulting string.
     [java] If OUTPUT is T, use *STANDARD-OUTPUT* as the stream.
     [java] If OUTPUT is a STRING with a fill-pointer, use it as a string-output-stream.
     [java] If OUTPUT is a PATHNAME, open the file and write to it, passing KEYS to WITH-OUTPUT-FILE
     [java] -- this latter as an extension since ASDF 3.1.
     [java] Otherwise, signal an error." (COMMON-LISP:ETYPECASE OUTPUT (COMMON-LISP:NULL (COMMON-LISP:WITH-OUTPUT-TO-STRING (COMMON-LISP:STREAM) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:STREAM))) ((COMMON-LISP:EQL COMMON-LISP:T) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:*STANDARD-OUTPUT*)) (COMMON-LISP:STREAM (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION OUTPUT)) (COMMON-LISP:STRING (COMMON-LISP:ASSERT (COMMON-LISP:FILL-POINTER OUTPUT)) (COMMON-LISP:WITH-OUTPUT-TO-STRING (COMMON-LISP:STREAM OUTPUT) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:STREAM))) (COMMON-LISP:PATHNAME (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-OUTPUT-FILE) OUTPUT COMMON-LISP:FUNCTION KEYS)))) (COMMON-LISP:DEFMACRO WITH-OUTPUT ((OUTPUT-VAR COMMON-LISP:&OPTIONAL (VALUE OUTPUT-VAR)) COMMON-LISP:&BODY BODY) "Bind OUTPUT-VAR to an output stream, coercing VALUE (default: previous binding of OUTPUT-VAR)
     [java] as per FORMAT, and evaluate BODY within the scope of this binding." (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-OUTPUT) VALUE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST OUTPUT-VAR) BODY)))) (COMMON-LISP:DEFUN OUTPUT-STRING (COMMON-LISP:STRING COMMON-LISP:&OPTIONAL OUTPUT) "If the desired OUTPUT is not NIL, print the string to the output; otherwise return the string" (COMMON-LISP:IF OUTPUT (WITH-OUTPUT (OUTPUT) (COMMON-LISP:PRINC COMMON-LISP:STRING OUTPUT)) COMMON-LISP:STRING)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CALL-WITH-INPUT-FILE (COMMON-LISP:PATHNAME THUNK COMMON-LISP:&KEY (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (IF-DOES-NOT-EXIST :ERROR)) "Open FILE for input with given recognizes options, call THUNK with the resulting stream.
     [java] Other keys are accepted but discarded." (COMMON-LISP:WITH-OPEN-FILE (S COMMON-LISP:PATHNAME :DIRECTION :INPUT :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST) (COMMON-LISP:FUNCALL THUNK S))) (COMMON-LISP:DEFMACRO WITH-INPUT-FILE ((VAR COMMON-LISP:PATHNAME COMMON-LISP:&REST KEYS COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST) COMMON-LISP:&BODY BODY) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST)) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) COMMON-LISP:PATHNAME (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST VAR) BODY)) KEYS)) (COMMON-LISP:DEFUN CALL-WITH-INPUT (INPUT COMMON-LISP:FUNCTION COMMON-LISP:&KEY KEYS) "Calls FUNCTION with an actual stream argument, interpreting
     [java] stream designators like READ, but also coercing strings to STRING-INPUT-STREAM,
     [java] and PATHNAME to FILE-STREAM.
     [java] If INPUT is a STREAM, use it as the stream.
     [java] If INPUT is NIL, use a *STANDARD-INPUT* as the stream.
     [java] If INPUT is T, use *TERMINAL-IO* as the stream.
     [java] If INPUT is a STRING, use it as a string-input-stream.
     [java] If INPUT is a PATHNAME, open it, passing KEYS to WITH-INPUT-FILE
     [java] -- the latter is an extension since ASDF 3.1.
     [java] Otherwise, signal an error." (COMMON-LISP:ETYPECASE INPUT (COMMON-LISP:NULL (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:*STANDARD-INPUT*)) ((COMMON-LISP:EQL COMMON-LISP:T) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:*TERMINAL-IO*)) (COMMON-LISP:STREAM (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION INPUT)) (COMMON-LISP:STRING (COMMON-LISP:WITH-INPUT-FROM-STRING (COMMON-LISP:STREAM INPUT) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION COMMON-LISP:STREAM))) (COMMON-LISP:PATHNAME (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) INPUT COMMON-LISP:FUNCTION KEYS)))) (COMMON-LISP:DEFMACRO WITH-INPUT ((INPUT-VAR COMMON-LISP:&OPTIONAL (VALUE INPUT-VAR)) COMMON-LISP:&BODY BODY) "Bind INPUT-VAR to an input stream, coercing VALUE (default: previous binding of INPUT-VAR)
     [java] as per CALL-WITH-INPUT, and evaluate BODY within the scope of this binding." (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-INPUT) VALUE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST INPUT-VAR) BODY)))) (COMMON-LISP:DEFUN INPUT-STRING (COMMON-LISP:&OPTIONAL INPUT) "If the desired INPUT is a string, return that string; otherwise slurp the INPUT into a string
     [java] and return that" (COMMON-LISP:IF (COMMON-LISP:STRINGP INPUT) INPUT (WITH-INPUT (INPUT) (COMMON-LISP:FUNCALL (COMMON-LISP:QUOTE SLURP-STREAM-STRING) INPUT)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN NULL-DEVICE-PATHNAME COMMON-LISP:NIL "Pathname to a bit bucket device that discards any information written to it
     [java] and always returns EOF when read from" (OS-COND ((OS-UNIX-P) #P"/dev/null") ((OS-WINDOWS-P) #P"NUL") (COMMON-LISP:T (COMMON-LISP:ERROR "No /dev/null on your OS")))) (COMMON-LISP:DEFUN CALL-WITH-NULL-INPUT (FUN COMMON-LISP:&REST KEYS COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST) "Call FUN with an input stream from the null device; pass keyword arguments to OPEN." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) (NULL-DEVICE-PATHNAME) FUN KEYS)) (COMMON-LISP:DEFMACRO WITH-NULL-INPUT ((VAR COMMON-LISP:&REST KEYS COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST) COMMON-LISP:&BODY BODY) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST)) "Evaluate BODY in a context when VAR is bound to an input stream accessing the null device.
     [java] Pass keyword arguments to OPEN." (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE CALL-WITH-NULL-INPUT) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST VAR) BODY)) KEYS)) (COMMON-LISP:DEFUN CALL-WITH-NULL-OUTPUT (FUN COMMON-LISP:&KEY (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (IF-EXISTS :OVERWRITE) (IF-DOES-NOT-EXIST :ERROR)) "Call FUN with an output stream to the null device; pass keyword arguments to OPEN." (CALL-WITH-OUTPUT-FILE (NULL-DEVICE-PATHNAME) FUN :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-EXISTS IF-EXISTS :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST)) (COMMON-LISP:DEFMACRO WITH-NULL-OUTPUT ((VAR COMMON-LISP:&REST KEYS COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT IF-DOES-NOT-EXIST IF-EXISTS) COMMON-LISP:&BODY BODY) "Evaluate BODY in a context when VAR is bound to an output stream accessing the null device.
     [java] Pass keyword arguments to OPEN." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE ELEMENT-TYPE EXTERNAL-FORMAT IF-EXISTS IF-DOES-NOT-EXIST)) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE CALL-WITH-NULL-OUTPUT) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST VAR) BODY)) KEYS)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN FINISH-OUTPUTS (COMMON-LISP:&REST STREAMS) "Finish output on the main output streams as well as any specified one.
     [java] Useful for portably flushing I/O before user input or program exit." (COMMON-LISP:DOLIST (S (COMMON-LISP:APPEND STREAMS (COMMON-LISP:LIST *STDOUT* *STDERR* COMMON-LISP:*ERROR-OUTPUT* COMMON-LISP:*STANDARD-OUTPUT* COMMON-LISP:*TRACE-OUTPUT* COMMON-LISP:*DEBUG-IO* COMMON-LISP:*TERMINAL-IO* COMMON-LISP:*QUERY-IO*))) (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:FINISH-OUTPUT S))) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFUN FORMAT! (COMMON-LISP:STREAM COMMON-LISP:FORMAT COMMON-LISP:&REST ARGS) "Just like format, but call finish-outputs before and after the output." (FINISH-OUTPUTS COMMON-LISP:STREAM) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:FORMAT) COMMON-LISP:STREAM COMMON-LISP:FORMAT ARGS) (FINISH-OUTPUTS COMMON-LISP:STREAM)) (COMMON-LISP:DEFUN SAFE-FORMAT! (COMMON-LISP:STREAM COMMON-LISP:FORMAT COMMON-LISP:&REST ARGS) "Variant of FORMAT that is safe against both
     [java] dangerous syntax configuration and errors while printing." (WITH-SAFE-IO-SYNTAX COMMON-LISP:NIL (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:APPLY (COMMON-LISP:QUOTE FORMAT!) COMMON-LISP:STREAM COMMON-LISP:FORMAT ARGS)) (FINISH-OUTPUTS COMMON-LISP:STREAM))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COPY-STREAM-TO-STREAM (INPUT OUTPUT COMMON-LISP:&KEY ELEMENT-TYPE BUFFER-SIZE LINEWISE PREFIX) "Copy the contents of the INPUT stream into the OUTPUT stream.
     [java] If LINEWISE is true, then read and copy the stream line by line, with an optional PREFIX.
     [java] Otherwise, using WRITE-SEQUENCE using a buffer of size BUFFER-SIZE." (COMMON-LISP:WITH-OPEN-STREAM (INPUT INPUT) (COMMON-LISP:IF LINEWISE (UIOP/COMMON-LISP::LOOP* :FOR (LINE EOF) COMMON-LISP:= (COMMON-LISP:MULTIPLE-VALUE-LIST (COMMON-LISP:READ-LINE INPUT COMMON-LISP:NIL COMMON-LISP:NIL)) :WHILE LINE :DO (COMMON-LISP:WHEN PREFIX (COMMON-LISP:PRINC PREFIX OUTPUT)) (COMMON-LISP:PRINC LINE OUTPUT) (COMMON-LISP:UNLESS EOF (COMMON-LISP:TERPRI OUTPUT)) (COMMON-LISP:FINISH-OUTPUT OUTPUT) (COMMON-LISP:WHEN EOF (COMMON-LISP:RETURN))) (COMMON-LISP:LOOP :WITH BUFFER-SIZE COMMON-LISP:= (COMMON-LISP:OR BUFFER-SIZE 8192) :FOR BUFFER COMMON-LISP:= (COMMON-LISP:MAKE-ARRAY (COMMON-LISP:LIST BUFFER-SIZE) :ELEMENT-TYPE (COMMON-LISP:OR ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER))) :FOR END COMMON-LISP:= (COMMON-LISP:READ-SEQUENCE BUFFER INPUT) :UNTIL (COMMON-LISP:ZEROP END) :DO (COMMON-LISP:WRITE-SEQUENCE BUFFER OUTPUT :END END) (COMMON-LISP:WHEN (COMMON-LISP:< END BUFFER-SIZE) (COMMON-LISP:RETURN)))))) (COMMON-LISP:DEFUN CONCATENATE-FILES (INPUTS OUTPUT) "create a new OUTPUT file the contents of which a the concatenate of the INPUTS files." (COMMON-LISP:WITH-OPEN-FILE (O OUTPUT :ELEMENT-TYPE (COMMON-LISP:QUOTE (COMMON-LISP:UNSIGNED-BYTE 8)) :DIRECTION :OUTPUT :IF-EXISTS :RENAME-AND-DELETE) (COMMON-LISP:DOLIST (INPUT INPUTS) (COMMON-LISP:WITH-OPEN-FILE (I INPUT :ELEMENT-TYPE (COMMON-LISP:QUOTE (COMMON-LISP:UNSIGNED-BYTE 8)) :DIRECTION :INPUT :IF-DOES-NOT-EXIST :ERROR) (COPY-STREAM-TO-STREAM I O :ELEMENT-TYPE (COMMON-LISP:QUOTE (COMMON-LISP:UNSIGNED-BYTE 8))))))) (COMMON-LISP:DEFUN COPY-FILE (INPUT OUTPUT) "Copy contents of the INPUT file to the OUTPUT file" (CONCATENATE-FILES (COMMON-LISP:LIST INPUT) OUTPUT)) (COMMON-LISP:DEFUN SLURP-STREAM-STRING (INPUT COMMON-LISP:&KEY (ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) STRIPPED) "Read the contents of the INPUT stream as a string" (COMMON-LISP:LET ((COMMON-LISP:STRING (COMMON-LISP:WITH-OPEN-STREAM (INPUT INPUT) (COMMON-LISP:WITH-OUTPUT-TO-STRING (OUTPUT) (COPY-STREAM-TO-STREAM INPUT OUTPUT :ELEMENT-TYPE ELEMENT-TYPE))))) (COMMON-LISP:IF STRIPPED (STRIPLN COMMON-LISP:STRING) COMMON-LISP:STRING))) (COMMON-LISP:DEFUN SLURP-STREAM-LINES (INPUT COMMON-LISP:&KEY COMMON-LISP:COUNT) "Read the contents of the INPUT stream as a list of lines, return those lines.
     [java]
     [java] Note: relies on the Lisp's READ-LINE, but additionally removes any remaining CR
     [java] from the line-ending if the file or stream had CR+LF but Lisp only removed LF.
     [java]
     [java] Read no more than COUNT lines." (COMMON-LISP:CHECK-TYPE COMMON-LISP:COUNT (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:INTEGER)) (COMMON-LISP:WITH-OPEN-STREAM (INPUT INPUT) (COMMON-LISP:LOOP :FOR N :FROM 0 :FOR L COMMON-LISP:= (COMMON-LISP:AND (COMMON-LISP:OR (COMMON-LISP:NOT COMMON-LISP:COUNT) (COMMON-LISP:< N COMMON-LISP:COUNT)) (COMMON-LISP:READ-LINE INPUT COMMON-LISP:NIL COMMON-LISP:NIL)) :WHILE L :COLLECT (STRIPLN L)))) (COMMON-LISP:DEFUN SLURP-STREAM-LINE (INPUT COMMON-LISP:&KEY (AT 0)) "Read the contents of the INPUT stream as a list of lines,
     [java] then return the ACCESS-AT of that list of lines using the AT specifier.
     [java] PATH defaults to 0, i.e. return the first line.
     [java] PATH is typically an integer, or a list of an integer and a function.
     [java] If PATH is NIL, it will return all the lines in the file.
     [java]
     [java] The stream will not be read beyond the Nth lines,
     [java] where N is the index specified by path
     [java] if path is either an integer or a list that starts with an integer." (ACCESS-AT (SLURP-STREAM-LINES INPUT :COUNT (ACCESS-AT-COUNT AT)) AT)) (COMMON-LISP:DEFUN SLURP-STREAM-FORMS (INPUT COMMON-LISP:&KEY COMMON-LISP:COUNT) "Read the contents of the INPUT stream as a list of forms,
     [java] and return those forms.
     [java]
     [java] If COUNT is null, read to the end of the stream;
     [java] if COUNT is an integer, stop after COUNT forms were read.
     [java]
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (COMMON-LISP:CHECK-TYPE COMMON-LISP:COUNT (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:INTEGER)) (COMMON-LISP:LOOP :WITH EOF COMMON-LISP:= (COMMON-LISP:QUOTE #:EOF) :FOR N :FROM 0 :FOR FORM COMMON-LISP:= (COMMON-LISP:IF (COMMON-LISP:AND COMMON-LISP:COUNT (COMMON-LISP:>= N COMMON-LISP:COUNT)) EOF (COMMON-LISP:READ-PRESERVING-WHITESPACE INPUT COMMON-LISP:NIL EOF)) :UNTIL (COMMON-LISP:EQ FORM EOF) :COLLECT FORM)) (COMMON-LISP:DEFUN SLURP-STREAM-FORM (INPUT COMMON-LISP:&KEY (AT 0)) "Read the contents of the INPUT stream as a list of forms,
     [java] then return the ACCESS-AT of these forms following the AT.
     [java] AT defaults to 0, i.e. return the first form.
     [java] AT is typically a list of integers.
     [java] If AT is NIL, it will return all the forms in the file.
     [java]
     [java] The stream will not be read beyond the Nth form,
     [java] where N is the index specified by path,
     [java] if path is either an integer or a list that starts with an integer.
     [java]
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (ACCESS-AT (SLURP-STREAM-FORMS INPUT :COUNT (ACCESS-AT-COUNT AT)) AT)) (COMMON-LISP:DEFUN READ-FILE-STRING (FILE COMMON-LISP:&REST KEYS) "Open FILE with option KEYS, read its contents as a string" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) FILE (COMMON-LISP:QUOTE SLURP-STREAM-STRING) KEYS)) (COMMON-LISP:DEFUN READ-FILE-LINES (FILE COMMON-LISP:&REST KEYS) "Open FILE with option KEYS, read its contents as a list of lines
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) FILE (COMMON-LISP:QUOTE SLURP-STREAM-LINES) KEYS)) (COMMON-LISP:DEFUN READ-FILE-LINE (FILE COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (AT 0) COMMON-LISP:&ALLOW-OTHER-KEYS) "Open input FILE with option KEYS (except AT),
     [java] and read its contents as per SLURP-STREAM-LINE with given AT specifier.
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) FILE (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (INPUT) (SLURP-STREAM-LINE INPUT :AT AT))) (REMOVE-PLIST-KEY :AT KEYS))) (COMMON-LISP:DEFUN READ-FILE-FORMS (FILE COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:COUNT COMMON-LISP:&ALLOW-OTHER-KEYS) "Open input FILE with option KEYS (except COUNT),
     [java] and read its contents as per SLURP-STREAM-FORMS with given COUNT.
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) FILE (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (INPUT) (SLURP-STREAM-FORMS INPUT :COUNT COMMON-LISP:COUNT))) (REMOVE-PLIST-KEY :COUNT KEYS))) (COMMON-LISP:DEFUN READ-FILE-FORM (FILE COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (AT 0) COMMON-LISP:&ALLOW-OTHER-KEYS) "Open input FILE with option KEYS (except AT),
     [java] and read its contents as per SLURP-STREAM-FORM with given AT specifier.
     [java] BEWARE: be sure to use WITH-SAFE-IO-SYNTAX, or some variant thereof" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE CALL-WITH-INPUT-FILE) FILE (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (INPUT) (SLURP-STREAM-FORM INPUT :AT AT))) (REMOVE-PLIST-KEY :AT KEYS))) (COMMON-LISP:DEFUN SAFE-READ-FILE-LINE (COMMON-LISP:PATHNAME COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL) COMMON-LISP:&ALLOW-OTHER-KEYS) "Reads the specified line from the top of a file using a safe standardized syntax.
     [java] Extracts the line using READ-FILE-LINE,
     [java] within an WITH-SAFE-IO-SYNTAX using the specified PACKAGE." (WITH-SAFE-IO-SYNTAX (:PACKAGE COMMON-LISP:PACKAGE) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE READ-FILE-LINE) COMMON-LISP:PATHNAME (REMOVE-PLIST-KEY :PACKAGE KEYS)))) (COMMON-LISP:DEFUN SAFE-READ-FILE-FORM (COMMON-LISP:PATHNAME COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL) COMMON-LISP:&ALLOW-OTHER-KEYS) "Reads the specified form from the top of a file using a safe standardized syntax.
     [java] Extracts the form using READ-FILE-FORM,
     [java] within an WITH-SAFE-IO-SYNTAX using the specified PACKAGE." (WITH-SAFE-IO-SYNTAX (:PACKAGE COMMON-LISP:PACKAGE) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE READ-FILE-FORM) COMMON-LISP:PATHNAME (REMOVE-PLIST-KEY :PACKAGE KEYS)))) (COMMON-LISP:DEFUN EVAL-INPUT (INPUT) "Portably read and evaluate forms from INPUT, return the last values." (WITH-INPUT (INPUT) (COMMON-LISP:LOOP :WITH RESULTS :WITH EOF COMMON-LISP:= (COMMON-LISP:QUOTE #:EOF) :FOR FORM COMMON-LISP:= (COMMON-LISP:READ INPUT COMMON-LISP:NIL EOF) :UNTIL (COMMON-LISP:EQ FORM EOF) :DO (COMMON-LISP:SETF RESULTS (COMMON-LISP:MULTIPLE-VALUE-LIST (COMMON-LISP:EVAL FORM))) :FINALLY (COMMON-LISP:RETURN (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:VALUES) RESULTS))))) (COMMON-LISP:DEFUN EVAL-THUNK (THUNK) "Evaluate a THUNK of code:
     [java] If a function, FUNCALL it without arguments.
     [java] If a constant literal and not a sequence, return it.
     [java] If a cons or a symbol, EVAL it.
     [java] If a string, repeatedly read and evaluate from it, returning the last values." (COMMON-LISP:ETYPECASE THUNK ((COMMON-LISP:OR COMMON-LISP:BOOLEAN COMMON-LISP:KEYWORD COMMON-LISP:NUMBER COMMON-LISP:CHARACTER COMMON-LISP:PATHNAME) THUNK) ((COMMON-LISP:OR COMMON-LISP:CONS COMMON-LISP:SYMBOL) (COMMON-LISP:EVAL THUNK)) (COMMON-LISP:FUNCTION (COMMON-LISP:FUNCALL THUNK)) (COMMON-LISP:STRING (EVAL-INPUT THUNK)))) (COMMON-LISP:DEFUN STANDARD-EVAL-THUNK (THUNK COMMON-LISP:&KEY (COMMON-LISP:PACKAGE :CL)) "Like EVAL-THUNK, but in a more standardized evaluation context." (COMMON-LISP:WHEN THUNK (WITH-SAFE-IO-SYNTAX (:PACKAGE COMMON-LISP:PACKAGE) (COMMON-LISP:LET ((COMMON-LISP:*READ-EVAL* COMMON-LISP:T)) (EVAL-THUNK THUNK))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN PRINTLN (X COMMON-LISP:&OPTIONAL (COMMON-LISP:STREAM COMMON-LISP:*STANDARD-OUTPUT*)) "Variant of PRINC that also calls TERPRI afterwards" (COMMON-LISP:PRINC X COMMON-LISP:STREAM) (COMMON-LISP:TERPRI COMMON-LISP:STREAM) (COMMON-LISP:FINISH-OUTPUT COMMON-LISP:STREAM) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFUN WRITELN (X COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (COMMON-LISP:STREAM COMMON-LISP:*STANDARD-OUTPUT*) COMMON-LISP:&ALLOW-OTHER-KEYS) "Variant of WRITE that also calls TERPRI afterwards" (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:WRITE) X KEYS) (COMMON-LISP:TERPRI COMMON-LISP:STREAM) (COMMON-LISP:FINISH-OUTPUT COMMON-LISP:STREAM) (COMMON-LISP:VALUES)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN DEFAULT-TEMPORARY-DIRECTORY COMMON-LISP:NIL "Return a default directory to use for temporary files" (OS-COND ((OS-UNIX-P) (COMMON-LISP:OR (GETENV-PATHNAME "TMPDIR" :ENSURE-DIRECTORY COMMON-LISP:T) (PARSE-NATIVE-NAMESTRING "/tmp/"))) ((OS-WINDOWS-P) (GETENV-PATHNAME "TEMP" :ENSURE-DIRECTORY COMMON-LISP:T)) (COMMON-LISP:T (SUBPATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME) "tmp/")))) (COMMON-LISP:DEFVAR *TEMPORARY-DIRECTORY* COMMON-LISP:NIL "User-configurable location for temporary files") (COMMON-LISP:DEFUN TEMPORARY-DIRECTORY COMMON-LISP:NIL "Return a directory to use for temporary files" (COMMON-LISP:OR *TEMPORARY-DIRECTORY* (DEFAULT-TEMPORARY-DIRECTORY))) (COMMON-LISP:DEFUN SETUP-TEMPORARY-DIRECTORY COMMON-LISP:NIL "Configure a default temporary directory to use." (COMMON-LISP:SETF *TEMPORARY-DIRECTORY* (DEFAULT-TEMPORARY-DIRECTORY))) (COMMON-LISP:DEFUN CALL-WITH-TEMPORARY-FILE (THUNK COMMON-LISP:&KEY (WANT-STREAM-P COMMON-LISP:T) (WANT-PATHNAME-P COMMON-LISP:T) (DIRECTION :IO) KEEP AFTER COMMON-LISP:DIRECTORY (COMMON-LISP:TYPE "tmp" COMMON-LISP:TYPEP) PREFIX (SUFFIX (COMMON-LISP:WHEN COMMON-LISP:TYPEP "-tmp")) (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*)) "Call a THUNK with stream and/or pathname arguments identifying a temporary file.
     [java]
     [java] The temporary file's pathname will be based on concatenating
     [java] PREFIX (defaults to \"uiop\"), a random alphanumeric string,
     [java] and optional SUFFIX (defaults to \"-tmp\" if a type was provided)
     [java] and TYPE (defaults to \"tmp\", using a dot as separator if not NIL),
     [java] within DIRECTORY (defaulting to the TEMPORARY-DIRECTORY) if the PREFIX isn't absolute.
     [java]
     [java] The file will be open with specified DIRECTION (defaults to :IO),
     [java] ELEMENT-TYPE (defaults to *DEFAULT-STREAM-ELEMENT-TYPE*) and
     [java] EXTERNAL-FORMAT (defaults to *UTF-8-EXTERNAL-FORMAT*).
     [java] If WANT-STREAM-P is true (the defaults to T), then THUNK will then be CALL-FUNCTION'ed
     [java] with the stream and the pathname (if WANT-PATHNAME-P is true, defaults to T),
     [java] and stream with be closed after the THUNK exits (either normally or abnormally).
     [java] If WANT-STREAM-P is false, then WANT-PATHAME-P must be true, and then
     [java] THUNK is only CALL-FUNCTION'ed after the stream is closed, with the pathname as argument.
     [java] Upon exit of THUNK, the AFTER thunk if defined is CALL-FUNCTION'ed with the pathname as argument.
     [java] If AFTER is defined, its results are returned, otherwise, the results of THUNK are returned.
     [java] Finally, the file will be deleted, unless the KEEP argument when CALL-FUNCTION'ed returns true." (COMMON-LISP:CHECK-TYPE DIRECTION (COMMON-LISP:MEMBER :OUTPUT :IO)) (COMMON-LISP:ASSERT (COMMON-LISP:OR WANT-STREAM-P WANT-PATHNAME-P)) (COMMON-LISP:LOOP :WITH PREFIX-PN COMMON-LISP:= (ENSURE-ABSOLUTE-PATHNAME (COMMON-LISP:OR PREFIX "tmp") (COMMON-LISP:OR (ENSURE-PATHNAME COMMON-LISP:DIRECTORY :NAMESTRING :NATIVE :ENSURE-DIRECTORY COMMON-LISP:T) (COMMON-LISP:FUNCTION TEMPORARY-DIRECTORY))) :WITH PREFIX-NNS COMMON-LISP:= (NATIVE-NAMESTRING PREFIX-PN) :WITH RESULTS COMMON-LISP:= (COMMON-LISP:PROGN (COMMON-LISP:ENSURE-DIRECTORIES-EXIST PREFIX-PN) COMMON-LISP:NIL) :FOR COUNTER :FROM (COMMON-LISP:RANDOM (COMMON-LISP:EXPT 36 8)) :FOR COMMON-LISP:PATHNAME COMMON-LISP:= (PARSE-NATIVE-NAMESTRING (COMMON-LISP:FORMAT COMMON-LISP:NIL "~A~36R~@[~A~]~@[.~A~]" PREFIX-NNS COUNTER SUFFIX (COMMON-LISP:UNLESS (COMMON-LISP:EQ COMMON-LISP:TYPE :UNSPECIFIC) COMMON-LISP:TYPE))) :FOR OKP COMMON-LISP:= COMMON-LISP:NIL :DO (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:PROGN (COMMON-LISP:ENSURE-DIRECTORIES-EXIST COMMON-LISP:PATHNAME) (COMMON-LISP:WITH-OPEN-FILE (COMMON-LISP:STREAM COMMON-LISP:PATHNAME :DIRECTION DIRECTION :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-EXISTS COMMON-LISP:NIL :IF-DOES-NOT-EXIST :CREATE) (COMMON-LISP:WHEN COMMON-LISP:STREAM (COMMON-LISP:SETF OKP COMMON-LISP:PATHNAME) (COMMON-LISP:WHEN WANT-STREAM-P (COMMON-LISP:SETF RESULTS (COMMON-LISP:MULTIPLE-VALUE-LIST (COMMON-LISP:IF WANT-PATHNAME-P (COMMON-LISP:FUNCALL THUNK COMMON-LISP:STREAM COMMON-LISP:PATHNAME) (COMMON-LISP:FUNCALL THUNK COMMON-LISP:STREAM))))))) (COMMON-LISP:COND ((COMMON-LISP:NOT OKP) COMMON-LISP:NIL) (AFTER (COMMON-LISP:RETURN (CALL-FUNCTION AFTER OKP))) ((COMMON-LISP:AND WANT-PATHNAME-P (COMMON-LISP:NOT WANT-STREAM-P)) (COMMON-LISP:RETURN (CALL-FUNCTION THUNK OKP))) (COMMON-LISP:T (COMMON-LISP:RETURN (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:VALUES) RESULTS))))) (COMMON-LISP:WHEN (COMMON-LISP:AND OKP (COMMON-LISP:NOT (CALL-FUNCTION KEEP))) (COMMON-LISP:IGNORE-ERRORS (DELETE-FILE-IF-EXISTS OKP)))))) (COMMON-LISP:DEFMACRO WITH-TEMPORARY-FILE ((COMMON-LISP:&KEY (COMMON-LISP:STREAM (COMMON-LISP:GENSYM "STREAM") COMMON-LISP:STREAMP) (COMMON-LISP:PATHNAME (COMMON-LISP:GENSYM "PATHNAME") COMMON-LISP:PATHNAMEP) COMMON-LISP:DIRECTORY PREFIX SUFFIX COMMON-LISP:TYPE KEEP DIRECTION ELEMENT-TYPE EXTERNAL-FORMAT) COMMON-LISP:&BODY BODY) "Evaluate BODY where the symbols specified by keyword arguments
     [java] STREAM and PATHNAME (if respectively specified) are bound corresponding
     [java] to a newly created temporary file ready for I/O, as per CALL-WITH-TEMPORARY-FILE.
     [java] At least one of STREAM or PATHNAME must be specified.
     [java] If the STREAM is not specified, it will be closed before the BODY is evaluated.
     [java] If STREAM is specified, then the :CLOSE-STREAM label if it appears in the BODY,
     [java] separates forms run before and after the stream is closed.
     [java] The values of the last form of the BODY (not counting the separating :CLOSE-STREAM) are returned.
     [java] Upon success, the KEEP form is evaluated and the file is is deleted unless it evaluates to TRUE." (COMMON-LISP:CHECK-TYPE COMMON-LISP:STREAM COMMON-LISP:SYMBOL) (COMMON-LISP:CHECK-TYPE COMMON-LISP:PATHNAME COMMON-LISP:SYMBOL) (COMMON-LISP:ASSERT (COMMON-LISP:OR COMMON-LISP:STREAMP COMMON-LISP:PATHNAMEP)) (COMMON-LISP:LET* ((AFTERP (COMMON-LISP:POSITION :CLOSE-STREAM BODY)) (BEFORE (COMMON-LISP:IF AFTERP (COMMON-LISP:SUBSEQ BODY 0 AFTERP) BODY)) (AFTER (COMMON-LISP:WHEN AFTERP (COMMON-LISP:SUBSEQ BODY (COMMON-LISP:1+ AFTERP)))) (BEFOREF (COMMON-LISP:GENSYM "BEFORE")) (AFTERF (COMMON-LISP:GENSYM "AFTER"))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FLET) (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN BEFORE (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* BEFOREF (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN COMMON-LISP:STREAMP (SYSTEM::BACKQ-LIST COMMON-LISP:STREAM)) (COMMON-LISP:WHEN COMMON-LISP:PATHNAMEP (SYSTEM::BACKQ-LIST COMMON-LISP:PATHNAME))) (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN AFTER (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DECLARE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IGNORABLE) COMMON-LISP:PATHNAME)))) BEFORE)))) (COMMON-LISP:WHEN AFTER (COMMON-LISP:ASSERT COMMON-LISP:PATHNAMEP) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST* AFTERF (SYSTEM::BACKQ-LIST COMMON-LISP:PATHNAME) AFTER)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DECLARE) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:DYNAMIC-EXTENT) (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN BEFORE (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) BEFOREF))) (COMMON-LISP:WHEN AFTER (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) AFTERF)))))) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE CALL-WITH-TEMPORARY-FILE) (COMMON-LISP:WHEN BEFORE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) BEFOREF)) (COMMON-LISP:QUOTE :WANT-STREAM-P) COMMON-LISP:STREAMP (COMMON-LISP:QUOTE :WANT-PATHNAME-P) COMMON-LISP:PATHNAMEP (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN DIRECTION (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DIRECTION) DIRECTION)) (COMMON-LISP:WHEN COMMON-LISP:DIRECTORY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DIRECTORY) COMMON-LISP:DIRECTORY)) (COMMON-LISP:WHEN PREFIX (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :PREFIX) PREFIX)) (COMMON-LISP:WHEN SUFFIX (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :SUFFIX) SUFFIX)) (COMMON-LISP:WHEN COMMON-LISP:TYPE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :TYPE) COMMON-LISP:TYPE)) (COMMON-LISP:WHEN KEEP (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :KEEP) KEEP)) (COMMON-LISP:WHEN AFTER (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :AFTER) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) AFTERF))) (COMMON-LISP:WHEN ELEMENT-TYPE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :ELEMENT-TYPE) ELEMENT-TYPE)) (COMMON-LISP:WHEN EXTERNAL-FORMAT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :EXTERNAL-FORMAT) EXTERNAL-FORMAT))))))) (COMMON-LISP:DEFUN GET-TEMPORARY-FILE (COMMON-LISP:&KEY COMMON-LISP:DIRECTORY PREFIX SUFFIX COMMON-LISP:TYPE) (WITH-TEMPORARY-FILE (:PATHNAME PN :KEEP COMMON-LISP:T :DIRECTORY COMMON-LISP:DIRECTORY :PREFIX PREFIX :SUFFIX SUFFIX :TYPE COMMON-LISP:TYPE) PN)) (COMMON-LISP:DEFUN ADD-PATHNAME-SUFFIX (COMMON-LISP:PATHNAME SUFFIX COMMON-LISP:&REST KEYS) "Add a SUFFIX to the name of a PATHNAME, return a new pathname.
     [java] Further KEYS can be passed to MAKE-PATHNAME." (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-PATHNAME) :NAME (STRCAT (COMMON-LISP:PATHNAME-NAME COMMON-LISP:PATHNAME) SUFFIX) :DEFAULTS COMMON-LISP:PATHNAME KEYS)) (COMMON-LISP:DEFUN TMPIZE-PATHNAME (X) "Return a new pathname modified from X by adding a trivial random suffix.
     [java] A new empty file with said temporary pathname is created, to ensure there is no
     [java] clash with any concurrent process attempting the same thing." (COMMON-LISP:LET* ((PX (ENSURE-PATHNAME X)) (PREFIX (IF-LET (N (COMMON-LISP:PATHNAME-NAME PX)) (STRCAT N "-tmp") "tmp")) (COMMON-LISP:DIRECTORY (COMMON-LISP:TRANSLATE-LOGICAL-PATHNAME (PATHNAME-DIRECTORY-PATHNAME PX)))) (GET-TEMPORARY-FILE :DIRECTORY COMMON-LISP:DIRECTORY :PREFIX PREFIX :TYPE (COMMON-LISP:PATHNAME-TYPE PX)))) (COMMON-LISP:DEFUN CALL-WITH-STAGING-PATHNAME (COMMON-LISP:PATHNAME FUN) "Calls FUN with a staging pathname, and atomically
     [java] renames the staging pathname to the PATHNAME in the end.
     [java] NB: this protects only against failure of the program, not against concurrent attempts.
     [java] For the latter case, we ought pick a random suffix and atomically open it." (COMMON-LISP:LET* ((COMMON-LISP:PATHNAME (COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME)) (STAGING (TMPIZE-PATHNAME COMMON-LISP:PATHNAME))) (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:MULTIPLE-VALUE-PROG1 (COMMON-LISP:FUNCALL FUN STAGING) (RENAME-FILE-OVERWRITING-TARGET STAGING COMMON-LISP:PATHNAME)) (DELETE-FILE-IF-EXISTS STAGING)))) (COMMON-LISP:DEFMACRO WITH-STAGING-PATHNAME ((PATHNAME-VAR COMMON-LISP:&OPTIONAL (PATHNAME-VALUE PATHNAME-VAR)) COMMON-LISP:&BODY BODY) "Trivial syntax wrapper for CALL-WITH-STAGING-PATHNAME" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-STAGING-PATHNAME) PATHNAME-VALUE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST PATHNAME-VAR) BODY)))))
     [java] ; (DEFINE-PACKAGE :UIOP/IMAGE (:NICKNAMES :ASDF/IMAGE) (:RECYCLE :UIOP/IMAGE :ASDF/IMAGE :XCVB-DRIVER) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/PATHNAME :UIOP/STREAM :UIOP/OS) (:EXPORT #:*IMAGE-DUMPED-P* #:RAW-COMMAND-LINE-ARGUMENTS #:*COMMAND-LINE-ARGUMENTS* #:COMMAND-LINE-ARGUMENTS #:RAW-COMMAND-LINE-ARGUMENTS #:SETUP-COMMAND-LINE-ARGUMENTS #:ARGV0 #:*LISP-INTERACTION* #:*FATAL-CONDITIONS* #:FATAL-CONDITION-P #:HANDLE-FATAL-CONDITION #:CALL-WITH-FATAL-CONDITION-HANDLER #:WITH-FATAL-CONDITION-HANDLER #:*IMAGE-RESTORE-HOOK* #:*IMAGE-PRELUDE* #:*IMAGE-ENTRY-POINT* #:*IMAGE-POSTLUDE* #:*IMAGE-DUMP-HOOK* #:QUIT #:DIE #:RAW-PRINT-BACKTRACE #:PRINT-BACKTRACE #:PRINT-CONDITION-BACKTRACE #:SHELL-BOOLEAN-EXIT #:REGISTER-IMAGE-RESTORE-HOOK #:REGISTER-IMAGE-DUMP-HOOK #:CALL-IMAGE-RESTORE-HOOK #:CALL-IMAGE-DUMP-HOOK #:RESTORE-IMAGE #:DUMP-IMAGE #:CREATE-IMAGE))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/IMAGE)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *LISP-INTERACTION* COMMON-LISP:T "Is this an interactive Lisp environment, or is it batch processing?") (COMMON-LISP:DEFVAR *COMMAND-LINE-ARGUMENTS* COMMON-LISP:NIL "Command-line arguments") (COMMON-LISP:DEFVAR *IMAGE-DUMPED-P* COMMON-LISP:NIL "Is this a dumped image? As a standalone executable?") (COMMON-LISP:DEFVAR *IMAGE-RESTORE-HOOK* COMMON-LISP:NIL "Functions to call (in reverse order) when the image is restored") (COMMON-LISP:DEFVAR *IMAGE-RESTORED-P* COMMON-LISP:NIL "Has the image been restored? A boolean, or :in-progress while restoring, :in-regress while dumping") (COMMON-LISP:DEFVAR *IMAGE-PRELUDE* COMMON-LISP:NIL "a form to evaluate, or string containing forms to read and evaluate
     [java] when the image is restarted, but before the entry point is called.") (COMMON-LISP:DEFVAR *IMAGE-ENTRY-POINT* COMMON-LISP:NIL "a function with which to restart the dumped image when execution is restored from it.") (COMMON-LISP:DEFVAR *IMAGE-POSTLUDE* COMMON-LISP:NIL "a form to evaluate, or string containing forms to read and evaluate
     [java] before the image dump hooks are called and before the image is dumped.") (COMMON-LISP:DEFVAR *IMAGE-DUMP-HOOK* COMMON-LISP:NIL "Functions to call (in order) when before an image is dumped") (COMMON-LISP:DEFVAR *FATAL-CONDITIONS* (COMMON-LISP:QUOTE (COMMON-LISP:ERROR)) "conditions that cause the Lisp image to enter the debugger if interactive,
     [java] or to die if not interactive"))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN QUIT (COMMON-LISP:&OPTIONAL (CODE 0) (COMMON-LISP:FINISH-OUTPUT COMMON-LISP:T)) "Quits from the Lisp world, with the given exit status if provided.
     [java] This is designed to abstract away the implementation specific quit forms." (COMMON-LISP:WHEN COMMON-LISP:FINISH-OUTPUT (FINISH-OUTPUTS)) (EXTENSIONS:QUIT :STATUS CODE)) (COMMON-LISP:DEFUN DIE (CODE COMMON-LISP:FORMAT COMMON-LISP:&REST ARGUMENTS) "Die in error with some error message" (WITH-SAFE-IO-SYNTAX COMMON-LISP:NIL (COMMON-LISP:IGNORE-ERRORS (FORMAT! *STDERR* "~&~?~&" COMMON-LISP:FORMAT ARGUMENTS))) (QUIT CODE)) (COMMON-LISP:DEFUN RAW-PRINT-BACKTRACE (COMMON-LISP:&KEY (COMMON-LISP:STREAM COMMON-LISP:*DEBUG-IO*) COMMON-LISP:COUNT COMMON-LISP:CONDITION) "Print a backtrace, directly accessing the implementation" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:STREAM COMMON-LISP:COUNT COMMON-LISP:CONDITION)) (COMMON-LISP:LOOP :FOR I :FROM 0 :FOR FRAME :IN (SYSTEM:BACKTRACE (COMMON-LISP:OR COMMON-LISP:COUNT COMMON-LISP:MOST-POSITIVE-FIXNUM)) :DO (SAFE-FORMAT! COMMON-LISP:STREAM "~&~D: ~A~%" I FRAME))) (COMMON-LISP:DEFUN PRINT-BACKTRACE (COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:STREAM COMMON-LISP:COUNT COMMON-LISP:CONDITION) "Print a backtrace" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE COMMON-LISP:STREAM COMMON-LISP:COUNT COMMON-LISP:CONDITION)) (WITH-SAFE-IO-SYNTAX (:PACKAGE :CL) (COMMON-LISP:LET ((COMMON-LISP:*PRINT-READABLY* COMMON-LISP:NIL) (COMMON-LISP:*PRINT-CIRCLE* COMMON-LISP:T) (COMMON-LISP:*PRINT-MISER-WIDTH* 75) (COMMON-LISP:*PRINT-LENGTH* COMMON-LISP:NIL) (COMMON-LISP:*PRINT-LEVEL* COMMON-LISP:NIL) (COMMON-LISP:*PRINT-PRETTY* COMMON-LISP:T)) (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:APPLY (COMMON-LISP:QUOTE RAW-PRINT-BACKTRACE) KEYS))))) (COMMON-LISP:DEFUN PRINT-CONDITION-BACKTRACE (COMMON-LISP:CONDITION COMMON-LISP:&KEY (COMMON-LISP:STREAM *STDERR*) COMMON-LISP:COUNT) "Print a condition after a backtrace triggered by that condition" (PRINT-BACKTRACE :STREAM COMMON-LISP:STREAM :COUNT COMMON-LISP:COUNT :CONDITION COMMON-LISP:CONDITION) (COMMON-LISP:WHEN COMMON-LISP:CONDITION (SAFE-FORMAT! COMMON-LISP:STREAM "~&Above backtrace due to this condition:~%~A~&" COMMON-LISP:CONDITION))) (COMMON-LISP:DEFUN FATAL-CONDITION-P (COMMON-LISP:CONDITION) "Is the CONDITION fatal? It is if it matches any in *FATAL-CONDITIONS*" (MATCH-ANY-CONDITION-P COMMON-LISP:CONDITION *FATAL-CONDITIONS*)) (COMMON-LISP:DEFUN HANDLE-FATAL-CONDITION (COMMON-LISP:CONDITION) "Handle a fatal CONDITION:
     [java] depending on whether *LISP-INTERACTION* is set, enter debugger or die" (COMMON-LISP:COND (*LISP-INTERACTION* (COMMON-LISP:INVOKE-DEBUGGER COMMON-LISP:CONDITION)) (COMMON-LISP:T (SAFE-FORMAT! *STDERR* "~&Fatal condition:~%~A~%" COMMON-LISP:CONDITION) (PRINT-CONDITION-BACKTRACE COMMON-LISP:CONDITION :STREAM *STDERR*) (DIE 99 "~A" COMMON-LISP:CONDITION)))) (COMMON-LISP:DEFUN CALL-WITH-FATAL-CONDITION-HANDLER (THUNK) "Call THUNK in a context where fatal conditions are appropriately handled" (COMMON-LISP:HANDLER-BIND (((COMMON-LISP:SATISFIES FATAL-CONDITION-P) (COMMON-LISP:FUNCTION HANDLE-FATAL-CONDITION))) (COMMON-LISP:FUNCALL THUNK))) (COMMON-LISP:DEFMACRO WITH-FATAL-CONDITION-HANDLER ((COMMON-LISP:&OPTIONAL) COMMON-LISP:&BODY BODY) "Execute BODY in a context where fatal conditions are appropriately handled" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-FATAL-CONDITION-HANDLER) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))) (COMMON-LISP:DEFUN SHELL-BOOLEAN-EXIT (X) "Quit with a return code that is 0 iff argument X is true" (QUIT (COMMON-LISP:IF X 0 1))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN REGISTER-IMAGE-RESTORE-HOOK (HOOK COMMON-LISP:&OPTIONAL (CALL-NOW-P COMMON-LISP:T)) "Regiter a hook function to be run when restoring a dumped image" (REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *IMAGE-RESTORE-HOOK*) HOOK CALL-NOW-P)) (COMMON-LISP:DEFUN REGISTER-IMAGE-DUMP-HOOK (HOOK COMMON-LISP:&OPTIONAL (CALL-NOW-P COMMON-LISP:NIL)) "Register a the hook function to be run before to dump an image" (REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *IMAGE-DUMP-HOOK*) HOOK CALL-NOW-P)) (COMMON-LISP:DEFUN CALL-IMAGE-RESTORE-HOOK COMMON-LISP:NIL "Call the hook functions registered to be run when restoring a dumped image" (CALL-FUNCTIONS (COMMON-LISP:REVERSE *IMAGE-RESTORE-HOOK*))) (COMMON-LISP:DEFUN CALL-IMAGE-DUMP-HOOK COMMON-LISP:NIL "Call the hook functions registered to be run before to dump an image" (CALL-FUNCTIONS *IMAGE-DUMP-HOOK*)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN RAW-COMMAND-LINE-ARGUMENTS COMMON-LISP:NIL "Find what the actual command line for this process was." EXTENSIONS:*COMMAND-LINE-ARGUMENT-LIST*) (COMMON-LISP:DEFUN COMMAND-LINE-ARGUMENTS (COMMON-LISP:&OPTIONAL (ARGUMENTS (RAW-COMMAND-LINE-ARGUMENTS))) "Extract user arguments from command-line invocation of current process.
     [java] Assume the calling conventions of a generated script that uses --
     [java] if we are not called from a directly executable image." (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:RETURN ARGUMENTS) (COMMON-LISP:UNLESS (COMMON-LISP:EQ *IMAGE-DUMPED-P* :EXECUTABLE) (COMMON-LISP:SETF ARGUMENTS (COMMON-LISP:MEMBER "--" ARGUMENTS :TEST (COMMON-LISP:QUOTE COMMON-LISP:STRING-EQUAL)))) (COMMON-LISP:REST ARGUMENTS))) (COMMON-LISP:DEFUN ARGV0 COMMON-LISP:NIL "On supported implementations (most that matter), or when invoked by a proper wrapper script,
     [java] return a string that for the name with which the program was invoked, i.e. argv[0] in C.
     [java] Otherwise, return NIL." (COMMON-LISP:COND ((COMMON-LISP:EQ *IMAGE-DUMPED-P* :EXECUTABLE) (COMMON-LISP:OR)) (COMMON-LISP:T (GETENVP "__CL_ARGV0")))) (COMMON-LISP:DEFUN SETUP-COMMAND-LINE-ARGUMENTS COMMON-LISP:NIL (COMMON-LISP:SETF *COMMAND-LINE-ARGUMENTS* (COMMAND-LINE-ARGUMENTS))) (COMMON-LISP:DEFUN RESTORE-IMAGE (COMMON-LISP:&KEY (LISP-INTERACTION *LISP-INTERACTION*) (RESTORE-HOOK *IMAGE-RESTORE-HOOK*) (PRELUDE *IMAGE-PRELUDE*) (ENTRY-POINT *IMAGE-ENTRY-POINT*) (IF-ALREADY-RESTORED (COMMON-LISP:QUOTE (COMMON-LISP:CERROR "RUN RESTORE-IMAGE ANYWAY")))) "From a freshly restarted Lisp image, restore the saved Lisp environment
     [java] by setting appropriate variables, running various hooks, and calling any specified entry point.
     [java]
     [java] If the image has already been restored or is already being restored, as per *IMAGE-RESTORED-P*,
     [java] call the IF-ALREADY-RESTORED error handler (by default, a continuable error), and do return
     [java] immediately to the surrounding restore process if allowed to continue.
     [java]
     [java] Then, comes the restore process itself:
     [java] First, call each function in the RESTORE-HOOK,
     [java] in the order they were registered with REGISTER-IMAGE-RESTORE-HOOK.
     [java] Second, evaluate the prelude, which is often Lisp text that is read,
     [java] as per EVAL-INPUT.
     [java] Third, call the ENTRY-POINT function, if any is specified, with no argument.
     [java]
     [java] The restore process happens in a WITH-FATAL-CONDITION-HANDLER, so that if LISP-INTERACTION is NIL,
     [java] any unhandled error leads to a backtrace and an exit with an error status.
     [java] If LISP-INTERACTION is NIL, the process also exits when no error occurs:
     [java] if neither restart nor entry function is provided, the program will exit with status 0 (success);
     [java] if a function was provided, the program will exit after the function returns (if it returns),
     [java] with status 0 if and only if the primary return value of result is generalized boolean true,
     [java] and with status 1 if this value is NIL.
     [java]
     [java] If LISP-INTERACTION is true, unhandled errors will take you to the debugger, and the result
     [java] of the function will be returned rather than interpreted as a boolean designating an exit code." (COMMON-LISP:WHEN *IMAGE-RESTORED-P* (COMMON-LISP:IF IF-ALREADY-RESTORED (CALL-FUNCTION IF-ALREADY-RESTORED "Image already ~:[being ~;~]restored" (COMMON-LISP:EQ *IMAGE-RESTORED-P* COMMON-LISP:T)) (COMMON-LISP:RETURN-FROM RESTORE-IMAGE))) (WITH-FATAL-CONDITION-HANDLER COMMON-LISP:NIL (COMMON-LISP:SETF *LISP-INTERACTION* LISP-INTERACTION) (COMMON-LISP:SETF *IMAGE-RESTORE-HOOK* RESTORE-HOOK) (COMMON-LISP:SETF *IMAGE-PRELUDE* PRELUDE) (COMMON-LISP:SETF *IMAGE-RESTORED-P* :IN-PROGRESS) (CALL-IMAGE-RESTORE-HOOK) (STANDARD-EVAL-THUNK PRELUDE) (COMMON-LISP:SETF *IMAGE-RESTORED-P* COMMON-LISP:T) (COMMON-LISP:LET ((RESULTS (COMMON-LISP:MULTIPLE-VALUE-LIST (COMMON-LISP:IF ENTRY-POINT (CALL-FUNCTION ENTRY-POINT) COMMON-LISP:T)))) (COMMON-LISP:IF LISP-INTERACTION (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:VALUES) RESULTS) (SHELL-BOOLEAN-EXIT (COMMON-LISP:FIRST RESULTS)))))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN DUMP-IMAGE (FILENAME COMMON-LISP:&KEY OUTPUT-NAME EXECUTABLE (POSTLUDE *IMAGE-POSTLUDE*) (DUMP-HOOK *IMAGE-DUMP-HOOK*)) "Dump an image of the current Lisp environment at pathname FILENAME, with various options.
     [java]
     [java] First, finalize the image, by evaluating the POSTLUDE as per EVAL-INPUT, then calling each of
     [java]  the functions in DUMP-HOOK, in reverse order of registration by REGISTER-DUMP-HOOK.
     [java]
     [java] If EXECUTABLE is true, create an standalone executable program that calls RESTORE-IMAGE on startup.
     [java]
     [java] Pass various implementation-defined options, such as PREPEND-SYMBOLS and PURITY on CCL,
     [java] or COMPRESSION on SBCL, and APPLICATION-TYPE on SBCL/Windows." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE FILENAME OUTPUT-NAME EXECUTABLE)) (COMMON-LISP:SETF *IMAGE-DUMPED-P* (COMMON-LISP:IF EXECUTABLE :EXECUTABLE COMMON-LISP:T)) (COMMON-LISP:SETF *IMAGE-RESTORED-P* :IN-REGRESS) (COMMON-LISP:SETF *IMAGE-POSTLUDE* POSTLUDE) (STANDARD-EVAL-THUNK *IMAGE-POSTLUDE*) (COMMON-LISP:SETF *IMAGE-DUMP-HOOK* DUMP-HOOK) (CALL-IMAGE-DUMP-HOOK) (COMMON-LISP:SETF *IMAGE-RESTORED-P* COMMON-LISP:NIL) (COMMON-LISP:WHEN EXECUTABLE (COMMON-LISP:ERROR "Dumping an executable is not supported on this implementation! Aborting.")) (COMMON-LISP:ERROR "Can't ~S ~S: UIOP doesn't support image dumping with ~A.~%" (COMMON-LISP:QUOTE DUMP-IMAGE) FILENAME (COMMON-LISP:NTH-VALUE 1 (IMPLEMENTATION-TYPE)))) (COMMON-LISP:DEFUN CREATE-IMAGE (DESTINATION LISP-OBJECT-FILES COMMON-LISP:&KEY KIND OUTPUT-NAME PROLOGUE-CODE EPILOGUE-CODE EXTRA-OBJECT-FILES (PRELUDE COMMON-LISP:NIL PRELUDEP) (POSTLUDE COMMON-LISP:NIL POSTLUDEP) (ENTRY-POINT COMMON-LISP:NIL ENTRY-POINT-P) BUILD-ARGS NO-UIOP) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE DESTINATION LISP-OBJECT-FILES EXTRA-OBJECT-FILES KIND OUTPUT-NAME PROLOGUE-CODE EPILOGUE-CODE PRELUDE PRELUDEP POSTLUDE POSTLUDEP ENTRY-POINT ENTRY-POINT-P BUILD-ARGS NO-UIOP)) "On ECL, create an executable at pathname DESTINATION from the specified OBJECT-FILES and options" (COMMON-LISP:ERROR "~S not implemented for your implementation (yet)" (COMMON-LISP:QUOTE CREATE-IMAGE))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:QUOTE REGISTER-IMAGE-RESTORE-HOOK) (COMMON-LISP:QUOTE (SETUP-STDIN SETUP-STDOUT SETUP-STDERR SETUP-COMMAND-LINE-ARGUMENTS SETUP-TEMPORARY-DIRECTORY DETECT-OS))))
     [java] ; (DEFINE-PACKAGE :UIOP/RUN-PROGRAM (:NICKNAMES :ASDF/RUN-PROGRAM) (:RECYCLE :UIOP/RUN-PROGRAM :ASDF/RUN-PROGRAM :XCVB-DRIVER) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/PATHNAME :UIOP/OS :UIOP/FILESYSTEM :UIOP/STREAM) (:EXPORT #:EASY-SH-CHARACTER-P #:ESCAPE-SH-TOKEN #:ESCAPE-SH-COMMAND #:ESCAPE-WINDOWS-TOKEN #:ESCAPE-WINDOWS-COMMAND #:ESCAPE-TOKEN #:ESCAPE-COMMAND #:SLURP-INPUT-STREAM #:VOMIT-OUTPUT-STREAM #:RUN-PROGRAM #:SUBPROCESS-ERROR #:SUBPROCESS-ERROR-CODE #:SUBPROCESS-ERROR-COMMAND #:SUBPROCESS-ERROR-PROCESS))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/RUN-PROGRAM)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN REQUIRES-ESCAPING-P (TOKEN COMMON-LISP:&KEY GOOD-CHARS BAD-CHARS) "Does this token require escaping, given the specification of
     [java] either good chars that don't need escaping or bad chars that do need escaping,
     [java] as either a recognizing function or a sequence of characters." (COMMON-LISP:SOME (COMMON-LISP:COND ((COMMON-LISP:AND GOOD-CHARS BAD-CHARS) (COMMON-LISP:ERROR "only one of good-chars and bad-chars can be provided")) ((COMMON-LISP:TYPEP GOOD-CHARS (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION)) (COMMON-LISP:COMPLEMENT GOOD-CHARS)) ((COMMON-LISP:TYPEP BAD-CHARS (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION)) BAD-CHARS) ((COMMON-LISP:AND GOOD-CHARS (COMMON-LISP:TYPEP GOOD-CHARS (COMMON-LISP:QUOTE COMMON-LISP:SEQUENCE))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:NOT (COMMON-LISP:FIND C GOOD-CHARS))))) ((COMMON-LISP:AND BAD-CHARS (COMMON-LISP:TYPEP BAD-CHARS (COMMON-LISP:QUOTE COMMON-LISP:SEQUENCE))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:FIND C BAD-CHARS)))) (COMMON-LISP:T (COMMON-LISP:ERROR "requires-escaping-p: no good-char criterion"))) TOKEN)) (COMMON-LISP:DEFUN ESCAPE-TOKEN (TOKEN COMMON-LISP:&KEY COMMON-LISP:STREAM COMMON-LISP:QUOTE GOOD-CHARS BAD-CHARS ESCAPER) "Call the ESCAPER function on TOKEN string if it needs escaping as per
     [java] REQUIRES-ESCAPING-P using GOOD-CHARS and BAD-CHARS, otherwise output TOKEN,
     [java] using STREAM as output (or returning result as a string if NIL)" (COMMON-LISP:IF (REQUIRES-ESCAPING-P TOKEN :GOOD-CHARS GOOD-CHARS :BAD-CHARS BAD-CHARS) (WITH-OUTPUT (COMMON-LISP:STREAM) (COMMON-LISP:APPLY ESCAPER TOKEN COMMON-LISP:STREAM (COMMON-LISP:WHEN COMMON-LISP:QUOTE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :QUOTE) COMMON-LISP:QUOTE)))) (OUTPUT-STRING TOKEN COMMON-LISP:STREAM))) (COMMON-LISP:DEFUN ESCAPE-WINDOWS-TOKEN-WITHIN-DOUBLE-QUOTES (X COMMON-LISP:&OPTIONAL S) "Escape a string token X within double-quotes
     [java] for use within a MS Windows command-line, outputing to S." (COMMON-LISP:LABELS ((ISSUE (C) (COMMON-LISP:PRINC C S)) (ISSUE-BACKSLASH (N) (COMMON-LISP:LOOP :REPEAT N :DO (ISSUE #\\)))) (COMMON-LISP:LOOP :INITIALLY (ISSUE #\") :FINALLY (ISSUE #\") :WITH L COMMON-LISP:= (COMMON-LISP:LENGTH X) :WITH I COMMON-LISP:= 0 :FOR I+1 COMMON-LISP:= (COMMON-LISP:1+ I) :WHILE (COMMON-LISP:< I L) :DO (COMMON-LISP:CASE (COMMON-LISP:CHAR X I) ((#\") (ISSUE-BACKSLASH 1) (ISSUE #\") (COMMON-LISP:SETF I I+1)) ((#\\) (COMMON-LISP:LET* ((J (COMMON-LISP:AND (COMMON-LISP:< I+1 L) (COMMON-LISP:POSITION-IF-NOT (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:EQL C #\\))) X :START I+1))) (N (COMMON-LISP:- (COMMON-LISP:OR J L) I))) (COMMON-LISP:COND ((COMMON-LISP:NULL J) (ISSUE-BACKSLASH (COMMON-LISP:* 2 N)) (COMMON-LISP:SETF I L)) ((COMMON-LISP:AND (COMMON-LISP:< J L) (COMMON-LISP:EQL (COMMON-LISP:CHAR X J) #\")) (ISSUE-BACKSLASH (COMMON-LISP:1+ (COMMON-LISP:* 2 N))) (ISSUE #\") (COMMON-LISP:SETF I (COMMON-LISP:1+ J))) (COMMON-LISP:T (ISSUE-BACKSLASH N) (COMMON-LISP:SETF I J))))) (COMMON-LISP:OTHERWISE (ISSUE (COMMON-LISP:CHAR X I)) (COMMON-LISP:SETF I I+1)))))) (COMMON-LISP:DEFUN EASY-WINDOWS-CHARACTER-P (X) "Is X an \"easy\" character that does not require quoting by the shell?" (COMMON-LISP:OR (COMMON-LISP:ALPHANUMERICP X) (COMMON-LISP:FIND X "+-_.,@:/="))) (COMMON-LISP:DEFUN ESCAPE-WINDOWS-TOKEN (TOKEN COMMON-LISP:&OPTIONAL S) "Escape a string TOKEN within double-quotes if needed
     [java] for use within a MS Windows command-line, outputing to S." (ESCAPE-TOKEN TOKEN :STREAM S :GOOD-CHARS (COMMON-LISP:FUNCTION EASY-WINDOWS-CHARACTER-P) :QUOTE COMMON-LISP:NIL :ESCAPER (COMMON-LISP:QUOTE ESCAPE-WINDOWS-TOKEN-WITHIN-DOUBLE-QUOTES))) (COMMON-LISP:DEFUN ESCAPE-SH-TOKEN-WITHIN-DOUBLE-QUOTES (X S COMMON-LISP:&KEY (COMMON-LISP:QUOTE COMMON-LISP:T)) "Escape a string TOKEN within double-quotes
     [java] for use within a POSIX Bourne shell, outputing to S;
     [java] omit the outer double-quotes if key argument :QUOTE is NIL" (COMMON-LISP:WHEN COMMON-LISP:QUOTE (COMMON-LISP:PRINC #\" S)) (COMMON-LISP:LOOP :FOR C :ACROSS X :DO (COMMON-LISP:WHEN (COMMON-LISP:FIND C "$`\\\"") (COMMON-LISP:PRINC #\\ S)) (COMMON-LISP:PRINC C S)) (COMMON-LISP:WHEN COMMON-LISP:QUOTE (COMMON-LISP:PRINC #\" S))) (COMMON-LISP:DEFUN EASY-SH-CHARACTER-P (X) "Is X an \"easy\" character that does not require quoting by the shell?" (COMMON-LISP:OR (COMMON-LISP:ALPHANUMERICP X) (COMMON-LISP:FIND X "+-_.,%@:/="))) (COMMON-LISP:DEFUN ESCAPE-SH-TOKEN (TOKEN COMMON-LISP:&OPTIONAL S) "Escape a string TOKEN within double-quotes if needed
     [java] for use within a POSIX Bourne shell, outputing to S." (ESCAPE-TOKEN TOKEN :STREAM S :QUOTE #\" :GOOD-CHARS (COMMON-LISP:FUNCTION EASY-SH-CHARACTER-P) :ESCAPER (COMMON-LISP:QUOTE ESCAPE-SH-TOKEN-WITHIN-DOUBLE-QUOTES))) (COMMON-LISP:DEFUN ESCAPE-SHELL-TOKEN (TOKEN COMMON-LISP:&OPTIONAL S) "Escape a token for the current operating system shell" (OS-COND ((OS-UNIX-P) (ESCAPE-SH-TOKEN TOKEN S)) ((OS-WINDOWS-P) (ESCAPE-WINDOWS-TOKEN TOKEN S)))) (COMMON-LISP:DEFUN ESCAPE-COMMAND (COMMAND COMMON-LISP:&OPTIONAL S (ESCAPER (COMMON-LISP:QUOTE ESCAPE-SHELL-TOKEN))) "Given a COMMAND as a list of tokens, return a string of the
     [java] spaced, escaped tokens, using ESCAPER to escape." (COMMON-LISP:ETYPECASE COMMAND (COMMON-LISP:STRING (OUTPUT-STRING COMMAND S)) (COMMON-LISP:LIST (WITH-OUTPUT (S) (COMMON-LISP:LOOP :FOR COMMON-LISP:FIRST COMMON-LISP:= COMMON-LISP:T :THEN COMMON-LISP:NIL :FOR TOKEN :IN COMMAND :DO (COMMON-LISP:UNLESS COMMON-LISP:FIRST (COMMON-LISP:PRINC #\  S)) (COMMON-LISP:FUNCALL ESCAPER TOKEN S)))))) (COMMON-LISP:DEFUN ESCAPE-WINDOWS-COMMAND (COMMAND COMMON-LISP:&OPTIONAL S) "Escape a list of command-line arguments into a string suitable for parsing
     [java] by CommandLineToArgv in MS Windows" (ESCAPE-COMMAND COMMAND S (COMMON-LISP:QUOTE ESCAPE-WINDOWS-TOKEN))) (COMMON-LISP:DEFUN ESCAPE-SH-COMMAND (COMMAND COMMON-LISP:&OPTIONAL S) "Escape a list of command-line arguments into a string suitable for parsing
     [java] by /bin/sh in POSIX" (ESCAPE-COMMAND COMMAND S (COMMON-LISP:QUOTE ESCAPE-SH-TOKEN))) (COMMON-LISP:DEFUN ESCAPE-SHELL-COMMAND (COMMAND COMMON-LISP:&OPTIONAL COMMON-LISP:STREAM) "Escape a command for the current operating system's shell" (ESCAPE-COMMAND COMMAND COMMON-LISP:STREAM (COMMON-LISP:QUOTE ESCAPE-SHELL-TOKEN))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CALL-STREAM-PROCESSOR (FUN PROCESSOR COMMON-LISP:STREAM) "Given FUN (typically SLURP-INPUT-STREAM or VOMIT-OUTPUT-STREAM,
     [java] a PROCESSOR specification which is either an atom or a list specifying
     [java] a processor an keyword arguments, call the specified processor with
     [java] the given STREAM as input" (COMMON-LISP:IF (COMMON-LISP:CONSP PROCESSOR) (COMMON-LISP:APPLY FUN (COMMON-LISP:FIRST PROCESSOR) COMMON-LISP:STREAM (COMMON-LISP:REST PROCESSOR)) (COMMON-LISP:FUNCALL FUN PROCESSOR COMMON-LISP:STREAM))) (COMMON-LISP:DEFGENERIC SLURP-INPUT-STREAM (PROCESSOR INPUT-STREAM COMMON-LISP:&KEY) (:DOCUMENTATION "SLURP-INPUT-STREAM is a generic function with two positional arguments
     [java] PROCESSOR and INPUT-STREAM and additional keyword arguments, that consumes (slurps)
     [java] the contents of the INPUT-STREAM and processes them according to a method
     [java] specified by PROCESSOR.
     [java]
     [java] Built-in methods include the following:
     [java] * if PROCESSOR is a function, it is called with the INPUT-STREAM as its argument
     [java] * if PROCESSOR is a list, its first element should be a function.  It will be applied to a cons of the
     [java]   INPUT-STREAM and the rest of the list.  That is (x . y) will be treated as
     [java]     (APPLY x <stream> y)
     [java] * if PROCESSOR is an output-stream, the contents of INPUT-STREAM is copied to the output-stream,
     [java]   per copy-stream-to-stream, with appropriate keyword arguments.
     [java] * if PROCESSOR is the symbol CL:STRING or the keyword :STRING, then the contents of INPUT-STREAM
     [java]   are returned as a string, as per SLURP-STREAM-STRING.
     [java] * if PROCESSOR is the keyword :LINES then the INPUT-STREAM will be handled by SLURP-STREAM-LINES.
     [java] * if PROCESSOR is the keyword :LINE then the INPUT-STREAM will be handled by SLURP-STREAM-LINE.
     [java] * if PROCESSOR is the keyword :FORMS then the INPUT-STREAM will be handled by SLURP-STREAM-FORMS.
     [java] * if PROCESSOR is the keyword :FORM then the INPUT-STREAM will be handled by SLURP-STREAM-FORM.
     [java] * if PROCESSOR is T, it is treated the same as *standard-output*. If it is NIL, NIL is returned.
     [java]
     [java] Programmers are encouraged to define their own methods for this generic function.")) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((COMMON-LISP:FUNCTION COMMON-LISP:FUNCTION) INPUT-STREAM COMMON-LISP:&KEY) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION INPUT-STREAM)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((COMMON-LISP:LIST COMMON-LISP:CONS) INPUT-STREAM COMMON-LISP:&KEY) (COMMON-LISP:APPLY (COMMON-LISP:FIRST COMMON-LISP:LIST) INPUT-STREAM (COMMON-LISP:REST COMMON-LISP:LIST))) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((OUTPUT-STREAM COMMON-LISP:STREAM) INPUT-STREAM COMMON-LISP:&KEY LINEWISE PREFIX (ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) BUFFER-SIZE) (COPY-STREAM-TO-STREAM INPUT-STREAM OUTPUT-STREAM :LINEWISE LINEWISE :PREFIX PREFIX :ELEMENT-TYPE ELEMENT-TYPE :BUFFER-SIZE BUFFER-SIZE)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL (COMMON-LISP:QUOTE COMMON-LISP:STRING))) COMMON-LISP:STREAM COMMON-LISP:&KEY STRIPPED) (SLURP-STREAM-STRING COMMON-LISP:STREAM :STRIPPED STRIPPED)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL :STRING)) COMMON-LISP:STREAM COMMON-LISP:&KEY STRIPPED) (SLURP-STREAM-STRING COMMON-LISP:STREAM :STRIPPED STRIPPED)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL :LINES)) COMMON-LISP:STREAM COMMON-LISP:&KEY COMMON-LISP:COUNT) (SLURP-STREAM-LINES COMMON-LISP:STREAM :COUNT COMMON-LISP:COUNT)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL :LINE)) COMMON-LISP:STREAM COMMON-LISP:&KEY (AT 0)) (SLURP-STREAM-LINE COMMON-LISP:STREAM :AT AT)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL :FORMS)) COMMON-LISP:STREAM COMMON-LISP:&KEY COMMON-LISP:COUNT) (SLURP-STREAM-FORMS COMMON-LISP:STREAM :COUNT COMMON-LISP:COUNT)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL :FORM)) COMMON-LISP:STREAM COMMON-LISP:&KEY (AT 0)) (SLURP-STREAM-FORM COMMON-LISP:STREAM :AT AT)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X (COMMON-LISP:EQL COMMON-LISP:T)) COMMON-LISP:STREAM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE SLURP-INPUT-STREAM) COMMON-LISP:*STANDARD-OUTPUT* COMMON-LISP:STREAM KEYS)) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((X COMMON-LISP:NULL) (COMMON-LISP:STREAM COMMON-LISP:T) COMMON-LISP:&KEY) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM ((COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME) INPUT COMMON-LISP:&KEY (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (IF-EXISTS :RENAME-AND-DELETE) (IF-DOES-NOT-EXIST :CREATE) BUFFER-SIZE LINEWISE) (WITH-OUTPUT-FILE (OUTPUT COMMON-LISP:PATHNAME :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-EXISTS IF-EXISTS :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST) (COPY-STREAM-TO-STREAM INPUT OUTPUT :ELEMENT-TYPE ELEMENT-TYPE :BUFFER-SIZE BUFFER-SIZE :LINEWISE LINEWISE))) (COMMON-LISP:DEFMETHOD SLURP-INPUT-STREAM (X COMMON-LISP:STREAM COMMON-LISP:&KEY LINEWISE PREFIX (ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) BUFFER-SIZE) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:STREAM LINEWISE PREFIX ELEMENT-TYPE BUFFER-SIZE)) (COMMON-LISP:COND (COMMON-LISP:T (COMMON-LISP:ERROR "Invalid ~S destination ~S" (COMMON-LISP:QUOTE SLURP-INPUT-STREAM) X)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC VOMIT-OUTPUT-STREAM (PROCESSOR OUTPUT-STREAM COMMON-LISP:&KEY) (:DOCUMENTATION "VOMIT-OUTPUT-STREAM is a generic function with two positional arguments
     [java] PROCESSOR and OUTPUT-STREAM and additional keyword arguments, that produces (vomits)
     [java] some content onto the OUTPUT-STREAM, according to a method specified by PROCESSOR.
     [java]
     [java] Built-in methods include the following:
     [java] * if PROCESSOR is a function, it is called with the OUTPUT-STREAM as its argument
     [java] * if PROCESSOR is a list, its first element should be a function.
     [java]   It will be applied to a cons of the OUTPUT-STREAM and the rest of the list.
     [java]   That is (x . y) will be treated as (APPLY x <stream> y)
     [java] * if PROCESSOR is an input-stream, its contents will be copied the OUTPUT-STREAM,
     [java]   per copy-stream-to-stream, with appropriate keyword arguments.
     [java] * if PROCESSOR is a string, its contents will be printed to the OUTPUT-STREAM.
     [java] * if PROCESSOR is T, it is treated the same as *standard-input*. If it is NIL, nothing is done.
     [java]
     [java] Programmers are encouraged to define their own methods for this generic function.")) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((COMMON-LISP:FUNCTION COMMON-LISP:FUNCTION) OUTPUT-STREAM COMMON-LISP:&KEY) (COMMON-LISP:FUNCALL COMMON-LISP:FUNCTION OUTPUT-STREAM)) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((COMMON-LISP:LIST COMMON-LISP:CONS) OUTPUT-STREAM COMMON-LISP:&KEY) (COMMON-LISP:APPLY (COMMON-LISP:FIRST COMMON-LISP:LIST) OUTPUT-STREAM (COMMON-LISP:REST COMMON-LISP:LIST))) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((INPUT-STREAM COMMON-LISP:STREAM) OUTPUT-STREAM COMMON-LISP:&KEY LINEWISE PREFIX (ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) BUFFER-SIZE) (COPY-STREAM-TO-STREAM INPUT-STREAM OUTPUT-STREAM :LINEWISE LINEWISE :PREFIX PREFIX :ELEMENT-TYPE ELEMENT-TYPE :BUFFER-SIZE BUFFER-SIZE)) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((X COMMON-LISP:STRING) COMMON-LISP:STREAM COMMON-LISP:&KEY COMMON-LISP:FRESH-LINE COMMON-LISP:TERPRI) (COMMON-LISP:PRINC X COMMON-LISP:STREAM) (COMMON-LISP:WHEN COMMON-LISP:FRESH-LINE (COMMON-LISP:FRESH-LINE COMMON-LISP:STREAM)) (COMMON-LISP:WHEN COMMON-LISP:TERPRI (COMMON-LISP:TERPRI COMMON-LISP:STREAM)) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((X (COMMON-LISP:EQL COMMON-LISP:T)) COMMON-LISP:STREAM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE VOMIT-OUTPUT-STREAM) COMMON-LISP:*STANDARD-INPUT* COMMON-LISP:STREAM KEYS)) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((X COMMON-LISP:NULL) (COMMON-LISP:STREAM COMMON-LISP:T) COMMON-LISP:&KEY) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM ((COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME) INPUT COMMON-LISP:&KEY (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (IF-EXISTS :RENAME-AND-DELETE) (IF-DOES-NOT-EXIST :CREATE) BUFFER-SIZE LINEWISE) (WITH-OUTPUT-FILE (OUTPUT COMMON-LISP:PATHNAME :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-EXISTS IF-EXISTS :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST) (COPY-STREAM-TO-STREAM INPUT OUTPUT :ELEMENT-TYPE ELEMENT-TYPE :BUFFER-SIZE BUFFER-SIZE :LINEWISE LINEWISE))) (COMMON-LISP:DEFMETHOD VOMIT-OUTPUT-STREAM (X COMMON-LISP:STREAM COMMON-LISP:&KEY LINEWISE PREFIX (ELEMENT-TYPE (COMMON-LISP:QUOTE COMMON-LISP:CHARACTER)) BUFFER-SIZE) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:STREAM LINEWISE PREFIX ELEMENT-TYPE BUFFER-SIZE)) (COMMON-LISP:COND (COMMON-LISP:T (COMMON-LISP:ERROR "Invalid ~S source ~S" (COMMON-LISP:QUOTE VOMIT-OUTPUT-STREAM) X)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION SUBPROCESS-ERROR (COMMON-LISP:ERROR) ((CODE :INITFORM COMMON-LISP:NIL :INITARG :CODE :READER SUBPROCESS-ERROR-CODE) (COMMAND :INITFORM COMMON-LISP:NIL :INITARG :COMMAND :READER SUBPROCESS-ERROR-COMMAND) (PROCESS :INITFORM COMMON-LISP:NIL :INITARG :PROCESS :READER SUBPROCESS-ERROR-PROCESS)) (:REPORT (COMMON-LISP:LAMBDA (COMMON-LISP:CONDITION COMMON-LISP:STREAM) (COMMON-LISP:FORMAT COMMON-LISP:STREAM "Subprocess ~@[~S~% ~]~@[with command ~S~% ~]exited with error~@[ code ~D~]" (SUBPROCESS-ERROR-PROCESS COMMON-LISP:CONDITION) (SUBPROCESS-ERROR-COMMAND COMMON-LISP:CONDITION) (SUBPROCESS-ERROR-CODE COMMON-LISP:CONDITION))))) (COMMON-LISP:DEFUN %CMD-SHELL-PATHNAME COMMON-LISP:NIL (OS-COND ((OS-WINDOWS-P) (STRCAT (NATIVE-NAMESTRING (GETENV-ABSOLUTE-DIRECTORY "WINDIR")) "System32\\cmd.exe")) (COMMON-LISP:T (COMMON-LISP:ERROR "CMD.EXE is not the command shell for this OS.")))) (COMMON-LISP:DEFUN %NORMALIZE-COMMAND (COMMAND) "Given a COMMAND as a list or string, transform it in a format suitable
     [java] for the implementation's underlying run-program function" (COMMON-LISP:ETYPECASE COMMAND (COMMON-LISP:STRING (SYSTEM::BACKQ-LIST "/bin/sh" "-c" COMMAND)) (COMMON-LISP:LIST COMMAND))) (COMMON-LISP:DEFUN %ACTIVE-IO-SPECIFIER-P (SPECIFIER) "Determines whether a run-program I/O specifier requires Lisp-side processing
     [java] via SLURP-INPUT-STREAM or VOMIT-OUTPUT-STREAM (return T),
     [java] or whether it's already taken care of by the implementation's underlying run-program." (COMMON-LISP:NOT (COMMON-LISP:TYPEP SPECIFIER (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING COMMON-LISP:PATHNAME (COMMON-LISP:MEMBER :INTERACTIVE :OUTPUT)))))) (COMMON-LISP:DEFUN %NORMALIZE-IO-SPECIFIER (SPECIFIER COMMON-LISP:&OPTIONAL ROLE) "Normalizes a portable I/O specifier for %RUN-PROGRAM into an implementation-dependent
     [java] argument to pass to the internal RUN-PROGRAM" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE ROLE)) (COMMON-LISP:ETYPECASE SPECIFIER (COMMON-LISP:NULL (COMMON-LISP:OR)) (COMMON-LISP:STRING (PARSE-NATIVE-NAMESTRING SPECIFIER)) (COMMON-LISP:PATHNAME SPECIFIER) (COMMON-LISP:STREAM SPECIFIER) ((COMMON-LISP:EQL :STREAM) :STREAM) ((COMMON-LISP:EQL :INTERACTIVE)))) (COMMON-LISP:DEFUN %INTERACTIVEP (INPUT OUTPUT ERROR-OUTPUT) (COMMON-LISP:MEMBER :INTERACTIVE (COMMON-LISP:LIST INPUT OUTPUT ERROR-OUTPUT))) (COMMON-LISP:DEFUN %RUN-PROGRAM (COMMAND COMMON-LISP:&REST KEYS COMMON-LISP:&KEY INPUT (IF-INPUT-DOES-NOT-EXIST :ERROR) OUTPUT (IF-OUTPUT-EXISTS :OVERWRITE) ERROR-OUTPUT (IF-ERROR-OUTPUT-EXISTS :OVERWRITE) COMMON-LISP:DIRECTORY WAIT COMMON-LISP:&ALLOW-OTHER-KEYS) "A portable abstraction of a low-level call to the implementation's run-program or equivalent.
     [java] It spawns a subprocess that runs the specified COMMAND (a list of program and arguments).
     [java] INPUT, OUTPUT and ERROR-OUTPUT specify a portable IO specifer,
     [java] to be normalized by %NORMALIZE-IO-SPECIFIER.
     [java] It returns a process-info plist with possible keys:
     [java]      PROCESS, EXIT-CODE, INPUT-STREAM, OUTPUT-STREAM, BIDIR-STREAM, ERROR-STREAM." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE COMMON-LISP:DIRECTORY IF-INPUT-DOES-NOT-EXIST IF-OUTPUT-EXISTS IF-ERROR-OUTPUT-EXISTS)) (COMMON-LISP:ASSERT (COMMON-LISP:NOT (COMMON-LISP:AND WAIT (COMMON-LISP:MEMBER :STREAM (COMMON-LISP:LIST INPUT OUTPUT ERROR-OUTPUT))))) (COMMON-LISP:PROGN COMMAND KEYS COMMON-LISP:DIRECTORY (COMMON-LISP:ERROR "run-program not available"))) (COMMON-LISP:DEFUN %PROCESS-INFO-PID (PROCESS-INFO) (COMMON-LISP:LET ((PROCESS (COMMON-LISP:GETF PROCESS-INFO :PROCESS))) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE PROCESS)) (COMMON-LISP:ERROR "~S not implemented" (COMMON-LISP:QUOTE %PROCESS-INFO-PID)))) (COMMON-LISP:DEFUN %WAIT-PROCESS-RESULT (PROCESS-INFO) (COMMON-LISP:OR (COMMON-LISP:GETF PROCESS-INFO :EXIT-CODE) (COMMON-LISP:LET ((PROCESS (COMMON-LISP:GETF PROCESS-INFO :PROCESS))) (COMMON-LISP:WHEN PROCESS)))) (COMMON-LISP:DEFUN %CHECK-RESULT (EXIT-CODE COMMON-LISP:&KEY COMMAND PROCESS IGNORE-ERROR-STATUS) (COMMON-LISP:UNLESS IGNORE-ERROR-STATUS (COMMON-LISP:UNLESS (COMMON-LISP:EQL EXIT-CODE 0) (COMMON-LISP:CERROR "IGNORE-ERROR-STATUS" (COMMON-LISP:QUOTE SUBPROCESS-ERROR) :COMMAND COMMAND :CODE EXIT-CODE :PROCESS PROCESS))) EXIT-CODE) (COMMON-LISP:DEFUN %CALL-WITH-PROGRAM-IO (GF TVAL STREAM-EASY-P FUN DIRECTION SPEC ACTIVEP RETURNER COMMON-LISP:&KEY ELEMENT-TYPE EXTERNAL-FORMAT COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE STREAM-EASY-P)) (COMMON-LISP:LET* ((ACTUAL-SPEC (COMMON-LISP:IF (COMMON-LISP:EQ SPEC COMMON-LISP:T) TVAL SPEC)) (ACTIVITY-SPEC (COMMON-LISP:IF (COMMON-LISP:EQ ACTUAL-SPEC :OUTPUT) (COMMON-LISP:ECASE DIRECTION ((:INPUT :OUTPUT) (COMMON-LISP:ERROR "~S not allowed as a ~S ~S spec" :OUTPUT (COMMON-LISP:QUOTE RUN-PROGRAM) DIRECTION)) ((:ERROR-OUTPUT) COMMON-LISP:NIL)) ACTUAL-SPEC))) (COMMON-LISP:LABELS ((ACTIVITY (COMMON-LISP:STREAM) (CALL-FUNCTION RETURNER (CALL-STREAM-PROCESSOR GF ACTIVITY-SPEC COMMON-LISP:STREAM))) (EASY-CASE COMMON-LISP:NIL (COMMON-LISP:FUNCALL FUN ACTUAL-SPEC COMMON-LISP:NIL)) (HARD-CASE COMMON-LISP:NIL (COMMON-LISP:IF ACTIVEP (COMMON-LISP:FUNCALL FUN :STREAM (COMMON-LISP:FUNCTION ACTIVITY)) (WITH-TEMPORARY-FILE (:PATHNAME TMP) (COMMON-LISP:ECASE DIRECTION (:INPUT (WITH-OUTPUT-FILE (S TMP :IF-EXISTS :OVERWRITE :EXTERNAL-FORMAT EXTERNAL-FORMAT :ELEMENT-TYPE ELEMENT-TYPE) (ACTIVITY S)) (COMMON-LISP:FUNCALL FUN TMP COMMON-LISP:NIL)) ((:OUTPUT :ERROR-OUTPUT) (COMMON-LISP:MULTIPLE-VALUE-PROG1 (COMMON-LISP:FUNCALL FUN TMP COMMON-LISP:NIL) (WITH-INPUT-FILE (S TMP :EXTERNAL-FORMAT EXTERNAL-FORMAT :ELEMENT-TYPE ELEMENT-TYPE) (ACTIVITY S))))))))) (COMMON-LISP:TYPECASE ACTIVITY-SPEC ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING COMMON-LISP:PATHNAME (COMMON-LISP:EQL :INTERACTIVE)) (EASY-CASE)) (COMMON-LISP:T (HARD-CASE)))))) (COMMON-LISP:DEFMACRO PLACE-SETTER (PLACE) (COMMON-LISP:WHEN PLACE (COMMON-LISP:LET ((VALUE (COMMON-LISP:GENSYM))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST VALUE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:SETF) PLACE VALUE)))))) (COMMON-LISP:DEFMACRO WITH-PROGRAM-INPUT (((REDUCED-INPUT-VAR COMMON-LISP:&OPTIONAL (INPUT-ACTIVITY-VAR (COMMON-LISP:GENSYM) IAVP)) INPUT-FORM COMMON-LISP:&KEY COMMON-LISP:SETF STREAM-EASY-P ACTIVE KEYS) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE %CALL-WITH-PROGRAM-IO)) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE VOMIT-OUTPUT-STREAM)) (COMMON-LISP:QUOTE COMMON-LISP:*STANDARD-INPUT*) STREAM-EASY-P (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST REDUCED-INPUT-VAR INPUT-ACTIVITY-VAR) (SYSTEM::BACKQ-APPEND (COMMON-LISP:UNLESS IAVP (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DECLARE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IGNORE) INPUT-ACTIVITY-VAR)))) BODY))) (COMMON-LISP:QUOTE :INPUT) INPUT-FORM ACTIVE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE PLACE-SETTER) COMMON-LISP:SETF) KEYS)) (COMMON-LISP:DEFMACRO WITH-PROGRAM-OUTPUT (((REDUCED-OUTPUT-VAR COMMON-LISP:&OPTIONAL (OUTPUT-ACTIVITY-VAR (COMMON-LISP:GENSYM) OAVP)) OUTPUT-FORM COMMON-LISP:&KEY COMMON-LISP:SETF STREAM-EASY-P ACTIVE KEYS) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE %CALL-WITH-PROGRAM-IO)) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE SLURP-INPUT-STREAM)) (COMMON-LISP:QUOTE COMMON-LISP:*STANDARD-OUTPUT*) STREAM-EASY-P (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST REDUCED-OUTPUT-VAR OUTPUT-ACTIVITY-VAR) (SYSTEM::BACKQ-APPEND (COMMON-LISP:UNLESS OAVP (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DECLARE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IGNORE) OUTPUT-ACTIVITY-VAR)))) BODY))) (COMMON-LISP:QUOTE :OUTPUT) OUTPUT-FORM ACTIVE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE PLACE-SETTER) COMMON-LISP:SETF) KEYS)) (COMMON-LISP:DEFMACRO WITH-PROGRAM-ERROR-OUTPUT (((REDUCED-ERROR-OUTPUT-VAR COMMON-LISP:&OPTIONAL (ERROR-OUTPUT-ACTIVITY-VAR (COMMON-LISP:GENSYM) EOAVP)) ERROR-OUTPUT-FORM COMMON-LISP:&KEY COMMON-LISP:SETF STREAM-EASY-P ACTIVE KEYS) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE %CALL-WITH-PROGRAM-IO)) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE SLURP-INPUT-STREAM)) (COMMON-LISP:QUOTE COMMON-LISP:*ERROR-OUTPUT*) STREAM-EASY-P (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) (SYSTEM::BACKQ-LIST REDUCED-ERROR-OUTPUT-VAR ERROR-OUTPUT-ACTIVITY-VAR) (SYSTEM::BACKQ-APPEND (COMMON-LISP:UNLESS EOAVP (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DECLARE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IGNORE) ERROR-OUTPUT-ACTIVITY-VAR)))) BODY))) (COMMON-LISP:QUOTE :ERROR-OUTPUT) ERROR-OUTPUT-FORM ACTIVE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE PLACE-SETTER) COMMON-LISP:SETF) KEYS)) (COMMON-LISP:DEFUN %USE-RUN-PROGRAM (COMMAND COMMON-LISP:&REST KEYS COMMON-LISP:&KEY INPUT OUTPUT ERROR-OUTPUT IGNORE-ERROR-STATUS COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:PROGN COMMAND KEYS INPUT OUTPUT ERROR-OUTPUT IGNORE-ERROR-STATUS (COMMON-LISP:ERROR "Not implemented on this platform")) (COMMON-LISP:ASSERT (COMMON-LISP:NOT (COMMON-LISP:MEMBER :STREAM (COMMON-LISP:LIST INPUT OUTPUT ERROR-OUTPUT)))) (COMMON-LISP:LET* ((ACTIVE-INPUT-P (%ACTIVE-IO-SPECIFIER-P INPUT)) (ACTIVE-OUTPUT-P (%ACTIVE-IO-SPECIFIER-P OUTPUT)) (ACTIVE-ERROR-OUTPUT-P (%ACTIVE-IO-SPECIFIER-P ERROR-OUTPUT)) (ACTIVITY (COMMON-LISP:COND (ACTIVE-OUTPUT-P :OUTPUT) (ACTIVE-INPUT-P :INPUT) (ACTIVE-ERROR-OUTPUT-P :ERROR-OUTPUT) (COMMON-LISP:T COMMON-LISP:NIL))) (WAIT (COMMON-LISP:NOT ACTIVITY)) OUTPUT-RESULT ERROR-OUTPUT-RESULT EXIT-CODE) (WITH-PROGRAM-OUTPUT ((REDUCED-OUTPUT OUTPUT-ACTIVITY) OUTPUT :KEYS KEYS :SETF OUTPUT-RESULT :STREAM-EASY-P COMMON-LISP:T :ACTIVE (COMMON-LISP:EQ ACTIVITY :OUTPUT)) (WITH-PROGRAM-ERROR-OUTPUT ((REDUCED-ERROR-OUTPUT ERROR-OUTPUT-ACTIVITY) ERROR-OUTPUT :KEYS KEYS :SETF ERROR-OUTPUT-RESULT :STREAM-EASY-P COMMON-LISP:T :ACTIVE (COMMON-LISP:EQ ACTIVITY :ERROR-OUTPUT)) (WITH-PROGRAM-INPUT ((REDUCED-INPUT INPUT-ACTIVITY) INPUT :KEYS KEYS :STREAM-EASY-P COMMON-LISP:T :ACTIVE (COMMON-LISP:EQ ACTIVITY :INPUT)) (COMMON-LISP:LET ((PROCESS-INFO (COMMON-LISP:APPLY (COMMON-LISP:QUOTE %RUN-PROGRAM) COMMAND :WAIT WAIT :INPUT REDUCED-INPUT :OUTPUT REDUCED-OUTPUT :ERROR-OUTPUT (COMMON-LISP:IF (COMMON-LISP:EQ ERROR-OUTPUT :OUTPUT) :OUTPUT REDUCED-ERROR-OUTPUT) KEYS))) (COMMON-LISP:LABELS ((GET-STREAM (STREAM-NAME COMMON-LISP:&OPTIONAL FALLBACKP) (COMMON-LISP:OR (COMMON-LISP:GETF PROCESS-INFO STREAM-NAME) (COMMON-LISP:WHEN FALLBACKP (COMMON-LISP:GETF PROCESS-INFO :BIDIR-STREAM)))) (RUN-ACTIVITY (ACTIVITY STREAM-NAME COMMON-LISP:&OPTIONAL FALLBACKP) (IF-LET (COMMON-LISP:STREAM (GET-STREAM STREAM-NAME FALLBACKP)) (COMMON-LISP:FUNCALL ACTIVITY COMMON-LISP:STREAM) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE SUBPROCESS-ERROR) :CODE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :MISSING) STREAM-NAME) :COMMAND COMMAND :PROCESS PROCESS-INFO)))) (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:ECASE ACTIVITY ((COMMON-LISP:NIL)) (:INPUT (RUN-ACTIVITY INPUT-ACTIVITY :INPUT-STREAM COMMON-LISP:T)) (:OUTPUT (RUN-ACTIVITY OUTPUT-ACTIVITY :OUTPUT-STREAM COMMON-LISP:T)) (:ERROR-OUTPUT (RUN-ACTIVITY ERROR-OUTPUT-ACTIVITY :ERROR-OUTPUT-STREAM))) (COMMON-LISP:LOOP :FOR (COMMON-LISP:NIL VAL) :ON PROCESS-INFO :BY (COMMON-LISP:FUNCTION COMMON-LISP:CDDR) :WHEN (COMMON-LISP:STREAMP VAL) :DO (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:CLOSE VAL))) (COMMON-LISP:SETF EXIT-CODE (%CHECK-RESULT (%WAIT-PROCESS-RESULT PROCESS-INFO) :COMMAND COMMAND :PROCESS PROCESS-INFO :IGNORE-ERROR-STATUS IGNORE-ERROR-STATUS)))))))) (COMMON-LISP:VALUES OUTPUT-RESULT ERROR-OUTPUT-RESULT EXIT-CODE))) (COMMON-LISP:DEFUN %NORMALIZE-SYSTEM-COMMAND (COMMAND) (COMMON-LISP:ETYPECASE COMMAND (COMMON-LISP:STRING (OS-COND ((OS-WINDOWS-P) COMMAND) (COMMON-LISP:T COMMAND))) (COMMON-LISP:LIST (ESCAPE-SHELL-COMMAND (OS-COND ((OS-UNIX-P) (COMMON-LISP:CONS "exec" COMMAND)) ((OS-WINDOWS-P) COMMAND) (COMMON-LISP:T COMMAND)))))) (COMMON-LISP:DEFUN %REDIRECTED-SYSTEM-COMMAND (COMMAND IN OUT ERR COMMON-LISP:DIRECTORY) (COMMON-LISP:FLET ((REDIRECT (SPEC OPERATOR) (COMMON-LISP:LET ((COMMON-LISP:PATHNAME (COMMON-LISP:TYPECASE SPEC (COMMON-LISP:NULL (NULL-DEVICE-PATHNAME)) (COMMON-LISP:STRING (PARSE-NATIVE-NAMESTRING SPEC)) (COMMON-LISP:PATHNAME SPEC) ((COMMON-LISP:EQL :OUTPUT) (COMMON-LISP:ASSERT (COMMON-LISP:EQUAL OPERATOR " 2>")) (COMMON-LISP:RETURN-FROM REDIRECT (COMMON-LISP:QUOTE (" 2>&1"))))))) (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:LIST OPERATOR " " (ESCAPE-SHELL-TOKEN (NATIVE-NAMESTRING COMMON-LISP:PATHNAME))))))) (COMMON-LISP:LET* ((REDIRECTIONS (COMMON-LISP:APPEND (REDIRECT IN " <") (REDIRECT OUT " >") (REDIRECT ERR " 2>"))) (NORMALIZED (%NORMALIZE-SYSTEM-COMMAND COMMAND)) (COMMON-LISP:DIRECTORY (COMMON-LISP:OR COMMON-LISP:DIRECTORY (GETCWD))) (CHDIR (COMMON-LISP:WHEN COMMON-LISP:DIRECTORY (COMMON-LISP:LET ((DIR-ARG (ESCAPE-SHELL-TOKEN (NATIVE-NAMESTRING COMMON-LISP:DIRECTORY)))) (OS-COND ((OS-UNIX-P) (SYSTEM::BACKQ-LIST* "cd " DIR-ARG (COMMON-LISP:QUOTE (" ; ")))) ((OS-WINDOWS-P) (SYSTEM::BACKQ-LIST* "cd /d " DIR-ARG (COMMON-LISP:QUOTE (" & "))))))))) (REDUCE/STRCAT (OS-COND ((OS-UNIX-P) (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN REDIRECTIONS (SYSTEM::BACKQ-CONS "exec " (SYSTEM::BACKQ-APPEND REDIRECTIONS (COMMON-LISP:QUOTE (" ; "))))) CHDIR (SYSTEM::BACKQ-LIST NORMALIZED))) ((OS-WINDOWS-P) (SYSTEM::BACKQ-APPEND CHDIR REDIRECTIONS (SYSTEM::BACKQ-LIST " " NORMALIZED)))))))) (COMMON-LISP:DEFUN %SYSTEM (COMMAND COMMON-LISP:&REST KEYS COMMON-LISP:&KEY INPUT OUTPUT ERROR-OUTPUT COMMON-LISP:DIRECTORY COMMON-LISP:&ALLOW-OTHER-KEYS) "A portable abstraction of a low-level call to libc's system()." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE INPUT OUTPUT ERROR-OUTPUT COMMON-LISP:DIRECTORY KEYS)) (COMMON-LISP:LET ((%COMMAND (%REDIRECTED-SYSTEM-COMMAND COMMAND INPUT OUTPUT ERROR-OUTPUT COMMON-LISP:DIRECTORY))) (WITH-CURRENT-DIRECTORY ((OS-COND ((COMMON-LISP:NOT (OS-UNIX-P)) COMMON-LISP:DIRECTORY))) (EXTENSIONS:RUN-SHELL-COMMAND %COMMAND)))) (COMMON-LISP:DEFUN %USE-SYSTEM (COMMAND COMMON-LISP:&REST KEYS COMMON-LISP:&KEY INPUT OUTPUT ERROR-OUTPUT IGNORE-ERROR-STATUS COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET (OUTPUT-RESULT ERROR-OUTPUT-RESULT EXIT-CODE) (WITH-PROGRAM-OUTPUT ((REDUCED-OUTPUT) OUTPUT :KEYS KEYS :SETF OUTPUT-RESULT) (WITH-PROGRAM-ERROR-OUTPUT ((REDUCED-ERROR-OUTPUT) ERROR-OUTPUT :KEYS KEYS :SETF ERROR-OUTPUT-RESULT) (WITH-PROGRAM-INPUT ((REDUCED-INPUT) INPUT :KEYS KEYS) (COMMON-LISP:SETF EXIT-CODE (%CHECK-RESULT (COMMON-LISP:APPLY (COMMON-LISP:QUOTE %SYSTEM) COMMAND :INPUT REDUCED-INPUT :OUTPUT REDUCED-OUTPUT :ERROR-OUTPUT REDUCED-ERROR-OUTPUT KEYS) :COMMAND COMMAND :IGNORE-ERROR-STATUS IGNORE-ERROR-STATUS))))) (COMMON-LISP:VALUES OUTPUT-RESULT ERROR-OUTPUT-RESULT EXIT-CODE))) (COMMON-LISP:DEFUN RUN-PROGRAM (COMMAND COMMON-LISP:&REST KEYS COMMON-LISP:&KEY IGNORE-ERROR-STATUS (FORCE-SHELL COMMON-LISP:NIL FORCE-SHELL-SUPPLIEDP) (INPUT COMMON-LISP:NIL INPUTP) (IF-INPUT-DOES-NOT-EXIST :ERROR) OUTPUT (IF-OUTPUT-EXISTS :OVERWRITE) (ERROR-OUTPUT COMMON-LISP:NIL ERROR-OUTPUT-P) (IF-ERROR-OUTPUT-EXISTS :OVERWRITE) (ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE*) (EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) COMMON-LISP:&ALLOW-OTHER-KEYS) "Run program specified by COMMAND,
     [java] either a list of strings specifying a program and list of arguments,
     [java] or a string specifying a shell command (/bin/sh on Unix, CMD.EXE on Windows);
     [java] _synchronously_ process its output as specified and return the processing results
     [java] when the program and its output processing are complete.
     [java]
     [java] Always call a shell (rather than directly execute the command when possible)
     [java] if FORCE-SHELL is specified.  Similarly, never call a shell if FORCE-SHELL is
     [java] specified to be NIL.
     [java]
     [java] Signal a continuable SUBPROCESS-ERROR if the process wasn't successful (exit-code 0),
     [java] unless IGNORE-ERROR-STATUS is specified.
     [java]
     [java] If OUTPUT is a pathname, a string designating a pathname, or NIL designating the null device,
     [java] the file at that path is used as output.
     [java] If it's :INTERACTIVE, output is inherited from the current process;
     [java] beware that this may be different from your *STANDARD-OUTPUT*,
     [java] and under SLIME will be on your *inferior-lisp* buffer.
     [java] If it's T, output goes to your current *STANDARD-OUTPUT* stream.
     [java] Otherwise, OUTPUT should be a value that is a suitable first argument to
     [java] SLURP-INPUT-STREAM (qv.), or a list of such a value and keyword arguments.
     [java] In this case, RUN-PROGRAM will create a temporary stream for the program output;
     [java] the program output, in that stream, will be processed by a call to SLURP-INPUT-STREAM,
     [java] using OUTPUT as the first argument (or the first element of OUTPUT, and the rest as keywords).
     [java] The primary value resulting from that call (or NIL if no call was needed)
     [java] will be the first value returned by RUN-PROGRAM.
     [java] E.g., using :OUTPUT :STRING will have it return the entire output stream as a string.
     [java] And using :OUTPUT '(:STRING :STRIPPED T) will have it return the same string
     [java] stripped of any ending newline.
     [java]
     [java] ERROR-OUTPUT is similar to OUTPUT, except that the resulting value is returned
     [java] as the second value of RUN-PROGRAM. T designates the *ERROR-OUTPUT*.
     [java] Also :OUTPUT means redirecting the error output to the output stream,
     [java] in which case NIL is returned.
     [java]
     [java] INPUT is similar to OUTPUT, except that VOMIT-OUTPUT-STREAM is used,
     [java] no value is returned, and T designates the *STANDARD-INPUT*.
     [java]
     [java] Use ELEMENT-TYPE and EXTERNAL-FORMAT are passed on
     [java] to your Lisp implementation, when applicable, for creation of the output stream.
     [java]
     [java] One and only one of the stream slurping or vomiting may or may not happen
     [java] in parallel in parallel with the subprocess,
     [java] depending on options and implementation,
     [java] and with priority being given to output processing.
     [java] Other streams are completely produced or consumed
     [java] before or after the subprocess is spawned, using temporary files.
     [java]
     [java] RUN-PROGRAM returns 3 values:
     [java] 0- the result of the OUTPUT slurping if any, or NIL
     [java] 1- the result of the ERROR-OUTPUT slurping if any, or NIL
     [java] 2- either 0 if the subprocess exited with success status,
     [java] or an indication of failure via the EXIT-CODE of the process" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE IGNORE-ERROR-STATUS)) (COMMON-LISP:WHEN (COMMON-LISP:STRINGP COMMAND) (COMMON-LISP:UNLESS FORCE-SHELL-SUPPLIEDP (COMMON-LISP:SETF FORCE-SHELL COMMON-LISP:T))) (COMMON-LISP:FLET ((DEFAULT (X XP OUTPUT) (COMMON-LISP:COND (XP X) ((COMMON-LISP:EQ OUTPUT :INTERACTIVE) :INTERACTIVE)))) (COMMON-LISP:APPLY (COMMON-LISP:IF (COMMON-LISP:OR FORCE-SHELL COMMON-LISP:T) (COMMON-LISP:QUOTE %USE-SYSTEM) (COMMON-LISP:QUOTE %USE-RUN-PROGRAM)) COMMAND :INPUT (DEFAULT INPUT INPUTP OUTPUT) :ERROR-OUTPUT (DEFAULT ERROR-OUTPUT ERROR-OUTPUT-P OUTPUT) :IF-INPUT-DOES-NOT-EXIST IF-INPUT-DOES-NOT-EXIST :IF-OUTPUT-EXISTS IF-OUTPUT-EXISTS :IF-ERROR-OUTPUT-EXISTS IF-ERROR-OUTPUT-EXISTS :ELEMENT-TYPE ELEMENT-TYPE :EXTERNAL-FORMAT EXTERNAL-FORMAT KEYS))))
     [java] ; (DEFINE-PACKAGE :UIOP/LISP-BUILD (:NICKNAMES :ASDF/LISP-BUILD) (:RECYCLE :UIOP/LISP-BUILD :ASDF/LISP-BUILD :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/OS :UIOP/PATHNAME :UIOP/FILESYSTEM :UIOP/STREAM :UIOP/IMAGE) (:EXPORT #:*COMPILE-FILE-WARNINGS-BEHAVIOUR* #:*COMPILE-FILE-FAILURE-BEHAVIOUR* #:*OUTPUT-TRANSLATION-FUNCTION* #:*OPTIMIZATION-SETTINGS* #:*PREVIOUS-OPTIMIZATION-SETTINGS* #:*BASE-BUILD-DIRECTORY* #:COMPILE-CONDITION #:COMPILE-FILE-ERROR #:COMPILE-WARNED-ERROR #:COMPILE-FAILED-ERROR #:COMPILE-WARNED-WARNING #:COMPILE-FAILED-WARNING #:CHECK-LISP-COMPILE-RESULTS #:CHECK-LISP-COMPILE-WARNINGS #:*UNINTERESTING-CONDITIONS* #:*USUAL-UNINTERESTING-CONDITIONS* #:*UNINTERESTING-COMPILER-CONDITIONS* #:*UNINTERESTING-LOADER-CONDITIONS* #:GET-OPTIMIZATION-SETTINGS #:PROCLAIM-OPTIMIZATION-SETTINGS #:WITH-OPTIMIZATION-SETTINGS #:CALL-WITH-MUFFLED-COMPILER-CONDITIONS #:WITH-MUFFLED-COMPILER-CONDITIONS #:CALL-WITH-MUFFLED-LOADER-CONDITIONS #:WITH-MUFFLED-LOADER-CONDITIONS #:REIFY-SIMPLE-SEXP #:UNREIFY-SIMPLE-SEXP #:REIFY-DEFERRED-WARNINGS #:UNREIFY-DEFERRED-WARNINGS #:RESET-DEFERRED-WARNINGS #:SAVE-DEFERRED-WARNINGS #:CHECK-DEFERRED-WARNINGS #:WITH-SAVED-DEFERRED-WARNINGS #:WARNINGS-FILE-P #:WARNINGS-FILE-TYPE #:*WARNINGS-FILE-TYPE* #:ENABLE-DEFERRED-WARNINGS-CHECK #:DISABLE-DEFERRED-WARNINGS-CHECK #:CURRENT-LISP-FILE-PATHNAME #:LOAD-PATHNAME #:LISPIZE-PATHNAME #:COMPILE-FILE-TYPE #:CALL-AROUND-HOOK #:COMPILE-FILE* #:COMPILE-FILE-PATHNAME* #:*COMPILE-CHECK* #:LOAD* #:LOAD-FROM-STRING #:COMBINE-FASLS) (:INTERN #:DEFAULTS #:FAILURE-P #:WARNINGS-P #:S #:Y #:BODY))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/LISP-BUILD)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *COMPILE-FILE-WARNINGS-BEHAVIOUR* (COMMON-LISP:OR :WARN) "How should ASDF react if it encounters a warning when compiling a file?
     [java] Valid values are :error, :warn, and :ignore.") (COMMON-LISP:DEFVAR *COMPILE-FILE-FAILURE-BEHAVIOUR* (COMMON-LISP:OR :WARN) "How should ASDF react if it encounters a failure (per the ANSI spec of COMPILE-FILE)
     [java] when compiling a file, which includes any non-style-warning warning.
     [java] Valid values are :error, :warn, and :ignore.
     [java] Note that ASDF ALWAYS raises an error if it fails to create an output file when compiling.") (COMMON-LISP:DEFVAR *BASE-BUILD-DIRECTORY* COMMON-LISP:NIL "When set to a non-null value, it should be an absolute directory pathname,
     [java] which will serve as the *DEFAULT-PATHNAME-DEFAULTS* around a COMPILE-FILE,
     [java] what more while the input-file is shortened if possible to ENOUGH-PATHNAME relative to it.
     [java] This can help you produce more deterministic output for FASLs."))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *OPTIMIZATION-SETTINGS* COMMON-LISP:NIL "Optimization settings to be used by PROCLAIM-OPTIMIZATION-SETTINGS") (COMMON-LISP:DEFVAR *PREVIOUS-OPTIMIZATION-SETTINGS* COMMON-LISP:NIL "Optimization settings saved by PROCLAIM-OPTIMIZATION-SETTINGS") (COMMON-LISP:DEFPARAMETER +OPTIMIZATION-VARIABLES+ (COMMON-LISP:OR (COMMON-LISP:QUOTE (SYSTEM:*SPEED* SYSTEM:*SPACE* SYSTEM:*SAFETY* SYSTEM:*DEBUG*)))) (COMMON-LISP:DEFUN GET-OPTIMIZATION-SETTINGS COMMON-LISP:NIL "Get current compiler optimization settings, ready to PROCLAIM again" (COMMON-LISP:LET ((SETTINGS (COMMON-LISP:QUOTE (COMMON-LISP:SPEED COMMON-LISP:SPACE COMMON-LISP:SAFETY COMMON-LISP:DEBUG COMMON-LISP:COMPILATION-SPEED)))) (COMMON-LISP:LOOP :FOR X :IN SETTINGS :FOR V :IN +OPTIMIZATION-VARIABLES+ :FOR Y COMMON-LISP:= (COMMON-LISP:OR (COMMON-LISP:SYMBOL-VALUE V)) :WHEN Y :COLLECT (COMMON-LISP:LIST X Y)))) (COMMON-LISP:DEFUN PROCLAIM-OPTIMIZATION-SETTINGS COMMON-LISP:NIL "Proclaim the optimization settings in *OPTIMIZATION-SETTINGS*" (COMMON-LISP:PROCLAIM (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:OPTIMIZE) *OPTIMIZATION-SETTINGS*)) (COMMON-LISP:LET ((SETTINGS (GET-OPTIMIZATION-SETTINGS))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL *PREVIOUS-OPTIMIZATION-SETTINGS* SETTINGS) (COMMON-LISP:SETF *PREVIOUS-OPTIMIZATION-SETTINGS* SETTINGS)))) (COMMON-LISP:DEFMACRO WITH-OPTIMIZATION-SETTINGS ((COMMON-LISP:&OPTIONAL (SETTINGS *OPTIMIZATION-SETTINGS*)) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LET) (COMMON-LISP:LOOP :FOR V :IN +OPTIMIZATION-VARIABLES+ :COLLECT (SYSTEM::BACKQ-LIST V V)) (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN SETTINGS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:PROCLAIM) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE SYSTEM::BACKQ-CONS) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE COMMON-LISP:OPTIMIZE)) SETTINGS)))) BODY))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *USUAL-UNINTERESTING-CONDITIONS* (COMMON-LISP:APPEND (COMMON-LISP:QUOTE ("No generic function ~S present when encountering macroexpansion of defmethod. Assuming it will be an instance of standard-generic-function."))) "A suggested value to which to set or bind *uninteresting-conditions*.") (COMMON-LISP:DEFVAR *UNINTERESTING-CONDITIONS* (COMMON-LISP:QUOTE COMMON-LISP:NIL) "Conditions that may be skipped while compiling or loading Lisp code.") (COMMON-LISP:DEFVAR *UNINTERESTING-COMPILER-CONDITIONS* (COMMON-LISP:QUOTE COMMON-LISP:NIL) "Additional conditions that may be skipped while compiling Lisp code.") (COMMON-LISP:DEFVAR *UNINTERESTING-LOADER-CONDITIONS* (COMMON-LISP:APPEND (COMMON-LISP:QUOTE ("Overwriting already existing readtable ~S." #(#:FINALIZERS-OFF-WARNING :ASDF-FINALIZERS)))) "Additional conditions that may be skipped while loading Lisp code."))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CALL-WITH-MUFFLED-COMPILER-CONDITIONS (THUNK) "Call given THUNK in a context where uninteresting conditions and compiler conditions are muffled" (CALL-WITH-MUFFLED-CONDITIONS THUNK (COMMON-LISP:APPEND *UNINTERESTING-CONDITIONS* *UNINTERESTING-COMPILER-CONDITIONS*))) (COMMON-LISP:DEFMACRO WITH-MUFFLED-COMPILER-CONDITIONS ((COMMON-LISP:&OPTIONAL) COMMON-LISP:&BODY BODY) "Trivial syntax for CALL-WITH-MUFFLED-COMPILER-CONDITIONS" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-MUFFLED-COMPILER-CONDITIONS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))) (COMMON-LISP:DEFUN CALL-WITH-MUFFLED-LOADER-CONDITIONS (THUNK) "Call given THUNK in a context where uninteresting conditions and loader conditions are muffled" (CALL-WITH-MUFFLED-CONDITIONS THUNK (COMMON-LISP:APPEND *UNINTERESTING-CONDITIONS* *UNINTERESTING-LOADER-CONDITIONS*))) (COMMON-LISP:DEFMACRO WITH-MUFFLED-LOADER-CONDITIONS ((COMMON-LISP:&OPTIONAL) COMMON-LISP:&BODY BODY) "Trivial syntax for CALL-WITH-MUFFLED-LOADER-CONDITIONS" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-MUFFLED-LOADER-CONDITIONS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION COMPILE-CONDITION (COMMON-LISP:CONDITION) ((CONTEXT-FORMAT :INITFORM COMMON-LISP:NIL :READER COMPILE-CONDITION-CONTEXT-FORMAT :INITARG :CONTEXT-FORMAT) (CONTEXT-ARGUMENTS :INITFORM COMMON-LISP:NIL :READER COMPILE-CONDITION-CONTEXT-ARGUMENTS :INITARG :CONTEXT-ARGUMENTS) (DESCRIPTION :INITFORM COMMON-LISP:NIL :READER COMPILE-CONDITION-DESCRIPTION :INITARG :DESCRIPTION)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<~A~@[ while ~?~]~@:>") (COMMON-LISP:OR (COMPILE-CONDITION-DESCRIPTION C) (COMMON-LISP:TYPE-OF C)) (COMPILE-CONDITION-CONTEXT-FORMAT C) (COMPILE-CONDITION-CONTEXT-ARGUMENTS C))))) (COMMON-LISP:DEFINE-CONDITION COMPILE-FILE-ERROR (COMPILE-CONDITION COMMON-LISP:ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-WARNED-WARNING (COMPILE-CONDITION COMMON-LISP:WARNING) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-WARNED-ERROR (COMPILE-CONDITION COMMON-LISP:ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-FAILED-WARNING (COMPILE-CONDITION COMMON-LISP:WARNING) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-FAILED-ERROR (COMPILE-CONDITION COMMON-LISP:ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFUN CHECK-LISP-COMPILE-WARNINGS (WARNINGS-P FAILURE-P COMMON-LISP:&OPTIONAL CONTEXT-FORMAT CONTEXT-ARGUMENTS) "Given the warnings or failures as resulted from COMPILE-FILE or checking deferred warnings,
     [java] raise an error or warning as appropriate" (COMMON-LISP:WHEN FAILURE-P (COMMON-LISP:CASE *COMPILE-FILE-FAILURE-BEHAVIOUR* (:WARN (COMMON-LISP:WARN (COMMON-LISP:QUOTE COMPILE-FAILED-WARNING) :DESCRIPTION "Lisp compilation failed" :CONTEXT-FORMAT CONTEXT-FORMAT :CONTEXT-ARGUMENTS CONTEXT-ARGUMENTS)) (:ERROR (COMMON-LISP:ERROR (COMMON-LISP:QUOTE COMPILE-FAILED-ERROR) :DESCRIPTION "Lisp compilation failed" :CONTEXT-FORMAT CONTEXT-FORMAT :CONTEXT-ARGUMENTS CONTEXT-ARGUMENTS)) (:IGNORE COMMON-LISP:NIL))) (COMMON-LISP:WHEN WARNINGS-P (COMMON-LISP:CASE *COMPILE-FILE-WARNINGS-BEHAVIOUR* (:WARN (COMMON-LISP:WARN (COMMON-LISP:QUOTE COMPILE-WARNED-WARNING) :DESCRIPTION "Lisp compilation had style-warnings" :CONTEXT-FORMAT CONTEXT-FORMAT :CONTEXT-ARGUMENTS CONTEXT-ARGUMENTS)) (:ERROR (COMMON-LISP:ERROR (COMMON-LISP:QUOTE COMPILE-WARNED-ERROR) :DESCRIPTION "Lisp compilation had style-warnings" :CONTEXT-FORMAT CONTEXT-FORMAT :CONTEXT-ARGUMENTS CONTEXT-ARGUMENTS)) (:IGNORE COMMON-LISP:NIL)))) (COMMON-LISP:DEFUN CHECK-LISP-COMPILE-RESULTS (OUTPUT WARNINGS-P FAILURE-P COMMON-LISP:&OPTIONAL CONTEXT-FORMAT CONTEXT-ARGUMENTS) "Given the results of COMPILE-FILE, raise an error or warning as appropriate" (COMMON-LISP:UNLESS OUTPUT (COMMON-LISP:ERROR (COMMON-LISP:QUOTE COMPILE-FILE-ERROR) :CONTEXT-FORMAT CONTEXT-FORMAT :CONTEXT-ARGUMENTS CONTEXT-ARGUMENTS)) (CHECK-LISP-COMPILE-WARNINGS WARNINGS-P FAILURE-P CONTEXT-FORMAT CONTEXT-ARGUMENTS)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN REIFY-SIMPLE-SEXP (SEXP) "Given a simple SEXP, return a representation of it as a portable SEXP.
     [java] Simple means made of symbols, numbers, characters, simple-strings, pathnames, cons cells." (COMMON-LISP:ETYPECASE SEXP (COMMON-LISP:SYMBOL (REIFY-SYMBOL SEXP)) ((COMMON-LISP:OR COMMON-LISP:NUMBER COMMON-LISP:CHARACTER COMMON-LISP:SIMPLE-STRING COMMON-LISP:PATHNAME) SEXP) (COMMON-LISP:CONS (COMMON-LISP:CONS (REIFY-SIMPLE-SEXP (COMMON-LISP:CAR SEXP)) (REIFY-SIMPLE-SEXP (COMMON-LISP:CDR SEXP)))) (COMMON-LISP:SIMPLE-VECTOR (COMMON-LISP:VECTOR (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE REIFY-SIMPLE-SEXP) (COMMON-LISP:COERCE SEXP (COMMON-LISP:QUOTE COMMON-LISP:LIST))))))) (COMMON-LISP:DEFUN UNREIFY-SIMPLE-SEXP (SEXP) "Given the portable output of REIFY-SIMPLE-SEXP, return the simple SEXP it represents" (COMMON-LISP:ETYPECASE SEXP ((COMMON-LISP:OR COMMON-LISP:SYMBOL COMMON-LISP:NUMBER COMMON-LISP:CHARACTER COMMON-LISP:SIMPLE-STRING COMMON-LISP:PATHNAME) SEXP) (COMMON-LISP:CONS (COMMON-LISP:CONS (UNREIFY-SIMPLE-SEXP (COMMON-LISP:CAR SEXP)) (UNREIFY-SIMPLE-SEXP (COMMON-LISP:CDR SEXP)))) ((COMMON-LISP:SIMPLE-VECTOR 2) (UNREIFY-SYMBOL SEXP)) ((COMMON-LISP:SIMPLE-VECTOR 1) (COMMON-LISP:COERCE (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE UNREIFY-SIMPLE-SEXP) (COMMON-LISP:AREF SEXP 0)) (COMMON-LISP:QUOTE COMMON-LISP:VECTOR))))) (COMMON-LISP:DEFUN REIFY-DEFERRED-WARNINGS COMMON-LISP:NIL "return a portable S-expression, portably readable and writeable in any Common Lisp implementation
     [java] using READ within a WITH-SAFE-IO-SYNTAX, that represents the warnings currently deferred by
     [java] WITH-COMPILATION-UNIT. One of three functions required for deferred-warnings support in ASDF.") (COMMON-LISP:DEFUN UNREIFY-DEFERRED-WARNINGS (REIFIED-DEFERRED-WARNINGS) "given a S-expression created by REIFY-DEFERRED-WARNINGS, reinstantiate the corresponding
     [java] deferred warnings as to be handled at the end of the current WITH-COMPILATION-UNIT.
     [java] Handle any warning that has been resolved already,
     [java] such as an undefined function that has been defined since.
     [java] One of three functions required for deferred-warnings support in ASDF." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE REIFIED-DEFERRED-WARNINGS))) (COMMON-LISP:DEFUN RESET-DEFERRED-WARNINGS COMMON-LISP:NIL "Reset the set of deferred warnings to be handled at the end of the current WITH-COMPILATION-UNIT.
     [java] One of three functions required for deferred-warnings support in ASDF.") (COMMON-LISP:DEFUN SAVE-DEFERRED-WARNINGS (WARNINGS-FILE) "Save forward reference conditions so they may be issued at a latter time,
     [java] possibly in a different process." (COMMON-LISP:WITH-OPEN-FILE (S WARNINGS-FILE :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE :ELEMENT-TYPE *DEFAULT-STREAM-ELEMENT-TYPE* :EXTERNAL-FORMAT *UTF-8-EXTERNAL-FORMAT*) (WITH-SAFE-IO-SYNTAX COMMON-LISP:NIL (COMMON-LISP:WRITE (REIFY-DEFERRED-WARNINGS) :STREAM S :PRETTY COMMON-LISP:T :READABLY COMMON-LISP:T) (COMMON-LISP:TERPRI S)))) (COMMON-LISP:DEFUN WARNINGS-FILE-TYPE (COMMON-LISP:&OPTIONAL IMPLEMENTATION-TYPE) "The pathname type for warnings files on given IMPLEMENTATION-TYPE,
     [java] where NIL designates the current one" (COMMON-LISP:CASE (COMMON-LISP:OR IMPLEMENTATION-TYPE *IMPLEMENTATION-TYPE*) ((:ACL :ALLEGRO) "allegro-warnings") ((:CMU :CMUCL) "cmucl-warnings") ((:SBCL) "sbcl-warnings") ((:CLOZURE :CCL) "ccl-warnings") ((:SCL) "scl-warnings"))) (COMMON-LISP:DEFVAR *WARNINGS-FILE-TYPE* COMMON-LISP:NIL "Pathname type for warnings files, or NIL if disabled") (COMMON-LISP:DEFUN ENABLE-DEFERRED-WARNINGS-CHECK COMMON-LISP:NIL "Enable the saving of deferred warnings" (COMMON-LISP:SETF *WARNINGS-FILE-TYPE* (WARNINGS-FILE-TYPE))) (COMMON-LISP:DEFUN DISABLE-DEFERRED-WARNINGS-CHECK COMMON-LISP:NIL "Disable the saving of deferred warnings" (COMMON-LISP:SETF *WARNINGS-FILE-TYPE* COMMON-LISP:NIL)) (COMMON-LISP:DEFUN WARNINGS-FILE-P (FILE COMMON-LISP:&OPTIONAL IMPLEMENTATION-TYPE) "Is FILE a saved warnings file for the given IMPLEMENTATION-TYPE?
     [java] If that given type is NIL, use the currently configured *WARNINGS-FILE-TYPE* instead." (IF-LET (COMMON-LISP:TYPE (COMMON-LISP:IF IMPLEMENTATION-TYPE (WARNINGS-FILE-TYPE IMPLEMENTATION-TYPE) *WARNINGS-FILE-TYPE*)) (COMMON-LISP:EQUAL (COMMON-LISP:PATHNAME-TYPE FILE) COMMON-LISP:TYPE))) (COMMON-LISP:DEFUN CHECK-DEFERRED-WARNINGS (FILES COMMON-LISP:&OPTIONAL CONTEXT-FORMAT CONTEXT-ARGUMENTS) "Given a list of FILES containing deferred warnings saved by CALL-WITH-SAVED-DEFERRED-WARNINGS,
     [java] re-intern and raise any warnings that are still meaningful." (COMMON-LISP:LET ((FILE-ERRORS COMMON-LISP:NIL) (FAILURE-P COMMON-LISP:NIL) (WARNINGS-P COMMON-LISP:NIL)) (COMMON-LISP:HANDLER-BIND ((COMMON-LISP:WARNING (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:SETF WARNINGS-P COMMON-LISP:T) (COMMON-LISP:UNLESS (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE COMMON-LISP:STYLE-WARNING)) (COMMON-LISP:SETF FAILURE-P COMMON-LISP:T)))))) (COMMON-LISP:WITH-COMPILATION-UNIT (:OVERRIDE COMMON-LISP:T) (RESET-DEFERRED-WARNINGS) (COMMON-LISP:DOLIST (FILE FILES) (UNREIFY-DEFERRED-WARNINGS (COMMON-LISP:HANDLER-CASE (SAFE-READ-FILE-FORM FILE) (COMMON-LISP:ERROR (C) (COMMON-LISP:PUSH C FILE-ERRORS) COMMON-LISP:NIL)))))) (COMMON-LISP:DOLIST (COMMON-LISP:ERROR FILE-ERRORS) (COMMON-LISP:ERROR COMMON-LISP:ERROR)) (CHECK-LISP-COMPILE-WARNINGS (COMMON-LISP:OR FAILURE-P WARNINGS-P) FAILURE-P CONTEXT-FORMAT CONTEXT-ARGUMENTS))) (COMMON-LISP:DEFUN CALL-WITH-SAVED-DEFERRED-WARNINGS (THUNK WARNINGS-FILE COMMON-LISP:&KEY SOURCE-NAMESTRING) "If WARNINGS-FILE is not nil, record the deferred-warnings around a call to THUNK
     [java] and save those warnings to the given file for latter use,
     [java] possibly in a different process. Otherwise just call THUNK." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE SOURCE-NAMESTRING)) (COMMON-LISP:IF WARNINGS-FILE (COMMON-LISP:WITH-COMPILATION-UNIT (:OVERRIDE COMMON-LISP:T) (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:LET COMMON-LISP:NIL (COMMON-LISP:MULTIPLE-VALUE-PROG1 (COMMON-LISP:FUNCALL THUNK) (SAVE-DEFERRED-WARNINGS WARNINGS-FILE))) (RESET-DEFERRED-WARNINGS))) (COMMON-LISP:FUNCALL THUNK))) (COMMON-LISP:DEFMACRO WITH-SAVED-DEFERRED-WARNINGS ((WARNINGS-FILE COMMON-LISP:&KEY SOURCE-NAMESTRING) COMMON-LISP:&BODY BODY) "Trivial syntax for CALL-WITH-SAVED-DEFERRED-WARNINGS" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-SAVED-DEFERRED-WARNINGS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)) WARNINGS-FILE (COMMON-LISP:QUOTE :SOURCE-NAMESTRING) SOURCE-NAMESTRING)))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN CURRENT-LISP-FILE-PATHNAME COMMON-LISP:NIL "Portably return the PATHNAME of the current Lisp source file being compiled or loaded" (COMMON-LISP:OR COMMON-LISP:*COMPILE-FILE-PATHNAME* COMMON-LISP:*LOAD-PATHNAME*)) (COMMON-LISP:DEFUN LOAD-PATHNAME COMMON-LISP:NIL "Portably return the LOAD-PATHNAME of the current source file or fasl" COMMON-LISP:*LOAD-PATHNAME*) (COMMON-LISP:DEFUN LISPIZE-PATHNAME (INPUT-FILE) "From a INPUT-FILE pathname, return a corresponding .lisp source pathname" (COMMON-LISP:MAKE-PATHNAME :TYPE "lisp" :DEFAULTS INPUT-FILE)) (COMMON-LISP:DEFUN COMPILE-FILE-TYPE (COMMON-LISP:&REST KEYS) "pathname TYPE for lisp FASt Loading files" (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE KEYS)) (COMMON-LISP:LOAD-TIME-VALUE (COMMON-LISP:PATHNAME-TYPE (COMMON-LISP:COMPILE-FILE-PATHNAME "foo.lisp")))) (COMMON-LISP:DEFUN CALL-AROUND-HOOK (HOOK COMMON-LISP:FUNCTION) "Call a HOOK around the execution of FUNCTION" (CALL-FUNCTION (COMMON-LISP:OR HOOK (COMMON-LISP:QUOTE COMMON-LISP:FUNCALL)) COMMON-LISP:FUNCTION)) (COMMON-LISP:DEFUN COMPILE-FILE-PATHNAME* (INPUT-FILE COMMON-LISP:&REST KEYS COMMON-LISP:&KEY OUTPUT-FILE COMMON-LISP:&ALLOW-OTHER-KEYS) "Variant of COMPILE-FILE-PATHNAME that works well with COMPILE-FILE*" (COMMON-LISP:LET* ((KEYS (REMOVE-PLIST-KEYS (COMMON-LISP:UNLESS OUTPUT-FILE (COMMON-LISP:QUOTE (:OUTPUT-FILE))) KEYS))) (COMMON-LISP:IF (ABSOLUTE-PATHNAME-P OUTPUT-FILE) (COMMON-LISP:LET* ((COMMON-LISP:TYPE (COMMON-LISP:PATHNAME-TYPE (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMPILE-FILE-TYPE) KEYS))) (DEFAULTS (COMMON-LISP:MAKE-PATHNAME :TYPE COMMON-LISP:TYPE :DEFAULTS (MERGE-PATHNAMES* INPUT-FILE)))) (MERGE-PATHNAMES* OUTPUT-FILE DEFAULTS)) (COMMON-LISP:FUNCALL *OUTPUT-TRANSLATION-FUNCTION* (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:COMPILE-FILE-PATHNAME) INPUT-FILE KEYS))))) (COMMON-LISP:DEFVAR *COMPILE-CHECK* COMMON-LISP:NIL "A hook for user-defined compile-time invariants") (DEFUN* (COMPILE-FILE*) (INPUT-FILE COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (COMPILE-CHECK *COMPILE-CHECK*) OUTPUT-FILE WARNINGS-FILE COMMON-LISP:&ALLOW-OTHER-KEYS) "This function provides a portable wrapper around COMPILE-FILE.
     [java] It ensures that the OUTPUT-FILE value is only returned and
     [java] the file only actually created if the compilation was successful,
     [java] even though your implementation may not do that, and including
     [java] an optional call to an user-provided consistency check function COMPILE-CHECK;
     [java] it will call this function if not NIL at the end of the compilation
     [java] with the arguments sent to COMPILE-FILE*, except with :OUTPUT-FILE TMP-FILE
     [java] where TMP-FILE is the name of a temporary output-file.
     [java] It also checks two flags (with legacy british spelling from ASDF1),
     [java] *COMPILE-FILE-FAILURE-BEHAVIOUR* and *COMPILE-FILE-WARNINGS-BEHAVIOUR*
     [java] with appropriate implementation-dependent defaults,
     [java] and if a failure (respectively warnings) are reported by COMPILE-FILE
     [java] with consider it an error unless the respective behaviour flag
     [java] is one of :SUCCESS :WARN :IGNORE.
     [java] If WARNINGS-FILE is defined, deferred warnings are saved to that file.
     [java] On ECL or MKCL, it creates both the linkable object and loadable fasl files.
     [java] On implementations that erroneously do not recognize standard keyword arguments,
     [java] it will filter them appropriately." (COMMON-LISP:LET* ((KEYWORDS (REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:OUTPUT-FILE :COMPILE-CHECK :WARNINGS-FILE)) KEYS)) (OUTPUT-FILE (COMMON-LISP:OR OUTPUT-FILE (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMPILE-FILE-PATHNAME*) INPUT-FILE :OUTPUT-FILE OUTPUT-FILE KEYWORDS))) (TMP-FILE (TMPIZE-PATHNAME OUTPUT-FILE))) (COMMON-LISP:MULTIPLE-VALUE-BIND (OUTPUT-TRUENAME WARNINGS-P FAILURE-P) (WITH-ENOUGH-PATHNAME (INPUT-FILE :DEFAULTS *BASE-BUILD-DIRECTORY*) (WITH-SAVED-DEFERRED-WARNINGS (WARNINGS-FILE :SOURCE-NAMESTRING (COMMON-LISP:NAMESTRING INPUT-FILE)) (WITH-MUFFLED-COMPILER-CONDITIONS COMMON-LISP:NIL (COMMON-LISP:OR (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:COMPILE-FILE) INPUT-FILE :OUTPUT-FILE TMP-FILE KEYWORDS))))) (COMMON-LISP:COND ((COMMON-LISP:AND OUTPUT-TRUENAME (COMMON-LISP:FLET ((CHECK-FLAG (FLAG BEHAVIOUR) (COMMON-LISP:OR (COMMON-LISP:NOT FLAG) (COMMON-LISP:MEMBER BEHAVIOUR (COMMON-LISP:QUOTE (:SUCCESS :WARN :IGNORE)))))) (COMMON-LISP:AND (CHECK-FLAG FAILURE-P *COMPILE-FILE-FAILURE-BEHAVIOUR*) (CHECK-FLAG WARNINGS-P *COMPILE-FILE-WARNINGS-BEHAVIOUR*))) (COMMON-LISP:PROGN (COMMON-LISP:OR (COMMON-LISP:NOT COMPILE-CHECK) (COMMON-LISP:APPLY COMPILE-CHECK INPUT-FILE :OUTPUT-FILE OUTPUT-FILE KEYWORDS)))) (DELETE-FILE-IF-EXISTS OUTPUT-FILE) (COMMON-LISP:WHEN OUTPUT-TRUENAME (RENAME-FILE-OVERWRITING-TARGET OUTPUT-TRUENAME OUTPUT-FILE) (COMMON-LISP:SETF OUTPUT-TRUENAME (COMMON-LISP:TRUENAME OUTPUT-FILE)))) (COMMON-LISP:T (DELETE-FILE-IF-EXISTS OUTPUT-TRUENAME) (COMMON-LISP:SETF OUTPUT-TRUENAME COMMON-LISP:NIL))) (COMMON-LISP:VALUES OUTPUT-TRUENAME WARNINGS-P FAILURE-P)))) (COMMON-LISP:DEFUN LOAD* (X COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) "Portable wrapper around LOAD that properly handles loading from a stream." (WITH-MUFFLED-LOADER-CONDITIONS COMMON-LISP:NIL (COMMON-LISP:ETYPECASE X ((COMMON-LISP:OR COMMON-LISP:PATHNAME COMMON-LISP:STRING COMMON-LISP:STREAM) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:LOAD) X KEYS))))) (COMMON-LISP:DEFUN LOAD-FROM-STRING (COMMON-LISP:STRING) "Portably read and evaluate forms from a STRING." (COMMON-LISP:WITH-INPUT-FROM-STRING (S COMMON-LISP:STRING) (LOAD* S))))
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COMBINE-FASLS (INPUTS OUTPUT) "Combine a list of FASLs INPUTS into a single FASL OUTPUT" (COMMON-LISP:FUNCALL (COMMON-LISP:QUOTE SYSTEM:CONCATENATE-FASLS) INPUTS OUTPUT)))
     [java] ; (DEFINE-PACKAGE :UIOP/CONFIGURATION (:NICKNAMES :ASDF/CONFIGURATION) (:RECYCLE :UIOP/CONFIGURATION :ASDF/CONFIGURATION :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/UTILITY :UIOP/OS :UIOP/PATHNAME :UIOP/FILESYSTEM :UIOP/STREAM :UIOP/IMAGE :UIOP/LISP-BUILD) (:EXPORT #:USER-CONFIGURATION-DIRECTORIES #:SYSTEM-CONFIGURATION-DIRECTORIES #:IN-FIRST-DIRECTORY #:IN-USER-CONFIGURATION-DIRECTORY #:IN-SYSTEM-CONFIGURATION-DIRECTORY #:GET-FOLDER-PATH #:XDG-DATA-HOME #:XDG-CONFIG-HOME #:XDG-DATA-DIRS #:XDG-CONFIG-DIRS #:XDG-CACHE-HOME #:XDG-RUNTIME-DIR #:SYSTEM-CONFIG-PATHNAMES #:FILTER-PATHNAME-SET #:XDG-DATA-PATHNAMES #:XDG-CONFIG-PATHNAMES #:FIND-PREFERRED-FILE #:XDG-DATA-PATHNAME #:XDG-CONFIG-PATHNAME #:VALIDATE-CONFIGURATION-FORM #:VALIDATE-CONFIGURATION-FILE #:VALIDATE-CONFIGURATION-DIRECTORY #:CONFIGURATION-INHERITANCE-DIRECTIVE-P #:REPORT-INVALID-FORM #:INVALID-CONFIGURATION #:*IGNORED-CONFIGURATION-FORM* #:*USER-CACHE* #:*CLEAR-CONFIGURATION-HOOK* #:CLEAR-CONFIGURATION #:REGISTER-CLEAR-CONFIGURATION-HOOK #:RESOLVE-LOCATION #:LOCATION-DESIGNATOR-P #:LOCATION-FUNCTION-P #:*HERE-DIRECTORY* #:RESOLVE-RELATIVE-LOCATION #:RESOLVE-ABSOLUTE-LOCATION #:UPGRADE-CONFIGURATION))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/CONFIGURATION)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION INVALID-CONFIGURATION COMMON-LISP:NIL ((FORM :READER CONDITION-FORM :INITARG :FORM) (LOCATION :READER CONDITION-LOCATION :INITARG :LOCATION) (COMMON-LISP:FORMAT :READER CONDITION-FORMAT :INITARG :FORMAT) (ARGUMENTS :READER CONDITION-ARGUMENTS :INITARG :ARGUMENTS :INITFORM COMMON-LISP:NIL)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<~? (will be skipped)~@:>") (CONDITION-FORMAT C) (COMMON-LISP:LIST* (CONDITION-FORM C) (CONDITION-LOCATION C) (CONDITION-ARGUMENTS C)))))) (COMMON-LISP:DEFUN CONFIGURATION-INHERITANCE-DIRECTIVE-P (X) "Is X a configuration inheritance directive?" (COMMON-LISP:LET ((KW (COMMON-LISP:QUOTE (:INHERIT-CONFIGURATION :IGNORE-INHERITED-CONFIGURATION)))) (COMMON-LISP:OR (COMMON-LISP:MEMBER X KW) (COMMON-LISP:AND (LENGTH=N-P X 1) (COMMON-LISP:MEMBER (COMMON-LISP:CAR X) KW))))) (COMMON-LISP:DEFUN REPORT-INVALID-FORM (REPORTER COMMON-LISP:&REST ARGS) "Report an invalid form according to REPORTER and various ARGS" (COMMON-LISP:ETYPECASE REPORTER (COMMON-LISP:NULL (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:ERROR) (COMMON-LISP:QUOTE INVALID-CONFIGURATION) ARGS)) (COMMON-LISP:FUNCTION (COMMON-LISP:APPLY REPORTER ARGS)) ((COMMON-LISP:OR COMMON-LISP:SYMBOL COMMON-LISP:STRING) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:ERROR) REPORTER ARGS)) (COMMON-LISP:CONS (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:APPEND REPORTER ARGS))))) (COMMON-LISP:DEFVAR *IGNORED-CONFIGURATION-FORM* COMMON-LISP:NIL "Have configuration forms been ignored while parsing the configuration?") (COMMON-LISP:DEFUN VALIDATE-CONFIGURATION-FORM (FORM TAG DIRECTIVE-VALIDATOR COMMON-LISP:&KEY LOCATION INVALID-FORM-REPORTER) "Validate a configuration FORM. By default it will raise an error if the
     [java] FORM is not valid.  Otherwise it will return the validated form.
     [java]      Arguments control the behavior:
     [java]      The configuration FORM should be of the form (TAG . <rest>)
     [java]      Each element of <rest> will be checked by first seeing if it's a configuration inheritance
     [java] directive (see CONFIGURATION-INHERITANCE-DIRECTIVE-P) then invoking DIRECTIVE-VALIDATOR
     [java] on it.
     [java]      In the event of an invalid form, INVALID-FORM-REPORTER will be used to control
     [java] reporting (see REPORT-INVALID-FORM) with LOCATION providing information about where
     [java] the configuration form appeared." (COMMON-LISP:UNLESS (COMMON-LISP:AND (COMMON-LISP:CONSP FORM) (COMMON-LISP:EQ (COMMON-LISP:CAR FORM) TAG)) (COMMON-LISP:SETF *IGNORED-CONFIGURATION-FORM* COMMON-LISP:T) (REPORT-INVALID-FORM INVALID-FORM-REPORTER :FORM FORM :LOCATION LOCATION) (COMMON-LISP:RETURN-FROM VALIDATE-CONFIGURATION-FORM COMMON-LISP:NIL)) (COMMON-LISP:LOOP :WITH INHERIT COMMON-LISP:= 0 :WITH IGNORE-INVALID-P COMMON-LISP:= COMMON-LISP:NIL :WITH X COMMON-LISP:= (COMMON-LISP:LIST TAG) :FOR DIRECTIVE :IN (COMMON-LISP:CDR FORM) :WHEN (COMMON-LISP:COND ((CONFIGURATION-INHERITANCE-DIRECTIVE-P DIRECTIVE) (COMMON-LISP:INCF INHERIT) COMMON-LISP:T) ((COMMON-LISP:EQ DIRECTIVE :IGNORE-INVALID-ENTRIES) (COMMON-LISP:SETF IGNORE-INVALID-P COMMON-LISP:T) COMMON-LISP:T) ((COMMON-LISP:FUNCALL DIRECTIVE-VALIDATOR DIRECTIVE) COMMON-LISP:T) (IGNORE-INVALID-P COMMON-LISP:NIL) (COMMON-LISP:T (COMMON-LISP:SETF *IGNORED-CONFIGURATION-FORM* COMMON-LISP:T) (REPORT-INVALID-FORM INVALID-FORM-REPORTER :FORM DIRECTIVE :LOCATION LOCATION) COMMON-LISP:NIL)) :DO (COMMON-LISP:PUSH DIRECTIVE X) :FINALLY (COMMON-LISP:UNLESS (COMMON-LISP:= INHERIT 1) (REPORT-INVALID-FORM INVALID-FORM-REPORTER :FORM FORM :LOCATION LOCATION :FORMAT (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid source registry ~S~@[ in ~S~]. ~
     [java]                                                         One and only one of ~S or ~S is required.~@:>") :ARGUMENTS (COMMON-LISP:QUOTE (:INHERIT-CONFIGURATION :IGNORE-INHERITED-CONFIGURATION)))) (COMMON-LISP:RETURN (COMMON-LISP:NREVERSE X)))) (COMMON-LISP:DEFUN VALIDATE-CONFIGURATION-FILE (FILE VALIDATOR COMMON-LISP:&KEY DESCRIPTION) "Validate a configuration FILE.  The configuration file should have only one s-expression
     [java] in it, which will be checked with the VALIDATOR FORM.  DESCRIPTION argument used for error
     [java] reporting." (COMMON-LISP:LET ((FORMS (READ-FILE-FORMS FILE))) (COMMON-LISP:UNLESS (LENGTH=N-P FORMS 1) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<One and only one form allowed for ~A. Got: ~3i~_~S~@:>~%") DESCRIPTION FORMS)) (COMMON-LISP:FUNCALL VALIDATOR (COMMON-LISP:CAR FORMS) :LOCATION FILE))) (COMMON-LISP:DEFUN VALIDATE-CONFIGURATION-DIRECTORY (COMMON-LISP:DIRECTORY TAG VALIDATOR COMMON-LISP:&KEY INVALID-FORM-REPORTER) "Map the VALIDATOR across the .conf files in DIRECTORY, the TAG will
     [java] be applied to the results to yield a configuration form.  Current
     [java] values of TAG include :source-registry and :output-translations." (COMMON-LISP:LET ((FILES (COMMON-LISP:SORT (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:REMOVE-IF (COMMON-LISP:QUOTE HIDDEN-PATHNAME-P) (DIRECTORY* (COMMON-LISP:MAKE-PATHNAME :NAME *WILD* :TYPE "conf" :DEFAULTS COMMON-LISP:DIRECTORY)))) (COMMON-LISP:FUNCTION COMMON-LISP:STRING<) :KEY (COMMON-LISP:FUNCTION COMMON-LISP:NAMESTRING)))) (SYSTEM::BACKQ-CONS TAG (SYSTEM::BACKQ-APPEND (COMMON-LISP:LOOP :FOR FILE :IN FILES :APPEND (COMMON-LISP:LOOP :WITH IGNORE-INVALID-P COMMON-LISP:= COMMON-LISP:NIL :FOR FORM :IN (READ-FILE-FORMS FILE) :WHEN (COMMON-LISP:EQ FORM :IGNORE-INVALID-ENTRIES) :DO (COMMON-LISP:SETF IGNORE-INVALID-P COMMON-LISP:T) :ELSE :WHEN (COMMON-LISP:FUNCALL VALIDATOR FORM) :COLLECT FORM :ELSE :WHEN IGNORE-INVALID-P :DO (COMMON-LISP:SETF *IGNORED-CONFIGURATION-FORM* COMMON-LISP:T) :ELSE :DO (REPORT-INVALID-FORM INVALID-FORM-REPORTER :FORM FORM :LOCATION FILE))) (COMMON-LISP:QUOTE (:INHERIT-CONFIGURATION)))))) (COMMON-LISP:DEFUN RESOLVE-RELATIVE-LOCATION (X COMMON-LISP:&KEY ENSURE-DIRECTORY WILDEN) "Given a designator X for an relative location, resolve it to a pathname." (ENSURE-PATHNAME (COMMON-LISP:ETYPECASE X (COMMON-LISP:NULL COMMON-LISP:NIL) (COMMON-LISP:PATHNAME X) (COMMON-LISP:STRING (PARSE-UNIX-NAMESTRING X :ENSURE-DIRECTORY ENSURE-DIRECTORY)) (COMMON-LISP:CONS (COMMON-LISP:IF (COMMON-LISP:NULL (COMMON-LISP:CDR X)) (RESOLVE-RELATIVE-LOCATION (COMMON-LISP:CAR X) :ENSURE-DIRECTORY ENSURE-DIRECTORY :WILDEN WILDEN) (COMMON-LISP:LET* ((COMMON-LISP:CAR (RESOLVE-RELATIVE-LOCATION (COMMON-LISP:CAR X) :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:NIL))) (MERGE-PATHNAMES* (RESOLVE-RELATIVE-LOCATION (COMMON-LISP:CDR X) :ENSURE-DIRECTORY ENSURE-DIRECTORY :WILDEN WILDEN) COMMON-LISP:CAR)))) ((COMMON-LISP:EQL :*/) *WILD-DIRECTORY*) ((COMMON-LISP:EQL :**/) *WILD-INFERIORS*) ((COMMON-LISP:EQL :*.*.*) *WILD-FILE*) ((COMMON-LISP:EQL :IMPLEMENTATION) (PARSE-UNIX-NAMESTRING (IMPLEMENTATION-IDENTIFIER) :ENSURE-DIRECTORY COMMON-LISP:T)) ((COMMON-LISP:EQL :IMPLEMENTATION-TYPE) (PARSE-UNIX-NAMESTRING (COMMON-LISP:STRING-DOWNCASE (IMPLEMENTATION-TYPE)) :ENSURE-DIRECTORY COMMON-LISP:T)) ((COMMON-LISP:EQL :HOSTNAME) (PARSE-UNIX-NAMESTRING (HOSTNAME) :ENSURE-DIRECTORY COMMON-LISP:T))) :WILDEN (COMMON-LISP:AND WILDEN (COMMON-LISP:NOT (COMMON-LISP:PATHNAMEP X)) (COMMON-LISP:NOT (COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE (:*/ :**/ :*.*.*))))) :WANT-RELATIVE COMMON-LISP:T)) (COMMON-LISP:DEFVAR *HERE-DIRECTORY* COMMON-LISP:NIL "This special variable is bound to the currect directory during calls to
     [java] PROCESS-SOURCE-REGISTRY in order that we be able to interpret the :here
     [java] directive.") (COMMON-LISP:DEFVAR *USER-CACHE* COMMON-LISP:NIL "A specification as per RESOLVE-LOCATION of where the user keeps his FASL cache") (COMMON-LISP:DEFUN RESOLVE-ABSOLUTE-LOCATION (X COMMON-LISP:&KEY ENSURE-DIRECTORY WILDEN) "Given a designator X for an absolute location, resolve it to a pathname" (ENSURE-PATHNAME (COMMON-LISP:ETYPECASE X (COMMON-LISP:NULL COMMON-LISP:NIL) (COMMON-LISP:PATHNAME X) (COMMON-LISP:STRING (COMMON-LISP:LET ((P (COMMON-LISP:PARSE-NAMESTRING X))) (COMMON-LISP:IF ENSURE-DIRECTORY (ENSURE-DIRECTORY-PATHNAME P) P))) (COMMON-LISP:CONS (COMMON-LISP:RETURN-FROM RESOLVE-ABSOLUTE-LOCATION (COMMON-LISP:IF (COMMON-LISP:NULL (COMMON-LISP:CDR X)) (RESOLVE-ABSOLUTE-LOCATION (COMMON-LISP:CAR X) :ENSURE-DIRECTORY ENSURE-DIRECTORY :WILDEN WILDEN) (MERGE-PATHNAMES* (RESOLVE-RELATIVE-LOCATION (COMMON-LISP:CDR X) :ENSURE-DIRECTORY ENSURE-DIRECTORY :WILDEN WILDEN) (RESOLVE-ABSOLUTE-LOCATION (COMMON-LISP:CAR X) :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:NIL))))) ((COMMON-LISP:EQL :ROOT) (COMMON-LISP:RETURN-FROM RESOLVE-ABSOLUTE-LOCATION (COMMON-LISP:LET ((P (MAKE-PATHNAME* :DIRECTORY (COMMON-LISP:QUOTE (:RELATIVE))))) (COMMON-LISP:IF WILDEN (WILDEN P) P)))) ((COMMON-LISP:EQL :HOME) (COMMON-LISP:USER-HOMEDIR-PATHNAME)) ((COMMON-LISP:EQL :HERE) (RESOLVE-ABSOLUTE-LOCATION (COMMON-LISP:OR *HERE-DIRECTORY* (PATHNAME-DIRECTORY-PATHNAME (LOAD-PATHNAME))) :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:NIL)) ((COMMON-LISP:EQL :USER-CACHE) (RESOLVE-ABSOLUTE-LOCATION *USER-CACHE* :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:NIL))) :WILDEN (COMMON-LISP:AND WILDEN (COMMON-LISP:NOT (COMMON-LISP:PATHNAMEP X))) :RESOLVE-SYMLINKS *RESOLVE-SYMLINKS* :WANT-ABSOLUTE COMMON-LISP:T)) (COMMON-LISP:DECLAIM (COMMON-LISP:FTYPE (COMMON-LISP:FUNCTION (COMMON-LISP:T COMMON-LISP:&KEY (:DIRECTORY COMMON-LISP:BOOLEAN) (:WILDEN COMMON-LISP:BOOLEAN) (:ENSURE-DIRECTORY COMMON-LISP:BOOLEAN)) COMMON-LISP:T) RESOLVE-LOCATION)) (DEFUN* (RESOLVE-LOCATION) (X COMMON-LISP:&KEY ENSURE-DIRECTORY WILDEN COMMON-LISP:DIRECTORY) "Resolve location designator X into a PATHNAME" (UIOP/COMMON-LISP::LOOP* :WITH DIRP COMMON-LISP:= (COMMON-LISP:OR COMMON-LISP:DIRECTORY ENSURE-DIRECTORY) :WITH (COMMON-LISP:FIRST . COMMON-LISP:REST) COMMON-LISP:= (COMMON-LISP:IF (COMMON-LISP:ATOM X) (COMMON-LISP:LIST X) X) :WITH PATH COMMON-LISP:= (COMMON-LISP:OR (RESOLVE-ABSOLUTE-LOCATION COMMON-LISP:FIRST :ENSURE-DIRECTORY (COMMON-LISP:AND (COMMON-LISP:OR DIRP COMMON-LISP:REST) COMMON-LISP:T) :WILDEN (COMMON-LISP:AND WILDEN (COMMON-LISP:NULL COMMON-LISP:REST))) (COMMON-LISP:RETURN COMMON-LISP:NIL)) :FOR (ELEMENT . MOREP) :ON COMMON-LISP:REST :FOR DIR COMMON-LISP:= (COMMON-LISP:AND (COMMON-LISP:OR MOREP DIRP) COMMON-LISP:T) :FOR WILD COMMON-LISP:= (COMMON-LISP:AND WILDEN (COMMON-LISP:NOT MOREP)) :FOR SUB COMMON-LISP:= (MERGE-PATHNAMES* (RESOLVE-RELATIVE-LOCATION ELEMENT :ENSURE-DIRECTORY DIR :WILDEN WILD) PATH) :DO (COMMON-LISP:SETF PATH (COMMON-LISP:IF (ABSOLUTE-PATHNAME-P SUB) (RESOLVE-SYMLINKS* SUB) SUB)) :FINALLY (COMMON-LISP:RETURN PATH))) (COMMON-LISP:DEFUN LOCATION-DESIGNATOR-P (X) "Is X a designator for a location?" (COMMON-LISP:FLET ((ABSOLUTE-COMPONENT-P (C) (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:PATHNAME (COMMON-LISP:MEMBER :ROOT :HOME :HERE :USER-CACHE))))) (RELATIVE-COMPONENT-P (C) (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:PATHNAME (COMMON-LISP:MEMBER :*/ :**/ :*.*.* :IMPLEMENTATION :IMPLEMENTATION-TYPE)))))) (COMMON-LISP:OR (COMMON-LISP:TYPEP X (COMMON-LISP:QUOTE COMMON-LISP:BOOLEAN)) (ABSOLUTE-COMPONENT-P X) (COMMON-LISP:AND (COMMON-LISP:CONSP X) (ABSOLUTE-COMPONENT-P (COMMON-LISP:FIRST X)) (COMMON-LISP:EVERY (COMMON-LISP:FUNCTION RELATIVE-COMPONENT-P) (COMMON-LISP:REST X)))))) (COMMON-LISP:DEFUN LOCATION-FUNCTION-P (X) "Is X the specification of a location function?" (COMMON-LISP:AND (LENGTH=N-P X 2) (COMMON-LISP:EQ (COMMON-LISP:CAR X) :FUNCTION))) (COMMON-LISP:DEFVAR *CLEAR-CONFIGURATION-HOOK* (COMMON-LISP:QUOTE COMMON-LISP:NIL)) (COMMON-LISP:DEFUN REGISTER-CLEAR-CONFIGURATION-HOOK (HOOK-FUNCTION COMMON-LISP:&OPTIONAL CALL-NOW-P) "Register a function to be called when clearing configuration" (REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *CLEAR-CONFIGURATION-HOOK*) HOOK-FUNCTION CALL-NOW-P)) (COMMON-LISP:DEFUN CLEAR-CONFIGURATION COMMON-LISP:NIL "Call the functions in *CLEAR-CONFIGURATION-HOOK*" (CALL-FUNCTIONS *CLEAR-CONFIGURATION-HOOK*)) (REGISTER-IMAGE-DUMP-HOOK (COMMON-LISP:QUOTE CLEAR-CONFIGURATION)) (COMMON-LISP:DEFUN UPGRADE-CONFIGURATION COMMON-LISP:NIL "If a previous version of ASDF failed to read some configuration, try again now." (COMMON-LISP:WHEN *IGNORED-CONFIGURATION-FORM* (CLEAR-CONFIGURATION) (COMMON-LISP:SETF *IGNORED-CONFIGURATION-FORM* COMMON-LISP:NIL))) (COMMON-LISP:DEFUN GET-FOLDER-PATH (FOLDER) "Semi-portable implementation of a subset of LispWorks' sys:get-folder-path,
     [java] this function tries to locate the Windows FOLDER for one of
     [java] :LOCAL-APPDATA, :APPDATA or :COMMON-APPDATA.
     [java]      Returns NIL when the folder is not defined (e.g., not on Windows)." (COMMON-LISP:OR (COMMON-LISP:ECASE FOLDER (:LOCAL-APPDATA (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORY "LOCALAPPDATA") (SUBPATHNAME* (GET-FOLDER-PATH :APPDATA) "Local"))) (:APPDATA (GETENV-ABSOLUTE-DIRECTORY "APPDATA")) (:COMMON-APPDATA (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORY "ALLUSERSAPPDATA") (SUBPATHNAME* (GETENV-ABSOLUTE-DIRECTORY "ALLUSERSPROFILE") "Application Data/")))))) (COMMON-LISP:DEFUN XDG-DATA-HOME (COMMON-LISP:&REST MORE) "Returns an absolute pathname for the directory containing user-specific data files.
     [java] MORE may contain specifications for a subpath relative to this directory: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (RESOLVE-ABSOLUTE-LOCATION (SYSTEM::BACKQ-LIST (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORY "XDG_DATA_HOME") (OS-COND ((OS-WINDOWS-P) (GET-FOLDER-PATH :LOCAL-APPDATA)) (COMMON-LISP:T (SUBPATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME) ".local/share/")))) MORE))) (COMMON-LISP:DEFUN XDG-CONFIG-HOME (COMMON-LISP:&REST MORE) "Returns a pathname for the directory containing user-specific configuration files.
     [java] MORE may contain specifications for a subpath relative to this directory: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (RESOLVE-ABSOLUTE-LOCATION (SYSTEM::BACKQ-LIST (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORY "XDG_CONFIG_HOME") (OS-COND ((OS-WINDOWS-P) (XDG-DATA-HOME "config/")) (COMMON-LISP:T (SUBPATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME) ".config/")))) MORE))) (COMMON-LISP:DEFUN XDG-DATA-DIRS (COMMON-LISP:&REST MORE) "The preference-ordered set of additional paths to search for data files.
     [java] Returns a list of absolute directory pathnames.
     [java] MORE may contain specifications for a subpath relative to these directories: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (D) (RESOLVE-LOCATION (SYSTEM::BACKQ-LIST D MORE)))) (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORIES "XDG_DATA_DIRS") (OS-COND ((OS-WINDOWS-P) (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE GET-FOLDER-PATH) (COMMON-LISP:QUOTE (:APPDATA :COMMON-APPDATA)))) (COMMON-LISP:T (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE PARSE-UNIX-NAMESTRING) (COMMON-LISP:QUOTE ("/usr/local/share/" "/usr/share/")))))))) (COMMON-LISP:DEFUN XDG-CONFIG-DIRS (COMMON-LISP:&REST MORE) "The preference-ordered set of additional base paths to search for configuration files.
     [java] Returns a list of absolute directory pathnames.
     [java] MORE may contain specifications for a subpath relative to these directories:
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (D) (RESOLVE-LOCATION (SYSTEM::BACKQ-LIST D MORE)))) (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORIES "XDG_CONFIG_DIRS") (OS-COND ((OS-WINDOWS-P) (XDG-DATA-DIRS "config/")) (COMMON-LISP:T (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE PARSE-UNIX-NAMESTRING) (COMMON-LISP:QUOTE ("/etc/xdg/")))))))) (COMMON-LISP:DEFUN XDG-CACHE-HOME (COMMON-LISP:&REST MORE) "The base directory relative to which user specific non-essential data files should be stored.
     [java] Returns an absolute directory pathname.
     [java] MORE may contain specifications for a subpath relative to this directory: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (RESOLVE-ABSOLUTE-LOCATION (SYSTEM::BACKQ-LIST (COMMON-LISP:OR (GETENV-ABSOLUTE-DIRECTORY "XDG_CACHE_HOME") (OS-COND ((OS-WINDOWS-P) (XDG-DATA-HOME "cache/")) (COMMON-LISP:T (SUBPATHNAME* (COMMON-LISP:USER-HOMEDIR-PATHNAME) ".cache/")))) MORE))) (COMMON-LISP:DEFUN XDG-RUNTIME-DIR (COMMON-LISP:&REST MORE) "Pathname for user-specific non-essential runtime files and other file objects,
     [java] such as sockets, named pipes, etc.
     [java] Returns an absolute directory pathname.
     [java] MORE may contain specifications for a subpath relative to this directory: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (RESOLVE-ABSOLUTE-LOCATION (SYSTEM::BACKQ-LIST (GETENV-ABSOLUTE-DIRECTORY "XDG_RUNTIME_DIR") MORE))) (COMMON-LISP:DEFUN SYSTEM-CONFIG-PATHNAMES (COMMON-LISP:&REST MORE) "Return a list of directories where are stored the system's default user configuration information.
     [java] MORE may contain specifications for a subpath relative to these directories: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE MORE)) (OS-COND ((OS-UNIX-P) (COMMON-LISP:LIST (RESOLVE-ABSOLUTE-LOCATION (SYSTEM::BACKQ-LIST (PARSE-UNIX-NAMESTRING "/etc/") MORE)))))) (COMMON-LISP:DEFUN FILTER-PATHNAME-SET (DIRS) "Parse strings as unix namestrings and remove duplicates and non absolute-pathnames in a list." (COMMON-LISP:REMOVE-DUPLICATES (COMMON-LISP:REMOVE-IF-NOT (COMMON-LISP:FUNCTION ABSOLUTE-PATHNAME-P) DIRS) :FROM-END COMMON-LISP:T :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMMON-LISP:DEFUN XDG-DATA-PATHNAMES (COMMON-LISP:&REST MORE) "Return a list of absolute pathnames for application data directories.  With APP,
     [java] returns directory for data for that application, without APP, returns the set of directories
     [java] for storing all application configurations.
     [java] MORE may contain specifications for a subpath relative to these directories: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (FILTER-PATHNAME-SET (SYSTEM::BACKQ-CONS (XDG-DATA-HOME MORE) (XDG-DATA-DIRS MORE)))) (COMMON-LISP:DEFUN XDG-CONFIG-PATHNAMES (COMMON-LISP:&REST MORE) "Return a list of pathnames for application configuration.
     [java] MORE may contain specifications for a subpath relative to these directories: a
     [java] subpathname specification and keyword arguments as per RESOLVE-LOCATION (see
     [java] also \"Configuration DSL\") in the ASDF manual." (FILTER-PATHNAME-SET (SYSTEM::BACKQ-CONS (XDG-CONFIG-HOME MORE) (XDG-CONFIG-DIRS MORE)))) (COMMON-LISP:DEFUN FIND-PREFERRED-FILE (FILES COMMON-LISP:&KEY (DIRECTION :INPUT)) "Find first file in the list of FILES that exists (for direction :input or :probe)
     [java] or just the first one (for direction :output or :io).
     [java]     Note that when we say \"file\" here, the files in question may be directories." (COMMON-LISP:FIND-IF (COMMON-LISP:ECASE DIRECTION ((:PROBE :INPUT) (COMMON-LISP:QUOTE PROBE-FILE*)) ((:OUTPUT :IO) (COMMON-LISP:QUOTE COMMON-LISP:IDENTITY))) FILES)) (COMMON-LISP:DEFUN XDG-DATA-PATHNAME (COMMON-LISP:&OPTIONAL MORE (DIRECTION :INPUT)) (FIND-PREFERRED-FILE (XDG-DATA-PATHNAMES MORE) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN XDG-CONFIG-PATHNAME (COMMON-LISP:&OPTIONAL MORE (DIRECTION :INPUT)) (FIND-PREFERRED-FILE (XDG-CONFIG-PATHNAMES MORE) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN COMPUTE-USER-CACHE COMMON-LISP:NIL "Compute (and return) the location of the default user-cache for translate-output
     [java] objects. Side-effects for cached file location computation." (COMMON-LISP:SETF *USER-CACHE* (XDG-CACHE-HOME "common-lisp" :IMPLEMENTATION))) (REGISTER-IMAGE-RESTORE-HOOK (COMMON-LISP:QUOTE COMPUTE-USER-CACHE)))
     [java] ;COMMON-LISP:LISP-IMPLEMENTATION-VERSION triggers autoloading of org.armedbear.lisp.lisp_implementation_version ...
     [java] ; Autoloaded org.armedbear.lisp.lisp_implementation_version (0.005 seconds)
     [java] ;SYSTEM::MAKE-CASE-FROB-STREAM triggers autoloading of org.armedbear.lisp.CaseFrobStream ...
     [java] ; Autoloaded org.armedbear.lisp.CaseFrobStream (0.045 seconds)
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :UIOP/BACKWARD-DRIVER (:NICKNAMES :ASDF/BACKWARD-DRIVER) (:RECYCLE :UIOP/BACKWARD-DRIVER :ASDF/BACKWARD-DRIVER :ASDF) (:USE :UIOP/COMMON-LISP :UIOP/PACKAGE :UIOP/UTILITY :UIOP/PATHNAME :UIOP/STREAM :UIOP/OS :UIOP/IMAGE :UIOP/RUN-PROGRAM :UIOP/LISP-BUILD :UIOP/CONFIGURATION) (:EXPORT #:COERCE-PATHNAME #:COMPONENT-NAME-TO-PATHNAME-COMPONENTS #:USER-CONFIGURATION-DIRECTORIES #:SYSTEM-CONFIGURATION-DIRECTORIES #:IN-FIRST-DIRECTORY #:IN-USER-CONFIGURATION-DIRECTORY #:IN-SYSTEM-CONFIGURATION-DIRECTORY))
     [java] ; (COMMON-LISP:IN-PACKAGE :UIOP/BACKWARD-DRIVER)
     [java] ; (WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COERCE-PATHNAME (NAME COMMON-LISP:&KEY COMMON-LISP:TYPE DEFAULTS) (PARSE-UNIX-NAMESTRING NAME :TYPE COMMON-LISP:TYPE :DEFAULTS DEFAULTS)) (COMMON-LISP:DEFUN COMPONENT-NAME-TO-PATHNAME-COMPONENTS (UNIX-STYLE-NAMESTRING COMMON-LISP:&KEY FORCE-DIRECTORY FORCE-RELATIVE) (COMMON-LISP:MULTIPLE-VALUE-BIND (RELABS PATH FILENAME FILE-ONLY) (SPLIT-UNIX-NAMESTRING-DIRECTORY-COMPONENTS UNIX-STYLE-NAMESTRING :ENSURE-DIRECTORY FORCE-DIRECTORY) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FILE-ONLY)) (COMMON-LISP:WHEN (COMMON-LISP:AND FORCE-RELATIVE (COMMON-LISP:NOT (COMMON-LISP:EQ RELABS :RELATIVE))) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Absolute pathname designator not allowed: ~3i~_~S~@:>") UNIX-STYLE-NAMESTRING)) (COMMON-LISP:VALUES RELABS PATH FILENAME))) (COMMON-LISP:DEFUN USER-CONFIGURATION-DIRECTORIES COMMON-LISP:NIL "Return the current user's list of user configuration directories
     [java] for configuring common-lisp.
     [java]     DEPRECATED. Use uiop:xdg-config-pathnames instead." (XDG-CONFIG-PATHNAMES "common-lisp")) (COMMON-LISP:DEFUN SYSTEM-CONFIGURATION-DIRECTORIES COMMON-LISP:NIL "Return the list of system configuration directories for common-lisp.
     [java]     DEPRECATED. Use uiop:config-system-pathnames instead." (SYSTEM-CONFIG-PATHNAMES "common-lisp")) (COMMON-LISP:DEFUN IN-FIRST-DIRECTORY (DIRS X COMMON-LISP:&KEY (DIRECTION :INPUT)) "Finds the first appropriate file named X in the list of DIRS for I/O
     [java] in DIRECTION (which may be :INPUT, :OUTPUT, :IO, or :PROBE).
     [java]    If direction is :INPUT or :PROBE, will return the first extant file named
     [java] X in one of the DIRS.
     [java]    If direction is :OUTPUT or :IO, will simply return the file named X in the
     [java] first element of DIRS that exists. DEPRECATED." (FIND-PREFERRED-FILE (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (DIR) (SUBPATHNAME (ENSURE-DIRECTORY-PATHNAME DIR) X))) DIRS) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN IN-USER-CONFIGURATION-DIRECTORY (X COMMON-LISP:&KEY (DIRECTION :INPUT)) "Return the file named X in the user configuration directory for common-lisp.
     [java] DEPRECATED." (XDG-CONFIG-PATHNAME (SYSTEM::BACKQ-LIST "common-lisp" X) DIRECTION)) (COMMON-LISP:DEFUN IN-SYSTEM-CONFIGURATION-DIRECTORY (X COMMON-LISP:&KEY (DIRECTION :INPUT)) "Return the pathname for the file named X under the system configuration directory
     [java] for common-lisp. DEPRECATED." (FIND-PREFERRED-FILE (SYSTEM-CONFIG-PATHNAMES "common-lisp" X) :DIRECTION DIRECTION)))
     [java] ; (DEFINE-PACKAGE :UIOP/DRIVER (:NICKNAMES :UIOP :ASDF/DRIVER :ASDF-DRIVER :ASDF-UTILS) (:USE :UIOP/COMMON-LISP) (:USE-REEXPORT :UIOP/PACKAGE :UIOP/UTILITY :UIOP/OS :UIOP/PATHNAME :UIOP/STREAM :UIOP/FILESYSTEM :UIOP/IMAGE :UIOP/RUN-PROGRAM :UIOP/LISP-BUILD :UIOP/CONFIGURATION :UIOP/BACKWARD-DRIVER))
     [java] ; (DEFINE-PACKAGE :ASDF/UPGRADE (:RECYCLE :ASDF/UPGRADE :ASDF) (:USE :UIOP/COMMON-LISP :UIOP) (:EXPORT #:ASDF-VERSION #:*PREVIOUS-ASDF-VERSIONS* #:*ASDF-VERSION* #:ASDF-MESSAGE #:*VERBOSE-OUT* #:UPGRADING-P #:WHEN-UPGRADING #:UPGRADE-ASDF #:ASDF-UPGRADE-ERROR #:DEFPARAMETER* #:*POST-UPGRADE-CLEANUP-HOOK* #:*POST-UPGRADE-RESTART-HOOK* #:CLEANUP-UPGRADED-ASDF #:INTERN*) (:IMPORT-FROM :UIOP/PACKAGE #:INTERN* #:FIND-SYMBOL*))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/UPGRADE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ASDF-VERSION COMMON-LISP:NIL "Exported interface to the version of ASDF currently installed. A string.
     [java] You can compare this string with e.g.: (ASDF:VERSION-SATISFIES (ASDF:ASDF-VERSION) \"3.4.5.67\")." (COMMON-LISP:WHEN (COMMON-LISP:FIND-PACKAGE :ASDF) (COMMON-LISP:OR (COMMON-LISP:SYMBOL-VALUE (COMMON-LISP:FIND-SYMBOL (COMMON-LISP:STRING :*ASDF-VERSION*) :ASDF)) (COMMON-LISP:LET* ((REVSYM (COMMON-LISP:FIND-SYMBOL (COMMON-LISP:STRING :*ASDF-REVISION*) :ASDF)) (REV (COMMON-LISP:AND REVSYM (COMMON-LISP:BOUNDP REVSYM) (COMMON-LISP:SYMBOL-VALUE REVSYM)))) (COMMON-LISP:ETYPECASE REV (COMMON-LISP:STRING REV) (COMMON-LISP:CONS (COMMON-LISP:FORMAT COMMON-LISP:NIL "~{~D~^.~}" REV)) (COMMON-LISP:NULL "1.0")))))) (COMMON-LISP:DEFVAR *PREVIOUS-ASDF-VERSIONS* (UIOP/UTILITY:IF-LET (PREVIOUS (ASDF-VERSION)) (COMMON-LISP:LIST PREVIOUS))) (COMMON-LISP:DEFVAR *ASDF-VERSION* COMMON-LISP:NIL) (COMMON-LISP:DEFPARAMETER *OLDEST-FORWARD-COMPATIBLE-ASDF-VERSION* "2.33") (COMMON-LISP:DEFVAR *VERBOSE-OUT* COMMON-LISP:NIL) (COMMON-LISP:DEFUN ASDF-MESSAGE (FORMAT-STRING COMMON-LISP:&REST FORMAT-ARGS) (COMMON-LISP:WHEN *VERBOSE-OUT* (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:FORMAT) *VERBOSE-OUT* FORMAT-STRING FORMAT-ARGS))) (COMMON-LISP:DEFVAR *POST-UPGRADE-CLEANUP-HOOK* COMMON-LISP:NIL) (COMMON-LISP:DEFVAR *POST-UPGRADE-RESTART-HOOK* COMMON-LISP:NIL) (COMMON-LISP:DEFUN UPGRADING-P (COMMON-LISP:&OPTIONAL (OLDEST-COMPATIBLE-VERSION *OLDEST-FORWARD-COMPATIBLE-ASDF-VERSION*)) (COMMON-LISP:AND *PREVIOUS-ASDF-VERSIONS* (UIOP/UTILITY:VERSION< (COMMON-LISP:FIRST *PREVIOUS-ASDF-VERSIONS*) OLDEST-COMPATIBLE-VERSION))) (COMMON-LISP:DEFMACRO DEFPARAMETER* (VAR VALUE COMMON-LISP:&OPTIONAL DOCSTRING (VERSION *OLDEST-FORWARD-COMPATIBLE-ASDF-VERSION*)) (COMMON-LISP:LET* ((NAME (COMMON-LISP:STRING-TRIM "*" VAR)) (VALFUN (COMMON-LISP:INTERN (COMMON-LISP:FORMAT COMMON-LISP:NIL "%~A-~A-~A" :COMPUTE NAME :VALUE)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:PROGN) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DEFUN) VALFUN COMMON-LISP:NIL VALUE) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:DEFVAR) VAR (SYSTEM::BACKQ-LIST VALFUN) (UIOP/UTILITY:ENSURE-LIST DOCSTRING)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:WHEN) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE UPGRADING-P) VERSION) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:SETF) VAR (SYSTEM::BACKQ-LIST VALFUN)))))) (COMMON-LISP:DEFMACRO WHEN-UPGRADING ((COMMON-LISP:&KEY (VERSION *OLDEST-FORWARD-COMPATIBLE-ASDF-VERSION*) (UPGRADING-P (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE UPGRADING-P) VERSION)) COMMON-LISP:WHEN) COMMON-LISP:&BODY BODY) "A wrapper macro for code that should only be run when upgrading a
     [java] previously-loaded version of ASDF." (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE UIOP/UTILITY:WITH-UPGRADABILITY) COMMON-LISP:NIL (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:WHEN) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:AND) UPGRADING-P (COMMON-LISP:WHEN COMMON-LISP:WHEN (SYSTEM::BACKQ-LIST COMMON-LISP:WHEN))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:HANDLER-BIND) (COMMON-LISP:QUOTE ((COMMON-LISP:STYLE-WARNING (COMMON-LISP:FUNCTION COMMON-LISP:MUFFLE-WARNING)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:EVAL) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE COMMON-LISP:PROGN) BODY))))))) (COMMON-LISP:LET* ((ASDF-VERSION "3.1.6") (EXISTING-VERSION (ASDF-VERSION))) (COMMON-LISP:SETF *ASDF-VERSION* ASDF-VERSION) (COMMON-LISP:WHEN (COMMON-LISP:AND EXISTING-VERSION (COMMON-LISP:NOT (COMMON-LISP:EQUAL ASDF-VERSION EXISTING-VERSION))) (COMMON-LISP:PUSH EXISTING-VERSION *PREVIOUS-ASDF-VERSIONS*) (COMMON-LISP:WHEN (COMMON-LISP:OR *VERBOSE-OUT* COMMON-LISP:*LOAD-VERBOSE*) (COMMON-LISP:FORMAT (COMMON-LISP:OR *VERBOSE-OUT* COMMON-LISP:*TRACE-OUTPUT*) (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;Upgrading ASDF ~@[from version ~A ~]to version ~A~@:>~%") EXISTING-VERSION ASDF-VERSION)))))
     [java] ; (WHEN-UPGRADING COMMON-LISP:NIL (COMMON-LISP:LET ((REDEFINED-FUNCTIONS (COMMON-LISP:QUOTE (#:COMPONENT-RELATIVE-PATHNAME #:COMPONENT-PARENT-PATHNAME #:SOURCE-FILE-TYPE #:FIND-SYSTEM #:SYSTEM-SOURCE-FILE #:SYSTEM-RELATIVE-PATHNAME #:FIND-COMPONENT #:EXPLAIN #:PERFORM #:PERFORM-WITH-RESTARTS #:INPUT-FILES #:OUTPUT-FILES #:COMPONENT-DEPENDS-ON #:OPERATION-DONE-P #:COMPONENT-DEPENDS-ON #:TRAVERSE #:MAP-DIRECT-DEPENDENCIES #:REDUCE-DIRECT-DEPENDENCIES #:DIRECT-DEPENDENCIES #:OPERATE #:PARSE-COMPONENT-FORM #:APPLY-OUTPUT-TRANSLATIONS #:PROCESS-OUTPUT-TRANSLATIONS-DIRECTIVE #:INHERIT-SOURCE-REGISTRY #:PROCESS-SOURCE-REGISTRY #:PROCESS-SOURCE-REGISTRY-DIRECTIVE #:TRIVIAL-SYSTEM-P))) (REDEFINED-CLASSES (COMMON-LISP:QUOTE ((#:COMPILE-CONCATENATED-SOURCE-OP (#:OPERATION) COMMON-LISP:NIL))))) (COMMON-LISP:LOOP :FOR NAME :IN REDEFINED-FUNCTIONS :FOR SYM COMMON-LISP:= (FIND-SYMBOL* NAME :ASDF COMMON-LISP:NIL) :DO (COMMON-LISP:WHEN SYM (COMMON-LISP:FMAKUNBOUND SYM))) (COMMON-LISP:LABELS ((ASYM (X) (COMMON-LISP:MULTIPLE-VALUE-BIND (S P) (COMMON-LISP:IF (COMMON-LISP:CONSP X) (COMMON-LISP:VALUES (COMMON-LISP:CAR X) (COMMON-LISP:CADR X)) (COMMON-LISP:VALUES X :ASDF)) (FIND-SYMBOL* S P COMMON-LISP:NIL))) (ASYMS (L) (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION ASYM) L))) (UIOP/COMMON-LISP::LOOP* :FOR (NAME SUPERCLASSES SLOTS) :IN REDEFINED-CLASSES :FOR SYM COMMON-LISP:= (FIND-SYMBOL* NAME :ASDF COMMON-LISP:NIL) :WHEN (COMMON-LISP:AND SYM (COMMON-LISP:FIND-CLASS SYM)) :DO (COMMON-LISP:EVAL (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DEFCLASS) SYM (ASYMS SUPERCLASSES) (ASYMS SLOTS)))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ASDF-UPGRADE-ERROR COMMON-LISP:NIL (COMMON-LISP:ERROR "When a system transitively depends on ASDF, it must :defsystem-depends-on (:asdf)~%~
     [java]           Otherwise, when you upgrade from ASDF 2, you must do it before you operate on any system.~%")) (COMMON-LISP:DEFUN CLEANUP-UPGRADED-ASDF (COMMON-LISP:&OPTIONAL (OLD-VERSION (COMMON-LISP:FIRST *PREVIOUS-ASDF-VERSIONS*))) (COMMON-LISP:LET ((NEW-VERSION (ASDF-VERSION))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL OLD-VERSION NEW-VERSION) (COMMON-LISP:PUSH NEW-VERSION *PREVIOUS-ASDF-VERSIONS*) (COMMON-LISP:WHEN OLD-VERSION (COMMON-LISP:IF (UIOP/UTILITY:VERSION<= NEW-VERSION OLD-VERSION) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;Downgraded ASDF from version ~A to version ~A~@:>~%") OLD-VERSION NEW-VERSION) (ASDF-MESSAGE (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;Upgraded ASDF from version ~A to version ~A~@:>~%") OLD-VERSION NEW-VERSION)) (COMMON-LISP:UNLESS (UIOP/UTILITY:VERSION<= *OLDEST-FORWARD-COMPATIBLE-ASDF-VERSION* OLD-VERSION) (UIOP/UTILITY:CALL-FUNCTIONS (COMMON-LISP:REVERSE *POST-UPGRADE-CLEANUP-HOOK*))) COMMON-LISP:T)))) (COMMON-LISP:DEFUN UPGRADE-ASDF COMMON-LISP:NIL "Try to upgrade of ASDF. If a different version was used, return T.
     [java]    We need do that before we operate on anything that may possibly depend on ASDF." (COMMON-LISP:LET ((COMMON-LISP:*LOAD-PRINT* COMMON-LISP:NIL) (COMMON-LISP:*COMPILE-PRINT* COMMON-LISP:NIL)) (COMMON-LISP:HANDLER-BIND (((COMMON-LISP:OR COMMON-LISP:STYLE-WARNING) (COMMON-LISP:FUNCTION COMMON-LISP:MUFFLE-WARNING))) (UIOP/PACKAGE:SYMBOL-CALL :ASDF :LOAD-SYSTEM :ASDF :VERBOSE COMMON-LISP:NIL)))) (UIOP/UTILITY:REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *POST-UPGRADE-CLEANUP-HOOK*) (COMMON-LISP:QUOTE UIOP/CONFIGURATION:UPGRADE-CONFIGURATION)))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/COMPONENT (:RECYCLE :ASDF/COMPONENT :ASDF/DEFSYSTEM :ASDF/FIND-SYSTEM :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE) (:EXPORT #:COMPONENT #:COMPONENT-FIND-PATH #:COMPONENT-NAME #:COMPONENT-PATHNAME #:COMPONENT-RELATIVE-PATHNAME #:COMPONENT-PARENT #:COMPONENT-SYSTEM #:COMPONENT-PARENT-PATHNAME #:CHILD-COMPONENT #:PARENT-COMPONENT #:MODULE #:FILE-COMPONENT #:SOURCE-FILE #:C-SOURCE-FILE #:JAVA-SOURCE-FILE #:STATIC-FILE #:DOC-FILE #:HTML-FILE #:FILE-TYPE #:SOURCE-FILE-TYPE #:SOURCE-FILE-EXPLICIT-TYPE #:COMPONENT-IN-ORDER-TO #:COMPONENT-SIDEWAY-DEPENDENCIES #:COMPONENT-IF-FEATURE #:AROUND-COMPILE-HOOK #:COMPONENT-DESCRIPTION #:COMPONENT-LONG-DESCRIPTION #:COMPONENT-VERSION #:VERSION-SATISFIES #:COMPONENT-INLINE-METHODS #:COMPONENT-OPERATION-TIMES #:COMPONENT-EXTERNAL-FORMAT #:COMPONENT-ENCODING #:COMPONENT-CHILDREN-BY-NAME #:COMPONENT-CHILDREN #:COMPUTE-CHILDREN-BY-NAME #:COMPONENT-BUILD-OPERATION #:MODULE-DEFAULT-COMPONENT-CLASS #:MODULE-COMPONENTS #:SUB-COMPONENTS #:SYSTEM-DEFINITION-ERROR #:DUPLICATE-NAMES #:NAME #:VERSION #:DESCRIPTION #:LONG-DESCRIPTION #:AUTHOR #:MAINTAINER #:LICENCE #:COMPONENTS-BY-NAME #:COMPONENTS #:CHILDREN #:CHILDREN-BY-NAME #:DEFAULT-COMPONENT-CLASS #:SOURCE-FILE #:DEFSYSTEM-DEPENDS-ON #:SIDEWAY-DEPENDENCIES #:IF-FEATURE #:IN-ORDER-TO #:INLINE-METHODS #:RELATIVE-PATHNAME #:ABSOLUTE-PATHNAME #:OPERATION-TIMES #:AROUND-COMPILE #:%ENCODING #:PROPERTIES #:COMPONENT-PROPERTIES #:PARENT))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/COMPONENT)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC COMPONENT-NAME (COMPONENT) (:DOCUMENTATION "Name of the COMPONENT, unique relative to its parent")) (COMMON-LISP:DEFGENERIC COMPONENT-SYSTEM (COMPONENT) (:DOCUMENTATION "Find the top-level system containing COMPONENT")) (COMMON-LISP:DEFGENERIC COMPONENT-PATHNAME (COMPONENT) (:DOCUMENTATION "Extracts the pathname applicable for a particular component.")) (COMMON-LISP:DEFGENERIC (COMPONENT-RELATIVE-PATHNAME) (COMPONENT) (:DOCUMENTATION "Returns a pathname for the component argument intended to be
     [java] interpreted relative to the pathname of that component's parent.
     [java] Despite the function's name, the return value may be an absolute
     [java] pathname, because an absolute pathname may be interpreted relative to
     [java] another pathname in a degenerate way.")) (COMMON-LISP:DEFGENERIC COMPONENT-EXTERNAL-FORMAT (COMPONENT)) (COMMON-LISP:DEFGENERIC COMPONENT-ENCODING (COMPONENT)) (COMMON-LISP:DEFGENERIC VERSION-SATISFIES (COMPONENT VERSION)) (COMMON-LISP:DEFGENERIC COMPONENT-VERSION (COMPONENT)) (COMMON-LISP:DEFGENERIC (COMMON-LISP:SETF COMPONENT-VERSION) (NEW-VERSION COMPONENT)) (COMMON-LISP:DEFGENERIC COMPONENT-PARENT (COMPONENT)) (COMMON-LISP:DEFMETHOD COMPONENT-PARENT ((COMPONENT COMMON-LISP:NULL)) COMMON-LISP:NIL) (COMMON-LISP:DEFGENERIC (SOURCE-FILE-TYPE) (COMPONENT SYSTEM)) (COMMON-LISP:DEFINE-CONDITION SYSTEM-DEFINITION-ERROR (COMMON-LISP:ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION DUPLICATE-NAMES (SYSTEM-DEFINITION-ERROR) ((NAME :INITARG :NAME :READER DUPLICATE-NAMES-NAME)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Error while defining system: multiple components are given same name ~S~@:>") (DUPLICATE-NAMES-NAME C))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS COMPONENT COMMON-LISP:NIL ((NAME :ACCESSOR COMPONENT-NAME :INITARG :NAME :TYPE COMMON-LISP:STRING :DOCUMENTATION "Component name: designator for a string composed of portable pathname characters") (VERSION :ACCESSOR COMPONENT-VERSION :INITARG :VERSION :INITFORM COMMON-LISP:NIL) (DESCRIPTION :ACCESSOR COMPONENT-DESCRIPTION :INITARG :DESCRIPTION :INITFORM COMMON-LISP:NIL) (LONG-DESCRIPTION :ACCESSOR COMPONENT-LONG-DESCRIPTION :INITARG :LONG-DESCRIPTION :INITFORM COMMON-LISP:NIL) (SIDEWAY-DEPENDENCIES :ACCESSOR COMPONENT-SIDEWAY-DEPENDENCIES :INITFORM COMMON-LISP:NIL) (IF-FEATURE :ACCESSOR COMPONENT-IF-FEATURE :INITFORM COMMON-LISP:NIL :INITARG :IF-FEATURE) (IN-ORDER-TO :INITFORM COMMON-LISP:NIL :INITARG :IN-ORDER-TO :ACCESSOR COMPONENT-IN-ORDER-TO) (INLINE-METHODS :ACCESSOR COMPONENT-INLINE-METHODS :INITFORM COMMON-LISP:NIL) (RELATIVE-PATHNAME :INITARG :PATHNAME) (ABSOLUTE-PATHNAME) (OPERATION-TIMES :INITFORM (COMMON-LISP:MAKE-HASH-TABLE) :ACCESSOR COMPONENT-OPERATION-TIMES) (AROUND-COMPILE :INITARG :AROUND-COMPILE) (PROPERTIES :ACCESSOR COMPONENT-PROPERTIES :INITARG :PROPERTIES :INITFORM COMMON-LISP:NIL) (%ENCODING :ACCESSOR %COMPONENT-ENCODING :INITFORM COMMON-LISP:NIL :INITARG :ENCODING) (PARENT :INITARG :PARENT :INITFORM COMMON-LISP:NIL :READER COMPONENT-PARENT) (BUILD-OPERATION :INITARG :BUILD-OPERATION :INITFORM COMMON-LISP:NIL :READER COMPONENT-BUILD-OPERATION))) (COMMON-LISP:DEFUN COMPONENT-FIND-PATH (COMPONENT) "Return a path from a root system to the COMPONENT.
     [java] The return value is a list of component NAMES; a list of strings." (COMMON-LISP:CHECK-TYPE COMPONENT (COMMON-LISP:OR COMMON-LISP:NULL COMPONENT)) (COMMON-LISP:REVERSE (COMMON-LISP:LOOP :FOR C COMMON-LISP:= COMPONENT :THEN (COMPONENT-PARENT C) :WHILE C :COLLECT (COMPONENT-NAME C)))) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((C COMPONENT) COMMON-LISP:STREAM) (COMMON-LISP:PRINT-UNREADABLE-OBJECT (C COMMON-LISP:STREAM :TYPE COMMON-LISP:T :IDENTITY COMMON-LISP:NIL) (COMMON-LISP:FORMAT COMMON-LISP:STREAM "~{~S~^ ~}" (COMPONENT-FIND-PATH C)))) (COMMON-LISP:DEFMETHOD COMPONENT-SYSTEM ((COMPONENT COMPONENT)) (UIOP/UTILITY:IF-LET (SYSTEM (COMPONENT-PARENT COMPONENT)) (COMPONENT-SYSTEM SYSTEM) COMPONENT)))
     [java] ;COMMON-LISP:DOCUMENTATION triggers autoloading of documentation ...
     [java] ; Autoloaded documentation (0.026 seconds)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS CHILD-COMPONENT (COMPONENT) COMMON-LISP:NIL (:DOCUMENTATION "A CHILD-COMPONENT is a component that may be part of
     [java] a PARENT-COMPONENT.")) (COMMON-LISP:DEFCLASS FILE-COMPONENT (CHILD-COMPONENT) ((COMMON-LISP:TYPE :ACCESSOR FILE-TYPE :INITARG :TYPE))) (COMMON-LISP:DEFCLASS SOURCE-FILE (FILE-COMPONENT) ((COMMON-LISP:TYPE :ACCESSOR SOURCE-FILE-EXPLICIT-TYPE :INITFORM COMMON-LISP:NIL))) (COMMON-LISP:DEFCLASS C-SOURCE-FILE (SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM "c"))) (COMMON-LISP:DEFCLASS JAVA-SOURCE-FILE (SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM "java"))) (COMMON-LISP:DEFCLASS STATIC-FILE (SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM COMMON-LISP:NIL))) (COMMON-LISP:DEFCLASS DOC-FILE (STATIC-FILE) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS HTML-FILE (DOC-FILE) ((COMMON-LISP:TYPE :INITFORM "html"))) (COMMON-LISP:DEFCLASS PARENT-COMPONENT (COMPONENT) ((CHILDREN :INITFORM COMMON-LISP:NIL :INITARG :COMPONENTS :READER MODULE-COMPONENTS :ACCESSOR COMPONENT-CHILDREN) (CHILDREN-BY-NAME :READER MODULE-COMPONENTS-BY-NAME :ACCESSOR COMPONENT-CHILDREN-BY-NAME) (DEFAULT-COMPONENT-CLASS :INITFORM COMMON-LISP:NIL :INITARG :DEFAULT-COMPONENT-CLASS :ACCESSOR MODULE-DEFAULT-COMPONENT-CLASS)) (:DOCUMENTATION "A PARENT-COMPONENT is a component that may have
     [java] children.")))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COMPUTE-CHILDREN-BY-NAME (PARENT COMMON-LISP:&KEY ONLY-IF-NEEDED-P) (COMMON-LISP:UNLESS (COMMON-LISP:AND ONLY-IF-NEEDED-P (COMMON-LISP:SLOT-BOUNDP PARENT (COMMON-LISP:QUOTE CHILDREN-BY-NAME))) (COMMON-LISP:LET ((HASH (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (COMMON-LISP:SETF (COMPONENT-CHILDREN-BY-NAME PARENT) HASH) (COMMON-LISP:LOOP :FOR C :IN (COMPONENT-CHILDREN PARENT) :FOR NAME COMMON-LISP:= (COMPONENT-NAME C) :FOR PREVIOUS COMMON-LISP:= (COMMON-LISP:GETHASH NAME HASH) :DO (COMMON-LISP:WHEN PREVIOUS (COMMON-LISP:ERROR (COMMON-LISP:QUOTE DUPLICATE-NAMES) :NAME NAME)) (COMMON-LISP:SETF (COMMON-LISP:GETHASH NAME HASH) C)) HASH))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS MODULE (CHILD-COMPONENT PARENT-COMPONENT) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (COMPONENT-PARENT-PATHNAME) (COMPONENT)) (COMMON-LISP:DEFMETHOD COMPONENT-PARENT-PATHNAME (COMPONENT) (COMPONENT-PATHNAME (COMPONENT-PARENT COMPONENT))) (COMMON-LISP:DEFMETHOD COMPONENT-PATHNAME ((COMPONENT COMPONENT)) (COMMON-LISP:IF (COMMON-LISP:SLOT-BOUNDP COMPONENT (COMMON-LISP:QUOTE ABSOLUTE-PATHNAME)) (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE ABSOLUTE-PATHNAME)) (COMMON-LISP:LET ((COMMON-LISP:PATHNAME (UIOP/PATHNAME:MERGE-PATHNAMES* (COMPONENT-RELATIVE-PATHNAME COMPONENT) (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (COMPONENT-PARENT-PATHNAME COMPONENT))))) (COMMON-LISP:UNLESS (COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:PATHNAME) (UIOP/PATHNAME:ABSOLUTE-PATHNAME-P COMMON-LISP:PATHNAME)) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid relative pathname ~S for component ~S~@:>") COMMON-LISP:PATHNAME (COMPONENT-FIND-PATH COMPONENT))) (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE ABSOLUTE-PATHNAME)) COMMON-LISP:PATHNAME) COMMON-LISP:PATHNAME))) (COMMON-LISP:DEFMETHOD COMPONENT-RELATIVE-PATHNAME ((COMPONENT COMPONENT)) (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:SLOT-BOUNDP COMPONENT (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE RELATIVE-PATHNAME))) (COMPONENT-NAME COMPONENT)) :WANT-RELATIVE COMMON-LISP:T :TYPE (SOURCE-FILE-TYPE COMPONENT (COMPONENT-SYSTEM COMPONENT)) :DEFAULTS (COMPONENT-PARENT-PATHNAME COMPONENT))) (COMMON-LISP:DEFMETHOD SOURCE-FILE-TYPE ((COMPONENT PARENT-COMPONENT) (SYSTEM PARENT-COMPONENT)) :DIRECTORY) (COMMON-LISP:DEFMETHOD SOURCE-FILE-TYPE ((COMPONENT FILE-COMPONENT) (SYSTEM PARENT-COMPONENT)) (FILE-TYPE COMPONENT)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD COMPONENT-ENCODING ((C COMPONENT)) (COMMON-LISP:OR (COMMON-LISP:LOOP :FOR X COMMON-LISP:= C :THEN (COMPONENT-PARENT X) :WHILE X :THEREIS (%COMPONENT-ENCODING X)) (UIOP/STREAM:DETECT-ENCODING (COMPONENT-PATHNAME C)))) (COMMON-LISP:DEFMETHOD COMPONENT-EXTERNAL-FORMAT ((C COMPONENT)) (UIOP/STREAM:ENCODING-EXTERNAL-FORMAT (COMPONENT-ENCODING C))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC AROUND-COMPILE-HOOK (COMPONENT)) (COMMON-LISP:DEFMETHOD AROUND-COMPILE-HOOK ((C COMPONENT)) (COMMON-LISP:COND ((COMMON-LISP:SLOT-BOUNDP C (COMMON-LISP:QUOTE AROUND-COMPILE)) (COMMON-LISP:SLOT-VALUE C (COMMON-LISP:QUOTE AROUND-COMPILE))) ((COMPONENT-PARENT C) (AROUND-COMPILE-HOOK (COMPONENT-PARENT C))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD VERSION-SATISFIES :AROUND ((C COMMON-LISP:T) (VERSION COMMON-LISP:NULL)) COMMON-LISP:T) (COMMON-LISP:DEFMETHOD VERSION-SATISFIES ((C COMPONENT) VERSION) (COMMON-LISP:UNLESS (COMMON-LISP:AND VERSION (COMMON-LISP:SLOT-BOUNDP C (COMMON-LISP:QUOTE VERSION)) (COMPONENT-VERSION C)) (COMMON-LISP:WHEN VERSION (COMMON-LISP:WARN "Requested version ~S but ~S has no version" VERSION C)) (COMMON-LISP:RETURN-FROM VERSION-SATISFIES COMMON-LISP:NIL)) (VERSION-SATISFIES (COMPONENT-VERSION C) VERSION)) (COMMON-LISP:DEFMETHOD VERSION-SATISFIES ((CVER COMMON-LISP:STRING) VERSION) (UIOP/UTILITY:VERSION<= VERSION CVER)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN SUB-COMPONENTS (COMPONENT COMMON-LISP:&KEY (COMMON-LISP:TYPE COMMON-LISP:T)) (UIOP/UTILITY:WHILE-COLLECTING (C) (COMMON-LISP:LABELS ((RECURSE (X) (COMMON-LISP:WHEN (UIOP/UTILITY:IF-LET (IT (COMPONENT-IF-FEATURE X)) (UIOP/OS:FEATUREP IT) COMMON-LISP:T) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP X COMMON-LISP:TYPE) (C X)) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP X (COMMON-LISP:QUOTE PARENT-COMPONENT)) (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:FUNCTION RECURSE) (COMPONENT-CHILDREN X)))))) (RECURSE COMPONENT)))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/SYSTEM (:RECYCLE :ASDF :ASDF/SYSTEM) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT) (:EXPORT #:SYSTEM #:PROTO-SYSTEM #:SYSTEM-SOURCE-FILE #:SYSTEM-SOURCE-DIRECTORY #:SYSTEM-RELATIVE-PATHNAME #:RESET-SYSTEM #:SYSTEM-DESCRIPTION #:SYSTEM-LONG-DESCRIPTION #:SYSTEM-AUTHOR #:SYSTEM-MAINTAINER #:SYSTEM-LICENCE #:SYSTEM-LICENSE #:SYSTEM-DEFSYSTEM-DEPENDS-ON #:SYSTEM-DEPENDS-ON #:SYSTEM-WEAKLY-DEPENDS-ON #:COMPONENT-BUILD-PATHNAME #:BUILD-PATHNAME #:COMPONENT-ENTRY-POINT #:ENTRY-POINT #:HOMEPAGE #:SYSTEM-HOMEPAGE #:BUG-TRACKER #:SYSTEM-BUG-TRACKER #:MAILTO #:SYSTEM-MAILTO #:LONG-NAME #:SYSTEM-LONG-NAME #:SOURCE-CONTROL #:SYSTEM-SOURCE-CONTROL #:FIND-SYSTEM #:BUILTIN-SYSTEM-P))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/SYSTEM)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (FIND-SYSTEM) (SYSTEM COMMON-LISP:&OPTIONAL ERROR-P)) (UIOP/UTILITY:DEFGENERIC* (SYSTEM-SOURCE-FILE :SUPERSEDE COMMON-LISP:T) (SYSTEM) (:DOCUMENTATION "Return the source file in which system is defined.")) (COMMON-LISP:DEFGENERIC COMPONENT-BUILD-PATHNAME (COMPONENT)) (COMMON-LISP:DEFGENERIC COMPONENT-ENTRY-POINT (COMPONENT)) (COMMON-LISP:DEFMETHOD COMPONENT-ENTRY-POINT ((C COMPONENT)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS PROTO-SYSTEM COMMON-LISP:NIL ((NAME) (SOURCE-FILE))) (COMMON-LISP:DEFCLASS SYSTEM (MODULE PROTO-SYSTEM) ((DESCRIPTION :ACCESSOR SYSTEM-DESCRIPTION) (LONG-DESCRIPTION :ACCESSOR SYSTEM-LONG-DESCRIPTION) (AUTHOR :ACCESSOR SYSTEM-AUTHOR :INITARG :AUTHOR :INITFORM COMMON-LISP:NIL) (MAINTAINER :ACCESSOR SYSTEM-MAINTAINER :INITARG :MAINTAINER :INITFORM COMMON-LISP:NIL) (LICENCE :ACCESSOR SYSTEM-LICENCE :INITARG :LICENCE :ACCESSOR SYSTEM-LICENSE :INITARG :LICENSE :INITFORM COMMON-LISP:NIL) (HOMEPAGE :ACCESSOR SYSTEM-HOMEPAGE :INITARG :HOMEPAGE :INITFORM COMMON-LISP:NIL) (BUG-TRACKER :ACCESSOR SYSTEM-BUG-TRACKER :INITARG :BUG-TRACKER :INITFORM COMMON-LISP:NIL) (MAILTO :ACCESSOR SYSTEM-MAILTO :INITARG :MAILTO :INITFORM COMMON-LISP:NIL) (LONG-NAME :ACCESSOR SYSTEM-LONG-NAME :INITARG :LONG-NAME :INITFORM COMMON-LISP:NIL) (SOURCE-CONTROL :ACCESSOR SYSTEM-SOURCE-CONTROL :INITARG :SOURCE-CONTROL :INITFORM COMMON-LISP:NIL) (BUILTIN-SYSTEM-P :ACCESSOR BUILTIN-SYSTEM-P :INITFORM COMMON-LISP:NIL :INITARG :BUILTIN-SYSTEM-P) (BUILD-PATHNAME :INITFORM COMMON-LISP:NIL :INITARG :BUILD-PATHNAME :ACCESSOR COMPONENT-BUILD-PATHNAME) (ENTRY-POINT :INITFORM COMMON-LISP:NIL :INITARG :ENTRY-POINT :ACCESSOR COMPONENT-ENTRY-POINT) (SOURCE-FILE :INITFORM COMMON-LISP:NIL :INITARG :SOURCE-FILE :ACCESSOR SYSTEM-SOURCE-FILE) (DEFSYSTEM-DEPENDS-ON :READER SYSTEM-DEFSYSTEM-DEPENDS-ON :INITARG :DEFSYSTEM-DEPENDS-ON :INITFORM COMMON-LISP:NIL) (DEPENDS-ON :READER SYSTEM-DEPENDS-ON :INITFORM COMMON-LISP:NIL) (WEAKLY-DEPENDS-ON :READER SYSTEM-WEAKLY-DEPENDS-ON :INITFORM COMMON-LISP:NIL))) (COMMON-LISP:DEFUN RESET-SYSTEM (SYSTEM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:CHANGE-CLASS (COMMON-LISP:CHANGE-CLASS SYSTEM (COMMON-LISP:QUOTE PROTO-SYSTEM)) (COMMON-LISP:QUOTE SYSTEM)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:REINITIALIZE-INSTANCE) SYSTEM KEYS)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD SYSTEM-SOURCE-FILE ((SYSTEM-NAME COMMON-LISP:STRING)) (SYSTEM-SOURCE-FILE (FIND-SYSTEM SYSTEM-NAME))) (COMMON-LISP:DEFMETHOD SYSTEM-SOURCE-FILE ((SYSTEM-NAME COMMON-LISP:SYMBOL)) (SYSTEM-SOURCE-FILE (FIND-SYSTEM SYSTEM-NAME))) (COMMON-LISP:DEFUN SYSTEM-SOURCE-DIRECTORY (SYSTEM-DESIGNATOR) "Return a pathname object corresponding to the directory
     [java] in which the system specification (.asd file) is located." (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (SYSTEM-SOURCE-FILE SYSTEM-DESIGNATOR))) (COMMON-LISP:DEFUN (SYSTEM-RELATIVE-PATHNAME) (SYSTEM NAME COMMON-LISP:&KEY COMMON-LISP:TYPE) (UIOP/PATHNAME:SUBPATHNAME (SYSTEM-SOURCE-DIRECTORY SYSTEM) NAME :TYPE COMMON-LISP:TYPE)) (COMMON-LISP:DEFMETHOD COMPONENT-PATHNAME ((SYSTEM SYSTEM)) (COMMON-LISP:LET ((COMMON-LISP:PATHNAME (COMMON-LISP:OR (COMMON-LISP:CALL-NEXT-METHOD) (SYSTEM-SOURCE-DIRECTORY SYSTEM)))) (COMMON-LISP:UNLESS (COMMON-LISP:AND (COMMON-LISP:SLOT-BOUNDP SYSTEM (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) (COMMON-LISP:SLOT-VALUE SYSTEM (COMMON-LISP:QUOTE RELATIVE-PATHNAME))) (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE SYSTEM (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) COMMON-LISP:PATHNAME)) COMMON-LISP:PATHNAME)) (COMMON-LISP:DEFMETHOD COMPONENT-RELATIVE-PATHNAME ((SYSTEM SYSTEM)) (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING (COMMON-LISP:AND (COMMON-LISP:SLOT-BOUNDP SYSTEM (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) (COMMON-LISP:SLOT-VALUE SYSTEM (COMMON-LISP:QUOTE RELATIVE-PATHNAME))) :WANT-RELATIVE COMMON-LISP:T :TYPE :DIRECTORY :ENSURE-ABSOLUTE COMMON-LISP:T :DEFAULTS (SYSTEM-SOURCE-DIRECTORY SYSTEM))) (COMMON-LISP:DEFMETHOD COMPONENT-PARENT-PATHNAME ((SYSTEM SYSTEM)) (SYSTEM-SOURCE-DIRECTORY SYSTEM)) (COMMON-LISP:DEFMETHOD COMPONENT-BUILD-PATHNAME ((C COMPONENT)) COMMON-LISP:NIL))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/CACHE (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE) (:EXPORT #:GET-FILE-STAMP #:COMPUTE-FILE-STAMP #:REGISTER-FILE-STAMP #:SET-ASDF-CACHE-ENTRY #:UNSET-ASDF-CACHE-ENTRY #:CONSULT-ASDF-CACHE #:DO-ASDF-CACHE #:NORMALIZE-NAMESTRING #:CALL-WITH-ASDF-CACHE #:WITH-ASDF-CACHE #:*ASDF-CACHE* #:CLEAR-CONFIGURATION-AND-RETRY #:RETRY))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/CACHE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *ASDF-CACHE* COMMON-LISP:NIL) (COMMON-LISP:DEFUN SET-ASDF-CACHE-ENTRY (KEY VALUE-LIST) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:VALUES) (COMMON-LISP:IF *ASDF-CACHE* (COMMON-LISP:SETF (COMMON-LISP:GETHASH KEY *ASDF-CACHE*) VALUE-LIST) VALUE-LIST))) (COMMON-LISP:DEFUN UNSET-ASDF-CACHE-ENTRY (KEY) (COMMON-LISP:WHEN *ASDF-CACHE* (COMMON-LISP:REMHASH KEY *ASDF-CACHE*))) (COMMON-LISP:DEFUN CONSULT-ASDF-CACHE (KEY COMMON-LISP:&OPTIONAL THUNK) (COMMON-LISP:IF *ASDF-CACHE* (COMMON-LISP:MULTIPLE-VALUE-BIND (RESULTS FOUNDP) (COMMON-LISP:GETHASH KEY *ASDF-CACHE*) (COMMON-LISP:IF FOUNDP (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:VALUES) RESULTS) (SET-ASDF-CACHE-ENTRY KEY (COMMON-LISP:MULTIPLE-VALUE-LIST (UIOP/UTILITY:CALL-FUNCTION THUNK))))) (UIOP/UTILITY:CALL-FUNCTION THUNK))) (COMMON-LISP:DEFMACRO DO-ASDF-CACHE (KEY COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CONSULT-ASDF-CACHE) KEY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))) (COMMON-LISP:DEFUN CALL-WITH-ASDF-CACHE (THUNK COMMON-LISP:&KEY OVERRIDE KEY) (COMMON-LISP:LET ((FUN (COMMON-LISP:IF KEY (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (CONSULT-ASDF-CACHE KEY THUNK))) THUNK))) (COMMON-LISP:IF (COMMON-LISP:AND *ASDF-CACHE* (COMMON-LISP:NOT OVERRIDE)) (COMMON-LISP:FUNCALL FUN) (COMMON-LISP:LOOP (COMMON-LISP:RESTART-CASE (COMMON-LISP:LET ((*ASDF-CACHE* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (COMMON-LISP:RETURN (COMMON-LISP:FUNCALL FUN))) (RETRY COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Retry ASDF operation.~@:>")))) (CLEAR-CONFIGURATION-AND-RETRY COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Retry ASDF operation after resetting the configuration.~@:>"))) (UIOP/CONFIGURATION:CLEAR-CONFIGURATION))))))) (COMMON-LISP:DEFMACRO WITH-ASDF-CACHE ((COMMON-LISP:&KEY KEY OVERRIDE) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WITH-ASDF-CACHE) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)) (COMMON-LISP:QUOTE :OVERRIDE) OVERRIDE (COMMON-LISP:QUOTE :KEY) KEY)) (COMMON-LISP:DEFUN NORMALIZE-NAMESTRING (COMMON-LISP:PATHNAME) (COMMON-LISP:LET ((RESOLVED (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME (UIOP/PATHNAME:PHYSICALIZE-PATHNAME COMMON-LISP:PATHNAME) (COMMON-LISP:QUOTE UIOP/FILESYSTEM:GET-PATHNAME-DEFAULTS))))) (UIOP/PATHNAME:WITH-PATHNAME-DEFAULTS COMMON-LISP:NIL (COMMON-LISP:NAMESTRING RESOLVED)))) (COMMON-LISP:DEFUN COMPUTE-FILE-STAMP (NORMALIZED-NAMESTRING) (UIOP/PATHNAME:WITH-PATHNAME-DEFAULTS COMMON-LISP:NIL (UIOP/FILESYSTEM:SAFE-FILE-WRITE-DATE NORMALIZED-NAMESTRING))) (COMMON-LISP:DEFUN REGISTER-FILE-STAMP (FILE COMMON-LISP:&OPTIONAL (STAMP COMMON-LISP:NIL STAMPP)) (COMMON-LISP:LET* ((COMMON-LISP:NAMESTRING (NORMALIZE-NAMESTRING FILE)) (STAMP (COMMON-LISP:IF STAMPP STAMP (COMPUTE-FILE-STAMP COMMON-LISP:NAMESTRING)))) (SET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE GET-FILE-STAMP) COMMON-LISP:NAMESTRING) (COMMON-LISP:LIST STAMP)))) (COMMON-LISP:DEFUN GET-FILE-STAMP (FILE) (COMMON-LISP:WHEN FILE (COMMON-LISP:LET ((COMMON-LISP:NAMESTRING (NORMALIZE-NAMESTRING FILE))) (DO-ASDF-CACHE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE GET-FILE-STAMP) COMMON-LISP:NAMESTRING) (COMPUTE-FILE-STAMP COMMON-LISP:NAMESTRING))))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/FIND-SYSTEM (:RECYCLE :ASDF/FIND-SYSTEM :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM) (:EXPORT #:REMOVE-ENTRY-FROM-REGISTRY #:COERCE-ENTRY-TO-DIRECTORY #:COERCE-NAME #:PRIMARY-SYSTEM-NAME #:COERCE-FILENAME #:FIND-SYSTEM #:LOCATE-SYSTEM #:LOAD-ASD #:SYSTEM-REGISTERED-P #:REGISTER-SYSTEM #:REGISTERED-SYSTEMS #:CLEAR-SYSTEM #:MAP-SYSTEMS #:MISSING-COMPONENT #:MISSING-REQUIRES #:MISSING-PARENT #:FORMATTED-SYSTEM-DEFINITION-ERROR #:FORMAT-CONTROL #:FORMAT-ARGUMENTS #:SYSDEF-ERROR #:LOAD-SYSTEM-DEFINITION-ERROR #:ERROR-NAME #:ERROR-PATHNAME #:ERROR-CONDITION #:*SYSTEM-DEFINITION-SEARCH-FUNCTIONS* #:SEARCH-FOR-SYSTEM-DEFINITION #:*CENTRAL-REGISTRY* #:PROBE-ASD #:SYSDEF-CENTRAL-REGISTRY-SEARCH #:FIND-SYSTEM-IF-BEING-DEFINED #:CONTRIB-SYSDEF-SEARCH #:SYSDEF-FIND-ASDF #:SYSDEF-PRELOADED-SYSTEM-SEARCH #:REGISTER-PRELOADED-SYSTEM #:*PRELOADED-SYSTEMS* #:SYSDEF-IMMUTABLE-SYSTEM-SEARCH #:REGISTER-IMMUTABLE-SYSTEM #:*IMMUTABLE-SYSTEMS* #:*DEFINED-SYSTEMS* #:CLEAR-DEFINED-SYSTEMS #:INITIALIZE-SOURCE-REGISTRY #:SYSDEF-SOURCE-REGISTRY-SEARCH))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/FIND-SYSTEM)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DECLAIM (COMMON-LISP:FTYPE (COMMON-LISP:FUNCTION (COMMON-LISP:&OPTIONAL COMMON-LISP:T) COMMON-LISP:T) INITIALIZE-SOURCE-REGISTRY)) (COMMON-LISP:DEFINE-CONDITION MISSING-COMPONENT (SYSTEM-DEFINITION-ERROR) ((REQUIRES :INITFORM "(unnamed)" :READER MISSING-REQUIRES :INITARG :REQUIRES) (PARENT :INITFORM COMMON-LISP:NIL :READER MISSING-PARENT :INITARG :PARENT))) (COMMON-LISP:DEFINE-CONDITION FORMATTED-SYSTEM-DEFINITION-ERROR (SYSTEM-DEFINITION-ERROR) ((FORMAT-CONTROL :INITARG :FORMAT-CONTROL :READER FORMAT-CONTROL) (FORMAT-ARGUMENTS :INITARG :FORMAT-ARGUMENTS :READER FORMAT-ARGUMENTS)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:FORMAT) S (FORMAT-CONTROL C) (FORMAT-ARGUMENTS C))))) (COMMON-LISP:DEFINE-CONDITION LOAD-SYSTEM-DEFINITION-ERROR (SYSTEM-DEFINITION-ERROR) ((NAME :INITARG :NAME :READER ERROR-NAME) (COMMON-LISP:PATHNAME :INITARG :PATHNAME :READER ERROR-PATHNAME) (COMMON-LISP:CONDITION :INITARG :CONDITION :READER ERROR-CONDITION)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Error while trying to load definition for system ~A from pathname ~A: ~3i~_~A~@:>") (ERROR-NAME C) (ERROR-PATHNAME C) (ERROR-CONDITION C))))) (COMMON-LISP:DEFUN SYSDEF-ERROR (COMMON-LISP:FORMAT COMMON-LISP:&REST ARGUMENTS) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE FORMATTED-SYSTEM-DEFINITION-ERROR) :FORMAT-CONTROL COMMON-LISP:FORMAT :FORMAT-ARGUMENTS ARGUMENTS)) (COMMON-LISP:DEFUN COERCE-NAME (NAME) (COMMON-LISP:TYPECASE NAME (COMPONENT (COMPONENT-NAME NAME)) (COMMON-LISP:SYMBOL (COMMON-LISP:STRING-DOWNCASE (COMMON-LISP:SYMBOL-NAME NAME))) (COMMON-LISP:STRING NAME) (COMMON-LISP:T (SYSDEF-ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid component designator: ~3i~_~A~@:>") NAME)))) (COMMON-LISP:DEFUN PRIMARY-SYSTEM-NAME (NAME) (COMMON-LISP:FIRST (UIOP/UTILITY:SPLIT-STRING (COERCE-NAME NAME) :SEPARATOR "/"))) (COMMON-LISP:DEFUN COERCE-FILENAME (NAME) (UIOP/COMMON-LISP::FROB-SUBSTRINGS (COERCE-NAME NAME) (COMMON-LISP:QUOTE ("/" ":" "\\")) "--")) (COMMON-LISP:DEFVAR *DEFINED-SYSTEMS* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) "This is a hash table whose keys are strings, being the
     [java] names of the systems, and whose values are pairs, the first
     [java] element of which is a universal-time indicating when the
     [java] system definition was last updated, and the second element
     [java] of which is a system object.") (COMMON-LISP:DEFUN SYSTEM-REGISTERED-P (NAME) (COMMON-LISP:GETHASH (COERCE-NAME NAME) *DEFINED-SYSTEMS*)) (COMMON-LISP:DEFUN REGISTERED-SYSTEMS COMMON-LISP:NIL (COMMON-LISP:LOOP :FOR REGISTERED :BEING :THE :HASH-VALUES :OF *DEFINED-SYSTEMS* :COLLECT (COERCE-NAME (COMMON-LISP:CDR REGISTERED)))) (COMMON-LISP:DEFUN REGISTER-SYSTEM (SYSTEM) (COMMON-LISP:CHECK-TYPE SYSTEM SYSTEM) (COMMON-LISP:LET ((NAME (COMPONENT-NAME SYSTEM))) (COMMON-LISP:CHECK-TYPE NAME COMMON-LISP:STRING) (ASDF-MESSAGE (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;Registering ~3i~_~A~@:>~%") SYSTEM) (COMMON-LISP:UNLESS (COMMON-LISP:EQ SYSTEM (COMMON-LISP:CDR (COMMON-LISP:GETHASH NAME *DEFINED-SYSTEMS*))) (COMMON-LISP:SETF (COMMON-LISP:GETHASH NAME *DEFINED-SYSTEMS*) (COMMON-LISP:CONS (UIOP/UTILITY:IF-LET (FILE (COMMON-LISP:IGNORE-ERRORS (SYSTEM-SOURCE-FILE SYSTEM))) (GET-FILE-STAMP FILE)) SYSTEM))))) (COMMON-LISP:DEFVAR *PRELOADED-SYSTEMS* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMMON-LISP:DEFUN MAKE-PRELOADED-SYSTEM (NAME KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-INSTANCE) (COMMON-LISP:GETF KEYS :CLASS (COMMON-LISP:QUOTE SYSTEM)) :NAME NAME :SOURCE-FILE (COMMON-LISP:GETF KEYS :SOURCE-FILE) (UIOP/UTILITY:REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:CLASS :NAME :SOURCE-FILE)) KEYS))) (COMMON-LISP:DEFUN SYSDEF-PRELOADED-SYSTEM-SEARCH (REQUESTED) (COMMON-LISP:LET ((NAME (COERCE-NAME REQUESTED))) (COMMON-LISP:MULTIPLE-VALUE-BIND (KEYS FOUNDP) (COMMON-LISP:GETHASH NAME *PRELOADED-SYSTEMS*) (COMMON-LISP:WHEN FOUNDP (MAKE-PRELOADED-SYSTEM NAME KEYS))))) (COMMON-LISP:DEFUN REGISTER-PRELOADED-SYSTEM (SYSTEM-NAME COMMON-LISP:&REST KEYS) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (COERCE-NAME SYSTEM-NAME) *PRELOADED-SYSTEMS*) KEYS)) (COMMON-LISP:DOLIST (S (COMMON-LISP:QUOTE ("asdf" "uiop" "asdf-driver" "asdf-defsystem" "asdf-package-system"))) (REGISTER-PRELOADED-SYSTEM S :VERSION *ASDF-VERSION*)) (COMMON-LISP:DEFVAR *IMMUTABLE-SYSTEMS* COMMON-LISP:NIL "An hash-set (equal hash-table mapping keys to T) of systems that are immutable,
     [java] i.e. already loaded in memory and not to be refreshed from the filesystem.
     [java] They will be treated specially by find-system, and passed as :force-not argument to make-plan.
     [java]
     [java] If you deliver an image with many systems precompiled, *and* do not want to check the filesystem
     [java] for them every time a user loads an extension, what more risk a problematic upgrade or catastrophic
     [java] downgrade, before you dump an image, use:
     [java]    (setf asdf::*immutable-systems* (uiop:list-to-hash-set (asdf:already-loaded-systems)))") (COMMON-LISP:DEFUN SYSDEF-IMMUTABLE-SYSTEM-SEARCH (REQUESTED) (COMMON-LISP:LET ((NAME (COERCE-NAME REQUESTED))) (COMMON-LISP:WHEN (COMMON-LISP:AND *IMMUTABLE-SYSTEMS* (COMMON-LISP:GETHASH NAME *IMMUTABLE-SYSTEMS*)) (COMMON-LISP:OR (COMMON-LISP:CDR (SYSTEM-REGISTERED-P REQUESTED)) (SYSDEF-PRELOADED-SYSTEM-SEARCH NAME) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE FORMATTED-SYSTEM-DEFINITION-ERROR) :FORMAT-CONTROL "Requested system ~A is in the *immutable-systems* set, ~
     [java] but not loaded in memory" :FORMAT-ARGUMENTS (COMMON-LISP:LIST NAME)))))) (COMMON-LISP:DEFUN REGISTER-IMMUTABLE-SYSTEM (SYSTEM-NAME COMMON-LISP:&KEY (VERSION COMMON-LISP:T)) (COMMON-LISP:LET* ((SYSTEM-NAME (COERCE-NAME SYSTEM-NAME)) (REGISTERED-SYSTEM (COMMON-LISP:CDR (SYSTEM-REGISTERED-P SYSTEM-NAME))) (DEFAULT-VERSION? (COMMON-LISP:EQL VERSION COMMON-LISP:T)) (VERSION (COMMON-LISP:COND ((COMMON-LISP:AND DEFAULT-VERSION? REGISTERED-SYSTEM) (COMPONENT-VERSION REGISTERED-SYSTEM)) (DEFAULT-VERSION? COMMON-LISP:NIL) (COMMON-LISP:T VERSION)))) (COMMON-LISP:UNLESS REGISTERED-SYSTEM (REGISTER-SYSTEM (MAKE-PRELOADED-SYSTEM SYSTEM-NAME (COMMON-LISP:LIST :VERSION VERSION)))) (REGISTER-PRELOADED-SYSTEM SYSTEM-NAME :VERSION VERSION) (COMMON-LISP:UNLESS *IMMUTABLE-SYSTEMS* (COMMON-LISP:SETF *IMMUTABLE-SYSTEMS* (UIOP/UTILITY:LIST-TO-HASH-SET COMMON-LISP:NIL))) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (COERCE-NAME SYSTEM-NAME) *IMMUTABLE-SYSTEMS*) COMMON-LISP:T))) (COMMON-LISP:DEFUN CLEAR-SYSTEM (SYSTEM) "Clear the entry for a SYSTEM in the database of systems previously loaded,
     [java] unless the system appears in the table of *IMMUTABLE-SYSTEMS*.
     [java] Note that this does NOT in any way cause the code of the system to be unloaded.
     [java] Returns T if cleared or already cleared,
     [java] NIL if not cleared because the system was found to be immutable." (COMMON-LISP:LET ((NAME (COERCE-NAME SYSTEM))) (COMMON-LISP:UNLESS (COMMON-LISP:AND *IMMUTABLE-SYSTEMS* (COMMON-LISP:GETHASH NAME *IMMUTABLE-SYSTEMS*)) (COMMON-LISP:REMHASH (COERCE-NAME NAME) *DEFINED-SYSTEMS*) (UNSET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE LOCATE-SYSTEM) NAME)) (UNSET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-SYSTEM) NAME)) COMMON-LISP:T))) (COMMON-LISP:DEFUN CLEAR-DEFINED-SYSTEMS COMMON-LISP:NIL (COMMON-LISP:LOOP :FOR NAME :BEING :THE :HASH-KEYS :OF *DEFINED-SYSTEMS* :UNLESS (COMMON-LISP:EQUAL NAME "asdf") :DO (CLEAR-SYSTEM NAME))) (UIOP/UTILITY:REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *POST-UPGRADE-CLEANUP-HOOK*) (COMMON-LISP:QUOTE CLEAR-DEFINED-SYSTEMS) COMMON-LISP:NIL) (COMMON-LISP:DEFUN MAP-SYSTEMS (FN) "Apply FN to each defined system.
     [java]
     [java] FN should be a function of one argument. It will be
     [java] called with an object of type asdf:system." (COMMON-LISP:LOOP :FOR REGISTERED :BEING :THE :HASH-VALUES :OF *DEFINED-SYSTEMS* :DO (COMMON-LISP:FUNCALL FN (COMMON-LISP:CDR REGISTERED)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *SYSTEM-DEFINITION-SEARCH-FUNCTIONS* (COMMON-LISP:QUOTE COMMON-LISP:NIL)) (COMMON-LISP:DEFUN CLEANUP-SYSTEM-DEFINITION-SEARCH-FUNCTIONS COMMON-LISP:NIL (COMMON-LISP:SETF *SYSTEM-DEFINITION-SEARCH-FUNCTIONS* (COMMON-LISP:APPEND (COMMON-LISP:REMOVE-IF (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:MEMBER X (COMMON-LISP:QUOTE (CONTRIB-SYSDEF-SEARCH SYSDEF-FIND-ASDF SYSDEF-PRELOADED-SYSTEM-SEARCH))))) *SYSTEM-DEFINITION-SEARCH-FUNCTIONS*) (COMMON-LISP:REMOVE-IF (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:MEMBER X *SYSTEM-DEFINITION-SEARCH-FUNCTIONS*))) (COMMON-LISP:QUOTE (SYSDEF-CENTRAL-REGISTRY-SEARCH SYSDEF-SOURCE-REGISTRY-SEARCH)))))) (CLEANUP-SYSTEM-DEFINITION-SEARCH-FUNCTIONS) (COMMON-LISP:DEFUN SEARCH-FOR-SYSTEM-DEFINITION (SYSTEM) (COMMON-LISP:LET ((NAME (COERCE-NAME SYSTEM))) (COMMON-LISP:FLET ((TRY (F) (UIOP/UTILITY:IF-LET ((X (COMMON-LISP:FUNCALL F NAME))) (COMMON-LISP:RETURN-FROM SEARCH-FOR-SYSTEM-DEFINITION X)))) (TRY (COMMON-LISP:QUOTE FIND-SYSTEM-IF-BEING-DEFINED)) (TRY (COMMON-LISP:QUOTE SYSDEF-IMMUTABLE-SYSTEM-SEARCH)) (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:FUNCTION TRY) *SYSTEM-DEFINITION-SEARCH-FUNCTIONS*) (TRY (COMMON-LISP:QUOTE SYSDEF-PRELOADED-SYSTEM-SEARCH))))) (COMMON-LISP:DEFVAR *CENTRAL-REGISTRY* COMMON-LISP:NIL "A list of 'system directory designators' ASDF uses to find systems.
     [java]
     [java] A 'system directory designator' is a pathname or an expression
     [java] which evaluates to a pathname. For example:
     [java]
     [java]     (setf asdf:*central-registry*
     [java]           (list '*default-pathname-defaults*
     [java]                 #p\"/home/me/cl/systems/\"
     [java]                 #p\"/usr/share/common-lisp/systems/\"))
     [java]
     [java] This is for backward compatibility.
     [java] Going forward, we recommend new users should be using the source-registry.
     [java] ") (COMMON-LISP:DEFUN PROBE-ASD (NAME DEFAULTS COMMON-LISP:&KEY COMMON-LISP:TRUENAME) (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:WHEN (UIOP/PATHNAME:DIRECTORY-PATHNAME-P DEFAULTS) (UIOP/UTILITY:IF-LET (FILE (UIOP/FILESYSTEM:PROBE-FILE* (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING NAME :TYPE "asd") (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME DEFAULTS (COMMON-LISP:QUOTE UIOP/FILESYSTEM:GET-PATHNAME-DEFAULTS) COMMON-LISP:NIL))) COMMON-LISP:NIL) :TRUENAME COMMON-LISP:TRUENAME)) (COMMON-LISP:RETURN FILE)) (UIOP/OS:OS-COND ((UIOP/OS:OS-WINDOWS-P) (COMMON-LISP:WHEN (UIOP/PATHNAME:PHYSICAL-PATHNAME-P DEFAULTS) (COMMON-LISP:LET ((SHORTCUT (COMMON-LISP:MAKE-PATHNAME :DEFAULTS DEFAULTS :CASE :LOCAL :NAME (UIOP/UTILITY:STRCAT NAME ".asd") :TYPE "lnk"))) (COMMON-LISP:WHEN (UIOP/FILESYSTEM:PROBE-FILE* SHORTCUT) (UIOP/PATHNAME:ENSURE-PATHNAME (UIOP/OS:PARSE-WINDOWS-SHORTCUT SHORTCUT) :NAMESTRING :NATIVE))))))))) (COMMON-LISP:DEFUN SYSDEF-CENTRAL-REGISTRY-SEARCH (SYSTEM) (COMMON-LISP:LET ((NAME (PRIMARY-SYSTEM-NAME SYSTEM)) (TO-REMOVE COMMON-LISP:NIL) (TO-REPLACE COMMON-LISP:NIL)) (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:DOLIST (DIR *CENTRAL-REGISTRY*) (COMMON-LISP:LET ((DEFAULTS (COMMON-LISP:EVAL DIR)) DIRECTORIZED) (COMMON-LISP:WHEN DEFAULTS (COMMON-LISP:COND ((UIOP/PATHNAME:DIRECTORY-PATHNAME-P DEFAULTS) (COMMON-LISP:LET* ((FILE (PROBE-ASD NAME DEFAULTS :TRUENAME UIOP/FILESYSTEM:*RESOLVE-SYMLINKS*))) (COMMON-LISP:WHEN FILE (COMMON-LISP:RETURN FILE)))) (COMMON-LISP:T (COMMON-LISP:RESTART-CASE (COMMON-LISP:LET* ((COMMON-LISP:*PRINT-CIRCLE* COMMON-LISP:NIL) (MESSAGE (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<While searching for system ~S: ~3i~_~S evaluated to ~S which is not an absolute directory.~@:>") SYSTEM DIR DEFAULTS))) (COMMON-LISP:ERROR MESSAGE)) (REMOVE-ENTRY-FROM-REGISTRY COMMON-LISP:NIL :REPORT "Remove entry from *central-registry* and continue" (COMMON-LISP:PUSH DIR TO-REMOVE)) (COERCE-ENTRY-TO-DIRECTORY COMMON-LISP:NIL :TEST (COMMON-LISP:LAMBDA (C) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE C)) (COMMON-LISP:AND (COMMON-LISP:NOT (UIOP/PATHNAME:DIRECTORY-PATHNAME-P DEFAULTS)) (UIOP/PATHNAME:DIRECTORY-PATHNAME-P (COMMON-LISP:SETF DIRECTORIZED (UIOP/PATHNAME:ENSURE-DIRECTORY-PATHNAME DEFAULTS))))) :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Coerce entry to ~a, replace ~a and continue.~@:>") DIRECTORIZED DIR)) (COMMON-LISP:PUSH (COMMON-LISP:CONS DIR DIRECTORIZED) TO-REPLACE)))))))) (COMMON-LISP:DOLIST (DIR TO-REMOVE) (COMMON-LISP:SETF *CENTRAL-REGISTRY* (COMMON-LISP:REMOVE DIR *CENTRAL-REGISTRY*))) (COMMON-LISP:DOLIST (PAIR TO-REPLACE) (COMMON-LISP:LET* ((CURRENT (COMMON-LISP:CAR PAIR)) (NEW (COMMON-LISP:CDR PAIR)) (COMMON-LISP:POSITION (COMMON-LISP:POSITION CURRENT *CENTRAL-REGISTRY*))) (COMMON-LISP:SETF *CENTRAL-REGISTRY* (COMMON-LISP:APPEND (COMMON-LISP:SUBSEQ *CENTRAL-REGISTRY* 0 COMMON-LISP:POSITION) (COMMON-LISP:LIST NEW) (COMMON-LISP:SUBSEQ *CENTRAL-REGISTRY* (COMMON-LISP:1+ COMMON-LISP:POSITION)))))))))) (COMMON-LISP:DEFMETHOD FIND-SYSTEM ((NAME COMMON-LISP:NULL) COMMON-LISP:&OPTIONAL (ERROR-P COMMON-LISP:T)) (COMMON-LISP:WHEN ERROR-P (SYSDEF-ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<NIL is not a valid system name~@:>")))) (COMMON-LISP:DEFMETHOD FIND-SYSTEM (NAME COMMON-LISP:&OPTIONAL (ERROR-P COMMON-LISP:T)) (FIND-SYSTEM (COERCE-NAME NAME) ERROR-P)) (COMMON-LISP:DEFUN FIND-SYSTEM-IF-BEING-DEFINED (NAME) (COMMON-LISP:FIRST (COMMON-LISP:GETHASH (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-SYSTEM) (COERCE-NAME NAME)) *ASDF-CACHE*))) (COMMON-LISP:DEFUN LOAD-ASD (COMMON-LISP:PATHNAME COMMON-LISP:&KEY NAME (EXTERNAL-FORMAT (UIOP/STREAM:ENCODING-EXTERNAL-FORMAT (UIOP/STREAM:DETECT-ENCODING COMMON-LISP:PATHNAME))) COMMON-LISP:&AUX (COMMON-LISP:READTABLE COMMON-LISP:*READTABLE*) (PRINT-PPRINT-DISPATCH COMMON-LISP:*PRINT-PPRINT-DISPATCH*)) (WITH-ASDF-CACHE COMMON-LISP:NIL (COMMON-LISP:WITH-STANDARD-IO-SYNTAX (COMMON-LISP:LET ((COMMON-LISP:*PACKAGE* (COMMON-LISP:FIND-PACKAGE :ASDF-USER)) (COMMON-LISP:*READTABLE* COMMON-LISP:READTABLE) (COMMON-LISP:*PRINT-PPRINT-DISPATCH* PRINT-PPRINT-DISPATCH) (COMMON-LISP:*PRINT-READABLY* COMMON-LISP:NIL) (COMMON-LISP:*DEFAULT-PATHNAME-DEFAULTS* (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (UIOP/PATHNAME:PHYSICALIZE-PATHNAME COMMON-LISP:PATHNAME)))) (COMMON-LISP:HANDLER-BIND ((COMMON-LISP:ERROR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (COMMON-LISP:CONDITION) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE LOAD-SYSTEM-DEFINITION-ERROR) :NAME NAME :PATHNAME COMMON-LISP:PATHNAME :CONDITION COMMON-LISP:CONDITION))))) (ASDF-MESSAGE (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;Loading system definition~@[ for ~A~] from ~A~@:>~%") NAME COMMON-LISP:PATHNAME) (UIOP/LISP-BUILD:LOAD* COMMON-LISP:PATHNAME :EXTERNAL-FORMAT EXTERNAL-FORMAT)))))) (COMMON-LISP:DEFVAR *OLD-ASDF-SYSTEMS* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMMON-LISP:DEFUN CHECK-NOT-OLD-ASDF-SYSTEM (NAME COMMON-LISP:PATHNAME) (COMMON-LISP:OR (COMMON-LISP:NOT (COMMON-LISP:EQUAL NAME "asdf")) (COMMON-LISP:NULL COMMON-LISP:PATHNAME) (COMMON-LISP:LET* ((VERSION-PATHNAME (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:PATHNAME "version.lisp-expr")) (VERSION (COMMON-LISP:AND (UIOP/FILESYSTEM:PROBE-FILE* VERSION-PATHNAME :TRUENAME COMMON-LISP:NIL) (UIOP/STREAM:READ-FILE-FORM VERSION-PATHNAME))) (OLD-VERSION (ASDF-VERSION))) (COMMON-LISP:COND ((UIOP/UTILITY:VERSION< OLD-VERSION VERSION) COMMON-LISP:T) ((COMMON-LISP:EQUAL OLD-VERSION VERSION) COMMON-LISP:NIL) (COMMON-LISP:T (UIOP/UTILITY:ENSURE-GETHASH (COMMON-LISP:LIST (COMMON-LISP:NAMESTRING COMMON-LISP:PATHNAME) VERSION) *OLD-ASDF-SYSTEMS* (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (COMMON-LISP:LET ((OLD-PATHNAME (UIOP/UTILITY:IF-LET (PAIR (SYSTEM-REGISTERED-P "asdf")) (SYSTEM-SOURCE-FILE (COMMON-LISP:CDR PAIR))))) (COMMON-LISP:WARN "~@<~
     [java]         You are using ASDF version ~A ~:[(probably from (require \"asdf\") ~
     [java]         or loaded by quicklisp)~;from ~:*~S~] and have an older version of ASDF ~
     [java]         ~:[(and older than 2.27 at that)~;~:*~A~] registered at ~S. ~
     [java]         Having an ASDF installed and registered is the normal way of configuring ASDF to upgrade itself, ~
     [java]         and having an old version registered is a configuration error. ~
     [java]         ASDF will ignore this configured system rather than downgrade itself. ~
     [java]         In the future, you may want to either: ~
     [java]         (a) upgrade this configured ASDF to a newer version, ~
     [java]         (b) install a newer ASDF and register it in front of the former in your configuration, or ~
     [java]         (c) uninstall or unregister this and any other old version of ASDF from your configuration. ~
     [java]         Note that the older ASDF might be registered implicitly through configuration inherited ~
     [java]         from your system installation, in which case you might have to specify ~
     [java]         :ignore-inherited-configuration in your in your ~~/.config/common-lisp/source-registry.conf ~
     [java]         or other source-registry configuration file, environment variable or lisp parameter. ~
     [java]         Indeed, a likely offender is an obsolete version of the cl-asdf debian or ubuntu package, ~
     [java]         that you might want to upgrade (if a recent enough version is available) ~
     [java]         or else remove altogether (since most implementations ship with a recent asdf); ~
     [java]         if you lack the system administration rights to upgrade or remove this package, ~
     [java]         then you might indeed want to either install and register a more recent version, ~
     [java]         or use :ignore-inherited-configuration to avoid registering the old one. ~
     [java]         Please consult ASDF documentation and/or experts.~@:>~%" OLD-VERSION OLD-PATHNAME VERSION COMMON-LISP:PATHNAME))))) COMMON-LISP:NIL))))) (COMMON-LISP:DEFUN LOCATE-SYSTEM (NAME) "Given a system NAME designator, try to locate where to load the system from.
     [java] Returns five values: FOUNDP FOUND-SYSTEM PATHNAME PREVIOUS PREVIOUS-TIME
     [java] FOUNDP is true when a system was found,
     [java] either a new unregistered one or a previously registered one.
     [java] FOUND-SYSTEM when not null is a SYSTEM object that may be REGISTER-SYSTEM'ed.
     [java] PATHNAME when not null is a path from which to load the system,
     [java] either associated with FOUND-SYSTEM, or with the PREVIOUS system.
     [java] PREVIOUS when not null is a previously loaded SYSTEM object of same name.
     [java] PREVIOUS-TIME when not null is the time at which the PREVIOUS system was loaded." (COMMON-LISP:LET* ((NAME (COERCE-NAME NAME)) (IN-MEMORY (SYSTEM-REGISTERED-P NAME)) (PREVIOUS (COMMON-LISP:CDR IN-MEMORY)) (PREVIOUS (COMMON-LISP:AND (COMMON-LISP:TYPEP PREVIOUS (COMMON-LISP:QUOTE SYSTEM)) PREVIOUS)) (PREVIOUS-TIME (COMMON-LISP:CAR IN-MEMORY)) (FOUND (SEARCH-FOR-SYSTEM-DEFINITION NAME)) (FOUND-SYSTEM (COMMON-LISP:AND (COMMON-LISP:TYPEP FOUND (COMMON-LISP:QUOTE SYSTEM)) FOUND)) (COMMON-LISP:PATHNAME (UIOP/PATHNAME:ENSURE-PATHNAME (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:TYPEP FOUND (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:PATHNAME COMMON-LISP:STRING))) (COMMON-LISP:PATHNAME FOUND)) (COMMON-LISP:AND FOUND-SYSTEM (SYSTEM-SOURCE-FILE FOUND-SYSTEM)) (COMMON-LISP:AND PREVIOUS (SYSTEM-SOURCE-FILE PREVIOUS))) :WANT-ABSOLUTE COMMON-LISP:T :RESOLVE-SYMLINKS UIOP/FILESYSTEM:*RESOLVE-SYMLINKS*)) (FOUNDP (COMMON-LISP:AND (COMMON-LISP:OR FOUND-SYSTEM COMMON-LISP:PATHNAME PREVIOUS) COMMON-LISP:T))) (COMMON-LISP:CHECK-TYPE FOUND (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:PATHNAME SYSTEM)) (COMMON-LISP:UNLESS (CHECK-NOT-OLD-ASDF-SYSTEM NAME COMMON-LISP:PATHNAME) (COMMON-LISP:COND (PREVIOUS (COMMON-LISP:SETF FOUND COMMON-LISP:NIL COMMON-LISP:PATHNAME COMMON-LISP:NIL)) (COMMON-LISP:T (COMMON-LISP:SETF FOUND (SYSDEF-PRELOADED-SYSTEM-SEARCH "asdf")) (COMMON-LISP:ASSERT (COMMON-LISP:TYPEP FOUND (COMMON-LISP:QUOTE SYSTEM))) (COMMON-LISP:SETF FOUND-SYSTEM FOUND COMMON-LISP:PATHNAME COMMON-LISP:NIL)))) (COMMON-LISP:VALUES FOUNDP FOUND-SYSTEM COMMON-LISP:PATHNAME PREVIOUS PREVIOUS-TIME))) (COMMON-LISP:DEFMETHOD FIND-SYSTEM ((NAME COMMON-LISP:STRING) COMMON-LISP:&OPTIONAL (ERROR-P COMMON-LISP:T)) (WITH-ASDF-CACHE (:KEY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-SYSTEM) NAME)) (COMMON-LISP:LET ((PRIMARY-NAME (PRIMARY-SYSTEM-NAME NAME))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL NAME PRIMARY-NAME) (FIND-SYSTEM PRIMARY-NAME COMMON-LISP:NIL))) (COMMON-LISP:OR (COMMON-LISP:AND *IMMUTABLE-SYSTEMS* (COMMON-LISP:GETHASH NAME *IMMUTABLE-SYSTEMS*) (COMMON-LISP:OR (COMMON-LISP:CDR (SYSTEM-REGISTERED-P NAME)) (SYSDEF-PRELOADED-SYSTEM-SEARCH NAME))) (COMMON-LISP:MULTIPLE-VALUE-BIND (FOUNDP FOUND-SYSTEM COMMON-LISP:PATHNAME PREVIOUS PREVIOUS-TIME) (LOCATE-SYSTEM NAME) (COMMON-LISP:ASSERT (COMMON-LISP:EQ FOUNDP (COMMON-LISP:AND (COMMON-LISP:OR FOUND-SYSTEM COMMON-LISP:PATHNAME PREVIOUS) COMMON-LISP:T))) (COMMON-LISP:LET ((PREVIOUS-PATHNAME (COMMON-LISP:AND PREVIOUS (SYSTEM-SOURCE-FILE PREVIOUS))) (SYSTEM (COMMON-LISP:OR PREVIOUS FOUND-SYSTEM))) (COMMON-LISP:WHEN (COMMON-LISP:AND FOUND-SYSTEM (COMMON-LISP:NOT PREVIOUS)) (REGISTER-SYSTEM FOUND-SYSTEM)) (COMMON-LISP:WHEN (COMMON-LISP:AND SYSTEM COMMON-LISP:PATHNAME) (COMMON-LISP:SETF (SYSTEM-SOURCE-FILE SYSTEM) COMMON-LISP:PATHNAME)) (COMMON-LISP:WHEN (COMMON-LISP:AND COMMON-LISP:PATHNAME (COMMON-LISP:LET ((STAMP (GET-FILE-STAMP COMMON-LISP:PATHNAME))) (COMMON-LISP:AND STAMP (COMMON-LISP:NOT (COMMON-LISP:AND PREVIOUS (COMMON-LISP:OR (UIOP/PATHNAME:PATHNAME-EQUAL COMMON-LISP:PATHNAME PREVIOUS-PATHNAME) (COMMON-LISP:AND COMMON-LISP:PATHNAME PREVIOUS-PATHNAME (UIOP/PATHNAME:PATHNAME-EQUAL (UIOP/PATHNAME:PHYSICALIZE-PATHNAME COMMON-LISP:PATHNAME) (UIOP/PATHNAME:PHYSICALIZE-PATHNAME PREVIOUS-PATHNAME)))) (UIOP/UTILITY:STAMP<= STAMP PREVIOUS-TIME)))))) (LOAD-ASD COMMON-LISP:PATHNAME :NAME NAME))) (COMMON-LISP:LET ((IN-MEMORY (SYSTEM-REGISTERED-P NAME))) (COMMON-LISP:COND (IN-MEMORY (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:SETF (COMMON-LISP:CAR IN-MEMORY) (GET-FILE-STAMP COMMON-LISP:PATHNAME))) (COMMON-LISP:CDR IN-MEMORY)) (ERROR-P (COMMON-LISP:ERROR (COMMON-LISP:QUOTE MISSING-COMPONENT) :REQUIRES NAME)) (COMMON-LISP:T (UNSET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE LOCATE-SYSTEM) NAME)) (COMMON-LISP:RETURN-FROM FIND-SYSTEM COMMON-LISP:NIL)))))))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/FIND-COMPONENT (:RECYCLE :ASDF/FIND-COMPONENT :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM) (:EXPORT #:FIND-COMPONENT #:RESOLVE-DEPENDENCY-NAME #:RESOLVE-DEPENDENCY-SPEC #:RESOLVE-DEPENDENCY-COMBINATION #:MISSING-COMPONENT #:MISSING-COMPONENT-OF-VERSION #:RETRY #:MISSING-DEPENDENCY #:MISSING-DEPENDENCY-OF-VERSION #:MISSING-REQUIRES #:MISSING-PARENT #:MISSING-REQUIRED-BY #:MISSING-VERSION))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/FIND-COMPONENT)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION MISSING-COMPONENT-OF-VERSION (MISSING-COMPONENT) ((VERSION :INITFORM COMMON-LISP:NIL :READER MISSING-VERSION :INITARG :VERSION))) (COMMON-LISP:DEFINE-CONDITION MISSING-DEPENDENCY (MISSING-COMPONENT) ((REQUIRED-BY :INITARG :REQUIRED-BY :READER MISSING-REQUIRED-BY))) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((C MISSING-DEPENDENCY) S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<~A, required by ~A~@:>") (COMMON-LISP:CALL-NEXT-METHOD C COMMON-LISP:NIL) (MISSING-REQUIRED-BY C))) (COMMON-LISP:DEFINE-CONDITION MISSING-DEPENDENCY-OF-VERSION (MISSING-DEPENDENCY MISSING-COMPONENT-OF-VERSION) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((C MISSING-COMPONENT) S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Component ~S not found~@[ in ~A~]~@:>") (MISSING-REQUIRES C) (COMMON-LISP:WHEN (MISSING-PARENT C) (COERCE-NAME (MISSING-PARENT C))))) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((C MISSING-COMPONENT-OF-VERSION) S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Component ~S does not match version ~A~@[ in ~A~]~@:>") (MISSING-REQUIRES C) (MISSING-VERSION C) (COMMON-LISP:WHEN (MISSING-PARENT C) (COERCE-NAME (MISSING-PARENT C))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (FIND-COMPONENT) (BASE PATH) (:DOCUMENTATION "Find a component by resolving the PATH starting from BASE parent")) (COMMON-LISP:DEFGENERIC RESOLVE-DEPENDENCY-COMBINATION (COMPONENT COMBINATOR ARGUMENTS)) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((BASE COMMON-LISP:STRING) PATH) (COMMON-LISP:LET ((S (FIND-SYSTEM BASE COMMON-LISP:NIL))) (COMMON-LISP:AND S (FIND-COMPONENT S PATH)))) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((BASE COMMON-LISP:SYMBOL) PATH) (COMMON-LISP:COND (BASE (FIND-COMPONENT (COERCE-NAME BASE) PATH)) (PATH (FIND-COMPONENT PATH COMMON-LISP:NIL)) (COMMON-LISP:T COMMON-LISP:NIL))) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((BASE COMMON-LISP:CONS) PATH) (FIND-COMPONENT (COMMON-LISP:CAR BASE) (COMMON-LISP:CONS (COMMON-LISP:CDR BASE) PATH))) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((PARENT PARENT-COMPONENT) (NAME COMMON-LISP:STRING)) (COMPUTE-CHILDREN-BY-NAME PARENT :ONLY-IF-NEEDED-P COMMON-LISP:T) (COMMON-LISP:VALUES (COMMON-LISP:GETHASH NAME (COMPONENT-CHILDREN-BY-NAME PARENT)))) (COMMON-LISP:DEFMETHOD FIND-COMPONENT (BASE (NAME COMMON-LISP:SYMBOL)) (COMMON-LISP:IF NAME (FIND-COMPONENT BASE (COERCE-NAME NAME)) BASE)) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((C COMPONENT) (NAME COMMON-LISP:CONS)) (FIND-COMPONENT (FIND-COMPONENT C (COMMON-LISP:CAR NAME)) (COMMON-LISP:CDR NAME))) (COMMON-LISP:DEFMETHOD FIND-COMPONENT ((BASE COMMON-LISP:T) (ACTUAL COMPONENT)) ACTUAL) (COMMON-LISP:DEFUN RESOLVE-DEPENDENCY-NAME (COMPONENT NAME COMMON-LISP:&OPTIONAL VERSION) (COMMON-LISP:LOOP (COMMON-LISP:RESTART-CASE (COMMON-LISP:RETURN (COMMON-LISP:LET ((COMP (FIND-COMPONENT (COMPONENT-PARENT COMPONENT) NAME))) (COMMON-LISP:UNLESS COMP (COMMON-LISP:ERROR (COMMON-LISP:QUOTE MISSING-DEPENDENCY) :REQUIRED-BY COMPONENT :REQUIRES NAME)) (COMMON-LISP:WHEN VERSION (COMMON-LISP:UNLESS (VERSION-SATISFIES COMP VERSION) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE MISSING-DEPENDENCY-OF-VERSION) :REQUIRED-BY COMPONENT :VERSION VERSION :REQUIRES NAME))) COMP)) (RETRY COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Retry loading ~3i~_~A.~@:>") NAME)) :TEST (COMMON-LISP:LAMBDA (C) (COMMON-LISP:OR (COMMON-LISP:NULL C) (COMMON-LISP:AND (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE MISSING-DEPENDENCY)) (COMMON-LISP:EQ (MISSING-REQUIRED-BY C) COMPONENT) (COMMON-LISP:EQUAL (MISSING-REQUIRES C) NAME)))) (COMMON-LISP:UNLESS (COMPONENT-PARENT COMPONENT) (COMMON-LISP:LET ((NAME (COERCE-NAME NAME))) (UNSET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-SYSTEM) NAME)) (UNSET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE LOCATE-SYSTEM) NAME)))))))) (COMMON-LISP:DEFUN RESOLVE-DEPENDENCY-SPEC (COMPONENT DEP-SPEC) (COMMON-LISP:LET ((COMPONENT (FIND-COMPONENT COMMON-LISP:NIL COMPONENT))) (COMMON-LISP:IF (COMMON-LISP:ATOM DEP-SPEC) (RESOLVE-DEPENDENCY-NAME COMPONENT DEP-SPEC) (RESOLVE-DEPENDENCY-COMBINATION COMPONENT (COMMON-LISP:CAR DEP-SPEC) (COMMON-LISP:CDR DEP-SPEC))))) (COMMON-LISP:DEFMETHOD RESOLVE-DEPENDENCY-COMBINATION (COMPONENT COMBINATOR ARGUMENTS) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Bad dependency ~S for ~S~@:>") (COMMON-LISP:CONS COMBINATOR ARGUMENTS) COMPONENT)) (COMMON-LISP:DEFMETHOD RESOLVE-DEPENDENCY-COMBINATION (COMPONENT (COMBINATOR (COMMON-LISP:EQL :FEATURE)) ARGUMENTS) (COMMON-LISP:WHEN (UIOP/OS:FEATUREP (COMMON-LISP:FIRST ARGUMENTS)) (RESOLVE-DEPENDENCY-SPEC COMPONENT (COMMON-LISP:SECOND ARGUMENTS)))) (COMMON-LISP:DEFMETHOD RESOLVE-DEPENDENCY-COMBINATION (COMPONENT (COMBINATOR (COMMON-LISP:EQL :VERSION)) ARGUMENTS) (RESOLVE-DEPENDENCY-NAME COMPONENT (COMMON-LISP:FIRST ARGUMENTS) (COMMON-LISP:SECOND ARGUMENTS))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/OPERATION (:RECYCLE :ASDF/OPERATION :ASDF/ACTION :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/FIND-SYSTEM) (:EXPORT #:OPERATION #:OPERATION-ORIGINAL-INITARGS #:ORIGINAL-INITARGS #:*OPERATIONS* #:MAKE-OPERATION #:FIND-OPERATION #:FEATURE))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/OPERATION)
     [java] ; (WHEN-UPGRADING (:WHEN (COMMON-LISP:FIND-CLASS (COMMON-LISP:QUOTE OPERATION) COMMON-LISP:NIL)) (COMMON-LISP:DEFMETHOD COMMON-LISP:SHARED-INITIALIZE :AFTER ((O OPERATION) (SLOT-NAMES COMMON-LISP:T) COMMON-LISP:&KEY) (COMMON-LISP:VALUES)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS OPERATION COMMON-LISP:NIL ((ORIGINAL-INITARGS :INITFORM COMMON-LISP:NIL :INITARG :ORIGINAL-INITARGS :ACCESSOR OPERATION-ORIGINAL-INITARGS))) (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :AFTER ((O OPERATION) COMMON-LISP:&REST INITARGS COMMON-LISP:&KEY FORCE FORCE-NOT SYSTEM VERBOSE COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE FORCE-NOT SYSTEM VERBOSE)) (COMMON-LISP:UNLESS (COMMON-LISP:SLOT-BOUNDP O (COMMON-LISP:QUOTE ORIGINAL-INITARGS)) (COMMON-LISP:SETF (OPERATION-ORIGINAL-INITARGS O) INITARGS))) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((O OPERATION) COMMON-LISP:STREAM) (COMMON-LISP:PRINT-UNREADABLE-OBJECT (O COMMON-LISP:STREAM :TYPE COMMON-LISP:T :IDENTITY COMMON-LISP:NIL) (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:FORMAT COMMON-LISP:STREAM "~{~S~^ ~}" (OPERATION-ORIGINAL-INITARGS O))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (DEFPARAMETER* *OPERATIONS* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMMON-LISP:DEFUN MAKE-OPERATION (OPERATION-CLASS COMMON-LISP:&REST INITARGS) (COMMON-LISP:LET ((COMMON-LISP:CLASS (UIOP/UTILITY:COERCE-CLASS OPERATION-CLASS :PACKAGE :ASDF/INTERFACE :SUPER (COMMON-LISP:QUOTE OPERATION) :ERROR (COMMON-LISP:QUOTE SYSDEF-ERROR)))) (UIOP/UTILITY:ENSURE-GETHASH (COMMON-LISP:CONS COMMON-LISP:CLASS INITARGS) *OPERATIONS* (COMMON-LISP:LIST* (COMMON-LISP:QUOTE COMMON-LISP:MAKE-INSTANCE) COMMON-LISP:CLASS INITARGS)))) (COMMON-LISP:DEFGENERIC FIND-OPERATION (CONTEXT SPEC) (:DOCUMENTATION "Find an operation by resolving the SPEC in the CONTEXT")) (COMMON-LISP:DEFMETHOD FIND-OPERATION ((CONTEXT COMMON-LISP:T) (SPEC OPERATION)) SPEC) (COMMON-LISP:DEFMETHOD FIND-OPERATION (CONTEXT (SPEC COMMON-LISP:SYMBOL)) (COMMON-LISP:WHEN SPEC (COMMON-LISP:APPLY (COMMON-LISP:QUOTE MAKE-OPERATION) SPEC (OPERATION-ORIGINAL-INITARGS CONTEXT)))) (COMMON-LISP:DEFMETHOD FIND-OPERATION (CONTEXT (SPEC COMMON-LISP:STRING)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE MAKE-OPERATION) SPEC (OPERATION-ORIGINAL-INITARGS CONTEXT))) (COMMON-LISP:DEFMETHOD OPERATION-ORIGINAL-INITARGS ((CONTEXT COMMON-LISP:SYMBOL)) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORABLE CONTEXT)) COMMON-LISP:NIL))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/ACTION (:NICKNAMES :ASDF-ACTION) (:RECYCLE :ASDF/ACTION :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/SYSTEM #:ASDF/CACHE :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/OPERATION) (:EXPORT #:ACTION #:DEFINE-CONVENIENCE-ACTION-METHODS #:EXPLAIN #:ACTION-DESCRIPTION #:DOWNWARD-OPERATION #:UPWARD-OPERATION #:SIDEWAY-OPERATION #:SELFWARD-OPERATION #:NON-PROPAGATING-OPERATION #:COMPONENT-DEPENDS-ON #:INPUT-FILES #:OUTPUT-FILES #:OUTPUT-FILE #:OPERATION-DONE-P #:ACTION-STATUS #:ACTION-STAMP #:ACTION-DONE-P #:COMPONENT-OPERATION-TIME #:MARK-OPERATION-DONE #:COMPUTE-ACTION-STAMP #:PERFORM #:PERFORM-WITH-RESTARTS #:RETRY #:ACCEPT #:TRAVERSE-ACTIONS #:TRAVERSE-SUB-ACTIONS #:REQUIRED-COMPONENTS #:ACTION-PATH #:FIND-ACTION #:STAMP #:DONE-P #:OPERATION-DEFINITION-WARNING #:OPERATION-DEFINITION-ERROR))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/ACTION)
     [java] ; (COMMON-LISP:DEFTYPE ACTION COMMON-LISP:NIL (COMMON-LISP:QUOTE (COMMON-LISP:CONS OPERATION COMPONENT)))
     [java] ; (COMMON-LISP:DEFTYPE OPERATION-DESIGNATOR COMMON-LISP:NIL (COMMON-LISP:QUOTE (COMMON-LISP:OR OPERATION COMMON-LISP:NULL COMMON-LISP:SYMBOL COMMON-LISP:CLASS)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC TRAVERSE-ACTIONS (ACTIONS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS)) (COMMON-LISP:DEFGENERIC TRAVERSE-SUB-ACTIONS (OPERATION COMPONENT COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS)) (COMMON-LISP:DEFGENERIC REQUIRED-COMPONENTS (COMPONENT COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ACTION-PATH (ACTION) (COMMON-LISP:DESTRUCTURING-BIND (O . C) ACTION (COMMON-LISP:CONS (COMMON-LISP:TYPE-OF O) (COMPONENT-FIND-PATH C)))) (COMMON-LISP:DEFUN FIND-ACTION (PATH) (COMMON-LISP:DESTRUCTURING-BIND (O . C) PATH (COMMON-LISP:CONS (MAKE-OPERATION O) (FIND-COMPONENT COMMON-LISP:NIL C)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMACRO DEFINE-CONVENIENCE-ACTION-METHODS (COMMON-LISP:FUNCTION FORMALS COMMON-LISP:&KEY IF-NO-OPERATION IF-NO-COMPONENT OPERATION-INITARGS) (COMMON-LISP:LET* ((COMMON-LISP:REST (COMMON-LISP:GENSYM "REST")) (FOUND (COMMON-LISP:GENSYM "FOUND")) (KEYP (COMMON-LISP:EQUAL (COMMON-LISP:LAST FORMALS) (COMMON-LISP:QUOTE (COMMON-LISP:&KEY)))) (FORMALS-NO-KEY (COMMON-LISP:IF KEYP (COMMON-LISP:BUTLAST FORMALS) FORMALS)) (LEN (COMMON-LISP:LENGTH FORMALS-NO-KEY)) (OPERATION (COMMON-LISP:QUOTE OPERATION)) (COMPONENT (COMMON-LISP:QUOTE COMPONENT)) (OPIX (COMMON-LISP:POSITION OPERATION FORMALS)) (COIX (COMMON-LISP:POSITION COMPONENT FORMALS)) (PREFIX (COMMON-LISP:SUBSEQ FORMALS 0 OPIX)) (SUFFIX (COMMON-LISP:SUBSEQ FORMALS (COMMON-LISP:1+ COIX) LEN)) (MORE-ARGS (COMMON-LISP:WHEN KEYP (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:&REST) COMMON-LISP:REST (COMMON-LISP:QUOTE (COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS)))))) (COMMON-LISP:ASSERT (COMMON-LISP:AND (COMMON-LISP:INTEGERP OPIX) (COMMON-LISP:INTEGERP COIX) (COMMON-LISP:= COIX (COMMON-LISP:1+ OPIX)))) (COMMON-LISP:FLET ((NEXT-METHOD (O C) (COMMON-LISP:IF KEYP (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-APPEND PREFIX (SYSTEM::BACKQ-LIST* O C (SYSTEM::BACKQ-APPEND SUFFIX (SYSTEM::BACKQ-LIST COMMON-LISP:REST))))) (SYSTEM::BACKQ-CONS COMMON-LISP:FUNCTION (SYSTEM::BACKQ-APPEND PREFIX (SYSTEM::BACKQ-LIST* O C SUFFIX)))))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:PROGN) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DEFMETHOD) COMMON-LISP:FUNCTION (SYSTEM::BACKQ-APPEND PREFIX (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-CONS OPERATION (COMMON-LISP:QUOTE (COMMON-LISP:STRING))) COMPONENT (SYSTEM::BACKQ-APPEND SUFFIX MORE-ARGS))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:LET) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST COMPONENT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-COMPONENT) COMMON-LISP:NIL COMPONENT))) (NEXT-METHOD (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE UIOP/STREAM:SAFE-READ-FROM-STRING) OPERATION (COMMON-LISP:QUOTE (:PACKAGE :ASDF/INTERFACE))) COMPONENT))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DEFMETHOD) COMMON-LISP:FUNCTION (SYSTEM::BACKQ-APPEND PREFIX (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-CONS OPERATION (COMMON-LISP:QUOTE (COMMON-LISP:SYMBOL))) COMPONENT (SYSTEM::BACKQ-APPEND SUFFIX MORE-ARGS))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IF) OPERATION (NEXT-METHOD (COMMON-LISP:IF OPERATION-INITARGS (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE MAKE-OPERATION)) OPERATION (COMMON-LISP:QUOTE :ORIGINAL-INITARGS) COMMON-LISP:REST COMMON-LISP:REST) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE MAKE-OPERATION) OPERATION)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:OR) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-COMPONENT) COMMON-LISP:NIL COMPONENT) IF-NO-COMPONENT)) IF-NO-OPERATION)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:DEFMETHOD) COMMON-LISP:FUNCTION (SYSTEM::BACKQ-APPEND PREFIX (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-CONS OPERATION (COMMON-LISP:QUOTE (OPERATION))) COMPONENT (SYSTEM::BACKQ-APPEND SUFFIX MORE-ARGS))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:IF) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:TYPEP) COMPONENT (COMMON-LISP:QUOTE ((COMMON-LISP:QUOTE COMPONENT)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:ERROR) "No defined method for ~S on ~/asdf-action:format-action/" (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:CONS) OPERATION COMPONENT)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE UIOP/UTILITY:IF-LET) (SYSTEM::BACKQ-LIST FOUND (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-COMPONENT) COMMON-LISP:NIL COMPONENT)) (NEXT-METHOD OPERATION FOUND) IF-NO-COMPONENT))))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC ACTION-DESCRIPTION (OPERATION COMPONENT) (:DOCUMENTATION "returns a phrase that describes performing this operation
     [java] on this component, e.g. \"loading /a/b/c\".
     [java] You can put together sentences using this phrase.")) (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION (OPERATION COMPONENT) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<~A on ~A~@:>") (COMMON-LISP:TYPE-OF OPERATION) COMPONENT)) (UIOP/UTILITY:DEFGENERIC* (EXPLAIN) (OPERATION COMPONENT)) (COMMON-LISP:DEFMETHOD EXPLAIN ((O OPERATION) (C COMPONENT)) (ASDF-MESSAGE (UIOP/COMMON-LISP::COMPATFMT "~&~@<; ~@;~A~:>~%") (ACTION-DESCRIPTION O C))) (DEFINE-CONVENIENCE-ACTION-METHODS EXPLAIN (OPERATION COMPONENT)) (COMMON-LISP:DEFUN FORMAT-ACTION (COMMON-LISP:STREAM ACTION COMMON-LISP:&OPTIONAL COLON-P AT-SIGN-P) (COMMON-LISP:ASSERT (COMMON-LISP:NULL COLON-P)) (COMMON-LISP:ASSERT (COMMON-LISP:NULL AT-SIGN-P)) (COMMON-LISP:DESTRUCTURING-BIND (OPERATION . COMPONENT) ACTION (COMMON-LISP:PRINC (ACTION-DESCRIPTION OPERATION COMPONENT) COMMON-LISP:STREAM))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (COMPONENT-DEPENDS-ON) (OPERATION COMPONENT) (:DOCUMENTATION "Returns a list of dependencies needed by the component to perform
     [java]     the operation.  A dependency has one of the following forms:
     [java]
     [java]       (<operation> <component>*), where <operation> is an operation designator
     [java]         with respect to FIND-OPERATION in the context of the OPERATION argument,
     [java]         and each <component> is a component designator with respect to
     [java]         FIND-COMPONENT in the context of the COMPONENT argument,
     [java]         and means that the component depends on
     [java]         <operation> having been performed on each <component>;
     [java]
     [java]         [Note: an <operation> is an operation designator -- it can be either an
     [java]         operation name or an operation object.  Similarly, a <component> may be
     [java]         a component name or a component object.  Also note that, the degenerate
     [java]         case of (<operation>) is a no-op.]
     [java]
     [java]     Methods specialized on subclasses of existing component types
     [java]     should usually append the results of CALL-NEXT-METHOD to the list.")) (DEFINE-CONVENIENCE-ACTION-METHODS COMPONENT-DEPENDS-ON (OPERATION COMPONENT)) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON :AROUND ((O OPERATION) (C COMPONENT)) (DO-ASDF-CACHE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMPONENT-DEPENDS-ON) O C) (COMMON-LISP:CALL-NEXT-METHOD))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS DOWNWARD-OPERATION (OPERATION) ((DOWNWARD-OPERATION :INITFORM COMMON-LISP:NIL :READER DOWNWARD-OPERATION :TYPE OPERATION-DESIGNATOR :ALLOCATION :CLASS)) (:DOCUMENTATION "A DOWNWARD-OPERATION's dependencies propagate down the component hierarchy.
     [java] I.e., if O is a DOWNWARD-OPERATION and its DOWNWARD-OPERATION slot designates operation D, then
     [java] the action (O . M) of O on module M will depends on each of (D . C) for each child C of module M.
     [java] The default value for slot DOWNWARD-OPERATION is NIL, which designates the operation O itself.
     [java] E.g. in order for a MODULE to be loaded with LOAD-OP (resp. compiled with COMPILE-OP), all the
     [java] children of the MODULE must have been loaded with LOAD-OP (resp. compiled with COMPILE-OP.")) (COMMON-LISP:DEFUN DOWNWARD-OPERATION-DEPENDS-ON (O C) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (COMMON-LISP:OR (DOWNWARD-OPERATION O) O) (COMPONENT-CHILDREN C)))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O DOWNWARD-OPERATION) (C PARENT-COMPONENT)) (SYSTEM::BACKQ-APPEND (DOWNWARD-OPERATION-DEPENDS-ON O C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFCLASS UPWARD-OPERATION (OPERATION) ((UPWARD-OPERATION :INITFORM COMMON-LISP:NIL :READER UPWARD-OPERATION :TYPE OPERATION-DESIGNATOR :ALLOCATION :CLASS)) (:DOCUMENTATION "An UPWARD-OPERATION has dependencies that propagate up the component hierarchy.
     [java] I.e., if O is an instance of UPWARD-OPERATION, and its UPWARD-OPERATION slot designates operation U,
     [java] then the action (O . C) of O on a component C that has the parent P will depends on (U . P).
     [java] The default value for slot UPWARD-OPERATION is NIL, which designates the operation O itself.
     [java] E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP, its PARENT
     [java] must first be prepared for loading or compiling with PREPARE-OP.")) (COMMON-LISP:DEFUN UPWARD-OPERATION-DEPENDS-ON (O C) (UIOP/UTILITY:IF-LET (P (COMPONENT-PARENT C)) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:OR (UPWARD-OPERATION O) O) P)))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O UPWARD-OPERATION) (C CHILD-COMPONENT)) (SYSTEM::BACKQ-APPEND (UPWARD-OPERATION-DEPENDS-ON O C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFCLASS SIDEWAY-OPERATION (OPERATION) ((SIDEWAY-OPERATION :INITFORM COMMON-LISP:NIL :READER SIDEWAY-OPERATION :TYPE OPERATION-DESIGNATOR :ALLOCATION :CLASS)) (:DOCUMENTATION "A SIDEWAY-OPERATION has dependencies that propagate \"sideway\" to siblings
     [java] that a component depends on. I.e. if O is a SIDEWAY-OPERATION, and its SIDEWAY-OPERATION slot
     [java] designates operation S (where NIL designates O itself), then the action (O . C) of O on component C
     [java] depends on each of (S . D) where D is a declared dependency of C.
     [java] E.g. in order for a COMPONENT to be prepared for loading or compiling with PREPARE-OP,
     [java] each of its declared dependencies must first be loaded as by LOAD-OP.")) (COMMON-LISP:DEFUN SIDEWAY-OPERATION-DEPENDS-ON (O C) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-CONS (COMMON-LISP:OR (SIDEWAY-OPERATION O) O) (COMPONENT-SIDEWAY-DEPENDENCIES C)))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O SIDEWAY-OPERATION) (C COMPONENT)) (SYSTEM::BACKQ-APPEND (SIDEWAY-OPERATION-DEPENDS-ON O C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFCLASS SELFWARD-OPERATION (OPERATION) ((SELFWARD-OPERATION :TYPE (COMMON-LISP:OR OPERATION-DESIGNATOR COMMON-LISP:LIST) :READER SELFWARD-OPERATION :ALLOCATION :CLASS)) (:DOCUMENTATION "A SELFWARD-OPERATION depends on another operation on the same component.
     [java] I.e., if O is a SELFWARD-OPERATION, and its SELFWARD-OPERATION designates a list of operations L,
     [java] then the action (O . C) of O on component C depends on each (S . C) for S in L.
     [java] E.g. before a component may be loaded by LOAD-OP, it must have been compiled by COMPILE-OP.
     [java] A operation-designator designates a singleton list of the designated operation;
     [java] a list of operation-designators designates the list of designated operations;
     [java] NIL is not a valid operation designator in that context.  Note that any dependency
     [java] ordering between the operations in a list of SELFWARD-OPERATION should be specified separately
     [java] in the respective operation's COMPONENT-DEPENDS-ON methods so that they be scheduled properly.")) (COMMON-LISP:DEFUN SELFWARD-OPERATION-DEPENDS-ON (O C) (COMMON-LISP:LOOP :FOR OP :IN (UIOP/UTILITY:ENSURE-LIST (SELFWARD-OPERATION O)) :COLLECT (SYSTEM::BACKQ-LIST OP C))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O SELFWARD-OPERATION) (C COMPONENT)) (SYSTEM::BACKQ-APPEND (SELFWARD-OPERATION-DEPENDS-ON O C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFCLASS NON-PROPAGATING-OPERATION (OPERATION) COMMON-LISP:NIL (:DOCUMENTATION "A NON-PROPAGATING-OPERATION is an operation that propagates
     [java] no dependencies whatsoever.  It is supplied in order that the programmer be able
     [java] to specify that s/he is intentionally specifying an operation which invokes no
     [java] dependencies.")))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION OPERATION-DEFINITION-WARNING (COMMON-LISP:SIMPLE-WARNING) COMMON-LISP:NIL (:DOCUMENTATION "Warning condition related to definition of obsolete OPERATION objects.")) (COMMON-LISP:DEFINE-CONDITION OPERATION-DEFINITION-ERROR (COMMON-LISP:SIMPLE-ERROR) COMMON-LISP:NIL (:DOCUMENTATION "Error condition related to definition of incorrect OPERATION objects.")) (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :BEFORE ((O OPERATION) COMMON-LISP:&KEY) (COMMON-LISP:UNLESS (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE (COMMON-LISP:OR DOWNWARD-OPERATION UPWARD-OPERATION SIDEWAY-OPERATION SELFWARD-OPERATION NON-PROPAGATING-OPERATION))) (COMMON-LISP:WARN (COMMON-LISP:QUOTE OPERATION-DEFINITION-WARNING) :FORMAT-CONTROL "No dependency propagating scheme specified for operation class ~S.
     [java] The class needs to be updated for ASDF 3.1 and specify appropriate propagation mixins." :FORMAT-ARGUMENTS (COMMON-LISP:LIST (COMMON-LISP:TYPE-OF O))))) (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :BEFORE ((O NON-PROPAGATING-OPERATION) COMMON-LISP:&KEY) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE (COMMON-LISP:OR DOWNWARD-OPERATION UPWARD-OPERATION SIDEWAY-OPERATION SELFWARD-OPERATION))) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE OPERATION-DEFINITION-ERROR) :FORMAT-CONTROL "Inconsistent class: ~S
     [java]   NON-PROPAGATING-OPERATION is incompatible with propagating operation classes as superclasses." :FORMAT-ARGUMENTS (COMMON-LISP:LIST (COMMON-LISP:TYPE-OF O))))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O OPERATION) (C COMPONENT)) (SYSTEM::BACKQ-APPEND (COMMON-LISP:CDR (COMMON-LISP:ASSOC (COMMON-LISP:TYPE-OF O) (COMPONENT-IN-ORDER-TO C))) (COMMON-LISP:UNLESS (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE (COMMON-LISP:OR DOWNWARD-OPERATION UPWARD-OPERATION SIDEWAY-OPERATION SELFWARD-OPERATION NON-PROPAGATING-OPERATION))) (SYSTEM::BACKQ-APPEND (SIDEWAY-OPERATION-DEPENDS-ON O C) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE PARENT-COMPONENT)) (DOWNWARD-OPERATION-DEPENDS-ON O C)))))) (COMMON-LISP:DEFMETHOD DOWNWARD-OPERATION ((O OPERATION)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD SIDEWAY-OPERATION ((O OPERATION)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (OUTPUT-FILES) (OPERATION COMPONENT)) (UIOP/UTILITY:DEFGENERIC* (INPUT-FILES) (OPERATION COMPONENT)) (UIOP/UTILITY:DEFGENERIC* (OPERATION-DONE-P) (OPERATION COMPONENT) (:DOCUMENTATION "Returns a boolean, which is NIL if the action is forced to be performed again")) (DEFINE-CONVENIENCE-ACTION-METHODS OUTPUT-FILES (OPERATION COMPONENT)) (DEFINE-CONVENIENCE-ACTION-METHODS INPUT-FILES (OPERATION COMPONENT)) (DEFINE-CONVENIENCE-ACTION-METHODS OPERATION-DONE-P (OPERATION COMPONENT)) (COMMON-LISP:DEFMETHOD OPERATION-DONE-P ((O OPERATION) (C COMPONENT)) COMMON-LISP:T) (COMMON-LISP:DEFMETHOD OUTPUT-FILES :AROUND (OPERATION COMPONENT) "Translate output files, unless asked not to. Memoize the result." OPERATION COMPONENT (DO-ASDF-CACHE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE OUTPUT-FILES) OPERATION COMPONENT) (COMMON-LISP:VALUES (COMMON-LISP:MULTIPLE-VALUE-BIND (PATHNAMES FIXEDP) (COMMON-LISP:CALL-NEXT-METHOD) (COMMON-LISP:LET* ((COMMON-LISP:DIRECTORY (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (COMPONENT-PATHNAME (FIND-COMPONENT COMMON-LISP:NIL COMPONENT)))) (ABSOLUTE-PATHNAMES (COMMON-LISP:LOOP :FOR COMMON-LISP:PATHNAME :IN PATHNAMES :COLLECT (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME COMMON-LISP:PATHNAME COMMON-LISP:DIRECTORY)))) (COMMON-LISP:IF FIXEDP ABSOLUTE-PATHNAMES (COMMON-LISP:MAPCAR UIOP/PATHNAME:*OUTPUT-TRANSLATION-FUNCTION* ABSOLUTE-PATHNAMES)))) COMMON-LISP:T))) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O OPERATION) (C COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFUN OUTPUT-FILE (OPERATION COMPONENT) "The unique output file of performing OPERATION on COMPONENT" (COMMON-LISP:LET ((FILES (OUTPUT-FILES OPERATION COMPONENT))) (COMMON-LISP:ASSERT (UIOP/UTILITY:LENGTH=N-P FILES 1)) (COMMON-LISP:FIRST FILES))) (COMMON-LISP:DEFMETHOD INPUT-FILES :AROUND (OPERATION COMPONENT) "memoize input files." (DO-ASDF-CACHE (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE INPUT-FILES) OPERATION COMPONENT) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O OPERATION) (C COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O SELFWARD-OPERATION) (C COMPONENT)) (SYSTEM::BACKQ-APPEND (COMMON-LISP:OR (COMMON-LISP:LOOP :FOR DEP-O :IN (UIOP/UTILITY:ENSURE-LIST (SELFWARD-OPERATION O)) :APPEND (COMMON-LISP:OR (OUTPUT-FILES DEP-O C) (INPUT-FILES DEP-O C))) (UIOP/UTILITY:IF-LET ((COMMON-LISP:PATHNAME (COMPONENT-PATHNAME C))) (COMMON-LISP:AND (UIOP/PATHNAME:FILE-PATHNAME-P COMMON-LISP:PATHNAME) (COMMON-LISP:LIST COMMON-LISP:PATHNAME)))) (COMMON-LISP:CALL-NEXT-METHOD))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC COMPONENT-OPERATION-TIME (OPERATION COMPONENT)) (DEFINE-CONVENIENCE-ACTION-METHODS COMPONENT-OPERATION-TIME (OPERATION COMPONENT)) (COMMON-LISP:DEFGENERIC MARK-OPERATION-DONE (OPERATION COMPONENT)) (COMMON-LISP:DEFGENERIC COMPUTE-ACTION-STAMP (PLAN OPERATION COMPONENT COMMON-LISP:&KEY JUST-DONE) (:DOCUMENTATION "Has this action been successfully done already,
     [java] and at what known timestamp has it been done at or will it be done at?
     [java] Takes two keywords JUST-DONE and PLAN:
     [java] JUST-DONE is a boolean that is true if the action was just successfully performed,
     [java] at which point we want compute the actual stamp and warn if files are missing;
     [java] otherwise we are making plans, anticipating the effects of the action.
     [java] PLAN is a plan object modelling future effects of actions,
     [java] or NIL to denote what actually happened.
     [java] Returns two values:
     [java] * a STAMP saying when it was done or will be done,
     [java]   or T if the action has involves files that need to be recomputed.
     [java] * a boolean DONE-P that indicates whether the action has actually been done,
     [java]   and both its output-files and its in-image side-effects are up to date.")) (COMMON-LISP:DEFCLASS ACTION-STATUS COMMON-LISP:NIL ((STAMP :INITARG :STAMP :READER ACTION-STAMP :DOCUMENTATION "STAMP associated with the ACTION if it has been completed already
     [java] in some previous image, or T if it needs to be done.") (DONE-P :INITARG :DONE-P :READER ACTION-DONE-P :DOCUMENTATION "a boolean, true iff the action was already done (before any planned action).")) (:DOCUMENTATION "Status of an action")) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((STATUS ACTION-STATUS) COMMON-LISP:STREAM) (COMMON-LISP:PRINT-UNREADABLE-OBJECT (STATUS COMMON-LISP:STREAM :TYPE COMMON-LISP:T) (COMMON-LISP:WITH-SLOTS (STAMP DONE-P) STATUS (COMMON-LISP:FORMAT COMMON-LISP:STREAM "~@{~S~^ ~}" :STAMP STAMP :DONE-P DONE-P)))) (COMMON-LISP:DEFMETHOD COMPONENT-OPERATION-TIME ((O OPERATION) (C COMPONENT)) (COMMON-LISP:GETHASH (COMMON-LISP:TYPE-OF O) (COMPONENT-OPERATION-TIMES C))) (COMMON-LISP:DEFMETHOD MARK-OPERATION-DONE ((O OPERATION) (C COMPONENT)) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (COMMON-LISP:TYPE-OF O) (COMPONENT-OPERATION-TIMES C)) (COMPUTE-ACTION-STAMP COMMON-LISP:NIL O C :JUST-DONE COMMON-LISP:T))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (PERFORM-WITH-RESTARTS) (OPERATION COMPONENT)) (UIOP/UTILITY:DEFGENERIC* (PERFORM) (OPERATION COMPONENT)) (DEFINE-CONVENIENCE-ACTION-METHODS PERFORM (OPERATION COMPONENT)) (COMMON-LISP:DEFMETHOD PERFORM :BEFORE ((O OPERATION) (C COMPONENT)) (UIOP/FILESYSTEM:ENSURE-ALL-DIRECTORIES-EXIST (OUTPUT-FILES O C))) (COMMON-LISP:DEFMETHOD PERFORM :AFTER ((O OPERATION) (C COMPONENT)) (MARK-OPERATION-DONE O C)) (COMMON-LISP:DEFMETHOD PERFORM ((O OPERATION) (C PARENT-COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O OPERATION) (C SOURCE-FILE)) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE (COMMON-LISP:OR DOWNWARD-OPERATION UPWARD-OPERATION SIDEWAY-OPERATION SELFWARD-OPERATION NON-PROPAGATING-OPERATION))) (SYSDEF-ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Required method ~S not implemented for ~/asdf-action:format-action/~@:>") (COMMON-LISP:QUOTE PERFORM) (COMMON-LISP:CONS O C)))) (COMMON-LISP:DEFMETHOD PERFORM-WITH-RESTARTS (OPERATION COMPONENT) (PERFORM OPERATION COMPONENT)) (COMMON-LISP:DEFMETHOD PERFORM-WITH-RESTARTS :AROUND (OPERATION COMPONENT) (COMMON-LISP:LOOP (COMMON-LISP:RESTART-CASE (COMMON-LISP:RETURN (COMMON-LISP:CALL-NEXT-METHOD)) (RETRY COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Retry ~A.~@:>") (ACTION-DESCRIPTION OPERATION COMPONENT)))) (ACCEPT COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Continue, treating ~A as having been successful.~@:>") (ACTION-DESCRIPTION OPERATION COMPONENT))) (MARK-OPERATION-DONE OPERATION COMPONENT) (COMMON-LISP:RETURN))))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/LISP-ACTION (:RECYCLE :ASDF/LISP-ACTION :ASDF) (:INTERN #:PROCLAMATIONS #:FLAGS) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-COMPONENT :ASDF/FIND-SYSTEM :ASDF/OPERATION :ASDF/ACTION) (:EXPORT #:TRY-RECOMPILING #:CL-SOURCE-FILE #:CL-SOURCE-FILE.CL #:CL-SOURCE-FILE.LSP #:BASIC-LOAD-OP #:BASIC-COMPILE-OP #:COMPILE-OP-FLAGS #:COMPILE-OP-PROCLAMATIONS #:LOAD-OP #:PREPARE-OP #:COMPILE-OP #:TEST-OP #:LOAD-SOURCE-OP #:PREPARE-SOURCE-OP #:CALL-WITH-AROUND-COMPILE-HOOK #:PERFORM-LISP-COMPILATION #:PERFORM-LISP-LOAD-FASL #:PERFORM-LISP-LOAD-SOURCE #:LISP-COMPILATION-OUTPUT-FILES #:FLAGS))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/LISP-ACTION)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS CL-SOURCE-FILE (SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM "lisp"))) (COMMON-LISP:DEFCLASS CL-SOURCE-FILE.CL (CL-SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM "cl"))) (COMMON-LISP:DEFCLASS CL-SOURCE-FILE.LSP (CL-SOURCE-FILE) ((COMMON-LISP:TYPE :INITFORM "lsp"))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS BASIC-LOAD-OP (OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS BASIC-COMPILE-OP (OPERATION) ((PROCLAMATIONS :INITARG :PROCLAMATIONS :ACCESSOR COMPILE-OP-PROCLAMATIONS :INITFORM COMMON-LISP:NIL) (FLAGS :INITARG :FLAGS :ACCESSOR COMPILE-OP-FLAGS :INITFORM COMMON-LISP:NIL))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS PREPARE-OP (UPWARD-OPERATION SIDEWAY-OPERATION) ((SIDEWAY-OPERATION :INITFORM (COMMON-LISP:QUOTE LOAD-OP) :ALLOCATION :CLASS)) (:DOCUMENTATION "Load dependencies necessary for COMPILE-OP or LOAD-OP of a given COMPONENT.")) (COMMON-LISP:DEFCLASS LOAD-OP (BASIC-LOAD-OP DOWNWARD-OPERATION SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-OP COMPILE-OP)) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS COMPILE-OP (BASIC-COMPILE-OP DOWNWARD-OPERATION SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE PREPARE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS PREPARE-SOURCE-OP (UPWARD-OPERATION SIDEWAY-OPERATION) ((SIDEWAY-OPERATION :INITFORM (COMMON-LISP:QUOTE LOAD-SOURCE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS LOAD-SOURCE-OP (BASIC-LOAD-OP DOWNWARD-OPERATION SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE PREPARE-SOURCE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS TEST-OP (SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE LOAD-OP) :ALLOCATION :CLASS))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O PREPARE-OP) (C COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<loading dependencies of ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD PERFORM ((O PREPARE-OP) (C COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O PREPARE-OP) (S SYSTEM)) (UIOP/UTILITY:IF-LET (IT (SYSTEM-SOURCE-FILE S)) (COMMON-LISP:LIST IT))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O COMPILE-OP) (C COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<compiling ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O COMPILE-OP) (C PARENT-COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<completing compilation for ~3i~_~A~@:>") C)) (COMMON-LISP:DEFGENERIC CALL-WITH-AROUND-COMPILE-HOOK (COMPONENT THUNK)) (COMMON-LISP:DEFMETHOD CALL-WITH-AROUND-COMPILE-HOOK ((C COMPONENT) COMMON-LISP:FUNCTION) (UIOP/LISP-BUILD:CALL-AROUND-HOOK (AROUND-COMPILE-HOOK C) COMMON-LISP:FUNCTION)) (COMMON-LISP:DEFUN PERFORM-LISP-COMPILATION (O C) (COMMON-LISP:LET ((INPUT-FILE (COMMON-LISP:FIRST (INPUT-FILES O C))) (OUTPUTS (OUTPUT-FILES O C))) (COMMON-LISP:MULTIPLE-VALUE-BIND (OUTPUT WARNINGS-P FAILURE-P) (COMMON-LISP:DESTRUCTURING-BIND (OUTPUT-FILE COMMON-LISP:&OPTIONAL WARNINGS-FILE COMMON-LISP:&REST COMMON-LISP:REST) OUTPUTS (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE COMMON-LISP:REST)) (COMMON-LISP:WHEN WARNINGS-FILE (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL (COMMON-LISP:PATHNAME-TYPE WARNINGS-FILE) (UIOP/LISP-BUILD:WARNINGS-FILE-TYPE)) (COMMON-LISP:SETF WARNINGS-FILE COMMON-LISP:NIL))) (CALL-WITH-AROUND-COMPILE-HOOK C (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (COMMON-LISP:&REST FLAGS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE UIOP/LISP-BUILD:COMPILE-FILE*) INPUT-FILE :OUTPUT-FILE OUTPUT-FILE :EXTERNAL-FORMAT (COMPONENT-EXTERNAL-FORMAT C) :WARNINGS-FILE WARNINGS-FILE (COMMON-LISP:APPEND FLAGS (COMPILE-OP-FLAGS O))))))) (UIOP/LISP-BUILD:CHECK-LISP-COMPILE-RESULTS OUTPUT WARNINGS-P FAILURE-P "~/asdf-action::format-action/" (COMMON-LISP:LIST (COMMON-LISP:CONS O C)))))) (COMMON-LISP:DEFUN REPORT-FILE-P (F) (COMMON-LISP:EQUALP (COMMON-LISP:PATHNAME-TYPE F) "build-report")) (COMMON-LISP:DEFUN PERFORM-LISP-WARNINGS-CHECK (O C) (COMMON-LISP:LET* ((EXPECTED-WARNINGS-FILES (COMMON-LISP:REMOVE-IF-NOT (COMMON-LISP:FUNCTION UIOP/LISP-BUILD:WARNINGS-FILE-P) (INPUT-FILES O C))) (ACTUAL-WARNINGS-FILES (COMMON-LISP:LOOP :FOR W :IN EXPECTED-WARNINGS-FILES :WHEN (GET-FILE-STAMP W) :COLLECT W :ELSE :DO (COMMON-LISP:WARN "Missing warnings file ~S while ~A" W (ACTION-DESCRIPTION O C))))) (UIOP/LISP-BUILD:CHECK-DEFERRED-WARNINGS ACTUAL-WARNINGS-FILES) (COMMON-LISP:LET* ((OUTPUT (OUTPUT-FILES O C)) (REPORT (COMMON-LISP:FIND-IF (COMMON-LISP:FUNCTION REPORT-FILE-P) OUTPUT))) (COMMON-LISP:WHEN REPORT (COMMON-LISP:WITH-OPEN-FILE (S REPORT :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE) (COMMON-LISP:FORMAT S ":success~%")))))) (COMMON-LISP:DEFMETHOD PERFORM ((O COMPILE-OP) (C CL-SOURCE-FILE)) (PERFORM-LISP-COMPILATION O C)) (COMMON-LISP:DEFUN LISP-COMPILATION-OUTPUT-FILES (O C) (COMMON-LISP:LET* ((I (COMMON-LISP:FIRST (INPUT-FILES O C))) (F (COMMON-LISP:COMPILE-FILE-PATHNAME I))) (SYSTEM::BACKQ-CONS F (COMMON-LISP:WHEN (COMMON-LISP:AND UIOP/LISP-BUILD:*WARNINGS-FILE-TYPE* (COMMON-LISP:NOT (BUILTIN-SYSTEM-P (COMPONENT-SYSTEM C)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:MAKE-PATHNAME :TYPE UIOP/LISP-BUILD:*WARNINGS-FILE-TYPE* :DEFAULTS F)))))) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O COMPILE-OP) (C CL-SOURCE-FILE)) (LISP-COMPILATION-OUTPUT-FILES O C)) (COMMON-LISP:DEFMETHOD PERFORM ((O COMPILE-OP) (C STATIC-FILE)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O COMPILE-OP) (C SYSTEM)) (COMMON-LISP:WHEN (COMMON-LISP:AND UIOP/LISP-BUILD:*WARNINGS-FILE-TYPE* (COMMON-LISP:NOT (BUILTIN-SYSTEM-P C))) (PERFORM-LISP-WARNINGS-CHECK O C))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O COMPILE-OP) (C SYSTEM)) (COMMON-LISP:WHEN (COMMON-LISP:AND UIOP/LISP-BUILD:*WARNINGS-FILE-TYPE* (COMMON-LISP:NOT (BUILTIN-SYSTEM-P C))) (COMMON-LISP:LOOP :FOR SUB :IN (SUB-COMPONENTS C :TYPE (COMMON-LISP:QUOTE CL-SOURCE-FILE)) :NCONC (COMMON-LISP:REMOVE-IF-NOT (COMMON-LISP:QUOTE UIOP/LISP-BUILD:WARNINGS-FILE-P) (OUTPUT-FILES O SUB))))) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O COMPILE-OP) (C SYSTEM)) (COMMON-LISP:WHEN (COMMON-LISP:AND UIOP/LISP-BUILD:*WARNINGS-FILE-TYPE* (COMMON-LISP:NOT (BUILTIN-SYSTEM-P C))) (UIOP/UTILITY:IF-LET ((COMMON-LISP:PATHNAME (COMPONENT-PATHNAME C))) (COMMON-LISP:LIST (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:PATHNAME (COERCE-FILENAME C) :TYPE "build-report"))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O LOAD-OP) (C CL-SOURCE-FILE)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<loading FASL for ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O LOAD-OP) (C PARENT-COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<completing load for ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O LOAD-OP) (C COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<loading ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD PERFORM-WITH-RESTARTS ((O LOAD-OP) (C CL-SOURCE-FILE)) (COMMON-LISP:LOOP (COMMON-LISP:RESTART-CASE (COMMON-LISP:RETURN (COMMON-LISP:CALL-NEXT-METHOD)) (TRY-RECOMPILING COMMON-LISP:NIL :REPORT (COMMON-LISP:LAMBDA (S) (COMMON-LISP:FORMAT S "Recompile ~a and try loading it again" (COMPONENT-NAME C))) (PERFORM (FIND-OPERATION O (COMMON-LISP:QUOTE COMPILE-OP)) C))))) (COMMON-LISP:DEFUN PERFORM-LISP-LOAD-FASL (O C) (UIOP/UTILITY:IF-LET (FASL (COMMON-LISP:FIRST (INPUT-FILES O C))) (UIOP/LISP-BUILD:LOAD* FASL))) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-OP) (C CL-SOURCE-FILE)) (PERFORM-LISP-LOAD-FASL O C)) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-OP) (C STATIC-FILE)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O PREPARE-SOURCE-OP) (C COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<loading source for dependencies of ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O PREPARE-SOURCE-OP) (S SYSTEM)) (UIOP/UTILITY:IF-LET (IT (SYSTEM-SOURCE-FILE S)) (COMMON-LISP:LIST IT))) (COMMON-LISP:DEFMETHOD PERFORM ((O PREPARE-SOURCE-OP) (C COMPONENT)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O LOAD-SOURCE-OP) (C COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<Loading source of ~3i~_~A~@:>") C)) (COMMON-LISP:DEFMETHOD ACTION-DESCRIPTION ((O LOAD-SOURCE-OP) (C PARENT-COMPONENT)) (COMMON-LISP:FORMAT COMMON-LISP:NIL (UIOP/COMMON-LISP::COMPATFMT "~@<Loaded source of ~3i~_~A~@:>") C)) (COMMON-LISP:DEFUN PERFORM-LISP-LOAD-SOURCE (O C) (CALL-WITH-AROUND-COMPILE-HOOK C (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (UIOP/LISP-BUILD:LOAD* (COMMON-LISP:FIRST (INPUT-FILES O C)) :EXTERNAL-FORMAT (COMPONENT-EXTERNAL-FORMAT C)))))) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-SOURCE-OP) (C CL-SOURCE-FILE)) (PERFORM-LISP-LOAD-SOURCE O C)) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-SOURCE-OP) (C STATIC-FILE)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD PERFORM ((O TEST-OP) (C COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD OPERATION-DONE-P ((O TEST-OP) (C SYSTEM)) "Testing a system is _never_ done." COMMON-LISP:NIL))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/PLAN (:RECYCLE :ASDF/PLAN :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/OPERATION :ASDF/SYSTEM :ASDF/CACHE :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/OPERATION :ASDF/ACTION :ASDF/LISP-ACTION) (:EXPORT #:COMPONENT-OPERATION-TIME #:MARK-OPERATION-DONE #:PLAN #:PLAN-TRAVERSAL #:SEQUENTIAL-PLAN #:*DEFAULT-PLAN-CLASS* #:PLANNED-ACTION-STATUS #:PLAN-ACTION-STATUS #:ACTION-ALREADY-DONE-P #:CIRCULAR-DEPENDENCY #:CIRCULAR-DEPENDENCY-ACTIONS #:NODE-FOR #:NEEDED-IN-IMAGE-P #:ACTION-INDEX #:ACTION-PLANNED-P #:ACTION-VALID-P #:PLAN-RECORD-DEPENDENCY #:NORMALIZE-FORCED-SYSTEMS #:ACTION-FORCED-P #:ACTION-FORCED-NOT-P #:MAP-DIRECT-DEPENDENCIES #:REDUCE-DIRECT-DEPENDENCIES #:DIRECT-DEPENDENCIES #:COMPUTE-ACTION-STAMP #:TRAVERSE-ACTION #:CIRCULAR-DEPENDENCY #:CIRCULAR-DEPENDENCY-ACTIONS #:CALL-WHILE-VISITING-ACTION #:WHILE-VISITING-ACTION #:MAKE-PLAN #:PLAN-ACTIONS #:PERFORM-PLAN #:PLAN-OPERATES-ON-P #:PLANNED-P #:INDEX #:FORCED #:FORCED-NOT #:TOTAL-ACTION-COUNT #:PLANNED-ACTION-COUNT #:PLANNED-OUTPUT-ACTION-COUNT #:VISITED-ACTIONS #:VISITING-ACTION-SET #:VISITING-ACTION-LIST #:PLAN-ACTIONS-R #:REQUIRED-COMPONENTS #:FILTERED-SEQUENTIAL-PLAN #:PLAN-SYSTEM #:PLAN-ACTION-FILTER #:PLAN-COMPONENT-TYPE #:PLAN-KEEP-OPERATION #:PLAN-KEEP-COMPONENT #:TRAVERSE-ACTIONS #:TRAVERSE-SUB-ACTIONS))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/PLAN)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS PLAN COMMON-LISP:NIL COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS PLAN-TRAVERSAL (PLAN) ((SYSTEM :INITFORM COMMON-LISP:NIL :INITARG :SYSTEM :ACCESSOR PLAN-SYSTEM) (FORCED :INITFORM COMMON-LISP:NIL :INITARG :FORCE :ACCESSOR PLAN-FORCED) (FORCED-NOT :INITFORM COMMON-LISP:NIL :INITARG :FORCE-NOT :ACCESSOR PLAN-FORCED-NOT) (TOTAL-ACTION-COUNT :INITFORM 0 :ACCESSOR PLAN-TOTAL-ACTION-COUNT) (PLANNED-ACTION-COUNT :INITFORM 0 :ACCESSOR PLAN-PLANNED-ACTION-COUNT) (PLANNED-OUTPUT-ACTION-COUNT :INITFORM 0 :ACCESSOR PLAN-PLANNED-OUTPUT-ACTION-COUNT) (VISITED-ACTIONS :INITFORM (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) :ACCESSOR PLAN-VISITED-ACTIONS) (VISITING-ACTION-SET :INITFORM (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) :ACCESSOR PLAN-VISITING-ACTION-SET) (VISITING-ACTION-LIST :INITFORM COMMON-LISP:NIL :ACCESSOR PLAN-VISITING-ACTION-LIST))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC PLAN-ACTION-STATUS (PLAN OPERATION COMPONENT) (:DOCUMENTATION "Returns the ACTION-STATUS associated to
     [java] the action of OPERATION on COMPONENT in the PLAN")) (COMMON-LISP:DEFGENERIC (COMMON-LISP:SETF PLAN-ACTION-STATUS) (NEW-STATUS PLAN OPERATION COMPONENT) (:DOCUMENTATION "Sets the ACTION-STATUS associated to
     [java] the action of OPERATION on COMPONENT in the PLAN")) (COMMON-LISP:DEFCLASS PLANNED-ACTION-STATUS (ACTION-STATUS) ((PLANNED-P :INITARG :PLANNED-P :READER ACTION-PLANNED-P :DOCUMENTATION "a boolean, true iff the action was included in the plan.") (INDEX :INITARG :INDEX :READER ACTION-INDEX :DOCUMENTATION "an integer, counting all traversed actions in traversal order.")) (:DOCUMENTATION "Status of an action in a plan")) (COMMON-LISP:DEFMETHOD COMMON-LISP:PRINT-OBJECT ((STATUS PLANNED-ACTION-STATUS) COMMON-LISP:STREAM) (COMMON-LISP:PRINT-UNREADABLE-OBJECT (STATUS COMMON-LISP:STREAM :TYPE COMMON-LISP:T :IDENTITY COMMON-LISP:NIL) (COMMON-LISP:WITH-SLOTS (STAMP DONE-P PLANNED-P INDEX) STATUS (COMMON-LISP:FORMAT COMMON-LISP:STREAM "~@{~S~^ ~}" :STAMP STAMP :DONE-P DONE-P :PLANNED-P PLANNED-P :INDEX INDEX)))) (COMMON-LISP:DEFMETHOD ACTION-PLANNED-P ((ACTION-STATUS COMMON-LISP:T)) COMMON-LISP:T) (COMMON-LISP:DEFUN NODE-FOR (O C) (COMMON-LISP:CONS (COMMON-LISP:TYPE-OF O) C)) (COMMON-LISP:DEFUN ACTION-ALREADY-DONE-P (PLAN OPERATION COMPONENT) (ACTION-DONE-P (PLAN-ACTION-STATUS PLAN OPERATION COMPONENT))) (COMMON-LISP:DEFMETHOD PLAN-ACTION-STATUS ((PLAN COMMON-LISP:NULL) (O OPERATION) (C COMPONENT)) (COMMON-LISP:MULTIPLE-VALUE-BIND (STAMP DONE-P) (COMPONENT-OPERATION-TIME O C) (COMMON-LISP:MAKE-INSTANCE (COMMON-LISP:QUOTE ACTION-STATUS) :STAMP STAMP :DONE-P DONE-P))) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF PLAN-ACTION-STATUS) (NEW-STATUS (PLAN COMMON-LISP:NULL) (O OPERATION) (C COMPONENT)) (COMMON-LISP:LET ((TO (COMMON-LISP:TYPE-OF O)) (TIMES (COMPONENT-OPERATION-TIMES C))) (COMMON-LISP:IF (ACTION-DONE-P NEW-STATUS) (COMMON-LISP:REMHASH TO TIMES) (COMMON-LISP:SETF (COMMON-LISP:GETHASH TO TIMES) (ACTION-STAMP NEW-STATUS)))) NEW-STATUS))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC ACTION-FORCED-P (PLAN OPERATION COMPONENT)) (COMMON-LISP:DEFGENERIC ACTION-FORCED-NOT-P (PLAN OPERATION COMPONENT)) (COMMON-LISP:DEFUN NORMALIZE-FORCED-SYSTEMS (X SYSTEM) (COMMON-LISP:ETYPECASE X ((COMMON-LISP:OR (COMMON-LISP:MEMBER COMMON-LISP:NIL :ALL) COMMON-LISP:HASH-TABLE COMMON-LISP:FUNCTION) X) (COMMON-LISP:CONS (UIOP/UTILITY:LIST-TO-HASH-SET (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION COERCE-NAME) X))) ((COMMON-LISP:EQL COMMON-LISP:T) (COMMON-LISP:WHEN SYSTEM (UIOP/UTILITY:LIST-TO-HASH-SET (COMMON-LISP:LIST (COERCE-NAME SYSTEM))))))) (COMMON-LISP:DEFUN NORMALIZE-FORCED-NOT-SYSTEMS (X SYSTEM) (COMMON-LISP:LET ((REQUESTED (COMMON-LISP:ETYPECASE X ((COMMON-LISP:OR (COMMON-LISP:MEMBER COMMON-LISP:NIL :ALL) COMMON-LISP:HASH-TABLE COMMON-LISP:FUNCTION) X) (COMMON-LISP:CONS (UIOP/UTILITY:LIST-TO-HASH-SET (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION COERCE-NAME) X))) ((COMMON-LISP:EQL COMMON-LISP:T) (COMMON-LISP:IF SYSTEM (COMMON-LISP:LET ((NAME (COERCE-NAME SYSTEM))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:NOT (COMMON-LISP:EQUAL X NAME))))) COMMON-LISP:T))))) (COMMON-LISP:IF (COMMON-LISP:AND *IMMUTABLE-SYSTEMS* REQUESTED) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:OR (UIOP/UTILITY:CALL-FUNCTION REQUESTED X) (UIOP/UTILITY:CALL-FUNCTION *IMMUTABLE-SYSTEMS* X)))) (COMMON-LISP:OR *IMMUTABLE-SYSTEMS* REQUESTED)))) (COMMON-LISP:DEFUN ACTION-OVERRIDE-P (PLAN OPERATION COMPONENT OVERRIDE-ACCESSOR) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE OPERATION)) (UIOP/UTILITY:CALL-FUNCTION (COMMON-LISP:FUNCALL OVERRIDE-ACCESSOR PLAN) (COERCE-NAME (COMPONENT-SYSTEM (FIND-COMPONENT COMMON-LISP:NIL COMPONENT))))) (COMMON-LISP:DEFMETHOD ACTION-FORCED-P (PLAN OPERATION COMPONENT) (COMMON-LISP:AND (ACTION-OVERRIDE-P PLAN OPERATION COMPONENT (COMMON-LISP:QUOTE PLAN-FORCED)) (COMMON-LISP:NOT (COMMON-LISP:LET ((SYSTEM (COMPONENT-SYSTEM COMPONENT))) (COMMON-LISP:AND (BUILTIN-SYSTEM-P SYSTEM) (COMMON-LISP:NOT (COMMON-LISP:EQ SYSTEM (PLAN-SYSTEM PLAN)))))))) (COMMON-LISP:DEFMETHOD ACTION-FORCED-NOT-P (PLAN OPERATION COMPONENT) (ACTION-OVERRIDE-P PLAN OPERATION COMPONENT (COMMON-LISP:QUOTE PLAN-FORCED-NOT))) (COMMON-LISP:DEFMETHOD ACTION-FORCED-P ((PLAN COMMON-LISP:NULL) (OPERATION OPERATION) (COMPONENT COMPONENT)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD ACTION-FORCED-NOT-P ((PLAN COMMON-LISP:NULL) (OPERATION OPERATION) (COMPONENT COMPONENT)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC ACTION-VALID-P (PLAN OPERATION COMPONENT) (:DOCUMENTATION "Is this action valid to include amongst dependencies?")) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN COMMON-LISP:T) (O OPERATION) (C COMPONENT)) (UIOP/UTILITY:IF-LET (IT (COMPONENT-IF-FEATURE C)) (UIOP/OS:FEATUREP IT) COMMON-LISP:T)) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN COMMON-LISP:T) (O COMMON-LISP:NULL) (C COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN COMMON-LISP:T) (O COMMON-LISP:T) (C COMMON-LISP:NULL)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN COMMON-LISP:NULL) (O OPERATION) (C COMPONENT)) COMMON-LISP:T))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC NEEDED-IN-IMAGE-P (OPERATION COMPONENT) (:DOCUMENTATION "Is the action of OPERATION on COMPONENT needed in the current image to be meaningful,
     [java]     or could it just as well have been done in another Lisp image?")) (COMMON-LISP:DEFMETHOD NEEDED-IN-IMAGE-P ((O OPERATION) (C COMPONENT)) (COMMON-LISP:NOT (OUTPUT-FILES O C))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN (MAP-DIRECT-DEPENDENCIES) (PLAN OPERATION COMPONENT FUN) (UIOP/COMMON-LISP::LOOP* :FOR (DEP-O-SPEC . DEP-C-SPECS) :IN (COMPONENT-DEPENDS-ON OPERATION COMPONENT) :FOR DEP-O COMMON-LISP:= (FIND-OPERATION OPERATION DEP-O-SPEC) :WHEN DEP-O :DO (COMMON-LISP:LOOP :FOR DEP-C-SPEC :IN DEP-C-SPECS :FOR DEP-C COMMON-LISP:= (COMMON-LISP:AND DEP-C-SPEC (RESOLVE-DEPENDENCY-SPEC COMPONENT DEP-C-SPEC)) :WHEN (COMMON-LISP:AND DEP-C (ACTION-VALID-P PLAN DEP-O DEP-C)) :DO (COMMON-LISP:FUNCALL FUN DEP-O DEP-C)))) (COMMON-LISP:DEFUN (REDUCE-DIRECT-DEPENDENCIES) (PLAN OPERATION COMPONENT COMBINATOR SEED) (MAP-DIRECT-DEPENDENCIES PLAN OPERATION COMPONENT (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (DEP-O DEP-C) (COMMON-LISP:SETF SEED (COMMON-LISP:FUNCALL COMBINATOR DEP-O DEP-C SEED))))) SEED) (COMMON-LISP:DEFUN (DIRECT-DEPENDENCIES) (PLAN OPERATION COMPONENT) (REDUCE-DIRECT-DEPENDENCIES PLAN OPERATION COMPONENT (COMMON-LISP:FUNCTION COMMON-LISP:ACONS) COMMON-LISP:NIL)) (COMMON-LISP:DEFMETHOD COMPUTE-ACTION-STAMP (PLAN (O OPERATION) (C COMPONENT) COMMON-LISP:&KEY JUST-DONE) (UIOP/UTILITY:NEST (COMMON-LISP:BLOCK COMMON-LISP:NIL) (COMMON-LISP:LET ((DEP-STAMP (REDUCE-DIRECT-DEPENDENCIES PLAN O C (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (O C STAMP) (UIOP/UTILITY:IF-LET (IT (PLAN-ACTION-STATUS PLAN O C)) (UIOP/UTILITY:LATEST-STAMP STAMP (ACTION-STAMP IT)) COMMON-LISP:T))) COMMON-LISP:NIL))) (COMMON-LISP:WHEN (COMMON-LISP:AND (COMMON-LISP:EQ DEP-STAMP COMMON-LISP:T) (COMMON-LISP:NOT JUST-DONE)) (COMMON-LISP:RETURN (COMMON-LISP:VALUES COMMON-LISP:T COMMON-LISP:NIL)))) (COMMON-LISP:LET* ((IN-FILES (INPUT-FILES O C)) (IN-STAMPS (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION GET-FILE-STAMP) IN-FILES)) (MISSING-IN (COMMON-LISP:LOOP :FOR F :IN IN-FILES :FOR S :IN IN-STAMPS :UNLESS S :COLLECT F)) (LATEST-IN (UIOP/UTILITY:STAMPS-LATEST (COMMON-LISP:CONS DEP-STAMP IN-STAMPS)))) (COMMON-LISP:WHEN (COMMON-LISP:AND MISSING-IN (COMMON-LISP:NOT JUST-DONE)) (COMMON-LISP:RETURN (COMMON-LISP:VALUES COMMON-LISP:T COMMON-LISP:NIL)))) (COMMON-LISP:LET* ((OUT-FILES (COMMON-LISP:REMOVE-IF (COMMON-LISP:QUOTE COMMON-LISP:NULL) (OUTPUT-FILES O C))) (OUT-STAMPS (COMMON-LISP:MAPCAR (COMMON-LISP:IF JUST-DONE (COMMON-LISP:QUOTE REGISTER-FILE-STAMP) (COMMON-LISP:QUOTE GET-FILE-STAMP)) OUT-FILES)) (MISSING-OUT (COMMON-LISP:LOOP :FOR F :IN OUT-FILES :FOR S :IN OUT-STAMPS :UNLESS S :COLLECT F)) (EARLIEST-OUT (UIOP/UTILITY:STAMPS-EARLIEST OUT-STAMPS))) (COMMON-LISP:WHEN (COMMON-LISP:AND MISSING-OUT (COMMON-LISP:NOT JUST-DONE)) (COMMON-LISP:RETURN (COMMON-LISP:VALUES COMMON-LISP:T COMMON-LISP:NIL)))) (COMMON-LISP:LET* ((OUT-OP (COMMON-LISP:AND OUT-FILES COMMON-LISP:T)) (OP-TIME (COMMON-LISP:OR JUST-DONE (COMPONENT-OPERATION-TIME O C))) (ALL-PRESENT (COMMON-LISP:NOT (COMMON-LISP:OR MISSING-IN MISSING-OUT))) (UP-TO-DATE-P (UIOP/UTILITY:STAMP<= LATEST-IN EARLIEST-OUT)) (DONE-STAMP (UIOP/UTILITY:STAMPS-LATEST (COMMON-LISP:CONS LATEST-IN OUT-STAMPS)))) (COMMON-LISP:WHEN (COMMON-LISP:AND JUST-DONE (COMMON-LISP:NOT ALL-PRESENT)) (COMMON-LISP:WARN "~A completed without ~:[~*~;~*its input file~:p~2:*~{ ~S~}~*~]~
     [java]                 ~:[~; or ~]~:[~*~;~*its output file~:p~2:*~{ ~S~}~*~]" (ACTION-DESCRIPTION O C) MISSING-IN (COMMON-LISP:LENGTH MISSING-IN) (COMMON-LISP:AND MISSING-IN MISSING-OUT) MISSING-OUT (COMMON-LISP:LENGTH MISSING-OUT)))) (COMMON-LISP:IF (COMMON-LISP:OR JUST-DONE (COMMON-LISP:AND ALL-PRESENT UP-TO-DATE-P (OPERATION-DONE-P O C) (COMMON-LISP:NOT (ACTION-FORCED-P PLAN O C)))) (COMMON-LISP:VALUES DONE-STAMP (COMMON-LISP:OR JUST-DONE OUT-OP (COMMON-LISP:AND OP-TIME (COMMON-LISP:EQL OP-TIME DONE-STAMP)))) (COMMON-LISP:VALUES COMMON-LISP:T COMMON-LISP:NIL)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC PLAN-RECORD-DEPENDENCY (PLAN OPERATION COMPONENT)) (COMMON-LISP:DEFGENERIC CALL-WHILE-VISITING-ACTION (PLAN OPERATION COMPONENT COMMON-LISP:FUNCTION) (:DOCUMENTATION "Detect circular dependencies")) (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :AFTER ((PLAN PLAN-TRAVERSAL) COMMON-LISP:&KEY FORCE FORCE-NOT SYSTEM COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:WITH-SLOTS (FORCED FORCED-NOT) PLAN (COMMON-LISP:SETF FORCED (NORMALIZE-FORCED-SYSTEMS FORCE SYSTEM)) (COMMON-LISP:SETF FORCED-NOT (NORMALIZE-FORCED-NOT-SYSTEMS FORCE-NOT SYSTEM)))) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF PLAN-ACTION-STATUS) (NEW-STATUS (PLAN PLAN-TRAVERSAL) (O OPERATION) (C COMPONENT)) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (NODE-FOR O C) (PLAN-VISITED-ACTIONS PLAN)) NEW-STATUS)) (COMMON-LISP:DEFMETHOD PLAN-ACTION-STATUS ((PLAN PLAN-TRAVERSAL) (O OPERATION) (C COMPONENT)) (COMMON-LISP:OR (COMMON-LISP:AND (ACTION-FORCED-NOT-P PLAN O C) (PLAN-ACTION-STATUS COMMON-LISP:NIL O C)) (COMMON-LISP:VALUES (COMMON-LISP:GETHASH (NODE-FOR O C) (PLAN-VISITED-ACTIONS PLAN))))) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN PLAN-TRAVERSAL) (O OPERATION) (S SYSTEM)) (COMMON-LISP:AND (COMMON-LISP:NOT (ACTION-FORCED-NOT-P PLAN O S)) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFMETHOD CALL-WHILE-VISITING-ACTION ((PLAN PLAN-TRAVERSAL) OPERATION COMPONENT FUN) (COMMON-LISP:WITH-ACCESSORS ((ACTION-SET PLAN-VISITING-ACTION-SET) (ACTION-LIST PLAN-VISITING-ACTION-LIST)) PLAN (COMMON-LISP:LET ((ACTION (COMMON-LISP:CONS OPERATION COMPONENT))) (COMMON-LISP:WHEN (COMMON-LISP:GETHASH ACTION ACTION-SET) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE CIRCULAR-DEPENDENCY) :ACTIONS (COMMON-LISP:MEMBER ACTION (COMMON-LISP:REVERSE ACTION-LIST) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (COMMON-LISP:SETF (COMMON-LISP:GETHASH ACTION ACTION-SET) COMMON-LISP:T) (COMMON-LISP:PUSH ACTION ACTION-LIST) (COMMON-LISP:UNWIND-PROTECT (COMMON-LISP:FUNCALL FUN) (COMMON-LISP:POP ACTION-LIST) (COMMON-LISP:SETF (COMMON-LISP:GETHASH ACTION ACTION-SET) COMMON-LISP:NIL))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION CIRCULAR-DEPENDENCY (SYSTEM-DEFINITION-ERROR) ((ACTIONS :INITARG :ACTIONS :READER CIRCULAR-DEPENDENCY-ACTIONS)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Circular dependency: ~3i~_~S~@:>") (CIRCULAR-DEPENDENCY-ACTIONS C))))) (COMMON-LISP:DEFMACRO WHILE-VISITING-ACTION ((P O C) COMMON-LISP:&BODY BODY) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CALL-WHILE-VISITING-ACTION) P O C (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:LAMBDA) COMMON-LISP:NIL BODY)))) (COMMON-LISP:DEFGENERIC TRAVERSE-ACTION (PLAN OPERATION COMPONENT NEEDED-IN-IMAGE-P)) (COMMON-LISP:DEFMETHOD TRAVERSE-ACTION (PLAN OPERATION COMPONENT NEEDED-IN-IMAGE-P) (COMMON-LISP:BLOCK COMMON-LISP:NIL (COMMON-LISP:UNLESS (ACTION-VALID-P PLAN OPERATION COMPONENT) (COMMON-LISP:RETURN COMMON-LISP:NIL)) (PLAN-RECORD-DEPENDENCY PLAN OPERATION COMPONENT) (COMMON-LISP:LET* ((ANIIP (NEEDED-IN-IMAGE-P OPERATION COMPONENT)) (ENIIP (COMMON-LISP:AND ANIIP NEEDED-IN-IMAGE-P)) (STATUS (PLAN-ACTION-STATUS PLAN OPERATION COMPONENT))) (COMMON-LISP:WHEN (COMMON-LISP:AND STATUS (COMMON-LISP:OR (ACTION-DONE-P STATUS) (ACTION-PLANNED-P STATUS) (COMMON-LISP:NOT ENIIP))) (COMMON-LISP:RETURN (ACTION-STAMP STATUS))) (COMMON-LISP:LABELS ((VISIT-ACTION (NIIP) (MAP-DIRECT-DEPENDENCIES PLAN OPERATION COMPONENT (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (O C) (TRAVERSE-ACTION PLAN O C NIIP)))) (COMMON-LISP:MULTIPLE-VALUE-BIND (STAMP DONE-P) (COMPUTE-ACTION-STAMP PLAN OPERATION COMPONENT) (COMMON-LISP:LET ((ADD-TO-PLAN-P (COMMON-LISP:OR (COMMON-LISP:EQL STAMP COMMON-LISP:T) (COMMON-LISP:AND NIIP (COMMON-LISP:NOT DONE-P))))) (COMMON-LISP:COND ((COMMON-LISP:AND ADD-TO-PLAN-P (COMMON-LISP:NOT NIIP)) (VISIT-ACTION COMMON-LISP:T)) (COMMON-LISP:T (COMMON-LISP:SETF (PLAN-ACTION-STATUS PLAN OPERATION COMPONENT) (COMMON-LISP:MAKE-INSTANCE (COMMON-LISP:QUOTE PLANNED-ACTION-STATUS) :STAMP STAMP :DONE-P (COMMON-LISP:AND DONE-P (COMMON-LISP:NOT ADD-TO-PLAN-P)) :PLANNED-P ADD-TO-PLAN-P :INDEX (COMMON-LISP:IF STATUS (ACTION-INDEX STATUS) (COMMON-LISP:INCF (PLAN-TOTAL-ACTION-COUNT PLAN))))) (COMMON-LISP:WHEN ADD-TO-PLAN-P (COMMON-LISP:INCF (PLAN-PLANNED-ACTION-COUNT PLAN)) (COMMON-LISP:UNLESS ANIIP (COMMON-LISP:INCF (PLAN-PLANNED-OUTPUT-ACTION-COUNT PLAN)))) STAMP)))))) (WHILE-VISITING-ACTION (PLAN OPERATION COMPONENT) (VISIT-ACTION ENIIP)))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS SEQUENTIAL-PLAN (PLAN-TRAVERSAL) ((ACTIONS-R :INITFORM COMMON-LISP:NIL :ACCESSOR PLAN-ACTIONS-R))) (COMMON-LISP:DEFGENERIC PLAN-ACTIONS (PLAN)) (COMMON-LISP:DEFMETHOD PLAN-ACTIONS ((PLAN COMMON-LISP:LIST)) PLAN) (COMMON-LISP:DEFMETHOD PLAN-ACTIONS ((PLAN SEQUENTIAL-PLAN)) (COMMON-LISP:REVERSE (PLAN-ACTIONS-R PLAN))) (COMMON-LISP:DEFMETHOD PLAN-RECORD-DEPENDENCY ((PLAN SEQUENTIAL-PLAN) (O OPERATION) (C COMPONENT)) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF PLAN-ACTION-STATUS) :AFTER (NEW-STATUS (P SEQUENTIAL-PLAN) (O OPERATION) (C COMPONENT)) (COMMON-LISP:WHEN (ACTION-PLANNED-P NEW-STATUS) (COMMON-LISP:PUSH (COMMON-LISP:CONS O C) (PLAN-ACTIONS-R P)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC MAKE-PLAN (PLAN-CLASS OPERATION COMPONENT COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (:DOCUMENTATION "Generate and return a plan for performing OPERATION on COMPONENT.")) (DEFINE-CONVENIENCE-ACTION-METHODS MAKE-PLAN (PLAN-CLASS OPERATION COMPONENT COMMON-LISP:&KEY)) (COMMON-LISP:DEFGENERIC PERFORM-PLAN (PLAN COMMON-LISP:&KEY)) (COMMON-LISP:DEFGENERIC PLAN-OPERATES-ON-P (PLAN COMPONENT)) (COMMON-LISP:DEFVAR *DEFAULT-PLAN-CLASS* (COMMON-LISP:QUOTE SEQUENTIAL-PLAN)) (COMMON-LISP:DEFMETHOD MAKE-PLAN (PLAN-CLASS (O OPERATION) (C COMPONENT) COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET ((PLAN (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-INSTANCE) (COMMON-LISP:OR PLAN-CLASS *DEFAULT-PLAN-CLASS*) :SYSTEM (COMPONENT-SYSTEM C) KEYS))) (TRAVERSE-ACTION PLAN O C COMMON-LISP:T) PLAN)) (COMMON-LISP:DEFMETHOD PERFORM-PLAN :AROUND ((PLAN COMMON-LISP:T) COMMON-LISP:&KEY) (COMMON-LISP:LET ((COMMON-LISP:*PACKAGE* COMMON-LISP:*PACKAGE*) (COMMON-LISP:*READTABLE* COMMON-LISP:*READTABLE*)) (COMMON-LISP:WITH-COMPILATION-UNIT COMMON-LISP:NIL (COMMON-LISP:CALL-NEXT-METHOD)))) (COMMON-LISP:DEFMETHOD PERFORM-PLAN ((PLAN COMMON-LISP:T) COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE PERFORM-PLAN) (PLAN-ACTIONS PLAN) KEYS)) (COMMON-LISP:DEFMETHOD PERFORM-PLAN ((STEPS COMMON-LISP:LIST) COMMON-LISP:&KEY FORCE COMMON-LISP:&ALLOW-OTHER-KEYS) (UIOP/COMMON-LISP::LOOP* :FOR (O . C) :IN STEPS :WHEN (COMMON-LISP:OR FORCE (COMMON-LISP:NOT (COMMON-LISP:NTH-VALUE 1 (COMPUTE-ACTION-STAMP COMMON-LISP:NIL O C)))) :DO (PERFORM-WITH-RESTARTS O C))) (COMMON-LISP:DEFMETHOD PLAN-OPERATES-ON-P ((PLAN PLAN-TRAVERSAL) (COMPONENT-PATH COMMON-LISP:LIST)) (PLAN-OPERATES-ON-P (PLAN-ACTIONS PLAN) COMPONENT-PATH)) (COMMON-LISP:DEFMETHOD PLAN-OPERATES-ON-P ((PLAN COMMON-LISP:LIST) (COMPONENT-PATH COMMON-LISP:LIST)) (COMMON-LISP:FIND COMPONENT-PATH (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE COMMON-LISP:CDR) PLAN) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL) :KEY (COMMON-LISP:QUOTE COMPONENT-FIND-PATH))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS FILTERED-SEQUENTIAL-PLAN (SEQUENTIAL-PLAN) ((ACTION-FILTER :INITFORM COMMON-LISP:T :INITARG :ACTION-FILTER :READER PLAN-ACTION-FILTER) (COMPONENT-TYPE :INITFORM COMMON-LISP:T :INITARG :COMPONENT-TYPE :READER PLAN-COMPONENT-TYPE) (KEEP-OPERATION :INITFORM COMMON-LISP:T :INITARG :KEEP-OPERATION :READER PLAN-KEEP-OPERATION) (KEEP-COMPONENT :INITFORM COMMON-LISP:T :INITARG :KEEP-COMPONENT :READER PLAN-KEEP-COMPONENT))) (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :AFTER ((PLAN FILTERED-SEQUENTIAL-PLAN) COMMON-LISP:&KEY FORCE FORCE-NOT OTHER-SYSTEMS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE FORCE-NOT)) (COMMON-LISP:WITH-SLOTS (FORCED FORCED-NOT ACTION-FILTER SYSTEM) PLAN (COMMON-LISP:SETF FORCED (NORMALIZE-FORCED-SYSTEMS (COMMON-LISP:IF OTHER-SYSTEMS :ALL COMMON-LISP:T) SYSTEM)) (COMMON-LISP:SETF FORCED-NOT (NORMALIZE-FORCED-NOT-SYSTEMS (COMMON-LISP:IF OTHER-SYSTEMS COMMON-LISP:NIL COMMON-LISP:T) SYSTEM)) (COMMON-LISP:SETF ACTION-FILTER (UIOP/UTILITY:ENSURE-FUNCTION ACTION-FILTER)))) (COMMON-LISP:DEFMETHOD ACTION-VALID-P ((PLAN FILTERED-SEQUENTIAL-PLAN) O C) (COMMON-LISP:AND (COMMON-LISP:FUNCALL (PLAN-ACTION-FILTER PLAN) O C) (COMMON-LISP:TYPEP C (PLAN-COMPONENT-TYPE PLAN)) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFMETHOD TRAVERSE-ACTIONS (ACTIONS COMMON-LISP:&REST KEYS COMMON-LISP:&KEY PLAN-CLASS COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET ((PLAN (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-INSTANCE) (COMMON-LISP:OR PLAN-CLASS (COMMON-LISP:QUOTE FILTERED-SEQUENTIAL-PLAN)) KEYS))) (UIOP/COMMON-LISP::LOOP* :FOR (O . C) :IN ACTIONS :DO (TRAVERSE-ACTION PLAN O C COMMON-LISP:T)) PLAN)) (DEFINE-CONVENIENCE-ACTION-METHODS TRAVERSE-SUB-ACTIONS (OPERATION COMPONENT COMMON-LISP:&KEY)) (COMMON-LISP:DEFMETHOD TRAVERSE-SUB-ACTIONS ((OPERATION OPERATION) (COMPONENT COMPONENT) COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE TRAVERSE-ACTIONS) (DIRECT-DEPENDENCIES COMMON-LISP:T OPERATION COMPONENT) :SYSTEM (COMPONENT-SYSTEM COMPONENT) KEYS)) (COMMON-LISP:DEFMETHOD PLAN-ACTIONS ((PLAN FILTERED-SEQUENTIAL-PLAN)) (COMMON-LISP:WITH-SLOTS (KEEP-OPERATION KEEP-COMPONENT) PLAN (UIOP/COMMON-LISP::LOOP* :FOR (O . C) :IN (COMMON-LISP:CALL-NEXT-METHOD) :WHEN (COMMON-LISP:AND (COMMON-LISP:TYPEP O KEEP-OPERATION) (COMMON-LISP:TYPEP C KEEP-COMPONENT)) :COLLECT (COMMON-LISP:CONS O C)))) (COMMON-LISP:DEFMETHOD REQUIRED-COMPONENTS (SYSTEM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY (GOAL-OPERATION (COMMON-LISP:QUOTE LOAD-OP)) COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:REMOVE-DUPLICATES (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE COMMON-LISP:CDR) (PLAN-ACTIONS (COMMON-LISP:APPLY (COMMON-LISP:QUOTE TRAVERSE-SUB-ACTIONS) GOAL-OPERATION SYSTEM (UIOP/UTILITY:REMOVE-PLIST-KEY :GOAL-OPERATION KEYS)))) :FROM-END COMMON-LISP:T)))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/OPERATE (:RECYCLE :ASDF/OPERATE :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/OPERATION :ASDF/ACTION :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/LISP-ACTION :ASDF/PLAN) (:EXPORT #:OPERATE #:OOS #:*SYSTEMS-BEING-OPERATED* #:BUILD-OP #:MAKE #:LOAD-SYSTEM #:LOAD-SYSTEMS #:LOAD-SYSTEMS* #:COMPILE-SYSTEM #:TEST-SYSTEM #:REQUIRE-SYSTEM #:*LOAD-SYSTEM-OPERATION* #:MODULE-PROVIDE-ASDF #:COMPONENT-LOADED-P #:ALREADY-LOADED-SYSTEMS))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/OPERATE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFGENERIC* (OPERATE) (OPERATION COMPONENT COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (:DOCUMENTATION "Operate does three things:
     [java]
     [java] 1. It creates an instance of OPERATION-CLASS using any keyword parameters as initargs.
     [java] 2. It finds the  asdf-system specified by SYSTEM (possibly loading it from disk).
     [java] 3. It then calls MAKE-PLAN with the operation and system as arguments
     [java]
     [java] The operation of making a plan is wrapped in WITH-COMPILATION-UNIT and error
     [java] handling code.  If a VERSION argument is supplied, then operate also ensures
     [java] that the system found satisfies it using the VERSION-SATISFIES method.
     [java]
     [java] Note that dependencies may cause the operation to invoke other operations on the system
     [java] or its components: the new operations will be created with the same initargs as the original one.
     [java]
     [java] The :FORCE or :FORCE-NOT argument to OPERATE can be:
     [java]   T to force the inside of the specified system to be rebuilt (resp. not),
     [java]     without recursively forcing the other systems we depend on.
     [java]   :ALL to force all systems including other systems we depend on to be rebuilt (resp. not).
     [java]   (SYSTEM1 SYSTEM2 ... SYSTEMN) to force systems named in a given list
     [java] :FORCE has precedence over :FORCE-NOT; builtin systems cannot be forced.")) (DEFINE-CONVENIENCE-ACTION-METHODS OPERATE (OPERATION COMPONENT COMMON-LISP:&KEY) :OPERATION-INITARGS COMMON-LISP:T :IF-NO-COMPONENT (COMMON-LISP:ERROR (COMMON-LISP:QUOTE MISSING-COMPONENT) :REQUIRES COMPONENT)) (COMMON-LISP:DEFVAR *SYSTEMS-BEING-OPERATED* COMMON-LISP:NIL "A boolean indicating that some systems are being operated on") (COMMON-LISP:DEFMETHOD OPERATE :AROUND (OPERATION COMPONENT COMMON-LISP:&REST KEYS COMMON-LISP:&KEY VERBOSE (ON-WARNINGS UIOP/LISP-BUILD:*COMPILE-FILE-WARNINGS-BEHAVIOUR*) (ON-FAILURE UIOP/LISP-BUILD:*COMPILE-FILE-FAILURE-BEHAVIOUR*) COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET* ((SYSTEMS-BEING-OPERATED *SYSTEMS-BEING-OPERATED*) (*SYSTEMS-BEING-OPERATED* (COMMON-LISP:OR SYSTEMS-BEING-OPERATED (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (OPERATION-REMAKER (COMMON-LISP:ETYPECASE OPERATION (OPERATION (COMMON-LISP:LET ((NAME (COMMON-LISP:TYPE-OF OPERATION)) (INITARGS (OPERATION-ORIGINAL-INITARGS OPERATION))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (COMMON-LISP:APPLY (COMMON-LISP:QUOTE MAKE-OPERATION) NAME :ORIGINAL-INITARGS INITARGS INITARGS))))) ((COMMON-LISP:OR COMMON-LISP:SYMBOL COMMON-LISP:STRING) (COMMON-LISP:CONSTANTLY OPERATION)))) (COMPONENT-PATH (COMMON-LISP:TYPECASE COMPONENT (COMPONENT (COMPONENT-FIND-PATH COMPONENT)) (COMMON-LISP:T COMPONENT)))) (COMMON-LISP:UNLESS SYSTEMS-BEING-OPERATED (COMMON-LISP:WHEN (UPGRADE-ASDF) (COMMON-LISP:RETURN-FROM OPERATE (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) (COMMON-LISP:FUNCALL OPERATION-REMAKER) COMPONENT-PATH KEYS)))) (WITH-ASDF-CACHE COMMON-LISP:NIL (COMMON-LISP:LET* ((*VERBOSE-OUT* (COMMON-LISP:AND VERBOSE COMMON-LISP:*STANDARD-OUTPUT*)) (UIOP/LISP-BUILD:*COMPILE-FILE-WARNINGS-BEHAVIOUR* ON-WARNINGS) (UIOP/LISP-BUILD:*COMPILE-FILE-FAILURE-BEHAVIOUR* ON-FAILURE)) (COMMON-LISP:CALL-NEXT-METHOD))))) (COMMON-LISP:DEFMETHOD OPERATE :BEFORE ((OPERATION OPERATION) (COMPONENT COMPONENT) COMMON-LISP:&KEY VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET ((SYSTEM (COMPONENT-SYSTEM COMPONENT))) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (COERCE-NAME SYSTEM) *SYSTEMS-BEING-OPERATED*) SYSTEM)) (COMMON-LISP:UNLESS (VERSION-SATISFIES COMPONENT VERSION) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE MISSING-COMPONENT-OF-VERSION) :REQUIRES COMPONENT :VERSION VERSION))) (COMMON-LISP:DEFMETHOD OPERATE ((OPERATION OPERATION) (COMPONENT COMPONENT) COMMON-LISP:&REST KEYS COMMON-LISP:&KEY PLAN-CLASS COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET ((PLAN (COMMON-LISP:APPLY (COMMON-LISP:QUOTE MAKE-PLAN) PLAN-CLASS OPERATION COMPONENT KEYS))) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE PERFORM-PLAN) PLAN KEYS) (COMMON-LISP:VALUES OPERATION PLAN))) (COMMON-LISP:DEFUN OOS (OPERATION COMPONENT COMMON-LISP:&REST ARGS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) OPERATION COMPONENT ARGS)) (COMMON-LISP:SETF (COMMON-LISP:DOCUMENTATION (COMMON-LISP:QUOTE OOS) (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION)) (COMMON-LISP:FORMAT COMMON-LISP:NIL "Short for _operate on system_ and an alias for the OPERATE function.~%~%~a" (COMMON-LISP:DOCUMENTATION (COMMON-LISP:QUOTE OPERATE) (COMMON-LISP:QUOTE COMMON-LISP:FUNCTION)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *LOAD-SYSTEM-OPERATION* (COMMON-LISP:QUOTE LOAD-OP) "Operation used by ASDF:LOAD-SYSTEM. By default, ASDF:LOAD-OP.
     [java] You may override it with e.g. ASDF:LOAD-FASL-OP from asdf-bundle
     [java] or ASDF:LOAD-SOURCE-OP if your fasl loading is somehow broken.
     [java]
     [java] The default operation may change in the future if we implement a
     [java] component-directed strategy for how to load or compile systems.") (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O PREPARE-OP) (S SYSTEM)) (COMMON-LISP:LOOP :FOR (O . CS) :IN (COMMON-LISP:CALL-NEXT-METHOD) :COLLECT (COMMON-LISP:CONS (COMMON-LISP:IF (COMMON-LISP:EQ O (COMMON-LISP:QUOTE LOAD-OP)) *LOAD-SYSTEM-OPERATION* O) CS))) (COMMON-LISP:DEFCLASS BUILD-OP (NON-PROPAGATING-OPERATION) COMMON-LISP:NIL (:DOCUMENTATION "Since ASDF3, BUILD-OP is the recommended 'master' operation,
     [java] to operate by default on a system or component, via the function BUILD.
     [java] Its meaning is configurable via the :BUILD-OPERATION option of a component.
     [java] which typically specifies the name of a specific operation to which to delegate the build,
     [java] as a symbol or as a string later read as a symbol (after loading the defsystem-depends-on);
     [java] if NIL is specified (the default), BUILD-OP falls back to the *LOAD-SYSTEM-OPERATION*
     [java] that will load the system in the current image, and its typically LOAD-OP.")) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O BUILD-OP) (C COMPONENT)) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (COMMON-LISP:OR (COMPONENT-BUILD-OPERATION C) *LOAD-SYSTEM-OPERATION*) C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFUN MAKE (SYSTEM COMMON-LISP:&REST KEYS) "The recommended way to interact with ASDF3.1 is via (ASDF:MAKE :FOO).
     [java] It will build system FOO using the operation BUILD-OP,
     [java] the meaning of which is configurable by the system, and
     [java] defaults to *LOAD-SYSTEM-OPERATION*, usually LOAD-OP,
     [java] to load it in current image." (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) (COMMON-LISP:QUOTE BUILD-OP) SYSTEM KEYS) COMMON-LISP:T) (COMMON-LISP:DEFUN LOAD-SYSTEM (SYSTEM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY FORCE FORCE-NOT VERBOSE VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) "Shorthand for `(operate 'asdf:load-op system)`. See OPERATE for details." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE FORCE-NOT VERBOSE VERSION)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) *LOAD-SYSTEM-OPERATION* SYSTEM KEYS) COMMON-LISP:T) (COMMON-LISP:DEFUN LOAD-SYSTEMS* (SYSTEMS COMMON-LISP:&REST KEYS) "Loading multiple systems at once." (COMMON-LISP:DOLIST (S SYSTEMS) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE LOAD-SYSTEM) S KEYS))) (COMMON-LISP:DEFUN LOAD-SYSTEMS (COMMON-LISP:&REST SYSTEMS) "Loading multiple systems at once." (LOAD-SYSTEMS* SYSTEMS)) (COMMON-LISP:DEFUN COMPILE-SYSTEM (SYSTEM COMMON-LISP:&REST ARGS COMMON-LISP:&KEY FORCE FORCE-NOT VERBOSE VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) "Shorthand for `(asdf:operate 'asdf:compile-op system)`. See OPERATE for details." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE FORCE-NOT VERBOSE VERSION)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) (COMMON-LISP:QUOTE COMPILE-OP) SYSTEM ARGS) COMMON-LISP:T) (COMMON-LISP:DEFUN TEST-SYSTEM (SYSTEM COMMON-LISP:&REST ARGS COMMON-LISP:&KEY FORCE FORCE-NOT VERBOSE VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) "Shorthand for `(asdf:operate 'asdf:test-op system)`. See OPERATE for details." (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE FORCE-NOT VERBOSE VERSION)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE OPERATE) (COMMON-LISP:QUOTE TEST-OP) SYSTEM ARGS) COMMON-LISP:T))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN COMPONENT-LOADED-P (COMPONENT) "has given COMPONENT been successfully loaded in the current image (yet)?" (ACTION-ALREADY-DONE-P COMMON-LISP:NIL (COMMON-LISP:MAKE-INSTANCE (COMMON-LISP:QUOTE LOAD-OP)) (FIND-COMPONENT COMPONENT COMMON-LISP:NIL))) (COMMON-LISP:DEFUN ALREADY-LOADED-SYSTEMS COMMON-LISP:NIL "return a list of the names of the systems that have been successfully loaded so far" (COMMON-LISP:REMOVE-IF-NOT (COMMON-LISP:QUOTE COMPONENT-LOADED-P) (REGISTERED-SYSTEMS))) (COMMON-LISP:DEFUN REQUIRE-SYSTEM (SYSTEM COMMON-LISP:&REST KEYS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) "Ensure the specified SYSTEM is loaded, passing the KEYS to OPERATE, but skip any update to the
     [java] system or its dependencies if they have already been loaded." (COMMON-LISP:APPLY (COMMON-LISP:QUOTE LOAD-SYSTEM) SYSTEM :FORCE-NOT (ALREADY-LOADED-SYSTEMS) KEYS)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *MODULES-BEING-REQUIRED* COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS REQUIRE-SYSTEM (SYSTEM) ((MODULE :INITARG :MODULE :INITFORM COMMON-LISP:NIL :ACCESSOR REQUIRED-MODULE)) (:DOCUMENTATION "A SYSTEM subclass whose processing is handled by
     [java] the implementation's REQUIRE rather than by internal ASDF mechanisms.")) (COMMON-LISP:DEFMETHOD PERFORM ((O COMPILE-OP) (C REQUIRE-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-OP) (S REQUIRE-SYSTEM)) (COMMON-LISP:LET* ((MODULE (COMMON-LISP:OR (REQUIRED-MODULE S) (COERCE-NAME S))) (*MODULES-BEING-REQUIRED* (COMMON-LISP:CONS MODULE *MODULES-BEING-REQUIRED*))) (COMMON-LISP:ASSERT (COMMON-LISP:NULL (COMPONENT-CHILDREN S))) (COMMON-LISP:REQUIRE MODULE))) (COMMON-LISP:DEFMETHOD RESOLVE-DEPENDENCY-COMBINATION (COMPONENT (COMBINATOR (COMMON-LISP:EQL :REQUIRE)) ARGUMENTS) (COMMON-LISP:UNLESS (UIOP/UTILITY:LENGTH=N-P ARGUMENTS 1) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Bad dependency ~S for ~S. ~S takes only one argument~@:>") (COMMON-LISP:CONS COMBINATOR ARGUMENTS) COMPONENT COMBINATOR)) (COMMON-LISP:LET* ((MODULE (COMMON-LISP:CAR ARGUMENTS)) (NAME (COMMON-LISP:STRING-DOWNCASE MODULE)) (SYSTEM (FIND-SYSTEM NAME COMMON-LISP:NIL))) (COMMON-LISP:ASSERT MODULE) (COMMON-LISP:OR SYSTEM (COMMON-LISP:LET ((SYSTEM (COMMON-LISP:MAKE-INSTANCE (COMMON-LISP:QUOTE REQUIRE-SYSTEM) :NAME NAME))) (REGISTER-SYSTEM SYSTEM) SYSTEM)))) (COMMON-LISP:DEFUN MODULE-PROVIDE-ASDF (NAME) (COMMON-LISP:LET ((MODULE (COMMON-LISP:STRING-DOWNCASE NAME))) (COMMON-LISP:UNLESS (COMMON-LISP:MEMBER MODULE *MODULES-BEING-REQUIRED* :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)) (COMMON-LISP:LET ((*MODULES-BEING-REQUIRED* (COMMON-LISP:CONS MODULE *MODULES-BEING-REQUIRED*))) (COMMON-LISP:HANDLER-BIND ((COMMON-LISP:STYLE-WARNING (COMMON-LISP:FUNCTION COMMON-LISP:MUFFLE-WARNING)) (MISSING-COMPONENT (COMMON-LISP:CONSTANTLY COMMON-LISP:NIL)) (COMMON-LISP:ERROR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (E) (COMMON-LISP:FORMAT COMMON-LISP:*ERROR-OUTPUT* (UIOP/COMMON-LISP::COMPATFMT "~@<ASDF could not load ~(~A~) because ~A.~@:>~%") NAME E))))) (COMMON-LISP:LET ((*VERBOSE-OUT* (COMMON-LISP:MAKE-BROADCAST-STREAM))) (COMMON-LISP:LET ((SYSTEM (FIND-SYSTEM MODULE COMMON-LISP:NIL))) (COMMON-LISP:WHEN SYSTEM (REQUIRE-SYSTEM SYSTEM :VERBOSE COMMON-LISP:NIL) COMMON-LISP:T)))))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN RESTART-UPGRADED-ASDF COMMON-LISP:NIL (COMMON-LISP:WHEN *ASDF-CACHE* (COMMON-LISP:LET ((L (COMMON-LISP:LOOP :FOR K :BEING :THE HASH-KEYS :OF *ASDF-CACHE* :WHEN (COMMON-LISP:EQ (COMMON-LISP:FIRST K) (COMMON-LISP:QUOTE FIND-SYSTEM)) :COLLECT (COMMON-LISP:SECOND K)))) (COMMON-LISP:CLRHASH *ASDF-CACHE*) (COMMON-LISP:DOLIST (S L) (FIND-SYSTEM S COMMON-LISP:NIL))))) (UIOP/UTILITY:REGISTER-HOOK-FUNCTION (COMMON-LISP:QUOTE *POST-UPGRADE-RESTART-HOOK*) (COMMON-LISP:QUOTE RESTART-UPGRADED-ASDF)))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/OUTPUT-TRANSLATIONS (:RECYCLE :ASDF/OUTPUT-TRANSLATIONS :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE) (:EXPORT #:*OUTPUT-TRANSLATIONS* #:*OUTPUT-TRANSLATIONS-PARAMETER* #:INVALID-OUTPUT-TRANSLATION #:OUTPUT-TRANSLATIONS #:OUTPUT-TRANSLATIONS-INITIALIZED-P #:INITIALIZE-OUTPUT-TRANSLATIONS #:CLEAR-OUTPUT-TRANSLATIONS #:DISABLE-OUTPUT-TRANSLATIONS #:ENSURE-OUTPUT-TRANSLATIONS #:APPLY-OUTPUT-TRANSLATIONS #:VALIDATE-OUTPUT-TRANSLATIONS-DIRECTIVE #:VALIDATE-OUTPUT-TRANSLATIONS-FORM #:VALIDATE-OUTPUT-TRANSLATIONS-FILE #:VALIDATE-OUTPUT-TRANSLATIONS-DIRECTORY #:PARSE-OUTPUT-TRANSLATIONS-STRING #:WRAPPING-OUTPUT-TRANSLATIONS #:USER-OUTPUT-TRANSLATIONS-PATHNAME #:SYSTEM-OUTPUT-TRANSLATIONS-PATHNAME #:USER-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME #:SYSTEM-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME #:ENVIRONMENT-OUTPUT-TRANSLATIONS #:PROCESS-OUTPUT-TRANSLATIONS #:COMPUTE-OUTPUT-TRANSLATIONS #:TRANSLATE-JAR-PATHNAME))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/OUTPUT-TRANSLATIONS)
     [java] ; (WHEN-UPGRADING COMMON-LISP:NIL (UIOP/UTILITY:UNDEFINE-FUNCTION (COMMON-LISP:QUOTE (COMMON-LISP:SETF OUTPUT-TRANSLATIONS))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION INVALID-OUTPUT-TRANSLATION (UIOP/CONFIGURATION:INVALID-CONFIGURATION COMMON-LISP:WARNING) ((COMMON-LISP:FORMAT :INITFORM (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid asdf output-translation ~S~@[ in ~S~]~@{ ~@?~}~@:>")))) (COMMON-LISP:DEFVAR *OUTPUT-TRANSLATIONS* COMMON-LISP:NIL "Either NIL (for uninitialized), or a list of one element,
     [java] said element itself being a sorted list of mappings.
     [java] Each mapping is a pair of a source pathname and destination pathname,
     [java] and the order is by decreasing length of namestring of the source pathname.") (COMMON-LISP:DEFUN OUTPUT-TRANSLATIONS COMMON-LISP:NIL (COMMON-LISP:CAR *OUTPUT-TRANSLATIONS*)) (COMMON-LISP:DEFUN SET-OUTPUT-TRANSLATIONS (NEW-VALUE) (COMMON-LISP:SETF *OUTPUT-TRANSLATIONS* (COMMON-LISP:LIST (COMMON-LISP:STABLE-SORT (COMMON-LISP:COPY-LIST NEW-VALUE) (COMMON-LISP:FUNCTION COMMON-LISP:>) :KEY (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:ETYPECASE (COMMON-LISP:CAR X) ((COMMON-LISP:EQL COMMON-LISP:T) -1) (COMMON-LISP:PATHNAME (COMMON-LISP:LET ((COMMON-LISP:DIRECTORY (COMMON-LISP:PATHNAME-DIRECTORY (COMMON-LISP:CAR X)))) (COMMON-LISP:IF (COMMON-LISP:LISTP COMMON-LISP:DIRECTORY) (COMMON-LISP:LENGTH COMMON-LISP:DIRECTORY) 0))))))))) NEW-VALUE) (UIOP/UTILITY:DEFUN* ((COMMON-LISP:SETF OUTPUT-TRANSLATIONS)) (NEW-VALUE) (SET-OUTPUT-TRANSLATIONS NEW-VALUE)) (COMMON-LISP:DEFUN OUTPUT-TRANSLATIONS-INITIALIZED-P COMMON-LISP:NIL (COMMON-LISP:AND *OUTPUT-TRANSLATIONS* COMMON-LISP:T)) (COMMON-LISP:DEFUN CLEAR-OUTPUT-TRANSLATIONS COMMON-LISP:NIL "Undoes any initialization of the output translations." (COMMON-LISP:SETF *OUTPUT-TRANSLATIONS* (COMMON-LISP:QUOTE COMMON-LISP:NIL)) (COMMON-LISP:VALUES)) (UIOP/CONFIGURATION:REGISTER-CLEAR-CONFIGURATION-HOOK (COMMON-LISP:QUOTE CLEAR-OUTPUT-TRANSLATIONS)) (COMMON-LISP:DEFUN VALIDATE-OUTPUT-TRANSLATIONS-DIRECTIVE (DIRECTIVE) (COMMON-LISP:OR (COMMON-LISP:MEMBER DIRECTIVE (COMMON-LISP:QUOTE (:ENABLE-USER-CACHE :DISABLE-CACHE COMMON-LISP:NIL))) (COMMON-LISP:AND (COMMON-LISP:CONSP DIRECTIVE) (COMMON-LISP:OR (COMMON-LISP:AND (UIOP/UTILITY:LENGTH=N-P DIRECTIVE 2) (COMMON-LISP:OR (COMMON-LISP:AND (COMMON-LISP:EQ (COMMON-LISP:FIRST DIRECTIVE) :INCLUDE) (COMMON-LISP:TYPEP (COMMON-LISP:SECOND DIRECTIVE) (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:PATHNAME COMMON-LISP:NULL)))) (COMMON-LISP:AND (UIOP/CONFIGURATION:LOCATION-DESIGNATOR-P (COMMON-LISP:FIRST DIRECTIVE)) (COMMON-LISP:OR (UIOP/CONFIGURATION:LOCATION-DESIGNATOR-P (COMMON-LISP:SECOND DIRECTIVE)) (UIOP/CONFIGURATION:LOCATION-FUNCTION-P (COMMON-LISP:SECOND DIRECTIVE)))))) (COMMON-LISP:AND (UIOP/UTILITY:LENGTH=N-P DIRECTIVE 1) (UIOP/CONFIGURATION:LOCATION-DESIGNATOR-P (COMMON-LISP:FIRST DIRECTIVE))))))) (COMMON-LISP:DEFUN VALIDATE-OUTPUT-TRANSLATIONS-FORM (FORM COMMON-LISP:&KEY LOCATION) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-FORM FORM :OUTPUT-TRANSLATIONS (COMMON-LISP:QUOTE VALIDATE-OUTPUT-TRANSLATIONS-DIRECTIVE) :LOCATION LOCATION :INVALID-FORM-REPORTER (COMMON-LISP:QUOTE INVALID-OUTPUT-TRANSLATION))) (COMMON-LISP:DEFUN VALIDATE-OUTPUT-TRANSLATIONS-FILE (FILE) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-FILE FILE (COMMON-LISP:QUOTE VALIDATE-OUTPUT-TRANSLATIONS-FORM) :DESCRIPTION "output translations")) (COMMON-LISP:DEFUN VALIDATE-OUTPUT-TRANSLATIONS-DIRECTORY (COMMON-LISP:DIRECTORY) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-DIRECTORY COMMON-LISP:DIRECTORY :OUTPUT-TRANSLATIONS (COMMON-LISP:QUOTE VALIDATE-OUTPUT-TRANSLATIONS-DIRECTIVE) :INVALID-FORM-REPORTER (COMMON-LISP:QUOTE INVALID-OUTPUT-TRANSLATION))) (COMMON-LISP:DEFUN PARSE-OUTPUT-TRANSLATIONS-STRING (COMMON-LISP:STRING COMMON-LISP:&KEY LOCATION) (COMMON-LISP:COND ((COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:STRING) (COMMON-LISP:EQUAL COMMON-LISP:STRING "")) (COMMON-LISP:QUOTE (:OUTPUT-TRANSLATIONS :INHERIT-CONFIGURATION))) ((COMMON-LISP:NOT (COMMON-LISP:STRINGP COMMON-LISP:STRING)) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Environment string isn't: ~3i~_~S~@:>") COMMON-LISP:STRING)) ((COMMON-LISP:EQL (COMMON-LISP:CHAR COMMON-LISP:STRING 0) #\") (PARSE-OUTPUT-TRANSLATIONS-STRING (COMMON-LISP:READ-FROM-STRING COMMON-LISP:STRING) :LOCATION LOCATION)) ((COMMON-LISP:EQL (COMMON-LISP:CHAR COMMON-LISP:STRING 0) #\() (VALIDATE-OUTPUT-TRANSLATIONS-FORM (COMMON-LISP:READ-FROM-STRING COMMON-LISP:STRING) :LOCATION LOCATION)) (COMMON-LISP:T (COMMON-LISP:LOOP :WITH INHERIT COMMON-LISP:= COMMON-LISP:NIL :WITH DIRECTIVES COMMON-LISP:= COMMON-LISP:NIL :WITH START COMMON-LISP:= 0 :WITH END COMMON-LISP:= (COMMON-LISP:LENGTH COMMON-LISP:STRING) :WITH SOURCE COMMON-LISP:= COMMON-LISP:NIL :WITH SEPARATOR COMMON-LISP:= (UIOP/FILESYSTEM:INTER-DIRECTORY-SEPARATOR) :FOR I COMMON-LISP:= (COMMON-LISP:OR (COMMON-LISP:POSITION SEPARATOR COMMON-LISP:STRING :START START) END) :DO (COMMON-LISP:LET ((S (COMMON-LISP:SUBSEQ COMMON-LISP:STRING START I))) (COMMON-LISP:COND (SOURCE (COMMON-LISP:PUSH (COMMON-LISP:LIST SOURCE (COMMON-LISP:IF (COMMON-LISP:EQUAL "" S) COMMON-LISP:NIL S)) DIRECTIVES) (COMMON-LISP:SETF SOURCE COMMON-LISP:NIL)) ((COMMON-LISP:EQUAL "" S) (COMMON-LISP:WHEN INHERIT (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Only one inherited configuration allowed: ~3i~_~S~@:>") COMMON-LISP:STRING)) (COMMON-LISP:SETF INHERIT COMMON-LISP:T) (COMMON-LISP:PUSH :INHERIT-CONFIGURATION DIRECTIVES)) (COMMON-LISP:T (COMMON-LISP:SETF SOURCE S))) (COMMON-LISP:SETF START (COMMON-LISP:1+ I)) (COMMON-LISP:WHEN (COMMON-LISP:> START END) (COMMON-LISP:WHEN SOURCE (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Uneven number of components in source to destination mapping: ~3i~_~S~@:>") COMMON-LISP:STRING)) (COMMON-LISP:UNLESS INHERIT (COMMON-LISP:PUSH :IGNORE-INHERITED-CONFIGURATION DIRECTIVES)) (COMMON-LISP:RETURN (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :OUTPUT-TRANSLATIONS) (COMMON-LISP:NREVERSE DIRECTIVES))))))))) (DEFPARAMETER* *DEFAULT-OUTPUT-TRANSLATIONS* (COMMON-LISP:QUOTE (ENVIRONMENT-OUTPUT-TRANSLATIONS USER-OUTPUT-TRANSLATIONS-PATHNAME USER-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME SYSTEM-OUTPUT-TRANSLATIONS-PATHNAME SYSTEM-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME))) (COMMON-LISP:DEFUN WRAPPING-OUTPUT-TRANSLATIONS COMMON-LISP:NIL (COMMON-LISP:QUOTE (:OUTPUT-TRANSLATIONS :INHERIT-CONFIGURATION (#P"/___jar___file___root___/**/*.*" (:USER-CACHE #P"**/*.*")) (#P"jar:file:/**/*.jar!/**/*.*" (:FUNCTION TRANSLATE-JAR-PATHNAME)) :ENABLE-USER-CACHE))) (COMMON-LISP:DEFPARAMETER *OUTPUT-TRANSLATIONS-FILE* (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING "common-lisp/asdf-output-translations.conf")) (COMMON-LISP:DEFPARAMETER *OUTPUT-TRANSLATIONS-DIRECTORY* (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING "common-lisp/asdf-output-translations.conf.d/")) (COMMON-LISP:DEFUN USER-OUTPUT-TRANSLATIONS-PATHNAME (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:XDG-CONFIG-PATHNAME *OUTPUT-TRANSLATIONS-FILE* DIRECTION)) (COMMON-LISP:DEFUN SYSTEM-OUTPUT-TRANSLATIONS-PATHNAME (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:FIND-PREFERRED-FILE (UIOP/CONFIGURATION:SYSTEM-CONFIG-PATHNAMES *OUTPUT-TRANSLATIONS-FILE*) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN USER-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:XDG-CONFIG-PATHNAME *OUTPUT-TRANSLATIONS-DIRECTORY* DIRECTION)) (COMMON-LISP:DEFUN SYSTEM-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:FIND-PREFERRED-FILE (UIOP/CONFIGURATION:SYSTEM-CONFIG-PATHNAMES *OUTPUT-TRANSLATIONS-DIRECTORY*) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN ENVIRONMENT-OUTPUT-TRANSLATIONS COMMON-LISP:NIL (UIOP/OS:GETENV "ASDF_OUTPUT_TRANSLATIONS")) (COMMON-LISP:DEFGENERIC PROCESS-OUTPUT-TRANSLATIONS (SPEC COMMON-LISP:&KEY INHERIT COLLECT)) (COMMON-LISP:DEFUN INHERIT-OUTPUT-TRANSLATIONS (INHERIT COMMON-LISP:&KEY COLLECT) (COMMON-LISP:WHEN INHERIT (PROCESS-OUTPUT-TRANSLATIONS (COMMON-LISP:FIRST INHERIT) :COLLECT COLLECT :INHERIT (COMMON-LISP:REST INHERIT)))) (UIOP/UTILITY:DEFUN* (PROCESS-OUTPUT-TRANSLATIONS-DIRECTIVE) (DIRECTIVE COMMON-LISP:&KEY INHERIT COLLECT) (COMMON-LISP:IF (COMMON-LISP:ATOM DIRECTIVE) (COMMON-LISP:ECASE DIRECTIVE ((:ENABLE-USER-CACHE) (PROCESS-OUTPUT-TRANSLATIONS-DIRECTIVE (COMMON-LISP:QUOTE (COMMON-LISP:T :USER-CACHE)) :COLLECT COLLECT)) ((:DISABLE-CACHE) (PROCESS-OUTPUT-TRANSLATIONS-DIRECTIVE (COMMON-LISP:QUOTE (COMMON-LISP:T COMMON-LISP:T)) :COLLECT COLLECT)) ((:INHERIT-CONFIGURATION) (INHERIT-OUTPUT-TRANSLATIONS INHERIT :COLLECT COLLECT)) ((:IGNORE-INHERITED-CONFIGURATION :IGNORE-INVALID-ENTRIES COMMON-LISP:NIL) COMMON-LISP:NIL)) (COMMON-LISP:LET ((SRC (COMMON-LISP:FIRST DIRECTIVE)) (DST (COMMON-LISP:SECOND DIRECTIVE))) (COMMON-LISP:IF (COMMON-LISP:EQ SRC :INCLUDE) (COMMON-LISP:WHEN DST (PROCESS-OUTPUT-TRANSLATIONS (COMMON-LISP:PATHNAME DST) :INHERIT COMMON-LISP:NIL :COLLECT COLLECT)) (COMMON-LISP:WHEN SRC (COMMON-LISP:LET ((TRUSRC (COMMON-LISP:OR (COMMON-LISP:EQL SRC COMMON-LISP:T) (COMMON-LISP:LET ((LOC (UIOP/CONFIGURATION:RESOLVE-LOCATION SRC :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:T))) (COMMON-LISP:IF (UIOP/PATHNAME:ABSOLUTE-PATHNAME-P LOC) (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* LOC) LOC))))) (COMMON-LISP:COND ((UIOP/CONFIGURATION:LOCATION-FUNCTION-P DST) (COMMON-LISP:FUNCALL COLLECT (COMMON-LISP:LIST TRUSRC (UIOP/UTILITY:ENSURE-FUNCTION (COMMON-LISP:SECOND DST))))) ((COMMON-LISP:TYPEP DST (COMMON-LISP:QUOTE COMMON-LISP:BOOLEAN)) (COMMON-LISP:FUNCALL COLLECT (COMMON-LISP:LIST TRUSRC COMMON-LISP:T))) (COMMON-LISP:T (COMMON-LISP:LET* ((TRUDST (UIOP/CONFIGURATION:RESOLVE-LOCATION DST :ENSURE-DIRECTORY COMMON-LISP:T :WILDEN COMMON-LISP:T))) (COMMON-LISP:FUNCALL COLLECT (COMMON-LISP:LIST TRUDST COMMON-LISP:T)) (COMMON-LISP:FUNCALL COLLECT (COMMON-LISP:LIST TRUSRC TRUDST))))))))))) (COMMON-LISP:DEFMETHOD PROCESS-OUTPUT-TRANSLATIONS ((X COMMON-LISP:SYMBOL) COMMON-LISP:&KEY (INHERIT *DEFAULT-OUTPUT-TRANSLATIONS*) COLLECT) (PROCESS-OUTPUT-TRANSLATIONS (COMMON-LISP:FUNCALL X) :INHERIT INHERIT :COLLECT COLLECT)) (COMMON-LISP:DEFMETHOD PROCESS-OUTPUT-TRANSLATIONS ((COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME) COMMON-LISP:&KEY INHERIT COLLECT) (COMMON-LISP:COND ((UIOP/PATHNAME:DIRECTORY-PATHNAME-P COMMON-LISP:PATHNAME) (PROCESS-OUTPUT-TRANSLATIONS (VALIDATE-OUTPUT-TRANSLATIONS-DIRECTORY COMMON-LISP:PATHNAME) :INHERIT INHERIT :COLLECT COLLECT)) ((UIOP/FILESYSTEM:PROBE-FILE* COMMON-LISP:PATHNAME :TRUENAME UIOP/FILESYSTEM:*RESOLVE-SYMLINKS*) (PROCESS-OUTPUT-TRANSLATIONS (VALIDATE-OUTPUT-TRANSLATIONS-FILE COMMON-LISP:PATHNAME) :INHERIT INHERIT :COLLECT COLLECT)) (COMMON-LISP:T (INHERIT-OUTPUT-TRANSLATIONS INHERIT :COLLECT COLLECT)))) (COMMON-LISP:DEFMETHOD PROCESS-OUTPUT-TRANSLATIONS ((COMMON-LISP:STRING COMMON-LISP:STRING) COMMON-LISP:&KEY INHERIT COLLECT) (PROCESS-OUTPUT-TRANSLATIONS (PARSE-OUTPUT-TRANSLATIONS-STRING COMMON-LISP:STRING) :INHERIT INHERIT :COLLECT COLLECT)) (COMMON-LISP:DEFMETHOD PROCESS-OUTPUT-TRANSLATIONS ((X COMMON-LISP:NULL) COMMON-LISP:&KEY INHERIT COLLECT) (INHERIT-OUTPUT-TRANSLATIONS INHERIT :COLLECT COLLECT)) (COMMON-LISP:DEFMETHOD PROCESS-OUTPUT-TRANSLATIONS ((FORM COMMON-LISP:CONS) COMMON-LISP:&KEY INHERIT COLLECT) (COMMON-LISP:DOLIST (DIRECTIVE (COMMON-LISP:CDR (VALIDATE-OUTPUT-TRANSLATIONS-FORM FORM))) (PROCESS-OUTPUT-TRANSLATIONS-DIRECTIVE DIRECTIVE :INHERIT INHERIT :COLLECT COLLECT))) (COMMON-LISP:DEFUN COMPUTE-OUTPUT-TRANSLATIONS (COMMON-LISP:&OPTIONAL PARAMETER) "read the configuration, return it" (COMMON-LISP:REMOVE-DUPLICATES (UIOP/UTILITY:WHILE-COLLECTING (C) (INHERIT-OUTPUT-TRANSLATIONS (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE WRAPPING-OUTPUT-TRANSLATIONS) PARAMETER *DEFAULT-OUTPUT-TRANSLATIONS*) :COLLECT (COMMON-LISP:FUNCTION C))) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL) :FROM-END COMMON-LISP:T)) (COMMON-LISP:DEFVAR *OUTPUT-TRANSLATIONS-PARAMETER* COMMON-LISP:NIL) (COMMON-LISP:DEFUN INITIALIZE-OUTPUT-TRANSLATIONS (COMMON-LISP:&OPTIONAL (PARAMETER *OUTPUT-TRANSLATIONS-PARAMETER*)) "read the configuration, initialize the internal configuration variable,
     [java] return the configuration" (COMMON-LISP:SETF *OUTPUT-TRANSLATIONS-PARAMETER* PARAMETER (OUTPUT-TRANSLATIONS) (COMPUTE-OUTPUT-TRANSLATIONS PARAMETER))) (COMMON-LISP:DEFUN DISABLE-OUTPUT-TRANSLATIONS COMMON-LISP:NIL "Initialize output translations in a way that maps every file to itself,
     [java] effectively disabling the output translation facility." (INITIALIZE-OUTPUT-TRANSLATIONS (COMMON-LISP:QUOTE (:OUTPUT-TRANSLATIONS :DISABLE-CACHE :IGNORE-INHERITED-CONFIGURATION)))) (COMMON-LISP:DEFUN ENSURE-OUTPUT-TRANSLATIONS COMMON-LISP:NIL (COMMON-LISP:IF (OUTPUT-TRANSLATIONS-INITIALIZED-P) (OUTPUT-TRANSLATIONS) (INITIALIZE-OUTPUT-TRANSLATIONS))) (UIOP/UTILITY:DEFUN* (APPLY-OUTPUT-TRANSLATIONS) (PATH) (COMMON-LISP:ETYPECASE PATH (COMMON-LISP:LOGICAL-PATHNAME PATH) ((COMMON-LISP:OR COMMON-LISP:PATHNAME COMMON-LISP:STRING) (ENSURE-OUTPUT-TRANSLATIONS) (UIOP/COMMON-LISP::LOOP* :WITH P COMMON-LISP:= (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* PATH) :FOR (SOURCE DESTINATION) :IN (COMMON-LISP:CAR *OUTPUT-TRANSLATIONS*) :FOR ROOT COMMON-LISP:= (COMMON-LISP:WHEN (COMMON-LISP:OR (COMMON-LISP:EQ SOURCE COMMON-LISP:T) (COMMON-LISP:AND (COMMON-LISP:PATHNAMEP SOURCE) (COMMON-LISP:NOT (UIOP/PATHNAME:ABSOLUTE-PATHNAME-P SOURCE)))) (UIOP/PATHNAME:PATHNAME-ROOT P)) :FOR ABSOLUTE-SOURCE COMMON-LISP:= (COMMON-LISP:COND ((COMMON-LISP:EQ SOURCE COMMON-LISP:T) (UIOP/PATHNAME:WILDEN ROOT)) (ROOT (UIOP/PATHNAME:MERGE-PATHNAMES* SOURCE ROOT)) (COMMON-LISP:T SOURCE)) :WHEN (COMMON-LISP:OR (COMMON-LISP:EQ SOURCE COMMON-LISP:T) (COMMON-LISP:PATHNAME-MATCH-P P ABSOLUTE-SOURCE)) :RETURN (UIOP/PATHNAME:TRANSLATE-PATHNAME* P ABSOLUTE-SOURCE DESTINATION ROOT SOURCE) :FINALLY (COMMON-LISP:RETURN P))))) (COMMON-LISP:SETF UIOP/PATHNAME:*OUTPUT-TRANSLATION-FUNCTION* (COMMON-LISP:QUOTE APPLY-OUTPUT-TRANSLATIONS)) (COMMON-LISP:DEFUN TRANSLATE-JAR-PATHNAME (SOURCE WILDCARD) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE WILDCARD)) (COMMON-LISP:FLET ((NORMALIZE-DEVICE (COMMON-LISP:PATHNAME) (COMMON-LISP:IF (COMMON-LISP:FIND :WINDOWS COMMON-LISP:*FEATURES*) COMMON-LISP:PATHNAME (COMMON-LISP:MAKE-PATHNAME :DEFAULTS COMMON-LISP:PATHNAME :DEVICE :UNSPECIFIC)))) (COMMON-LISP:LET* ((JAR (COMMON-LISP:PATHNAME (COMMON-LISP:FIRST (COMMON-LISP:PATHNAME-DEVICE SOURCE)))) (TARGET-ROOT-DIRECTORY-NAMESTRING (COMMON-LISP:FORMAT COMMON-LISP:NIL "/___jar___file___root___/~@[~A/~]" (COMMON-LISP:AND (COMMON-LISP:FIND :WINDOWS COMMON-LISP:*FEATURES*) (COMMON-LISP:PATHNAME-DEVICE JAR)))) (RELATIVE-SOURCE (UIOP/PATHNAME:RELATIVIZE-PATHNAME-DIRECTORY SOURCE)) (RELATIVE-JAR (UIOP/PATHNAME:RELATIVIZE-PATHNAME-DIRECTORY (UIOP/PATHNAME:ENSURE-DIRECTORY-PATHNAME JAR))) (TARGET-ROOT-DIRECTORY (NORMALIZE-DEVICE (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (COMMON-LISP:PARSE-NAMESTRING TARGET-ROOT-DIRECTORY-NAMESTRING)))) (TARGET-ROOT (UIOP/PATHNAME:MERGE-PATHNAMES* RELATIVE-JAR TARGET-ROOT-DIRECTORY)) (TARGET (UIOP/PATHNAME:MERGE-PATHNAMES* RELATIVE-SOURCE TARGET-ROOT))) (NORMALIZE-DEVICE (APPLY-OUTPUT-TRANSLATIONS TARGET))))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/SOURCE-REGISTRY (:RECYCLE :ASDF/SOURCE-REGISTRY :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/FIND-SYSTEM) (:EXPORT #:*SOURCE-REGISTRY-PARAMETER* #:*DEFAULT-SOURCE-REGISTRIES* #:INVALID-SOURCE-REGISTRY #:SOURCE-REGISTRY-INITIALIZED-P #:INITIALIZE-SOURCE-REGISTRY #:CLEAR-SOURCE-REGISTRY #:*SOURCE-REGISTRY* #:ENSURE-SOURCE-REGISTRY #:*SOURCE-REGISTRY-PARAMETER* #:*DEFAULT-SOURCE-REGISTRY-EXCLUSIONS* #:*SOURCE-REGISTRY-EXCLUSIONS* #:*WILD-ASD* #:DIRECTORY-ASD-FILES #:REGISTER-ASD-DIRECTORY #:*RECURSE-BEYOND-ASDS* #:COLLECT-ASDS-IN-DIRECTORY #:COLLECT-SUB*DIRECTORIES-ASD-FILES #:VALIDATE-SOURCE-REGISTRY-DIRECTIVE #:VALIDATE-SOURCE-REGISTRY-FORM #:VALIDATE-SOURCE-REGISTRY-FILE #:VALIDATE-SOURCE-REGISTRY-DIRECTORY #:PARSE-SOURCE-REGISTRY-STRING #:WRAPPING-SOURCE-REGISTRY #:DEFAULT-USER-SOURCE-REGISTRY #:DEFAULT-SYSTEM-SOURCE-REGISTRY #:USER-SOURCE-REGISTRY #:SYSTEM-SOURCE-REGISTRY #:USER-SOURCE-REGISTRY-DIRECTORY #:SYSTEM-SOURCE-REGISTRY-DIRECTORY #:ENVIRONMENT-SOURCE-REGISTRY #:PROCESS-SOURCE-REGISTRY #:INHERIT-SOURCE-REGISTRY #:COMPUTE-SOURCE-REGISTRY #:FLATTEN-SOURCE-REGISTRY #:SYSDEF-SOURCE-REGISTRY-SEARCH))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/SOURCE-REGISTRY)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION INVALID-SOURCE-REGISTRY (UIOP/CONFIGURATION:INVALID-CONFIGURATION COMMON-LISP:WARNING) ((COMMON-LISP:FORMAT :INITFORM (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid source registry ~S~@[ in ~S~]~@{ ~@?~}~@:>")))) (COMMON-LISP:DEFVAR *DEFAULT-SOURCE-REGISTRY-EXCLUSIONS* (COMMON-LISP:QUOTE (".bzr" ".cdv" ".git" ".hg" ".pc" ".svn" "CVS" "RCS" "SCCS" "_darcs" "_sgbak" "autom4te.cache" "cover_db" "_build" "debian"))) (COMMON-LISP:DEFVAR *SOURCE-REGISTRY-EXCLUSIONS* *DEFAULT-SOURCE-REGISTRY-EXCLUSIONS*) (COMMON-LISP:DEFVAR *SOURCE-REGISTRY* COMMON-LISP:NIL "Either NIL (for uninitialized), or an equal hash-table, mapping
     [java] system names to pathnames of .asd files") (COMMON-LISP:DEFVAR *SOURCE-REGISTRY-PARAMETER* COMMON-LISP:NIL) (COMMON-LISP:DEFUN SOURCE-REGISTRY-INITIALIZED-P COMMON-LISP:NIL (COMMON-LISP:TYPEP *SOURCE-REGISTRY* (COMMON-LISP:QUOTE COMMON-LISP:HASH-TABLE))) (COMMON-LISP:DEFUN CLEAR-SOURCE-REGISTRY COMMON-LISP:NIL "Undoes any initialization of the source registry." (COMMON-LISP:SETF *SOURCE-REGISTRY* COMMON-LISP:NIL) (COMMON-LISP:VALUES)) (UIOP/CONFIGURATION:REGISTER-CLEAR-CONFIGURATION-HOOK (COMMON-LISP:QUOTE CLEAR-SOURCE-REGISTRY)) (COMMON-LISP:DEFPARAMETER *WILD-ASD* (UIOP/PATHNAME:MAKE-PATHNAME* :DIRECTORY COMMON-LISP:NIL :NAME UIOP/PATHNAME:*WILD* :TYPE "asd" :VERSION :NEWEST)) (COMMON-LISP:DEFUN DIRECTORY-ASD-FILES (COMMON-LISP:DIRECTORY) (UIOP/FILESYSTEM:DIRECTORY-FILES COMMON-LISP:DIRECTORY *WILD-ASD*)) (COMMON-LISP:DEFUN COLLECT-ASDS-IN-DIRECTORY (COMMON-LISP:DIRECTORY COLLECT) (COMMON-LISP:LET ((ASDS (DIRECTORY-ASD-FILES COMMON-LISP:DIRECTORY))) (COMMON-LISP:MAP COMMON-LISP:NIL COLLECT ASDS) ASDS)) (COMMON-LISP:DEFVAR *RECURSE-BEYOND-ASDS* COMMON-LISP:T "Should :tree entries of the source-registry recurse in subdirectories
     [java] after having found a .asd file? True by default.") (COMMON-LISP:DEFUN PROCESS-SOURCE-REGISTRY-CACHE (COMMON-LISP:DIRECTORY COLLECT) (COMMON-LISP:LET ((CACHE (COMMON-LISP:IGNORE-ERRORS (UIOP/STREAM:SAFE-READ-FILE-FORM (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:DIRECTORY ".cl-source-registry.cache"))))) (COMMON-LISP:WHEN (COMMON-LISP:AND (COMMON-LISP:LISTP CACHE) (COMMON-LISP:EQ :SOURCE-REGISTRY-CACHE (COMMON-LISP:FIRST CACHE))) (COMMON-LISP:LOOP :FOR S :IN (COMMON-LISP:REST CACHE) :DO (COMMON-LISP:FUNCALL COLLECT (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:DIRECTORY S))) COMMON-LISP:T))) (COMMON-LISP:DEFUN COLLECT-SUB*DIRECTORIES-ASD-FILES (COMMON-LISP:DIRECTORY COMMON-LISP:&KEY (EXCLUDE *DEFAULT-SOURCE-REGISTRY-EXCLUSIONS*) COLLECT (RECURSE-BEYOND-ASDS *RECURSE-BEYOND-ASDS*) IGNORE-CACHE) (UIOP/FILESYSTEM:COLLECT-SUB*DIRECTORIES COMMON-LISP:DIRECTORY (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (DIR) (COMMON-LISP:UNLESS (COMMON-LISP:AND (COMMON-LISP:NOT IGNORE-CACHE) (PROCESS-SOURCE-REGISTRY-CACHE COMMON-LISP:DIRECTORY COLLECT)) (COMMON-LISP:LET ((ASDS (COLLECT-ASDS-IN-DIRECTORY DIR COLLECT))) (COMMON-LISP:OR RECURSE-BEYOND-ASDS (COMMON-LISP:NOT ASDS)))))) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:NOT (COMMON-LISP:MEMBER (COMMON-LISP:CAR (COMMON-LISP:LAST (COMMON-LISP:PATHNAME-DIRECTORY X))) EXCLUDE :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUAL))))) (COMMON-LISP:CONSTANTLY COMMON-LISP:NIL))) (COMMON-LISP:DEFUN VALIDATE-SOURCE-REGISTRY-DIRECTIVE (DIRECTIVE) (COMMON-LISP:OR (COMMON-LISP:MEMBER DIRECTIVE (COMMON-LISP:QUOTE (:DEFAULT-REGISTRY))) (COMMON-LISP:AND (COMMON-LISP:CONSP DIRECTIVE) (COMMON-LISP:LET ((COMMON-LISP:REST (COMMON-LISP:REST DIRECTIVE))) (COMMON-LISP:CASE (COMMON-LISP:FIRST DIRECTIVE) ((:INCLUDE :DIRECTORY :TREE) (COMMON-LISP:AND (UIOP/UTILITY:LENGTH=N-P COMMON-LISP:REST 1) (UIOP/CONFIGURATION:LOCATION-DESIGNATOR-P (COMMON-LISP:FIRST COMMON-LISP:REST)))) ((:EXCLUDE :ALSO-EXCLUDE) (COMMON-LISP:EVERY (COMMON-LISP:FUNCTION COMMON-LISP:STRINGP) COMMON-LISP:REST)) ((:DEFAULT-REGISTRY) (COMMON-LISP:NULL COMMON-LISP:REST))))))) (COMMON-LISP:DEFUN VALIDATE-SOURCE-REGISTRY-FORM (FORM COMMON-LISP:&KEY LOCATION) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-FORM FORM :SOURCE-REGISTRY (COMMON-LISP:QUOTE VALIDATE-SOURCE-REGISTRY-DIRECTIVE) :LOCATION LOCATION :INVALID-FORM-REPORTER (COMMON-LISP:QUOTE INVALID-SOURCE-REGISTRY))) (COMMON-LISP:DEFUN VALIDATE-SOURCE-REGISTRY-FILE (FILE) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-FILE FILE (COMMON-LISP:QUOTE VALIDATE-SOURCE-REGISTRY-FORM) :DESCRIPTION "a source registry")) (COMMON-LISP:DEFUN VALIDATE-SOURCE-REGISTRY-DIRECTORY (COMMON-LISP:DIRECTORY) (UIOP/CONFIGURATION:VALIDATE-CONFIGURATION-DIRECTORY COMMON-LISP:DIRECTORY :SOURCE-REGISTRY (COMMON-LISP:QUOTE VALIDATE-SOURCE-REGISTRY-DIRECTIVE) :INVALID-FORM-REPORTER (COMMON-LISP:QUOTE INVALID-SOURCE-REGISTRY))) (COMMON-LISP:DEFUN PARSE-SOURCE-REGISTRY-STRING (COMMON-LISP:STRING COMMON-LISP:&KEY LOCATION) (COMMON-LISP:COND ((COMMON-LISP:OR (COMMON-LISP:NULL COMMON-LISP:STRING) (COMMON-LISP:EQUAL COMMON-LISP:STRING "")) (COMMON-LISP:QUOTE (:SOURCE-REGISTRY :INHERIT-CONFIGURATION))) ((COMMON-LISP:NOT (COMMON-LISP:STRINGP COMMON-LISP:STRING)) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Environment string isn't: ~3i~_~S~@:>") COMMON-LISP:STRING)) ((COMMON-LISP:FIND (COMMON-LISP:CHAR COMMON-LISP:STRING 0) "\"(") (VALIDATE-SOURCE-REGISTRY-FORM (COMMON-LISP:READ-FROM-STRING COMMON-LISP:STRING) :LOCATION LOCATION)) (COMMON-LISP:T (COMMON-LISP:LOOP :WITH INHERIT COMMON-LISP:= COMMON-LISP:NIL :WITH DIRECTIVES COMMON-LISP:= COMMON-LISP:NIL :WITH START COMMON-LISP:= 0 :WITH END COMMON-LISP:= (COMMON-LISP:LENGTH COMMON-LISP:STRING) :WITH SEPARATOR COMMON-LISP:= (UIOP/FILESYSTEM:INTER-DIRECTORY-SEPARATOR) :FOR POS COMMON-LISP:= (COMMON-LISP:POSITION SEPARATOR COMMON-LISP:STRING :START START) :DO (COMMON-LISP:LET ((S (COMMON-LISP:SUBSEQ COMMON-LISP:STRING START (COMMON-LISP:OR POS END)))) (COMMON-LISP:FLET ((CHECK (DIR) (COMMON-LISP:UNLESS (UIOP/PATHNAME:ABSOLUTE-PATHNAME-P DIR) (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<source-registry string must specify absolute pathnames: ~3i~_~S~@:>") COMMON-LISP:STRING)) DIR)) (COMMON-LISP:COND ((COMMON-LISP:EQUAL "" S) (COMMON-LISP:WHEN INHERIT (COMMON-LISP:ERROR (UIOP/COMMON-LISP::COMPATFMT "~@<Only one inherited configuration allowed: ~3i~_~S~@:>") COMMON-LISP:STRING)) (COMMON-LISP:SETF INHERIT COMMON-LISP:T) (COMMON-LISP:PUSH (COMMON-LISP:QUOTE :INHERIT-CONFIGURATION) DIRECTIVES)) ((UIOP/UTILITY:STRING-SUFFIX-P S "//") (COMMON-LISP:PUSH (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :TREE) (CHECK (COMMON-LISP:SUBSEQ S 0 (COMMON-LISP:- (COMMON-LISP:LENGTH S) 2)))) DIRECTIVES)) (COMMON-LISP:T (COMMON-LISP:PUSH (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DIRECTORY) (CHECK S)) DIRECTIVES)))) (COMMON-LISP:COND (POS (COMMON-LISP:SETF START (COMMON-LISP:1+ POS))) (COMMON-LISP:T (COMMON-LISP:UNLESS INHERIT (COMMON-LISP:PUSH (COMMON-LISP:QUOTE (:IGNORE-INHERITED-CONFIGURATION)) DIRECTIVES)) (COMMON-LISP:RETURN (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :SOURCE-REGISTRY) (COMMON-LISP:NREVERSE DIRECTIVES)))))))))) (COMMON-LISP:DEFUN REGISTER-ASD-DIRECTORY (COMMON-LISP:DIRECTORY COMMON-LISP:&KEY RECURSE EXCLUDE COLLECT) (COMMON-LISP:IF (COMMON-LISP:NOT RECURSE) (COLLECT-ASDS-IN-DIRECTORY COMMON-LISP:DIRECTORY COLLECT) (COLLECT-SUB*DIRECTORIES-ASD-FILES COMMON-LISP:DIRECTORY :EXCLUDE EXCLUDE :COLLECT COLLECT))) (DEFPARAMETER* *DEFAULT-SOURCE-REGISTRIES* (COMMON-LISP:QUOTE (ENVIRONMENT-SOURCE-REGISTRY USER-SOURCE-REGISTRY USER-SOURCE-REGISTRY-DIRECTORY DEFAULT-USER-SOURCE-REGISTRY SYSTEM-SOURCE-REGISTRY SYSTEM-SOURCE-REGISTRY-DIRECTORY DEFAULT-SYSTEM-SOURCE-REGISTRY)) "List of default source registries" "3.1.0.102") (COMMON-LISP:DEFPARAMETER *SOURCE-REGISTRY-FILE* (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING "common-lisp/source-registry.conf")) (COMMON-LISP:DEFPARAMETER *SOURCE-REGISTRY-DIRECTORY* (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING "common-lisp/source-registry.conf.d/")) (COMMON-LISP:DEFUN WRAPPING-SOURCE-REGISTRY COMMON-LISP:NIL (COMMON-LISP:QUOTE (:SOURCE-REGISTRY :INHERIT-CONFIGURATION))) (COMMON-LISP:DEFUN DEFAULT-USER-SOURCE-REGISTRY COMMON-LISP:NIL (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE :SOURCE-REGISTRY) (COMMON-LISP:QUOTE (:TREE (:HOME "common-lisp/"))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DIRECTORY) (UIOP/CONFIGURATION:XDG-DATA-HOME "common-lisp/systems/")) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :TREE) (UIOP/CONFIGURATION:XDG-DATA-HOME "common-lisp/source/")) (COMMON-LISP:QUOTE (:INHERIT-CONFIGURATION)))) (COMMON-LISP:DEFUN DEFAULT-SYSTEM-SOURCE-REGISTRY COMMON-LISP:NIL (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :SOURCE-REGISTRY) (SYSTEM::BACKQ-APPEND (COMMON-LISP:LOOP :FOR DIR :IN (UIOP/CONFIGURATION:XDG-DATA-DIRS "common-lisp/") :COLLECT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DIRECTORY) (SYSTEM::BACKQ-CONS DIR (COMMON-LISP:QUOTE ("systems/")))) :COLLECT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :TREE) (SYSTEM::BACKQ-CONS DIR (COMMON-LISP:QUOTE ("source/"))))) (COMMON-LISP:QUOTE (:INHERIT-CONFIGURATION))))) (COMMON-LISP:DEFUN USER-SOURCE-REGISTRY (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:XDG-CONFIG-PATHNAME *SOURCE-REGISTRY-FILE* DIRECTION)) (COMMON-LISP:DEFUN SYSTEM-SOURCE-REGISTRY (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:FIND-PREFERRED-FILE (UIOP/CONFIGURATION:SYSTEM-CONFIG-PATHNAMES *SOURCE-REGISTRY-FILE*) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN USER-SOURCE-REGISTRY-DIRECTORY (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:XDG-CONFIG-PATHNAME *SOURCE-REGISTRY-DIRECTORY* DIRECTION)) (COMMON-LISP:DEFUN SYSTEM-SOURCE-REGISTRY-DIRECTORY (COMMON-LISP:&KEY (DIRECTION :INPUT)) (UIOP/CONFIGURATION:FIND-PREFERRED-FILE (UIOP/CONFIGURATION:SYSTEM-CONFIG-PATHNAMES *SOURCE-REGISTRY-DIRECTORY*) :DIRECTION DIRECTION)) (COMMON-LISP:DEFUN ENVIRONMENT-SOURCE-REGISTRY COMMON-LISP:NIL (UIOP/OS:GETENV "CL_SOURCE_REGISTRY")) (UIOP/UTILITY:DEFGENERIC* (PROCESS-SOURCE-REGISTRY) (SPEC COMMON-LISP:&KEY INHERIT REGISTER)) (UIOP/UTILITY:DEFUN* (INHERIT-SOURCE-REGISTRY) (INHERIT COMMON-LISP:&KEY REGISTER) (COMMON-LISP:WHEN INHERIT (PROCESS-SOURCE-REGISTRY (COMMON-LISP:FIRST INHERIT) :REGISTER REGISTER :INHERIT (COMMON-LISP:REST INHERIT)))) (UIOP/UTILITY:DEFUN* (PROCESS-SOURCE-REGISTRY-DIRECTIVE) (DIRECTIVE COMMON-LISP:&KEY INHERIT REGISTER) (COMMON-LISP:DESTRUCTURING-BIND (KW COMMON-LISP:&REST COMMON-LISP:REST) (COMMON-LISP:IF (COMMON-LISP:CONSP DIRECTIVE) DIRECTIVE (COMMON-LISP:LIST DIRECTIVE)) (COMMON-LISP:ECASE KW ((:INCLUDE) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:PATHNAME) COMMON-LISP:REST (PROCESS-SOURCE-REGISTRY (UIOP/CONFIGURATION:RESOLVE-LOCATION COMMON-LISP:PATHNAME) :INHERIT COMMON-LISP:NIL :REGISTER REGISTER))) ((:DIRECTORY) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:PATHNAME) COMMON-LISP:REST (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:FUNCALL REGISTER (UIOP/CONFIGURATION:RESOLVE-LOCATION COMMON-LISP:PATHNAME :ENSURE-DIRECTORY COMMON-LISP:T))))) ((:TREE) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:PATHNAME) COMMON-LISP:REST (COMMON-LISP:WHEN COMMON-LISP:PATHNAME (COMMON-LISP:FUNCALL REGISTER (UIOP/CONFIGURATION:RESOLVE-LOCATION COMMON-LISP:PATHNAME :ENSURE-DIRECTORY COMMON-LISP:T) :RECURSE COMMON-LISP:T :EXCLUDE *SOURCE-REGISTRY-EXCLUSIONS*)))) ((:EXCLUDE) (COMMON-LISP:SETF *SOURCE-REGISTRY-EXCLUSIONS* COMMON-LISP:REST)) ((:ALSO-EXCLUDE) (UIOP/UTILITY:APPENDF *SOURCE-REGISTRY-EXCLUSIONS* COMMON-LISP:REST)) ((:DEFAULT-REGISTRY) (INHERIT-SOURCE-REGISTRY (COMMON-LISP:QUOTE (DEFAULT-USER-SOURCE-REGISTRY DEFAULT-SYSTEM-SOURCE-REGISTRY)) :REGISTER REGISTER)) ((:INHERIT-CONFIGURATION) (INHERIT-SOURCE-REGISTRY INHERIT :REGISTER REGISTER)) ((:IGNORE-INHERITED-CONFIGURATION) COMMON-LISP:NIL))) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PROCESS-SOURCE-REGISTRY ((X COMMON-LISP:SYMBOL) COMMON-LISP:&KEY INHERIT REGISTER) (PROCESS-SOURCE-REGISTRY (COMMON-LISP:FUNCALL X) :INHERIT INHERIT :REGISTER REGISTER)) (COMMON-LISP:DEFMETHOD PROCESS-SOURCE-REGISTRY ((COMMON-LISP:PATHNAME COMMON-LISP:PATHNAME) COMMON-LISP:&KEY INHERIT REGISTER) (COMMON-LISP:COND ((UIOP/PATHNAME:DIRECTORY-PATHNAME-P COMMON-LISP:PATHNAME) (COMMON-LISP:LET ((UIOP/CONFIGURATION:*HERE-DIRECTORY* (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* COMMON-LISP:PATHNAME))) (PROCESS-SOURCE-REGISTRY (VALIDATE-SOURCE-REGISTRY-DIRECTORY COMMON-LISP:PATHNAME) :INHERIT INHERIT :REGISTER REGISTER))) ((UIOP/FILESYSTEM:PROBE-FILE* COMMON-LISP:PATHNAME :TRUENAME UIOP/FILESYSTEM:*RESOLVE-SYMLINKS*) (COMMON-LISP:LET ((UIOP/CONFIGURATION:*HERE-DIRECTORY* (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME COMMON-LISP:PATHNAME))) (PROCESS-SOURCE-REGISTRY (VALIDATE-SOURCE-REGISTRY-FILE COMMON-LISP:PATHNAME) :INHERIT INHERIT :REGISTER REGISTER))) (COMMON-LISP:T (INHERIT-SOURCE-REGISTRY INHERIT :REGISTER REGISTER)))) (COMMON-LISP:DEFMETHOD PROCESS-SOURCE-REGISTRY ((COMMON-LISP:STRING COMMON-LISP:STRING) COMMON-LISP:&KEY INHERIT REGISTER) (PROCESS-SOURCE-REGISTRY (PARSE-SOURCE-REGISTRY-STRING COMMON-LISP:STRING) :INHERIT INHERIT :REGISTER REGISTER)) (COMMON-LISP:DEFMETHOD PROCESS-SOURCE-REGISTRY ((X COMMON-LISP:NULL) COMMON-LISP:&KEY INHERIT REGISTER) (INHERIT-SOURCE-REGISTRY INHERIT :REGISTER REGISTER)) (COMMON-LISP:DEFMETHOD PROCESS-SOURCE-REGISTRY ((FORM COMMON-LISP:CONS) COMMON-LISP:&KEY INHERIT REGISTER) (COMMON-LISP:LET ((*SOURCE-REGISTRY-EXCLUSIONS* *DEFAULT-SOURCE-REGISTRY-EXCLUSIONS*)) (COMMON-LISP:DOLIST (DIRECTIVE (COMMON-LISP:CDR (VALIDATE-SOURCE-REGISTRY-FORM FORM))) (PROCESS-SOURCE-REGISTRY-DIRECTIVE DIRECTIVE :INHERIT INHERIT :REGISTER REGISTER)))) (COMMON-LISP:DEFUN FLATTEN-SOURCE-REGISTRY (COMMON-LISP:&OPTIONAL (PARAMETER *SOURCE-REGISTRY-PARAMETER*)) (COMMON-LISP:REMOVE-DUPLICATES (UIOP/UTILITY:WHILE-COLLECTING (COLLECT) (UIOP/PATHNAME:WITH-PATHNAME-DEFAULTS COMMON-LISP:NIL (INHERIT-SOURCE-REGISTRY (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE WRAPPING-SOURCE-REGISTRY) PARAMETER *DEFAULT-SOURCE-REGISTRIES*) :REGISTER (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (COMMON-LISP:DIRECTORY COMMON-LISP:&KEY RECURSE EXCLUDE) (COLLECT (COMMON-LISP:LIST COMMON-LISP:DIRECTORY :RECURSE RECURSE :EXCLUDE EXCLUDE))))))) :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL) :FROM-END COMMON-LISP:T)) (COMMON-LISP:DEFUN COMPUTE-SOURCE-REGISTRY (COMMON-LISP:&OPTIONAL (PARAMETER *SOURCE-REGISTRY-PARAMETER*) (REGISTRY *SOURCE-REGISTRY*)) (COMMON-LISP:DOLIST (ENTRY (FLATTEN-SOURCE-REGISTRY PARAMETER)) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:DIRECTORY COMMON-LISP:&KEY RECURSE EXCLUDE) ENTRY (COMMON-LISP:LET* ((H (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (REGISTER-ASD-DIRECTORY COMMON-LISP:DIRECTORY :RECURSE RECURSE :EXCLUDE EXCLUDE :COLLECT (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (ASD) (COMMON-LISP:LET* ((NAME (COMMON-LISP:PATHNAME-NAME ASD)) (NAME (COMMON-LISP:IF (COMMON-LISP:TYPEP ASD (COMMON-LISP:QUOTE COMMON-LISP:LOGICAL-PATHNAME)) (COMMON-LISP:STRING-DOWNCASE NAME) NAME))) (COMMON-LISP:COND ((COMMON-LISP:GETHASH NAME REGISTRY) COMMON-LISP:NIL) ((COMMON-LISP:GETHASH NAME H) (COMMON-LISP:WHEN *VERBOSE-OUT* (COMMON-LISP:WARN (UIOP/COMMON-LISP::COMPATFMT "~@<In source-registry entry ~A~@[/~*~] ~
     [java]                                 found several entries for ~A - picking ~S over ~S~:>") COMMON-LISP:DIRECTORY RECURSE NAME (COMMON-LISP:GETHASH NAME H) ASD))) (COMMON-LISP:T (COMMON-LISP:SETF (COMMON-LISP:GETHASH NAME REGISTRY) ASD) (COMMON-LISP:SETF (COMMON-LISP:GETHASH NAME H) ASD))))))) H))) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFUN INITIALIZE-SOURCE-REGISTRY (COMMON-LISP:&OPTIONAL (PARAMETER *SOURCE-REGISTRY-PARAMETER*)) (COMMON-LISP:SETF *SOURCE-REGISTRY-PARAMETER* PARAMETER) (COMMON-LISP:SETF *SOURCE-REGISTRY* (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMPUTE-SOURCE-REGISTRY PARAMETER)) (COMMON-LISP:DEFUN ENSURE-SOURCE-REGISTRY (COMMON-LISP:&OPTIONAL PARAMETER) (COMMON-LISP:UNLESS (SOURCE-REGISTRY-INITIALIZED-P) (INITIALIZE-SOURCE-REGISTRY PARAMETER)) (COMMON-LISP:VALUES)) (COMMON-LISP:DEFUN SYSDEF-SOURCE-REGISTRY-SEARCH (SYSTEM) (ENSURE-SOURCE-REGISTRY) (COMMON-LISP:VALUES (COMMON-LISP:GETHASH (PRIMARY-SYSTEM-NAME SYSTEM) *SOURCE-REGISTRY*))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/PARSE-DEFSYSTEM (:RECYCLE :ASDF/PARSE-DEFSYSTEM :ASDF/DEFSYSTEM :ASDF) (:NICKNAMES :ASDF/DEFSYSTEM) (:USE :UIOP/COMMON-LISP :ASDF/DRIVER :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/ACTION :ASDF/LISP-ACTION :ASDF/OPERATE) (:IMPORT-FROM :ASDF/SYSTEM #:DEPENDS-ON #:WEAKLY-DEPENDS-ON) (:EXPORT #:DEFSYSTEM #:REGISTER-SYSTEM-DEFINITION #:CLASS-FOR-TYPE #:*DEFAULT-COMPONENT-CLASS* #:DETERMINE-SYSTEM-DIRECTORY #:PARSE-COMPONENT-FORM #:NON-TOPLEVEL-SYSTEM #:NON-SYSTEM-SYSTEM #:SYSDEF-ERROR-COMPONENT #:CHECK-COMPONENT-INPUT))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/PARSE-DEFSYSTEM)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN DETERMINE-SYSTEM-DIRECTORY (COMMON-LISP:PATHNAME) (COMMON-LISP:CHECK-TYPE COMMON-LISP:PATHNAME (COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING COMMON-LISP:PATHNAME)) (UIOP/PATHNAME:PATHNAME-DIRECTORY-PATHNAME (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME (UIOP/PATHNAME:PARSE-UNIX-NAMESTRING COMMON-LISP:PATHNAME :TYPE :DIRECTORY) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA COMMON-LISP:NIL (UIOP/PATHNAME:ENSURE-ABSOLUTE-PATHNAME (UIOP/LISP-BUILD:LOAD-PATHNAME) (COMMON-LISP:QUOTE UIOP/FILESYSTEM:GET-PATHNAME-DEFAULTS) COMMON-LISP:NIL))) COMMON-LISP:NIL)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *DEFAULT-COMPONENT-CLASS* (COMMON-LISP:QUOTE CL-SOURCE-FILE)) (COMMON-LISP:DEFUN CLASS-FOR-TYPE (PARENT COMMON-LISP:TYPE) (COMMON-LISP:OR (UIOP/UTILITY:COERCE-CLASS COMMON-LISP:TYPE :PACKAGE :ASDF/INTERFACE :SUPER (COMMON-LISP:QUOTE COMPONENT) :ERROR COMMON-LISP:NIL) (COMMON-LISP:AND (COMMON-LISP:EQ COMMON-LISP:TYPE :FILE) (UIOP/UTILITY:COERCE-CLASS (COMMON-LISP:OR (COMMON-LISP:LOOP :FOR P COMMON-LISP:= PARENT :THEN (COMPONENT-PARENT P) :WHILE P :THEREIS (MODULE-DEFAULT-COMPONENT-CLASS P)) *DEFAULT-COMPONENT-CLASS*) :PACKAGE :ASDF/INTERFACE :SUPER (COMMON-LISP:QUOTE COMPONENT) :ERROR COMMON-LISP:NIL)) (SYSDEF-ERROR "don't recognize component type ~S" COMMON-LISP:TYPE))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION NON-SYSTEM-SYSTEM (SYSTEM-DEFINITION-ERROR) ((NAME :INITARG :NAME :READER NON-SYSTEM-SYSTEM-NAME) (COMMON-LISP:CLASS-NAME :INITARG :CLASS-NAME :READER NON-SYSTEM-SYSTEM-CLASS-NAME)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Error while defining system ~S: class ~S isn't a subclass of ~S~@:>") (NON-SYSTEM-SYSTEM-NAME C) (NON-SYSTEM-SYSTEM-CLASS-NAME C) (COMMON-LISP:QUOTE SYSTEM))))) (COMMON-LISP:DEFINE-CONDITION NON-TOPLEVEL-SYSTEM (SYSTEM-DEFINITION-ERROR) ((PARENT :INITARG :PARENT :READER NON-TOPLEVEL-SYSTEM-PARENT) (NAME :INITARG :NAME :READER NON-TOPLEVEL-SYSTEM-NAME)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<Error while defining system: component ~S claims to have a system ~S as a child~@:>") (NON-TOPLEVEL-SYSTEM-PARENT C) (NON-TOPLEVEL-SYSTEM-NAME C))))) (COMMON-LISP:DEFUN SYSDEF-ERROR-COMPONENT (MSG COMMON-LISP:TYPE NAME VALUE) (SYSDEF-ERROR (UIOP/UTILITY:STRCAT MSG (UIOP/COMMON-LISP::COMPATFMT "~&~@<The value specified for ~(~A~) ~A is ~S~@:>")) COMMON-LISP:TYPE NAME VALUE)) (COMMON-LISP:DEFUN CHECK-COMPONENT-INPUT (COMMON-LISP:TYPE NAME WEAKLY-DEPENDS-ON DEPENDS-ON COMPONENTS) "A partial test of the values of a component." (COMMON-LISP:UNLESS (COMMON-LISP:LISTP DEPENDS-ON) (SYSDEF-ERROR-COMPONENT ":depends-on must be a list." COMMON-LISP:TYPE NAME DEPENDS-ON)) (COMMON-LISP:UNLESS (COMMON-LISP:LISTP WEAKLY-DEPENDS-ON) (SYSDEF-ERROR-COMPONENT ":weakly-depends-on must be a list." COMMON-LISP:TYPE NAME WEAKLY-DEPENDS-ON)) (COMMON-LISP:UNLESS (COMMON-LISP:LISTP COMPONENTS) (SYSDEF-ERROR-COMPONENT ":components must be NIL or a list of components." COMMON-LISP:TYPE NAME COMPONENTS))) (UIOP/UTILITY:DEFUN* (NORMALIZE-VERSION) (FORM COMMON-LISP:&KEY COMMON-LISP:PATHNAME COMPONENT PARENT) (COMMON-LISP:LABELS ((INVALID (COMMON-LISP:&OPTIONAL (CONTINUATION "using NIL instead")) (COMMON-LISP:WARN (UIOP/COMMON-LISP::COMPATFMT "~@<Invalid :version specifier ~S~@[ for component ~S~]~@[ in ~S~]~@[ from file ~S~]~@[, ~A~]~@:>") FORM COMPONENT PARENT COMMON-LISP:PATHNAME CONTINUATION)) (INVALID-PARSE (CONTROL COMMON-LISP:&REST ARGS) (COMMON-LISP:UNLESS (UIOP/UTILITY:IF-LET (TARGET (FIND-COMPONENT PARENT COMPONENT)) (BUILTIN-SYSTEM-P TARGET)) (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:WARN) CONTROL ARGS) (INVALID)))) (UIOP/UTILITY:IF-LET (V (COMMON-LISP:TYPECASE FORM ((COMMON-LISP:OR COMMON-LISP:STRING COMMON-LISP:NULL) FORM) (COMMON-LISP:REAL (INVALID "Substituting a string") (COMMON-LISP:FORMAT COMMON-LISP:NIL "~D" FORM)) (COMMON-LISP:CONS (COMMON-LISP:CASE (COMMON-LISP:FIRST FORM) ((:READ-FILE-FORM) (COMMON-LISP:DESTRUCTURING-BIND (SUBPATH COMMON-LISP:&KEY (AT 0)) (COMMON-LISP:REST FORM) (UIOP/STREAM:SAFE-READ-FILE-FORM (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:PATHNAME SUBPATH) :AT AT :PACKAGE :ASDF-USER))) ((:READ-FILE-LINE) (COMMON-LISP:DESTRUCTURING-BIND (SUBPATH COMMON-LISP:&KEY (AT 0)) (COMMON-LISP:REST FORM) (UIOP/STREAM:SAFE-READ-FILE-LINE (UIOP/PATHNAME:SUBPATHNAME COMMON-LISP:PATHNAME SUBPATH) :AT AT))) (COMMON-LISP:OTHERWISE (INVALID)))) (COMMON-LISP:T (INVALID)))) (UIOP/UTILITY:IF-LET (PV (UIOP/UTILITY:PARSE-VERSION V (COMMON-LISP:FUNCTION INVALID-PARSE))) (UIOP/UTILITY:UNPARSE-VERSION PV) (INVALID))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (DEFPARAMETER* +ASDF-METHODS+ (COMMON-LISP:QUOTE (PERFORM-WITH-RESTARTS PERFORM EXPLAIN OUTPUT-FILES OPERATION-DONE-P))) (COMMON-LISP:DEFUN %REMOVE-COMPONENT-INLINE-METHODS (COMPONENT) (COMMON-LISP:DOLIST (NAME +ASDF-METHODS+) (COMMON-LISP:MAP COMMON-LISP:NIL (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (M) (COMMON-LISP:REMOVE-METHOD (COMMON-LISP:SYMBOL-FUNCTION NAME) M))) (COMPONENT-INLINE-METHODS COMPONENT))) (COMPONENT-INLINE-METHODS COMPONENT) COMMON-LISP:NIL) (COMMON-LISP:DEFUN %DEFINE-COMPONENT-INLINE-METHODS (RET COMMON-LISP:REST) (UIOP/COMMON-LISP::LOOP* :FOR (KEY VALUE) :ON COMMON-LISP:REST :BY (COMMON-LISP:FUNCTION COMMON-LISP:CDDR) :FOR NAME COMMON-LISP:= (COMMON-LISP:AND (COMMON-LISP:KEYWORDP KEY) (COMMON-LISP:FIND KEY +ASDF-METHODS+ :TEST (COMMON-LISP:QUOTE COMMON-LISP:STRING=))) :WHEN NAME :DO (COMMON-LISP:DESTRUCTURING-BIND (OP COMMON-LISP:&REST BODY) VALUE (COMMON-LISP:LOOP :FOR ARG COMMON-LISP:= (COMMON-LISP:POP BODY) :WHILE (COMMON-LISP:ATOM ARG) :COLLECT ARG :INTO QUALIFIERS :FINALLY (COMMON-LISP:DESTRUCTURING-BIND (O C) ARG (COMMON-LISP:PUSHNEW (COMMON-LISP:EVAL (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE COMMON-LISP:DEFMETHOD) NAME (SYSTEM::BACKQ-APPEND QUALIFIERS (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST O OP) (SYSTEM::BACKQ-LIST C (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:EQL) RET))) BODY)))) (COMPONENT-INLINE-METHODS RET))))))) (COMMON-LISP:DEFUN %REFRESH-COMPONENT-INLINE-METHODS (COMPONENT COMMON-LISP:REST) (%REMOVE-COMPONENT-INLINE-METHODS COMPONENT) (%DEFINE-COMPONENT-INLINE-METHODS COMPONENT COMMON-LISP:REST)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:DEFUN* PARSE-DEPENDENCY-DEF (DD) (COMMON-LISP:IF (COMMON-LISP:LISTP DD) (COMMON-LISP:CASE (COMMON-LISP:FIRST DD) (:FEATURE (COMMON-LISP:UNLESS (COMMON-LISP:= (COMMON-LISP:LENGTH DD) 3) (SYSDEF-ERROR "Ill-formed feature dependency: ~s" DD)) (COMMON-LISP:LET ((EMBEDDED (PARSE-DEPENDENCY-DEF (COMMON-LISP:THIRD DD)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :FEATURE) (COMMON-LISP:SECOND DD) EMBEDDED))) (FEATURE (SYSDEF-ERROR "`feature' has been removed from the dependency spec language of ASDF. Use :feature instead in ~s." DD)) (:REQUIRE (COMMON-LISP:UNLESS (COMMON-LISP:= (COMMON-LISP:LENGTH DD) 2) (SYSDEF-ERROR "Ill-formed require dependency: ~s" DD)) DD) (:VERSION (COMMON-LISP:UNLESS (COMMON-LISP:= (COMMON-LISP:LENGTH DD) 3) (SYSDEF-ERROR "Ill-formed version dependency: ~s" DD)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :VERSION) (COERCE-NAME (COMMON-LISP:SECOND DD)) (COMMON-LISP:THIRD DD))) (COMMON-LISP:OTHERWISE (SYSDEF-ERROR "Ill-formed dependency: ~s" DD))) (COERCE-NAME DD))) (UIOP/UTILITY:DEFUN* PARSE-DEPENDENCY-DEFS (DD-LIST) "Parse the dependency defs in DD-LIST into canonical form by translating all
     [java] system names contained using COERCE-NAME. Return the result." (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE PARSE-DEPENDENCY-DEF) DD-LIST)) (UIOP/UTILITY:DEFUN* (PARSE-COMPONENT-FORM) (PARENT OPTIONS COMMON-LISP:&KEY PREVIOUS-SERIAL-COMPONENT) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:TYPE NAME COMMON-LISP:&REST COMMON-LISP:REST COMMON-LISP:&KEY (BUILTIN-SYSTEM-P COMMON-LISP:NIL BSPP) COMPONENTS COMMON-LISP:PATHNAME PERFORM EXPLAIN OUTPUT-FILES OPERATION-DONE-P WEAKLY-DEPENDS-ON DEPENDS-ON SERIAL DO-FIRST IF-COMPONENT-DEP-FAILS VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) OPTIONS (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE PERFORM EXPLAIN OUTPUT-FILES OPERATION-DONE-P BUILTIN-SYSTEM-P)) (CHECK-COMPONENT-INPUT COMMON-LISP:TYPE NAME WEAKLY-DEPENDS-ON DEPENDS-ON COMPONENTS) (COMMON-LISP:WHEN (COMMON-LISP:AND PARENT (FIND-COMPONENT PARENT NAME) (COMMON-LISP:NOT (COMMON-LISP:TYPEP (FIND-COMPONENT PARENT NAME) (CLASS-FOR-TYPE PARENT COMMON-LISP:TYPE)))) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE DUPLICATE-NAMES) :NAME NAME)) (COMMON-LISP:WHEN DO-FIRST (COMMON-LISP:ERROR "DO-FIRST is not supported anymore as of ASDF 3")) (COMMON-LISP:LET* ((NAME (COERCE-NAME NAME)) (ARGS (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE :NAME) NAME (COMMON-LISP:QUOTE :PATHNAME) COMMON-LISP:PATHNAME (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN PARENT (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :PARENT) PARENT)) (UIOP/UTILITY:REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:COMPONENTS :PATHNAME :IF-COMPONENT-DEP-FAILS :VERSION :PERFORM :EXPLAIN :OUTPUT-FILES :OPERATION-DONE-P :WEAKLY-DEPENDS-ON :DEPENDS-ON :SERIAL)) COMMON-LISP:REST)))) (COMPONENT (FIND-COMPONENT PARENT NAME)) (COMMON-LISP:CLASS (CLASS-FOR-TYPE PARENT COMMON-LISP:TYPE))) (COMMON-LISP:WHEN (COMMON-LISP:AND PARENT (COMMON-LISP:SUBTYPEP COMMON-LISP:CLASS (COMMON-LISP:QUOTE SYSTEM))) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE NON-TOPLEVEL-SYSTEM) :PARENT PARENT :NAME NAME)) (COMMON-LISP:IF COMPONENT (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:REINITIALIZE-INSTANCE) COMPONENT ARGS) (COMMON-LISP:SETF COMPONENT (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:MAKE-INSTANCE) COMMON-LISP:CLASS ARGS))) (COMPONENT-PATHNAME COMPONENT) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP COMPONENT (COMMON-LISP:QUOTE SYSTEM)) (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE DEPENDS-ON)) (PARSE-DEPENDENCY-DEFS DEPENDS-ON) (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE WEAKLY-DEPENDS-ON)) (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE COERCE-NAME) WEAKLY-DEPENDS-ON))) (COMMON-LISP:LET ((SYSFILE (SYSTEM-SOURCE-FILE (COMPONENT-SYSTEM COMPONENT)))) (COMMON-LISP:WHEN (COMMON-LISP:AND (COMMON-LISP:TYPEP COMPONENT (COMMON-LISP:QUOTE SYSTEM)) (COMMON-LISP:NOT BSPP)) (COMMON-LISP:SETF (BUILTIN-SYSTEM-P COMPONENT) (UIOP/FILESYSTEM:LISP-IMPLEMENTATION-PATHNAME-P SYSFILE))) (COMMON-LISP:SETF VERSION (NORMALIZE-VERSION VERSION :COMPONENT NAME :PARENT PARENT :PATHNAME SYSFILE))) (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE COMPONENT (COMMON-LISP:QUOTE VERSION)) VERSION) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP COMPONENT (COMMON-LISP:QUOTE PARENT-COMPONENT)) (COMMON-LISP:SETF (COMPONENT-CHILDREN COMPONENT) (COMMON-LISP:LOOP :WITH PREVIOUS-COMPONENT COMMON-LISP:= COMMON-LISP:NIL :FOR C-FORM :IN COMPONENTS :FOR C COMMON-LISP:= (PARSE-COMPONENT-FORM COMPONENT C-FORM :PREVIOUS-SERIAL-COMPONENT PREVIOUS-COMPONENT) :FOR NAME COMMON-LISP:= (COMPONENT-NAME C) :COLLECT C :WHEN SERIAL :DO (COMMON-LISP:SETF PREVIOUS-COMPONENT NAME))) (COMPUTE-CHILDREN-BY-NAME COMPONENT)) (COMMON-LISP:WHEN PREVIOUS-SERIAL-COMPONENT (COMMON-LISP:PUSH PREVIOUS-SERIAL-COMPONENT DEPENDS-ON)) (COMMON-LISP:WHEN WEAKLY-DEPENDS-ON (UIOP/UTILITY:APPENDF DEPENDS-ON (COMMON-LISP:REMOVE-IF (COMMON-LISP:COMPLEMENT (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (FIND-SYSTEM X COMMON-LISP:NIL)))) WEAKLY-DEPENDS-ON))) (COMMON-LISP:SETF (COMPONENT-SIDEWAY-DEPENDENCIES COMPONENT) DEPENDS-ON) (%REFRESH-COMPONENT-INLINE-METHODS COMPONENT COMMON-LISP:REST) (COMMON-LISP:WHEN IF-COMPONENT-DEP-FAILS (COMMON-LISP:ERROR "The system definition for ~S uses deprecated ~
     [java]             ASDF option :IF-COMPONENT-DEP-FAILS. ~
     [java]             Starting with ASDF 3, please use :IF-FEATURE instead" (COERCE-NAME (COMPONENT-SYSTEM COMPONENT)))) COMPONENT))) (COMMON-LISP:DEFUN REGISTER-SYSTEM-DEFINITION (NAME COMMON-LISP:&REST OPTIONS COMMON-LISP:&KEY COMMON-LISP:PATHNAME (COMMON-LISP:CLASS (COMMON-LISP:QUOTE SYSTEM)) (SOURCE-FILE COMMON-LISP:NIL SFP) DEFSYSTEM-DEPENDS-ON COMMON-LISP:&ALLOW-OTHER-KEYS) (WITH-ASDF-CACHE COMMON-LISP:NIL (COMMON-LISP:LET* ((NAME (COERCE-NAME NAME)) (SOURCE-FILE (COMMON-LISP:IF SFP SOURCE-FILE (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* (UIOP/LISP-BUILD:LOAD-PATHNAME)))) (REGISTERED (SYSTEM-REGISTERED-P NAME)) (REGISTERED! (COMMON-LISP:IF REGISTERED (COMMON-LISP:RPLACA REGISTERED (GET-FILE-STAMP SOURCE-FILE)) (REGISTER-SYSTEM (COMMON-LISP:MAKE-INSTANCE (COMMON-LISP:QUOTE SYSTEM) :NAME NAME :SOURCE-FILE SOURCE-FILE)))) (SYSTEM (RESET-SYSTEM (COMMON-LISP:CDR REGISTERED!) :NAME NAME :SOURCE-FILE SOURCE-FILE)) (COMPONENT-OPTIONS (UIOP/UTILITY:REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:DEFSYSTEM-DEPENDS-ON :CLASS)) OPTIONS)) (DEFSYSTEM-DEPENDENCIES (COMMON-LISP:LOOP :FOR SPEC :IN DEFSYSTEM-DEPENDS-ON :WHEN (RESOLVE-DEPENDENCY-SPEC COMMON-LISP:NIL SPEC) :COLLECT :IT))) (COMMON-LISP:WHEN DEFSYSTEM-DEPENDS-ON (COMMON-LISP:SETF COMPONENT-OPTIONS (COMMON-LISP:APPEND (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :DEFSYSTEM-DEPENDS-ON) (PARSE-DEPENDENCY-DEFS DEFSYSTEM-DEPENDS-ON)) COMPONENT-OPTIONS))) (SET-ASDF-CACHE-ENTRY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE FIND-SYSTEM) NAME) (COMMON-LISP:LIST SYSTEM)) (LOAD-SYSTEMS* DEFSYSTEM-DEPENDENCIES) (COMMON-LISP:LET ((COMMON-LISP:CLASS (CLASS-FOR-TYPE COMMON-LISP:NIL COMMON-LISP:CLASS))) (COMMON-LISP:UNLESS (COMMON-LISP:SUBTYPEP COMMON-LISP:CLASS (COMMON-LISP:QUOTE SYSTEM)) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE NON-SYSTEM-SYSTEM) :NAME NAME :CLASS-NAME (COMMON-LISP:CLASS-NAME COMMON-LISP:CLASS))) (COMMON-LISP:UNLESS (COMMON-LISP:EQ (COMMON-LISP:TYPE-OF SYSTEM) COMMON-LISP:CLASS) (COMMON-LISP:CHANGE-CLASS SYSTEM COMMON-LISP:CLASS))) (PARSE-COMPONENT-FORM COMMON-LISP:NIL (COMMON-LISP:LIST* :MODULE NAME :PATHNAME (DETERMINE-SYSTEM-DIRECTORY COMMON-LISP:PATHNAME) COMPONENT-OPTIONS))))) (COMMON-LISP:DEFMACRO DEFSYSTEM (NAME COMMON-LISP:&BODY OPTIONS) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:APPLY) (COMMON-LISP:QUOTE (COMMON-LISP:QUOTE REGISTER-SYSTEM-DEFINITION)) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) NAME) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE COMMON-LISP:QUOTE) OPTIONS))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/BUNDLE (:RECYCLE :ASDF/BUNDLE :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/OPERATION :ASDF/ACTION :ASDF/LISP-ACTION :ASDF/PLAN :ASDF/OPERATE :ASDF/DEFSYSTEM) (:EXPORT #:BUNDLE-OP #:BUNDLE-TYPE #:PROGRAM-SYSTEM #:BUNDLE-SYSTEM #:BUNDLE-PATHNAME-TYPE #:DIRECT-DEPENDENCY-FILES #:MONOLITHIC-OP #:MONOLITHIC-BUNDLE-OP #:OPERATION-MONOLITHIC-P #:BASIC-COMPILE-BUNDLE-OP #:PREPARE-BUNDLE-OP #:COMPILE-BUNDLE-OP #:LOAD-BUNDLE-OP #:MONOLITHIC-COMPILE-BUNDLE-OP #:MONOLITHIC-LOAD-BUNDLE-OP #:LIB-OP #:MONOLITHIC-LIB-OP #:DLL-OP #:MONOLITHIC-DLL-OP #:DELIVER-ASD-OP #:MONOLITHIC-DELIVER-ASD-OP #:PROGRAM-OP #:IMAGE-OP #:COMPILED-FILE #:PRECOMPILED-SYSTEM #:PREBUILT-SYSTEM #:USER-SYSTEM-P #:USER-SYSTEM #:TRIVIAL-SYSTEM-P #:MAKE-BUILD #:BUILD-ARGS #:NAME-SUFFIX #:PROLOGUE-CODE #:EPILOGUE-CODE #:STATIC-LIBRARY))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/BUNDLE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS BUNDLE-OP (BASIC-COMPILE-OP) ((BUILD-ARGS :INITARG :ARGS :INITFORM COMMON-LISP:NIL :ACCESSOR EXTRA-BUILD-ARGS) (NAME-SUFFIX :INITARG :NAME-SUFFIX :INITFORM COMMON-LISP:NIL) (BUNDLE-TYPE :INITFORM :NO-OUTPUT-FILE :READER BUNDLE-TYPE))) (COMMON-LISP:DEFCLASS MONOLITHIC-OP (OPERATION) COMMON-LISP:NIL (:DOCUMENTATION "A MONOLITHIC operation operates on a system *and all of its
     [java] dependencies*.  So, for example, a monolithic concatenate operation will
     [java] concatenate together a system's components and all of its dependencies, but a
     [java] simple concatenate operation will concatenate only the components of the system
     [java] itself.")) (COMMON-LISP:DEFCLASS MONOLITHIC-BUNDLE-OP (MONOLITHIC-OP BUNDLE-OP) ((PROLOGUE-CODE :INITFORM COMMON-LISP:NIL :ACCESSOR PROLOGUE-CODE) (EPILOGUE-CODE :INITFORM COMMON-LISP:NIL :ACCESSOR EPILOGUE-CODE))) (COMMON-LISP:DEFCLASS PROGRAM-SYSTEM (SYSTEM) ((PROLOGUE-CODE :INITFORM COMMON-LISP:NIL :INITARG :PROLOGUE-CODE :READER PROLOGUE-CODE) (EPILOGUE-CODE :INITFORM COMMON-LISP:NIL :INITARG :EPILOGUE-CODE :READER EPILOGUE-CODE) (NO-UIOP :INITFORM COMMON-LISP:NIL :INITARG :NO-UIOP :READER NO-UIOP) (PREFIX-LISP-OBJECT-FILES :INITARG :PREFIX-LISP-OBJECT-FILES :INITFORM COMMON-LISP:NIL :ACCESSOR PREFIX-LISP-OBJECT-FILES) (POSTFIX-LISP-OBJECT-FILES :INITARG :POSTFIX-LISP-OBJECT-FILES :INITFORM COMMON-LISP:NIL :ACCESSOR POSTFIX-LISP-OBJECT-FILES) (EXTRA-OBJECT-FILES :INITARG :EXTRA-OBJECT-FILES :INITFORM COMMON-LISP:NIL :ACCESSOR EXTRA-OBJECT-FILES) (EXTRA-BUILD-ARGS :INITARG :EXTRA-BUILD-ARGS :INITFORM COMMON-LISP:NIL :ACCESSOR EXTRA-BUILD-ARGS))) (COMMON-LISP:DEFMETHOD PROLOGUE-CODE ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD EPILOGUE-CODE ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD NO-UIOP ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PREFIX-LISP-OBJECT-FILES ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD POSTFIX-LISP-OBJECT-FILES ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD EXTRA-OBJECT-FILES ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD EXTRA-BUILD-ARGS ((X COMMON-LISP:T)) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS LINK-OP (BUNDLE-OP) COMMON-LISP:NIL (:DOCUMENTATION "Abstract operation for linking files together")) (COMMON-LISP:DEFCLASS GATHER-OP (BUNDLE-OP) ((GATHER-OP :INITFORM COMMON-LISP:NIL :ALLOCATION :CLASS :READER GATHER-OP) (GATHER-TYPE :INITFORM :NO-OUTPUT-FILE :ALLOCATION :CLASS :READER GATHER-TYPE)) (:DOCUMENTATION "Abstract operation for gathering many input files from a system")) (COMMON-LISP:DEFUN OPERATION-MONOLITHIC-P (OP) (COMMON-LISP:TYPEP OP (COMMON-LISP:QUOTE MONOLITHIC-OP))) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O GATHER-OP) (S SYSTEM)) (COMMON-LISP:LET* ((MONO (OPERATION-MONOLITHIC-P O)) (DEPS (REQUIRED-COMPONENTS S :OTHER-SYSTEMS MONO :COMPONENT-TYPE (COMMON-LISP:IF MONO (COMMON-LISP:QUOTE SYSTEM) (COMMON-LISP:QUOTE (COMMON-LISP:NOT SYSTEM))) :GOAL-OPERATION (FIND-OPERATION O (COMMON-LISP:QUOTE LOAD-OP)) :KEEP-OPERATION (COMMON-LISP:QUOTE COMPILE-OP)))) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-CONS (MAKE-OPERATION (COMMON-LISP:OR (GATHER-OP O) (COMMON-LISP:IF MONO (COMMON-LISP:QUOTE LIB-OP) (COMMON-LISP:QUOTE COMPILE-OP)))) DEPS) (COMMON-LISP:CALL-NEXT-METHOD)))) (COMMON-LISP:DEFCLASS BASIC-COMPILE-BUNDLE-OP (BUNDLE-OP) ((GATHER-TYPE :INITFORM :FASL :ALLOCATION :CLASS) (BUNDLE-TYPE :INITFORM :FASL :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS PREPARE-BUNDLE-OP (SIDEWAY-OPERATION) ((SIDEWAY-OPERATION :INITFORM (COMMON-LISP:QUOTE LOAD-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS LIB-OP (LINK-OP GATHER-OP NON-PROPAGATING-OPERATION) ((GATHER-TYPE :INITFORM :OBJECT :ALLOCATION :CLASS) (BUNDLE-TYPE :INITFORM :LIB :ALLOCATION :CLASS)) (:DOCUMENTATION "Compile the system and produce a linkable static library (.a/.lib)
     [java] for all the linkable object files associated with the system. Compare with DLL-OP.
     [java]
     [java] On most implementations, these object files only include extensions to the runtime
     [java] written in C or another language with a compiler producing linkable object files.
     [java] On CLASP, ECL, MKCL, these object files also include the contents of Lisp files
     [java] themselves. In any case, this operation will produce what you need to further build
     [java] a static runtime for your system, or a dynamic library to load in an existing runtime.")) (COMMON-LISP:DEFCLASS COMPILE-BUNDLE-OP (BASIC-COMPILE-BUNDLE-OP SELFWARD-OPERATION GATHER-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-BUNDLE-OP)) :ALLOCATION :CLASS)) (:DOCUMENTATION "This operator is an alternative to COMPILE-OP. Build a system
     [java] and all of its dependencies, but build only a single (\"monolithic\") FASL, instead
     [java] of one per source file, which may be more resource efficient.  That monolithic
     [java] FASL should be loaded with LOAD-BUNDLE-OP, rather than LOAD-OP.")) (COMMON-LISP:DEFCLASS LOAD-BUNDLE-OP (BASIC-LOAD-OP SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-BUNDLE-OP COMPILE-BUNDLE-OP)) :ALLOCATION :CLASS)) (:DOCUMENTATION "This operator is an alternative to LOAD-OP. Build a system
     [java] and all of its dependencies, using COMPILE-BUNDLE-OP. The difference with
     [java] respect to LOAD-OP is that it builds only a single FASL, which may be
     [java] faster and more resource efficient.")) (COMMON-LISP:DEFCLASS DLL-OP (LINK-OP GATHER-OP NON-PROPAGATING-OPERATION) ((GATHER-TYPE :INITFORM :OBJECT :ALLOCATION :CLASS) (BUNDLE-TYPE :INITFORM :DLL :ALLOCATION :CLASS)) (:DOCUMENTATION "Compile the system and produce a dynamic loadable library (.so/.dll)
     [java] for all the linkable object files associated with the system. Compare with LIB-OP.")) (COMMON-LISP:DEFCLASS DELIVER-ASD-OP (BASIC-COMPILE-OP SELFWARD-OPERATION) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (COMPILE-BUNDLE-OP)) :ALLOCATION :CLASS)) (:DOCUMENTATION "produce an asd file for delivering the system as a single fasl")) (COMMON-LISP:DEFCLASS MONOLITHIC-DELIVER-ASD-OP (MONOLITHIC-BUNDLE-OP DELIVER-ASD-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (MONOLITHIC-COMPILE-BUNDLE-OP)) :ALLOCATION :CLASS)) (:DOCUMENTATION "produce fasl and asd files for combined system and dependencies.")) (COMMON-LISP:DEFCLASS MONOLITHIC-COMPILE-BUNDLE-OP (MONOLITHIC-BUNDLE-OP BASIC-COMPILE-BUNDLE-OP GATHER-OP NON-PROPAGATING-OPERATION) ((GATHER-OP :INITFORM (COMMON-LISP:QUOTE COMPILE-BUNDLE-OP) :ALLOCATION :CLASS) (GATHER-TYPE :INITFORM :FASL :ALLOCATION :CLASS)) (:DOCUMENTATION "Create a single fasl for the system and its dependencies.")) (COMMON-LISP:DEFCLASS MONOLITHIC-LOAD-BUNDLE-OP (MONOLITHIC-BUNDLE-OP LOAD-BUNDLE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE MONOLITHIC-COMPILE-BUNDLE-OP) :ALLOCATION :CLASS)) (:DOCUMENTATION "Load a single fasl for the system and its dependencies.")) (COMMON-LISP:DEFCLASS MONOLITHIC-LIB-OP (MONOLITHIC-BUNDLE-OP LIB-OP NON-PROPAGATING-OPERATION) ((GATHER-TYPE :INITFORM :STATIC-LIBRARY :ALLOCATION :CLASS)) (:DOCUMENTATION "Compile the system and produce a linkable static library (.a/.lib)
     [java] for all the linkable object files associated with the system or its dependencies. See LIB-OP.")) (COMMON-LISP:DEFCLASS MONOLITHIC-DLL-OP (MONOLITHIC-BUNDLE-OP DLL-OP NON-PROPAGATING-OPERATION) ((GATHER-TYPE :INITFORM :STATIC-LIBRARY :ALLOCATION :CLASS)) (:DOCUMENTATION "Compile the system and produce a dynamic loadable library (.so/.dll)
     [java] for all the linkable object files associated with the system or its dependencies. See LIB-OP")) (COMMON-LISP:DEFCLASS IMAGE-OP (MONOLITHIC-BUNDLE-OP SELFWARD-OPERATION) ((BUNDLE-TYPE :INITFORM :IMAGE) (SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (LOAD-OP)) :ALLOCATION :CLASS)) (:DOCUMENTATION "create an image file from the system and its dependencies")) (COMMON-LISP:DEFCLASS PROGRAM-OP (IMAGE-OP) ((BUNDLE-TYPE :INITFORM :PROGRAM)) (:DOCUMENTATION "create an executable file from the system and its dependencies")) (COMMON-LISP:DEFUN BUNDLE-PATHNAME-TYPE (BUNDLE-TYPE) (COMMON-LISP:ETYPECASE BUNDLE-TYPE ((COMMON-LISP:OR COMMON-LISP:NULL COMMON-LISP:STRING) BUNDLE-TYPE) ((COMMON-LISP:EQL :NO-OUTPUT-FILE) (COMMON-LISP:ERROR "No output file, therefore no pathname type")) ((COMMON-LISP:EQL :FASL) (UIOP/LISP-BUILD:COMPILE-FILE-TYPE)) ((COMMON-LISP:MEMBER :IMAGE) "image") ((COMMON-LISP:EQL :OBJECT) (UIOP/OS:OS-COND ((UIOP/OS:OS-UNIX-P) "o") ((UIOP/OS:OS-WINDOWS-P) (COMMON-LISP:IF (UIOP/OS:FEATUREP (COMMON-LISP:QUOTE (:OR :MINGW32 :MINGW64))) "o" "obj")))) ((COMMON-LISP:MEMBER :LIB :STATIC-LIBRARY) (UIOP/OS:OS-COND ((UIOP/OS:OS-UNIX-P) "a") ((UIOP/OS:OS-WINDOWS-P) (COMMON-LISP:IF (UIOP/OS:FEATUREP (COMMON-LISP:QUOTE (:OR :MINGW32 :MINGW64))) "a" "lib")))) ((COMMON-LISP:MEMBER :DLL :SHARED-LIBRARY) (UIOP/OS:OS-COND ((UIOP/OS:OS-MACOSX-P) "dylib") ((UIOP/OS:OS-UNIX-P) "so") ((UIOP/OS:OS-WINDOWS-P) "dll"))) ((COMMON-LISP:EQL :PROGRAM) (UIOP/OS:OS-COND ((UIOP/OS:OS-UNIX-P) COMMON-LISP:NIL) ((UIOP/OS:OS-WINDOWS-P) "exe"))))) (COMMON-LISP:DEFUN BUNDLE-OUTPUT-FILES (O C) (COMMON-LISP:LET ((BUNDLE-TYPE (BUNDLE-TYPE O))) (COMMON-LISP:UNLESS (COMMON-LISP:OR (COMMON-LISP:EQ BUNDLE-TYPE :NO-OUTPUT-FILE) (COMMON-LISP:AND (COMMON-LISP:NULL (INPUT-FILES O C)) (COMMON-LISP:NOT (COMMON-LISP:MEMBER BUNDLE-TYPE (COMMON-LISP:QUOTE (:IMAGE :PROGRAM)))))) (COMMON-LISP:LET ((NAME (COMMON-LISP:OR (COMPONENT-BUILD-PATHNAME C) (COMMON-LISP:FORMAT COMMON-LISP:NIL "~A~@[~A~]" (COMPONENT-NAME C) (COMMON-LISP:SLOT-VALUE O (COMMON-LISP:QUOTE NAME-SUFFIX))))) (COMMON-LISP:TYPE (BUNDLE-PATHNAME-TYPE BUNDLE-TYPE))) (COMMON-LISP:VALUES (COMMON-LISP:LIST (UIOP/PATHNAME:SUBPATHNAME (COMPONENT-PATHNAME C) NAME :TYPE COMMON-LISP:TYPE)) (COMMON-LISP:EQ (COMMON-LISP:TYPE-OF O) (UIOP/UTILITY:COERCE-CLASS (COMPONENT-BUILD-OPERATION C) :PACKAGE :ASDF/INTERFACE :SUPER (COMMON-LISP:QUOTE OPERATION) :ERROR COMMON-LISP:NIL))))))) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O BUNDLE-OP) (C SYSTEM)) (BUNDLE-OUTPUT-FILES O C)) (COMMON-LISP:PROGN (COMMON-LISP:DEFMETHOD PERFORM ((O IMAGE-OP) (C SYSTEM)) (UIOP/IMAGE:DUMP-IMAGE (OUTPUT-FILE O C) :EXECUTABLE (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE PROGRAM-OP)))) (COMMON-LISP:DEFMETHOD PERFORM :BEFORE ((O PROGRAM-OP) (C SYSTEM)) (COMMON-LISP:SETF UIOP/IMAGE:*IMAGE-ENTRY-POINT* (UIOP/UTILITY:ENSURE-FUNCTION (COMPONENT-ENTRY-POINT C))))) (COMMON-LISP:DEFCLASS COMPILED-FILE (FILE-COMPONENT) ((COMMON-LISP:TYPE :INITFORM (UIOP/LISP-BUILD:COMPILE-FILE-TYPE)))) (COMMON-LISP:DEFCLASS PRECOMPILED-SYSTEM (SYSTEM) ((BUILD-PATHNAME :INITARG :FASL))) (COMMON-LISP:DEFCLASS PREBUILT-SYSTEM (SYSTEM) ((BUILD-PATHNAME :INITARG :STATIC-LIBRARY :INITARG :LIB :ACCESSOR PREBUILT-SYSTEM-STATIC-LIBRARY))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD COMMON-LISP:INITIALIZE-INSTANCE :AFTER ((INSTANCE BUNDLE-OP) COMMON-LISP:&REST INITARGS COMMON-LISP:&KEY (NAME-SUFFIX COMMON-LISP:NIL NAME-SUFFIX-P) COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE INITARGS NAME-SUFFIX)) (COMMON-LISP:UNLESS NAME-SUFFIX-P (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE INSTANCE (COMMON-LISP:QUOTE NAME-SUFFIX)) (COMMON-LISP:UNLESS (COMMON-LISP:TYPEP INSTANCE (COMMON-LISP:QUOTE PROGRAM-OP)) (COMMON-LISP:IF (OPERATION-MONOLITHIC-P INSTANCE) "--all-systems" "--system")))) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP INSTANCE (COMMON-LISP:QUOTE MONOLITHIC-BUNDLE-OP)) (COMMON-LISP:DESTRUCTURING-BIND (COMMON-LISP:&KEY LISP-FILES PROLOGUE-CODE EPILOGUE-CODE COMMON-LISP:&ALLOW-OTHER-KEYS) (OPERATION-ORIGINAL-INITARGS INSTANCE) (COMMON-LISP:SETF (PROLOGUE-CODE INSTANCE) PROLOGUE-CODE (EPILOGUE-CODE INSTANCE) EPILOGUE-CODE) (COMMON-LISP:ASSERT (COMMON-LISP:NULL (COMMON-LISP:OR LISP-FILES EPILOGUE-CODE PROLOGUE-CODE))))) (COMMON-LISP:SETF (EXTRA-BUILD-ARGS INSTANCE) (UIOP/UTILITY:REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:TYPE :MONOLITHIC :NAME-SUFFIX :EPILOGUE-CODE :PROLOGUE-CODE :LISP-FILES :FORCE :FORCE-NOT :PLAN-CLASS)) (OPERATION-ORIGINAL-INITARGS INSTANCE)))) (UIOP/UTILITY:DEFGENERIC* (TRIVIAL-SYSTEM-P) (COMPONENT)) (COMMON-LISP:DEFUN USER-SYSTEM-P (S) (COMMON-LISP:AND (COMMON-LISP:TYPEP S (COMMON-LISP:QUOTE SYSTEM)) (COMMON-LISP:NOT (BUILTIN-SYSTEM-P S)) (COMMON-LISP:NOT (TRIVIAL-SYSTEM-P S)))))
     [java] ; (COMMON-LISP:DEFTYPE USER-SYSTEM COMMON-LISP:NIL (COMMON-LISP:QUOTE (COMMON-LISP:AND SYSTEM (COMMON-LISP:SATISFIES USER-SYSTEM-P))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN DIRECT-DEPENDENCY-FILES (O C COMMON-LISP:&KEY (TEST (COMMON-LISP:QUOTE COMMON-LISP:IDENTITY)) (KEY (COMMON-LISP:QUOTE OUTPUT-FILES)) COMMON-LISP:&ALLOW-OTHER-KEYS) (UIOP/UTILITY:WHILE-COLLECTING (COLLECT) (MAP-DIRECT-DEPENDENCIES COMMON-LISP:T O C (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (SUB-O SUB-C) (COMMON-LISP:LOOP :FOR F :IN (COMMON-LISP:FUNCALL KEY SUB-O SUB-C) :WHEN (COMMON-LISP:FUNCALL TEST F) :DO (COLLECT F))))))) (COMMON-LISP:DEFUN PATHNAME-TYPE-EQUAL-FUNCTION (COMMON-LISP:TYPE) (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (P) (COMMON-LISP:EQUAL (COMMON-LISP:PATHNAME-TYPE P) COMMON-LISP:TYPE)))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O GATHER-OP) (C SYSTEM)) (COMMON-LISP:UNLESS (COMMON-LISP:EQ (BUNDLE-TYPE O) :NO-OUTPUT-FILE) (DIRECT-DEPENDENCY-FILES O C :KEY (COMMON-LISP:QUOTE OUTPUT-FILES) :TEST (PATHNAME-TYPE-EQUAL-FUNCTION (BUNDLE-PATHNAME-TYPE (GATHER-TYPE O)))))) (COMMON-LISP:DEFUN SELECT-BUNDLE-OPERATION (COMMON-LISP:TYPE COMMON-LISP:&OPTIONAL MONOLITHIC) (COMMON-LISP:ECASE COMMON-LISP:TYPE ((:DLL :SHARED-LIBRARY) (COMMON-LISP:IF MONOLITHIC (COMMON-LISP:QUOTE MONOLITHIC-DLL-OP) (COMMON-LISP:QUOTE DLL-OP))) ((:LIB :STATIC-LIBRARY) (COMMON-LISP:IF MONOLITHIC (COMMON-LISP:QUOTE MONOLITHIC-LIB-OP) (COMMON-LISP:QUOTE LIB-OP))) ((:FASL) (COMMON-LISP:IF MONOLITHIC (COMMON-LISP:QUOTE MONOLITHIC-COMPILE-BUNDLE-OP) (COMMON-LISP:QUOTE COMPILE-BUNDLE-OP))) ((:IMAGE) (COMMON-LISP:QUOTE IMAGE-OP)) ((:PROGRAM) (COMMON-LISP:QUOTE PROGRAM-OP)))) (COMMON-LISP:DEFUN MAKE-BUILD (SYSTEM COMMON-LISP:&REST ARGS COMMON-LISP:&KEY (MONOLITHIC COMMON-LISP:NIL) (COMMON-LISP:TYPE :FASL) (MOVE-HERE COMMON-LISP:NIL MOVE-HERE-P) COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:LET* ((OPERATION-NAME (SELECT-BUNDLE-OPERATION COMMON-LISP:TYPE MONOLITHIC)) (MOVE-HERE-PATH (COMMON-LISP:IF (COMMON-LISP:AND MOVE-HERE (COMMON-LISP:TYPEP MOVE-HERE (COMMON-LISP:QUOTE (COMMON-LISP:OR COMMON-LISP:PATHNAME COMMON-LISP:STRING)))) (UIOP/PATHNAME:ENSURE-PATHNAME MOVE-HERE :NAMESTRING :LISP :ENSURE-DIRECTORY COMMON-LISP:T) (SYSTEM-RELATIVE-PATHNAME SYSTEM "asdf-output/"))) (OPERATION (COMMON-LISP:APPLY (COMMON-LISP:FUNCTION OPERATE) OPERATION-NAME SYSTEM (UIOP/UTILITY:REMOVE-PLIST-KEYS (COMMON-LISP:QUOTE (:MONOLITHIC :TYPE :MOVE-HERE)) ARGS))) (SYSTEM (FIND-SYSTEM SYSTEM)) (FILES (COMMON-LISP:AND SYSTEM (OUTPUT-FILES OPERATION SYSTEM)))) (COMMON-LISP:IF (COMMON-LISP:OR MOVE-HERE (COMMON-LISP:AND (COMMON-LISP:NULL MOVE-HERE-P) (COMMON-LISP:MEMBER OPERATION-NAME (COMMON-LISP:QUOTE (:PROGRAM :IMAGE))))) (COMMON-LISP:LOOP :WITH DEST-PATH COMMON-LISP:= (UIOP/FILESYSTEM:RESOLVE-SYMLINKS* (COMMON-LISP:ENSURE-DIRECTORIES-EXIST MOVE-HERE-PATH)) :FOR F :IN FILES :FOR NEW-F COMMON-LISP:= (COMMON-LISP:MAKE-PATHNAME :NAME (COMMON-LISP:PATHNAME-NAME F) :TYPE (COMMON-LISP:PATHNAME-TYPE F) :DEFAULTS DEST-PATH) :DO (UIOP/FILESYSTEM:RENAME-FILE-OVERWRITING-TARGET F NEW-F) :COLLECT NEW-F) FILES))) (COMMON-LISP:DEFUN BUNDLE-SYSTEM (SYSTEM COMMON-LISP:&REST ARGS COMMON-LISP:&KEY FORCE (VERBOSE COMMON-LISP:T) VERSION COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE FORCE VERBOSE VERSION)) (COMMON-LISP:APPLY (COMMON-LISP:FUNCTION OPERATE) (COMMON-LISP:QUOTE DELIVER-ASD-OP) SYSTEM ARGS)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O LOAD-BUNDLE-OP) (C SYSTEM)) (SYSTEM::BACKQ-LIST* (SYSTEM::BACKQ-CONS O (COMPONENT-SIDEWAY-DEPENDENCIES C)) (SYSTEM::BACKQ-LIST (COMMON-LISP:IF (USER-SYSTEM-P C) (COMMON-LISP:QUOTE COMPILE-BUNDLE-OP) (COMMON-LISP:QUOTE LOAD-OP)) C) (COMMON-LISP:CALL-NEXT-METHOD))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O LOAD-BUNDLE-OP) (C SYSTEM)) (COMMON-LISP:WHEN (USER-SYSTEM-P C) (OUTPUT-FILES (FIND-OPERATION O (COMMON-LISP:QUOTE COMPILE-BUNDLE-OP)) C))) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-BUNDLE-OP) (C SYSTEM)) (COMMON-LISP:WHEN (INPUT-FILES O C) (PERFORM-LISP-LOAD-FASL O C))) (COMMON-LISP:DEFMETHOD MARK-OPERATION-DONE :AFTER ((O LOAD-BUNDLE-OP) (C SYSTEM)) (MARK-OPERATION-DONE (FIND-OPERATION O (COMMON-LISP:QUOTE LOAD-OP)) C)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD TRIVIAL-SYSTEM-P ((S SYSTEM)) (COMMON-LISP:EVERY (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (C) (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE COMPILED-FILE)))) (COMPONENT-CHILDREN S))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O OPERATION) (C COMPILED-FILE)) (COMMON-LISP:LIST (COMPONENT-PATHNAME C))) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-OP) (C COMPILED-FILE)) (PERFORM-LISP-LOAD-FASL O C)) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-SOURCE-OP) (C COMPILED-FILE)) (PERFORM (FIND-OPERATION O (COMMON-LISP:QUOTE LOAD-OP)) C)) (COMMON-LISP:DEFMETHOD PERFORM ((O OPERATION) (C COMPILED-FILE)) COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD TRIVIAL-SYSTEM-P ((S PREBUILT-SYSTEM)) COMMON-LISP:T) (COMMON-LISP:DEFMETHOD PERFORM ((O LINK-OP) (C PREBUILT-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-COMPILE-BUNDLE-OP) (C PREBUILT-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O LIB-OP) (C PREBUILT-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD PERFORM ((O DLL-OP) (C PREBUILT-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O GATHER-OP) (C PREBUILT-SYSTEM)) COMMON-LISP:NIL) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O LIB-OP) (C PREBUILT-SYSTEM)) (COMMON-LISP:VALUES (COMMON-LISP:LIST (PREBUILT-SYSTEM-STATIC-LIBRARY C)) COMMON-LISP:T)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O DELIVER-ASD-OP) (S SYSTEM)) (COMMON-LISP:LIST (COMMON-LISP:MAKE-PATHNAME :NAME (COMPONENT-NAME S) :TYPE "asd" :DEFAULTS (COMPONENT-PATHNAME S)))) (COMMON-LISP:DEFMETHOD PERFORM ((O DELIVER-ASD-OP) (S SYSTEM)) (COMMON-LISP:LET* ((INPUTS (INPUT-FILES O S)) (FASL (COMMON-LISP:FIRST INPUTS)) (LIBRARY (COMMON-LISP:SECOND INPUTS)) (ASD (COMMON-LISP:FIRST (OUTPUT-FILES O S))) (NAME (COMMON-LISP:IF (COMMON-LISP:AND FASL ASD) (COMMON-LISP:PATHNAME-NAME ASD) (COMMON-LISP:RETURN-FROM PERFORM))) (VERSION (COMPONENT-VERSION S)) (DEPENDENCIES (COMMON-LISP:IF (OPERATION-MONOLITHIC-P O) (COMMON-LISP:REMOVE-IF-NOT (COMMON-LISP:QUOTE BUILTIN-SYSTEM-P) (REQUIRED-COMPONENTS S :COMPONENT-TYPE (COMMON-LISP:QUOTE SYSTEM) :KEEP-OPERATION (COMMON-LISP:QUOTE LOAD-OP))) (UIOP/UTILITY:WHILE-COLLECTING (X) (MAP-DIRECT-DEPENDENCIES COMMON-LISP:T (COMMON-LISP:QUOTE LOAD-OP) S (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (O C) (COMMON-LISP:WHEN (COMMON-LISP:AND (COMMON-LISP:TYPEP O (COMMON-LISP:QUOTE LOAD-OP)) (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE SYSTEM))) (X C)))))))) (DEPENDS-ON (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE COERCE-NAME) DEPENDENCIES))) (COMMON-LISP:WHEN (UIOP/PATHNAME:PATHNAME-EQUAL ASD (SYSTEM-SOURCE-FILE S)) (COMMON-LISP:CERROR "overwrite the asd file" "~/asdf-action:format-action/ is going to overwrite the system definition file ~S which is probably not what you want; you probably need to tweak your output translations." (COMMON-LISP:CONS O S) ASD)) (COMMON-LISP:WITH-OPEN-FILE (S ASD :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE :IF-DOES-NOT-EXIST :CREATE) (COMMON-LISP:FORMAT S ";;; Prebuilt~:[~; monolithic~] ASDF definition for system ~A~%" (OPERATION-MONOLITHIC-P O) NAME) (COMMON-LISP:FORMAT S ";;; Built for ~A ~A on a ~A/~A ~A~%" (COMMON-LISP:LISP-IMPLEMENTATION-TYPE) (COMMON-LISP:LISP-IMPLEMENTATION-VERSION) (COMMON-LISP:SOFTWARE-TYPE) (COMMON-LISP:MACHINE-TYPE) (COMMON-LISP:SOFTWARE-VERSION)) (COMMON-LISP:LET ((COMMON-LISP:*PACKAGE* (COMMON-LISP:FIND-PACKAGE :ASDF-USER))) (COMMON-LISP:PPRINT (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE DEFSYSTEM) NAME (COMMON-LISP:QUOTE :CLASS) (COMMON-LISP:QUOTE PREBUILT-SYSTEM) (COMMON-LISP:QUOTE :VERSION) VERSION (COMMON-LISP:QUOTE :DEPENDS-ON) DEPENDS-ON (COMMON-LISP:QUOTE :COMPONENTS) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :COMPILED-FILE) (COMMON-LISP:PATHNAME-NAME FASL))) (COMMON-LISP:WHEN LIBRARY (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :LIB) (COMMON-LISP:FILE-NAMESTRING LIBRARY)))) S) (COMMON-LISP:TERPRI S))))) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-COMPILE-BUNDLE-OP) (C SYSTEM)) (COMMON-LISP:LET* ((INPUT-FILES (INPUT-FILES O C)) (FASL-FILES (COMMON-LISP:REMOVE (UIOP/LISP-BUILD:COMPILE-FILE-TYPE) INPUT-FILES :KEY (COMMON-LISP:FUNCTION COMMON-LISP:PATHNAME-TYPE) :TEST-NOT (COMMON-LISP:FUNCTION COMMON-LISP:EQUALP))) (NON-FASL-FILES (COMMON-LISP:REMOVE (UIOP/LISP-BUILD:COMPILE-FILE-TYPE) INPUT-FILES :KEY (COMMON-LISP:FUNCTION COMMON-LISP:PATHNAME-TYPE) :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUALP))) (OUTPUT-FILES (OUTPUT-FILES O C)) (OUTPUT-FILE (COMMON-LISP:FIRST OUTPUT-FILES))) (COMMON-LISP:ASSERT (COMMON-LISP:EQ (COMMON-LISP:NOT INPUT-FILES) (COMMON-LISP:NOT OUTPUT-FILES))) (COMMON-LISP:WHEN INPUT-FILES (COMMON-LISP:WHEN NON-FASL-FILES (COMMON-LISP:ERROR "On ~A, asdf/bundle can only bundle FASL files, but these were also produced: ~S" (UIOP/OS:IMPLEMENTATION-TYPE) NON-FASL-FILES)) (COMMON-LISP:WHEN (COMMON-LISP:OR (PROLOGUE-CODE O) (EPILOGUE-CODE O) (PROLOGUE-CODE C) (EPILOGUE-CODE C)) (COMMON-LISP:ERROR "prologue-code and epilogue-code are not supported on ~A" (UIOP/OS:IMPLEMENTATION-TYPE))) (UIOP/STREAM:WITH-STAGING-PATHNAME (OUTPUT-FILE) (UIOP/LISP-BUILD:COMBINE-FASLS FASL-FILES OUTPUT-FILE))))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((O LOAD-OP) (S PRECOMPILED-SYSTEM)) (BUNDLE-OUTPUT-FILES (FIND-OPERATION O (COMMON-LISP:QUOTE COMPILE-BUNDLE-OP)) S)) (COMMON-LISP:DEFMETHOD PERFORM ((O LOAD-OP) (S PRECOMPILED-SYSTEM)) (PERFORM-LISP-LOAD-FASL O S)) (COMMON-LISP:DEFMETHOD COMPONENT-DEPENDS-ON ((O LOAD-BUNDLE-OP) (S PRECOMPILED-SYSTEM)) (SYSTEM::BACKQ-CONS (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE LOAD-OP) S) (COMMON-LISP:CALL-NEXT-METHOD))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/CONCATENATE-SOURCE (:RECYCLE :ASDF/CONCATENATE-SOURCE :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/OPERATION :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/ACTION :ASDF/LISP-ACTION :ASDF/BUNDLE) (:EXPORT #:CONCATENATE-SOURCE-OP #:LOAD-CONCATENATED-SOURCE-OP #:COMPILE-CONCATENATED-SOURCE-OP #:LOAD-COMPILED-CONCATENATED-SOURCE-OP #:MONOLITHIC-CONCATENATE-SOURCE-OP #:MONOLITHIC-LOAD-CONCATENATED-SOURCE-OP #:MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP #:MONOLITHIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/CONCATENATE-SOURCE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFCLASS BASIC-CONCATENATE-SOURCE-OP (BUNDLE-OP) ((BUNDLE-TYPE :INITFORM "lisp"))) (COMMON-LISP:DEFCLASS BASIC-LOAD-CONCATENATED-SOURCE-OP (BASIC-LOAD-OP SELFWARD-OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS BASIC-COMPILE-CONCATENATED-SOURCE-OP (BASIC-COMPILE-OP SELFWARD-OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS BASIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP (BASIC-LOAD-OP SELFWARD-OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS CONCATENATE-SOURCE-OP (BASIC-CONCATENATE-SOURCE-OP NON-PROPAGATING-OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS LOAD-CONCATENATED-SOURCE-OP (BASIC-LOAD-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-OP CONCATENATE-SOURCE-OP)) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS COMPILE-CONCATENATED-SOURCE-OP (BASIC-COMPILE-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-OP CONCATENATE-SOURCE-OP)) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS LOAD-COMPILED-CONCATENATED-SOURCE-OP (BASIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE (PREPARE-OP COMPILE-CONCATENATED-SOURCE-OP)) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS MONOLITHIC-CONCATENATE-SOURCE-OP (BASIC-CONCATENATE-SOURCE-OP MONOLITHIC-BUNDLE-OP NON-PROPAGATING-OPERATION) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS MONOLITHIC-LOAD-CONCATENATED-SOURCE-OP (BASIC-LOAD-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE MONOLITHIC-CONCATENATE-SOURCE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP (BASIC-COMPILE-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE MONOLITHIC-CONCATENATE-SOURCE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFCLASS MONOLITHIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP (BASIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP) ((SELFWARD-OPERATION :INITFORM (COMMON-LISP:QUOTE MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP) :ALLOCATION :CLASS))) (COMMON-LISP:DEFMETHOD INPUT-FILES ((OPERATION BASIC-CONCATENATE-SOURCE-OP) (S SYSTEM)) (COMMON-LISP:LOOP :WITH ENCODING COMMON-LISP:= (COMMON-LISP:OR (COMPONENT-ENCODING S) UIOP/STREAM:*DEFAULT-ENCODING*) :WITH OTHER-ENCODINGS COMMON-LISP:= (COMMON-LISP:QUOTE COMMON-LISP:NIL) :WITH AROUND-COMPILE COMMON-LISP:= (AROUND-COMPILE-HOOK S) :WITH OTHER-AROUND-COMPILE COMMON-LISP:= (COMMON-LISP:QUOTE COMMON-LISP:NIL) :FOR C :IN (REQUIRED-COMPONENTS S :GOAL-OPERATION (COMMON-LISP:QUOTE COMPILE-OP) :KEEP-OPERATION (COMMON-LISP:QUOTE COMPILE-OP) :OTHER-SYSTEMS (OPERATION-MONOLITHIC-P OPERATION)) :APPEND (COMMON-LISP:WHEN (COMMON-LISP:TYPEP C (COMMON-LISP:QUOTE CL-SOURCE-FILE)) (COMMON-LISP:LET ((E (COMPONENT-ENCODING C))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL E ENCODING) (COMMON-LISP:LET ((A (COMMON-LISP:ASSOC E OTHER-ENCODINGS))) (COMMON-LISP:IF A (COMMON-LISP:PUSH (COMPONENT-FIND-PATH C) (COMMON-LISP:CDR A)) (COMMON-LISP:PUSH (COMMON-LISP:LIST A (COMPONENT-FIND-PATH C)) OTHER-ENCODINGS))))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL AROUND-COMPILE (AROUND-COMPILE-HOOK C)) (COMMON-LISP:PUSH (COMPONENT-FIND-PATH C) OTHER-AROUND-COMPILE)) (INPUT-FILES (MAKE-OPERATION (COMMON-LISP:QUOTE COMPILE-OP)) C)) :INTO INPUTS :FINALLY (COMMON-LISP:WHEN OTHER-ENCODINGS (COMMON-LISP:WARN "~S uses encoding ~A but has sources that use these encodings:~{ ~A~}" OPERATION ENCODING (COMMON-LISP:MAPCAR (COMMON-LISP:FUNCTION (COMMON-LISP:LAMBDA (X) (COMMON-LISP:CONS (COMMON-LISP:CAR X) (COMMON-LISP:LIST (COMMON-LISP:REVERSE (COMMON-LISP:CDR X)))))) OTHER-ENCODINGS))) (COMMON-LISP:WHEN OTHER-AROUND-COMPILE (COMMON-LISP:WARN "~S uses around-compile hook ~A but has sources that use these hooks: ~A" OPERATION AROUND-COMPILE OTHER-AROUND-COMPILE)) (COMMON-LISP:RETURN INPUTS))) (COMMON-LISP:DEFMETHOD OUTPUT-FILES ((O BASIC-COMPILE-CONCATENATED-SOURCE-OP) (S SYSTEM)) (LISP-COMPILATION-OUTPUT-FILES O S)) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-CONCATENATE-SOURCE-OP) (S SYSTEM)) (COMMON-LISP:LET* ((INS (INPUT-FILES O S)) (OUT (OUTPUT-FILE O S)) (TMP (UIOP/STREAM:TMPIZE-PATHNAME OUT))) (UIOP/STREAM:CONCATENATE-FILES INS TMP) (UIOP/FILESYSTEM:RENAME-FILE-OVERWRITING-TARGET TMP OUT))) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-LOAD-CONCATENATED-SOURCE-OP) (S SYSTEM)) (PERFORM-LISP-LOAD-SOURCE O S)) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-COMPILE-CONCATENATED-SOURCE-OP) (S SYSTEM)) (PERFORM-LISP-COMPILATION O S)) (COMMON-LISP:DEFMETHOD PERFORM ((O BASIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP) (S SYSTEM)) (PERFORM-LISP-LOAD-FASL O S)))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/PACKAGE-INFERRED-SYSTEM (:RECYCLE :ASDF/PACKAGE-INFERRED-SYSTEM :ASDF/PACKAGE-SYSTEM :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/DEFSYSTEM :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/LISP-ACTION) (:EXPORT #:PACKAGE-INFERRED-SYSTEM #:SYSDEF-PACKAGE-INFERRED-SYSTEM-SEARCH #:PACKAGE-SYSTEM #:REGISTER-SYSTEM-PACKAGES #:*DEFPACKAGE-FORMS* #:*PACKAGE-INFERRED-SYSTEMS* #:PACKAGE-INFERRED-SYSTEM-MISSING-PACKAGE-ERROR))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/PACKAGE-INFERRED-SYSTEM)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFPARAMETER *DEFPACKAGE-FORMS* (COMMON-LISP:QUOTE (COMMON-LISP:DEFPACKAGE UIOP/PACKAGE:DEFINE-PACKAGE))) (COMMON-LISP:DEFUN INITIAL-PACKAGE-INFERRED-SYSTEMS-TABLE COMMON-LISP:NIL (COMMON-LISP:LET ((H (COMMON-LISP:MAKE-HASH-TABLE :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL)))) (COMMON-LISP:DOLIST (P (COMMON-LISP:LIST-ALL-PACKAGES)) (COMMON-LISP:DOLIST (N (UIOP/PACKAGE:PACKAGE-NAMES P)) (COMMON-LISP:SETF (COMMON-LISP:GETHASH N H) COMMON-LISP:T))) H)) (COMMON-LISP:DEFVAR *PACKAGE-INFERRED-SYSTEMS* (INITIAL-PACKAGE-INFERRED-SYSTEMS-TABLE)) (COMMON-LISP:DEFCLASS PACKAGE-INFERRED-SYSTEM (SYSTEM) COMMON-LISP:NIL) (COMMON-LISP:DEFCLASS PACKAGE-SYSTEM (PACKAGE-INFERRED-SYSTEM) COMMON-LISP:NIL) (COMMON-LISP:DEFUN DEFPACKAGE-FORM-P (FORM) (COMMON-LISP:AND (COMMON-LISP:CONSP FORM) (COMMON-LISP:MEMBER (COMMON-LISP:CAR FORM) *DEFPACKAGE-FORMS*))) (COMMON-LISP:DEFUN STREAM-DEFPACKAGE-FORM (COMMON-LISP:STREAM) (COMMON-LISP:LOOP :FOR FORM COMMON-LISP:= (COMMON-LISP:READ COMMON-LISP:STREAM COMMON-LISP:NIL COMMON-LISP:NIL) :WHILE FORM :WHEN (DEFPACKAGE-FORM-P FORM) :RETURN FORM)) (COMMON-LISP:DEFUN FILE-DEFPACKAGE-FORM (FILE) "Return the first DEFPACKAGE form in FILE." (UIOP/STREAM:WITH-INPUT-FILE (F FILE) (STREAM-DEFPACKAGE-FORM F))) (COMMON-LISP:DEFINE-CONDITION PACKAGE-INFERRED-SYSTEM-MISSING-PACKAGE-ERROR (SYSTEM-DEFINITION-ERROR) ((SYSTEM :INITARG :SYSTEM :READER ERROR-SYSTEM) (COMMON-LISP:PATHNAME :INITARG :PATHNAME :READER ERROR-PATHNAME)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<No package form found while ~
     [java]                                      trying to define package-inferred-system ~A from file ~A~>") (ERROR-SYSTEM C) (ERROR-PATHNAME C))))) (COMMON-LISP:DEFUN PACKAGE-DEPENDENCIES (DEFPACKAGE-FORM) "Return a list of packages depended on by the package
     [java] defined in DEFPACKAGE-FORM.  A package is depended upon if
     [java] the DEFPACKAGE-FORM uses it or imports a symbol from it." (COMMON-LISP:ASSERT (DEFPACKAGE-FORM-P DEFPACKAGE-FORM)) (COMMON-LISP:REMOVE-DUPLICATES (UIOP/UTILITY:WHILE-COLLECTING (DEP) (UIOP/COMMON-LISP::LOOP* :FOR (OPTION . ARGUMENTS) :IN (COMMON-LISP:CDDR DEFPACKAGE-FORM) :DO (COMMON-LISP:ECASE OPTION ((:USE :MIX :REEXPORT :USE-REEXPORT :MIX-REEXPORT) (COMMON-LISP:DOLIST (P ARGUMENTS) (DEP (COMMON-LISP:STRING P)))) ((:IMPORT-FROM :SHADOWING-IMPORT-FROM) (DEP (COMMON-LISP:STRING (COMMON-LISP:FIRST ARGUMENTS)))) ((:NICKNAMES :DOCUMENTATION :SHADOW :EXPORT :INTERN :UNINTERN :RECYCLE))))) :FROM-END COMMON-LISP:T :TEST (COMMON-LISP:QUOTE COMMON-LISP:EQUAL))) (COMMON-LISP:DEFUN PACKAGE-DESIGNATOR-NAME (COMMON-LISP:PACKAGE) (COMMON-LISP:ETYPECASE COMMON-LISP:PACKAGE (COMMON-LISP:PACKAGE (COMMON-LISP:PACKAGE-NAME COMMON-LISP:PACKAGE)) (COMMON-LISP:STRING COMMON-LISP:PACKAGE) (COMMON-LISP:SYMBOL (COMMON-LISP:STRING COMMON-LISP:PACKAGE)))) (COMMON-LISP:DEFUN REGISTER-SYSTEM-PACKAGES (SYSTEM PACKAGES) "Register SYSTEM as providing PACKAGES." (COMMON-LISP:LET ((NAME (COMMON-LISP:OR (COMMON-LISP:EQ SYSTEM COMMON-LISP:T) (COERCE-NAME SYSTEM)))) (COMMON-LISP:DOLIST (P (UIOP/UTILITY:ENSURE-LIST PACKAGES)) (COMMON-LISP:SETF (COMMON-LISP:GETHASH (PACKAGE-DESIGNATOR-NAME P) *PACKAGE-INFERRED-SYSTEMS*) NAME)))) (COMMON-LISP:DEFUN PACKAGE-NAME-SYSTEM (COMMON-LISP:PACKAGE-NAME) "Return the name of the SYSTEM providing PACKAGE-NAME, if such exists,
     [java] otherwise return a default system name computed from PACKAGE-NAME." (COMMON-LISP:CHECK-TYPE COMMON-LISP:PACKAGE-NAME COMMON-LISP:STRING) (UIOP/UTILITY:IF-LET ((SYSTEM-NAME (COMMON-LISP:GETHASH COMMON-LISP:PACKAGE-NAME *PACKAGE-INFERRED-SYSTEMS*))) SYSTEM-NAME (COMMON-LISP:STRING-DOWNCASE COMMON-LISP:PACKAGE-NAME))) (COMMON-LISP:DEFUN PACKAGE-INFERRED-SYSTEM-FILE-DEPENDENCIES (FILE COMMON-LISP:&OPTIONAL SYSTEM) (UIOP/UTILITY:IF-LET (DEFPACKAGE-FORM (FILE-DEFPACKAGE-FORM FILE)) (COMMON-LISP:REMOVE COMMON-LISP:T (COMMON-LISP:MAPCAR (COMMON-LISP:QUOTE PACKAGE-NAME-SYSTEM) (PACKAGE-DEPENDENCIES DEFPACKAGE-FORM))) (COMMON-LISP:ERROR (COMMON-LISP:QUOTE PACKAGE-INFERRED-SYSTEM-MISSING-PACKAGE-ERROR) :SYSTEM SYSTEM :PATHNAME FILE))) (COMMON-LISP:DEFUN SAME-PACKAGE-INFERRED-SYSTEM-P (SYSTEM NAME COMMON-LISP:DIRECTORY SUBPATH DEPENDENCIES) (COMMON-LISP:AND (COMMON-LISP:EQ (COMMON-LISP:TYPE-OF SYSTEM) (COMMON-LISP:QUOTE PACKAGE-INFERRED-SYSTEM)) (COMMON-LISP:EQUAL (COMPONENT-NAME SYSTEM) NAME) (UIOP/PATHNAME:PATHNAME-EQUAL COMMON-LISP:DIRECTORY (COMPONENT-PATHNAME SYSTEM)) (COMMON-LISP:EQUAL DEPENDENCIES (COMPONENT-SIDEWAY-DEPENDENCIES SYSTEM)) (COMMON-LISP:LET ((CHILDREN (COMPONENT-CHILDREN SYSTEM))) (COMMON-LISP:AND (UIOP/UTILITY:LENGTH=N-P CHILDREN 1) (COMMON-LISP:LET ((CHILD (COMMON-LISP:FIRST CHILDREN))) (COMMON-LISP:AND (COMMON-LISP:EQ (COMMON-LISP:TYPE-OF CHILD) (COMMON-LISP:QUOTE CL-SOURCE-FILE)) (COMMON-LISP:EQUAL (COMPONENT-NAME CHILD) "lisp") (COMMON-LISP:AND (COMMON-LISP:SLOT-BOUNDP CHILD (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) (COMMON-LISP:EQUAL (COMMON-LISP:SLOT-VALUE CHILD (COMMON-LISP:QUOTE RELATIVE-PATHNAME)) SUBPATH)))))))) (COMMON-LISP:DEFUN SYSDEF-PACKAGE-INFERRED-SYSTEM-SEARCH (SYSTEM) (COMMON-LISP:LET ((PRIMARY (PRIMARY-SYSTEM-NAME SYSTEM))) (COMMON-LISP:UNLESS (COMMON-LISP:EQUAL PRIMARY SYSTEM) (COMMON-LISP:LET ((TOP (FIND-SYSTEM PRIMARY COMMON-LISP:NIL))) (COMMON-LISP:WHEN (COMMON-LISP:TYPEP TOP (COMMON-LISP:QUOTE PACKAGE-INFERRED-SYSTEM)) (UIOP/UTILITY:IF-LET (DIR (COMPONENT-PATHNAME TOP)) (COMMON-LISP:LET* ((SUB (COMMON-LISP:SUBSEQ SYSTEM (COMMON-LISP:1+ (COMMON-LISP:LENGTH PRIMARY)))) (F (UIOP/FILESYSTEM:PROBE-FILE* (UIOP/PATHNAME:SUBPATHNAME DIR SUB :TYPE "lisp") :TRUENAME UIOP/FILESYSTEM:*RESOLVE-SYMLINKS*))) (COMMON-LISP:WHEN (UIOP/PATHNAME:FILE-PATHNAME-P F) (COMMON-LISP:LET ((DEPENDENCIES (PACKAGE-INFERRED-SYSTEM-FILE-DEPENDENCIES F SYSTEM)) (PREVIOUS (COMMON-LISP:CDR (SYSTEM-REGISTERED-P SYSTEM)))) (COMMON-LISP:IF (SAME-PACKAGE-INFERRED-SYSTEM-P PREVIOUS SYSTEM DIR SUB DEPENDENCIES) PREVIOUS (COMMON-LISP:EVAL (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE DEFSYSTEM) SYSTEM (COMMON-LISP:QUOTE :CLASS) (COMMON-LISP:QUOTE PACKAGE-INFERRED-SYSTEM) (COMMON-LISP:QUOTE :SOURCE-FILE) COMMON-LISP:NIL (COMMON-LISP:QUOTE :PATHNAME) DIR (COMMON-LISP:QUOTE :DEPENDS-ON) DEPENDENCIES (COMMON-LISP:QUOTE :COMPONENTS) (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE CL-SOURCE-FILE) "lisp" (COMMON-LISP:QUOTE :PATHNAME) SUB)))))))))))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:PUSHNEW (COMMON-LISP:QUOTE SYSDEF-PACKAGE-INFERRED-SYSTEM-SEARCH) *SYSTEM-DEFINITION-SEARCH-FUNCTIONS*) (COMMON-LISP:SETF *SYSTEM-DEFINITION-SEARCH-FUNCTIONS* (COMMON-LISP:REMOVE (UIOP/PACKAGE:FIND-SYMBOL* :SYSDEF-PACKAGE-SYSTEM-SEARCH :ASDF/PACKAGE-SYSTEM COMMON-LISP:NIL) *SYSTEM-DEFINITION-SEARCH-FUNCTIONS*)))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/BACKWARD-INTERNALS (:RECYCLE :ASDF/BACKWARD-INTERNALS :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/FIND-SYSTEM) (:EXPORT #:MAKE-SUB-OPERATION #:LOAD-SYSDEF #:MAKE-TEMPORARY-PACKAGE))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/BACKWARD-INTERNALS)
     [java] ; (WHEN-UPGRADING (:WHEN (COMMON-LISP:FBOUNDP (COMMON-LISP:QUOTE MAKE-SUB-OPERATION))) (COMMON-LISP:DEFUN MAKE-SUB-OPERATION (C O DEP-C DEP-O) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE C O DEP-C DEP-O)) (ASDF-UPGRADE-ERROR)))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN LOAD-SYSDEF (NAME COMMON-LISP:PATHNAME) (LOAD-ASD COMMON-LISP:PATHNAME :NAME NAME)) (COMMON-LISP:DEFUN MAKE-TEMPORARY-PACKAGE COMMON-LISP:NIL (COMMON-LISP:MAKE-PACKAGE (UIOP/PACKAGE:FRESH-PACKAGE-NAME :PREFIX :ASDF :INDEX 0) :USE (COMMON-LISP:QUOTE (:CL :ASDF)))))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/BACKWARD-INTERFACE (:RECYCLE :ASDF/BACKWARD-INTERFACE :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/OPERATION :ASDF/ACTION :ASDF/LISP-ACTION :ASDF/PLAN :ASDF/OPERATE :ASDF/OUTPUT-TRANSLATIONS) (:EXPORT #:*ASDF-VERBOSE* #:OPERATION-ERROR #:COMPILE-ERROR #:COMPILE-FAILED #:COMPILE-WARNED #:ERROR-COMPONENT #:ERROR-OPERATION #:TRAVERSE #:COMPONENT-LOAD-DEPENDENCIES #:ENABLE-ASDF-BINARY-LOCATIONS-COMPATIBILITY #:OPERATION-FORCED #:OPERATION-ON-FAILURE #:OPERATION-ON-WARNINGS #:ON-FAILURE #:ON-WARNINGS #:COMPONENT-PROPERTY #:RUN-SHELL-COMMAND #:SYSTEM-DEFINITION-PATHNAME))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/BACKWARD-INTERFACE)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFINE-CONDITION OPERATION-ERROR (COMMON-LISP:ERROR) ((COMPONENT :READER ERROR-COMPONENT :INITARG :COMPONENT) (OPERATION :READER ERROR-OPERATION :INITARG :OPERATION)) (:REPORT (COMMON-LISP:LAMBDA (C S) (COMMON-LISP:FORMAT S (UIOP/COMMON-LISP::COMPATFMT "~@<~A while invoking ~A on ~A~@:>") (COMMON-LISP:TYPE-OF C) (ERROR-OPERATION C) (ERROR-COMPONENT C))))) (COMMON-LISP:DEFINE-CONDITION COMPILE-ERROR (OPERATION-ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-FAILED (COMPILE-ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFINE-CONDITION COMPILE-WARNED (COMPILE-ERROR) COMMON-LISP:NIL) (COMMON-LISP:DEFUN COMPONENT-LOAD-DEPENDENCIES (COMPONENT) (COMPONENT-SIDEWAY-DEPENDENCIES COMPONENT)) (COMMON-LISP:DEFGENERIC OPERATION-FORCED (OPERATION)) (COMMON-LISP:DEFMETHOD OPERATION-FORCED ((O OPERATION)) (COMMON-LISP:GETF (OPERATION-ORIGINAL-INITARGS O) :FORCE)) (COMMON-LISP:DEFGENERIC OPERATION-ON-WARNINGS (OPERATION)) (COMMON-LISP:DEFGENERIC OPERATION-ON-FAILURE (OPERATION)) (COMMON-LISP:DEFGENERIC (COMMON-LISP:SETF OPERATION-ON-WARNINGS) (X OPERATION)) (COMMON-LISP:DEFGENERIC (COMMON-LISP:SETF OPERATION-ON-FAILURE) (X OPERATION)) (COMMON-LISP:DEFMETHOD OPERATION-ON-WARNINGS ((O OPERATION)) UIOP/LISP-BUILD:*COMPILE-FILE-WARNINGS-BEHAVIOUR*) (COMMON-LISP:DEFMETHOD OPERATION-ON-FAILURE ((O OPERATION)) UIOP/LISP-BUILD:*COMPILE-FILE-FAILURE-BEHAVIOUR*) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF OPERATION-ON-WARNINGS) (X (O OPERATION)) (COMMON-LISP:SETF UIOP/LISP-BUILD:*COMPILE-FILE-WARNINGS-BEHAVIOUR* X)) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF OPERATION-ON-FAILURE) (X (O OPERATION)) (COMMON-LISP:SETF UIOP/LISP-BUILD:*COMPILE-FILE-FAILURE-BEHAVIOUR* X)) (COMMON-LISP:DEFUN SYSTEM-DEFINITION-PATHNAME (X) "Function ASDF:SYSTEM-DEFINITION-PATHNAME is obsolete.
     [java] It used to expose ASDF internals with subtle differences with respect to
     [java] user expectations, that have been refactored away since.
     [java] We recommend you use ASDF:SYSTEM-SOURCE-FILE instead
     [java] for a mostly compatible replacement that we're supporting,
     [java] or even ASDF:SYSTEM-SOURCE-DIRECTORY or ASDF:SYSTEM-RELATIVE-PATHNAME
     [java] if that's whay you mean." (SYSTEM-SOURCE-FILE X)) (UIOP/UTILITY:DEFGENERIC* (TRAVERSE) (OPERATION COMPONENT COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (:DOCUMENTATION "Generate and return a plan for performing OPERATION on COMPONENT.
     [java]
     [java] The plan returned is a list of dotted-pairs. Each pair is the CONS
     [java] of ASDF operation object and a COMPONENT object. The pairs will be
     [java] processed in order by OPERATE.")) (DEFINE-CONVENIENCE-ACTION-METHODS TRAVERSE (OPERATION COMPONENT COMMON-LISP:&KEY)) (COMMON-LISP:DEFMETHOD TRAVERSE ((O OPERATION) (C COMPONENT) COMMON-LISP:&REST KEYS COMMON-LISP:&KEY PLAN-CLASS COMMON-LISP:&ALLOW-OTHER-KEYS) (PLAN-ACTIONS (COMMON-LISP:APPLY (COMMON-LISP:QUOTE MAKE-PLAN) PLAN-CLASS O C KEYS))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN ENABLE-ASDF-BINARY-LOCATIONS-COMPATIBILITY (COMMON-LISP:&KEY (CENTRALIZE-LISP-BINARIES COMMON-LISP:NIL) (DEFAULT-TOPLEVEL-DIRECTORY (UIOP/PATHNAME:SUBPATHNAME (COMMON-LISP:USER-HOMEDIR-PATHNAME) ".fasls/")) (INCLUDE-PER-USER-INFORMATION COMMON-LISP:NIL) (MAP-ALL-SOURCE-FILES (COMMON-LISP:OR COMMON-LISP:NIL)) (SOURCE-TO-TARGET-MAPPINGS COMMON-LISP:NIL) (FILE-TYPES (SYSTEM::BACKQ-CONS (UIOP/LISP-BUILD:COMPILE-FILE-TYPE) (COMMON-LISP:QUOTE ("build-report"))))) (COMMON-LISP:LET* ((PATTERNS (COMMON-LISP:IF MAP-ALL-SOURCE-FILES (COMMON-LISP:LIST UIOP/PATHNAME:*WILD-FILE*) (COMMON-LISP:LOOP :FOR COMMON-LISP:TYPE :IN FILE-TYPES :COLLECT (COMMON-LISP:MAKE-PATHNAME :TYPE COMMON-LISP:TYPE :DEFAULTS UIOP/PATHNAME:*WILD-FILE*)))) (DESTINATION-DIRECTORY (COMMON-LISP:IF CENTRALIZE-LISP-BINARIES (SYSTEM::BACKQ-CONS DEFAULT-TOPLEVEL-DIRECTORY (SYSTEM::BACKQ-APPEND (COMMON-LISP:WHEN INCLUDE-PER-USER-INFORMATION (COMMON-LISP:CDR (COMMON-LISP:PATHNAME-DIRECTORY (COMMON-LISP:USER-HOMEDIR-PATHNAME)))) (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :IMPLEMENTATION) UIOP/PATHNAME:*WILD-INFERIORS*))) (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE :ROOT) UIOP/PATHNAME:*WILD-INFERIORS* (COMMON-LISP:QUOTE (:IMPLEMENTATION)))))) (INITIALIZE-OUTPUT-TRANSLATIONS (SYSTEM::BACKQ-CONS (COMMON-LISP:QUOTE :OUTPUT-TRANSLATIONS) (SYSTEM::BACKQ-APPEND SOURCE-TO-TARGET-MAPPINGS (SYSTEM::BACKQ-LIST* (COMMON-LISP:QUOTE (#P"jar:file:/**/*.jar!/**/*.*" (:FUNCTION TRANSLATE-JAR-PATHNAME))) (SYSTEM::BACKQ-LIST #P"/___jar___file___root___/**/*.*" DESTINATION-DIRECTORY) (SYSTEM::BACKQ-APPEND (COMMON-LISP:LOOP :FOR PATTERN :IN PATTERNS :COLLECT (SYSTEM::BACKQ-LIST (SYSTEM::BACKQ-LIST (COMMON-LISP:QUOTE :ROOT) UIOP/PATHNAME:*WILD-INFERIORS* PATTERN) (SYSTEM::BACKQ-APPEND DESTINATION-DIRECTORY (SYSTEM::BACKQ-LIST PATTERN)))) (COMMON-LISP:QUOTE ((COMMON-LISP:T COMMON-LISP:T) :IGNORE-INHERITED-CONFIGURATION))))))))) (COMMON-LISP:DEFMETHOD OPERATE :BEFORE (OPERATION-CLASS SYSTEM COMMON-LISP:&REST ARGS COMMON-LISP:&KEY COMMON-LISP:&ALLOW-OTHER-KEYS) (COMMON-LISP:DECLARE (COMMON-LISP:IGNORE OPERATION-CLASS SYSTEM ARGS)) (COMMON-LISP:WHEN (UIOP/PACKAGE:FIND-SYMBOL* (COMMON-LISP:QUOTE #:OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION) :ASDF COMMON-LISP:NIL) (COMMON-LISP:ERROR "ASDF 2 is not compatible with ASDF-BINARY-LOCATIONS, which you are using.
     [java] ASDF 2 now achieves the same purpose with its builtin ASDF-OUTPUT-TRANSLATIONS,
     [java] which should be easier to configure. Please stop using ASDF-BINARY-LOCATIONS,
     [java] and instead use ASDF-OUTPUT-TRANSLATIONS. See the ASDF manual for details.
     [java] In case you insist on preserving your previous A-B-L configuration, but
     [java] do not know how to achieve the same effect with A-O-T, you may use function
     [java] ASDF:ENABLE-ASDF-BINARY-LOCATIONS-COMPATIBILITY as documented in the manual;
     [java] call that function where you would otherwise have loaded and configured A-B-L."))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFUN RUN-SHELL-COMMAND (CONTROL-STRING COMMON-LISP:&REST ARGS) "Interpolate ARGS into CONTROL-STRING as if by FORMAT, and
     [java] synchronously execute the result using a Bourne-compatible shell, with
     [java] output to *VERBOSE-OUT*.  Returns the shell's exit code.
     [java]
     [java] PLEASE DO NOT USE.
     [java] Deprecated function, for backward-compatibility only.
     [java] Please use UIOP:RUN-PROGRAM instead." (COMMON-LISP:LET ((COMMAND (COMMON-LISP:APPLY (COMMON-LISP:QUOTE COMMON-LISP:FORMAT) COMMON-LISP:NIL CONTROL-STRING ARGS))) (ASDF-MESSAGE "; $ ~A~%" COMMAND) (COMMON-LISP:LET ((EXIT-CODE (COMMON-LISP:IGNORE-ERRORS (COMMON-LISP:NTH-VALUE 2 (UIOP/RUN-PROGRAM:RUN-PROGRAM COMMAND :FORCE-SHELL COMMON-LISP:T :IGNORE-ERROR-STATUS COMMON-LISP:T :OUTPUT *VERBOSE-OUT*))))) (COMMON-LISP:TYPECASE EXIT-CODE ((COMMON-LISP:INTEGER 0 255) EXIT-CODE) (COMMON-LISP:T 255))))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFVAR *ASDF-VERBOSE* COMMON-LISP:NIL))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DEFGENERIC COMPONENT-PROPERTY (COMPONENT PROPERTY)) (COMMON-LISP:DEFGENERIC (COMMON-LISP:SETF COMPONENT-PROPERTY) (NEW-VALUE COMPONENT PROPERTY)) (COMMON-LISP:DEFMETHOD COMPONENT-PROPERTY ((C COMPONENT) PROPERTY) (COMMON-LISP:CDR (COMMON-LISP:ASSOC PROPERTY (COMMON-LISP:SLOT-VALUE C (COMMON-LISP:QUOTE PROPERTIES)) :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUAL)))) (COMMON-LISP:DEFMETHOD (COMMON-LISP:SETF COMPONENT-PROPERTY) (NEW-VALUE (C COMPONENT) PROPERTY) (COMMON-LISP:LET ((A (COMMON-LISP:ASSOC PROPERTY (COMMON-LISP:SLOT-VALUE C (COMMON-LISP:QUOTE PROPERTIES)) :TEST (COMMON-LISP:FUNCTION COMMON-LISP:EQUAL)))) (COMMON-LISP:IF A (COMMON-LISP:SETF (COMMON-LISP:CDR A) NEW-VALUE) (COMMON-LISP:SETF (COMMON-LISP:SLOT-VALUE C (COMMON-LISP:QUOTE PROPERTIES)) (COMMON-LISP:ACONS PROPERTY NEW-VALUE (COMMON-LISP:SLOT-VALUE C (COMMON-LISP:QUOTE PROPERTIES)))))) NEW-VALUE))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/INTERFACE (:NICKNAMES :ASDF :ASDF-UTILITIES) (:RECYCLE :ASDF/INTERFACE :ASDF) (:UNINTERN #:LOADED-SYSTEMS #:OUTPUT-FILES-FOR-SYSTEM-AND-OPERATION) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/CACHE :ASDF/COMPONENT :ASDF/SYSTEM :ASDF/FIND-SYSTEM :ASDF/FIND-COMPONENT :ASDF/OPERATION :ASDF/ACTION :ASDF/LISP-ACTION :ASDF/OUTPUT-TRANSLATIONS :ASDF/SOURCE-REGISTRY :ASDF/PLAN :ASDF/OPERATE :ASDF/PARSE-DEFSYSTEM :ASDF/BUNDLE :ASDF/CONCATENATE-SOURCE :ASDF/BACKWARD-INTERNALS :ASDF/BACKWARD-INTERFACE :ASDF/PACKAGE-INFERRED-SYSTEM) (:EXPORT #:DEFSYSTEM #:FIND-SYSTEM #:LOAD-ASD #:LOCATE-SYSTEM #:COERCE-NAME #:PRIMARY-SYSTEM-NAME #:OOS #:OPERATE #:MAKE-PLAN #:PERFORM-PLAN #:SEQUENTIAL-PLAN #:SYSTEM-DEFINITION-PATHNAME #:SEARCH-FOR-SYSTEM-DEFINITION #:FIND-COMPONENT #:COMPONENT-FIND-PATH #:COMPILE-SYSTEM #:LOAD-SYSTEM #:LOAD-SYSTEMS #:LOAD-SYSTEMS* #:REQUIRE-SYSTEM #:TEST-SYSTEM #:CLEAR-SYSTEM #:OPERATION #:MAKE-OPERATION #:FIND-OPERATION #:UPWARD-OPERATION #:DOWNWARD-OPERATION #:SIDEWAY-OPERATION #:SELFWARD-OPERATION #:NON-PROPAGATING-OPERATION #:BUILD-OP #:MAKE #:LOAD-OP #:PREPARE-OP #:COMPILE-OP #:PREPARE-SOURCE-OP #:LOAD-SOURCE-OP #:TEST-OP #:FEATURE #:VERSION #:VERSION-SATISFIES #:UPGRADE-ASDF #:IMPLEMENTATION-IDENTIFIER #:IMPLEMENTATION-TYPE #:HOSTNAME #:INPUT-FILES #:OUTPUT-FILES #:OUTPUT-FILE #:PERFORM #:PERFORM-WITH-RESTARTS #:OPERATION-DONE-P #:EXPLAIN #:ACTION-DESCRIPTION #:COMPONENT-SIDEWAY-DEPENDENCIES #:NEEDED-IN-IMAGE-P #:COMPONENT-LOAD-DEPENDENCIES #:RUN-SHELL-COMMAND #:BUNDLE-OP #:MONOLITHIC-BUNDLE-OP #:PRECOMPILED-SYSTEM #:COMPILED-FILE #:BUNDLE-SYSTEM #:PROGRAM-SYSTEM #:MAKE-BUILD #:BASIC-COMPILE-BUNDLE-OP #:PREPARE-BUNDLE-OP #:COMPILE-BUNDLE-OP #:LOAD-BUNDLE-OP #:MONOLITHIC-COMPILE-BUNDLE-OP #:MONOLITHIC-LOAD-BUNDLE-OP #:LIB-OP #:DLL-OP #:DELIVER-ASD-OP #:PROGRAM-OP #:IMAGE-OP #:MONOLITHIC-LIB-OP #:MONOLITHIC-DLL-OP #:MONOLITHIC-DELIVER-ASD-OP #:CONCATENATE-SOURCE-OP #:LOAD-CONCATENATED-SOURCE-OP #:COMPILE-CONCATENATED-SOURCE-OP #:LOAD-COMPILED-CONCATENATED-SOURCE-OP #:MONOLITHIC-CONCATENATE-SOURCE-OP #:MONOLITHIC-LOAD-CONCATENATED-SOURCE-OP #:MONOLITHIC-COMPILE-CONCATENATED-SOURCE-OP #:MONOLITHIC-LOAD-COMPILED-CONCATENATED-SOURCE-OP #:OPERATION-MONOLITHIC-P #:REQUIRED-COMPONENTS #:COMPONENT-LOADED-P #:COMPONENT #:PARENT-COMPONENT #:CHILD-COMPONENT #:SYSTEM #:MODULE #:FILE-COMPONENT #:SOURCE-FILE #:C-SOURCE-FILE #:JAVA-SOURCE-FILE #:CL-SOURCE-FILE #:CL-SOURCE-FILE.CL #:CL-SOURCE-FILE.LSP #:STATIC-FILE #:DOC-FILE #:HTML-FILE #:FILE-TYPE #:SOURCE-FILE-TYPE #:REGISTER-PRELOADED-SYSTEM #:SYSDEF-PRELOADED-SYSTEM-SEARCH #:REGISTER-IMMUTABLE-SYSTEM #:SYSDEF-IMMUTABLE-SYSTEM-SEARCH #:PACKAGE-INFERRED-SYSTEM #:REGISTER-SYSTEM-PACKAGES #:PACKAGE-SYSTEM #:COMPONENT-CHILDREN #:COMPONENT-CHILDREN-BY-NAME #:COMPONENT-PATHNAME #:COMPONENT-RELATIVE-PATHNAME #:COMPONENT-NAME #:COMPONENT-VERSION #:COMPONENT-PARENT #:COMPONENT-SYSTEM #:COMPONENT-ENCODING #:COMPONENT-EXTERNAL-FORMAT #:COMPONENT-DEPENDS-ON #:MODULE-COMPONENTS #:OPERATION-ON-WARNINGS #:OPERATION-ON-FAILURE #:COMPONENT-PROPERTY #:TRAVERSE #:SYSTEM-DESCRIPTION #:SYSTEM-LONG-DESCRIPTION #:SYSTEM-AUTHOR #:SYSTEM-MAINTAINER #:SYSTEM-LICENSE #:SYSTEM-LICENCE #:SYSTEM-SOURCE-FILE #:SYSTEM-SOURCE-DIRECTORY #:SYSTEM-RELATIVE-PATHNAME #:SYSTEM-HOMEPAGE #:SYSTEM-MAILTO #:SYSTEM-BUG-TRACKER #:SYSTEM-LONG-NAME #:SYSTEM-SOURCE-CONTROL #:MAP-SYSTEMS #:SYSTEM-DEFSYSTEM-DEPENDS-ON #:SYSTEM-DEPENDS-ON #:SYSTEM-WEAKLY-DEPENDS-ON #:*SYSTEM-DEFINITION-SEARCH-FUNCTIONS* #:*CENTRAL-REGISTRY* #:*COMPILE-FILE-WARNINGS-BEHAVIOUR* #:*COMPILE-FILE-FAILURE-BEHAVIOUR* #:*RESOLVE-SYMLINKS* #:*LOAD-SYSTEM-OPERATION* #:*ASDF-VERBOSE* #:*VERBOSE-OUT* #:ASDF-VERSION #:COMPILE-CONDITION #:COMPILE-FILE-ERROR #:COMPILE-WARNED-ERROR #:COMPILE-FAILED-ERROR #:COMPILE-WARNED-WARNING #:COMPILE-FAILED-WARNING #:OPERATION-ERROR #:COMPILE-FAILED #:COMPILE-WARNED #:COMPILE-ERROR #:ERROR-NAME #:ERROR-PATHNAME #:LOAD-SYSTEM-DEFINITION-ERROR #:ERROR-COMPONENT #:ERROR-OPERATION #:SYSTEM-DEFINITION-ERROR #:MISSING-COMPONENT #:MISSING-COMPONENT-OF-VERSION #:MISSING-DEPENDENCY #:MISSING-DEPENDENCY-OF-VERSION #:CIRCULAR-DEPENDENCY #:DUPLICATE-NAMES #:NON-TOPLEVEL-SYSTEM #:NON-SYSTEM-SYSTEM #:PACKAGE-INFERRED-SYSTEM-MISSING-PACKAGE-ERROR #:OPERATION-DEFINITION-WARNING #:OPERATION-DEFINITION-ERROR #:TRY-RECOMPILING #:RETRY #:ACCEPT #:COERCE-ENTRY-TO-DIRECTORY #:REMOVE-ENTRY-FROM-REGISTRY #:CLEAR-CONFIGURATION-AND-RETRY #:*ENCODING-DETECTION-HOOK* #:*ENCODING-EXTERNAL-FORMAT-HOOK* #:*DEFAULT-ENCODING* #:*UTF-8-EXTERNAL-FORMAT* #:CLEAR-CONFIGURATION #:*OUTPUT-TRANSLATIONS-PARAMETER* #:INITIALIZE-OUTPUT-TRANSLATIONS #:DISABLE-OUTPUT-TRANSLATIONS #:CLEAR-OUTPUT-TRANSLATIONS #:ENSURE-OUTPUT-TRANSLATIONS #:APPLY-OUTPUT-TRANSLATIONS #:COMPILE-FILE* #:COMPILE-FILE-PATHNAME* #:*WARNINGS-FILE-TYPE* #:ENABLE-DEFERRED-WARNINGS-CHECK #:DISABLE-DEFERRED-WARNINGS-CHECK #:ENABLE-ASDF-BINARY-LOCATIONS-COMPATIBILITY #:*DEFAULT-SOURCE-REGISTRIES* #:*SOURCE-REGISTRY-PARAMETER* #:INITIALIZE-SOURCE-REGISTRY #:COMPUTE-SOURCE-REGISTRY #:CLEAR-SOURCE-REGISTRY #:ENSURE-SOURCE-REGISTRY #:PROCESS-SOURCE-REGISTRY #:SYSTEM-REGISTERED-P #:REGISTERED-SYSTEMS #:ALREADY-LOADED-SYSTEMS #:RESOLVE-LOCATION #:ASDF-MESSAGE #:*USER-CACHE* #:USER-OUTPUT-TRANSLATIONS-PATHNAME #:SYSTEM-OUTPUT-TRANSLATIONS-PATHNAME #:USER-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME #:SYSTEM-OUTPUT-TRANSLATIONS-DIRECTORY-PATHNAME #:USER-SOURCE-REGISTRY #:SYSTEM-SOURCE-REGISTRY #:USER-SOURCE-REGISTRY-DIRECTORY #:SYSTEM-SOURCE-REGISTRY-DIRECTORY))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/USER (:NICKNAMES :ASDF-USER) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/INTERFACE))
     [java] ; (UIOP/PACKAGE:DEFINE-PACKAGE :ASDF/FOOTER (:RECYCLE :ASDF/FOOTER :ASDF) (:USE :UIOP/COMMON-LISP :UIOP :ASDF/UPGRADE :ASDF/FIND-SYSTEM :ASDF/OPERATE :ASDF/BUNDLE))
     [java] ; (COMMON-LISP:IN-PACKAGE :ASDF/FOOTER)
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (UIOP/UTILITY:IF-LET (X (COMMON-LISP:AND)) (COMMON-LISP:EVAL (COMMON-LISP:QUOTE (COMMON-LISP:PUSHNEW (COMMON-LISP:QUOTE MODULE-PROVIDE-ASDF) SYSTEM::*MODULE-PROVIDER-FUNCTIONS*)))))
     [java] ; (UIOP/UTILITY:WITH-UPGRADABILITY COMMON-LISP:NIL (COMMON-LISP:DOLIST (F (COMMON-LISP:QUOTE (:ASDF :ASDF2 :ASDF3 :ASDF3.1 :ASDF-PACKAGE-SYSTEM))) (COMMON-LISP:PUSHNEW F COMMON-LISP:*FEATURES*)) (COMMON-LISP:PROVIDE "asdf") (COMMON-LISP:PROVIDE "ASDF") (CLEANUP-UPGRADED-ASDF))
     [java] ; (COMMON-LISP:WHEN COMMON-LISP:*LOAD-VERBOSE* (ASDF-MESSAGE ";; ASDF, version ~a~%" (ASDF-VERSION)))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/asdf.abcl (70.757 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/asdf.abcl ...
     [java] ; COMMON-LISP:COMPILE-FILE-PATHNAME triggers autoloading of compile-file-pathname ...
     [java] ;  Autoloaded compile-file-pathname (0.01 seconds)
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/asdf.abcl (12.514 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/abcl-contrib.lisp ...
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DEFCONSTANT +GET-CLASSLOADER+ (JAVA:JMETHOD "java.lang.Class" "getClassLoader"))
     [java] ; (DEFUN BOOT-CLASSLOADER NIL (LET ((BOOT-CLASS (JAVA:JCLASS "org.armedbear.lisp.Main"))) (JAVA:JCALL +GET-CLASSLOADER+ BOOT-CLASS)))
     [java] ; (DEFUN SYSTEM-JAR-P (P) (OR (NAMED-JAR-P "abcl" P) (NAMED-JAR-P "abcl-aio" P)))
     [java] ; (DEFUN CONTRIB-JAR-P (P) (OR (NAMED-JAR-P "abcl-contrib" P) (NAMED-JAR-P "abcl-aio" P)))
     [java] ; (DEFUN NAMED-JAR-P (NAME P) (AND (PATHNAMEP P) (EQUAL (PATHNAME-TYPE P) "jar") (OR (JAVA:JSTATIC "matches" "java.util.regex.Pattern" (CONCATENATE (QUOTE STRING) NAME "(-[0-9]\\.[0-9]\\.[0-9]([+~-].+)?)?") (PATHNAME-NAME P)) (JAVA:JSTATIC "matches" "java.util.regex.Pattern" (CONCATENATE (QUOTE STRING) NAME "(-[0-9]\\.[0-9]\\.[0-9]\\.[0-9]([+~-]+)?)?") (PATHNAME-NAME P))) P))
     [java] ; (DEFUN FIND-SYSTEM NIL "Find the location of the Armed Bear system implementation
     [java]
     [java] Used to determine relative pathname to find 'abcl-contrib.jar'." (OR (IGNORE-ERRORS (FIND-SYSTEM-JAR)) (IGNORE-ERRORS (SOME (LAMBDA (U) (PROBE-FILE (MAKE-PATHNAME :DEFAULTS (JAVA:JCALL "toString" U) :NAME "abcl"))) (JAVA:JSTATIC "getURLs" (JAVA:JCLASS "org.armedbear.lisp.Lisp") (BOOT-CLASSLOADER)))) (IGNORE-ERRORS #P"http://abcl.org/releases/current/abcl.jar")))
     [java] ; (DEFUN FIND-JAR (PREDICATE) (DOLIST (LOADER (JAVA:DUMP-CLASSPATH)) (LET ((JAR (SOME PREDICATE LOADER))) (WHEN JAR (RETURN JAR)))))
     [java] ; (DEFUN FIND-SYSTEM-JAR NIL "Return the pathname of the system jar, one of `abcl.jar` or
     [java] `abcl-m.n.p.jar` or `abcl-m.n.p[.~-]something.jar`." (FIND-JAR (FUNCTION SYSTEM-JAR-P)))
     [java] ; (DEFUN FIND-CONTRIB-JAR NIL "Return the pathname of the contrib jar, one of `abcl-contrib.jar` or
     [java] `abcl-contrib-m.n.p.jar` or `abcl-contrib-m.n.p[.~-]something.jar`." (FIND-JAR (FUNCTION CONTRIB-JAR-P)))
     [java] ; (DEFVAR *ABCL-CONTRIB* NIL "Pathname of the abcl-contrib artifact.
     [java]
     [java] Initialized via SYSTEM:FIND-CONTRIB.")
     [java] ; (DEFUN ADD-CONTRIB (ABCL-CONTRIB-JAR &KEY (VERBOSE *LOAD-VERBOSE*)) "Introspects the ABCL-CONTRIB-JAR path for sub-directories which
     [java]   contain asdf definitions, adding those found to asdf." (LET ((JAR-PATH (IF (PATHNAME-JAR-P ABCL-CONTRIB-JAR) ABCL-CONTRIB-JAR (MAKE-PATHNAME :DEVICE (LIST ABCL-CONTRIB-JAR))))) (DOLIST (ASDF-FILE (DIRECTORY (MERGE-PATHNAMES "*/*.asd" JAR-PATH))) (LET ((ASDF-DIRECTORY (MAKE-PATHNAME :DEFAULTS ASDF-FILE :NAME NIL :TYPE NIL))) (UNLESS (FIND ASDF-DIRECTORY ASDF/FIND-SYSTEM:*CENTRAL-REGISTRY* :TEST (FUNCTION EQUAL)) (PUSH ASDF-DIRECTORY ASDF/FIND-SYSTEM:*CENTRAL-REGISTRY*) (FORMAT VERBOSE "~&; abcl-contrib; Added ~A to ASDF.~&" ASDF-DIRECTORY))))))
     [java] ; (DEFUN FIND-AND-ADD-CONTRIB (&KEY (VERBOSE *LOAD-VERBOSE*)) "Attempt to find the ABCL contrib jar and add its contents to ASDF.
     [java] returns the pathname of the contrib if it can be found." (IF *ABCL-CONTRIB* (FORMAT VERBOSE "~&; abcl-contrib; Using already initialized value of SYS:*ABCL-CONTRIB* '~A'.~%" *ABCL-CONTRIB*) (PROGN (LET ((CONTRIB (FIND-CONTRIB))) (WHEN CONTRIB (FORMAT VERBOSE "~&; abcl-contrib; Using probed value of SYS:*ABCL-CONTRIB* '~A'.~%" CONTRIB) (SETF *ABCL-CONTRIB* CONTRIB))))) (WHEN *ABCL-CONTRIB* (ADD-CONTRIB *ABCL-CONTRIB*)))
     [java] ; (DEFUN FIND-NAME-FOR-IMPLEMENTATION-TITLE (FILE ID) "For a jar FILE containing a manifest, return the name of the
     [java]   section which annotates 'Implementation-Title' whose string value is
     [java]   ID." (DECLARE (TYPE PATHNAME FILE)) (LET* ((JAR (JAVA:JNEW "java.util.jar.JarFile" (NAMESTRING FILE))) (MANIFEST (JAVA:JCALL "getManifest" JAR)) (ENTRIES (JAVA:JCALL "toArray" (JAVA:JCALL "entrySet" (JAVA:JCALL "getEntries" MANIFEST))))) (DOLIST (ENTRY (LOOP :FOR ENTRY :ACROSS ENTRIES :COLLECTING ENTRY)) (LET ((TITLE (JAVA:JCALL "getValue" (JAVA:JCALL "getValue" ENTRY) "Implementation-Title"))) (WHEN (STRING-EQUAL TITLE ID) (RETURN-FROM FIND-NAME-FOR-IMPLEMENTATION-TITLE (JAVA:JCALL "getKey" ENTRY)))) NIL)))
     [java] ; (DEFUN FIND-CONTRIB NIL "Introspect runtime classpaths to return a pathname containing
     [java]   subdirectories containing ASDF definitions." (OR (IGNORE-ERRORS (LET* ((SYSTEM-JAR (FIND-SYSTEM-JAR)) (RELATIVE-PATHNAME (FIND-NAME-FOR-IMPLEMENTATION-TITLE SYSTEM-JAR "org.abcl-contrib"))) (WHEN (AND SYSTEM-JAR RELATIVE-PATHNAME) (MERGE-PATHNAMES (PATHNAME (CONCATENATE (QUOTE STRING) RELATIVE-PATHNAME "/")) (MAKE-PATHNAME :DEVICE (LIST SYSTEM-JAR)))))) (IGNORE-ERRORS (FIND-CONTRIB-JAR)) (IGNORE-ERRORS (LET ((SYSTEM-JAR (FIND-SYSTEM-JAR))) (WHEN SYSTEM-JAR (PROBE-FILE (MAKE-PATHNAME :DEFAULTS SYSTEM-JAR :NAME (CONCATENATE (QUOTE STRING) "abcl-contrib" (SUBSEQ (PATHNAME-NAME SYSTEM-JAR) 4))))))) (SOME (LAMBDA (U) (PROBE-FILE (MAKE-PATHNAME :DEFAULTS (JAVA:JCALL "toString" U) :NAME "abcl-contrib"))) (JAVA:JSTATIC "getURLs" (JAVA:JCLASS "org.armedbear.lisp.Lisp") (BOOT-CLASSLOADER)))))
     [java] ; (WHEN (FIND-AND-ADD-CONTRIB :VERBOSE *LOAD-VERBOSE*) (PROVIDE :ABCL-CONTRIB))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/abcl-contrib.abcl (0.541 seconds)
     [java] ; Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/abcl-contrib.abcl ...
     [java] ; Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/abcl-contrib.abcl (0.186 seconds)
     [java] ; Generating autoloads...
     [java] ;COMMON-LISP:DIRECTORY triggers autoloading of directory ...
     [java] ; Autoloaded directory (0.014 seconds)
     [java] ; Removing multi-homed symbols
     [java] (("clos" MAKE-INSTANCE) ("clos" SHARED-INITIALIZE) ("clos" MOP:COMPUTE-CLASS-PRECEDENCE-LIST) ("clos" MAKE-LOAD-FORM) ("clos" DESCRIBE-OBJECT) ("defpackage" SYSTEM::ENSURE-AVAILABLE-SYMBOLS) ("describe" DESCRIBE-OBJECT) ("format" PRINT-OBJECT) ("java" MAKE-LOAD-FORM) ("java" PRINT-OBJECT) ("java" MOP:VALIDATE-SUPERCLASS) ("java" MOP:COMPUTE-CLASS-PRECEDENCE-LIST) ("java" MAKE-INSTANCE) ("jvm-class-file" PRINT-OBJECT) ("jvm" PRINT-OBJECT) ("mop" MOP:VALIDATE-SUPERCLASS) ("mop" SHARED-INITIALIZE) ("package" SYSTEM::ENSURE-AVAILABLE-SYMBOLS) ("print-object" PRINT-OBJECT) ("run-program" PRINT-OBJECT)) ; Removing multi-homed symbols
     [java] (("define-modify-macro" INCF) ("define-modify-macro" DECF) ("defsetf" DEFSETF) ("delete" SYSTEM::REAL-COUNT) ("nsubstitute" SYSTEM::REAL-COUNT) ("remove" SYSTEM::REAL-COUNT) ("setf" INCF) ("setf" DECF) ("setf" DEFSETF)) ; Removing multi-homed symbols
     [java] (("extensible-sequences" SEQUENCE:ELT) ("extensible-sequences" SEQUENCE:ITERATOR-ELEMENT) ("java-collections" SEQUENCE:ELT) ("java-collections" SEQUENCE:ITERATOR-ELEMENT)) ; Removing multi-homed symbols
     [java] NIL ; Removing multi-homed symbols
     [java] NIL ; Removing multi-homed symbols
     [java] NIL ; Removing multi-homed symbols
     [java] NIL ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/autoloads-gen.lisp ...
     [java] ; (IN-PACKAGE :FORMAT)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("format") %PRINT-FORMAT-ERROR MISSING-ARG MAKE-FORMAT-DIRECTIVE FORMAT-DIRECTIVE-P TOKENIZE-CONTROL-STRING PARSE-DIRECTIVE %FORMATTER EXPAND-CONTROL-STRING EXPAND-DIRECTIVE-LIST EXPAND-DIRECTIVE EXPAND-NEXT-ARG %SET-FORMAT-DIRECTIVE-EXPANDER %SET-FORMAT-DIRECTIVE-INTERPRETER FIND-DIRECTIVE |Latin_Capital_Letter_A-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_S-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_C-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_W-FORMAT-DIRECTIVE-EXPANDER| EXPAND-FORMAT-INTEGER |Latin_Capital_Letter_D-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_B-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_O-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_X-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_R-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_P-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_F-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_E-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_G-FORMAT-DIRECTIVE-EXPANDER| |Dollar_Sign-FORMAT-DIRECTIVE-EXPANDER| |Percent_Sign-FORMAT-DIRECTIVE-EXPANDER| |Ampersand-FORMAT-DIRECTIVE-EXPANDER| |Vertical_Line-FORMAT-DIRECTIVE-EXPANDER| |Tilde-FORMAT-DIRECTIVE-EXPANDER| |Newline-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_T-FORMAT-DIRECTIVE-EXPANDER| |Low_Line-FORMAT-DIRECTIVE-EXPANDER| |Latin_Capital_Letter_I-FORMAT-DIRECTIVE-EXPANDER| |Asterisk-FORMAT-DIRECTIVE-EXPANDER| |Question_Mark-FORMAT-DIRECTIVE-EXPANDER| |Left_Parenthesis-FORMAT-DIRECTIVE-EXPANDER| |Right_Parenthesis-FORMAT-DIRECTIVE-EXPANDER| |Left_Square_Bracket-FORMAT-DIRECTIVE-EXPANDER| PARSE-CONDITIONAL-DIRECTIVE EXPAND-MAYBE-CONDITIONAL EXPAND-TRUE-FALSE-CONDITIONAL |Semicolon-FORMAT-DIRECTIVE-EXPANDER| |Right_Square_Bracket-FORMAT-DIRECTIVE-EXPANDER| |Circumflex_Accent-FORMAT-DIRECTIVE-EXPANDER| |Left_Curly_Bracket-FORMAT-DIRECTIVE-EXPANDER| |Right_Curly_Bracket-FORMAT-DIRECTIVE-EXPANDER| ILLEGAL-INSIDE-JUSTIFICATION-P |Less-Than_Sign-FORMAT-DIRECTIVE-EXPANDER| |Greater-Than_Sign-FORMAT-DIRECTIVE-EXPANDER| PARSE-FORMAT-LOGICAL-BLOCK ADD-FILL-STYLE-NEWLINES ADD-FILL-STYLE-NEWLINES-AUX PARSE-FORMAT-JUSTIFICATION EXPAND-FORMAT-LOGICAL-BLOCK EXPAND-FORMAT-JUSTIFICATION |Solidus-FORMAT-DIRECTIVE-EXPANDER| EXTRACT-USER-FUN-NAME %COMPILER-WALK-FORMAT-STRING %FORMAT INTERPRET-DIRECTIVE-LIST FORMAT-WRITE-FIELD FORMAT-PRINC |Latin_Capital_Letter_A-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-PRIN1 |Latin_Capital_Letter_S-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_C-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-PRINT-NAMED-CHARACTER |Latin_Capital_Letter_W-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-PRINT-INTEGER FORMAT-ADD-COMMAS |Latin_Capital_Letter_D-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_B-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_O-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_X-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_R-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-PRINT-SMALL-CARDINAL FORMAT-PRINT-CARDINAL FORMAT-PRINT-CARDINAL-AUX FORMAT-PRINT-ORDINAL FORMAT-PRINT-OLD-ROMAN FORMAT-PRINT-ROMAN |Latin_Capital_Letter_P-FORMAT-DIRECTIVE-INTERPRETER| DECIMAL-STRING |Latin_Capital_Letter_F-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-FIXED FORMAT-FIXED-AUX |Latin_Capital_Letter_E-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-EXPONENTIAL FORMAT-EXPONENT-MARKER FORMAT-EXP-AUX |Latin_Capital_Letter_G-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-GENERAL FORMAT-GENERAL-AUX |Dollar_Sign-FORMAT-DIRECTIVE-INTERPRETER| FORMAT-DOLLARS |Percent_Sign-FORMAT-DIRECTIVE-INTERPRETER| |Ampersand-FORMAT-DIRECTIVE-INTERPRETER| |Vertical_Line-FORMAT-DIRECTIVE-INTERPRETER| |Tilde-FORMAT-DIRECTIVE-INTERPRETER| |Newline-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_T-FORMAT-DIRECTIVE-INTERPRETER| OUTPUT-SPACES FORMAT-RELATIVE-TAB FORMAT-ABSOLUTE-TAB |Low_Line-FORMAT-DIRECTIVE-INTERPRETER| |Latin_Capital_Letter_I-FORMAT-DIRECTIVE-INTERPRETER| |Asterisk-FORMAT-DIRECTIVE-INTERPRETER| |Question_Mark-FORMAT-DIRECTIVE-INTERPRETER| |Left_Parenthesis-FORMAT-DIRECTIVE-INTERPRETER| |Right_Parenthesis-FORMAT-DIRECTIVE-INTERPRETER| |Left_Square_Bracket-FORMAT-DIRECTIVE-INTERPRETER| |Semicolon-FORMAT-DIRECTIVE-INTERPRETER| |Right_Square_Bracket-FORMAT-DIRECTIVE-INTERPRETER| |Circumflex_Accent-FORMAT-DIRECTIVE-INTERPRETER| |Left_Curly_Bracket-FORMAT-DIRECTIVE-INTERPRETER| |Right_Curly_Bracket-FORMAT-DIRECTIVE-INTERPRETER| |Less-Than_Sign-FORMAT-DIRECTIVE-INTERPRETER| INTERPRET-FORMAT-JUSTIFICATION FORMAT-JUSTIFICATION INTERPRET-FORMAT-LOGICAL-BLOCK |Solidus-FORMAT-DIRECTIVE-INTERPRETER|)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :FORMAT)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("format") EXPANDER-NEXT-ARG EXPAND-BIND-DEFAULTS DEF-COMPLEX-FORMAT-DIRECTIVE DEF-FORMAT-DIRECTIVE EXPANDER-PPRINT-NEXT-ARG INTERPRET-FORMAT-INTEGER)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :LOOP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("loop") MAKE-LOOP-MINIMAX-INTERNAL MAKE-LOOP-MINIMAX LOOP-NOTE-MINIMAX-OPERATION LOOP-TEQUAL LOOP-TASSOC LOOP-TMEMBER LOOP-LOOKUP-KEYWORD MAKE-LOOP-UNIVERSE MAKE-STANDARD-LOOP-UNIVERSE LOOP-MAKE-PSETQ LOOP-MAKE-DESETQ LOOP-CONSTANT-FOLD-IF-POSSIBLE LOOP-CONSTANTP LOOP-CODE-DUPLICATION-THRESHOLD DUPLICATABLE-CODE-P DESTRUCTURING-SIZE ESTIMATE-CODE-SIZE ESTIMATE-CODE-SIZE-1 LOOP-CONTEXT LOOP-ERROR LOOP-WARN LOOP-CHECK-DATA-TYPE SUBST-GENSYMS-FOR-NIL LOOP-BUILD-DESTRUCTURING-BINDINGS LOOP-TRANSLATE LOOP-ITERATION-DRIVER LOOP-POP-SOURCE LOOP-GET-FORM LOOP-GET-COMPOUND-FORM LOOP-GET-PROGN LOOP-CONSTRUCT-RETURN LOOP-PSEUDO-BODY LOOP-EMIT-BODY LOOP-EMIT-FINAL-VALUE LOOP-DISALLOW-CONDITIONAL LOOP-DISALLOW-ANONYMOUS-COLLECTORS LOOP-DISALLOW-AGGREGATE-BOOLEANS LOOP-TYPED-INIT LOOP-OPTIONAL-TYPE LOOP-BIND-BLOCK LOOP-VAR-P LOOP-MAKE-VAR LOOP-MAKE-ITERATION-VAR LOOP-DECLARE-VAR LOOP-MAYBE-BIND-FORM LOOP-DO-IF LOOP-DO-INITIALLY LOOP-DO-FINALLY LOOP-DO-DO LOOP-DO-NAMED LOOP-DO-RETURN MAKE-LOOP-COLLECTOR LOOP-GET-COLLECTION-INFO LOOP-LIST-COLLECTION LOOP-SUM-COLLECTION LOOP-MAXMIN-COLLECTION LOOP-DO-ALWAYS LOOP-DO-THEREIS LOOP-DO-WHILE LOOP-DO-REPEAT LOOP-DO-WITH LOOP-HACK-ITERATION LOOP-DO-FOR LOOP-WHEN-IT-VAR LOOP-ANSI-FOR-EQUALS LOOP-FOR-ACROSS LOOP-LIST-STEP LOOP-FOR-ON LOOP-FOR-IN MAKE-LOOP-PATH ADD-LOOP-PATH LOOP-FOR-BEING LOOP-NAMED-VAR LOOP-COLLECT-PREPOSITIONAL-PHRASES LOOP-SEQUENCER LOOP-FOR-ARITHMETIC LOOP-SEQUENCE-ELEMENTS-PATH LOOP-HASH-TABLE-ITERATION-PATH LOOP-PACKAGE-SYMBOLS-ITERATION-PATH MAKE-ANSI-LOOP-UNIVERSE LOOP-STANDARD-EXPANSION)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :LOOP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("loop") WITH-LOOP-LIST-COLLECTION-HEAD LOOP-COLLECT-RPLACD LOOP-COLLECT-ANSWER WITH-MINIMAX-VALUE LOOP-ACCUMULATE-MINIMAX-VALUE LOOP-STORE-TABLE-DATA LOOP-REALLY-DESETQ LOOP-BODY LOOP-DESTRUCTURING-BIND)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :MOP)
     [java] ; (IN-PACKAGE :MOP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("clos") CLASS-SLOTS CLASS-DIRECT-SLOTS CLASS-LAYOUT CLASS-DIRECT-SUPERCLASSES CLASS-DIRECT-SUBCLASSES CLASS-DIRECT-METHODS CLASS-PRECEDENCE-LIST CLASS-FINALIZED-P CLASS-DEFAULT-INITARGS CLASS-DIRECT-DEFAULT-INITARGS ADD-DIRECT-SUBCLASS REMOVE-DIRECT-SUBCLASS FIXUP-STANDARD-CLASS-HIERARCHY STD-CLASS-P MAP-DEPENDENTS MAPAPPEND MAPPLIST FUNCALLABLE-STANDARD-INSTANCE-ACCESS CANONICALIZE-DIRECT-SLOTS CANONICALIZE-DIRECT-SLOT MAYBE-NOTE-NAME-DEFINED CANONICALIZE-DEFCLASS-OPTIONS CANONICALIZE-DEFCLASS-OPTION MAKE-INITFUNCTION SLOT-DEFINITION-ALLOCATION SLOT-DEFINITION-INITARGS SLOT-DEFINITION-INITFORM SLOT-DEFINITION-INITFUNCTION SLOT-DEFINITION-NAME SLOT-DEFINITION-READERS SLOT-DEFINITION-WRITERS SLOT-DEFINITION-ALLOCATION-CLASS SLOT-DEFINITION-LOCATION SLOT-DEFINITION-TYPE SLOT-DEFINITION-DOCUMENTATION INIT-SLOT-DEFINITION DIRECT-SLOT-DEFINITION-CLASS MAKE-DIRECT-SLOT-DEFINITION EFFECTIVE-SLOT-DEFINITION-CLASS MAKE-EFFECTIVE-SLOT-DEFINITION COMPUTE-DEFAULT-INITARGS STD-COMPUTE-DEFAULT-INITARGS STD-FINALIZE-INHERITANCE FINALIZE-INHERITANCE STD-COMPUTE-CLASS-PRECEDENCE-LIST TOPOLOGICAL-SORT STD-TIE-BREAKER-RULE COLLECT-SUPERCLASSES* LOCAL-PRECEDENCE-ORDERING STD-COMPUTE-SLOTS STD-COMPUTE-EFFECTIVE-SLOT-DEFINITION FIND-SLOT-DEFINITION SLOT-LOCATION INSTANCE-SLOT-LOCATION %SET-SLOT-VALUE STD-SLOT-MAKUNBOUND STD-SLOT-EXISTS-P INSTANCE-SLOT-P STD-ALLOCATE-INSTANCE ALLOCATE-FUNCALLABLE-INSTANCE CLASS-PROTOTYPE MAYBE-FINALIZE-CLASS-SUBTREE MAKE-INSTANCE-STANDARD-CLASS MAKE-OR-FIND-INSTANCE-FUNCALLABLE-STANDARD-CLASS CANONICALIZE-DIRECT-SUPERCLASS-LIST STD-AFTER-INITIALIZATION-FOR-CLASSES EXPAND-LONG-DEFCOMBIN %MAKE-LONG-METHOD-COMBINATION METHOD-COMBINATION-NAME METHOD-COMBINATION-DOCUMENTATION SHORT-METHOD-COMBINATION-OPERATOR SHORT-METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT LONG-METHOD-COMBINATION-LAMBDA-LIST LONG-METHOD-COMBINATION-METHOD-GROUP-SPECS LONG-METHOD-COMBINATION-ARGS-LAMBDA-LIST LONG-METHOD-COMBINATION-GENERIC-FUNCTION-SYMBOL LONG-METHOD-COMBINATION-FUNCTION LONG-METHOD-COMBINATION-ARGUMENTS LONG-METHOD-COMBINATION-DECLARATIONS LONG-METHOD-COMBINATION-FORMS EXPAND-SHORT-DEFCOMBIN METHOD-GROUP-P CHECK-VARIABLE-NAME CANONICALIZE-METHOD-GROUP-SPEC EXTRACT-REQUIRED-PART EXTRACT-SPECIFIED-PART EXTRACT-OPTIONAL-PART PARSE-DEFINE-METHOD-COMBINATION-ARGS-LAMBDA-LIST WRAP-WITH-CALL-METHOD-MACRO ASSERT-UNAMBIGUOUS-METHOD-SORTING METHOD-COMBINATION-TYPE-LAMBDA-WITH-ARGS-EMF METHOD-COMBINATION-TYPE-LAMBDA DECLARATIONP LONG-FORM-METHOD-COMBINATION-ARGS DEFINE-LONG-FORM-METHOD-COMBINATION STD-FIND-METHOD-COMBINATION FIND-METHOD-COMBINATION STD-GENERIC-FUNCTION-P INTERN-EQL-SPECIALIZER EQL-SPECIALIZER-OBJECT STD-METHOD-FUNCTION STD-METHOD-GENERIC-FUNCTION STD-METHOD-SPECIALIZERS STD-METHOD-QUALIFIERS STD-ACCESSOR-METHOD-SLOT-DEFINITION STD-METHOD-FAST-FUNCTION STD-FUNCTION-KEYWORDS METHOD-GENERIC-FUNCTION METHOD-FUNCTION METHOD-SPECIALIZERS GENERIC-FUNCTION-NAME GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION-METHODS GENERIC-FUNCTION-METHOD-CLASS GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER GENERIC-FUNCTION-REQUIRED-ARGUMENTS GENERIC-FUNCTION-OPTIONAL-ARGUMENTS METHOD-DOCUMENTATION CANONICALIZE-DEFGENERIC-OPTIONS CANONICALIZE-DEFGENERIC-OPTION ARGUMENT-PRECEDENCE-ORDER-INDICES FIND-GENERIC-FUNCTION LAMBDA-LISTS-CONGRUENT-P %DEFGENERIC COLLECT-EQL-SPECIALIZER-OBJECTS FINALIZE-STANDARD-GENERIC-FUNCTION MAKE-INSTANCE-STANDARD-GENERIC-FUNCTION CANONICALIZE-SPECIALIZERS CANONICALIZE-SPECIALIZER PARSE-DEFMETHOD REQUIRED-PORTION EXTRACT-LAMBDA-LIST EXTRACT-SPECIALIZER-NAMES GET-KEYWORD-FROM-ARG ANALYZE-LAMBDA-LIST CHECK-METHOD-LAMBDA-LIST CHECK-ARGUMENT-PRECEDENCE-ORDER ENSURE-METHOD MAKE-INSTANCE-STANDARD-METHOD ADD-DIRECT-METHOD REMOVE-DIRECT-METHOD STD-ADD-METHOD STD-REMOVE-METHOD %FIND-METHOD FAST-CALLABLE-P STD-COMPUTE-DISCRIMINATING-FUNCTION SORT-METHODS METHOD-APPLICABLE-P STD-COMPUTE-APPLICABLE-METHODS METHOD-APPLICABLE-USING-CLASSES-P CHECK-APPLICABLE-METHOD-KEYWORD-ARGS COMPUTE-APPLICABLE-KEYWORDS WRAP-EMFUN-FOR-KEYWORD-ARGS-CHECK SLOW-METHOD-LOOKUP SUB-SPECIALIZER-P STD-METHOD-MORE-SPECIFIC-P PRIMARY-METHOD-P BEFORE-METHOD-P AFTER-METHOD-P AROUND-METHOD-P PROCESS-NEXT-METHOD-LIST STD-COMPUTE-EFFECTIVE-METHOD GENERATE-EMF-LAMBDA COMPUTE-PRIMARY-EMFUN WALK-FORM COMPUTE-METHOD-FUNCTION COMPUTE-METHOD-FAST-FUNCTION MAKE-METHOD-LAMBDA ALLOW-OTHER-KEYS MAKE-INSTANCE-STANDARD-ACCESSOR-METHOD ADD-READER-METHOD ADD-WRITER-METHOD CHECK-DUPLICATE-SLOTS CHECK-DUPLICATE-DEFAULT-INITARGS CANONICALIZE-DIRECT-SUPERCLASSES ENSURE-CLASS ENSURE-CLASS-USING-CLASS READER-METHOD-CLASS WRITER-METHOD-CLASS COMPUTE-APPLICABLE-METHODS-USING-CLASSES SLOT-VALUE-USING-CLASS SLOT-EXISTS-P-USING-CLASS SLOT-BOUNDP-USING-CLASS SLOT-MAKUNBOUND-USING-CLASS CALCULATE-ALLOWABLE-INITARGS CHECK-INITARGS MERGE-INITARGS-SETS EXTRACT-LAMBDA-LIST-KEYWORDS AUGMENT-INITARGS-WITH-DEFAULTS STD-SHARED-INITIALIZE STD-AFTER-REINITIALIZATION-FOR-CLASSES COMPUTE-SLOTS COMPUTE-EFFECTIVE-SLOT-DEFINITION COMPUTE-DISCRIMINATING-FUNCTION METHOD-MORE-SPECIFIC-P COMPUTE-EFFECTIVE-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS SPECIALIZER-DIRECT-METHODS ADD-DEPENDENT REMOVE-DEPENDENT UPDATE-DEPENDENT ENSURE-GENERIC-FUNCTION-USING-CLASS %METHOD-GENERIC-FUNCTION %METHOD-FUNCTION)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :MOP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("clos") DEFINE-CLASS->%CLASS-FORWARDER PUSH-ON-END DEFINE-PRIMORDIAL-CLASS DEFINE-FUNCALLABLE-PRIMORDIAL-CLASS WITH-METHOD-GROUPS ATOMIC-DEFGENERIC REDEFINE-CLASS-FORWARDER SLOT-DEFINITION-DISPATCH)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :XP)
     [java] ; (IN-PACKAGE :XP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("pprint-dispatch") MAKE-PPRINT-DISPATCH-TABLE PPRINT-DISPATCH-TABLE-P MAKE-ENTRY ENTRY-P SET-PPRINT-DISPATCH+ PRIORITY-> ADJUST-COUNTS GET-PRINTER FITS SPECIFIER-CATEGORY ALWAYS-TRUE SPECIFIER-FN CONVERT-BODY FUNCTION-CALL-P PPRINT-DISPATCH-PRINT) (("pprint") STRUCTURE-TYPE-P OUTPUT-WIDTH MAKE-XP-STRUCTURE XP-STRUCTURE-P PUSH-BLOCK-STACK POP-BLOCK-STACK PUSH-PREFIX-STACK POP-PREFIX-STACK ENQUEUE INITIALIZE-XP WRITE-CHAR+ WRITE-STRING+ WRITE-CHAR++ FORCE-SOME-OUTPUT WRITE-STRING++ WRITE-STRING+++ PPRINT-TAB+ PPRINT-NEWLINE+ START-BLOCK END-BLOCK PPRINT-INDENT+ ATTEMPT-TO-OUTPUT FLUSH OUTPUT-LINE SETUP-FOR-NEXT-LINE SET-INDENTATION-PREFIX SET-PREFIX SET-SUFFIX REVERSE-STRING-IN-PLACE MAYBE-INITIATE-XP-PRINTING XP-PRINT DO-XP-PRINTING WRITE+ NON-PRETTY-PRINT MAYBE-PRINT-FAST PRINT-FIXNUM PPRINT-POP-CHECK+ CHECK-BLOCK-ABBREVIATION PRETTY-ARRAY PRETTY-VECTOR PRETTY-NON-VECTOR ARRAY-READABLY-PRINTABLE-P FN-CALL ALTERNATIVE-FN-CALL BIND-LIST BLOCK-LIKE DEFUN-LIKE PRINT-FANCY-FN-CALL LET-PRINT COND-PRINT DMM-PRINT DEFSETF-PRINT DO-PRINT FLET-PRINT FUNCTION-PRINT MVB-PRINT MAYBELAB PROG-PRINT TAGBODY-PRINT SETQ-PRINT QUOTE-PRINT UP-PRINT TOKEN-TYPE PRETTY-LOOP OUTPUT-PRETTY-OBJECT)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :XP)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("pprint") LP<-BP TP<-BP BP<-LP BP<-TP LP<-TP CHECK-SIZE SECTION-START PREFIX-PTR SUFFIX-PTR NON-BLANK-PREFIX-PTR INITIAL-PREFIX-PTR SECTION-START-LINE QTYPE QKIND QPOS QDEPTH QEND QOFFSET QARG QNEXT MAYBE-TOO-LARGE MISERING? PPRINT-LOGICAL-BLOCK+ PPRINT-POP+)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :PROFILER)
     [java] ; (IN-PACKAGE :PROFILER)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("profiler") MAKE-PROFILE-INFO PROFILE-INFO-P LIST-CALLED-OBJECTS OBJECT-NAME OBJECT-COMPILED-FUNCTION-P SHOW-CALL-COUNT SHOW-HOT-COUNT SHOW-CALL-COUNTS SHOW-HOT-COUNTS START-PROFILER)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :PROFILER)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("profiler") WITH-PROFILING)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JAVA)
     [java] ; (IN-PACKAGE :JAVA)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("java") ADD-URL-TO-CLASSPATH ADD-URLS-TO-CLASSPATH ADD-TO-CLASSPATH JREGISTER-HANDLER JINTERFACE-IMPLEMENTATION JMAKE-INVOCATION-HANDLER JMAKE-PROXY CANONICALIZE-JPROXY-INTERFACES JEQUAL JOBJECT-CLASS JCLASS-SUPERCLASS JCLASS-INTERFACES JCLASS-INTERFACE-P JCLASS-SUPERCLASS-P JCLASS-ARRAY-P JARRAY-COMPONENT-TYPE JARRAY-LENGTH JNEW-ARRAY-FROM-ARRAY JNEW-ARRAY-FROM-LIST JARRAY-FROM-LIST LIST-FROM-JARRAY VECTOR-FROM-JARRAY LIST-FROM-JENUMERATION JCLASS-CONSTRUCTORS JCONSTRUCTOR-PARAMS JCLASS-FIELDS JCLASS-FIELD JFIELD-TYPE JFIELD-NAME JCLASS-METHODS JMETHOD-PARAMS JMETHOD-RETURN-TYPE JMETHOD-DECLARING-CLASS JMETHOD-NAME JINSTANCE-OF-P JMEMBER-STATIC-P JMEMBER-PUBLIC-P JMEMBER-PROTECTED-P JPROPERTY-VALUE PRINT-JAVA-OBJECT-BY-CLASS JCLASS-ADDITIONAL-SUPERCLASSES ENSURE-JAVA-CLASS JINPUT-STREAM) (("runtime-class") MAKE-MEMORY-CLASS-LOADER JNEW-RUNTIME-CLASS %JNEW-RUNTIME-CLASS MAKE-ACCESSOR-NAME CANONICALIZE-JAVA-TYPE EMIT-UNBOX-AND-RETURN RUNTIME-CLASS-ADD-METHODS RUNTIME-CLASS-ADD-FIELDS)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JAVA)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("java") CHAIN JMETHOD-LET) (("runtime-class") DEFINE-JAVA-CLASS)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JAVA)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("java") JARRAY-REF JFIELD JPROPERTY-VALUE)))) (FUNCALL (FUNCTION AUTOLOAD-SETF-FUNCTION) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("compiler-pass1") GENERATE-INLINE-EXPANSION PARSE-LAMBDA-LIST MATCH-LAMBDA-LIST MATCH-KEYWORD-AND-REST-ARGS EXPAND-FUNCTION-CALL-INLINE PROCESS-DECLARATIONS-FOR-VARS CHECK-NAME P1-BODY P1-DEFAULT LET/LET*-VARIABLES VALID-LET/LET*-BINDING-P CHECK-LET/LET*-BINDINGS P1-LET-VARS P1-LET*-VARS P1-LET/LET* P1-LOCALLY P1-M-V-B P1-BLOCK P1-CATCH P1-THREADS-SYNCHRONIZED-ON P1-JAVA-JRUN-EXCEPTION-PROTECTED P1-UNWIND-PROTECT P1-RETURN-FROM P1-TAGBODY P1-GO SPLIT-DECLS LAMBDA-LIST-NAMES LAMBDA-LIST-KEYWORD-P REWRITE-AUX-VARS REWRITE-LAMBDA VALIDATE-FUNCTION-NAME CONSTRUCT-FLET/LABELS-FUNCTION P1-FLET P1-LABELS P1-FUNCALL P1-FUNCTION P1-LAMBDA P1-EVAL-WHEN P1-PROGV P1-QUOTE P1-SETQ P1-THE P1-TRULY-THE P1-THROW REWRITE-FUNCTION-CALL P1-FUNCTION-CALL %FUNCALL P1-VARIABLE-REFERENCE P1 INSTALL-P1-HANDLER INITIALIZE-P1-HANDLERS P1-COMPILAND) (("compiler-pass2") POOL-NAME POOL-NAME-AND-TYPE POOL-CLASS POOL-STRING POOL-FIELD POOL-METHOD POOL-INT POOL-FLOAT POOL-LONG POOL-DOUBLE ADD-EXCEPTION-HANDLER EMIT-PUSH-NIL EMIT-PUSH-NIL-SYMBOL EMIT-PUSH-T EMIT-PUSH-FALSE EMIT-PUSH-TRUE EMIT-PUSH-CONSTANT-INT EMIT-PUSH-CONSTANT-LONG EMIT-PUSH-CONSTANT-FLOAT EMIT-PUSH-CONSTANT-DOUBLE EMIT-DUP EMIT-SWAP EMIT-INVOKESTATIC PRETTY-JAVA-CLASS GET-DESCRIPTOR-INFO MAKE-DESCRIPTOR-INFO EMIT-INVOKEINTERFACE EMIT-INVOKEVIRTUAL EMIT-INVOKESPECIAL-INIT PRETTY-JAVA-TYPE EMIT-GETSTATIC EMIT-PUTSTATIC EMIT-GETFIELD EMIT-PUTFIELD EMIT-NEW EMIT-ANEWARRAY EMIT-CHECKCAST EMIT-INSTANCEOF TYPE-REPRESENTATION EMIT-UNBOX-BOOLEAN EMIT-UNBOX-CHARACTER CONVERT-REPRESENTATION COMMON-REPRESENTATION MAYBE-INITIALIZE-THREAD-VAR ENSURE-THREAD-VAR-INITIALIZED EMIT-PUSH-CURRENT-THREAD VARIABLE-LOCAL-P EMIT-LOAD-LOCAL-VARIABLE EMIT-PUSH-VARIABLE-NAME GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VARIABLE FIND-TYPE-FOR-TYPE-CHECK GENERATE-TYPE-CHECK-FOR-VARIABLE MAYBE-GENERATE-TYPE-CHECK GENERATE-TYPE-CHECKS-FOR-VARIABLES GENERATE-ARG-COUNT-CHECK MAYBE-GENERATE-INTERRUPT-CHECK SINGLE-VALUED-P EMIT-CLEAR-VALUES MAYBE-EMIT-CLEAR-VALUES COMPILE-FORMS-AND-MAYBE-EMIT-CLEAR-VALUES LOAD-SAVED-OPERANDS SAVE-EXISTING-OPERANDS SAVE-OPERAND COMPILE-OPERAND EMIT-VARIABLE-OPERAND EMIT-REGISTER-OPERAND EMIT-THREAD-OPERAND EMIT-LOAD-EXTERNALIZED-OBJECT-OPERAND EMIT-UNBOX-FIXNUM EMIT-UNBOX-LONG EMIT-UNBOX-FLOAT EMIT-UNBOX-DOUBLE FIX-BOXING EMIT-MOVE-FROM-STACK EMIT-PUSH-REGISTER EMIT-INVOKE-METHOD CHECK-NUMBER-OF-ARGS CHECK-ARG-COUNT CHECK-MIN-ARGS EMIT-CONSTRUCTOR-LAMBDA-NAME EMIT-CONSTRUCTOR-LAMBDA-LIST EMIT-READ-FROM-STRING MAKE-CONSTRUCTOR MAKE-STATIC-INITIALIZER FINISH-CLASS DECLARE-FIELD SANITIZE SERIALIZE-INTEGER SERIALIZE-CHARACTER SERIALIZE-FLOAT SERIALIZE-DOUBLE SERIALIZE-STRING SERIALIZE-PACKAGE COMPILAND-EXTERNAL-CONSTANT-RESOURCE-NAME SERIALIZE-OBJECT SERIALIZE-SYMBOL EMIT-LOAD-EXTERNALIZED-OBJECT DECLARE-FUNCTION DECLARE-SETF-FUNCTION LOCAL-FUNCTION-CLASS-AND-FIELD DECLARE-LOCAL-FUNCTION DECLARE-OBJECT-AS-STRING DECLARE-LOAD-TIME-VALUE DECLARE-OBJECT COMPILE-CONSTANT INITIALIZE-UNARY-OPERATORS INSTALL-P2-HANDLER DEFINE-PREDICATE P2-PREDICATE COMPILE-FUNCTION-CALL-1 INITIALIZE-BINARY-OPERATORS COMPILE-BINARY-OPERATION COMPILE-FUNCTION-CALL-2 FIXNUM-OR-UNBOXED-VARIABLE-P EMIT-PUSH-INT EMIT-PUSH-LONG P2-EQ/NEQ EMIT-IFNE-FOR-EQL P2-EQL P2-MEMQ P2-MEMQL P2-GENSYM P2-GET P2-GETF P2-GETHASH P2-PUTHASH INLINE-OK PROCESS-ARGS EMIT-CALL-EXECUTE EMIT-CALL-THREAD-EXECUTE COMPILE-FUNCTION-CALL COMPILE-CALL P2-FUNCALL DUPLICATE-CLOSURE-ARRAY EMIT-LOAD-LOCAL-FUNCTION COMPILE-LOCAL-FUNCTION-CALL EMIT-NUMERIC-COMPARISON P2-NUMERIC-COMPARISON P2-TEST-HANDLER INITIALIZE-P2-TEST-HANDLERS NEGATE-JUMP-CONDITION EMIT-TEST-JUMP P2-TEST-PREDICATE P2-TEST-INSTANCEOF-PREDICATE P2-TEST-BIT-VECTOR-P P2-TEST-CHARACTERP P2-TEST-CONSTANTP P2-TEST-ENDP P2-TEST-EVENP P2-TEST-ODDP P2-TEST-FLOATP P2-TEST-INTEGERP P2-TEST-LISTP P2-TEST-MINUSP P2-TEST-PLUSP P2-TEST-ZEROP P2-TEST-NUMBERP P2-TEST-PACKAGEP P2-TEST-RATIONALP P2-TEST-REALP P2-TEST-SPECIAL-OPERATOR-P P2-TEST-SPECIAL-VARIABLE-P P2-TEST-SYMBOLP P2-TEST-CONSP P2-TEST-ATOM P2-TEST-FIXNUMP P2-TEST-STRINGP P2-TEST-VECTORP P2-TEST-SIMPLE-VECTOR-P COMPILE-TEST-FORM P2-TEST-NOT/NULL P2-TEST-CHAR= P2-TEST-EQ P2-TEST-OR P2-TEST-AND P2-TEST-NEQ P2-TEST-EQL P2-TEST-EQUALITY P2-TEST-SIMPLE-TYPEP P2-TEST-MEMQ P2-TEST-MEMQL P2-TEST-/= P2-TEST-NUMERIC-COMPARISON P2-IF COMPILE-MULTIPLE-VALUE-LIST COMPILE-MULTIPLE-VALUE-PROG1 COMPILE-MULTIPLE-VALUE-CALL UNUSED-VARIABLE CHECK-FOR-UNUSED-VARIABLES EMIT-NEW-CLOSURE-BINDING COMPILE-BINDING COMPILE-PROGN-BODY RESTORE-DYNAMIC-ENVIRONMENT SAVE-DYNAMIC-ENVIRONMENT P2-M-V-B-NODE PROPAGATE-VARS DERIVE-VARIABLE-REPRESENTATION ALLOCATE-VARIABLE-REGISTER EMIT-MOVE-TO-VARIABLE EMIT-PUSH-VARIABLE P2-LET-BINDINGS P2-LET*-BINDINGS P2-LET/LET*-NODE P2-LOCALLY-NODE P2-TAGBODY-NODE P2-GO P2-ATOM P2-INSTANCEOF-PREDICATE P2-BIT-VECTOR-P P2-CHARACTERP P2-CONSP P2-FIXNUMP P2-PACKAGEP P2-READTABLEP P2-SIMPLE-VECTOR-P P2-STRINGP P2-SYMBOLP P2-VECTORP P2-COERCE-TO-FUNCTION P2-BLOCK-NODE P2-RETURN-FROM EMIT-CAR/CDR P2-CAR P2-CDR P2-CONS COMPILE-PROGN P2-EVAL-WHEN P2-LOAD-TIME-VALUE P2-PROGV-NODE P2-QUOTE P2-RPLACD P2-SET-CAR/CDR COMPILE-DECLARE COMPILE-LOCAL-FUNCTION P2-FLET-NODE P2-LABELS-NODE P2-LAMBDA P2-FUNCTION P2-ASH P2-LOGAND P2-LOGIOR P2-LOGXOR P2-LOGNOT P2-%LDB P2-MOD P2-ZEROP P2-FIND-CLASS P2-VECTOR-PUSH-EXTEND P2-STD-SLOT-VALUE P2-SET-STD-SLOT-VALUE P2-STREAM-ELEMENT-TYPE P2-WRITE-8-BITS P2-READ-LINE DERIVE-TYPE-AREF DERIVE-TYPE-FIXNUMP DERIVE-TYPE-SETQ DERIVE-TYPE-LOGIOR/LOGXOR DERIVE-TYPE-LOGAND DERIVE-TYPE-LOGNOT DERIVE-TYPE-MOD DERIVE-TYPE-COERCE DERIVE-TYPE-COPY-SEQ DERIVE-TYPE-INTEGER-LENGTH DERIVE-TYPE-%LDB DERIVE-INTEGER-TYPE DERIVE-TYPE-NUMERIC-OP DERIVE-COMPILER-TYPES DERIVE-TYPE-MINUS DERIVE-TYPE-PLUS DERIVE-TYPE-TIMES DERIVE-TYPE-MAX DERIVE-TYPE-MIN DERIVE-TYPE-READ-CHAR DERIVE-TYPE-ASH DERIVE-TYPE DERIVE-COMPILER-TYPE P2-DELETE P2-LENGTH CONS-FOR-LIST/LIST* P2-LIST P2-LIST* COMPILE-NTH P2-TIMES P2-MIN/MAX P2-PLUS P2-MINUS P2-CHAR/SCHAR P2-SET-CHAR/SCHAR P2-SVREF P2-SVSET P2-TRUNCATE P2-ELT P2-AREF P2-ASET P2-STRUCTURE-REF P2-STRUCTURE-SET P2-NOT/NULL P2-NTHCDR P2-AND P2-OR P2-VALUES COMPILE-SPECIAL-REFERENCE COMPILE-VAR-REF P2-SET P2-SETQ P2-SXHASH P2-SYMBOL-NAME P2-SYMBOL-PACKAGE P2-SYMBOL-VALUE GENERATE-INSTANCEOF-TYPE-CHECK-FOR-VALUE GENERATE-TYPE-CHECK-FOR-VALUE P2-THE P2-TRULY-THE P2-CHAR-CODE P2-JAVA-JCLASS P2-JAVA-JCONSTRUCTOR P2-JAVA-JMETHOD P2-CHAR= P2-THREADS-SYNCHRONIZED-ON P2-JAVA-JRUN-EXCEPTION-PROTECTED P2-CATCH-NODE P2-THROW P2-UNWIND-PROTECT-NODE COMPILE-FORM P2-COMPILAND-PROCESS-TYPE-DECLARATIONS P2-COMPILAND-UNBOX-VARIABLE ASSIGN-FIELD-NAME P2-COMPILAND COMPILE-TO-JVM-CLASS P2-WITH-INLINE-CODE COMPILE-1 MAKE-COMPILER-ERROR-FORM COMPILE-DEFUN NOTE-ERROR-CONTEXT HANDLE-WARNING HANDLE-COMPILER-ERROR %WITH-COMPILATION-UNIT %JVM-COMPILE JVM-COMPILE INITIALIZE-P2-HANDLERS) (("dump-class") READ-U1 READ-U2 READ-U4 LOOKUP-UTF8 READ-CONSTANT-POOL-ENTRY DUMP-CODE DUMP-CODE-ATTRIBUTE DUMP-EXCEPTIONS READ-ATTRIBUTE READ-INFO DUMP-CLASS) (("jvm-class-file") MAP-PRIMITIVE-TYPE PRETTY-CLASS PRETTY-TYPE %MAKE-JVM-CLASS-NAME JVM-CLASS-NAME-P %PRINT-JVM-CLASS-NAME MAKE-JVM-CLASS-NAME CLASS-ARRAY INTERNAL-FIELD-TYPE INTERNAL-FIELD-REF DESCRIPTOR DESCRIPTOR-STACK-EFFECT MAKE-POOL POOL-P MATCHING-INDEX-P FIND-POOL-ENTRY MAKE-CONSTANT CONSTANT-P PRINT-POOL-CONSTANT MAKE-CONSTANT-CLASS CONSTANT-CLASS-P %MAKE-CONSTANT-MEMBER-REF CONSTANT-MEMBER-REF-P MAKE-CONSTANT-FIELD-REF MAKE-CONSTANT-METHOD-REF MAKE-CONSTANT-INTERFACE-METHOD-REF MAKE-CONSTANT-STRING CONSTANT-STRING-P %MAKE-CONSTANT-FLOAT/INT CONSTANT-FLOAT/INT-P MAKE-CONSTANT-FLOAT MAKE-CONSTANT-INT %MAKE-CONSTANT-DOUBLE/LONG CONSTANT-DOUBLE/LONG-P MAKE-CONSTANT-DOUBLE MAKE-CONSTANT-LONG MAKE-CONSTANT-NAME/TYPE CONSTANT-NAME/TYPE-P PARSE-DESCRIPTOR MAKE-CONSTANT-UTF8 CONSTANT-UTF8-P POOL-ADD-CLASS POOL-ADD-FIELD-REF POOL-ADD-METHOD-REF POOL-ADD-INTERFACE-METHOD-REF POOL-ADD-STRING POOL-ADD-INT POOL-ADD-FLOAT POOL-ADD-LONG POOL-ADD-DOUBLE POOL-ADD-NAME/TYPE POOL-ADD-UTF8 MAKE-CLASS-FILE CLASS-FILE-P MAKE-CLASS-INTERFACE-FILE CLASS-ADD-FIELD CLASS-FIELD CLASS-ADD-METHOD CLASS-METHODS-BY-NAME CLASS-METHOD CLASS-REMOVE-METHOD CLASS-ADD-ATTRIBUTE CLASS-ADD-SUPERINTERFACE CLASS-ATTRIBUTE FINALIZE-INTERFACES FINALIZE-CLASS-FILE WRITE-U1 WRITE-U2 WRITE-U4 WRITE-S4 WRITE-ASCII WRITE-UTF8 WRITE-CLASS-FILE WRITE-CONSTANTS PRINT-ENTRY MAP-FLAGS %MAKE-FIELD FIELD-P MAKE-FIELD FIELD-ADD-ATTRIBUTE FIELD-ATTRIBUTE FINALIZE-FIELD WRITE-FIELD %MAKE-JVM-METHOD JVM-METHOD-P MAP-METHOD-NAME MAKE-JVM-METHOD METHOD-ADD-ATTRIBUTE METHOD-ADD-CODE METHOD-ENSURE-CODE METHOD-ATTRIBUTE FINALIZE-METHOD WRITE-METHOD MAKE-ATTRIBUTE ATTRIBUTE-P FINALIZE-ATTRIBUTES WRITE-ATTRIBUTES %MAKE-CODE-ATTRIBUTE CODE-ATTRIBUTE-P CODE-LABEL-OFFSET FINALIZE-CODE-ATTRIBUTE WRITE-CODE-ATTRIBUTE MAKE-CODE-ATTRIBUTE CODE-ADD-ATTRIBUTE CODE-ATTRIBUTE CODE-ADD-EXCEPTION-HANDLER MAKE-EXCEPTION EXCEPTION-P MAKE-CONSTANT-VALUE-ATTRIBUTE CONSTANT-VALUE-ATTRIBUTE-P MAKE-CHECKED-EXCEPTIONS-ATTRIBUTE CHECKED-EXCEPTIONS-ATTRIBUTE-P FINALIZE-CHECKED-EXCEPTIONS WRITE-CHECKED-EXCEPTIONS MAKE-DEPRECATED-ATTRIBUTE DEPRECATED-ATTRIBUTE-P SAVE-CODE-SPECIALS RESTORE-CODE-SPECIALS MAKE-SOURCE-FILE-ATTRIBUTE SOURCE-FILE-ATTRIBUTE-P FINALIZE-SOURCE-FILE WRITE-SOURCE-FILE MAKE-SYNTHETIC-ATTRIBUTE SYNTHETIC-ATTRIBUTE-P MAKE-LINE-NUMBERS-ATTRIBUTE LINE-NUMBERS-ATTRIBUTE-P MAKE-LINE-NUMBER LINE-NUMBER-P FINALIZE-LINE-NUMBERS WRITE-LINE-NUMBERS LINE-NUMBERS-ADD-LINE MAKE-LOCAL-VARIABLES-ATTRIBUTE LOCAL-VARIABLES-ATTRIBUTE-P MAKE-LOCAL-VARIABLE LOCAL-VARIABLE-P FINALIZE-LOCAL-VARIABLES WRITE-LOCAL-VARIABLES MAKE-ANNOTATIONS-ATTRIBUTE ANNOTATIONS-ATTRIBUTE-P MAKE-ANNOTATION ANNOTATION-P MAKE-ANNOTATION-ELEMENT ANNOTATION-ELEMENT-P MAKE-PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT PRIMITIVE-OR-STRING-ANNOTATION-ELEMENT-P MAKE-ENUM-VALUE-ANNOTATION-ELEMENT ENUM-VALUE-ANNOTATION-ELEMENT-P MAKE-ANNOTATION-VALUE-ANNOTATION-ELEMENT ANNOTATION-VALUE-ANNOTATION-ELEMENT-P MAKE-ARRAY-ANNOTATION-ELEMENT ARRAY-ANNOTATION-ELEMENT-P MAKE-RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE RUNTIME-VISIBLE-ANNOTATIONS-ATTRIBUTE-P FINALIZE-ANNOTATIONS FINALIZE-ANNOTATION FINALIZE-ANNOTATION-ELEMENT WRITE-ANNOTATIONS WRITE-ANNOTATION WRITE-ANNOTATION-ELEMENT) (("jvm-instructions") U2 S1 S2 MAKE-JVM-OPCODE JVM-OPCODE-P %DEFINE-OPCODE OPCODE-NAME OPCODE-NUMBER OPCODE-SIZE OPCODE-STACK-EFFECT OPCODE-ARGS-SPEC %MAKE-INSTRUCTION INSTRUCTION-P MAKE-INSTRUCTION PRINT-INSTRUCTION INSTRUCTION-LABEL INST %%EMIT %EMIT LABEL ALOAD ASTORE ILOAD ISTORE BRANCH-P UNCONDITIONAL-CONTROL-TRANSFER-P LABEL-P FORMAT-INSTRUCTION-ARGS PRINT-CODE PRINT-CODE2 EXPAND-VIRTUAL-INSTRUCTIONS UNSUPPORTED-OPCODE INITIALIZE-RESOLVERS LOAD/STORE-RESOLVER RESOLVE-INSTRUCTION RESOLVE-INSTRUCTIONS ANALYZE-STACK-PATH ANALYZE-STACK ANALYZE-LOCALS DELETE-UNUSED-LABELS DELETE-UNREACHABLE-CODE LABEL-TARGET-INSTRUCTIONS OPTIMIZE-JUMPS OPTIMIZE-INSTRUCTION-SEQUENCES OPTIMIZE-CODE CODE-BYTES FINALIZE-CODE) (("jvm") INVOKE-CALLBACKS %MAKE-ABCL-CLASS-FILE ABCL-CLASS-FILE-P CLASS-NAME-FROM-FILESPEC MAKE-UNIQUE-CLASS-NAME MAKE-ABCL-CLASS-FILE MAKE-COMPILAND COMPILAND-P COMPILAND-SINGLE-VALUED-P DUMP-1-VARIABLE DUMP-VARIABLES MAKE-VARIABLE VARIABLE-P MAKE-VAR-REF VAR-REF-P UNBOXED-FIXNUM-VARIABLE FIND-VARIABLE FIND-VISIBLE-VARIABLE REPRESENTATION-SIZE ALLOCATE-REGISTER MAKE-LOCAL-FUNCTION LOCAL-FUNCTION-P FIND-LOCAL-FUNCTION MAKE-NODE NODE-P ADD-NODE-CHILD MAKE-CONTROL-TRANSFERRING-NODE CONTROL-TRANSFERRING-NODE-P %MAKE-TAGBODY-NODE TAGBODY-NODE-P MAKE-TAGBODY-NODE %MAKE-CATCH-NODE CATCH-NODE-P MAKE-CATCH-NODE %MAKE-BLOCK-NODE BLOCK-NODE-P MAKE-BLOCK-NODE %MAKE-JUMP-NODE JUMP-NODE-P MAKE-JUMP-NODE MAKE-BINDING-NODE BINDING-NODE-P %MAKE-LET/LET*-NODE LET/LET*-NODE-P MAKE-LET/LET*-NODE %MAKE-FLET-NODE FLET-NODE-P MAKE-FLET-NODE %MAKE-LABELS-NODE LABELS-NODE-P MAKE-LABELS-NODE %MAKE-M-V-B-NODE M-V-B-NODE-P MAKE-M-V-B-NODE %MAKE-PROGV-NODE PROGV-NODE-P MAKE-PROGV-NODE %MAKE-LOCALLY-NODE LOCALLY-NODE-P MAKE-LOCALLY-NODE %MAKE-PROTECTED-NODE PROTECTED-NODE-P MAKE-PROTECTED-NODE %MAKE-UNWIND-PROTECT-NODE UNWIND-PROTECT-NODE-P MAKE-UNWIND-PROTECT-NODE %MAKE-SYNCHRONIZED-NODE SYNCHRONIZED-NODE-P MAKE-SYNCHRONIZED-NODE %MAKE-EXCEPTION-PROTECTED-NODE EXCEPTION-PROTECTED-NODE-P MAKE-EXCEPTION-PROTECTED-NODE FIND-BLOCK %FIND-ENCLOSED-BLOCKS FIND-ENCLOSED-BLOCKS SOME-NESTED-BLOCK NODE-CONSTANT-P BLOCK-REQUIRES-NON-LOCAL-EXIT-P NODE-OPSTACK-UNSAFE-P BLOCK-CREATES-RUNTIME-BINDINGS-P ENCLOSED-BY-RUNTIME-BINDINGS-CREATING-BLOCK-P ENCLOSED-BY-PROTECTED-BLOCK-P ENCLOSED-BY-ENVIRONMENT-SETTING-BLOCK-P ENVIRONMENT-REGISTER-TO-RESTORE MAKE-TAG TAG-P FIND-TAG PROCESS-IGNORE/IGNORABLE FINALIZE-GENERIC-FUNCTIONS) (("runtime-class") BOX-ARGUMENTS EMIT-INVOKESPECIAL PARSE-ANNOTATION PARSE-ANNOTATION-ELEMENT)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("compiler-pass1") PUSH-ARGUMENT-BINDING) (("compiler-pass2") WITH-OPERAND-ACCUMULATION ACCUMULATE-OPERAND DECLARE-WITH-HASHTABLE DEFINE-INLINED-FUNCTION P2-TEST-INTEGER-PREDICATE DEFINE-DERIVE-TYPE-HANDLER DEFINE-INT-BOUNDS-DERIVATION WITH-OPEN-CLASS-FILE WITH-FILE-COMPILATION) (("dump-class") OUT) (("jvm-class-file") DEFINE-CLASS-NAME WITH-CODE-TO-METHOD) (("jvm-instructions") DEFINE-OPCODE EMIT DEFINE-RESOLVER) (("jvm") DFORMAT WITH-SAVED-COMPILER-POLICY WITH-CLASS-FILE)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :JVM)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("jvm-class-file") CODE-LABEL-OFFSET)))) (FUNCALL (FUNCTION AUTOLOAD-SETF-FUNCTION) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("collect") COLLECT-NORMAL-EXPANDER COLLECT-LIST-EXPANDER) (("compile-system") COMPILE-SYSTEM) (("debug") SHOW-RESTARTS) (("featurep") FEATUREP OS-MACOSX-P OS-UNIX-P OS-WINDOWS-P OS-GENERA-P OS-OLDMAC-P OS-HAIKU-P) (("get-pid") GET-PID) (("gui") INIT-GUI MAKE-DIALOG-PROMPT-STREAM %MAKE-DIALOG-PROMPT-STREAM) (("package") ADD-PACKAGE-LOCAL-NICKNAME) (("pathnames") URL-PATHNAME-SCHEME SET-URL-PATHNAME-SCHEME URL-PATHNAME-AUTHORITY SET-URL-PATHNAME-AUTHORITY URL-PATHNAME-QUERY SET-URL-PATHNAME-QUERY URL-PATHNAME-FRAGMENT SET-URL-PATHNAME-FRAGMENT) (("pprint") CHARPOS) (("run-shell-command") RUN-SHELL-COMMAND) (("socket") GET-SOCKET-STREAM MAKE-SOCKET MAKE-SERVER-SOCKET SOCKET-ACCEPT SOCKET-CLOSE SERVER-SOCKET-CLOSE %SOCKET-ADDRESS %SOCKET-PORT SOCKET-LOCAL-ADDRESS SOCKET-PEER-ADDRESS SOCKET-LOCAL-PORT SOCKET-PEER-PORT READ-TIMEOUT WRITE-TIMEOUT)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("collect") COLLECT)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :EXTENSIONS)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("pprint") CHARPOS)))) (FUNCALL (FUNCTION AUTOLOAD-SETF-FUNCTION) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :THREADS)
     [java] ; (IN-PACKAGE :THREADS)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("threads") THREAD-FUNCTION-WRAPPER MAKE-MAILBOX MAILBOX-P MAILBOX-SEND MAILBOX-EMPTY-P MAILBOX-READ MAILBOX-PEEK MAKE-MUTEX MUTEX-P GET-MUTEX RELEASE-MUTEX MAKE-THREAD-LOCK YIELD)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :THREADS)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("threads") WITH-MUTEX WITH-THREAD-LOCK)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :TOP-LEVEL)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("top-level") PROMPT-PACKAGE-NAME REPL-PROMPT-FUN PEEK-CHAR-NON-WHITESPACE APROPOS-COMMAND CONTINUE-COMMAND DESCRIBE-COMMAND ERROR-COMMAND PRINT-FRAME BACKTRACE-COMMAND FRAME-COMMAND INSPECT-COMMAND ISTEP-COMMAND MACROEXPAND-COMMAND PACKAGE-COMMAND RESET-COMMAND EXIT-COMMAND CD-COMMAND LS-COMMAND TOKENIZE LD-COMMAND CF-COMMAND CLOAD-COMMAND RQ-COMMAND PWD-COMMAND TRACE-COMMAND UNTRACE-COMMAND PAD %HELP-COMMAND HELP-COMMAND ENTRY-NAME ENTRY-ABBREVIATION ENTRY-COMMAND ENTRY-HELP FIND-COMMAND PROCESS-CMD READ-CMD REPL-READ-FORM-FUN REPL TOP-LEVEL-LOOP)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DOLIST (FS (QUOTE ((("abcl-contrib") BOOT-CLASSLOADER SYSTEM-JAR-P CONTRIB-JAR-P NAMED-JAR-P FIND-SYSTEM FIND-JAR FIND-SYSTEM-JAR FIND-CONTRIB-JAR ADD-CONTRIB FIND-AND-ADD-CONTRIB FIND-NAME-FOR-IMPLEMENTATION-TITLE FIND-CONTRIB) (("apropos") APROPOS-LIST-EO APROPOS-EO) (("assert") ASSERT-ERROR ASSERT-PROMPT) (("aver") %FAILED-AVER) (("backquote") BACKQUOTE-MACRO COMMA-MACRO EXPANDABLE-BACKQ-EXPRESSION-P BACKQUOTIFY COMMA BACKQUOTIFY-1 BACKQ-LIST BACKQ-LIST* BACKQ-APPEND BACKQ-NCONC BACKQ-CONS BACKQ-VECTOR %READER-ERROR) (("bit-array-ops") BIT-ARRAY-SAME-DIMENSIONS-P REQUIRE-SAME-DIMENSIONS PICK-RESULT-ARRAY) (("case") LIST-OF-LENGTH-AT-LEAST-P CASE-BODY-ERROR CASE-BODY-AUX CASE-BODY) (("check-type") CHECK-TYPE-ERROR) (("clos") COERCE-TO-CONDITION) (("coerce") COERCE-LIST-TO-VECTOR COPY-STRING COERCE-ERROR COERCE-OBJECT-TO-AND-TYPE) (("compile-file-pathname") CFP-OUTPUT-FILE-DEFAULT) (("compile-file") BASE-CLASSNAME FASL-LOADER-CLASSNAME COMPUTE-CLASSFILE SANITIZE-CLASS-NAME NEXT-CLASSFILE DUMMY VERIFY-LOAD NOTE-TOPLEVEL-FORM OUTPUT-FORM FINALIZE-FASL-OUTPUT SIMPLE-TOPLEVEL-FORM-P CONVERT-TOPLEVEL-FORM PROCESS-PROGN PRECOMPILE-TOPLEVEL-FORM PROCESS-TOPLEVEL-MACROLET PROCESS-TOPLEVEL-DEFCONSTANT PROCESS-TOPLEVEL-QUOTE PROCESS-TOPLEVEL-IMPORT PROCESS-TOPLEVEL-EXPORT PROCESS-RECORD-SOURCE-INFORMATION PROCESS-TOPLEVEL-MOP.ENSURE-METHOD PROCESS-TOPLEVEL-DEFVAR/DEFPARAMETER PROCESS-TOPLEVEL-DEFPACKAGE/IN-PACKAGE PROCESS-TOPLEVEL-DECLARE PROCESS-TOPLEVEL-PROGN PROCESS-TOPLEVEL-DEFTYPE PROCESS-TOPLEVEL-EVAL-WHEN PROCESS-TOPLEVEL-DEFMETHOD/DEFGENERIC PROCESS-TOPLEVEL-LOCALLY PROCESS-TOPLEVEL-DEFMACRO PROCESS-TOPLEVEL-DEFUN INSTALL-TOPLEVEL-HANDLER PROCESS-TOPLEVEL-FORM POPULATE-ZIP-FASL WRITE-FASL-PROLOGUE COMPILE-FROM-STREAM COMPILE-FILE-IF-NEEDED) (("compile-system") CHECK-LISP-HOME GROVEL-JAVA-DEFINITIONS-IN-FILE GROVEL-JAVA-DEFINITIONS PACKAGES-FROM-COMBOS REMOVE-MULTI-COMBO-SYMBOLS SET-EQUAL COMBOS-TO-SYMBOL-FILESETS COMBOS-TO-FILESET-SYMBOLS WRITE-AUTOLOADER WRITE-PACKAGE-FILESETS LOAD-COMBOS GENERATE-AUTOLOADS %COMPILE-SYSTEM CREATE-SYSTEM-LOGICAL-TRANSLATIONS) (("compiler-error") COMPILER-STYLE-WARN COMPILER-WARN COMPILER-ERROR INTERNAL-COMPILER-ERROR COMPILER-UNSUPPORTED) (("compiler-macro") COMPILER-MACROEXPAND-1 COMPILER-MACROEXPAND) (("compiler-pass2") AUTOCOMPILE) (("compiler-types") MAKE-CONSTANT-TYPE CONSTANT-TYPE-P %MAKE-INTEGER-TYPE INTEGER-TYPE-P MAKE-INTEGER-TYPE FIXNUM-TYPE-P FIXNUM-CONSTANT-VALUE INTEGER-CONSTANT-VALUE JAVA-LONG-TYPE-P MAKE-UNION-TYPE MAKE-COMPILER-TYPE INTEGER-TYPE-SUBTYPEP COMPILER-SUBTYPEP FUNCTION-RESULT-TYPE SET-FUNCTION-RESULT-TYPE %DEFKNOWN) (("concatenate") CONCATENATE-TO-STRING) (("debug") INTERNAL-DEBUG DEBUG-LOOP INVOKE-DEBUGGER-REPORT-CONDITION RUN-HOOK BACKTRACE-AS-LIST) (("define-symbol-macro") %DEFINE-SYMBOL-MACRO) (("defpackage") DESIGNATED-PACKAGE-NAME STRINGIFY-NAMES CHECK-DISJOINT) (("defsetf") %DEFSETF) (("defstruct") MAKE-DEFSTRUCT-DESCRIPTION MAKE-DEFSTRUCT-SLOT-DESCRIPTION KEYWORDIFY DEFINE-KEYWORD-CONSTRUCTOR FIND-DSD GET-SLOT DEFINE-BOA-CONSTRUCTOR DEFAULT-CONSTRUCTOR-NAME DEFINE-CONSTRUCTORS NAME-INDEX DEFINE-PREDICATE MAKE-LIST-READER MAKE-VECTOR-READER MAKE-STRUCTURE-READER DEFINE-READER MAKE-LIST-WRITER MAKE-VECTOR-WRITER MAKE-STRUCTURE-WRITER DEFINE-WRITER DEFINE-ACCESS-FUNCTIONS DEFINE-COPIER DEFINE-PRINT-FUNCTION PARSE-1-OPTION PARSE-NAME-AND-OPTIONS COMPILER-DEFSTRUCT DEFSTRUCT-DEFAULT-CONSTRUCTOR) (("deftype") EXPAND-DEFTYPE) (("delete-duplicates") LIST-DELETE-DUPLICATES* VECTOR-DELETE-DUPLICATES*) (("describe-compiler-policy") DESCRIBE-COMPILER-POLICY) (("describe") DESCRIBE-ARGLIST %DESCRIBE-OBJECT %DESCRIBE-STANDARD-OBJECT/FUNCALLABLE) (("destructuring-bind") PARSE-BODY ARG-COUNT-ERROR BOGUS-SUBLIST-ERROR LAMBDA-LIST-BROKEN-KEY-LIST-ERROR PARSE-DEFMACRO DEFMACRO-ERROR VERIFY-KEYWORDS LOOKUP-KEYWORD KEYWORD-SUPPLIED-P DOT-LENGTH PARSE-DEFMACRO-LAMBDA-LIST PUSH-SUB-LIST-BINDING PUSH-LET-BINDING PUSH-OPTIONAL-BINDING MAKE-MACRO-EXPANDER) (("digest") ASCIIFY SHA256 DIGEST DIGEST-PATH DIGEST-NIO) (("directory") PATHNAME-AS-FILE WILD-INFERIORS-P LIST-DIRECTORIES-WITH-WILDCARDS) (("disassemble") CHOOSE-DISASSEMBLER READ-BYTE-ARRAY-FROM-STREAM CLASS-RESOURCE-PATH CLASS-BYTES DISASSEMBLE-BYTES DISASSEMBLE-FUNCTION FUNCTION-PLIST GET-LOADED-FROM SET-LOADED-FROM FASL-COMPILED-CLOSURE-CLASS-BYTES PRINT-LINES-WITH-PREFIX) (("do") DO-DO-BODY) (("dump-form") GET-INSTANCE-FORM DF-REGISTER-CIRCULARITY DF-CHECK-CONS DF-CHECK-VECTOR DF-CHECK-INSTANCE DF-CHECK-OBJECT DF-HANDLE-CIRCULARITY DUMP-CONS DUMP-VECTOR DUMP-INSTANCE DUMP-UNINTERNED-SYMBOL-INDEX DUMP-PATHNAME DUMP-OBJECT DUMP-FORM) (("ed") DEFAULT-ED-FUNCTION) (("enough-namestring") EQUAL-COMPONENTS-P) (("fasl-concat") PATHNAME-DIRECTORY-P LOAD-CONCATENATED-FASL CONCATENATE-FASLS SUB-DIRECTORY) (("fill") LIST-FILL VECTOR-FILL) (("find") LIST-POSITION* VECTOR-POSITION* LIST-FIND* VECTOR-FIND*) (("format") SYMBOLICATE PROPER-LIST-OF-LENGTH-P FLOAT-TO-DIGITS* FLONUM-TO-STRING-OLD SCALE-EXPONENT ROUND-UP SCALE-EXPONENT-OLD FLOAT-DENORMALIZED-P FLOAT-TO-DIGITS-OLD FLOAT-TO-DIGITS) (("inline") INLINE-EXPANSION SET-INLINE-EXPANSION) (("inspect") LEADER SAFE-LENGTH DISPLAY-OBJECT DISPLAY-CURRENT ISTEP) (("late-setf") MAKE-GENSYM-LIST) (("lcm") TWO-ARG-LCM) (("ldb") %LDB) (("load") LOAD-RETURNING-LAST-RESULT) (("make-sequence") SIZE-MISMATCH-ERROR) (("map1") MAP1) (("nsubstitute") NLIST-SUBSTITUTE* NVECTOR-SUBSTITUTE* NLIST-SUBSTITUTE-IF* NVECTOR-SUBSTITUTE-IF* NLIST-SUBSTITUTE-IF-NOT* NVECTOR-SUBSTITUTE-IF-NOT*) (("open") UPGRADED-ELEMENT-TYPE-BITS UPGRADED-ELEMENT-TYPE) (("parse-integer") PARSE-INTEGER-ERROR) (("parse-lambda-list") PARSE-LAMBDA-LIST-LIKE-THING PARSE-LAMBDA-LIST) (("pathnames") COMPONENT-MATCH-WILD-P COMPONENT-MATCH-P DIRECTORY-MATCH-COMPONENTS DIRECTORY-MATCH-P WILD-P CASIFY TRANSLATE-COMPONENT TRANSLATE-JAR-DEVICE TRANSLATE-DIRECTORY-COMPONENTS-AUX TRANSLATE-DIRECTORY-COMPONENTS TRANSLATE-DIRECTORY LOGICAL-HOST-P CANONICALIZE-LOGICAL-PATHNAME-TRANSLATIONS %SET-LOGICAL-PATHNAME-TRANSLATIONS) (("print-unreadable-object") %PRINT-UNREADABLE-OBJECT) (("print") COMPOUND-OBJECT-P OUTPUT-INTEGER OUTPUT-LIST OUTPUT-TERSE-ARRAY ARRAY-READABLY-PRINTABLE-P OUTPUT-VECTOR OUTPUT-UGLY-OBJECT CHECK-FOR-CIRCULARITY HANDLE-CIRCULARITY PRINT-LABEL PRINT-REFERENCE UNIQUELY-IDENTIFIED-BY-PRINT-P %PRINT-OBJECT %CHECK-OBJECT OUTPUT-OBJECT) (("proclaim") DECLARATION-ERROR CHECK-DECLARATION-TYPE PROCLAIM-TYPE PROCLAIMED-TYPE PROCLAIM-FTYPE-1 PROCLAIM-FTYPE PROCLAIMED-FTYPE FTYPE-RESULT-TYPE) (("query") QUERY-READLINE) (("read-circle") CIRCLE-SUBST SHARP-EQUAL SHARP-SHARP) (("read-conditional") READ-FEATURE READ-CONDITIONAL) (("remove-duplicates") LIST-REMOVE-DUPLICATES VECTOR-REMOVE-DUPLICATES) (("replace") LIST-REPLACE-FROM-LIST* LIST-REPLACE-FROM-VECTOR* VECTOR-REPLACE-FROM-LIST* VECTOR-REPLACE-FROM-VECTOR*) (("run-program") NOT-JAVA-6 RUN-PROGRAM COERCE-TO-FILE SETUP-INPUT-REDIRECTION SETUP-OUTPUT-REDIRECTION %MAKE-PROCESS PROCESS-P MAKE-PROCESS PROCESS-INPUT PROCESS-OUTPUT PROCESS-ERROR PROCESS-ALIVE-P PROCESS-WAIT PROCESS-EXIT-CODE PROCESS-KILL PROCESS-PID %MAKE-PROCESS-BUILDER %PROCESS-BUILDER-ENVIRONMENT %PROCESS-BUILDER-ENV-PUT %PROCESS-BUILDER-ENV-CLEAR %PROCESS-BUILDER-START %MAKE-PROCESS-INPUT-STREAM %MAKE-PROCESS-OUTPUT-STREAM %MAKE-PROCESS-ERROR-STREAM %PROCESS-ALIVE-P %PROCESS-WAIT %PROCESS-EXIT-CODE %PROCESS-PID %PROCESS-KILL TO-FILE FROM-FILE) (("search") SIMPLE-SEARCH) (("sequences") MAKE-SEQUENCE-OF-TYPE) (("setf") GET-SETF-METHOD-INVERSE EXPAND-OR-GET-SETF-INVERSE %SET-SUBSEQ %DEFINE-SETF-MACRO %SET-CAAR %SET-CADR %SET-CDAR %SET-CDDR %SET-CAAAR %SET-CADAR %SET-CDAAR %SET-CDDAR %SET-CAADR %SET-CADDR %SET-CDADR %SET-CDDDR %SET-CAAAAR %SET-CADAAR %SET-CDAAAR %SET-CDDAAR %SET-CAADAR %SET-CADDAR %SET-CDADAR %SET-CDDDAR %SET-CAAADR %SET-CADADR %SET-CDAADR %SET-CDDADR %SET-CAADDR %SET-CADDDR %SET-CDADDR %SET-CDDDDR %SET-FIFTH %SET-SIXTH %SET-SEVENTH %SET-EIGHTH %SET-NINTH %SET-TENTH) (("sort") MERGE-SORT-VECTORS LAST-CONS-OF MERGE-LISTS MERGE-LISTS-NO-KEY SORT-LIST QUICKSORT QUICK-SORT) (("source-transform") SOURCE-TRANSFORM SET-SOURCE-TRANSFORM EXPAND-SOURCE-TRANSFORM-1 EXPAND-SOURCE-TRANSFORM) (("subst") %SUBST %SUBST-IF %SUBST-IF-NOT) (("subtypep") INITIALIZE-KNOWN-TYPES KNOWN-TYPE-P SUB-INTERVAL-P DIMENSION-SUBTYPEP SIMPLE-SUBTYPEP MAKE-CTYPE CTYPE-SUPER CTYPE-TYPE CTYPE CSUBTYPEP-ARRAY CSUBTYPEP-FUNCTION CSUBTYPEP-COMPLEX CSUBTYPEP PROPERLY-NAMED-CLASS-P %SUBTYPEP) (("time") PICK-OBVIOUS-YEAR LEAP-YEARS-BEFORE) (("trace") MAKE-TRACE-INFO TRACE-INFO-P LIST-TRACED-FUNCTIONS EXPAND-TRACE TRACE-1 TRACED-FUNCTION UNTRACED-FUNCTION TRACE-REDEFINED-UPDATE INDENT UNTRACE-ALL UNTRACE-1) (("tree-equal") TREE-EQUAL-TEST-NOT TREE-EQUAL-TEST) (("typep") SIMPLE-ARRAY-P IN-INTERVAL-P MATCH-DIMENSIONS %TYPEP) (("with-hash-table-iterator") HASH-TABLE-ITERATOR-FUNCTION) (("with-package-iterator") PACKAGE-ITERATOR-FUNCTION) (("with-standard-io-syntax") %WITH-STANDARD-IO-SYNTAX)))) (FUNCALL (FUNCTION AUTOLOAD) (CDR FS) (CAR (CAR FS))))
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DOLIST (FS (QUOTE ((("assoc") ASSOC-GUTS) (("aver") AVER) (("chars") EQUAL-CHAR-CODE) (("compile-file") REPORT-ERROR DIAG) (("compiler-types") DEFKNOWN) (("copy-seq") VECTOR-COPY-SEQ LIST-COPY-SEQ) (("define-modify-macro") INCF-COMPLEX DECF-COMPLEX) (("defstruct") DD-NAME DD-CONC-NAME DD-DEFAULT-CONSTRUCTOR DD-CONSTRUCTORS DD-COPIER DD-INCLUDE DD-TYPE DD-NAMED DD-INITIAL-OFFSET DD-PREDICATE DD-PRINT-FUNCTION DD-PRINT-OBJECT DD-DIRECT-SLOTS DD-SLOTS DD-INHERITED-ACCESSORS DSD-NAME DSD-INDEX DSD-READER DSD-INITFORM DSD-TYPE DSD-READ-ONLY) (("delete") MUMBLE-DELETE MUMBLE-DELETE-FROM-END NORMAL-MUMBLE-DELETE NORMAL-MUMBLE-DELETE-FROM-END LIST-DELETE LIST-DELETE-FROM-END NORMAL-LIST-DELETE NORMAL-LIST-DELETE-FROM-END IF-MUMBLE-DELETE IF-MUMBLE-DELETE-FROM-END IF-LIST-DELETE IF-LIST-DELETE-FROM-END IF-NOT-MUMBLE-DELETE IF-NOT-MUMBLE-DELETE-FROM-END IF-NOT-LIST-DELETE IF-NOT-LIST-DELETE-FROM-END) (("disassemble") WITH-OPEN) (("find") VECTOR-LOCATER-MACRO LOCATER-TEST-NOT VECTOR-LOCATER LOCATER-IF-TEST VECTOR-LOCATER-IF-MACRO VECTOR-LOCATER-IF VECTOR-LOCATER-IF-NOT LIST-LOCATER-MACRO LIST-LOCATER LIST-LOCATER-IF-MACRO LIST-LOCATER-IF LIST-LOCATER-IF-NOT VECTOR-POSITION LIST-POSITION VECTOR-POSITION-IF LIST-POSITION-IF VECTOR-POSITION-IF-NOT LIST-POSITION-IF-NOT VECTOR-FIND LIST-FIND VECTOR-FIND-IF LIST-FIND-IF VECTOR-FIND-IF-NOT LIST-FIND-IF-NOT) (("format") NAMED-LET ONCE-ONLY) (("list") APPLY-KEY) (("print") PUNT-PRINT-IF-TOO-LONG) (("reduce") LIST-REDUCE LIST-REDUCE-FROM-END) (("remove") MUMBLE-REMOVE-MACRO MUMBLE-REMOVE MUMBLE-REMOVE-FROM-END NORMAL-MUMBLE-REMOVE NORMAL-MUMBLE-REMOVE-FROM-END IF-MUMBLE-REMOVE IF-MUMBLE-REMOVE-FROM-END IF-NOT-MUMBLE-REMOVE IF-NOT-MUMBLE-REMOVE-FROM-END LIST-REMOVE-MACRO LIST-REMOVE LIST-REMOVE-FROM-END NORMAL-LIST-REMOVE NORMAL-LIST-REMOVE-FROM-END IF-LIST-REMOVE IF-LIST-REMOVE-FROM-END IF-NOT-LIST-REMOVE IF-NOT-LIST-REMOVE-FROM-END) (("sequences") TYPE-SPECIFIER-ATOM MAKE-SEQUENCE-LIKE) (("sets") WITH-SET-KEYS STEVE-SPLICE) (("sort") MERGE-VECTORS-BODY MERGE-SORT-BODY QUICKSORT-BODY) (("source-transform") DEFINE-SOURCE-TRANSFORM) (("subst") SATISFIES-THE-TEST)))) (FUNCALL (FUNCTION AUTOLOAD-MACRO) (CDR FS) (CAR (CAR FS))))
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DOLIST (FS (QUOTE ((("disassemble") FUNCTION-PLIST)))) (FUNCALL (FUNCTION AUTOLOAD-SETF-FUNCTION) (CDR FS) (CAR (CAR FS))))
     [java] ; (IN-PACKAGE :SYSTEM)
     [java] ; (DOLIST (FS (QUOTE ((("ldb") %LDB)))) (FUNCALL (FUNCTION AUTOLOAD-SETF-EXPANDER) (CDR FS) (CAR (CAR FS))))
     [java] ; (IN-PACKAGE :CL)
     [java] ; (IN-PACKAGE :CL)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("adjoin") ADJOIN) (("apropos") APROPOS-LIST APROPOS) (("arrays") MAKE-ARRAY ADJUST-ARRAY ARRAY-ROW-MAJOR-INDEX BIT SBIT) (("assoc") ASSOC ASSOC-IF ASSOC-IF-NOT RASSOC RASSOC-IF RASSOC-IF-NOT ACONS PAIRLIS COPY-ALIST) (("bit-array-ops") BIT-AND BIT-IOR BIT-XOR BIT-EQV BIT-NAND BIT-NOR BIT-ANDC1 BIT-ANDC2 BIT-ORC1 BIT-ORC2 BIT-NOT) (("boole") BOOLE) (("butlast") BUTLAST NBUTLAST) (("byte-io") WRITE-BYTE READ-BYTE) (("chars") CHAR/= CHAR> CHAR>= CHAR-NOT-EQUAL) (("clos") CLASS-NAME NO-APPLICABLE-METHOD FUNCTION-KEYWORDS SLOT-VALUE SLOT-BOUNDP SLOT-MAKUNBOUND SLOT-EXISTS-P METHOD-QUALIFIERS ENSURE-GENERIC-FUNCTION COMPUTE-APPLICABLE-METHODS SLOT-MISSING SLOT-UNBOUND ALLOCATE-INSTANCE INITIALIZE-INSTANCE REINITIALIZE-INSTANCE CHANGE-CLASS UPDATE-INSTANCE-FOR-DIFFERENT-CLASS MAKE-INSTANCES-OBSOLETE UPDATE-INSTANCE-FOR-REDEFINED-CLASS MAKE-CONDITION INVALID-METHOD-ERROR METHOD-COMBINATION-ERROR FIND-METHOD ADD-METHOD REMOVE-METHOD NO-NEXT-METHOD) (("coerce") COERCE) (("compile-file-pathname") COMPILE-FILE-PATHNAME) (("compile-file") COMPILE-FILE) (("compiler-macro") COMPILER-MACRO-FUNCTION) (("compiler-pass2") COMPILE) (("concatenate") CONCATENATE) (("copy-seq") COPY-SEQ) (("copy-symbol") COPY-SYMBOL) (("count") COUNT COUNT-IF COUNT-IF-NOT) (("debug") INVOKE-DEBUGGER BREAK) (("delete-duplicates") DELETE-DUPLICATES) (("delete") DELETE DELETE-IF DELETE-IF-NOT) (("deposit-field") DEPOSIT-FIELD) (("describe") DESCRIBE) (("directory") DIRECTORY) (("disassemble") DISASSEMBLE) (("documentation") DOCUMENTATION) (("dribble") DRIBBLE) (("ed") ED) (("enough-namestring") ENOUGH-NAMESTRING) (("ensure-directories-exist") ENSURE-DIRECTORIES-EXIST) (("fill") FILL) (("find-all-symbols") FIND-ALL-SYMBOLS) (("find") POSITION POSITION-IF POSITION-IF-NOT FIND FIND-IF FIND-IF-NOT) (("format") FORMAT) (("gentemp") GENTEMP) (("inspect") INSPECT) (("lcm") LCM) (("ldb") BYTE BYTE-SIZE BYTE-POSITION LDB LDB-TEST DPB) (("ldiff") LDIFF) (("list-length") LIST-LENGTH) (("list") FIFTH SIXTH SEVENTH EIGHTH NINTH TENTH MAKE-LIST COMPLEMENT CONSTANTLY MEMBER) (("load") LOAD) (("make-hash-table") MAKE-HASH-TABLE) (("make-load-form-saving-slots") MAKE-LOAD-FORM-SAVING-SLOTS) (("make-sequence") MAKE-SEQUENCE) (("make-string-output-stream") MAKE-STRING-OUTPUT-STREAM) (("make-string") MAKE-STRING) (("map-into") MAP-INTO) (("map") MAP) (("map1") MAPCAN MAPL MAPLIST MAPCON) (("mask-field") MASK-FIELD) (("member-if") MEMBER-IF MEMBER-IF-NOT) (("mismatch") BAD-SEQ-LIMIT THE-END THE-START CALL-TEST TEST-ERROR MISMATCH) (("nsubstitute") NSUBSTITUTE NSUBSTITUTE-IF NSUBSTITUTE-IF-NOT) (("numbers") SIGNUM ROUND FFLOOR FCEILING FROUND RATIONALIZE GCD ISQRT FLOAT-PRECISION DECODE-FLOAT CONJUGATE PHASE) (("open") OPEN) (("package") MAKE-PACKAGE IMPORT DELETE-PACKAGE) (("parse-integer") PARSE-INTEGER) (("pathnames") PATHNAME-HOST PATHNAME-DEVICE PATHNAME-DIRECTORY PATHNAME-NAME PATHNAME-TYPE WILD-PATHNAME-P PATHNAME-MATCH-P TRANSLATE-PATHNAME LOGICAL-PATHNAME-TRANSLATIONS TRANSLATE-LOGICAL-PATHNAME LOAD-LOGICAL-PATHNAME-TRANSLATIONS LOGICAL-PATHNAME PARSE-NAMESTRING) (("pprint-dispatch") COPY-PPRINT-DISPATCH SET-PPRINT-DISPATCH PPRINT-DISPATCH) (("pprint") WRITE PRINT PRIN1 PRINC PPRINT WRITE-TO-STRING PRIN1-TO-STRING PRINC-TO-STRING WRITE-CHAR WRITE-STRING WRITE-LINE TERPRI FRESH-LINE FINISH-OUTPUT FORCE-OUTPUT CLEAR-OUTPUT PPRINT-NEWLINE PPRINT-INDENT PPRINT-TAB PPRINT-LINEAR PPRINT-FILL PPRINT-TABULAR) (("proclaim") PROCLAIM) (("query") Y-OR-N-P YES-OR-NO-P) (("read-from-string") READ-FROM-STRING) (("read-sequence") READ-SEQUENCE) (("reduce") REDUCE) (("remove-duplicates") REMOVE-DUPLICATES) (("remove") REMOVE REMOVE-IF REMOVE-IF-NOT) (("replace") REPLACE) (("revappend") REVAPPEND) (("search") SEARCH) (("setf") GET-SETF-EXPANSION) (("sets") UNION NUNION INTERSECTION NINTERSECTION SET-DIFFERENCE NSET-DIFFERENCE SET-EXCLUSIVE-OR NSET-EXCLUSIVE-OR SUBSETP) (("sort") MERGE SORT STABLE-SORT) (("strings") STRING-UPCASE STRING-DOWNCASE STRING-CAPITALIZE NSTRING-UPCASE NSTRING-DOWNCASE NSTRING-CAPITALIZE STRING= STRING/= STRING-EQUAL STRING-NOT-EQUAL STRING< STRING> STRING<= STRING>= STRING-LESSP STRING-GREATERP STRING-NOT-LESSP STRING-NOT-GREATERP STRING-LEFT-TRIM STRING-RIGHT-TRIM STRING-TRIM) (("sublis") SUBLIS NSUBLIS) (("subst") SUBST SUBST-IF SUBST-IF-NOT NSUBST NSUBST-IF NSUBST-IF-NOT) (("substitute") LIST-SUBSTITUTE* VECTOR-SUBSTITUTE* SUBSTITUTE SUBSTITUTE-IF SUBSTITUTE-IF-NOT) (("subtypep") SUBTYPEP) (("tailp") TAILP) (("time") DECODE-UNIVERSAL-TIME GET-DECODED-TIME ENCODE-UNIVERSAL-TIME) (("tree-equal") TREE-EQUAL) (("typep") TYPEP) (("upgraded-complex-part-type") UPGRADED-COMPLEX-PART-TYPE) (("write-sequence") WRITE-SEQUENCE)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :CL)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("and") AND) (("assert") ASSERT) (("case") CASE CCASE ECASE TYPECASE CTYPECASE ETYPECASE) (("check-type") CHECK-TYPE) (("clos") DEFINE-METHOD-COMBINATION DEFGENERIC DEFMETHOD DEFCLASS DEFINE-CONDITION) (("compiler-macro") DEFINE-COMPILER-MACRO) (("compiler-pass2") WITH-COMPILATION-UNIT) (("cond") COND) (("count") VECTOR-COUNT-IF LIST-COUNT-IF) (("define-modify-macro") DEFINE-MODIFY-MACRO) (("define-symbol-macro") DEFINE-SYMBOL-MACRO) (("defmacro") DEFMACRO) (("defpackage") DEFPACKAGE) (("defstruct") DEFSTRUCT) (("deftype") DEFTYPE) (("destructuring-bind") DESTRUCTURING-BIND) (("do-all-symbols") DO-ALL-SYMBOLS) (("do-external-symbols") DO-EXTERNAL-SYMBOLS) (("do-symbols") DO-SYMBOLS) (("do") DO DO*) (("dolist") DOLIST) (("dotimes") DOTIMES) (("error") IGNORE-ERRORS) (("format") FORMATTER) (("late-setf") DEFINE-SETF-EXPANDER) (("loop") LOOP LOOP-FINISH) (("mismatch") WITH-START-END) (("multiple-value-bind") MULTIPLE-VALUE-BIND) (("multiple-value-list") MULTIPLE-VALUE-LIST) (("multiple-value-setq") MULTIPLE-VALUE-SETQ) (("nth-value") NTH-VALUE) (("or") OR) (("pprint") PPRINT-LOGICAL-BLOCK) (("print-unreadable-object") PRINT-UNREADABLE-OBJECT) (("proclaim") DECLAIM) (("prog") PROG PROG*) (("psetf") PSETF) (("remf") REMF) (("rotatef") ROTATEF) (("setf") SETF) (("shiftf") SHIFTF) (("step") STEP) (("sublis") NSUBLIS-MACRO) (("substitute") REAL-COUNT SUBST-DISPATCH) (("trace") TRACE UNTRACE) (("with-accessors") WITH-ACCESSORS) (("with-hash-table-iterator") WITH-HASH-TABLE-ITERATOR) (("with-input-from-string") WITH-INPUT-FROM-STRING) (("with-open-file") WITH-OPEN-FILE) (("with-output-to-string") WITH-OUTPUT-TO-STRING) (("with-package-iterator") WITH-PACKAGE-ITERATOR) (("with-slots") WITH-SLOTS) (("with-standard-io-syntax") WITH-STANDARD-IO-SYNTAX)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD-MACRO) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :CL)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("arrays") AREF BIT SBIT) (("compiler-macro") COMPILER-MACRO-FUNCTION) (("documentation") DOCUMENTATION) (("late-setf") MACRO-FUNCTION)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD-SETF-FUNCTION) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; (IN-PACKAGE :CL)
     [java] ; (DOLIST (SYSTEM::FS (QUOTE ((("late-setf") VALUES GETF APPLY THE) (("ldb") LDB) (("mask-field") MASK-FIELD)))) (FUNCALL (FUNCTION EXTENSIONS:AUTOLOAD-SETF-EXPANDER) (CDR SYSTEM::FS) (CAR (CAR SYSTEM::FS))))
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/autoloads-gen.abcl (0.701 seconds)
     [java] ; Compiling /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/src/org/armedbear/lisp/autoloads.lisp ...
     [java] ; (IN-PACKAGE "SYSTEM")
     [java] ; (AUTOLOAD (QUOTE SIMPLE-FORMAT) "format")
     [java] ; Wrote /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/autoloads.abcl (0.04 seconds)
     [java]
     [java] ; Compilation unit finished
     [java] ;   Caught 6 STYLE-WARNING conditions
     [java] ;   The following functions were used but not defined:
     [java] ;     SYSTEM::SOURCE
     [java]
     [java] 391.513 seconds real time
     [java] 246298618 cons cells
     [java] ;COMMON-LISP:FILL triggers autoloading of fill ...
     [java] ; Autoloaded fill (0.008 seconds)
     [java] ;COMMON-LISP:REPLACE triggers autoloading of replace ...
     [java] ; Autoloaded replace (0.012 seconds)
     [java] Java Result: 255
     [echo]  concat "/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes/org/armedbear/lisp/system.lisp
     [echo]                     /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/startup.lisp
     [echo]  Done with abcl.compile.lisp

abcl.compile:
     [echo] Compiled ABCL with Java version: 1.8.0_222

abcl.version.src.0:

abcl.version.src.1:

abcl.version.src.2:

abcl.version.src.3:

abcl.version.src:

abcl.stamp.version.uptodate:

abcl.stamp.version.generate:

abcl.stamp.version.0:

abcl.stamp.version.1:

abcl.stamp.version.2:

abcl.stamp.version:
     [echo] ABCL implementation version: 1.6.0-uabcl

abcl.stamp.hostname:
     [echo] abcl.hostname: gitlab

abcl.stamp:

abcl.jar.uptodate:

abcl.contrib:
      [jar] Building jar: /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl-contrib.jar
     [echo]
     [echo] Packaged contribs in /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl-contrib.jar. To use contribs, ensure that
     [echo] this file is in the same directory as 'abcl.jar', and then
     [echo]
     [echo]   CL-USER> (require 'abcl-contrib)
     [echo]
     [echo] will place all the contribs in the ASDF registry.
     [echo]
     [echo] To load a contrib, something like
     [echo]
     [echo]   CL-USER> (require 'jss)
     [echo]
     [echo] will compile (if necessary) and load JSS.

abcl-contrib.jar:

abcl.jar:
      [jar] Building jar: /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl.jar

abcl.wrapper.unix:

abcl.wrapper.windows:

abcl.wrapper:
     [copy] Copying 1 file to /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform
     [echo] Created executable ABCL wrapper in 'abcl'
     [echo] N.B. This wrapper requires '/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl.jar' not be moved.
[INFO] Executed tasks
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  11:46 min
[INFO] Finished at: 2019-09-26T16:51:56-07:00
[INFO] ------------------------------------------------------------------------
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform#
````

````
root@gitlab:/opt/CYC_JRTL_with_CommonLisp/platform# ./abclc --rcyc
############################################################################
############################################################################
############################ LarKC BEGIN ###################################
############################################################################
############################################################################
BASEDIR=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform

;;; toplevel:  ./abclc --rcyc

export LARKC_HOME=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform
export JARPREFIX=./lib/
export SWI_HOME=/usr/lib/swi-prolog
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
export LD_PRELOAD=/usr/lib/swi-prolog/lib/x86_64-linux/libswipl.so
export OLD_LD_LIBRARY_PATH=/usr/lib/guile/2.2/extensions
export LD_LIBRARY_PATH=/usr/lib/swi-prolog/lib/x86_64-linux:/usr/lib/jvm/java-8-openjdk-amd64/lib:/usr/lib/swi-prolog/lib/x86_64-linux:/usr/lib/guile/2.2/extensions:.
export CATALINA_HOME=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform
export OLD_CLASSPATH=
export CLASSPATH=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar
export JAVA_OPTS=-XX:+AggressiveOpts -XX:CompileThreshold=10 -Xmx8000m -XX:ReservedCodeCacheSize=1024m -XX:MinHeapFreeRatio=5 -XX:+FailOverToOldVerifier -Xss=256m
export JAVA_OPTS1=-agentlib:jdwp=transport=dt_socket,server=n,address=10.0.0.122:5005,suspend=n
export JAVA_OPTS2=-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=y
export LCD=/opt/CYC_JRTL_with_CommonLisp/platform
export ARGV=--rcyc
export ANT_OPTS=-d64 -XX:+UseG1GC -XshowSettings:vm -Xms4096m -Xmx8g -Xss512m   -XX:+CMSClassUnloadingEnabled -XX:+AggressiveOpts -XX:CompileThreshold=10       -XX:ReservedCodeCacheSize=1024m -XX:MinHeapFreeRatio=5 -XX:+FailOverToOldVerifier

;;; Run... ;;;;

  java -cp /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar \
    -server \
    -d64 \
    -XX:+UseG1GC \
    -XshowSettings:vm \
    -Xms4096m \
    -Xmx8g \
    -Xss512m \
    -XX:+CMSClassUnloadingEnabled \
    -XX:+AggressiveOpts \
    -XX:CompileThreshold=10 \
    -XX:ReservedCodeCacheSize=1024m \
    -XX:MinHeapFreeRatio=5 \
    -XX:+FailOverToOldVerifier \
    -Djava.library.path=/usr/lib/swi-prolog/lib/x86_64-linux:/usr/lib/jvm/java-8-openjdk-amd64/lib:/usr/lib/swi-prolog/lib/x86_64-linux:/usr/lib/guile/2.2/extensions:. \
    -Dfile.lcd="/opt/CYC_JRTL_with_CommonLisp/platform" \
    -Duser.home="/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/" \
    -Dplatform.dir="/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform" \
    -Dlisp.jargv="--rcyc" \
    -Dold.claspath="" \
    -Dswi.home="/usr/lib/swi-prolog" \
    -XshowSettings:vm \
    org.armedbear.lisp.Main \
                       \
    --rcyc

;;; Now... ;;;;

Listening for transport dt_socket at address: 5005
Exists /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/units/7166/unrepresented-terms.cfasl
Exists /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/data/caches/7166/generic-singular-nl-generation-fort-cache.fht
Exists /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/data/scg-repo-v2/service.properties
Exists /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/webapps/apps/webapp-manifest.xml
Exists /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/httpd/htdocs/javascript/similarity.js
addDefaultJarsToClassPath from /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform
java.system.class.loader=null
addJar: Adding file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/hamcrest-all-1.3.jar to sun.misc.Launcher$AppClassLoader@18b4aac2
addJar: Adding file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/junit-4.12.jar to sun.misc.Launcher$AppClassLoader@18b4aac2
addJar: Adding file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/dist/abcl-contrib.jar to sun.misc.Launcher$AppClassLoader@18b4aac2
AddCode: Adding file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/all-deps/ to sun.misc.Launcher$AppClassLoader@18b4aac2
addJar: Adding file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/data/parsers/stanford-ner-cyc-2006-09-18/stanford-ner.jar to sun.misc.Launcher$AppClassLoader@18b4aac2
CLASSPATH=/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/target/classes:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar
Armed Bear Common Lisp 1.6.0-uabcl (built Thu Sep 26 2019 16:44:10 PDT)
Java 1.8.0_222 Private Build
OpenJDK 64-Bit Server VM
Low-level initialization used 0.032 seconds.
Startup completed in 9.894 seconds.
Low-level initialization completed in 15.711 seconds.

((USER-HOMEDIR-PATHNAME) => #P"/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/")
(*SITE-LISP* => #P"/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/") Warn: NOT redefining COMMON-LISP:* #<Primitive.pf_multiply * "&rest numbers" {F3021CB}> with #<SubLCompiledFunction * SubLSystemTrampolineFile.Numbers::multiply(&REST REST-LIST) {27ACE0B1}>
Warn: Defining {dynamic special built-in-function CL:* -pf_multiply- ====> CL:NIL} not using {dynamic special built-in-function CL:* -pf_multiply- ====> CL:NIL}

"called init-cycl" syncedTypes.add("SHOP-.*");
syncedTypes.add("TRANSFORMATION-.*");


(d)

(add-kb-class "SHOP-.*")
(add-kb-class "TRANSFORMATION.*")


(trace shop:find-plans)

(time (fiveam:run-all-tests))



(PROGN (QUICKLISP-CLIENT:QUICKLOAD "shop3")
       (QUICKLISP-CLIENT:QUICKLOAD "fiveam")
       (QUICKLISP-CLIENT:QUICKLOAD "pddl-utils")
       (QUICKLISP-CLIENT:QUICKLOAD "openstacks-problem-translator")
       (QUICKLISP-CLIENT:QUICKLOAD "shop3-thmpr-api")
       (QUICKLISP-CLIENT:QUICKLOAD "shop3/test"))
(:QUICKLISP :MAIN-RCYC :CYC-LARKC :CYC-OOPS :USE-CYC
 :ASDF-PACKAGE-SYSTEM :ASDF3.1 :ASDF3 :ASDF2 :ASDF :OS-UNIX
 :ASDF-UNICODE :UABCL :X86-64 :JAVA-1.8 :UNIX :LINUX :ARMEDBEAR :ABCL
Failed to load /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/slime/site-init.lisp
Failed to load /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.swank.lisp
 :COMMON-LISP :ANSI-CL :CDR6 :MOP :PACKAGE-LOCAL-NICKNAMES :SL2JAVA)
;; Swank started at port: 4005.

(:SWANK :QUICKLISP :MAIN-RCYC :CYC-LARKC :CYC-OOPS :USE-CYC
 :ASDF-PACKAGE-SYSTEM :ASDF3.1 :ASDF3 :ASDF2 :ASDF :OS-UNIX
 :ASDF-UNICODE :UABCL :X86-64 :JAVA-1.8 :UNIX :LINUX :ARMEDBEAR :ABCL
 :COMMON-LISP :ANSI-CL :CDR6 :MOP :PACKAGE-LOCAL-NICKNAMES :SL2JAVA) ;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp-backend.abcl ...
STYLE-WARNING: redefining FUNCTION-NAME in #P"/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/cusp/cusp-backend.lisp" (previously defined in #P"/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/slime/swank/backend.lisp")
;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp-backend.abcl (1.933 seconds)
;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp-abcl.abcl ...
;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp-abcl.abcl (0.138 seconds)
;   Loading /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp.abcl ...
;   Loaded /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.slime/fasl/2009-10-10/armedbear-1.6.0-uabcl-linux-x86-64/cusp.abcl (0.837 seconds)
WARNING: These CUSP interfaces are unimplemented:
 (ACTIVATE-STEPPING ADD-FD-HANDLER ADD-SIGIO-HANDLER
  DISASSEMBLE-FRAME EVAL-IN-FRAME FIND-SOURCE-LOCATION
  FRAME-VAR-VALUE LIST-CALLEES LIST-CALLERS PROFILE PROFILE-PACKAGE
  PROFILE-REPORT PROFILE-RESET PROFILED-FUNCTIONS REMOVE-FD-HANDLERS
  REMOVE-SIGIO-HANDLERS RESTART-FRAME RETURN-FROM-FRAME SAVE-IMAGE
  SLDB-BREAK-AT-START SLDB-BREAK-ON-RETURN SLDB-STEP-INTO
  SLDB-STEP-NEXT SLDB-STEP-OUT TOGGLE-TRACE UNPROFILE)
Failed to load /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/cusp/site-init.lisp
Failed to load /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/site-lisp/.cusp.lisp
;; CUSP started at port: 3005.

(:SWANK :QUICKLISP :MAIN-RCYC :CYC-LARKC :CYC-OOPS :USE-CYC
 :ASDF-PACKAGE-SYSTEM :ASDF3.1 :ASDF3 :ASDF2 :ASDF :OS-UNIX
 :ASDF-UNICODE :UABCL :X86-64 :JAVA-1.8 :UNIX :LINUX :ARMEDBEAR :ABCL
Found: file:/mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/lib/all-deps/org/objectweb/asm/MethodVisitor.class
interface org.objectweb.asm.MethodVisitor
 Loading implementation classes ...
 ......... 10% ......... 20% ......... 30% ......... 40% ......... 50%
 ......... 60% ......... 70% ......... 80% ......... 90% ......... 100%
 Done.
Low memory situations will be triggered when post-gc usage exceeds 7372MB(90% of 8192MB) for Heap memory pool G1 Old Gen
CollectionUsageThresholdSupported Total memory allocated to VM: 4096MB.
CollectionUsageThresholdSupported Memory currently available: 3765MB.
CollectionUsageThresholdSupported Memory currently used: 330MB.
ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console...
;;; loading init/jrtl-release-init.lisp ...
;;; CYC(1): (IN-PACKAGE "CYC")
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): (CVS-ID "$Id: jrtl-release-init.lisp 129137 2009-11-05 03:40:25Z rck $")
;;; Result(2)  <==== CL:NIL
;;; CYC(3): (CSETQ *MASTER-LICENSE-KEY* "d928-2826-1787-5fe9-6d31")
;;; Result(3)  <==== d928-2826-1787-5fe9-6d31
;;; CYC(4): (PWHEN-FEATURE :CYC-RESEARCHCYC (PWHEN-FEATURE :SL2JAVA (CSETQ *MASTER-LICENSE-KEY* "d928-2826-1787-5fe9-6d31")))
;;; Result(4)  <==== d928-2826-1787-5fe9-6d31
;;; CYC(5): (PROGN (CSETQ *STANFORD-NER-HOST* "localhost") (CSETQ *STANFORD-NER-PORT* 6666) (PIF (FBOUNDP (QUOTE START-NER-SERVER)) (START-NER-SERVER *STANFORD-NER-PORT*) (CUNWIND-PROTECT (FORMAT T "Starting Named Entity Recognizer.~%") (RUN-EXTERNAL-PROCESS "java" (BQ-LIST "-server" "-Xmx1024m" "-XX:MaxPermSize=512m" "-cp" "data/parsers/stanford-ner-cyc-2006-09-18/stanford-ner.jar" "edu.stanford.nlp.ie.NERServer" "-loadClassifier" "data/parsers/stanford-ner-cyc-2006-09-18/classifiers/ner-eng-ie.crf-7-muc-distsim.ser.gz" (TO-STRING *STANFORD-NER-PORT*)) *NULL-INPUT* *NULL-OUTPUT* *ERROR-OUTPUT*) (SLEEP 20) (PROGN))))
;;; Result(5)  <==== CL:NIL
;;; CYC(6): (LOAD "init/jrtl-init.lisp")
;;; loading init/jrtl-init.lisp ...
;;; CYC(1): (IN-PACKAGE "CYC")
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): (CVS-ID "$Id: jrtl-init.lisp 132325 2010-09-28 16:53:34Z rck $")
;;; Result(2)  <==== CL:NIL
;;; CYC(3): (LOAD-SYSTEM-PARAMETERS)
;;; Result(3)  <==== CL:NIL
;;; CYC(4): (SYSTEM-CODE-INITIALIZATIONS)
 :COMMON-LISP :ANSI-CL :CDR6 :MOP :PACKAGE-LOCAL-NICKNAMES :SL2JAVA) Initializing Cyc 10.152303 (ResearchCyc (custom))
Warning: No KB is loaded.  System KB initializations will not be run.
;;; Result(4)  <==== CL:T
;;; CYC(5): (QUOTE (CLET ((UNITS-DIRECTORY "units/0988/")) (PIF (FBOUNDP (QUOTE CYC-LOAD-KB)) (CYC-LOAD-KB UNITS-DIRECTORY) (PROGN (LOAD-KB UNITS-DIRECTORY) (SYSTEM-CODE-INITIALIZATIONS)))))
;;; Result(5)  <==== (CLET ((UNITS-DIRECTORY "units/0988/")) (PIF (FBOUNDP (QUOTE CYC-LOAD-KB)) (CYC-LOAD-KB UNITS-DIRECTORY) (PROGN (LOAD-KB UNITS-DIRECTORY) (SYSTEM-CODE-INITIALIZATIONS))))
;;; CYC(6): (CLET ((UNITS-DIRECTORY "units/7166/")) (PIF (FBOUNDP (QUOTE CYC-LOAD-KB)) (CYC-LOAD-KB UNITS-DIRECTORY) (PROGN (LOAD-KB UNITS-DIRECTORY) (SYSTEM-CODE-INITIALIZATIONS))))


;;; Loading KB from units/7166/ at 09/26/2019 18:47:41
Loading special objects ... DONE (0:00)
Initializing HL backing store caches from units/7166/.

;;; Loading essential KB at 09/26/2019 18:47:41
Loading classifier from /mnt/gggg/opt/CYC_JRTL_with_CommonLisp/platform/data/parsers/stanford-ner-cyc-2006-09-18/classifiers/ner-eng-ie.crf-7-muc-distsim.ser.gz ... Freeing clause-strucs ... DONE (0:00)
Freeing KB HL supports ... DONE (0:00)
Freeing deductions ... DONE (0:00)
Freeing assertions ... DONE (0:00)
Freeing NARTs ... DONE (0:00)
Freeing constants ... DONE (0:00)
Determining maximum unrepresented-term SUID ... DONE (0:00)
Loading constant shellsdone [4.4 sec].

 [.. 10% 20% 30% 40% 50% 60% 70% 80% 90% DONE (0:08) ]
Enabling lazy assertion handle support ... DONE (0:00)
Enabling lazy KB HL support handle support ... DONE (0:00)
Loading clause-struc definitions
 [ 30% DONE (0:03) ]
Deduction definitions will be swapped in lazily from
   units/7166/deduction.cfasl
   units/7166/deduction-index.cfasl
Determining deduction max ID from index entries ... DONE (0:00)
Enabling lazy deduction handle support ... DONE (0:00)
Assertion definitions will be swapped in lazily from:
   units/7166/assertion.cfasl
   units/7166/assertion-index.cfasl
KB HL supports will be swapped in lazily from:
   units/7166/kb-hl-support.cfasl
   units/7166/kb-hl-support-index.cfasl
Loading bookkeeping assertions ... DONE (0:01)
Loading rule utility experience ... DONE (0:00)

;;; Loading computable KB at 09/26/2019 18:47:58
Loading KB unrepresented terms
 [ DONE (0:03) ]
Constant indexing will be swapped in lazily from:
   units/7166/indices.cfasl
   units/7166/indices-index.cfasl
Constant complex indexing will be swapped in lazily from:
   units/7166/constant-complex-indices.cfasl
   units/7166/constant-complex-indices-index.cfasl
NART indexing will be swapped in lazily from:
   units/7166/nat-indices.cfasl
   units/7166/nat-indices-index.cfasl
NART complex indexing will be swapped in lazily from:
   units/7166/nat-complex-indices.cfasl
   units/7166/nat-complex-indices-index.cfasl
Unrepresented term indexing will be swapped in lazily from:
   units/7166/unrepresented-term-indices.cfasl
   units/7166/unrepresented-term-indices-index.cfasl
Unrepresented complex term indexing will be swapped in lazily from:
   units/7166/unrepresented-term-complex-indices.cfasl
   units/7166/unrepresented-term-complex-indices-index.cfasl
Loading assertion indices ... DONE (0:00)
Loading auxiliary indices ... DONE (0:00)
Loading bookkeeping indices ... DONE (0:01)
Loading KB HL support indexing ... DONE (0:05)
Loading rule set ... DONE (0:00)
Loading non-true assertion tv cache ... DONE (0:00)

;;; Loading computable remaining HL at 09/26/2019 18:48:10
NART HL formulas will be swapped in lazily from:
   units/7166/nart-hl-formula.cfasl
   units/7166/nart-hl-formula-index.cfasl
Loading miscellaneous stuff ... DONE (0:00)
Loading SBHL graphs ... DONE (0:02)
Loading SBHL time state ... DONE (0:03)
Loading SBHL cache ... DONE (0:02)
Loading cardinality estimates ... DONE (0:01)
Loading arg-type cache ... DONE (0:00)
Loading defns cache ... DONE (0:00)
Loading somewhere cache ... DONE (0:01)
Loading arity cache ... DONE (0:00)
Loading TVA cache ... DONE (0:01)
Loading reformulator rules ... DONE (0:00)
Loading lexicon cache ... DONE (0:02)
Loading RTP rules cache ... DONE (0:00)
Initializing minor paraphrase CycL structures ... DONE (0:00)
Loading pph-phrase shells ... DONE (0:01)
Loading pph-phrase definitions
 [ 20% 30% 40% 50% 60% 80% DONE (0:06) ]
Loading #$genTemplate store ... DONE (0:01)
Loading English units of measure ... DONE (0:00)

;;; Performing KB initializations at 09/26/2019 18:48:33
Computing bogus constant names in code ... DONE (0:00)
Initializing some equality assertions somewhere ... DONE (0:03)
Initializing #$interArgIsa cache
 [ 20% 40% 60% DONE (0:02) ]
Initializing #$interArgFormat cache ... DONE (0:00)
Initializing old constant name table ... DONE (0:04)
Initializing KB variables ... DONE (0:01)

;;; Rebuilding computable-but-not-dumpable-yet-KB at 09/26/2019 18:48:52
Swapping out assertion objects ... DONE (0:00)
Swapping out deduction objects ... DONE (0:00)
Swapping out constant-index objects ... DONE (0:00)
Swapping out nart-index objects ... DONE (0:00)
Swapping out nart-hl-formula objects ... DONE (0:00)
Swapping out unrepresented-term-index objects ... DONE (0:00)
Swapping out kb-hl-support objects ... DONE (0:00)
Enforcing SBHL caching policies ... DONE (0:05)

;;; Load of KB 7166 completed (1:18) at 09/26/2019 18:48:59

;;; KB 7166 statistics
FORTs                   :    638756
 Constants              :    336790
  cached indexing       :         0  (0%)
 NARTs                  :    301966
  cached indexing       :         0  (0%)
  cached HL formulas    :         0  (0%)
Assertions              :   9042563
 KB Assertions          :   8469860
  cached                :         0  (0%)
 Bookkeeping Assertions :    572703
Deductions              :  11218595
  cached                :         0  (0%)
KB HL supports          :   1348309
  cached                :         0  (0%)
Unrepresented terms     :   1100717
  cached indexing       :         0  (0%)
;;; Result(6)  <==== 7166
;;; CYC(7): (PWHEN (FBOUNDP (QUOTE CL-IMPORTS-CYC)) (CL-IMPORTS-CYC))
;;; Result(7)  <==== CL:NIL
;;; CYC(8): (PWHEN (FBOUNDP (QUOTE CYC-IMPORTS-CL)) (CYC-IMPORTS-CL))
;; in pkg CYC Local Symbol CYC:FINALIZE will trump {built-in-function EXT:FINALIZE -pf_finalize-}.
;; in pkg CYC Local Symbol CYC:SOURCE will trump {built-in-function EXT:SOURCE -source-}.
;; in pkg CYC Local Symbol CYC:COLLECT will trump {EXT:COLLECT -MacroObject-}.
;; in pkg CYC Local Symbol CYC:MAILBOX will trump EXT:MAILBOX.
;; in pkg CYC Local Symbol CYC:MERGE will trump {CL:MERGE -sort_12-}.
;; in pkg CYC Local Symbol {CYC:NUMERATOR -SubLCompiledFunction-} will trump {built-in-function CL:NUMERATOR -pf_numerator-}.
;; in pkg CYC Local Symbol CYC:CONTINUE will trump {CL:CONTINUE -restart_60-}.
;; in pkg CYC Local Symbol CYC:DO will trump {CL:DO -sf_do-}.
;; in pkg CYC Local Symbol CYC:ABORT will trump {CL:ABORT -restart_58-}.
;; in pkg CYC Local Symbol CYC:PPRINT will trump {CL:PPRINT -pprint_155-}.
;; in pkg CYC Local Symbol CYC:MAP will trump {CL:MAP -map_1-}.
;; in pkg CYC Local Symbol {CYC:FIND-IF-NOT -SubLCompiledFunction-} will trump {CL:FIND-IF-NOT -find_34-}.
;; in pkg CYC Local Symbol {CYC:VALUES-LIST -SubLCompiledFunction-} will trump {built-in-function CL:VALUES-LIST -pf_values_list-}.
;; in pkg CYC Local Symbol CYC:CLASS will trump CL:CLASS.
;; in pkg CYC Local Symbol {CYC:GCD -SubLCompiledFunction-} will trump {CL:GCD -Autoload-}.
;; in pkg CYC Local Symbol {CYC:TIME -SubLMacro-} will trump {CL:TIME -MacroObject-}.
;; in pkg CYC Local Symbol CYC:SLOT-VALUE will trump {CL:SLOT-VALUE -clos_92-}.
;; in pkg CYC Local Symbol CYC:WHEN will trump {CL:WHEN -sf_when-}.
;; in pkg CYC Local Symbol CYC:METHOD will trump CL:METHOD.
;; in pkg CYC Local Symbol CYC:ADD-METHOD will trump {CL:ADD-METHOD -FuncallableStandardObject-}.
;; in pkg CYC Local Symbol {CYC:ENSURE-DIRECTORIES-EXIST -SubLCompiledFunction-} will trump {CL:ENSURE-DIRECTORIES-EXIST -ensure_directories_exist_1-}.
;; in pkg CYC Local Symbol CYC:THE will trump {CL:THE -sf_the-}.
;; in pkg CYC Local Symbol {CYC:DENOMINATOR -SubLCompiledFunction-} will trump {built-in-function CL:DENOMINATOR -pf_denominator-}.
;; in pkg CYC Local Symbol CYC:PATHNAME will trump {built-in-function CL:PATHNAME -pf_pathname-}.
;; in pkg CYC Local Symbol CYC:UNTRACE will trump {CL:UNTRACE -AutoloadMacro-}.
;; in pkg CYC Local Symbol CYC:SOME will trump {CL:SOME -early_defuns_21-}.
;; in pkg CYC Local Symbol CYC:ASSERT will trump {CL:ASSERT -AutoloadMacro-}.
;; in pkg CYC Local Symbol CYC:CLASS-OF will trump {built-in-function CL:CLASS-OF -pf_class_of-}.
;; in pkg CYC Local Symbol {CYC:LCM -SubLCompiledFunction-} will trump {CL:LCM -Autoload-}.
;; in pkg CYC Local Symbol CYC:PHASE will trump {CL:PHASE -Autoload-}.
;; in pkg CYC Local Symbol CYC:TRACE will trump {CL:TRACE -AutoloadMacro-}.
;; in pkg CYC Local Symbol CYC:POP will trump {CL:POP -MacroObject-}.
;; in pkg CYC Local Symbol CYC:COMPLEMENT will trump {CL:COMPLEMENT -list_9-}.
;; in pkg CYC Local Symbol CYC:LABELS will trump {CL:LABELS -sf_labels-}.
;; in pkg CYC Local Symbol CYC:STEP will trump {CL:STEP -AutoloadMacro-}.
;; in pkg CYC Local Symbol CYC:COND will trump {CL:COND -sf_cond-}.
;; in pkg CYC Local Symbol CYC:PUSH will trump {CL:PUSH -MacroObject-}.
;; in pkg CYC Local Symbol CYC:BLOCK will trump {CL:BLOCK -sf_block-}.
;;; Result(8)  <==== CL:NIL
;;; CYC(9): :EOF
;;; ... init/jrtl-init.lisp loaded; SHA-1: 32dc24b5e24e9c0e2a593964f7fd033a71a2a915
;;; Result(6)  <==== CL:T
;;; CYC(7): (LOAD "init/release-specific-init.lisp")
;;; loading init/release-specific-init.lisp ...
;;; CYC(1): (IN-PACKAGE :CYC)
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): :EOF
;;; ... init/release-specific-init.lisp loaded; SHA-1: f7a2b3709b0377f49e804e5b7bceb2b712e21f9e
;;; Result(7)  <==== CL:T
;;; CYC(8): :EOF
;;; ... init/jrtl-release-init.lisp loaded; SHA-1: cf74cf49f5797741c766e535601a55de6f7dbe03
;;; loading init/services-init.lisp ...
;;; CYC(1): (IN-PACKAGE "CYC")
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): (CVS-ID "$Id: services-init.lisp 146227 2013-06-26 21:56:23Z tbrussea $")
;;; Result(2)  <==== CL:NIL
;;; CYC(3): (CSETQ *GC-REPORTS* NIL)
;;; Result(3)  <==== CL:NIL
;;; CYC(4): (LOAD "init/cyc-init.lisp")
;;; loading init/cyc-init.lisp ...
;;; CYC(1): (IN-PACKAGE "CYC")
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): (CVS-ID "$Id: cyc-init.lisp 148269 2013-11-09 02:57:49Z goolsbey $")
;;; Result(2)  <==== CL:NIL
;;; CYC(3): (CVS-ID "$Id: cyc-init.lisp 132323 2010-09-28 16:49:56Z rck $")
;;; Result(3)  <==== CL:NIL
;;; CYC(4): (PWHEN (FBOUNDP (QUOTE DEVELOPMENT-INITIALIZATIONS)) (DEVELOPMENT-INITIALIZATIONS))
;;; Result(4)  <==== CL:NIL
;;; CYC(5): (LOAD-SYSTEM-PARAMETERS)
;;; Result(5)  <==== CL:NIL
;;; CYC(6): (SYSTEM-CODE-INITIALIZATIONS)
;;; Result(6)  <==== CL:T
;;; CYC(7): (PWHEN (PROBE-FILE (CYC-HOME-FILENAME NIL "setup/my-cyc-init.lisp")) (LOAD-FROM-CYC-HOME "setup/my-cyc-init.lisp"))
;;; Result(7)  <==== CL:NIL
;;; CYC(8): (QUOTE (PWHEN (PROBE-FILE "setup/my-cyc-init.lisp") (LOAD "setup/my-cyc-init.lisp")))
;;; Result(8)  <==== (PWHEN (PROBE-FILE "setup/my-cyc-init.lisp") (LOAD "setup/my-cyc-init.lisp"))
;;; CYC(9): (CSETQ *INIT-FILE-LOADED?* T)
;;; Result(9)  <==== CL:T
;;; CYC(10): :EOF
;;; ... init/cyc-init.lisp loaded; SHA-1: 605754feab427349db1f959ca1702e6bc5fe3861
;;; Result(4)  <==== CL:T
;;; CYC(5): (LOAD "init/port-init.lisp")
;;; loading init/port-init.lisp ...
;;; CYC(1): (IN-PACKAGE "CYC")
;;; Result(1)  <==== #.(CL:FIND-PACKAGE "CYC")
;;; CYC(2): (CVS-ID "$Id: port-init.lisp 149644 2014-02-24 16:06:53Z daves $")
;;; Result(2)  <==== CL:NIL
;;; CYC(3): (DEFINE ROBUST-ENABLE-TCP-SERVER (TYPE PORT HANDLER) (PIF (FBOUNDP (QUOTE ENABLE-TCP-SERVER)) (RET (ENABLE-TCP-SERVER TYPE PORT)) (RET (START-TCP-SERVER PORT HANDLER NIL))))
;;; Result(3)  <==== {CYC:ROBUST-ENABLE-TCP-SERVER -SubLInterpretedFunction-}
;;; CYC(4): (PUNLESS (BOUNDP (QUOTE *BASE-TCP-PORT*)) (CSETQ *BASE-TCP-PORT* 3600))
;;; Result(4)  <==== CL:NIL
;;; CYC(5): (PROGN (FORMAT T "~&Enabling base TCP services to port ~S.~%" *BASE-TCP-PORT*) (FINISH-OUTPUT))
Initializing Cyc 10.152303 (ResearchCyc (custom))
Initializing HL backing store caches from units/7166/.
Initializing Cyc 10.152303 (ResearchCyc (custom))
Initializing HL backing store caches from units/7166/.
Enabling base TCP services to port 3600.
;;; Result(5)  <==== CL:NIL
;;; CYC(6): (PWHEN (FBOUNDP (QUOTE HTML-SERVER-TOP-LEVEL)) (ROBUST-ENABLE-TCP-SERVER :HTML (HTML-PORT) (QUOTE HTML-SERVER-TOP-LEVEL)))
;;; Result(6)  <==== #<TCP-SERVER 3600/HTML>
;;; CYC(7): (PWHEN (FBOUNDP (QUOTE API-SERVER-TOP-LEVEL)) (ROBUST-ENABLE-TCP-SERVER :CYC-API (API-PORT) (QUOTE API-SERVER-TOP-LEVEL)))
;;; Result(7)  <==== #<TCP-SERVER 3601/CYC-API>
;;; CYC(8): (PWHEN (FBOUNDP (QUOTE CFASL-SERVER-TOP-LEVEL)) (ROBUST-ENABLE-TCP-SERVER :CFASL (CFASL-PORT) (QUOTE CFASL-SERVER-TOP-LEVEL)))
;;; Result(8)  <==== #<TCP-SERVER 3614/CFASL>
;;; CYC(9): (PWHEN (FBOUNDP (QUOTE HTTP-SERVER-TOP-LEVEL)) (PWHEN (ROBUST-ENABLE-TCP-SERVER :HTTP (HTTP-PORT) (QUOTE HTTP-SERVER-TOP-LEVEL)) (FORMAT T "HTTP server listening on port ~A.  Connect via URL http://~A:~A/cgi-bin/cg?cb-start~%" (HTTP-PORT) (HOSTNAME) (HTTP-PORT))))
;;; Result(9)  <==== CL:NIL
;;; CYC(10): (PWHEN-FEATURE :CYC-THESAURUS (PWHEN *TM-START-TMAP-ON-STARTUP?* (ROBUST-ENABLE-TCP-SERVER :TMAP (TMAP-PORT) (FUNCTION THESAURUS-MANAGER-ACCESS-PROTOCOL-SERVER-TOP-LEVEL))))
;;; Result(10)  <==== CL:NIL
;;; CYC(11): (CSETQ *INFERENCE-TRACE-PORT* (+ *BASE-TCP-PORT* 7))
;;; Result(11)  <==== 3607
;;; CYC(12): (PWHEN (FBOUNDP (QUOTE START-EXTERNAL-SPARQL-PROCESS)) (CLET ((ERR)) (CATCH-ERROR-MESSAGE (ERR) (ROBUST-ENABLE-TCP-SERVER :SPARQL (SPARQL-PORT) (QUOTE START-EXTERNAL-SPARQL-PROCESS))) (PWHEN ERR (WARN "Unable to start SPARQL server: ~%~S" ERR))))
;;; Result(12)  <==== CL:NIL
;;; CYC(13): (PWHEN (FBOUNDP (QUOTE START-SERVLET-CONTAINER)) (ROBUST-ENABLE-TCP-SERVER :SERVLET (SERVLET-CONTAINER-PORT) (QUOTE START-SERVLET-CONTAINER)))
HTTP server listening on port 3602.  Connect via URL http://www.logicmoo.org:3602/cgi-bin/cg?cb-start

SPARQL server started on port 3615.
Jetty server started on port 3603
Handler=o.e.j.w.WebAppContext{/SchemaModelingTool,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/SchemaModelingTool/webapp/},webapps/apps/SchemaModelingTool.war
Handler=o.e.j.w.WebAppContext{/proxy,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/proxy/webapp/},webapps/apps/CycHttpProxy.war
Handler=o.e.j.w.WebAppContext{/cycdoc,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cycdoc/webapp/},webapps/apps/CycHttpProxy.war
Handler=o.e.j.w.WebAppContext{/cgi-bin,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cgi-bin/webapp/},webapps/apps/CycHttpProxy.war
Handler=o.e.j.w.WebAppContext{/a,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/a/webapp/},webapps/apps/CycHttpProxy.war
Handler=o.e.j.w.WebAppContext{/kbmonitor,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/kbmonitor/webapp/},webapps/apps/KBQueryMonitor-0.0.1-SNAPSHOT.war
Handler=o.e.j.w.WebAppContext{/sandbox,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/sandbox/webapp/},webapps/apps/cycAppToolkitSandbox.war
Handler=o.e.j.w.WebAppContext{/cycJS,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cycJS/webapp/},webapps/apps/cycAppToolkitJS.war
Handler=o.e.j.w.WebAppContext{/scg,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/scg/webapp/},webapps/apps/scg.war
Handler=o.e.j.w.WebAppContext{/cure,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cure/webapp/},webapps/apps/ConceptSearch.war
Handler=o.e.j.w.WebAppContext{/,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/webapp/},webapps/apps/KEA.war
WebAppContext=o.e.j.w.WebAppContext{/SchemaModelingTool,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/SchemaModelingTool/webapp/},webapps/apps/SchemaModelingTool.war
WebAppContext=o.e.j.w.WebAppContext{/proxy,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/proxy/webapp/},webapps/apps/CycHttpProxy.war
WebAppContext=o.e.j.w.WebAppContext{/cycdoc,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cycdoc/webapp/},webapps/apps/CycHttpProxy.war
WebAppContext=o.e.j.w.WebAppContext{/cgi-bin,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cgi-bin/webapp/},webapps/apps/CycHttpProxy.war
WebAppContext=o.e.j.w.WebAppContext{/a,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/a/webapp/},webapps/apps/CycHttpProxy.war
WebAppContext=o.e.j.w.WebAppContext{/kbmonitor,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/kbmonitor/webapp/},webapps/apps/KBQueryMonitor-0.0.1-SNAPSHOT.war
WebAppContext=o.e.j.w.WebAppContext{/sandbox,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/sandbox/webapp/},webapps/apps/cycAppToolkitSandbox.war
WebAppContext=o.e.j.w.WebAppContext{/cycJS,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cycJS/webapp/},webapps/apps/cycAppToolkitJS.war
WebAppContext=o.e.j.w.WebAppContext{/scg,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/scg/webapp/},webapps/apps/scg.war
WebAppContext=o.e.j.w.WebAppContext{/cure,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/cure/webapp/},webapps/apps/ConceptSearch.war
WebAppContext=o.e.j.w.WebAppContext{/,file:/tmp/cyc-servlet-container-tmp-dir-root-3600/webapp/},webapps/apps/KEA.war
;;; Result(13)  <==== #<TCP-SERVER 3603/SERVLET>
;;; CYC(14): (PUNLESS-FEATURE :CYC-ALEXANDRIA (START-AGENDA))
;;; Result(14)  <==== CL:T
;;; CYC(15): (FORMAT T "~&Ready for services.~%")
;;; Result(15)  <==== CL:NIL
;;; CYC(16): :EOF
;;; ... init/port-init.lisp loaded; SHA-1: 24ad0071622d957b943a2de6e1c73a4e5369f9dc
;;; Result(5)  <==== CL:T
;;; CYC(6): (BOOLEAN (PRINC ";;  At this point the cyc http server is running and you can access
;;  Cyc directly via the local web browser.
;;  http://localhost:3602/cgi-bin/cyccgi/cg?cb-start
;;  You can browse cyc via the Guest account or perform updates by
;;  logging on as CycAdminstrator.
"))
;;; Result(6)  <==== CL:T
;;; CYC(7): :EOF
;;; ... init/services-init.lisp loaded; SHA-1: 0321b7d6f51903395f85790f82f79c2b1210545a
Ready for services.
;;  At this point the cyc http server is running and you can access
;;  Cyc directly via the local web browser.
;;  http://localhost:3602/cgi-bin/cyccgi/cg?cb-start
;;  You can browse cyc via the Guest account or perform updates by
;;  logging on as CycAdminstrator.

Type ":help" for a list of available commands.
CYC(1): (cyc-repl) ;; since we are in lisp-repl
CYC(1):
`````
