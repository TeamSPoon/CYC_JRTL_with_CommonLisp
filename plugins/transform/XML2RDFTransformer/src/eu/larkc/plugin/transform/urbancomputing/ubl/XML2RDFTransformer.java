/*
 * Copyright (C) 2009-2010 CEFRIEL 
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package eu.larkc.plugin.transform.urbancomputing.ubl;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashSet;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.openrdf.model.Statement;
import org.openrdf.model.URI;
import org.openrdf.model.ValueFactory;
import org.openrdf.model.impl.URIImpl;
import org.openrdf.model.impl.ValueFactoryImpl;
import org.openrdf.rio.RDFHandlerException;
import org.openrdf.rio.RDFParseException;
import org.openrdf.rio.RDFParser;
import org.openrdf.rio.rdfxml.RDFXMLParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.tidy.Tidy;

import eu.larkc.core.data.CloseableIterator;
import eu.larkc.core.data.DataFactory;
import eu.larkc.core.data.InformationSet;
import eu.larkc.core.data.RdfStoreConnection;
import eu.larkc.core.data.SetOfStatements;
//import eu.larkc.core.data.XMLDocument;
import eu.larkc.core.data.iterator.RDFHandlerIterator;
import eu.larkc.core.qos.QoSInformation;
import eu.larkc.plugin.Context;
import eu.larkc.plugin.Contract;
import eu.larkc.plugin.transform.InformationSetTransformer;
import eu.larkc.urbancomputing.LarKCUtilities;


/**
 * This plugin applies an XSL transformation to an XML document to convert it in RDF.
 * Locations of XML document and its transformations are set in a XMLDocument object.
 * 
 * @author Daniele Dell'Aglio
 *
 */
public class XML2RDFTransformer implements InformationSetTransformer {
	private static final Logger logger = LoggerFactory.getLogger(XML2RDFTransformer.class);
	
	public static final URI GRAPH_PROPERTY = new URIImpl("http://larkc.cefriel.it/ontologies/plugin#isPartOfGraph");
	public static final URI XSLT_PROPERTY = new URIImpl("http://larkc.cefriel.it/ontologies/plugin#hasXslt");

	private boolean importConfig = false;
	
	public XML2RDFTransformer() {
	}

	@Override
	public Context createContext() {
		return null;
	}

	@Override
	public void initialise() {
		if(!importConfig){
			DataFactory.INSTANCE.createRdfStoreConnection().removeStatement(null, null, null, this.getIdentifier());
			LarKCUtilities.importRdfGraph(new File("plugins/XML2RDFTransformer/configuration-schema/configuration.rdf"), this.getIdentifier());
			importConfig=true;
		}
	}
	
	@Override
	public void shutdown() {
	}

	public InformationSet transform(InformationSet theInformationSet,
			Contract theContract, Context theContext) {
		if (theInformationSet == null) {
			return null;
		}

		if (theInformationSet instanceof SetOfStatements) {
			SetOfStatements sos = (SetOfStatements)theInformationSet;
			URI graphName = null; 
			
			CloseableIterator<Statement> it = sos.getStatements();
			
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			URL doc = null;
			String xslt = null;

			while(it.hasNext()){
				Statement s = it.next();
				if(s.getPredicate().equals(XSLT_PROPERTY)){
					try{
						doc = new URL(s.getSubject().stringValue());
					}catch (MalformedURLException e) {
						System.err.println("Malformed URL Exception");
						return null;
					}
					xslt = s.getObject().stringValue();
				}
				else if(s.getPredicate().equals(GRAPH_PROPERTY)){
					graphName = new URIImpl(s.getObject().stringValue());
				}
			}
			
			if(doc==null || xslt==null || graphName == null){
				//raise exception
				logger.error("Error! One of the two parameters is missing!");
				return null;
			}
			else{
				logger.debug("Inserting the graph generated by {} via {} in {}", new Object[]{doc, xslt, graphName});
			}
			
			try {
				TransformerFactory tFactory = TransformerFactory.newInstance();
				Transformer transformer;
				transformer = tFactory.newTransformer(new StreamSource(xslt));
				transformer.transform(new StreamSource(doc.openStream()), new StreamResult(baos));

				HashSet<Statement> statements = new HashSet<Statement>();
				DataFactory df = DataFactory.INSTANCE;
				ValueFactory vf = new ValueFactoryImpl();
				RdfStoreConnection con = df.createRdfStoreConnection();
				RDFHandlerIterator iter = new RDFHandlerIterator(graphName);
				RDFParser parser = new RDFXMLParser();
				parser.setValueFactory(vf);
				parser.setRDFHandler(iter);
				parser.parse(new ByteArrayInputStream(baos.toByteArray()), graphName.toString());
				while(iter.hasNext()){
					Statement st = iter.next();
//					System.out.println(st.getSubject() +" "+ st.getPredicate() +" "+ st.getObject()); 
					statements.add(con.addStatement(st.getSubject(), st.getPredicate(), st.getObject(), graphName));
				}
//				System.out.println("Ending XSL transformation!!");
				return df.createRdfGraph(statements, graphName);

			} catch (RDFParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (RDFHandlerException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TransformerConfigurationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TransformerException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return null;
	}

	@Override
	public URI getIdentifier() {
		return new URIImpl("urn:" + this.getClass().getName());
	}

	@Override
	public QoSInformation getQoSInformation() {
		return new QoSInformation() {
		};
	}
}
